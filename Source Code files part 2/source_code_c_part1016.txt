//--
/////////////////////////////////////////////////////////////////////////////
const CString & CTreeItem::StrProfileSection(void)
{
	ASSERT_VALID(Pci());

	if (Pci() != NULL)
	{
		// Set the column section name.  If there is a parent, append our name
		// onto the parent's section name.
		try
		{
			if (PtiParent() == NULL)
			{
				ASSERT_VALID(Pci()->Pdoc());
				m_strProfileSection.Format(
					REGPARAM_CONNECTIONS _T("\\%s\\%s"),
					Pci()->Pdoc()->StrNode(),
					Pci()->StrName()
					);
			}  // if:  item has no parent
			else
			{
				m_strProfileSection.Format(
					_T("%s\\%s"),
					PtiParent()->StrProfileSection(),
					Pci()->StrName()
					);
			}  // else:  item has a parent
		}  // try
		catch (CException * pe)
		{
			// If an error occurs constructing the section name, just ignore it.
			pe->Delete();
		}  // catch:  CException
	}  // if:  valid cluster item and document

	return m_strProfileSection;

}  //*** CTreeItem::StrProfileSection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiAddChildBefore
//
//	Routine Description:
//		Add a child to the item's list of children following the specified
//		item.  Also creates an entry in the list of children list items.
//
//	Arguments:
//		pciOld			[IN] Cluster item to follow the new tree item.
//		pciNew			[IN OUT] Cluster item represented by the new tree item.
//		bTakeOwnership	[IN] TRUE = delete pci when done, FALSE = don't delete.
//
//	Return Value:
//		ptiChild		The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChildBefore(
	IN const CClusterItem *	pciOld,
	OUT CClusterItem *		pciNew,
	IN BOOL					bTakeOwnership	// = FALSE
	)
{
	CTreeItem *		ptiOldChild;
	CTreeItem *		ptiNewChild;
	CListItem *		pliChild;
	POSITION		posOld;

	// If no old was specified, add to the tail.
	if (pciOld == NULL)
		return PtiAddChild(pciNew, bTakeOwnership);

	// Find the old item.
	ptiOldChild = LptiChildren().PtiFromPci(pciOld, &posOld);
	ASSERT_VALID(ptiOldChild);

	// Create a child tree item.
	ptiNewChild = new CTreeItem(this, pciNew, bTakeOwnership);
    if (ptiNewChild == NULL)
    {
        ThrowStaticException(GetLastError());
    } // if: error allocating the tree item
	ASSERT_VALID(ptiNewChild);
	ptiNewChild->Init();

	// Add the item before the specified item.
	VERIFY((m_lptiChildren.InsertBefore(posOld, ptiNewChild)) != NULL);

	// Add it to the back of the cluster item's list.
	pciNew->AddTreeItem(ptiNewChild);

	// Create a list item.
	pliChild = PliAddChild(pciNew);
	ASSERT_VALID(pliChild);

	// Insert the new tree item in all tree controls.
	InsertChildInAllTrees(ptiNewChild);

	return ptiNewChild;

}  //*** CTreeItem::PtiAddChildBefore()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::InsertChildInAllTrees
//
//	Routine Description:
//		Insert a child item in all tree controls.  The child item must have
//		already been inserted in the list of child tree items.
//
//	Arguments:
//		ptiNewChild		[IN OUT] Tree item to be inserted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::InsertChildInAllTrees(IN OUT CTreeItem * ptiNewChild)
{
	POSITION			posPtic;
	CTreeItemContext *	pticParent;
	POSITION			posPrevChild;
	HTREEITEM			htiPrevChild;
	CTreeItemContext *	pticPrevChild;
	CTreeItem *			ptiPrevChild;
	CTreeItemContext *	pticNewChild;
	CTreeCtrl *			ptc;
	CString				strName;

	ASSERT_VALID(ptiNewChild);

	// Find the position of the child being inserted.  Then get the address
	// of the child before the one being inserted.  This requires two calls
	// to GetPrev.
	VERIFY((posPrevChild = LptiChildren().Find(ptiNewChild)) != NULL);		// Get new child pos.
	VERIFY((ptiPrevChild = LptiChildren().GetPrev(posPrevChild)) != NULL);	// Get pointer to new child.
	if (posPrevChild == NULL)												// If this is the first child,
	{
		htiPrevChild = TVI_FIRST;											//   set the hti to that value.
		ptiPrevChild = NULL;
	}  // if:  new child is not the first child
	else
	{
		htiPrevChild = NULL;
		ptiPrevChild = LptiChildren().GetPrev(posPrevChild);				// Get pointer to prev child.
		ASSERT_VALID(ptiPrevChild);
	}  // else:  new child is the first child

	// Loop through all the tree item contexts and add this item
	// to the tree controls.
	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		// Get the parent's tree item context.
		pticParent = Lptic().GetNext(posPtic);
		ASSERT_VALID(pticParent);

		// Get the child's tree item context.
		if (ptiPrevChild != NULL)
		{
			pticPrevChild = ptiPrevChild->PticFromFrame(pticParent->m_pframe);
			ASSERT_VALID(pticPrevChild);
			htiPrevChild = pticPrevChild->m_hti;
		}  // if:  not inserting at beginning of list

		// Allocate a new tree item context.
		pticNewChild = new CTreeItemContext(pticParent->m_pframe, ptiNewChild, NULL, FALSE /*bExpanded*/);
		if (pticNewChild == NULL)
		{
			ThrowStaticException(GetLastError());
		} // if: error allocating the tree item context
		ASSERT_VALID(pticNewChild);
		pticNewChild->Init();
		ptiNewChild->m_lptic.AddTail(pticNewChild);

		// Get the name to show in the tree.
		ptiNewChild->Pci()->GetTreeName(strName);

		// Insert the item in the tree.
		ASSERT_VALID(pticParent->m_pframe);
		ASSERT_VALID(pticParent->m_pframe->PviewTree());
		ptc = &pticParent->m_pframe->PviewTree()->GetTreeCtrl();
		VERIFY((pticNewChild->m_hti = ptc->InsertItem(strName, pticParent->m_hti, htiPrevChild)) != NULL);
		VERIFY(ptc->SetItemData(pticNewChild->m_hti, (DWORD_PTR) ptiNewChild));
	}  // while:  more tree item contexts in the list

}  //*** CTreeItem::InsertChildInAllTrees()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiAddChild(CClusterItem*)
//
//	Routine Description:
//		Add a child to the item's list of children.  Also creates an entry
//		in the list of children list items.
//
//	Arguments:
//		pci				[IN OUT] Cluster item represented by the new tree item.
//		bTakeOwnership	[IN] TRUE = delete pci when done, FALSE = don't delete.
//
//	Return Value:
//		ptiChild		The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChild(
	IN OUT CClusterItem *	pci,
	IN BOOL					bTakeOwnership	// = FALSE
	)
{
	CTreeItem *		ptiChild;
	CListItem *		pliChild;

	ASSERT_VALID(pci);

	// Create a child tree item.
	ptiChild = new CTreeItem(this, pci, bTakeOwnership);
	if (ptiChild == NULL)
	{
		ThrowStaticException(GetLastError());
	} // if: error allocating the child tree item
	ASSERT_VALID(ptiChild);
	ptiChild->Init();

	// Add the item to the list of child tree items.
	m_lptiChildren.AddTail(ptiChild);

	// Add ourselves to the back of the cluster item's list.
	pci->AddTreeItem(ptiChild);

	// Create a list item.
	pliChild = PliAddChild(pci);
	ASSERT_VALID(pliChild);

	// Insert the new tree item in all tree controls.
	InsertChildInAllTrees(ptiChild);

	return ptiChild;

}  //*** CTreeItem::PtiAddChild(CClusterItem*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiAddChild(CString&)
//
//	Routine Description:
//		Add a child to the item's list of children.  Also creates an entry
//		in the list of children list items.
//
//	Arguments:
//		rstrName	[IN] String for the name of the item.
//
//	Return Value:
//		ptiChild	The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChild(IN const CString & rstrName)
{
	CClusterItem *	pci;
	CTreeItem *		ptiChild;

	// Create the cluster item.
	pci = new CClusterItem(&rstrName);
	if (pci == NULL)
	{
		ThrowStaticException(GetLastError());
	} // if: error allocating the cluster item
	ASSERT_VALID(pci);

	// Add the cluster item to our list of children.
	ptiChild = PtiAddChild(pci, TRUE /*bTakeOwnership*/);
	ASSERT_VALID(ptiChild);

	return ptiChild;

}  //*** CTreeItem::PtiAddChild(CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiAddChild(IDS)
//
//	Routine Description:
//		Add a child to the item's list of children.  Also creates an entry
//		in the list of children list items.
//
//	Arguments:
//		idsName		[IN] String resource ID for the name of the item.
//
//	Return Value:
//		ptiChild	The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChild(IN IDS idsName)
{
	CString		strName;

	ASSERT(idsName != 0);

	strName.LoadString(idsName);
	return PtiAddChild(strName);

}  //*** CTreeItem::PtiAddChild(IDS)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PliAddChild
//
//	Routine Description:
//		Add a child to the item's list of children list items.
//
//	Arguments:
//		pci			[IN OUT] Cluster item represented by the list item.
//
//	Return Value:
//		pliChild	The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem * CTreeItem::PliAddChild(IN OUT CClusterItem * pci)
{
	CListItem *		pliChild;

	ASSERT_VALID(pci);

	// Create a list item.
	pliChild = new CListItem(pci, this);
	if (pliChild == NULL)
	{
		ThrowStaticException(GetLastError());
	} // if: error allocating the list item
	ASSERT_VALID(pliChild);

	// Add the list item to the list of child list items.
	m_lpliChildren.AddTail(pliChild);

	// Add the list item to the cluster item's list.
	pci->AddListItem(pliChild);

	// Add the list item to any list views.
	{
		POSITION			posPtic;
		CTreeItemContext *	ptic;
		int					ili;

		posPtic = Lptic().GetHeadPosition();
		while (posPtic != NULL)
		{
			ptic = Lptic().GetNext(posPtic);
			ASSERT_VALID(ptic);

			if (ptic->m_pframe->PviewTree()->HtiSelected() == ptic->m_hti)
			{
				ASSERT_VALID(ptic->m_pframe);
				VERIFY((ili = pliChild->IliInsertInList(ptic->m_pframe->PviewList())) != -1);
			}  // if:  currently showing children in list view
		}  // while:  item is showing in more views
	}  // Add the list item to any list views

	return pliChild;

}  //*** CTreeItem::PliAddChild()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::RemoveItem
//
//	Routine Description:
//		Remove the item from the tree.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::RemoveItem(void)
{
	ASSERT_VALID(PtiParent());
	PtiParent()->RemoveChild(Pci());

}  //*** CTreeItem::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::RemoveChild
//
//	Routine Description:
//		Remove a child from the item's list of children list items.
//
//	Arguments:
//		pci			[IN OUT] Cluster item represented by the list item.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::RemoveChild(IN OUT CClusterItem * pci)
{
	ASSERT_VALID(pci);

	// Remove the item from the list of list items.
	{
		CListItem *		pliChild;
		POSITION		posPli;

		pliChild = PliChildFromPci(pci);
		if (pliChild != NULL)
		{
			pliChild->RemoveFromAllLists();
			posPli = LpliChildren().Find(pliChild);
			ASSERT(posPli != NULL);
			m_lpliChildren.RemoveAt(posPli);
			Trace(g_tagTreeItemDelete, _T("RemoveChild() - Deleting child list item '%s' from '%s' - %d left"), pliChild->Pci()->StrName(), Pci()->StrName(), LpliChildren().GetCount());
			delete pliChild;
		}  // if:  child lives in the list

	}  // Remove the item from the list of list items

	// Remove the item from the list of tree items.
	{
		CTreeItem *		ptiChild;
		CTreeItem *		ptiChildChild;
		POSITION		posPti;
		ULONG			nReferenceCount;

		ptiChild = PtiChildFromPci(pci);
		if (ptiChild != NULL)
		{
			// Remove the children of this child.
			{
				posPti = ptiChild->LptiChildren().GetHeadPosition();
				while (posPti != NULL)
				{
					ptiChildChild = ptiChild->LptiChildren().GetNext(posPti);
					ASSERT_VALID(ptiChildChild);
					ptiChildChild->RemoveItem();
				}  // while:  more items in the list
			}  // Remove the children of this child

			posPti = LptiChildren().Find(ptiChild);
			ASSERT(posPti != NULL);
			nReferenceCount = ptiChild->NReferenceCount();
			m_lptiChildren.RemoveAt(posPti);
			Trace(g_tagTreeItemDelete, _T("RemoveChild() - Deleting child tree item '%s' from '%s' - %d left"), ptiChild->Pci()->StrName(), Pci()->StrName(), LptiChildren().GetCount());
			if (nReferenceCount > 1)
			{
				ptiChild->AddRef();
				ptiChild->RemoveFromAllLists();
				ptiChild->Release();
			}  // if:  child not deleted yet
		}  // if:  child lives in the tree

	}  // Remove the item from the list of tree items

}  //*** CTreeItem::RemoveChild()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiChildFromName
//
//	Routine Description:
//		Find a child tree item from its name.
//
//	Arguments:
//		rstrName	[IN] Name of the item.
//		ppos		[OUT] Position of the item in the list.
//
//	Return Value:
//		ptiChild	Child item corresponding to the specified name.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiChildFromName(
	IN const CString &	rstrName,
	OUT POSITION *		ppos		// = NULL
	) const
{
	POSITION	posPtiChild;
	POSITION	posCurPtiChild;
	CTreeItem *	ptiChild	= NULL;

	// Loop through each child item to find the specified item.
	posPtiChild = LptiChildren().GetHeadPosition();
	while (posPtiChild != NULL)
	{
		posCurPtiChild = posPtiChild;
		ptiChild = LptiChildren().GetNext(posPtiChild);
		ASSERT_VALID(ptiChild);

		if (ptiChild->StrName() == rstrName)
		{
			if (ppos != NULL)
				*ppos = posCurPtiChild;
			break;
		}  // if:  found a match
	}  // while:  more children of this tree item

	return ptiChild;

}  //*** CTreeItem::PtiChildFromName(CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiChildFromName
//
//	Routine Description:
//		Find a child tree item from its name.
//
//	Arguments:
//		idsName		[IN] ID of the name of the item.
//		ppos		[OUT] Position of the item in the list.
//
//	Return Value:
//		ptiChild	Child item corresponding to the specified name.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiChildFromName(
	IN IDS			idsName,
	OUT POSITION *	ppos	// = NULL
	) const
{
	CString		strName;

	VERIFY(strName.LoadString(idsName));
	return PtiChildFromName(strName, ppos);

}  //*** CTreeItem::PtiChildFromName(IDS)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PtiChildFromPci
//
//	Routine Description:
//		Find a child tree item from its cluster item.
//
//	Arguments:
//		pci			[IN] Cluster item to search for.
//
//	Return Value:
//		ptiChild	Child item corresponding to the specified cluster item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiChildFromPci(IN const CClusterItem * pci) const
{
	POSITION	posPtiChild;
	CTreeItem *	ptiChild	= NULL;

	ASSERT_VALID(pci);

	// Loop through each child item to find the specified item.
	posPtiChild = LptiChildren().GetHeadPosition();
	while (posPtiChild != NULL)
	{
		ptiChild = LptiChildren().GetNext(posPtiChild);
		ASSERT_VALID(ptiChild);

		if (ptiChild->Pci() == pci)
			break;
	}  // while:  more children of this tree item

	return ptiChild;

}  //*** CTreeItem::PtiChildFromPci()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PliChildFromPci
//
//	Routine Description:
//		Find a child list item from its cluster item.
//
//	Arguments:
//		pci			[IN] Cluster item to search for.
//
//	Return Value:
//		pliChild	Child item corresponding to the specified cluster item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem * CTreeItem::PliChildFromPci(IN const CClusterItem * pci) const
{
	POSITION	posPliChild;
	CListItem *	pliChild	= NULL;

	// Loop through each child item to find the specified item.
	posPliChild = LpliChildren().GetHeadPosition();
	while (posPliChild != NULL)
	{
		pliChild = LpliChildren().GetNext(posPliChild);
		ASSERT_VALID(pliChild);

		if (pliChild->Pci() == pci)
			break;
	}  // while:  more children of this tree item

	return pliChild;

}  //*** CTreeItem::PliChildFromPci()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::HtiInsertInTree
//
//	Routine Description:
//		Insert the item in a tree under the specified parent.
//
//	Arguments:
//		pctv		[IN OUT] Cluster tree view in which item is displayed.
//
//	Return Value:
//		m_hti		Handle of the new item in the tree.
//
//--
/////////////////////////////////////////////////////////////////////////////
HTREEITEM CTreeItem::HtiInsertInTree(
	IN OUT CClusterTreeView *	pctv
	)
{
	CTreeItemContext *	ptic;
	HTREEITEM			htiParent;
	CSplitterFrame *	pframe;

	ASSERT_VALID(pctv);
	ASSERT_VALID(Pci());

	// Get the frame pointer.
	pframe = (CSplitterFrame *) pctv->GetParent()->GetParent();
	ASSERT_VALID(pframe);

	// Get the tree item context for this item.
	// If it doesn't exist yet, create one.
	ptic = PticFromView(pctv);
	if (ptic == NULL)
	{
		// Create the new tree item context.
		ptic = new CTreeItemContext(pframe, this, NULL, FALSE /*bExpanded*/);
		if (ptic == NULL)
		{
			ThrowStaticException(GetLastError());
		} // if: error allcoating the tree item context
		ASSERT_VALID(ptic);
		ptic->Init();
		m_lptic.AddTail(ptic);
	}  // if:  no entry found

	// Get our parent's handle.
	if (PtiParent() != NULL)
	{
		CTreeItemContext *	pticParent;

		pticParent = PtiParent()->PticFromFrame(pframe);
		ASSERT_VALID(pticParent);
		htiParent = pticParent->m_hti;
	}  // if:  parent specified
	else
		htiParent = NULL;

	// Insert the item in the tree.
	{
		CTreeCtrl *			ptc;
		CString				strName;

		ASSERT_VALID(pframe->PviewTree());

		Pci()->GetTreeName(strName);

		ptc = &pframe->PviewTree()->GetTreeCtrl();
		VERIFY((ptic->m_hti = ptc->InsertItem(strName, htiParent)) != NULL);
		VERIFY(ptc->SetItemData(ptic->m_hti, (DWORD_PTR) this));
	}  // Insert the item in the tree

	UpdateState();
	return ptic->m_hti;

}  //*** CTreeItem::HtiInsertInTree()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::RemoveFromAllLists
//
//	Routine Description:
//		Remove this item from all lists.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::RemoveFromAllLists(void)
{
	if (Pci() != NULL)
	{
		ASSERT_VALID(Pci());

		// Loop through each view and remove the item from the list.
		{
			POSITION			posPtic;
			POSITION			posPticPrev;
			CTreeItemContext *	ptic;
			CTreeCtrl *			ptc;
			CClusterListView *	pviewList;

			posPtic = Lptic().GetHeadPosition();
			while (posPtic != NULL)
			{
				// Get the next tree item context list entry.
				posPticPrev = posPtic;
				ptic = Lptic().GetNext(posPtic);
				ASSERT_VALID(ptic);

				// Get the tree control and list view from the frame.
				ASSERT_VALID(ptic->m_pframe);
				ptc = &ptic->m_pframe->PviewTree()->GetTreeCtrl();
				pviewList = ptic->m_pframe->PviewList();

				// If this tree item is the parent of the list control items,
				// refresh the list control with no selection.
				if (pviewList->PtiParent() == this)
					pviewList->Refresh(NULL);

				// Delete the item from the tree control and the list.
				VERIFY(ptc->DeleteItem(ptic->m_hti));
				m_lptic.RemoveAt(posPticPrev);
				delete ptic;
			}  // while:  more lists
		}  // Loop through each view and remove the item from the list

		// Remove ourselves from the cluster item's list.
		Pci()->RemoveTreeItem(this);
	}  // if:  valid cluster item pointer

}  //*** CTreeItem::RemoveFromAllLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::Select
//
//	Routine Description:
//		Select this item in the specified tree view.  This causes the
//		children of this item to be displayed in a list view.
//
//	Arguments:
//		pctv			[IN OUT] Tree view in which item was selected.
//		bSelectInTree	[IN] TRUE = select in tree control also.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Select(IN OUT CClusterTreeView * pctv, IN BOOL bSelectInTree)
{
	CTreeItemContext *	ptic;

	ASSERT_VALID(pctv);

	// Get the tree item context.
	ptic = PticFromView(pctv);
	ASSERT_VALID(ptic);
	Trace(g_tagTreeItemSelect, _T("'%s' selected"), Pci()->StrName());

	// Select the item in the tree control.
	if (bSelectInTree)
		ptic->m_pframe->PviewTree()->GetTreeCtrl().Select(ptic->m_hti, TVGN_CARET);

	// Refresh the list control.
	ASSERT_VALID(ptic->m_pframe);
	ASSERT_VALID(ptic->m_pframe->PviewList());
	ptic->m_pframe->PviewList()->Refresh(this);

}  //*** CTreeItem::Select()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PreRemoveFromFrameWithChildren
//
//	Routine Description:
//		Cleanup an item and all its children.
//
//	Arguments:
//		pframe	[IN OUT] Frame window item is being removed from.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::PreRemoveFromFrameWithChildren(IN OUT CSplitterFrame * pframe)
{
	POSITION	posChild;
	CTreeItem *	ptiChild;

	ASSERT_VALID(this);

	// Cleanup all child items.
	posChild = LptiChildren().GetHeadPosition();
	while (posChild != NULL)
	{
		ptiChild = LptiChildren().GetNext(posChild);
		ASSERT_VALID(ptiChild);
		ptiChild->PreRemoveFromFrameWithChildren(pframe);
	}  // while:  more items in the list

	// Cleanup this item.
	PreRemoveFromFrame(pframe);

}  //*** CTreeItem::PreRemoveFromFrameWithChildren()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PreRemoveFromFrame
//
//	Routine Description:
//		Prepare to remove the item from a tree.
//
//	Arguments:
//		pframe		[IN OUT] Frame window item is being removed from.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::PreRemoveFromFrame(IN OUT CSplitterFrame * pframe)
{
	CTreeItemContext *	ptic;
	POSITION			posPtic;

	ASSERT_VALID(pframe);

	// Find the view in our list.
	ptic = PticFromFrame(pframe);
	if (ptic == NULL)
		return;
	ASSERT_VALID(ptic);
	VERIFY((posPtic = Lptic().Find(ptic)) != NULL);

	// Remove the view from the list.
	m_lptic.RemoveAt(posPtic);

	// Delete the context item.
	delete ptic;

}  //*** CTreeItem::PreRemoveFromFrame(pframe)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PticFromFrame
//
//	Routine Description:
//		Find a tree item context from a frame.
//
//	Arguments:
//		pframe		[IN] Frame to search on.
//
//	Return Value:
//		ptic		Found context, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItemContext * CTreeItem::PticFromFrame(IN const CSplitterFrame * pframe) const
{
	POSITION			posPtic;
	CTreeItemContext *	ptic;

	ASSERT_VALID(pframe);

	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		ptic = Lptic().GetNext(posPtic);
		ASSERT_VALID(ptic);
		if (ptic->m_pframe == pframe)
			return ptic;
	}  // while:  more items in the list

	return NULL;

}  //*** CTreeItem::PticFromFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PticFromView
//
//	Routine Description:
//		Find a tree item context from a tree view.
//
//	Arguments:
//		pctv		[IN] Tree view to search on.
//
//	Return Value:
//		ptic		Found context, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItemContext * CTreeItem::PticFromView(IN const CClusterTreeView * pctv) const
{
	POSITION			posPtic;
	CTreeItemContext *	ptic;

	ASSERT_VALID(pctv);

	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		ptic = Lptic().GetNext(posPtic);
		ASSERT_VALID(ptic);
		ASSERT_VALID(ptic->m_pframe);
		if (ptic->m_pframe->PviewTree() == pctv)
			return ptic;
	}  // while:  more items in the list

	return NULL;

}  //*** CTreeItem::PticFromView(CClusterTreeView*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PticFromView
//
//	Routine Description:
//		Find a tree item context from a list view.
//
//	Arguments:
//		pclv		[IN] List view to search on.
//
//	Return Value:
//		ptic		Found context, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItemContext * CTreeItem::PticFromView(IN const CClusterListView * pclv) const
{
	POSITION			posPtic;
	CTreeItemContext *	ptic;

	ASSERT_VALID(pclv);

	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		ptic = Lptic().GetNext(posPtic);
		ASSERT_VALID(ptic);
		ASSERT_VALID(ptic->m_pframe);
		if (ptic->m_pframe->PviewList() == pclv)
			return ptic;
	}  // while:  more items in the list

	return NULL;

}  //*** CTreeItem::PticFromView(CClusterListView*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::HtiFromView
//
//	Routine Description:
//		Find a tree item handle from a view.
//
//	Arguments:
//		pctv		[IN] View to search on.
//
//	Return Value:
//		hti			Found tree item handle, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HTREEITEM CTreeItem::HtiFromView(IN const CClusterTreeView * pctv) const
{
	CTreeItemContext *	ptic;
	HTREEITEM			hti		= NULL;

	ASSERT_VALID(pctv);

	ptic = PticFromView(pctv);
	if (ptic != NULL)
		hti = ptic->m_hti;

	return hti;

}  //*** CTreeItem::HtiFromView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PcoliAddColumn
//
//	Routine Description:
//		Add a column to the list of column header items.
//
//	Arguments:
//		rstrText		[IN] Reference to the text of the column.
//		idsColumnID		[IN] ID of the column to identify the data.
//		nDefaultWidth	[IN] Default width of the column.
//		nWidth			[IN] Actual width of the column.
//
//	Return Value:
//		pcoli			Column item added to the list.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem * CTreeItem::PcoliAddColumn(
	IN const CString &	rstrText,
	IN IDS				idsColumnID,
	IN int				nDefaultWidth,
	IN int				nWidth
	)
{
	CColumnItem *	pcoli;

	pcoli = new CColumnItem(rstrText, idsColumnID, nDefaultWidth, nWidth);
	if (pcoli == NULL)
	{
		ThrowStaticException(GetLastError());
	} // if: error allocating the column item
	m_lpcoli.AddTail(pcoli);

	return pcoli;

}  //*** CTreeItem::PcoliAddColumn(CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::PcoliAddColumn
//
//	Routine Description:
//		Add a column to the list of column header items.
//
//	Arguments:
//		idsText			[IN] String resource ID for the text of the column.
//						  Also used as the column ID.
//		nDefaultWidth	[IN] Default width of the column.
//		nWidth			[IN] Actual width of the column.
//
//	Return Value:
//		pcoli			Column item added to the list.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem * CTreeItem::PcoliAddColumn(IN IDS idsText, IN int nDefaultWidth, IN int nWidth)
{
	CString		strText;

	strText.LoadString(idsText);
	return PcoliAddColumn(strText, idsText, nDefaultWidth, nWidth);

}  //*** CTreeItem::PcoliAddColumn(IDS)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::BSelectItem
//
//	Routine Description:
//		Select the item in the specified tree control.
//
//	Arguments:
//		pctv	[IN OUT] Cluster tree view in which to select the item.
//
//	Return Value:
//		TRUE	Item was selected successfully.
//		FALSE	Item not selected.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::BSelectItem(IN OUT CClusterTreeView  * pctv)
{
	HTREEITEM	hti;

	ASSERT_VALID(pctv);

	VERIFY((hti = HtiFromView(pctv)) != NULL);
	return (pctv->GetTreeCtrl().SelectItem(hti) != 0);

}  //*** CTreeItem::BSelectItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::SelectInAllViews
//
//	Routine Description:
//		Select this item in all views in which it is being displayed.  This
//		causes the children of this item to be displayed in a list view.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::SelectInAllViews(void)
{
	POSITION			posPtic;
	CTreeItemContext *	ptic;

	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		// Get the next tree item context list entry.
		ptic = Lptic().GetNext(posPtic);
		ASSERT_VALID(ptic);

		// Select the item in this list.
		ASSERT_VALID(ptic->m_pframe);
		BSelectItem(ptic->m_pframe->PviewTree());
		ptic->m_pframe->PviewTree()->SetFocus();
	}  // while:  more items in the list

}  //*** CTreeItem::SelectInAllViews()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::BExpand
//
//	Routine Description:
//		Expand the item in the specified tree control.
//
//	Arguments:
//		pctv	[IN OUT] Cluster tree view in which to expand the item.
//		nCode	[IN] Flag indicating the type of action to be taken.
//
//	Return Value:
//		TRUE	Item was expanded successfully.
//		FALSE	Item not expanded.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::BExpand(IN OUT CClusterTreeView  * pctv, IN UINT nCode)
{
	CTreeItemContext *	ptic;

	ASSERT_VALID(pctv);
	ASSERT(nCode != 0);

	ptic = PticFromView(pctv);
	ASSERT_VALID(ptic);
	if (nCode == TVE_EXPAND)
		ptic->m_bExpanded = TRUE;
	else
		ptic->m_bExpanded = FALSE;
	return (pctv->GetTreeCtrl().Expand(ptic->m_hti, nCode) != 0);

}  //*** CTreeItem::BExpand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::ExpandInAllViews
//
//	Routine Description:
//		Expand the item in all views in which it is displayed.
//
//	Arguments:
//		nCode	[IN] Flag indicating the type of action to be taken.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::ExpandInAllViews(IN UINT nCode)
{
	POSITION			posPtic;
	CTreeItemContext *	ptic;

	ASSERT(nCode != 0);

	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		// Get the next tree item context list entry.
		ptic = Lptic().GetNext(posPtic);
		ASSERT_VALID(ptic);

		// Select the item in this list.
		ASSERT_VALID(ptic->m_pframe);
		BExpand(ptic->m_pframe->PviewTree(), nCode);
	}  // while:  more items in the list

}  //*** CTreeItem::ExpandInAllViews()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::SetExpandedState
//
//	Routine Description:
//		Save the expanded state of the item in the specified view.
//
//	Arguments:
//		pctv		[IN] Tree view in which expanded state is being saved.
//		bExpanded	[IN] TRUE = item is expanded in the specified view.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::SetExpandedState(
	IN const CClusterTreeView *	pctv,
	IN BOOL						bExpanded
	)
{
	CTreeItemContext *	ptic;

	ASSERT_VALID(pctv);

	ptic = PticFromView(pctv);
	ASSERT_VALID(ptic);
	ptic->m_bExpanded = bExpanded;

}  //*** CTreeItem::SetExpandedState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::BShouldBeExpanded
//
//	Routine Description:
//		Returns whether the item should be expanded in the specified tree
//		view based on the user's profile.
//
//	Arguments:
//		pctv		[IN] Tree view in which expanded state is being saved.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::BShouldBeExpanded(IN const CClusterTreeView * pctv) const
{
	CTreeItemContext *	ptic;

	ASSERT_VALID(pctv);

	ptic = PticFromView(pctv);
	ASSERT_VALID(ptic);
	return ptic->m_bExpanded;

}  //*** CTreeItem::BShouldBeExpanded()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::UpdateState
//
//	Routine Description:
//		Update the current state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::UpdateState(void)
{
	ASSERT_VALID(this);
	ASSERT_VALID(Pci());

	// Ask the item to update its state.
	if (Pci() != NULL)
		Pci()->UpdateState();

}  //*** CTreeItem::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::UpdateAllStatesInTree
//
//	Routine Description:
//		Update the current state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::UpdateAllStatesInTree(void)
{
	POSITION	posPti;
	CTreeItem *	ptiChild;

	UpdateState();
	posPti = LptiChildren().GetHeadPosition();
	while (posPti != NULL)
	{
		ptiChild = LptiChildren().GetNext(posPti);
		ASSERT_VALID(ptiChild);
		ptiChild->UpdateAllStatesInTree();
	}  // while:  more children

}  //*** CTreeItem::UpdateAllStatesInTree()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::UpdateUIState
//
//	Routine Description:
//		Update the current UI state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::UpdateUIState(void)
{
	POSITION			posPtic;
	CTreeItemContext *	ptic;
	UINT				nMask;
	UINT				nImage;
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
	CString				strText;
#endif

	ASSERT_VALID(Pci());

	// Loop through the views and update the state on each one.
	posPtic = Lptic().GetHeadPosition();
	while (posPtic != NULL)
	{
		ptic = Lptic().GetNext(posPtic);
		ASSERT_VALID(ptic);

		// Set the images that are displayed for the item.
		ASSERT_VALID(ptic->m_pframe);
		ASSERT_VALID(ptic->m_pframe->PviewTree());
		nMask = TVIF_TEXT;
		if (Pci() == NULL)
		{
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
			strText = StrName();
#endif
			nImage = 0;
		}  // if:  invalid cluster item
		else
		{
			nMask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
			Pci()->GetTreeName(strText);
#endif
			nImage = Pci()->IimgState();
		}  // else:  valid cluster item
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
		Trace(g_tagTreeItemUpdate, _T("Updating item '%s' (pci name = '%s')"), strText, Pci()->StrName());
#else
		Trace(g_tagTreeItemUpdate, _T("Updating item '%s' (pci name = '%s')"), StrName(), Pci()->StrName());
#endif
		ptic->m_pframe->PviewTree()->GetTreeCtrl().SetItem(
											ptic->m_hti,	// hItem
											nMask,			// nMask
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
											strText,		// lpszItem
#else
											StrName(),		// lpszItem
#endif
											nImage,			// nImage
											nImage,			// nSelectedImage
											0,				// nState
											0,				// nStatemask
											NULL			// lParam
											);
	}  // while:  more view

}  //*** CTreeItem::UpdateUIState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::OnCmdMsg
//
//	Routine Description:
//		Processes command messages.  Attempts to pass them on to a selected
//		item first.
//
//	Arguments:
//		nID				[IN] Command ID.
//		nCode			[IN] Notification code.
//		pExtra			[IN OUT] Used according to the value of nCode.
//		pHandlerInfo	[OUT] ???
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::OnCmdMsg(
	UINT					nID,
	int						nCode,
	void *					pExtra,
	AFX_CMDHANDLERINFO *	pHandlerInfo
	)
{
	if (Pci() != NULL)
	{
		// Give the cluster item a chance to handle the message.
		if (Pci()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			return TRUE;
	}  // if:  valid cluster item

	return CBaseCmdTarget::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

}  //*** CTreeItem::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::OpenChild
//
//	Routine Description:
//		Open the specified child item.
//
//	Arguments:
//		pti			[IN OUT] Child tree item to open.
//		pframe		[IN OUT] Frame in which to open the item.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::OpenChild(
	IN OUT CTreeItem *		pti,
	IN OUT CSplitterFrame *	pframe
	)
{
	CTreeItemContext *	ptic;

	ASSERT_VALID(pti);
	ASSERT_VALID(pframe);

	// Find the tree item context for the frame.
	ptic = PticFromFrame(pframe);
	ASSERT_VALID(ptic);

	// Expand the parent item and then select the child item.
	if (pframe->PviewTree()->GetTreeCtrl().Expand(ptic->m_hti, TVE_EXPAND))
		pti->Select(pframe->PviewTree(), TRUE /*bSelectInTree*/);

}  //*** CTreeItem::OpenChild()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::EditLabel
//
//	Routine Description:
//		Processes the ID_FILE_RENAME menu command.
//
//	Arguments:
//		pctv		[IN OUT] Cluster tree view item is being edited in.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::EditLabel(IN OUT CClusterTreeView * pctv)
{
	HTREEITEM	hti;

	ASSERT_VALID(pctv);
	ASSERT_VALID(Pci());
	ASSERT(Pci()->BCanBeEdited());

	hti = HtiFromView(pctv);
	ASSERT(hti != NULL);
	pctv->GetTreeCtrl().EditLabel(hti);

}  //*** CTreeItem::EditLabel()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CTreeItemContext
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CTreeItemContext, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItemContext::Init
//
//	Routine Description:
//		Initialize the tree item context.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItemContext::Init(void)
{
	BOOL	bExpanded;
	UINT	cbColumnInfo;
	CString	strValueName;

	ASSERT_VALID(m_pti);
	ASSERT(m_pti->StrProfileSection().GetLength() > 0);
	ASSERT(m_prgnColumnInfo == NULL);

	try
	{
		// Read the expanded state.
		m_pframe->ConstructProfileValueName(strValueName, REGPARAM_EXPANDED);
		bExpanded = AfxGetApp()->GetProfileInt(
			m_pti->StrProfileSection(),
			strValueName,
			m_bExpanded
			);
		if (bExpanded)
			m_bExpanded = bExpanded;

		// Read the column information.
		m_pframe->ConstructProfileValueName(strValueName, REGPARAM_COLUMNS);
		AfxGetApp()->GetProfileBinary(
			m_pti->StrProfileSection(),
			strValueName,
			(BYTE **) &m_prgnColumnInfo,
			&cbColumnInfo
			);
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

}  //*** CTreeItemContext::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItemContext::SaveProfileInfo
//
//	Routine Description:
//		Save state information to the user's profile.  This includes column
//		widths and positions as well as whether the tree item was expanded
//		or not.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItemContext::SaveProfileInfo(void)
{
	CString		strValueName;

	try
	{
		ASSERT_VALID(m_pti);
		ASSERT(m_pti->StrProfileSection().GetLength() > 0);

		// Save expansion info to the user's profile.
		m_pframe->ConstructProfileValueName(strValueName, REGPARAM_EXPANDED);
		AfxGetApp()->WriteProfileInt(
			m_pti->StrProfileSection(),
			strValueName,
			m_bExpanded
			);

		if (m_prgnColumnInfo != NULL)
		{
			// Save column info to the user's profile.
			m_pframe->ConstructProfileValueName(strValueName, REGPARAM_COLUMNS);
			AfxGetApp()->WriteProfileBinary(
				m_pti->StrProfileSection(),
				strValueName,
				(PBYTE) m_prgnColumnInfo,
				((m_prgnColumnInfo[0] * 2) + 1) * sizeof(DWORD)
				);
		}  // if:  there is column info
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

}  //*** CTreeItemContext::SaveProfileInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItemContext::PrgnColumnInfo
//
//	Routine Description:
//		Return the column info.  If it doesn't exist or isn't the right
//		size, allocate one.
//
//	Arguments:
//		None.
//
//	Return Value:
//		prgnColumnInfo	The column info array.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD * CTreeItemContext::PrgnColumnInfo(void)
{
	DWORD	cColumns;

	ASSERT_VALID(m_pti);

	cColumns = (DWORD)m_pti->Lpcoli().GetCount();

	if ((m_prgnColumnInfo == NULL)
			|| (cColumns != m_prgnColumnInfo[0]))
	{
		DWORD cnColumnInfo = (cColumns * 2) + 1;
		delete [] m_prgnColumnInfo;
		m_prgnColumnInfo = new DWORD[cnColumnInfo];
		if (m_prgnColumnInfo == NULL)
		{
			ThrowStaticException(GetLastError());
		} // if: error allocating column info array

		//
		// Initialize the column info array
		//
		{
			DWORD	inColumnInfo;

			// The first entry is the number of columns.
			m_prgnColumnInfo[0] = cColumns;

			// The second set of entries is the width of each column.
			{
				POSITION		pos;
				CColumnItem *	pcoli;

				inColumnInfo = 1;
				pos = m_pti->Lpcoli().GetHeadPosition();
				while (pos != NULL)
				{
					pcoli = m_pti->Lpcoli().GetNext(pos);
					ASSERT_VALID(pcoli);

					ASSERT(inColumnInfo <= cColumns);
					m_prgnColumnInfo[inColumnInfo++] = pcoli->NWidth();
				}  // while:  more items in the list
			}  // The second set of entries is the width of each column

			// The third set of entries is the order of the columns.
			{
				DWORD *	prgnColumnInfo = &m_prgnColumnInfo[inColumnInfo];
				for (inColumnInfo = 0 ; inColumnInfo < cColumns ; inColumnInfo++)
					prgnColumnInfo[inColumnInfo] = inColumnInfo;
			}  // The third set of entries is the order of the columns
		}  // Initialize the column info array
	}  // if:  column info array doesn't exist or is wrong size

	return m_prgnColumnInfo;

}  //*** CTreeItemContext::PrgnColumnInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItemContext::BIsExpanded
//
//	Routine Description:
//		Return the EXPANDED state of the item in this tree view.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Item is expanded.
//		FALSE		Item is not expanded.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItemContext::BIsExpanded(void) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pframe);
	ASSERT_VALID(m_pframe->PviewTree());
	ASSERT(m_hti != NULL);
	return (m_pframe->PviewTree()->GetTreeCtrl().GetItemState(m_hti, TVIS_EXPANDED) == TVIS_EXPANDED);

}  //*** CTreeItemContext::BIsExpanded()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DestructElements
//
//	Routine Description:
//		Destroys CTreeItem* elements.
//
//	Arguments:
//		pElements	Array of pointers to elements to destruct.
//		nCount		Number of elements to destruct.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DestructElements(CTreeItem ** pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(CTreeItem *)));

	// call the destructor(s)
	for (; nCount--; pElements++)
	{
		ASSERT_VALID(*pElements);
		(*pElements)->Release();
	}  // for:  each item in the array

}  //*** DestructElements(CTreeItem**)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] Reference to the list whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CTreeItemList & rlp)
{
	POSITION	pos;
	CTreeItem *	pti;

	// Delete all the items in the Contained list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pti = rlp.GetNext(pos);
		ASSERT_VALID(pti);
//		Trace(g_tagTreeItemDelete, _T("DeleteAllItemData(rlpti) - Deleting tree item '%s'"), pti->Pci()->StrName());
		pti->Delete();
	}  // while:  more items in the list

}  //*** DeleteAllItemData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] Reference to the list whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CTreeItemContextList & rlp)
{
	POSITION			pos;
	CTreeItemContext *	ptic;

	// Delete all the items in the Contained list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		ptic = rlp.GetNext(pos);
		ASSERT_VALID(ptic);
		delete ptic;
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\treeview.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      TreeView.cpp
//
//  Abstract:
//      Implementation of the CClusterTreeView class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusDoc.h"
#include "TreeView.h"
#include "ListView.h"
#include "SplitFrm.h"
#include "TreeItem.inl"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagTreeView(_T("UI"), _T("TREE VIEW"), 0);
CTraceTag   g_tagTreeDrag(_T("Drag&Drop"), _T("TREE VIEW DRAG"), 0);
CTraceTag   g_tagTreeDragMouse(_T("Drag&Drop"), _T("TREE VIEW DRAG MOUSE"), 0);
CTraceTag   g_tagTreeViewSelect(_T("UI"), _T("TREE VIEW SELECT"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterTreeView
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterTreeView, CTreeView)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterTreeView, CTreeView)
    //{{AFX_MSG_MAP(CClusterTreeView)
    ON_WM_DESTROY()
    ON_COMMAND(ID_FILE_RENAME, OnCmdRename)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChanged)
    ON_NOTIFY_REFLECT(TVN_BEGINLABELEDIT, OnBeginLabelEdit)
    ON_NOTIFY_REFLECT(TVN_ENDLABELEDIT, OnEndLabelEdit)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemExpanded)
    ON_NOTIFY_REFLECT(TVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(TVN_BEGINRDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeyDown)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::CClusterTreeView
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterTreeView::CClusterTreeView(void)
{
    m_pframe = NULL;

    // Initialize label editing.
    m_ptiBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

    // Initialize drag & drop.
    m_htiDrag = NULL;
    m_ptiDrag = NULL;
    m_htiDrop = NULL;

}  //*** CClusterTreeView::CClusterTreeView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::~CClusterTreeView
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterTreeView::~CClusterTreeView(void)
{
}  //*** CClusterTreeView::~CClusterTreeView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PreCreateWindow
//
//  Routine Description:
//      Called before the window has been created.
//
//  Arguments:
//      cs      CREATESTRUCT
//
//  Return Value:
//      TRUE    Successful.
//      FALSE   Failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::PreCreateWindow(CREATESTRUCT & cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CTreeView::PreCreateWindow(cs);

}  //*** CClusterTreeView::PreCreateWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::Create
//
//  Routine Description:
//      Create the window.
//
//  Arguments:
//      lpszClassName   [IN] Name of the window class to create.
//      lpszWindowName  [IN] Name of the window (used as the caption).
//      dwStyle         [IN] Window styles.
//      rect            [IN] Size and position of the window
//      pParentWnd      [IN OUT] Parent window.
//      nID             [IN] ID of the window.
//      pContext        [IN OUT] Create context of the window.
//
//  Return Value:
//      0               Successful.
//      !0              Unsuccessful.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::Create(
    LPCTSTR             lpszClassName,
    LPCTSTR             lpszWindowName,
    DWORD               dwStyle,
    const RECT &        rect,
    CWnd *              pParentWnd,
    UINT                nID,
    CCreateContext *    pContext
    )
{
    dwStyle |= TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_EDITLABELS | TVS_SHOWSELALWAYS;
    return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

}  //*** CClusterTreeView::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnDraw
//
//  Routine Description:
//      Called to draw the view.
//
//  Arguments:
//      pDC     [IN OUT] Device Context for the view.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnDraw(IN OUT CDC* pDC)
{
#if 0
    CClusterDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
#endif
}  //*** CClusterTreeView::OnDraw()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnInitialUpdate
//
//  Routine Description:
//      Do one-time initialization.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnInitialUpdate(void)
{
    CClusterAdminApp *  papp        = GetClusterAdminApp();
    CClusterDoc *       pdocCluster = GetDocument();
    CString             strSelection;

    CTreeView::OnInitialUpdate();

    // Save the frame pointer.
//  ASSERT(m_pframe == NULL);
    m_pframe = (CSplitterFrame *) GetParentFrame();
    ASSERT_VALID(m_pframe);
    ASSERT_KINDOF(CSplitterFrame, m_pframe);

    // Tell the tree control about our images.  We are using the
    // same image list for both normal and state images.
    GetTreeCtrl().SetImageList(papp->PilSmallImages(), TVSIL_NORMAL);
//  GetTreeCtrl().SetImageList(papp->PilSmallImages(), TVSIL_STATE);

    // Read the last selection.
    ReadPreviousSelection(strSelection);

    // Recursively add items starting with the cluster.
    BAddItems(pdocCluster->PtiCluster(), strSelection, TRUE /*bExpanded*/);

    // Expand the Cluster item by default.
//  pdocCluster->PtiCluster()->BExpand(this, TVE_EXPAND);

}  //*** CClusterTreeView::OnInitialUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::BAddItems
//
//  Routine Description:
//      Add an item and then add all its children.
//
//  Arguments:
//      pti             [IN OUT] Item to add to the tree.
//      rstrSelection   [IN] Previous selection.
//      bExpanded       [IN] TRUE = add expanded.
//
//  Return Value:
//      TRUE        Parent needs to be expanded.
//      FALSE       Parent does not need to be expanded.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::BAddItems(
    IN OUT CTreeItem *  pti,
    IN const CString &  rstrSelection,
    IN BOOL             bExpanded       // = FALSE
    )
{
    POSITION        posChild;
    CTreeItem *     ptiChild;
    BOOL            bRetExpanded = FALSE;

    ASSERT_VALID(pti);

    // Insert this item into the tree.
    pti->HtiInsertInTree(this);
    if (bExpanded || pti->BShouldBeExpanded(this))
        bRetExpanded = TRUE;

    // Add all the child items.
    posChild = pti->LptiChildren().GetHeadPosition();
    while (posChild != NULL)
    {
        ptiChild = pti->LptiChildren().GetNext(posChild);
        ASSERT_VALID(ptiChild);
        bExpanded = BAddItems(ptiChild, rstrSelection);
        if (bExpanded)
            bRetExpanded = TRUE;
    }  // while:  more child items

    if (bRetExpanded)
        pti->BExpand(this, TVE_EXPAND);

    if (rstrSelection == pti->StrProfileSection())
    {
        pti->Select(this, TRUE /*bSelectInTrue*/);
        bRetExpanded = TRUE;
    }  // if:  this is the selected item

    return bRetExpanded;

}  //*** CClusterTreeView::BAddItems()

#ifdef NEVER
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::CleanupItems
//
//  Routine Description:
//      Cleanup an item and all its children.
//
//  Arguments:
//      ptiParent   [IN OUT] Parent item to cleanup.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::CleanupItems(IN OUT CTreeItem * ptiParent)
{
    POSITION    posChild;
    CTreeItem * ptiChild;

    // Cleanup all child items.
    if (ptiParent != NULL)
    {
        posChild = ptiParent->LptiChildren().GetHeadPosition();
        while (posChild != NULL)
        {
            ptiChild = ptiParent->LptiChildren().GetNext(posChild);
            ASSERT_VALID(ptiChild);
            CleanupItems(ptiChild);
        }  // while:  more items in the list

        // Cleanup this item.
        ptiParent->PreRemoveFromTree(this);
    }  // if:  parent was specified

}  //*** CClusterTreeView::CleanupItems()
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterTreeView diagnostics

#ifdef _DEBUG
void CClusterTreeView::AssertValid(void) const
{
    CTreeView::AssertValid();

}  //*** CClusterTreeView::AssertValid()

void CClusterTreeView::Dump(CDumpContext & dc) const
{
    CTreeView::Dump(dc);

}  //*** CClusterTreeView::Dump()

CClusterDoc * CClusterTreeView::GetDocument(void) // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClusterDoc)));
    return (CClusterDoc *) m_pDocument;

}  //*** CClusterTreeView::GetDocument()
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PtiSelected
//
//  Routine Description:
//      Get the tree item that is selected.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ptiSelected     The selected item or NULL if no item is selected.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CClusterTreeView::PtiSelected(void) const
{
    HTREEITEM   htiSelected;
    CTreeItem * ptiSelected;

    htiSelected = HtiSelected();
    if (htiSelected != NULL)
    {
        ptiSelected = (CTreeItem *) GetTreeCtrl().GetItemData(htiSelected);
        ASSERT_VALID(ptiSelected);
    }  // if:  selected item found
    else
        ptiSelected = NULL;

    return ptiSelected;

}  //*** CClusterTreeView::PtiSelected()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::SaveCurrentSelection
//
//  Routine Description:
//      Save the current selection.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::SaveCurrentSelection(void)
{
    CTreeItem * ptiSelected = PtiSelected();

    if (ptiSelected != NULL)
    {
        CString             strSection;
        CString             strValueName;

        ASSERT_VALID(Pframe());

        try
        {
            strSection.Format(
                REGPARAM_CONNECTIONS _T("\\%s"),
                GetDocument()->StrNode()
                );

            Pframe()->ConstructProfileValueName(strValueName, REGPARAM_SELECTION);

            AfxGetApp()->WriteProfileString(
                strSection,
                strValueName,
                ptiSelected->StrProfileSection()
                );
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // if:  there is a current selection

}  //*** CClusterTreeView::SaveCurrentSelection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::ReadPreviousSelection
//
//  Routine Description:
//      Read the previous selection.
//
//  Arguments:
//      rstrSelection   [OUT] Previous selection read from the user's profile.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::ReadPreviousSelection(OUT CString & rstrSelection)
{
    CString             strSection;
    CString             strValueName;

    ASSERT_VALID(Pframe());

    try
    {
        // Get the selected item.
        strSection.Format(
            REGPARAM_CONNECTIONS _T("\\%s"),
            GetDocument()->StrNode()
            );

        Pframe()->ConstructProfileValueName(strValueName, REGPARAM_SELECTION);

        rstrSelection = AfxGetApp()->GetProfileString(
                            strSection,
                            strValueName,
                            _T("")
                            );
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

}  //*** CClusterTreeView::ReadPreviousSelection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnSelChanged
//
//  Routine Description:
//      Handler method for the TVN_SELCHANGED message.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnSelChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_TREEVIEW *       pNMTreeView = (NM_TREEVIEW *) pNMHDR;
    CTreeItem *         ptiSelected;

    if (!BDragging())
    {
        Trace(g_tagTreeViewSelect, _T("OnSelChanged() - BEGIN"));

        // Get the selected item.
        ptiSelected = (CTreeItem *) pNMTreeView->itemNew.lParam;
        ASSERT_VALID(ptiSelected);

        // Ask the list view to display the items for this tree item.
        ASSERT_VALID(ptiSelected->Pci());
        Trace(g_tagTreeViewSelect, _T("OnSelChanged() - '%s' selected"), ptiSelected->Pci()->StrName());
        ptiSelected->Select(this, FALSE /*bSelectInTree*/);

        // Tell the document of the new selection.
        if (m_pDocument != NULL)  // this happens on system shutdown
            GetDocument()->OnSelChanged(ptiSelected->Pci());

        *pResult = 0;
        Trace(g_tagTreeViewSelect, _T("OnSelChanged() - END"));
    }  // if:  not dragging

}  //*** CClusterTreeView::OnSelChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If there is a current item selected, give it a chance
    // to handle the message.
    if (HtiSelected() != NULL)
        bHandled = PtiSelected()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    if (!bHandled)
        bHandled = CTreeView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

}  //*** CClusterTreeView::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      rpointScreen    [IN OUT] Position of the cursor, in screen coordinates.
//      rpci            [OUT] Pointer in which to return associated cluster item.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CClusterTreeView::PmenuPopup(
    IN OUT CPoint &     rpointScreen,
    OUT CClusterItem *& rpci
    )
{
    CTreeItem * pti     = NULL;
    CMenu *     pmenu   = NULL;

    rpci = NULL;

    // If there are no coordinates (-1,-1), display a menu for the selected item.
    if ((rpointScreen.x == -1) && (rpointScreen.y == -1))
    {
        CRect       rect;
        CTreeItem * ptiSelected = PtiSelected();

        if ((ptiSelected != NULL)
                && GetTreeCtrl().GetItemRect(HtiSelected(), &rect, FALSE))
        {
            pti = ptiSelected;
        }  // if:  selected item and it is visible
        else
            GetWindowRect(&rect);
        rpointScreen.x = (rect.right - rect.left) / 2;
        rpointScreen.y = (rect.bottom - rect.top) / 2;
        ClientToScreen(&rpointScreen);
    }  // if:  no coordinates
    else
    {
        CPoint      pointClient;
        HTREEITEM   hti;
        UINT        uiFlags;

        // Get the coordinates of the point where the user clicked the right mouse
        // button.  We need in both screen and client coordinates.
        pointClient = rpointScreen;
        ScreenToClient(&pointClient);

        // Get the item under the cursor and get its popup menu.
        hti = GetTreeCtrl().HitTest(pointClient, &uiFlags);
        if (hti != NULL)
        {
            // Get the tree item for the item under the cursor.
            pti = (CTreeItem *) GetTreeCtrl().GetItemData(hti);
            ASSERT_VALID(pti);

            // Select the item because that's the only way for it us process the menu.
            pti->BSelectItem(this);
        }  // if:  on an item
    }  // else:  coordinates specified

    if (pti != NULL)
    {
        // Get a menu from the item.
        pmenu = pti->PmenuPopup();
        rpci = pti->Pci();
    }  // if:  item found

    return pmenu;

}  //*** CClusterTreeView::PmenuPopup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnActivateView
//
//  Routine Description:
//      Called when the view is activated.
//
//  Arguments:
//      bActivate       [IN] Indicates whether the view being activated or deactivated.
//      pActivateView   [IN OUT] Points to the view object that is being activated.
//      peactiveView    [IN OUT] Points to the view object that is being deactivated.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnActivateView(
    BOOL        bActivate,
    CView *     pActivateView,
    CView *     pDeactiveView
    )
{
    CTreeItem * ptiSelected = PtiSelected();

    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        if (bActivate && (ptiSelected != NULL))
        {
            ASSERT_VALID(ptiSelected->Pci());
            Trace(g_tagTreeViewSelect, _T("OnActiveView: '%s' selected"), ptiSelected->Pci()->StrName());

            // Tell the document of the new selection.
            GetDocument()->OnSelChanged(ptiSelected->Pci());
        }  // if:  we are being activated
    }  // if:  document is available

    CTreeView::OnActivateView(bActivate, pActivateView, pDeactiveView);

}  //*** CClusterTreeView::OnActivateView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnDestroy(void)
{
    // Clean up the control.
    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        // Save the currently selected item.
        SaveCurrentSelection();

        // Cleanup after ourselves.
//      CleanupItems(GetDocument()->PtiCluster());
    }  // if:  the document is still available

    CTreeView::OnDestroy();

}  //*** CClusterTreeView::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnItemExpanded
//
//  Routine Description:
//      Handler method for the TVN_ITEMEXPANDED message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnItemExpanded(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_TREEVIEW * pNMTreeView = (NM_TREEVIEW *) pNMHDR;

    if (pNMTreeView->itemNew.mask & TVIF_STATE)
    {
        BOOL        bExpanded;
        CTreeItem * pti;

        bExpanded = (pNMTreeView->itemNew.state & TVIS_EXPANDED) != 0;
        ASSERT(pNMTreeView->itemNew.mask & TVIF_PARAM);
        pti = (CTreeItem *) pNMTreeView->itemNew.lParam;
        ASSERT_VALID(pti);
        ASSERT_KINDOF(CTreeItem, pti);
        pti->SetExpandedState(this, bExpanded);
    }  // if:  expanded state changed.

    *pResult = 0;

}  //*** CClusterTreeView::OnItemExpanded()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnBeginLabelEdit
//
//  Routine Description:
//      Handler method for the TVN_BEGINLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//                      TRUE = don't edit, FALSE = edit.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnBeginLabelEdit(NMHDR * pNMHDR, LRESULT * pResult) 
{
    ASSERT(pNMHDR != NULL);

    TV_DISPINFO * pTVDispInfo = (TV_DISPINFO *) pNMHDR;
    CTreeItem * pti = (CTreeItem *) pTVDispInfo->item.lParam;

    ASSERT(m_ptiBeingEdited == NULL);
    ASSERT_VALID(pti);
    ASSERT_VALID(pti->Pci());

    if (!BDragging() && pti->Pci()->BCanBeEdited())
    {
        pti->Pci()->OnBeginLabelEdit(GetTreeCtrl().GetEditControl());
        m_ptiBeingEdited = pti;
        *pResult = FALSE;
    }  // if:  not dragging and object can be edited
    else
        *pResult = TRUE;

    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterTreeView::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnEndLabelEdit
//
//  Routine Description:
//      Handler method for the TVN_ENDLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnEndLabelEdit(NMHDR * pNMHDR, LRESULT * pResult) 
{
    ASSERT(pNMHDR != NULL);

    TV_DISPINFO * pTVDispInfo = (TV_DISPINFO *) pNMHDR;
    CTreeItem * pti = (CTreeItem *) pTVDispInfo->item.lParam;

    ASSERT_VALID(pti);
    ASSERT(pti == m_ptiBeingEdited);
    ASSERT_VALID(pti->Pci());

    // If the edit wasn't cancelled, rename it.
    if (pTVDispInfo->item.mask & LVIF_TEXT)
    {
        ASSERT(pti->Pci()->BCanBeEdited());
        ASSERT(pTVDispInfo->item.pszText != NULL);

        Trace(g_tagTreeView, _T("Ending edit of item '%s' (Saving as '%s')"), pti->Pci()->StrName(), pTVDispInfo->item.pszText);

        if ( pti->Pci()->BIsLabelEditValueValid( pTVDispInfo->item.pszText ) )
        {
            try
            {
                pti->Pci()->Rename(pTVDispInfo->item.pszText);
                *pResult = TRUE;
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                *pResult = FALSE;
            }  // catch:  CException
        } // if:  name is valid
        else
        {
            *pResult = FALSE;
        }
    }  // if:  the edit wasn't cancelled
    else
    {
        Trace(g_tagTreeView, _T("Ending edit of item '%s' (Not Saving)"), pti->Pci()->StrName());
        *pResult = TRUE;
    }  // else:  edit was cancelled

    m_ptiBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterTreeView::OnEndLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnBeginDrag
//
//  Routine Description:
//      Handler method for the TVN_BEGINDRAG and TVN_BEGINRDRAG messages.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnBeginDrag(NMHDR * pNMHDR, LRESULT * pResult)
{
    CTreeCtrl &     rtc         = GetTreeCtrl();
    CPoint          ptScreen;
    CPoint          ptFrame;
    CPoint          ptView;
    UINT            nFlags;
    CClusterItem *  pci = NULL;
    CImageList *    pimagelist;

    ASSERT_VALID(Pframe());

    // Get the current cursor position for identifying the item being dragged.
    GetCursorPos(&ptScreen);
    ptFrame = ptScreen;
    Pframe()->ScreenToClient(&ptFrame);
    ptView = ptScreen;
    rtc.ScreenToClient(&ptView);

    // Get the item being dragged.
    {
        HTREEITEM   hti;
        CTreeItem * pti;

        hti = rtc.HitTest(ptView, &nFlags);
        if (hti == NULL)
            return;

        pti = (CTreeItem *) rtc.GetItemData(hti);
        ASSERT_VALID(pti);
        ASSERT_KINDOF(CTreeItem, pti);
        ASSERT_VALID(pti->Pci());

        // If the item can not be dragged, abort the operation.
        if (!pti->Pci()->BCanBeDragged())
            return;

        // Save info for later.
        m_htiDrag = hti;
        m_ptiDrag = pti;
        m_htiDrop = NULL;
        pci = pti->Pci();
    }  // Get the item being dragged

    Trace(g_tagTreeDrag, _T("OnBeginDrag() - Dragging '%s' at (%d,%d)"), m_ptiDrag->StrName(), ptFrame.x, ptFrame.y);

    // Create an image list for the image being dragged.
    pimagelist = rtc.CreateDragImage(m_htiDrag);

    // Let the frame window initialize the drag operation.
    Pframe()->BeginDrag(pimagelist, pci, ptFrame, CPoint(0, -16));

    *pResult = 0;

}  //*** CClusterTreeView::OnBeginDrag(pNMHDR, pResult)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnMouseMoveForDrag
//
//  Routine Description:
//      Handler method for the WM_MOUSEMOVE message during a drag operation.
//      This function is only responsible for providing view-specific
//      functionality, such as selecting the drop target if it is valid.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor in frame
//                      coordinates.
//      pwndDrop    Specifies the window under the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnMouseMoveForDrag(
    IN UINT         nFlags,
    IN CPoint       point,
    IN const CWnd * pwndDrop
    )
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());

    // If we are dragging, select the drop target.
    if (BDragging())
    {
        HTREEITEM       hti;
        UINT            flags;
        CPoint          ptView;
        CTreeCtrl &     rtc     = GetTreeCtrl();

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rtc.ScreenToClient(&ptView);

        // If this window is the drop target, find the item under the cursor.
        if (pwndDrop == &rtc)
        {
            // If we are over a tree item, highlight it.
            hti = rtc.HitTest(ptView, &flags);
            if (hti != NULL)
            {
                CTreeItem * pti;

                // Get the item to be highlight.
                pti = (CTreeItem *) rtc.GetItemData(hti);
                ASSERT_VALID(pti);
                ASSERT_KINDOF(CTreeItem, pti);
                ASSERT_VALID(pti->Pci());

                // If this is not a drop target, change the cursor.
                if (pti->Pci()->BCanBeDropTarget(Pframe()->PciDrag()))
                    Pframe()->ChangeDragCursor(IDC_ARROW);
                else
                    Pframe()->ChangeDragCursor(IDC_NO);
            }  // if:  over a tree item
        }  // if:  this window is the drop target
        else
            hti = NULL;

        // Unlock window updates.
        VERIFY(Pimagelist()->DragShowNolock(FALSE /*bShow*/));

        // Highlight the new drop target.
        rtc.SelectDropTarget(hti);
        m_htiDrop = hti;

        VERIFY(Pimagelist()->DragShowNolock(TRUE /*bShow*/));
    }  // if:  tree item is being dragged

}  //*** CClusterTreeView::OnMouseMoveForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnButtonUpForDrag
//
//  Routine Description:
//      Called to handle a button up event during drag and drop.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnButtonUpForDrag(IN UINT nFlags, IN CPoint point)
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());
    ASSERT_VALID(Pframe()->PciDrag());

    // If we are dragging, process the drop.
    if (BDragging())
    {
        HTREEITEM       hti;
        UINT            flags;
        CPoint          ptView;
        CTreeCtrl &     rtc     = GetTreeCtrl();

        Trace(g_tagTreeDrag, _T("OnButtonUpForDrag()"));

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rtc.ScreenToClient(&ptView);

        // If we are over a tree item, drop the item being dragged.
        hti = rtc.HitTest(ptView, &flags);
        if (hti != NULL)
        {
            CTreeItem * ptiDropTarget;

            // Get the item to drop on.
            ptiDropTarget = (CTreeItem *) rtc.GetItemData(hti);
            ASSERT_VALID(ptiDropTarget);
            ASSERT_KINDOF(CTreeItem, ptiDropTarget);
            ASSERT_VALID(ptiDropTarget->Pci());

            if (ptiDropTarget->Pci() != Pframe()->PciDrag())
                ptiDropTarget->Pci()->DropItem(Pframe()->PciDrag());

        }  // if:  over a tree item
    }  // if:  tree item is being dragged

}  //*** CClusterTreeView::OnButtonUpForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::BeginDrag
//
//  Routine Description:
//      Called by the frame to begin a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::BeginDrag(void)
{
    Trace(g_tagTreeDrag, _T("BeginDrag()"));

}  //*** CClusterTreeView::BeginDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::EndDrag
//
//  Routine Description:
//      Called by the frame to end a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::EndDrag(void)
{
    // Cleanup.
    GetTreeCtrl().SelectDropTarget(NULL);
    m_htiDrag = NULL;
    m_ptiDrag = NULL;
    m_htiDrop = NULL;

    Trace(g_tagTreeDrag, _T("EndDrag()"));

}  //*** CClusterTreeView::EndDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PreTranslateMessage
//
//  Routine Description:
//      Translate window messages before they are dispatched.
//
//  Arguments:
//      pMsg    Points to a MSG structure that contains the message to process.
//
//  Return Value:
//      TRUE    Message was handled.
//      FALSE   Message was not handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::PreTranslateMessage(MSG * pMsg)
{
    BOOL    bForward    = FALSE;

    if (m_ptiBeingEdited != NULL)
    {
        CEdit * pedit = GetTreeCtrl().GetEditControl();
        ASSERT(pedit != NULL);

        if (pMsg->message == WM_KEYDOWN)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = TRUE;
            else if (pMsg->wParam == VK_CONTROL)
            {
                ::CopyMemory(&m_msgControl, pMsg, sizeof(m_msgControl));
                m_bControlPressed = TRUE;
            }  // else if:  control key pressed
            else if ((pMsg->wParam == VK_RETURN)
                        || (pMsg->wParam == VK_ESCAPE)
                        || (pMsg->wParam == VK_INSERT)
                        || (pMsg->wParam == VK_DELETE)
                        || (pMsg->wParam == VK_F1)
                        || (pMsg->wParam == VK_F5)
                        || (pMsg->wParam == VK_F6)
                        )
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
                if (m_bControlPressed)
                {
                    if (pMsg->wParam == VK_RETURN)
                        pedit->SendMessage(WM_KEYUP, m_msgControl.wParam, m_msgControl.lParam);
                }  // if:  control key pressed
            }  // else if:  editing key pressed
            else if ((pMsg->wParam == VK_TAB)
                        || (m_bControlPressed
                                && (_T('A') <= pMsg->wParam) && (pMsg->wParam <= _T('Y'))
                                && (pMsg->wParam != _T('C'))
                                && (pMsg->wParam != _T('H'))
                                && (pMsg->wParam != _T('M'))
                                && (pMsg->wParam != _T('V'))
                                && (pMsg->wParam != _T('X'))
                            )
                        )
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Ignoring WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                MessageBeep(MB_ICONEXCLAMATION);
                return TRUE;
            }  // else if:  key pressed that should be ignored
#ifdef NEVER
            else
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Not forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // if:  key pressed while editing label
        else if (pMsg->message == WM_SYSKEYDOWN)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = TRUE;
            else if ((pMsg->wParam == VK_RETURN)
                    )
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
            }  // else if:  editing key pressed
#ifdef NEVER
            else
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Not forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // else if:  system key pressed while editing label
        if (bForward)
        {
            pedit->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
            return TRUE;
        }  // if:  forwarding the message
        else if (pMsg->message == WM_KEYUP)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = FALSE;
            else if (pMsg->wParam == VK_CONTROL)
                m_bControlPressed = FALSE;
        }  // else if:  key up
        else if (pMsg->message == WM_SYSKEYUP)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = FALSE;
        }  // else if:  system key up
    }  // if:  editing a label

    return CTreeView::PreTranslateMessage(pMsg);

}  //*** CClusterTreeView::PreTranslateMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnCmdRename
//
//  Routine Description:
//      Processes the ID_FILE_RENAME menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnCmdRename(void)
{
    CTreeItem * ptiSelected = PtiSelected();

    // If an item has benn selected, begin label editing
    if (ptiSelected != NULL)
    {
        ASSERT_VALID(ptiSelected);
        ptiSelected->EditLabel(this);
    }  // if:  an item has the focus

}  //*** CClusterTreeView::OnCmdRename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnKeyDown
//
//  Routine Description:
//      Handler method for the TVN_KEYDOWN message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnKeyDown(NMHDR * pNMHDR, LRESULT * pResult)
{
    TV_KEYDOWN * pTVKeyDown = (TV_KEYDOWN *) pNMHDR;

    if (BDragging() && (pTVKeyDown->wVKey == VK_ESCAPE))
        Pframe()->AbortDrag();

    *pResult = 0;

}  //*** CClusterTreeView::OnKeyDown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceTag.h
//
//  Abstract:
//      Definition of the CTraceTag class.
//
//  Implementation File:
//      TraceTag.cpp
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag;
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define TRACE_TAG_REG_SECTION       TEXT("Debug")
#define TRACE_TAG_REG_SECTION_FMT   TRACE_TAG_REG_SECTION TEXT("\\%s")
#define TRACE_TAG_REG_FILE          TEXT("Trace File")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  CTraceTag
//
//  Purpose:
//      Object containing a specific set of trace settings allowing trace
//      output to go to multiple outputs.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag : public CString
{
    friend class CTraceDialog;
    friend void InitAllTraceTags(void);
    friend void CleanupAllTraceTags(void);

public:
    CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL);
    ~CTraceTag(void);

    enum    TraceFlags
    {
        tfCom2      = 1,
        tfFile      = 2,
        tfDebug     = 4,
        tfBreak     = 8
    };

// Attributes
protected:
    UINT        m_uiFlags;
    UINT        m_uiFlagsDialog;
    UINT        m_uiFlagsDefault;
    UINT        m_uiFlagsDialogStart;   // of Selection...

    LPCTSTR     m_pszSubsystem;
    LPCTSTR     m_pszName;

    LPCTSTR     PszSubsystem(void)                  { return m_pszSubsystem; }
    LPCTSTR     PszName(void)                       { return m_pszName; }

    void        ConstructRegState(OUT CString & rstr);

    void        SetFlags(IN UINT tf, IN BOOL bEnable);
    void        SetFlagsDialog(IN UINT tf, IN BOOL bEnable);

    void        SetBCom2(IN BOOL bEnable)           { SetFlags(tfCom2, bEnable); }
    void        SetBCom2Dialog(IN BOOL bEnable)     { SetFlagsDialog(tfCom2, bEnable); }
    BOOL        BCom2Dialog(void) const             { return m_uiFlagsDialog & tfCom2 ? TRUE : FALSE; }

    void        SetBFile(IN BOOL bEnable)           { SetFlags(tfFile, bEnable); }
    void        SetBFileDialog(IN BOOL bEnable)     { SetFlagsDialog(tfFile, bEnable); }
    BOOL        BFileDialog(void) const             { return m_uiFlagsDialog & tfFile ? TRUE : FALSE; }

    void        SetBDebug(IN BOOL bEnable)          { SetFlags(tfDebug, bEnable); }
    void        SetBDebugDialog(IN BOOL bEnable)    { SetFlagsDialog(tfDebug, bEnable); }
    BOOL        BDebugDialog(void) const            { return m_uiFlagsDialog & tfDebug ? TRUE : FALSE; }

    void        SetBBreak(IN BOOL bEnable)          { SetFlags(tfBreak, bEnable); }
    void        SetBBreakDialog(IN BOOL bEnable)    { SetFlagsDialog(tfBreak, bEnable); }
    BOOL        BBreakDialog(void) const            { return m_uiFlagsDialog & tfBreak ? TRUE : FALSE; }

public:
    BOOL        BCom2(void) const                   { return m_uiFlags & tfCom2 ? TRUE : FALSE; }
    BOOL        BFile(void) const                   { return m_uiFlags & tfFile ? TRUE : FALSE; }
    BOOL        BDebug(void) const                  { return m_uiFlags & tfDebug ? TRUE : FALSE; }
    BOOL        BBreak(void) const                  { return m_uiFlags & tfBreak ? TRUE : FALSE; }
    BOOL        BAny(void) const                    { return m_uiFlags != 0; }

// Operations
public:

// Implementation
public:
    void                TraceV(IN LPCTSTR pszFormat, va_list);

protected:
    void                Init(void);

    static LPCTSTR      s_pszCom2;
    static LPCTSTR      s_pszFile;
    static LPCTSTR      s_pszDebug;
    static LPCTSTR      s_pszBreak;

    static LPCTSTR      PszFile(void);

    static CTraceTag *  s_ptagFirst;
    static CTraceTag *  s_ptagLast;
    CTraceTag *         m_ptagNext;
//  static HANDLE           s_hfileCom2;

    static CRITICAL_SECTION s_critsec;
    static BOOL             s_bCritSecValid;

    static BOOL             BCritSecValid(void) { return s_bCritSecValid; }

};  //*** class CTraceTag

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 extern     CTraceTag               g_tagAlways;
 extern     CTraceTag               g_tagError;
 void __cdecl Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...);
 void       TraceError(IN OUT CException & rexcept);
 void       TraceError(IN LPCTSTR pszModule, IN SC sc);
 void       InitAllTraceTags(void);
 void       CleanupAllTraceTags(void);
 void       TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix);

// extern       LPTSTR      g_pszTraceIniFile;
 extern     CString     g_strTraceFile;
 extern     BOOL        g_bBarfDebug;

#else // _DEBUG

 //         Expand to ";", <tab>, one "/" followed by another "/"
 //         (which is //).
 //         NOTE: This means the Trace statements have to be on ONE line.
 //         If you need multiple line Trace statements, enclose them in
 //         a #ifdef _DEBUG block.
 #define    Trace                   ;   /##/
 inline void TraceError(IN OUT CException & rexcept)    { }
 inline void TraceError(IN LPCTSTR pszModule, IN SC sc) { }
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 inline void InitAllTraceTags(void)                     { }
 inline void CleanupAllTraceTags(void)                  { }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\treeview.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TreeView.h
//
//	Abstract:
//		Definition of the CClusterTreeView class.
//
//	Implementation File:
//		TreeView.cpp
//
//	Author:
//		David Potter (davidp)	May 1, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEVIEW_H_
#define _TREEVIEW_H_

/////////////////////////////////////////////////////////////////////////////
//	Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterTreeView;

/////////////////////////////////////////////////////////////////////////////
//	External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CSplitterFrame;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CClusterTreeView *, CClusterTreeView *> CClusterTreeViewList;

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "TreeItem.h"	// for CTreeItem
#endif

#ifndef _SPLITFRM_H
#include "SplitFrm.h"	// for CSplitterFrame
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterTreeView view
/////////////////////////////////////////////////////////////////////////////

class CClusterTreeView : public CTreeView
{
	friend class CTreeItem;
	friend class CClusterDoc;
	friend class CSplitterFrame;

protected: // create from serialization only
	CClusterTreeView(void);
	DECLARE_DYNCREATE(CClusterTreeView)

// Attributes
protected:
	CSplitterFrame *	m_pframe;

	BOOL				BDragging(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->BDragging(); }
	CImageList *		Pimagelist(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->Pimagelist(); }

public:
	CClusterDoc *		GetDocument(void);
	CSplitterFrame *	Pframe(void) const			{ return m_pframe; }
	CTreeItem *			PtiSelected(void) const;
	HTREEITEM			HtiSelected(void) const		{ return GetTreeCtrl().GetSelectedItem(); }

// Operations
public:
	CMenu *			PmenuPopup(
						IN CPoint &			rpointScreen,
						OUT CClusterItem *&	rpci
						);
	void			SaveCurrentSelection(void);
	void			ReadPreviousSelection(OUT CString & rstrSelection);

protected:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClusterTreeView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CClusterTreeView(void);
#ifdef _DEBUG
	virtual void	AssertValid(void) const;
	virtual void	Dump(CDumpContext& dc) const;
#endif

protected:
	// Label editing.
	CTreeItem *		m_ptiBeingEdited;
	BOOL			m_bShiftPressed;
	BOOL			m_bControlPressed;
	BOOL			m_bAltPressed;
	MSG				m_msgControl;

	// Drag & drop.
	HTREEITEM		m_htiDrag;
	CTreeItem *		m_ptiDrag;
	HTREEITEM		m_htiDrop;
	void			OnMouseMoveForDrag(IN UINT nFlags, IN CPoint point, IN const CWnd * pwndDrop);
	void			OnButtonUpForDrag(IN UINT nFlags, IN CPoint point);
	void			BeginDrag(void);
	void			EndDrag(void);
	
	BOOL			BAddItems(
						IN OUT CTreeItem *	pti,
						IN const CString &	rstrSelection,
						IN BOOL				bExpanded = FALSE
						);

// Generated message map functions
protected:
	//{{AFX_MSG(CClusterTreeView)
	afx_msg void OnDestroy();
	afx_msg void OnCmdRename();
	afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBeginLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in TreeView.cpp
inline CClusterDoc * CClusterTreeView::GetDocument(void)
   { return (CClusterDoc *) m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\treeitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TreeItem.h
//
//	Abstract:
//		Definition of the CTreeItem class.
//
//	Implementation File:
//		TreeItem.cpp
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#define _TREEITEM_H_

#ifndef __AFXTEMPL_H__
#include "afxtempl.h"	// for CList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CTreeItemList;
class CTreeItemContext;
class CTreeItem;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CSplitterFrame;
class CClusterListView;
class CClusterTreeView;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CTreeItemContext *, CTreeItemContext *> CTreeItemContextList;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASECMDT_H_
#include "BaseCmdT.h"	// for CBaseCmdTarget
#endif

#ifndef _COLITEM_H_
#include "ColItem.h"	// for CColumnItem
#endif

#ifndef _LISTITEM_H_
#include "ListItem.h"	// for CListItemList
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeItemList
/////////////////////////////////////////////////////////////////////////////

class CTreeItemList : public CList<CTreeItem *, CTreeItem *>
{
public:
	CTreeItem *		PtiFromPci(
						IN const CClusterItem *	pci,
						OUT POSITION *			ppos = NULL
						) const;

	// add before head or after tail
	POSITION AddHead(CTreeItem * newElement);
	POSITION AddTail(CTreeItem * newElement);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CTreeItem * newElement);
	POSITION InsertAfter(POSITION position, CTreeItem * newElement);

};  //*** class CTreeItemList

/////////////////////////////////////////////////////////////////////////////
// CTreeItemContext
/////////////////////////////////////////////////////////////////////////////

class CTreeItemContext : public CObject
{
	DECLARE_DYNCREATE(CTreeItemContext)

public:
	CSplitterFrame *	m_pframe;
	CTreeItem *			m_pti;
	HTREEITEM			m_hti;
	BOOL				m_bExpanded;
	DWORD *				m_prgnColumnInfo;

	CTreeItemContext(void)
	{
		CommonConstruct();
	};
	CTreeItemContext(
		CSplitterFrame *	pframe,
		CTreeItem *			pti,
		HTREEITEM			hti,
		BOOL				bExpanded
		)
	{
		CommonConstruct();
		m_pframe = pframe;
		m_pti = pti;
		m_hti = hti;
		m_bExpanded = bExpanded;
	}
	~CTreeItemContext(void)
	{
		SaveProfileInfo();
		delete [] m_prgnColumnInfo;
		m_prgnColumnInfo = NULL;
	}
		
	void CommonConstruct(void)
	{
		m_pframe = NULL;
		m_pti = NULL;
		m_hti = NULL;
		m_bExpanded = FALSE;
		m_prgnColumnInfo = NULL;
	}
	void Init(void);
	void SaveProfileInfo(void);
	DWORD * PrgnColumnInfo(void);

	BOOL BIsExpanded(void) const;

};  //*** class CTreeItemContext

/////////////////////////////////////////////////////////////////////////////
// CTreeItem command target
/////////////////////////////////////////////////////////////////////////////

class CTreeItem : public CBaseCmdTarget
{
	friend class CClusterTreeView;

	DECLARE_DYNCREATE(CTreeItem)

	CTreeItem(void);				// protected constructor used by dynamic creation
	CTreeItem(IN OUT CTreeItem * ptiParent, IN OUT CClusterItem * pci, IN BOOL m_fTakeOwnership = FALSE);
	void					Init(void);

// Attributes
protected:
	CTreeItem *				m_ptiParent;
	CClusterItem *			m_pci;
	BOOL					m_bWeOwnPci;
	CString					m_strProfileSection;

	CColumnItemList			m_lpcoli;
	CTreeItemList			m_lptiChildren;
	CListItemList			m_lpliChildren;

	CTreeItemContextList	m_lptic;

	const CTreeItemContextList &	Lptic(void) const		{ return m_lptic; }

public:
	CTreeItem *				PtiParent(void) const			{ return m_ptiParent; }
	CClusterItem *			Pci(void) const					{ return m_pci; }
	const CString &			StrProfileSection(void);

	const CColumnItemList &	Lpcoli(void) const				{ return m_lpcoli; }
	const CTreeItemList &	LptiChildren(void) const		{ return m_lptiChildren; }
	const CListItemList &	LpliChildren(void) const		{ return m_lpliChildren; }

	const CString &			StrName(void) const;

	DWORD *					PrgnColumnInfo(IN const CClusterListView * pclv)
	{
		CTreeItemContext *	ptic;

		ptic = PticFromView(pclv);
		ASSERT_VALID(ptic);
		return ptic->PrgnColumnInfo();

	}  //*** CTreeItem::PrgnColumnInfo()

// Operations
public:
	HTREEITEM				HtiInsertInTree(IN OUT CClusterTreeView * pctv);
	void					RemoveFromAllLists(void);
	void					PreRemoveFromFrame(IN OUT CSplitterFrame * pframe);
	void					PreRemoveFromFrameWithChildren(IN OUT CSplitterFrame * pframe);
	CColumnItem *			PcoliAddColumn(
								IN const CString &	rstrText,
								IN IDS				idsColumnID,
								IN int				nDefaultWidth = -1,
								IN int				nWidth = -1
								);
	CColumnItem *			PcoliAddColumn(IN IDS idsText, IN int nDefaultWidth = -1, IN int nWidth = -1);
	void					DeleteAllColumns(void)			{ m_lpcoli.RemoveAll(); }
	void					UpdateState(void);
	void					UpdateAllStatesInTree(void);
	void					UpdateUIState(void);

	void					Select(IN OUT CClusterTreeView * pctv, IN BOOL bSelectInTree);
//	void					Unselect(CClusterTreeView * pctv);

	CTreeItem *				PtiAddChildBefore(
								IN const CClusterItem *	pciOld,
								OUT CClusterItem *		pciNew,
								IN BOOL					bTakeOwnership = FALSE
								);
	void					InsertChildInAllTrees(IN OUT CTreeItem * ptiNewChild);
	CTreeItem *				PtiAddChild(IN OUT CClusterItem * pci, IN BOOL bTakeOwnership = FALSE);
	CTreeItem *				PtiAddChild(IN const CString & rstrName);
	CTreeItem *				PtiAddChild(IN IDS idsName);
	CListItem *				PliAddChild(IN OUT CClusterItem * pci);

	CTreeItem *				PtiChildFromName(IN const CString & rstrName, OUT POSITION * ppos = NULL) const;
	CTreeItem *				PtiChildFromName(IN IDS idsName, OUT POSITION * ppos = NULL) const;
	CTreeItem *				PtiChildFromPci(IN const CClusterItem * pci) const;
	CListItem *				PliChildFromPci(IN const CClusterItem * pci) const;

	void					RemoveItem(void);
	void					RemoveChild(IN OUT CClusterItem * pci);

	CMenu *					PmenuPopup(void);
	BOOL					BSelectItem(IN OUT CClusterTreeView * pctv);
	BOOL					BExpand(IN OUT CClusterTreeView * pctv, IN UINT nCode);
	void					SelectInAllViews(void);
	void					ExpandInAllViews(IN UINT nCode);
	void					SetExpandedState(IN const CClusterTreeView * pctv, IN BOOL bExpanded);
	BOOL					BShouldBeExpanded(IN const CClusterTreeView * pctv) const;

	void					OpenChild(IN OUT CTreeItem * pti, IN OUT CSplitterFrame * pframe);
	void					EditLabel(IN OUT CClusterTreeView * pctv);

	void					Delete(void);

protected:
	void					Cleanup(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeItem)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual					~CTreeItem(void);

protected:
	CTreeItemContext *		PticFromFrame(IN const CSplitterFrame * pframe) const;
	CTreeItemContext *		PticFromView(IN const CClusterTreeView * pctv) const;
	CTreeItemContext *		PticFromView(IN const CClusterListView * pclv) const;
	HTREEITEM				HtiFromView(IN const CClusterTreeView * pctv) const;

	// Generated message map functions
	//{{AFX_MSG(CTreeItem)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CTreeItem

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DestructElements(CTreeItem ** pElements, int nCount);
void DeleteAllItemData(IN OUT CTreeItemList & rlp);
void DeleteAllItemData(IN OUT CTreeItemContextList & rlp);

/////////////////////////////////////////////////////////////////////////////
// Inline Functions
/////////////////////////////////////////////////////////////////////////////

inline POSITION CTreeItemList::AddHead(CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::AddHead(newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::AddHead()

inline POSITION CTreeItemList::AddTail(CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::AddTail(newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::AddTail()

inline POSITION CTreeItemList::InsertBefore(POSITION position, CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::InsertBefore(position, newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::InsertBefore()

inline POSITION CTreeItemList::InsertAfter(POSITION position, CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::InsertAfter(position, newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::InsertAfter()

/////////////////////////////////////////////////////////////////////////////

#endif // _TREEITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\verinfo.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		VerInfo.h
//
//	Abstract:
//		Definition of the CVersionInfo class.
//
//	Implementation File:
//		VerInfo.cpp
//
//	Author:
//		David Potter (davidp)	October 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _VERINFO_H_
#define _VERINFO_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CVersionInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVersionInfo:
/////////////////////////////////////////////////////////////////////////////

class CVersionInfo
{
public:
	// Construction
	CVersionInfo(void);
	~CVersionInfo(void);

	// Secondary construction.
	void		Init(void);

// Operations
public:
	LPCTSTR		PszQueryValue(IN LPCTSTR pszValueName);
	BOOL		BQueryValue(
					IN LPCTSTR	pszValueName,
					OUT DWORD &	rdwValue
					);
	const VS_FIXEDFILEINFO *	PffiQueryValue(void);
	void		QueryFileVersionDisplayString(OUT CString & rstrValue);

// Implementation
protected:
	LPBYTE		m_pbVerInfo;

	LPBYTE		PbVerInfo(void)		{ return m_pbVerInfo; }

};  //*** class CVersionInfo

/////////////////////////////////////////////////////////////////////////////

#endif // _VERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\yestoall.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		YesToAll.h
//
//	Abstract:
//		Definition of the CYesToAllDialog class.
//
//	Implementation File:
//		YesToAll.cpp
//
//	Author:
//		David Potter (davidp)	May 20, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _YESTOALL_H_
#define _YESTOALL_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CYesToAllDialog;

/////////////////////////////////////////////////////////////////////////////
// class CYesToAllDialog
/////////////////////////////////////////////////////////////////////////////

class CYesToAllDialog : public CDialog
{
// Construction
public:
	CYesToAllDialog(LPCTSTR pszMessage, CWnd * pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CYesToAllDialog)
	enum { IDD = IDD_YESTOALL };
	CString	m_strMessage;
	//}}AFX_DATA
	LPCTSTR	m_pszMessage;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CYesToAllDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CYesToAllDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	afx_msg void OnYesToAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CYesToAllDialog

/////////////////////////////////////////////////////////////////////////////

#endif // _YESTOALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\verinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      VerInfo.cpp
//
//  Abstract:
//      Implementation of the CVersionInfo class.
//
//  Author:
//      David Potter (davidp)   October 11, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VerInfo.h"
#include "ExcOper.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagVersionInfo(_T("Misc"), _T("CVersionInfo"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CVersionInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::CVersionInfo
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CVersionInfo::CVersionInfo(void)
{
    m_pbVerInfo = NULL;

}  //*** CVersionInfo::CVersionInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::~CVersionInfo
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CVersionInfo::~CVersionInfo(void)
{
    delete [] m_pbVerInfo;

}  //*** CVersionInfo::~CVersionInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::Init
//
//  Routine Description:
//      Initialize the class instance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from GetModuleFileName(),
//                              GetFileVersionInfoSize(), and
//                              GetFileVersionInfo().
//      Any exceptions thrown by new[]().
//--
/////////////////////////////////////////////////////////////////////////////
void CVersionInfo::Init(void)
{
    TCHAR       szExeName[MAX_PATH];
    DWORD       dwVerHandle;
    DWORD       cbVerInfo;

    ASSERT(m_pbVerInfo == NULL);

    // Get the name of the file from which to read version information.
    if (!::GetModuleFileName(
                    AfxGetInstanceHandle(),
                    szExeName,
                    sizeof(szExeName) / sizeof(TCHAR)
                    ))
        ThrowStaticException(::GetLastError());

    // Trace(...)

    try
    {
        // Get the size of the version information
        cbVerInfo = ::GetFileVersionInfoSize(szExeName, &dwVerHandle);
        if (cbVerInfo == 0)
            ThrowStaticException(::GetLastError());

        // Allocate the version info buffer.
        m_pbVerInfo = new BYTE[cbVerInfo];
        if ( m_pbVerInfo == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the version info buffer

        // Read the version info from the file.
        if (!::GetFileVersionInfo(szExeName, dwVerHandle, cbVerInfo, PbVerInfo()))
            ThrowStaticException(::GetLastError());
    }  // try
    catch (CException *)
    {
        delete [] m_pbVerInfo;
        m_pbVerInfo = NULL;
        throw;
    }  // catch:  CException

}  //*** CVersionInfo::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::PszQueryValue
//
//  Routine Description:
//      Read a string value from the version resource.
//
//  Arguments:
//      pszValueName    [IN] Name of value to get.
//
//  Return Value:
//      Pointer to value string buffer.
//      The string pointed to belongs to CVersionInfo and
//      is valid until the object is destructed.
//
//  Exceptions Thrown:
//      CNTException        Errors from VerQueryValue().
//      Any exceptions thrown by CString::Format().
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CVersionInfo::PszQueryValue(IN LPCTSTR pszValueName)
{
    CString     strValueName;
    LPDWORD     pdwTranslation;
    LPTSTR      pszReturn;
    UINT        cbReturn;
    UINT        cchReturn;

    ASSERT(pszValueName != NULL);
    ASSERT(PbVerInfo() != NULL);

    // Get the LangID and CharSetID.
    strValueName = _T("\\VarFileInfo\\Translation");
    if (!::VerQueryValue(
                PbVerInfo(),
                (LPTSTR) (LPCTSTR) strValueName,
                (LPVOID *) &pdwTranslation,
                &cbReturn
                )
            || (cbReturn == 0))
    {
        pszReturn = NULL;
    }  // if:  error getting LangID and CharSetID
    else
    {
        // Construct the name of the value to read.
        strValueName.Format(
                        _T("\\StringFileInfo\\%04X%04X\\%s"), 
                        LOWORD(*pdwTranslation), // LangID
                        HIWORD(*pdwTranslation), // CharSetID
                        pszValueName
                        );
        Trace(g_tagVersionInfo, _T("Querying '%s'"), strValueName);

        // Read the value.
        if (!::VerQueryValue(
                    PbVerInfo(),
                    (LPTSTR) (LPCTSTR) strValueName,
                    (LPVOID *) &pszReturn,
                    &cchReturn
                    )
                || (cchReturn == 0))
            pszReturn = NULL;
    }  // else:  

#ifdef _DEBUG
    if (pszReturn != NULL)
        Trace(g_tagVersionInfo, _T("PszQueryValue(%s) = '%s'"), pszValueName, pszReturn);
    else
        Trace(g_tagVersionInfo, _T("PszQueryValue(%s) = Not Available"), pszValueName);
#endif

    return pszReturn;

}  //*** CVersionInfo::PszQueryValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::BQueryValue
//
//  Routine Description:
//      Read a value from the version resource.
//
//  Arguments:
//      pszValueName    [IN] Name of value to get.
//      rdwValue        [OUT] DWORD in which to return the value.
//
//  Return Value:
//      TRUE = success, FALSE = failure
//
//  Exceptions Thrown:
//      None.
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CVersionInfo::BQueryValue(
    IN LPCTSTR  pszValueName,
    OUT DWORD & rdwValue
    )
{
    BOOL        bSuccess;
    UINT        cbReturn;
    DWORD *     pdwValue;

    ASSERT(pszValueName != NULL);
    ASSERT(PbVerInfo() != NULL);

    // Read the value.
    if (!::VerQueryValue(
                PbVerInfo(),
                (LPTSTR) pszValueName,
                (LPVOID *) &pdwValue,
                &cbReturn
                )
            || (cbReturn == 0))
        bSuccess = FALSE;
    else
    {
        rdwValue = *pdwValue;
        bSuccess = TRUE;
    }  // else:  value read successfully

#ifdef _DEBUG
    if (bSuccess)
        Trace(g_tagVersionInfo, _T("BQueryValue(%s) = '%lx'"), pszValueName, rdwValue);
    else
        Trace(g_tagVersionInfo, _T("BQueryValue(%s) = Not Available"), pszValueName);
#endif

    return bSuccess;

}  //*** CVersionInfo::BQueryValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::PffiQueryValue
//
//  Routine Description:
//      Read the VS_FIXEDFILEINFO information from the version resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pffi            Pointer to a VS_FIXEDFILEINFO structure.  The buffer
//                          pointerd to belongs to CVersionInfo and is valid
//                          until the object is destructed.
//
//  Exceptions Thrown:
//      CNTException        Errors from VerQueryValue().
//      Any exceptions thrown by CString::Format().
//--
/////////////////////////////////////////////////////////////////////////////
const VS_FIXEDFILEINFO * CVersionInfo::PffiQueryValue(void)
{
    VS_FIXEDFILEINFO *  pffi;
    UINT                cbReturn;

    ASSERT(PbVerInfo() != NULL);

    // Read the FixedFileInfo.
    if (!::VerQueryValue(PbVerInfo(), _T("\\"), (LPVOID *) &pffi, &cbReturn)
            || (cbReturn == 0))
        pffi = NULL;

#ifdef _DEBUG
    if (pffi != NULL)
        Trace(g_tagVersionInfo, _T("PffiQueryValue() version = %d.%d.%d.%d"),
            HIWORD(pffi->dwFileVersionMS),
            LOWORD(pffi->dwFileVersionMS),
            HIWORD(pffi->dwFileVersionLS),
            LOWORD(pffi->dwFileVersionLS));
    else
        Trace(g_tagVersionInfo, _T("PffiQueryValue() = Not Available"));
#endif

    return pffi;

}  //*** CVersionInfo::PffiQueryValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::QueryFileVersionDisplayString
//
//  Routine Description:
//      Read the file version as a display string from the version resource.
//
//  Arguments:
//      rstrValue   [OUT] String in which to return the version display string.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        ERROR_RESOURCE_TYPE_NOT_FOUND.
//      Any exceptions thrown by CString::Format().
//--
/////////////////////////////////////////////////////////////////////////////
void CVersionInfo::QueryFileVersionDisplayString(OUT CString & rstrValue)
{
    const VS_FIXEDFILEINFO *    pffi;

    // Get the file version information.
    pffi = PffiQueryValue();
    if (pffi == NULL)
        ThrowStaticException((SC) ERROR_RESOURCE_TYPE_NOT_FOUND);

    // Format the display string.
    rstrValue.Format(
        IDS_VERSION_NUMBER_FORMAT,
        HIWORD(pffi->dwFileVersionMS),
        LOWORD(pffi->dwFileVersionMS),
        HIWORD(pffi->dwFileVersionLS),
        LOWORD(pffi->dwFileVersionLS)
        );

    Trace(g_tagVersionInfo, _T("QueryFileVersionDisplayString() = %s"), rstrValue);

}  //*** CVersionInfo::QueryFileVersionDisplayString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\yestoall.cpp ===
// YesToAll.cpp : implementation file
//

#include "stdafx.h"
#include "cluadmin.h"
#include "YesToAll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CYesToAllDialog dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CYesToAllDialog, CDialog)
	//{{AFX_MSG_MAP(CYesToAllDialog)
	ON_BN_CLICKED(IDYES, OnYes)
	ON_BN_CLICKED(IDNO, OnNo)
	ON_BN_CLICKED(IDC_YTA_YESTOALL, OnYesToAll)
	//}}AFX_MSG_MAP
	ON_COMMAND(IDCANCEL, OnNo)
	ON_COMMAND(IDOK, OnYes)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::CYesToAllDialog
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		pszMessage	[IN] Message to display.
//		pParent		[IN] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CYesToAllDialog::CYesToAllDialog(LPCTSTR pszMessage, CWnd * pParent /*=NULL*/)
	: CDialog(IDD, pParent)
{
	//{{AFX_DATA_INIT(CYesToAllDialog)
	m_strMessage = _T("");
	//}}AFX_DATA_INIT

	ASSERT(pszMessage != NULL);
	m_pszMessage = pszMessage;

}  //*** CYesToAllDialog::CYesToAllDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::DoDataExchange(CDataExchange * pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CYesToAllDialog)
	DDX_Text(pDX, IDC_YTA_MESSAGE, m_strMessage);
	//}}AFX_DATA_MAP

}  //*** CYesToAllDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CYesToAllDialog::OnInitDialog(void)
{
	LPCTSTR	pszAppName;

	m_strMessage = m_pszMessage;

	CDialog::OnInitDialog();

	pszAppName = AfxGetApp()->m_pszAppName;
	SetWindowText(pszAppName);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CYesToAllDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnYes
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Yes push button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::OnYes(void)
{
	EndDialog(IDYES);

}  //*** CYesToAllDialog::OnYes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnNo
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the No push button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::OnNo(void)
{
	EndDialog(IDNO);

}  //*** CYesToAllDialog::OnNo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnYesToAll
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Yes To All push button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::OnYesToAll(void)
{
	EndDialog(IDC_YTA_YESTOALL);

}  //*** CYesToAllDialog::OnYesToAll()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\waitdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      WaitDlg.h
//
//  Implementation File:
//      WaitDlg.cpp
//
//  Description:
//      Definition of the CWaitDlg class.
//
//  Maintained By:
//      David Potter (davidp)   07-NOV-2000
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWaitDlg;
class CWaitForResourceOfflineDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RES_H_
#include "Res.h"    // for CResource
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWaitDlg
//
//  Description:
//      Display a dialog while waiting for something to complete.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWaitDlg : public CDialog
{
public:
    CWaitDlg(
        LPCTSTR pcszMessageIn,
        UINT    idsTitleIn      = 0,
        CWnd *  pwndParentIn    = NULL
        );

// Dialog Data
    //{{AFX_DATA(CWaitDlg)
    enum { IDD = IDD_WAIT };
    CStatic m_staticMessage;
    CStatic m_iconProgress;
    CString m_strMessage;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWaitDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWaitDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnTimer(UINT nIDTimer);
    afx_msg void OnClose();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void OnTimerTick( void )
    {
        CDialog::OnOK();

    } //*** CWaitDlg::OnTimerTick()

    void    UpdateIndicator( void );
    void    CloseTimer( void );

    CString     m_strTitle;
    UINT        m_idsTitle;
    UINT_PTR    m_timerId;
    int         m_nTickCounter;
    int         m_nTotalTickCount;

}; //*** class CWaitDlg

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWaitForResourceOfflineDlg
//
//  Description:
//      Display a dialog while waiting for a resource to go offline.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWaitForResourceOfflineDlg : public CWaitDlg
{
public:
    CWaitForResourceOfflineDlg(
        CResource const *   pResIn,
        CWnd *              pwndParentIn = NULL
        );

// Dialog Data
    //{{AFX_DATA(CWaitForResourceOfflineDlg)
    enum { IDD = IDD_WAIT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWaitForResourceOfflineDlg)
    protected:
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWaitForResourceOfflineDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void OnTimerTick( void );

    CResource const *   m_pRes;

}; //*** class CWaitForResourceOfflineDlg

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWaitForResourceOnlineDlg
//
//  Description:
//      Display a dialog while waiting for a resource to go online.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWaitForResourceOnlineDlg : public CWaitDlg
{
public:
    CWaitForResourceOnlineDlg(
        CResource const *   pResIn,
        CWnd *              pwndParentIn = NULL
        );

// Dialog Data
    //{{AFX_DATA(CWaitForResourceOnlineDlg)
    enum { IDD = IDD_WAIT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWaitForResourceOnlineDlg)
    protected:
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWaitForResourceOnlineDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void OnTimerTick( void );

    CResource const *   m_pRes;

}; //*** class CWaitForResourceOnlineDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\basedata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BaseData.h
//
//  Abstract:
//      Definition of the CBaseSnapInDataInterface template class.
//
//  Implementation File:
//      BaseData.cpp
//
//  Author:
//      David Potter (davidp)   November 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEDATA_H_
#define __BASEDATA_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseNodeObj;
template < class T > class CBaseNodeObjImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_
#include "CompData.h"   // for CClusterComponentData
#endif

/////////////////////////////////////////////////////////////////////////////
// class CBaseNodeObj
/////////////////////////////////////////////////////////////////////////////

class CBaseNodeObj
{
public:
    //
    // Object construction and destruction.
    //

    CBaseNodeObj( CClusterComponentData * pcd )
    {
        _ASSERTE( pcd != NULL );
        m_pcd = pcd;

    } //*** CBaseNodeObj()

    ~CBaseNodeObj( void )
    {
        m_pcd = NULL;

    } //*** ~CBaseNodeObj()

public:
    //
    // CBaseNodeObj-specific methods.
    //

    // Object is being destroyed
    STDMETHOD( OnDestroy )( void ) = 0;

    // Set the scope pane ID.
    STDMETHOD_( void, SetScopePaneID )( HSCOPEITEM hsi ) = 0;

public:
    //
    // IConsole methods through m_pcd.
    //

    // Returns a handle to the main frame window
    HWND GetMainWindow( void )
    {
        _ASSERTE( m_pcd != NULL );
        return m_pcd->GetMainWindow();

    } //*** GetMainWindow()

    // Display a message box as a child of the console
    int MessageBox(
        LPCWSTR lpszText,
        LPCWSTR lpszTitle = NULL,
        UINT fuStyle = MB_OK
        )
    {
        _ASSERTE( m_pcd != NULL );
        return m_pcd->MessageBox( lpszText, lpszTitle, fuStyle );

    } //*** MessageBox()

protected:
    CClusterComponentData * m_pcd;

public:
    CClusterComponentData * Pcd( void )
    {
        return m_pcd;

    } //*** Pcd()

}; //*** class CBaseNodeObj

/////////////////////////////////////////////////////////////////////////////
// class CBaseNodeObjImpl
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CBaseNodeObjImpl :
    public CSnapInItemImpl< T >,
    public CBaseNodeObj
{
public:
    //
    // Construction and destruction.
    //

    CBaseNodeObjImpl( CClusterComponentData * pcd ) : CBaseNodeObj( pcd )
    {
    } //*** CBaseNodeObjImpl()

public:
    //
    // CBaseNodeObj methods.
    //

    // Object is being destroyed
    STDMETHOD( OnDestroy )( void )
    {
        return S_OK;

    } //*** OnDestroy()

    // Set the scope pane ID.
    STDMETHOD_( void, SetScopePaneID )( HSCOPEITEM hsi )
    {
        m_scopeDataItem.ID = hsi;

    } //*** SetScopePaneID()

public:
    //
    // CBaseNodeObjImpl-specific methods.
    //

    // Insert the item into the namespace (scope pane)
    HRESULT InsertIntoNamespace( HSCOPEITEM hsiParent )
    {
        _ASSERTE( m_pcd != NULL );
        _ASSERTE( m_pcd->m_spConsoleNameSpace != NULL );

        HRESULT         hr = S_OK;
        SCOPEDATAITEM   sdi;

        ZeroMemory( &sdi, sizeof(sdi) );

        //
        // Fill in the scope data item structure.
        //
        sdi.mask        = SDI_STR
                            | SDI_IMAGE
                            | SDI_OPENIMAGE
                            | SDI_PARAM
                            | SDI_PARENT;
        sdi.displayname = MMC_CALLBACK;
        sdi.nImage      = m_scopeDataItem.nImage;
        sdi.nOpenImage  = m_scopeDataItem.nImage;
        sdi.lParam      = (LPARAM) this;
        sdi.relativeID  = hsiParent;

        //
        // Insert the item into the namespace.
        //
        hr = m_pcd->m_spConsoleNameSpace->InsertItem( &sdi );
        if ( SUCCEEDED(hr) )
            m_scopeDataItem.ID = hsiParent;

        return hr;

    } //*** InsertIntoNamespace()

public:
    //
    // CSnapInItem methods
    //

    STDMETHOD_( LPWSTR, PszGetDisplayName )( void ) = 0;

    // Get display info for a scope pane item
    STDMETHOD( GetScopePaneInfo )(
        SCOPEDATAITEM * pScopeDataItem
        )
    {
        _ASSERTE( pScopeDataItem != NULL );

        if ( pScopeDataItem->mask & SDI_STR )
        {
            pScopeDataItem->displayname = PszGetDisplayName();
        }
        if ( pScopeDataItem->mask & SDI_IMAGE )
        {
            pScopeDataItem->nImage = m_scopeDataItem.nImage;
        }
        if ( pScopeDataItem->mask & SDI_OPENIMAGE )
        {
            pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
        }
        if ( pScopeDataItem->mask & SDI_PARAM )
        {
            pScopeDataItem->lParam = m_scopeDataItem.lParam;
        }
        if ( pScopeDataItem->mask & SDI_STATE )
        {
            pScopeDataItem->nState = m_scopeDataItem.nState;
        }

        return S_OK;

    } //*** GetScopePaneInfo()

    // Get display info for a result pane item
    STDMETHOD( GetResultPaneInfo )(
        RESULTDATAITEM * pResultDataItem
        )
    {
        _ASSERTE( pResultDataItem != NULL );

        if ( pResultDataItem->bScopeItem )
        {
            if ( pResultDataItem->mask & RDI_STR )
            {
                pResultDataItem->str = GetResultPaneColInfo( pResultDataItem->nCol );
            }
            if ( pResultDataItem->mask & RDI_IMAGE )
            {
                pResultDataItem->nImage = m_scopeDataItem.nImage;
            }
            if ( pResultDataItem->mask & RDI_PARAM )
            {
                pResultDataItem->lParam = m_scopeDataItem.lParam;
            }

            return S_OK;
        }

        if ( pResultDataItem->mask & RDI_STR )
        {
            pResultDataItem->str = GetResultPaneColInfo( pResultDataItem->nCol );
        }
        if ( pResultDataItem->mask & RDI_IMAGE )
        {
            pResultDataItem->nImage = m_resultDataItem.nImage;
        }
        if ( pResultDataItem->mask & RDI_PARAM )
        {
            pResultDataItem->lParam = m_resultDataItem.lParam;
        }
        if ( pResultDataItem->mask & RDI_INDEX )
        {
            pResultDataItem->nIndex = m_resultDataItem.nIndex;
        }
        return S_OK;

    } //*** GetResultPaneInfo()

    // Get column info for the result pane
    virtual LPOLESTR GetResultPaneColInfo( int nCol )
    {
        LPOLESTR polesz = L"";

        switch ( nCol )
        {
            case 0:
                polesz = PszGetDisplayName();
                break;
        } // switch:  nCol

        return polesz;

    } //*** GetResultPaneColInfo()

}; //*** class CBaseNodeObjImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\waitdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      WaitDlg.cpp
//
//  Abstract:
//      Implementation of the CWaitDlg class.
//
//  Author:
//      David Potter (davidp)   07-NOV-2000
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "CluAdmin.h"
#include "WaitDlg.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define WAIT_DLG_TIMER_ID   10
#define WAIT_DLG_WAIT_TIME  500
#define WAIT_DLG_SKIP_COUNT 6
#define PROGRESS_ICON_COUNT 12

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CWaitDlg, CDialog )
    //{{AFX_MSG_MAP(CWaitDlg)
    ON_BN_CLICKED(IDCANCEL, OnCancel)
    ON_WM_CLOSE()
    ON_WM_TIMER()
    ON_COMMAND(IDCANCEL, OnClose)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::CWaitDlg
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pcszMessageIn   -- Message to display.
//      idsTitleIn      -- Title of the dialog.
//      pwndParentIn    -- Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWaitDlg::CWaitDlg(
    LPCTSTR pcszMessageIn,
    UINT    idsTitleIn,     // = 0
    CWnd *  pwndParentIn    // = NULL
    )
    : CDialog( IDD, pwndParentIn )
    , m_idsTitle( idsTitleIn )
    , m_nTickCounter( WAIT_DLG_SKIP_COUNT )
    , m_nTotalTickCount( 0 )
    , m_timerId( 0 )
{
    //{{AFX_DATA_INIT(CWaitDlg)
    //}}AFX_DATA_INIT

    m_strMessage = pcszMessageIn;
    if ( m_idsTitle == 0 )
    {
        m_idsTitle = IDS_WAIT_TITLE;
    }

} //*** CWaitDlg::CWaitDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::DoDataExchange( CDataExchange * pDX )
{
    CDialog::DoDataExchange( pDX );
    //{{AFX_DATA_MAP(CWaitDlg)
    DDX_Control(pDX, IDC_W_MESSAGE, m_staticMessage);
    DDX_Control(pDX, IDC_W_PROGRESS, m_iconProgress);
    DDX_Text(pDX, IDC_W_MESSAGE, m_strMessage);
    //}}AFX_DATA_MAP

} //*** CWaitDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CWaitDlg::OnInitDialog(void)
{
    CString strSubTitle;

    CDialog::OnInitDialog();

    // Start the timer.
    m_timerId = SetTimer( WAIT_DLG_TIMER_ID, WAIT_DLG_WAIT_TIME, NULL );

    // Set the title of the dialog.
    strSubTitle.LoadString( m_idsTitle );
    m_strTitle.Format( _T("%s - %s"), AfxGetApp()->m_pszAppName, strSubTitle );
    SetWindowText( m_strTitle );

    // Update the progress indicator.
    UpdateIndicator();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

} //*** CWaitDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::OnClose
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Cancel push button and
//      for the WM_CLOSE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::OnClose( void )
{
    CloseTimer();
    CDialog::OnClose();

}  //*** CWaitDlg::OnClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::CloseTimer
//
//  Routine Description:
//      Close the timer down.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::CloseTimer( void )
{
    if ( m_timerId != 0 )
    {
        KillTimer( m_timerId );
    } // if: timer is active

    m_timerId = 0;

}  //*** CWaitDlg::CloseTimer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::OnTimer
//
//  Routine Description:
//      Handler for the WM_TIMER message..
//
//  Arguments:
//      nIDTimer
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::OnTimer( UINT nIDTimer )
{
    //
    // Don't do anything if it isn't our timer.
    //
    if ( nIDTimer != WAIT_DLG_TIMER_ID )
        goto Cleanup;

    //
    //  Advance the progress indicator.
    //
    UpdateIndicator();

    //
    //  No need to continue if we're just amusing the user.
    //
    if ( --m_nTickCounter > 0 )
        goto Cleanup;

    m_nTickCounter = WAIT_DLG_SKIP_COUNT;

    //
    // Check here to see if we can exit out.
    // This method is typically overridden.
    //
    OnTimerTick();

Cleanup:
    return;

}  //*** CWaitDlg::OnTimer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::UpdateIndicator
//
//  Routine Description:
//      Update the indicator control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::UpdateIndicator( void )
{
    if ( m_nTotalTickCount % (1000 / WAIT_DLG_WAIT_TIME) == 0 )
    {
        int     nTempTickCount = m_nTotalTickCount / (1000 / WAIT_DLG_WAIT_TIME);
        HICON   hIcon;

        hIcon = AfxGetApp()->LoadIcon( IDI_PROGRESS_0 + (nTempTickCount % PROGRESS_ICON_COUNT) );
        m_iconProgress.SetIcon( hIcon );
    } // if: advancing to the next image
    
    m_nTotalTickCount++;

} //*** CWaitDlg::UpdateIndicator()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CWaitForResourceOfflineDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CWaitForResourceOfflineDlg, CWaitDlg )
    //{{AFX_MSG_MAP(CWaitForResourceOfflineDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOfflineDlg::CWaitForResourceOfflineDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pResIn          -- Resource to wait on.
//      pwndParentIn    -- Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWaitForResourceOfflineDlg::CWaitForResourceOfflineDlg(
    CResource const *   pResIn,
    CWnd *              pwndParentIn    // = NULL
    )
    : CWaitDlg( NULL, IDS_WAIT_FOR_OFFLINE_TITLE, pwndParentIn )
    , m_pRes( pResIn )
{
    ASSERT( pResIn != NULL );

    //{{AFX_DATA_INIT(CWaitForResourceOfflineDlg)
    //}}AFX_DATA_INIT

} //*** CWaitForResourceOfflineDlg::CWaitForResourceOfflineDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOfflineDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CWaitForResourceOfflineDlg::OnInitDialog( void )
{
    m_strMessage.Format( IDS_WAIT_FOR_OFFLINE_MESSAGE, m_pRes->StrName() );

    return CWaitDlg::OnInitDialog();

} //*** CWaitForResourceOfflineDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOfflineDlg::OnTimerTick
//
//  Routine Description:
//      Determine whether the timer should be terminated.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitForResourceOfflineDlg::OnTimerTick( void )
{
    DWORD                   dwStatus;
    CLUSTER_RESOURCE_STATE  crs;

    // Get the state of the resource in a loop until either the resource
    // is no longer in a pending state or the maximum number of retries
    // is exceeded.

    // Get the state of the resource.
    crs = GetClusterResourceState( m_pRes->Hresource(), NULL, NULL, NULL, NULL );
    if ( crs == ClusterResourceStateUnknown )
    {
        dwStatus = GetLastError();
        CloseTimer();
        CDialog::OnCancel();
        ThrowStaticException( dwStatus, IDS_GET_RESOURCE_STATE_ERROR, m_pRes->StrName() );
    } // if: error getting resource state

    // See if we reached a stable state.
    if ( crs < ClusterResourcePending )
    {
        CloseTimer();
        CDialog::OnOK();
    }

}  //*** CWaitForResourceOfflineDlg::OnTimerTick()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CWaitForResourceOnlineDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CWaitForResourceOnlineDlg, CWaitDlg )
    //{{AFX_MSG_MAP(CWaitForResourceOnlineDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOnlineDlg::CWaitForResourceOnlineDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pResIn          -- Resource to wait on.
//      pwndParentIn    -- Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWaitForResourceOnlineDlg::CWaitForResourceOnlineDlg(
    CResource const *   pResIn,
    CWnd *              pwndParentIn    // = NULL
    )
    : CWaitDlg( NULL, IDS_WAIT_FOR_ONLINE_TITLE, pwndParentIn )
    , m_pRes( pResIn )
{
    ASSERT( pResIn != NULL );

    //{{AFX_DATA_INIT(CWaitForResourceOnlineDlg)
    //}}AFX_DATA_INIT

} //*** CWaitForResourceOnlineDlg::CWaitForResourceOnlineDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOnlineDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CWaitForResourceOnlineDlg::OnInitDialog( void )
{
    m_strMessage.Format( IDS_WAIT_FOR_ONLINE_MESSAGE, m_pRes->StrName() );

    return CWaitDlg::OnInitDialog();

} //*** CWaitForResourceOnlineDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOnlineDlg::OnTimerTick
//
//  Routine Description:
//      Determine whether the timer should be terminated.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitForResourceOnlineDlg::OnTimerTick( void )
{
    DWORD                   dwStatus;
    CLUSTER_RESOURCE_STATE  crs;

    // Get the state of the resource in a loop until either the resource
    // is no longer in a pending state or the maximum number of retries
    // is exceeded.

    // Get the state of the resource.
    crs = GetClusterResourceState( m_pRes->Hresource(), NULL, NULL, NULL, NULL );
    if ( crs == ClusterResourceStateUnknown )
    {
        dwStatus = GetLastError();
        CloseTimer();
        CDialog::OnCancel();
        ThrowStaticException( dwStatus, IDS_GET_RESOURCE_STATE_ERROR, m_pRes->StrName() );
    } // if: error getting resource state

    // See if we reached a stable state.
    if ( crs < ClusterResourcePending )
    {
        CloseTimer();
        CDialog::OnOK();
    }

}  //*** CWaitForResourceOnlineDlg::OnTimerTick()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\basedata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseData.cpp
//
//	Abstract:
//		Implementation of the CBaseSnapInDataInterface template class.
//
//	Author:
//		David Potter (davidp)	November 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseData.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\basedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.h
//
//	Abstract:
//		Definition of the CBaseDialogImpl and CBaseModelessDialogImpl
//		classes.
//
//	Implementation File:
//		BaseDlg.cpp
//
//	Author:
//		David Potter (davidp)	November 13, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEDLG_H_
#define __BASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template <class T> class CBaseDialogImpl;
template <class T> class CBaseModelessDialogImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CBaseDialogImpl
/////////////////////////////////////////////////////////////////////////////

template <class T>
class CBaseDialogImpl :
	public CDialogImpl< T >,
	public CMessageFilter
{
protected:
	//
	// CMessageFilter required overrides.
	//
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return ::IsDialogMessage(m_hWnd, pMsg);
	}

}; // class CBaseDialogImpl

/////////////////////////////////////////////////////////////////////////////
// class CBaseDialogImpl
/////////////////////////////////////////////////////////////////////////////

template <class T>
class CBaseModelessDialogImpl :
	public CDialogImpl< T >,
	public CMessageLoop
{
protected:
	HWND		m_hwndParent;	// Used for centering the dialog.
	HANDLE		m_hThread;		// Used to make sure the thread shuts down properly.
//	BOOL		m_bUsesCom;		// Used to determine whether COM should be initialized or not.
	IStream *	m_pstm;			// Used for inter-thread marshalling.

public:
	//
	// Constructors and destructors.
	//

	CBaseModelessDialogImpl(void) :
		m_hwndParent(NULL),
		m_hThread(NULL),
		m_pstm(NULL)
	{
	}

#ifdef _DEBUG
	~CBaseModelessDialogImpl(void)
	{
		_ASSERTE(m_hwndParent == NULL);
		_ASSERTE(m_hThread == NULL);
		_ASSERTE(m_pstm == NULL);
	}
#endif

	// Shutdown the dialog
	void Shutdown(void)
	{
		if ((m_hWnd != NULL) && (m_hThread != NULL))
		{
			PostMessage(WM_COMMAND, IDCANCEL, 0);
			BOOL bSignaled = AtlWaitWithMessageLoop(m_hThread); // wait for thread to exit
			_ASSERTE(bSignaled);
		}
		_ASSERTE(m_hWnd == NULL);
		_ASSERTE(m_hThread == NULL);
	}

	// End the dialog
	BOOL EndDialog(int nRetCode = IDOK)
	{
		// Since this is a modeless dialog, don't call EndDialog.
		// Destroy the window instead.
		DestroyWindow();
		return TRUE;
	}

protected:
	//
	// Thread handling.
	//

	// Static thread procedure
	static DWORD WINAPI S_ThreadProc(LPVOID pvThis)
	{
		_ASSERTE(pvThis != NULL);
		CBaseModelessDialogImpl< T > * pThis = (CBaseModelessDialogImpl< T > *) pvThis;
		DWORD dwStatus = pThis->ThreadProc();
		CloseHandle(pThis->m_hThread);
		pThis->m_hThread = NULL;
		return dwStatus;
	}

	virtual DWORD ThreadProc(void) = 0;

protected:
	//
	// CMessageLoop required overrides.
	//
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		BOOL bHandled;
		bHandled = ::IsDialogMessage(m_hWnd, pMsg);
		if (!bHandled)
			bHandled = CMessageLoop::PreTranslateMessage(pMsg);
		return bHandled;
	}

}; // class CBaseModelessDialogImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\cluadmmc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CluAdMMC.cpp
//
//	Abstract:
//		Implementation of DLL Exports.
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CluAdMMCps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "CompData.h"
#include "SnapAbout.h"

/////////////////////////////////////////////////////////////////////////////
// Single module object
/////////////////////////////////////////////////////////////////////////////

CMMCSnapInModule _Module;

/////////////////////////////////////////////////////////////////////////////
// Objects supported by this DLL
/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP( ObjectMap )
	OBJECT_ENTRY( CLSID_ClusterAdmin, CClusterComponentData )
	OBJECT_ENTRY( CLSID_ClusterAdminAbout, CClusterAdminAbout )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllMain
//
//	Routine Description:
//		DLL Entry Point.
//
//	Arguments:
//		hInstance		Handle to this DLL.
//		dwReason		Reason this function was called.
//							Can be Process/Thread Attach/Detach.
//		lpReserved		Reserved.
//
//	Return Value:
//		TRUE			No error.
//		FALSE			Error occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/ )
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		_Module.Init( ObjectMap, hInstance );
		CSnapInItem::Init();
		DisableThreadLibraryCalls( hInstance );
	} // if:  attaching to a process
	else if ( dwReason == DLL_PROCESS_DETACH )
	{
		_Module.Term();
	} // else:  detaching from a process

	return TRUE;    // ok

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllCanUnloadNow
//
//	Routine Description:
//		Used to determine whether the DLL can be unloaded by OLE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL can be unloaded.
//		S_FALSE		DLL can not be unloaded.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllGetClassObject
//
//	Routine Description:
//		Returns a class factory to create an object of the requested type.
//
//	Arguments:
//		rclsid		CLSID of class desired.
//		riid		IID of interface on class factory desired.
//		ppv			Filled with interface pointer to class factory.
//
//	Return Value:
//		S_OK		Class object returned successfully.
//		Any status codes returned from _Module.GetClassObject().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv )
{
	return _Module.GetClassObject( rclsid, riid, ppv );

} //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Routine Description:
//		Registers the interfaces and objects that this DLL supports in the
//		system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL registered successfully.
//		Any status codes returned from _Module.RegisterServer().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer( TRUE /*bRegTypeLib*/ );

} //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Routine Description:
//		Unregisters the interfaces and objects that this DLL supports in the
//		system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL unregistered successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
	_Module.UnregisterServer();
	return S_OK;

} //*** DllUnregisterServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\comp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Comp.cpp
//
//	Abstract:
//		Implementation of the CClusterComponent class.
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Comp.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponent
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterComponent::GetHelpTopic [ISnapinHelp]
//
//	Routine Description:
//		Merge our help file into the MMC help file.
//
//	Arguments:
//		lpCompiledHelpFile	[OUT] Pointer to the address of the NULL-terminated
//								UNICODE string that contains the full path of
//								compiled help file (.chm) for the snap-in.
//
//	Return Value:
//		HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponent::GetHelpTopic(
	OUT LPOLESTR * lpCompiledHelpFile
	)
{
	HRESULT	hr = S_OK;

	ATLTRACE( _T("Entering CClusterComponent::GetHelpTopic()\n") );

	if ( lpCompiledHelpFile == NULL )
	{
		hr = E_POINTER;
	} // if: no output string
	else
	{
		*lpCompiledHelpFile = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( MAX_PATH ) );
		if ( *lpCompiledHelpFile == NULL )
		{
			hr = E_OUTOFMEMORY;
		} // if: error allocating memory for the string
		else
		{
			ExpandEnvironmentStringsW( HELP_FILE_NAME, *lpCompiledHelpFile, MAX_PATH );
			ATLTRACE( _T("CClusterComponent::GetHelpTopic() - Returning %s as help file\n"), *lpCompiledHelpFile );
		} // else: allocated memory successfully
	} // else: help string specified

	ATLTRACE( _T("Leaving CClusterComponent::GetHelpTopic()\n") );

	return hr;

} //*** CClusterComponent::GetHelpTopic()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\comp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Comp.h
//
//	Abstract:
//		Definition of the CClusterComponent class.
//
//	Implementation File:
//		Comp.cpp
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMP_H_
#define __COMP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterComponent;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"
//#include <atlsnap.h>

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

// Enumeration for the icon index in the image list.
enum
{
	IMGLI_ROOT = 0,
	IMGLI_CLUSTER,
	IMGLI_NODE,
	IMGLI_GROUP,
	IMGLI_RES,
	IMGLI_RESTYPE,
	IMGLI_NETWORK,
	IMGLI_NETIFACE,

	IMGLI_MAX	// Must be last
};

#define HELP_FILE_NAME	L"%SystemRoot%\\Help\\mscs.chm"
#define FULL_HELP_TOPIC	L"mscsConcepts.chm::/mscsQuick.htm"

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponent
/////////////////////////////////////////////////////////////////////////////

class CClusterComponent :
	public CComObjectRootEx< CComSingleThreadModel >,
	public CSnapInObjectRoot,
	public IExtendContextMenuImpl< CClusterComponent >,
	public ISnapinHelp,
	public IComponentImpl< CClusterComponent >
{
public:
	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CClusterComponent )
		COM_INTERFACE_ENTRY( IComponent )
		COM_INTERFACE_ENTRY( IExtendContextMenu )
		COM_INTERFACE_ENTRY( ISnapinHelp )
	END_COM_MAP()

public:
	//
	// Object construction and destruction.
	//

	CClusterComponent( void )
	{
	}

public:
	//
	// ISnapinHelp methods.
	//

	// Merge our help file into the MMC help file
	STDMETHOD( GetHelpTopic )( OUT LPOLESTR * lpCompiledHelpFile );

}; // class CClusterComponent

/////////////////////////////////////////////////////////////////////////////

#endif // __COMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

inline int EXC_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return MMCMessageBox(NULL, lpszText, nType);
}

inline int EXC_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return MMCMessageBox(NULL, nIDPrompt, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return MMCMessageBox(hwndParent, lpszText, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return MMCMessageBox(hwndParent, nIDPrompt, nType);
}

inline HINSTANCE EXC_GetResourceInstance(void)
{
	return _Module.GetResourceInstance();
}

#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\compdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		CompData.h
//
//	Abstract:
//		Definition of the CClusterComponentData class.
//
//	Implementation File:
//		CompData.cpp
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterComponentData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseNodeObj;
class CServerAppsNodeData;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMP_H_
#include "Comp.h"			// for CClusterComponent
#endif

#ifndef __SERVERAPPSNODE_H_
#include "ServerAppsNode.h"	// for CServerAppsNodeData
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponentData
/////////////////////////////////////////////////////////////////////////////

class CClusterComponentData :
	public CComObjectRootEx< CComSingleThreadModel >,
	public CSnapInObjectRoot,
	public IComponentDataImpl< CClusterComponentData, CClusterComponent >,
	public IExtendContextMenuImpl< CClusterComponentData >,
	public ISnapinHelp,
	public CComCoClass< CClusterComponentData, &CLSID_ClusterAdmin >
{
public:
	//
	// Object construction and destruction.
	//

	CClusterComponentData( void );
	~CClusterComponentData( void );

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CClusterComponentData )
		COM_INTERFACE_ENTRY( IComponentData )
		COM_INTERFACE_ENTRY( IExtendContextMenu )
		COM_INTERFACE_ENTRY( ISnapinHelp )
	END_COM_MAP()

	static HRESULT WINAPI UpdateRegistry( BOOL bRegister );

	//
	// If this is an extension, map the node type.
	//
	EXTENSION_SNAPIN_DATACLASS( CServerAppsNodeData )

	BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP( CClusterComponentData )
		EXTENSION_SNAPIN_NODEINFO_ENTRY( CServerAppsNodeData )
	END_EXTENSION_SNAPIN_NODEINFO_MAP()

	DECLARE_NOT_AGGREGATABLE( CClusterComponentData )

public:
	//
	// IComponentData methods.
	//

	// Initialize this object
	STDMETHOD( Initialize )( LPUNKNOWN pUnknown );

	// Object is being destroyed
	STDMETHOD( Destroy )( void );

public:
	//
	// IComponentDatImpl methods.
	//

	// Handle notification messages from MMC
	STDMETHOD( Notify )( 
		LPDATAOBJECT lpDataObject,
		MMC_NOTIFY_TYPE event,
		long arg,
		long param
		);

public:
	//
	// ISnapinHelp methods.
	//

	// Merge our help file into the MMC help file
	STDMETHOD( GetHelpTopic )( OUT LPOLESTR * lpCompiledHelpFile );

public:
	//
	// CClusterComponentData-specific methods.
	//

	// Returns a handle to the main frame window
	HWND GetMainWindow( void )
	{
		_ASSERTE( m_spConsole != NULL );

		HWND hwnd;
		HRESULT hr;
		hr = m_spConsole->GetMainWindow( &hwnd );
		_ASSERTE( SUCCEEDED( hr ) );
		return hwnd;
	}

	// Display a message box as a child of the console
	int MessageBox(
		LPCWSTR lpszText,
		LPCWSTR lpszTitle = NULL,
		UINT fuStyle = MB_OK
		)
	{
		_ASSERTE( m_spConsole != NULL );
		_ASSERTE( lpszText != NULL );

		int iRetVal;
		HRESULT hr;

		if ( lpszTitle == NULL )
			lpszTitle = _Module.GetAppName();

		hr = m_spConsole->MessageBox(
				lpszText,
				lpszTitle,
				fuStyle,
				&iRetVal
				);
		_ASSERTE( SUCCEEDED( hr ) );

		return iRetVal;
	}

protected:
	// Extract data from a data object
	HRESULT ExtractFromDataObject(
		LPDATAOBJECT	pDataObject,
		CLIPFORMAT		cf,
		DWORD			cb,
		HGLOBAL *		phGlobal
		);

	// Save the machine name from the data object
	HRESULT HrSaveMachineNameFromDataObject( LPDATAOBJECT lpDataObject );

	// Set the machine name being managed
	void SetMachineName( LPCWSTR pwszMachineName );

	// Create the root node object
	HRESULT CreateNode(
				LPDATAOBJECT lpDataObject,
				long arg,
				long param
				);

	// Display context-sensitive help
	HRESULT HrDisplayContextHelp( void );

protected:
	//
	// Clipboard formats we will be using.
	//
	static CLIPFORMAT	s_CCF_MACHINE_NAME;

	//
	// Name of machine being managed.
	//
	WCHAR m_wszMachineName[ MAX_PATH ];

public:
	LPCWSTR PwszMachineName( void ) const { return m_wszMachineName; }

	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > m_spConsoleNameSpace;

}; // class CClusterComponentData

/////////////////////////////////////////////////////////////////////////////

#endif // __COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\mmcapp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		MMCApp.cpp
//
//	Abstract:
//		Implementation of the CMMCSnapInModule class.
//
//	Author:
//		David Potter (davidp)	November 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MMCApp.h"

/////////////////////////////////////////////////////////////////////////////
// class CMMCSnapInModule
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMMCSnapInModule::Release
//
//	Routine Description:
//		Decrement the reference count.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Reference count after decrementing
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMMCSnapInModule::Release( void )
{
	//
	// Decrement the reference count.
	//
	int crefs = --m_crefs;

	//
	// If there are no more references to this object, free up all our
	// pointers, allocations, etc.
	//
	if ( crefs == 0 )
	{
		m_spConsole.Release();
		if ( m_pszAppName != NULL )
		{
			delete [] m_pszAppName;
			m_pszAppName = NULL;
		} // if:  app name string was allocated
	} // if:  no more references to this object

	return crefs;

} //*** CMMCSnapInModule::Release()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMMCSnapInModule::Init
//
//	Routine Description:
//		Initialize the module with a console interface pointer.
//
//	Arguments:
//		pUnknown	IUnknown pointer for getting the IConsole interface pointer.
//		UINT		idsAppName
//
//	Return Value:
//		Reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMMCSnapInModule::Init( IUnknown * pUnknown, UINT idsAppName )
{
	CString strAppName;
	strAppName.LoadString( idsAppName );
	return Init( pUnknown, strAppName );

} //*** CMMCSnapInModule::Init( pUnknown, idsAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMMCSnapInModule::GetProfileString
//
//	Routine Description:
//		Read a value from the profile.
//
//	Arguments:
//		lpszSection	[IN] Name of subkey below HKEY_CURRENT_USER to read from.
//		lpszEntry	[IN] Name of value to read.
//		lpszDefault	[IN] Default if no value found.
//
//	Return Value:
//		CString value.
//
//--
/////////////////////////////////////////////////////////////////////////////
CString CMMCSnapInModule::GetProfileString(
	LPCTSTR lpszSection,
	LPCTSTR lpszEntry,
	LPCTSTR lpszDefault // = NULL
	)
{
	CRegKey	key;
	CString	strKey;
	CString	strValue;
	LPTSTR	pszValue;
	DWORD	dwCount;
	DWORD	dwStatus;

	_ASSERTE( m_pszAppName != NULL );

	//
	// Open the key.
	//
	strKey.Format( _T("Software\\%s\\%s"), m_pszAppName, lpszSection );
	dwStatus = key.Open( HKEY_CURRENT_USER, strKey, KEY_READ );
	if ( dwStatus != ERROR_SUCCESS )
	{
		return lpszDefault;
	} // if:  error opening the registry key

	//
	// Read the value.
	//
	dwCount = 256;
	pszValue = strValue.GetBuffer( dwCount );
	dwStatus = key.QueryValue( pszValue, lpszEntry, &dwCount );
	if ( dwStatus != ERROR_SUCCESS )
	{
		return lpszDefault;
	} // if:  error reading the value

	//
	// Return the buffer to the caller.
	//
	strValue.ReleaseBuffer();
	return strValue;

} //*** CMMCSnapInModule::GetProfileString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\mmcapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		MMCApp.h
//
//	Abstract:
//		Definition of the CMMCSnapInModule class.
//
//	Implementation File:
//		MMCApp.cpp
//
//	Author:
//		David Potter (davidp)	November 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MMCAPP_H_
#define __MMCAPP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CMMCSnapInModule;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

interface IConsole;
namespace ATL
{
	class CString;
}

/////////////////////////////////////////////////////////////////////////////
// External Declarations
/////////////////////////////////////////////////////////////////////////////

EXTERN_C const IID IID_IConsole;
extern CMMCSnapInModule _Module;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CMMCSnapInModule
/////////////////////////////////////////////////////////////////////////////

class CMMCSnapInModule : public CComModule
{
protected:
	int m_crefs;
	LPWSTR m_pszAppName;

public:
	CComQIPtr< IConsole, &IID_IConsole > m_spConsole;

	// Default constructor
	CMMCSnapInModule( void )
	{
		m_crefs = 0;
		m_pszAppName = NULL;

	} //*** CMMCSnapInModule()

	// Destructor
	~CMMCSnapInModule( void )
	{
		delete [] m_pszAppName;

	} //*** ~CMMCSnapInModule()

	// Increment the reference count to this object
	int AddRef( void )
	{
		m_crefs++;
		return m_crefs;

	} //*** AddRef()

	// Decrement the reference count to this object
	int Release( void );

	// Initialize the module.
	void Init( _ATL_OBJMAP_ENTRY * p, HINSTANCE h )
	{
		CComModule::Init( p, h );

	} //*** Init( p, h )

	// Initialize the application object
	int Init( IUnknown * pUnknown, LPCWSTR pszAppName )
	{
		_ASSERTE( pUnknown != NULL );
		_ASSERTE( pszAppName != NULL );

		if ( m_spConsole == NULL )
		{
			m_spConsole = pUnknown;
		} // if:  console interface not set yet
		if ( m_pszAppName == NULL )
		{
			m_pszAppName = new TCHAR[lstrlen( pszAppName ) + 1];
			_ASSERTE( m_pszAppName != NULL );
			lstrcpy( m_pszAppName, pszAppName );
		} //** if:  app name specified
		return AddRef();

	} //*** Init( pUnknown, pszAppName )

	// Initialize the application object
	int Init( IUnknown * pUnknown, UINT idsAppName );

	// Terminate the module
	void Term( void )
	{
		CComModule::Term();

	} //*** Term()

	// Returns the name of the application.
	LPCTSTR GetAppName( void )
	{
		return m_pszAppName;

	} //*** GetAppName()

	// Returns a handle to the main MMC frame window
	HWND GetMainWindow( void );

	// Display a message box as a child of the console
	int MessageBox(
		HWND hwndParent,
		LPCWSTR lpszText,
		UINT fuStyle = MB_OK
		);

	// Display a message box as a child of the console
	int MessageBox(
		HWND hwndParent,
		UINT nID,
		UINT fuStyle = MB_OK
		);

	// Read a value from the profile
	CString GetProfileString(
		LPCTSTR lpszSection,
		LPCTSTR lpszEntry,
		LPCTSTR lpszDefault = NULL
		);

}; // class CMMCSnapInModule

/////////////////////////////////////////////////////////////////////////////

#endif // __MMCAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\compdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      CompData.cpp
//
//  Abstract:
//      Implementation of the CClusterComponent class.
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CompData.h"
#include "RootNode.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponentData
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Extension Snap-In Node Info Map

//BEGIN_EXTENSION_SNAPIN_NODEINFO_PTR_MAP( CClusterComponentData( 
//  EXTENSION_SNAPIN_NODEINFO_PTR_ENTRY( CServerAppsNodeData( 
//END_EXTENSION_SNAPIN_NODEINFO_MAP()

/////////////////////////////////////////////////////////////////////////////
// Static Variables

_declspec( selectany ) CLIPFORMAT CClusterComponentData::s_CCF_MACHINE_NAME = 0;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::CClusterComponentData
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterComponentData::CClusterComponentData( void )
{
    m_pNode = NULL;
    ZeroMemory( m_wszMachineName, sizeof(m_wszMachineName) );

//  m_pNode = new CRootNodeData( this );
//  _ASSERTE( m_pNode != NULL );

    //
    // Initialize the extension node objects.
    //
//  INIT_EXTENSION_SNAPIN_DATACLASS_PTR( CServerAppsNodeData );

} //*** CClusterComponentData::CClusterComponentData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::~CClusterComponentData
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterComponentData::~CClusterComponentData( void )
{
    delete m_pNode;
    m_pNode = NULL;

    //
    // Cleanup the extension node objects.
    //
//  DEINIT_EXTENSION_SNAPIN_DATACLASS_PTR( CServerAppsNodeData );

} //*** CClusterComponentData::~CClusterComponentData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::UpdateRegistry
//
//  Routine Description:
//      Update the registry for this object.
//
//  Arguments:
//      bRegister   TRUE = register, FALSE = unregister.
//
//  Return Value:
//      Any return values from _Module.UpdateRegistryFromResource.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CClusterComponentData::UpdateRegistry( BOOL bRegister )
{
    static WCHAR oszAppDisplayName[256] = { 0 };
    static WCHAR oszSnapInDisplayName[256] = { 0 };
    static _ATL_REGMAP_ENTRY rgRegMap[] =
    {
        { OLESTR("AppDisplayName"),     oszAppDisplayName },
        { OLESTR("SnapInDisplayName"),  oszSnapInDisplayName },
        { NULL, NULL }
    };

    //
    // Load replacement values.
    //
    if ( oszAppDisplayName[0] == OLESTR('\0') )
    {
        CString str;

        str.LoadString( IDS_CLUSTERADMIN_APP_NAME );
        lstrcpyW( oszAppDisplayName, str );

        str.LoadString( IDS_CLUSTERADMIN_SNAPIN_NAME );
        lstrcpyW( oszSnapInDisplayName, str );
    } // if:  replacement values not loaded yet

    return _Module.UpdateRegistryFromResourceS( IDR_CLUSTERADMIN, bRegister, rgRegMap );

} //*** CClusterComponentData::UpdateRegistry()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::Initialize [IComponentData]
//
//  Routine Description:
//      Initialize this object.
//
//  Arguments:
//      pUnknown    IUnknown pointer from the console.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::Initialize( LPUNKNOWN pUnknown )
{
    HRESULT hr = S_OK;
    HBITMAP hBitmap16 = NULL;
    HBITMAP hBitmap32 = NULL;

    //
    // Add bitmaps to the scope page image list.
    //

    CComPtr<IImageList> spImageList;

    // Call the base class.
    hr = IComponentDataImpl< CClusterComponentData, CClusterComponent >::Initialize( pUnknown );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Initialize the application.
    //
    MMCGetApp()->Init( m_spConsole, IDS_CLUSTERADMIN_APP_NAME );

    //
    // Get a pointer to the IConsoleNameSpace interface.
    //
    m_spConsoleNameSpace = pUnknown;
    if ( m_spConsoleNameSpace == NULL )
    {
        ATLTRACE( _T("QI for IConsoleNameSpace failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Register the clipboard formats we will be using.
    //
    if ( s_CCF_MACHINE_NAME == NULL )
    {
        s_CCF_MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat( _T("MMC_SNAPIN_MACHINE_NAME") );
    }

    if ( m_spConsole->QueryScopeImageList( &spImageList ) != S_OK )
    {
        ATLTRACE( _T("IConsole::QueryScopeImageList failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as needed
    hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_16 ) );
    if ( hBitmap16 == NULL )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_32 ) );
    if ( hBitmap32 == NULL )
    {
        hr = S_OK;
        goto Cleanup;
    }

    if ( spImageList->ImageListSetStrip( (LONG_PTR*)hBitmap16, 
        (LONG_PTR*)hBitmap32, IMGLI_ROOT, RGB( 255, 0, 255 ) ) != S_OK )
    {
        ATLTRACE( _T("IImageList::ImageListSetStrip failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    if ( spImageList->ImageListSetStrip( (LONG_PTR*)hBitmap16, 
        (LONG_PTR*)hBitmap32, IMGLI_CLUSTER, RGB( 255, 0, 255 ) ) != S_OK )
    {
        ATLTRACE( _T("IImageList::ImageListSetStrip failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Allocate the extension node objects.
    //

//  ALLOC_EXTENSION_SNAPIN_DATACLASS_PTR( CServerAppsNodeData );

Cleanup:
    if ( hBitmap16 != NULL )
    {
        DeleteObject( hBitmap16 );
    }
    if ( hBitmap32 != NULL )
    {
        DeleteObject( hBitmap32 );
    }

    return hr;

} //*** CClusterComponentData::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::Destroy [IComponentData]
//
//  Routine Description:
//      Object is being destroyed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::Destroy( void )
{
    //
    // Notify the node that it is being destroyed.
    //
    if ( m_pNode != NULL )
    {
        CBaseNodeObj * pBaseNode = dynamic_cast< CBaseNodeObj * >( m_pNode );
        _ASSERTE( pBaseNode != NULL );
        pBaseNode->OnDestroy();
        m_pNode = NULL;
    } // if:  we have a reference to a node

    //
    // Notify the application that we are going away.
    //
    MMCGetApp()->Release();

    return S_OK;

} //*** CClusterComponentData::Destroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::Notify [IComponentData]
//
//  Routine Description:
//      Handle notification messages from MMC.
//
//  Arguments:
//      lpDataObject    [IN] Data object containing info about event.
//      event           [IN] The event that occurred.
//      arg             [IN] Event-specific argument.
//      param           [IN] Event-specific parameter.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    long arg,
    long param
    )
{
    HRESULT hr = S_OK;

    switch ( event )
    {
        case MMCN_EXPAND:
            //
            // Create the node if it doesn't exist.
            //
            if ( m_pNode != NULL )
            {
                hr = IComponentDataImpl< CClusterComponentData, CClusterComponent >::Notify( lpDataObject, event, arg, param );
            } // if:  node already created
            else
            {
                hr = CreateNode( lpDataObject, arg, param );
            } // else:  no node created yet
            break;

        case MMCN_REMOVE_CHILDREN:
            if ( m_pNode != NULL )
            {
                CBaseNodeObj * pBaseNode = dynamic_cast< CBaseNodeObj * >( m_pNode );
                _ASSERTE( pBaseNode != NULL );
                pBaseNode->OnDestroy();
                m_pNode = NULL;
            } // if:  node not released yet
            ZeroMemory( m_wszMachineName, sizeof( m_wszMachineName ) );
            break;

        case MMCN_CONTEXTHELP:
            hr = HrDisplayContextHelp();
            break;

        default:
            hr = IComponentDataImpl< CClusterComponentData, CClusterComponent >::Notify( lpDataObject, event, arg, param );
            break;
    } // switch:  event

    return hr;

} //*** CClusterComponentData::Notify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::CreateNode
//
//  Routine Description:
//      Create the root node object.
//
//  Arguments:
//      lpDataObject    [IN] Data object containing info about event.
//      arg             [IN] Event-specific argument.
//      param           [IN] Event-specific parameter.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::CreateNode(
    LPDATAOBJECT lpDataObject,
    long arg,
    long param
    )
{
    _ASSERTE( m_pNode == NULL );

    HRESULT hr = S_OK;

    // Loop to avoid goto's.
    do
    {
        //
        // Get the parent scope item.
        //
        HSCOPEITEM hsiParent = (HSCOPEITEM) param;
        _ASSERTE( hsiParent != NULL );

        //
        // Save the name of the computer being managed.
        //
        hr = HrSaveMachineNameFromDataObject( lpDataObject );
        if ( FAILED( hr ) )
        {
            CNTException nte( hr );
            nte.ReportError();
            break;
        } // if:  error saving the machine name

        //
        // Allocate a new CRootNodeData object.
        //
        CRootNodeData * pData = new CRootNodeData( this );
        _ASSERTE( pData != NULL );

        //
        // Insert the node into the namespace.
        //
        hr = pData->InsertIntoNamespace( hsiParent );
        if ( FAILED( hr ) )
        {
            delete pData;
        } // if:  failed to insert it into the namespace
        else
        {
            m_pNode = pData;
        } // else:  inserted into the namespace successfully

    } while ( 0 );

    return hr;

} //*** CClusterComponentData::CreateNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::HrSaveMachineNameFromDataObject
//
//  Routine Description:
//      Get the machine name from the data object and save it.
//
//  Arguments:
//      lpDataObject    [IN] Data object containing info about event.
//
//  Return Value:
//      S_OK        Operation completed successfully.
//      HRESULT from CClusterComponentData::ExtractFromDataObject().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::HrSaveMachineNameFromDataObject(
    LPDATAOBJECT lpDataObject
    )
{
    _ASSERTE( m_pNode == NULL );

    HRESULT     hr = S_OK;
    HGLOBAL     hGlobal = NULL;

    //
    // Get the name of the computer being managed.
    //
    hr = ExtractFromDataObject(
            lpDataObject,
            s_CCF_MACHINE_NAME,
            sizeof( m_wszMachineName ),
            &hGlobal
            );
    if ( SUCCEEDED( hr ) )
    {
        SetMachineName( (LPCWSTR) hGlobal );
        GlobalFree( hGlobal );
    } // if:  successfully extracted the machine name

    return hr;

} //*** CClusterComponentData::HrSaveMachineNameFromDataObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::ExtractFromDataObject
//
//  Routine Description:
//      Extract data from a data object.
//
//  Arguments:
//      pDataObject Data object from which to extract the string.
//      cf          Clipboard format of the data.
//      cb          Size, in bytes, of requested data.
//      phGlobal    Filled with handle to data.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::ExtractFromDataObject(
    LPDATAOBJECT    pDataObject,
    CLIPFORMAT      cf,
    DWORD           cb,
    HGLOBAL *       phGlobal
    )
{
    _ASSERTE( pDataObject != NULL );
    _ASSERTE( phGlobal != NULL );
    _ASSERTE( cb > 0 );

    STGMEDIUM   stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC   formatetc = { cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    HRESULT     hr = S_OK;

    *phGlobal = NULL;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate memory for the stream.
        //
        stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, cb );
        if ( stgmedium.hGlobal == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if:  error allocating memory

        //
        // Attempt to get data from the object.
        //
        hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED( hr ) )
            break;

        *phGlobal = stgmedium.hGlobal;
        stgmedium.hGlobal = NULL;

    } while ( 0 );

    if ( FAILED( hr ) && (stgmedium.hGlobal != NULL) )
        GlobalFree( stgmedium.hGlobal );

    return hr;

} //*** CClusterComponentData::ExtractFromDataObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::SetMachineName
//
//  Routine Description:
//      Set the machine name being managed.
//
//  Arguments:
//      pszMachineName  Name of machine being managed.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterComponentData::SetMachineName( LPCWSTR pwszMachineName )
{
    //
    // Copy the data to the class member variable.
    //
    _ASSERTE( lstrlenW( pwszMachineName ) < sizeof( m_wszMachineName ) / sizeof( m_wszMachineName[ 0 ] ) );
    lstrcpynW( m_wszMachineName, pwszMachineName, sizeof(m_wszMachineName ) / sizeof(WCHAR) );

} //*** CClusterComponentData::SetMachineName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::GetHelpTopic [ISnapinHelp]
//
//  Routine Description:
//      Merge our help file into the MMC help file.
//
//  Arguments:
//      lpCompiledHelpFile  [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::GetHelpTopic(
    OUT LPOLESTR * lpCompiledHelpFile
    )
{
    HRESULT hr = S_OK;

    ATLTRACE( _T("Entering CClusterComponentData::GetHelpTopic()\n") );

    if ( lpCompiledHelpFile == NULL )
    {
        hr = E_POINTER;
    } // if: no output string
    else
    {
        *lpCompiledHelpFile = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( sizeof( HELP_FILE_NAME ) ) );
        if ( *lpCompiledHelpFile == NULL )
        {
            hr = E_OUTOFMEMORY;
        } // if: error allocating memory for the string
        else
        {
            ATLTRACE( _T("CClusterComponentData::GetHelpTopic() - Returning %s as help file\n"), HELP_FILE_NAME );
            wcscpy( *lpCompiledHelpFile, HELP_FILE_NAME );
        } // else: allocated memory successfully
    } // else: help string specified

    ATLTRACE( _T("Leaving CClusterComponentData::GetHelpTopic()\n") );

    return hr;

} //*** CClusterComponentData::GetHelpTopic()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::HrDisplayContextHelp
//
//  Routine Description:
//      Display context-sensitive help.
//
//  Arguments:
//      pszHelpTopic    [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::HrDisplayContextHelp( void )
{
    HRESULT         hr = S_OK;
    IDisplayHelp *  pi = NULL;
    LPOLESTR        postr = NULL;

    // Loop to avoid goto's.
    do
    {
        //
        // Get the IDisplayHelp interface pointer.
        //
        hr = m_spConsole->QueryInterface(
                IID_IDisplayHelp,
                reinterpret_cast< void ** >( &pi )
                );
        if ( FAILED( hr ) )
        {
            break;
        } // if: error getting interface pointer

        //
        // Construct the help topic path.
        //
        postr = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( sizeof( FULL_HELP_TOPIC ) ) );
        if ( postr == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory
        wcscpy( postr, FULL_HELP_TOPIC );

        //
        // Show the topic.
        //
        hr = pi->ShowTopic( postr );
        if ( ! FAILED( hr ) )
        {
            postr = NULL;
        } // if: topic shown successfully
    } while ( 0 );

    //
    // Cleanup before returning.
    //
    if ( postr != NULL )
    {
        CoTaskMemFree( postr );
    } // if: topic string not passed to MMC successfully
    if ( pi != NULL )
    {
        pi->Release();
    } // if:  valid interface pointer

    return hr;

} //*** CClusterComponentData::HrDisplayContextHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\mmcapp.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		MMCApp.inl
//
//	Abstract:
//		Inline method implementations for the CMMCSnapInModule class.
//
//	Author:
//		David Potter (davidp)	November 12, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MMCAPP_INL_
#define __MMCAPP_INL_

/////////////////////////////////////////////////////////////////////////////
// class CMMCSnapInModule
/////////////////////////////////////////////////////////////////////////////

// Returns a handle to the main MMC frame window
inline HWND CMMCSnapInModule::GetMainWindow(void)
{
	_ASSERTE(m_spConsole != NULL);

	HWND hwnd;
	HRESULT hr;
	hr = m_spConsole->GetMainWindow(&hwnd);
	_ASSERTE(SUCCEEDED(hr));
	return hwnd;

} //*** CMMCSnapInModule::GetMainWindow()

// Display a message box as a child of the console
inline int CMMCSnapInModule::MessageBox(
	HWND hwndParent,
	LPCWSTR lpszText,
	UINT fuStyle
	)
{
	if (hwndParent == NULL)
		hwndParent = GetMainWindow();

	return ::MessageBox(
			hwndParent,
			lpszText,
			m_pszAppName,
			fuStyle
			);

} //*** CMMCSnapInModule::MessageBox(lpszText)

// Display a message box as a child of the console
inline int CMMCSnapInModule::MessageBox(
	HWND hwndParent,
	UINT nID,
	UINT fuStyle
	)
{
	CString strMsg;

	strMsg.LoadString(nID);

	if (hwndParent == NULL)
		hwndParent = GetMainWindow();

	return ::MessageBox(
			hwndParent,
			strMsg,
			m_pszAppName,
			fuStyle
			);

} //*** CMMCSnapInModule::MessageBox(nID)

/////////////////////////////////////////////////////////////////////////////
// Helper Functions
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the MMC application object
inline CMMCSnapInModule * MMCGetApp(void)
{
	return &_Module;
}

// Retuns a handle to the main MMC frame window
inline HWND MMCGetMainWindow(void)
{
	return MMCGetApp()->GetMainWindow();
}

// Display a message box with the MMC console as the parent
inline int MMCMessageBox(HWND hwndParent, LPCWSTR lpszText, UINT fuStyle)
{
	return MMCGetApp()->MessageBox(hwndParent, lpszText, fuStyle);

} // MMCMessageBox()

// Display a message box with the MMC console as the parent
inline int MMCMessageBox(HWND hwndParent, UINT nID, UINT fuStyle)
{
	return MMCGetApp()->MessageBox(hwndParent, nID, fuStyle);

} // MMCMessageBox()

/////////////////////////////////////////////////////////////////////////////
// Provide TRACE support
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the application object
inline CMMCSnapInModule * TRACE_GetApp(void)
{
	return MMCGetApp();
}

inline int TRACE_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return MMCMessageBox(NULL, lpszText, nType);
}

inline int TRACE_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return MMCMessageBox(NULL, nIDPrompt, nType);
}

/////////////////////////////////////////////////////////////////////////////

#endif // __MMCAPP_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\snapabout.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		SnapAbout.cpp
//
//	Abstract:
//		Implementation of the CClusterAdminAbout class.
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SnapAbout.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusterAdminAbout
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\serverappsnode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ServerAppsNode.h
//
//	Abstract:
//		Definition of the CServerAppsNodeData class.
//
//	Implementation File:
//		ServerAppsNode.h (this file)
//
//	Author:
//		David Potter (davidp)	March 2, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SERVERAPPSNODE_H_
#define __SERVERAPPSNODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CServerAppsNodeData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CServerAppsNodeData
/////////////////////////////////////////////////////////////////////////////

class CServerAppsNodeData : public CSnapInItemImpl< CServerAppsNodeData, TRUE >
{
public:
	static const GUID *		m_NODETYPE;
	static const TCHAR *	m_SZNODETYPE;
	static const TCHAR *	m_SZDISPLAY_NAME;
	static const CLSID *	m_SNAPIN_CLASSID;

	IDataObject *			m_pDataObject;

public:
	//
	// Object construction and destruction.
	//

	CServerAppsNodeData( void )
	{
		memset( &m_scopeDataItem, 0, sizeof(SCOPEDATAITEM) );
		memset( &m_resultDataItem, 0, sizeof(RESULTDATAITEM) );

	} //*** CServerAppsNodeData()

public:
	//
	// Map menu and controlbar commands to this class.
	//
	BEGIN_SNAPINCOMMAND_MAP( CServerAppsNodeData, TRUE )
	END_SNAPINCOMMAND_MAP()

	//
	// Map a menu to this node type.
	//
	SNAPINMENUID( IDR_CLUSTERADMIN_MENU )

	virtual void InitDataClass( IDataObject * pDataObject, CSnapInItem * pDefault )
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem * GetExtNodeObject( IDataObject * pDataObject, CSnapInItem * pDefault )
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

}; // class CServerAppsNodeData

/////////////////////////////////////////////////////////////////////////////
// Static Data
/////////////////////////////////////////////////////////////////////////////

_declspec( selectany ) extern const GUID CServerAppsNodeDataGUID_NODETYPE = 
{ 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
_declspec( selectany ) const GUID *  CServerAppsNodeData::m_NODETYPE = &CServerAppsNodeDataGUID_NODETYPE;
_declspec( selectany ) const TCHAR * CServerAppsNodeData::m_SZNODETYPE = _T("476e6449-aaff-11d0-b944-00c04fd8d5b0");
_declspec( selectany ) const TCHAR * CServerAppsNodeData::m_SZDISPLAY_NAME = _T("Server Applications and Services");
_declspec( selectany ) const CLSID * CServerAppsNodeData::m_SNAPIN_CLASSID = &CLSID_ClusterAdmin;

/////////////////////////////////////////////////////////////////////////////

#endif // __SERVERAPPSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#pragma warning( disable: 4189 )
#include <statreg.cpp>
#pragma warning( default: 4189 )

#endif

#include <atlimpl.cpp>
#include <atlwin21.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\rootnode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		RootNode.h
//
//	Abstract:
//		Definition of the CRootNodeData and CRootNodeDataPage classes.
//
//	Implementation File:
//		RootNode.cpp
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ROOTNODE_H_
#define __ROOTNODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CRootNodeData;
class CRootNodeDataPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEDATA_H_
#include "BaseData.h" // CBaseNodeObjImpl
#endif

/////////////////////////////////////////////////////////////////////////////
// class CRootNodeData
/////////////////////////////////////////////////////////////////////////////

class CRootNodeData : public CBaseNodeObjImpl< CRootNodeData >
{
	typedef CBaseNodeObjImpl< CRootNodeData > baseClass;

	static const GUID * s_pguidNODETYPE;
	static LPCWSTR s_pszNODETYPEGUID;
	static WCHAR s_szDISPLAY_NAME[];
	static const CLSID * s_pclsidSNAPIN_CLASSID;

public:
	static CComPtr< IControlbar > m_spControlBar;

public:
	//
	// Object construction and destruction.
	//

	CRootNodeData( CClusterComponentData * pcd );

	~CRootNodeData( void );

public:
	//
	// Map menu and controlbar commands to this class.
	//
	BEGIN_SNAPINCOMMAND_MAP( CRootNodeData, FALSE )
		SNAPINCOMMAND_ENTRY( ID_MANAGE_CLUSTER, OnManageCluster )
	END_SNAPINCOMMAND_MAP()

	//
	// Map a menu to this node type.
	//
	SNAPINMENUID( IDR_CLUSTERADMIN_MENU )

	//
	// Map event notifications to this class.
	//
#if 0
	BEGIN_SNAPINDATANOTIFY_MAP( CRootNodeData, FALSE )
		SNAPINDATANOTIFY_ADD_IMAGES( OnAddImages )
		SNAPINDATANOTIFY_EXPAND( OnExpand )
	END_SNAPINDATANOTIFY_MAP()
#endif

public:
	//
	// CBaseNodeObjImpl methods.
	//

	// Get column info for the result pane
	virtual LPOLESTR GetResultPaneColInfo( int nCol )
	{
		USES_CONVERSION;

		OLECHAR		olesz[ 256 ];
		LPOLESTR	polesz;
		CString		str;

		switch ( nCol )
		{
			case 1:
				str.LoadString( IDS_CLUSTERADMIN_SNAPIN_TYPE );
				ocscpy( T2OLE( olesz ), str );
				polesz = olesz;
				break;

			case 2:
				str.LoadString( IDS_CLUSTERADMIN_DESC );
				ocscpy( T2OLE( olesz ), str );
				polesz = olesz;
				break;

			default:
				polesz = baseClass::GetResultPaneColInfo( nCol );
				break;

		} // switch:  nCol

		return polesz;

	} //*** GetResultPaneColInfo()


public:
	//
	// ISnapInDataInterface methods
	//

	// Notifies the snap-in of actions taken by the user
	STDMETHOD( Notify )(
		MMC_NOTIFY_TYPE		event,
		LPARAM              arg,
		LPARAM  			param,
		IComponentData *	pComponentData,
		IComponent *		pComponent,
		DATA_OBJECT_TYPES	type
		);

public:
	//
	// Notification handlers.
	//

	// Adds images to the result pane image list
	HRESULT OnAddImages(
		IImageList *		pImageList,
		HSCOPEITEM			hsi,
		IComponentData *	pComponentData,
		IComponent *		pComponent,
		DATA_OBJECT_TYPES	type
		);

	// Node is expanding or contracting
	HRESULT OnExpand(
		BOOL				bExpanding,
		HSCOPEITEM			hsi,
		IComponentData *	pComponentData,
		IComponent *		pComponent,
		DATA_OBJECT_TYPES	type
		);

public:
	//
	// Command handlers.
	//

	// Manage the cluster on this node
	HRESULT OnManageCluster( bool & bHandled, CSnapInObjectRoot * pObj );

protected:
	// Find the Cluster Administrator executable image
	DWORD ScFindCluAdmin( CString & rstrImage );

	// Display context-sensitive help
	HRESULT HrDisplayContextHelp( void );

public:
	//
	// IExtendPropertySheet methods.
	//

	// Adds pages to the property sheet
	STDMETHOD( CreatePropertyPages )(
		LPPROPERTYSHEETCALLBACK lpProvider,
		long handle,
		IUnknown * pUnk
		);

	// Determines whether the object requires pages
	STDMETHOD( QueryPagesFor )( void )
	{
		return S_FALSE;
	}

public:
	//
	// CSnapInDataInterface required methods
	//

	// Returns the node type GUID
	void * GetNodeType( void )
	{
		return (void *) s_pguidNODETYPE;
	}

	// Returns the stringized node type GUID
	void * GetSZNodeType( void )
	{
		return (void *) s_pszNODETYPEGUID;
	}

	// Returns the display name for this node type
	void * GetDisplayName( void );

	// Returns the display name for this node type as a string
	STDMETHOD_( LPWSTR, PszGetDisplayName )( void )
	{
		return (LPWSTR) GetDisplayName();
	}

	// Returns the CLSID for the snapin handling the node type
	void * GetSnapInCLSID( void )
	{
		return (void *) s_pclsidSNAPIN_CLASSID;
	}

}; // class CRootNodeData

/////////////////////////////////////////////////////////////////////////////
// class CRootNodeDataPage
/////////////////////////////////////////////////////////////////////////////

class CRootNodeDataPage : public CSnapInPropertyPageImpl< CRootNodeDataPage >
{
public :
	CRootNodeDataPage( TCHAR * pTitle = NULL )
		: CSnapInPropertyPageImpl< CRootNodeDataPage >( pTitle )
	{
	}

	enum { IDD = IDD_CLUSTERADMIN };

	//
	// Map Windows messages to class methods.
	//
	BEGIN_MSG_MAP( CRootNodeDataPage )
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		CHAIN_MSG_MAP( CSnapInPropertyPageImpl< CRootNodeDataPage > )
	END_MSG_MAP()

	LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		::SendMessage( GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH );
		return 1;
	}

}; // class CRootNodeDataPage

/////////////////////////////////////////////////////////////////////////////

#endif // __ROOTNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CluAdMMC.rc
//
#define IDR_CLUSTERADMIN                100
#define IDR_CLUSTERADMIN_MENU           101
#define IDR_CLUSTER_MENU                102
#define IDB_CLUSTER_16                  130
#define IDB_CLUSTER_32                  131
#define IDB_CLUSTER_64                  132
#define IDD_CLUSTERADMIN                200
#define IDS_PROJNAME                    10000
#define IDS_CLUSTERADMIN_DESC           10001
#define IDS_CLUSTERADMIN_PROVIDER       10002
#define IDS_CLUSTERADMIN_VERSION        10003
#define IDS_CLUSTERADMIN_APP_NAME       10004
#define IDS_CLUSTERADMIN_SNAPIN_NAME    10005
#define IDS_CLUSTERADMIN_SNAPIN_TYPE    10006
#define IDS_NODETYPE_STATIC_NODE        20000
#define ID_MANAGE_CLUSTER               32768
#define IDS_ERROR_MSG_ID                40609
#define IDS_ERROR_FINDING_CLUADMIN      41000
#define IDS_ERROR_LAUNCHING_CLUADMIN    41001
#define IDP_NO_ERROR_AVAILABLE          61472

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        300
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           150
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\rootnode.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      RootNode.cpp
//
//  Abstract:
//      Implementation of the CRootNodeData and CRootNodeDataPage classes.
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RootNode.h"

/////////////////////////////////////////////////////////////////////////////
// class CRootNodeData
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// static variables

static const GUID g_CClusterAdminGUID_NODETYPE =
    { 0x12e7ed20, 0x5540, 0x11d1, { 0x9a, 0xa4, 0x0, 0xc0, 0x4f, 0xb9, 0x3a, 0x80 } };

const GUID *    CRootNodeData::s_pguidNODETYPE = &g_CClusterAdminGUID_NODETYPE;
LPCWSTR         CRootNodeData::s_pszNODETYPEGUID = _T("12E7ED20-5540-11D1-9AA4-00C04FB93A80");
WCHAR           CRootNodeData::s_szDISPLAY_NAME[256] = { 0 };
const CLSID *   CRootNodeData::s_pclsidSNAPIN_CLASSID = &CLSID_ClusterAdmin;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::CRootNodeData
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pComponentData  Pointer to component data object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRootNodeData::CRootNodeData( CClusterComponentData * pcd )
    : CBaseNodeObjImpl< CRootNodeData >( pcd )
{
    //
    // Initialize the scope data item.
    //
    memset( &m_scopeDataItem, 0, sizeof(SCOPEDATAITEM) );
    m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage = IMGLI_CLUSTER;
    m_scopeDataItem.nOpenImage = IMGLI_CLUSTER;
    m_scopeDataItem.lParam = (LPARAM) this;

    //
    // Initialize the result data item.
    //
    memset( &m_resultDataItem, 0, sizeof(RESULTDATAITEM) );
    m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str = MMC_CALLBACK;
    m_resultDataItem.nImage = IMGLI_CLUSTER;
    m_resultDataItem.lParam = (LPARAM) this;

} //*** CRootNodeData::CRootNodeData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::~CRootNodeData
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRootNodeData::~CRootNodeData( void )
{
} //*** CRootNodeData::CRootNodeData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::CreatePropertyPages [IExtendPropertySheet]
//
//  Routine Description:
//      Called to create property pages for the MMC node and add them to
//      the sheet.
//
//  Arguments:
//      lpProvider  [IN] Pointer to the IPropertySheetCallback interface.
//      handle      [IN] Specifies the handle used to route the
//                      MMCN_PROPERTY_CHANGE notification message to the
//                      appropriate IComponent or IComponentData.
//      pUnk        [IN] Pointer to the IDataObject interface on the object
//                      that contains context information about the node.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRootNodeData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    long handle,
    IUnknown * pUnk
    )
{
    HRESULT hr = S_OK;
    CRootNodeDataPage * pPage = new CRootNodeDataPage( _T("ClusterAdmin") );
    if ( pPage == NULL )
    {
        hr = E_OUTOFMEMORY;
    } // if: error allocating memory
    else
    {
        lpProvider->AddPage( pPage->Create() );
    } // else: memory allocated successfully

    return hr;

} //*** CRootNodeData::CreatePropertyPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::GetDisplayName [CSnapInDataInterface]
//
//  Routine Description:
//      Returns the display name of this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Pointer to Unicode string containing the display name.
//
//--
/////////////////////////////////////////////////////////////////////////////
void * CRootNodeData::GetDisplayName( void )
{
    // If the display name hasn't been read from the
    if ( s_szDISPLAY_NAME[0] == L'\0' )
    {
        CString strDisplayName;
        strDisplayName.LoadString( IDS_NODETYPE_STATIC_NODE );
        lstrcpyW(s_szDISPLAY_NAME, strDisplayName);
    } // if:  display name hasn't been loaded yet

    return (void *) s_szDISPLAY_NAME;

} //*** CRootNodeData::GetDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::Notify [ISnapInDataInterface]
//
//  Routine Description:
//      Notifies the snap-in of actions taken by the user.  Handles
//      notifications sent through both IComponent and IComponentData.
//
//  Arguments:
//      event           [IN] Identifies the action taken by the user.
//      arg             Depends on the notification type.
//      param           Depends on the notification type.
//      pComponentData  Pointer to the IComponentData interface if this
//                          was invoked through that interface.
//      pComponent      Pointer to the IComponent interface if this was
//                          invoked through that interface.
//      type            Type of object.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
//#if 0
STDMETHODIMP CRootNodeData::Notify(
    MMC_NOTIFY_TYPE     event,
    LPARAM              arg,
    LPARAM              param,
    IComponentData *    pComponentData,
    IComponent *        pComponent,
    DATA_OBJECT_TYPES   type
    )
{
    HRESULT hr = S_OK;

    if ( pComponentData != NULL )
        ATLTRACE( _T("IComponentData::Notify(%d, %d, %d, %d)"), event, arg, param, type );
    else
        ATLTRACE( _T("IComponent::Notify(%d, %d, %d, %d)"), event, arg, param, type );

    switch ( event )
    {
        case MMCN_ACTIVATE:
            ATLTRACE( _T(" - MMCN_ACTIVATE\n") );
            break;
        case MMCN_ADD_IMAGES:
            ATLTRACE( _T(" - MMCN_ADD_IMAGES\n") );
            hr = OnAddImages( (IImageList *) arg, (HSCOPEITEM) param, pComponentData, pComponent, type );
            break;
        case MMCN_BTN_CLICK:
            ATLTRACE( _T(" - MMCN_BTN_CLICK\n") );
            break;
        case MMCN_CLICK:
            ATLTRACE( _T(" - MMCN_CLICK\n") );
            break;
        case MMCN_CONTEXTHELP:
            hr = HrDisplayContextHelp();
            break;
        case MMCN_DBLCLICK:
            ATLTRACE( _T(" - MMCN_DBLCLICK\n") );
            break;
        case MMCN_DELETE:
            ATLTRACE( _T(" - MMCN_DELETE\n") );
            break;
        case MMCN_EXPAND:
            ATLTRACE( _T(" - MMCN_EXPAND\n") );
            hr = OnExpand( (BOOL) arg, (HSCOPEITEM) param, pComponentData, pComponent, type );
            break;
        case MMCN_MINIMIZED:
            ATLTRACE( _T(" - MMCN_MINIMIZED\n") );
            break;
        case MMCN_PROPERTY_CHANGE:
            ATLTRACE( _T(" - MMCN_PROPERTY_CHANGE\n") );
            break;
        case MMCN_REMOVE_CHILDREN:
            ATLTRACE( _T(" - MMCN_REMOVE_CHILDREN\n") );
            break;
        case MMCN_RENAME:
            ATLTRACE( _T(" - MMCN_RENAME\n") );
            break;
        case MMCN_SELECT:
            ATLTRACE( _T(" - MMCN_SELECT\n") );
            break;
        case MMCN_SHOW:
            ATLTRACE( _T(" - MMCN_SHOW\n") );
            break;
        case MMCN_VIEW_CHANGE:
            ATLTRACE( _T(" - MMCN_VIEW_CHANGE\n") );
            break;
        default:
            ATLTRACE( _T(" - *** UNKNOWN event ***\n") );
            break;
    } // switch:  event

    return hr;

} //*** CRootNodeData::Notify()
//#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::OnAddImages
//
//  Routine Description:
//      Adds images to the result pane image list.
//
//  Arguments:
//      pImageList      Pointer to the result pane's image list (IImageList).
//      hsi             Specifies the HSCOPEITEM of the item that was
//                          selected or deselected.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::OnAddImages(
    IImageList *        pImageList,
    HSCOPEITEM          hsi,
    IComponentData *    pComponentData,
    IComponent *        pComponent,
    DATA_OBJECT_TYPES   type
    )
{
    _ASSERTE( pImageList != NULL );

    CBitmap     bm16;
    CBitmap     bm32;
    COLORREF    crMaskColor = RGB( 255, 0, 255 );
    HRESULT     hr;

    //
    // Add an image for the cluster object.
    //

    bm16.LoadBitmap( IDB_CLUSTER_16 );
    if ( bm16.m_hBitmap != NULL )
    {
        bm32.LoadBitmap( IDB_CLUSTER_32 );
        if ( bm32.m_hBitmap != NULL )
        {
            hr = pImageList->ImageListSetStrip(
                (LONG_PTR *) bm16.m_hBitmap,
                (LONG_PTR *) bm32.m_hBitmap,
                IMGLI_CLUSTER,
                crMaskColor
                );
            if ( FAILED( hr ) )
            {
                ATLTRACE( _T("CRootNodeData::OnAddImages() - IImageList::ImageListSetStrip failed with %08.8x\n"), hr );
            } // if:  error setting bitmaps into image list
        } // if:  32x32 bitmap loaded successfully
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        } // else:  error loading 32x32 bitmap
    } // if:  16x16 bitmap loaded successfully
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    } // else:  error loading 32x32 bitmap

    return hr;

} //*** CRootNodeData::OnAddImages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::OnExpand
//
//  Routine Description:
//      Node is expanding or contracting.
//
//  Arguments:
//      pImageList      Pointer to the result pane's image list (IImageList).
//      hsi             Specifies the HSCOPEITEM of the item that was
//                          selected or deselected.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::OnExpand(
    BOOL                bExpanding,
    HSCOPEITEM          hsi,
    IComponentData *    pComponentData,
    IComponent *        pComponent,
    DATA_OBJECT_TYPES   type
    )
{
    m_scopeDataItem.ID = hsi;
    return S_OK;

} //*** CRootNodeData::OnExpand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::OnManageCluster
//
//  Routine Description:
//      Manage the cluster on this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::OnManageCluster(
    bool &              bHandled,
    CSnapInObjectRoot * pObj
    )
{
    BOOL                bSuccessful;
    DWORD               dwStatus;
    HRESULT             hr = S_OK;
    CString             strCommandLine;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    LPCWSTR             pszMachineName = Pcd()->PwszMachineName();

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    //
    // Find the Cluster Administrator executable.
    //
    dwStatus = ScFindCluAdmin( strCommandLine );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        CNTException nte( dwStatus, IDS_ERROR_FINDING_CLUADMIN );
        nte.ReportError( MB_OK | MB_ICONEXCLAMATION );
        return hr;
    } // if:  failed to find the executable

    //
    // Construct the command line.  If the machine name is blank, we are
    // on the local machine.  Specify a dot (.) in its place.
    //
    if ( *pszMachineName == L'\0' )
    {
        strCommandLine += _T(" .");
    } // if:  running on the cluster node
    else
    {
        strCommandLine += _T(" ");
        strCommandLine += pszMachineName;
    } // else:  not running on the cluster node

    //
    // Create a process for Cluster Administrator.
    //
    bSuccessful = CreateProcess(
                    NULL,                               // lpApplicationName
                    (LPTSTR)(LPCTSTR) strCommandLine,   // lpCommandLine
                    NULL,                               // lpProcessAttributes
                    NULL,                               // lpThreadAttributes
                    FALSE,                              // bInheritHandles
                    CREATE_DEFAULT_ERROR_MODE           // dwCreationFlags
                    | CREATE_UNICODE_ENVIRONMENT,
                    GetEnvironmentStrings(),            // lpEnvironment
                    NULL,                               // lpCurrentDirectory
                    &si,                                // lpStartupInfo
                    &pi                                 // lpProcessInfo
                    );
    if ( !bSuccessful )
    {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32( dwStatus );
        CNTException nte( dwStatus, IDS_ERROR_LAUNCHING_CLUADMIN, strCommandLine );
        nte.ReportError( MB_OK | MB_ICONEXCLAMATION );
    } // if:  error invoking Cluster Administrator
    else
    {
        CloseHandle( pi.hProcess );
    } // else:  no error invoking Cluster Administrator

    return hr;

} //*** CRootNodeData::OnManageCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::ScFindCluAdmin
//
//  Routine Description:
//      Find the Cluster Administrator image.
//
//  Arguments:
//      rstrImage       [OUT] String in which to return the path.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRootNodeData::ScFindCluAdmin( CString & rstrImage )
{
    DWORD   dwStatus;
    CRegKey rk;
    TCHAR   szImage[MAX_PATH];
    DWORD   cbImage = sizeof(szImage);

    // Loop to avoid using goto's
    do
    {
        //
        // Open the App Paths registry key for CluAdmin.
        //
        dwStatus = rk.Open(
            HKEY_LOCAL_MACHINE,
            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CluAdmin.exe"),
            KEY_READ
            );
        if ( dwStatus != ERROR_SUCCESS )
        {
            break;
        } // if:  error opening the registry key

        //
        // Read the value.
        //
        dwStatus = rk.QueryValue( szImage, _T(""), &cbImage );
        if ( dwStatus != ERROR_SUCCESS )
        {
            break;
        } // if:  error reading the value

        //
        // Expand any environment string that may be embedded in the value.
        //

        TCHAR tszExpandedRegValue[_MAX_PATH];


        dwStatus = ExpandEnvironmentStrings( szImage,
                                                    tszExpandedRegValue,
                                                    (DWORD) _MAX_PATH );

        _ASSERTE( dwStatus != 0 );

        if ( dwStatus != 0L )
        {
            rstrImage = tszExpandedRegValue;

            dwStatus = 0L;
        }
        else
        {
            // Could not expand the environment string.

            rstrImage = szImage;

            dwStatus = GetLastError();
        }  // if: testing value returned by ExpandEnvironmentStrings


    } while ( 0 );

    return dwStatus;

} //*** CRootNodeData::ScFindCluAdmin()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::HrDisplayContextHelp
//
//  Routine Description:
//      Display context-sensitive help.
//
//  Arguments:
//      pszHelpTopic    [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::HrDisplayContextHelp( void )
{
    HRESULT         hr = S_OK;
    IDisplayHelp *  pi = NULL;
    LPOLESTR        postr = NULL;

    // Loop to avoid goto's.
    do
    {
        //
        // Get the IDisplayHelp interface pointer.
        //
        hr = Pcd()->m_spConsole->QueryInterface(
                IID_IDisplayHelp,
                reinterpret_cast< void ** >( &pi )
                );
        if ( FAILED( hr ) )
        {
            break;
        } // if: error getting interface pointer

        //
        // Construct the help topic path.
        //
        postr = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( sizeof( FULL_HELP_TOPIC ) ) );
        if ( postr == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory
        wcscpy( postr, FULL_HELP_TOPIC );

        //
        // Show the topic.
        //
        hr = pi->ShowTopic( postr );
        if ( ! FAILED( hr ) )
        {
            postr = NULL;
        } // if: topic shown successfully
    } while ( 0 );

    //
    // Cleanup before returning.
    //
    if ( postr != NULL )
    {
        CoTaskMemFree( postr );
    } // if: topic string not passed to MMC successfully
    if ( pi != NULL )
    {
        pi->Release();
    } // if:  valid interface pointer

    return hr;

} //*** CRootNodeData::HrDisplayContextHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(__STDAFX_H_)
#define __STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#pragma warning( disable : 4100 ) // unreferenced formal parameter
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4244 ) // possible lose of data
#pragma warning( disable : 4505 ) // unreferenced local function has been removed

// Enable some warnings.
#pragma warning( error : 4706 )  // assignment within conditional expression

#if defined(_DEBUG)
#define THIS_FILE __FILE__
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#define _CRTDBG_MAP_ALLOC
#endif // defined(_DEBUG)

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
#include "MMCApp.h"
extern CMMCSnapInModule _Module;

//#define _ATL_DEBUG_QI

#include <atlcom.h>

// atlwin.h needs this for the definition of DragAcceptFiles
#include <shellapi.h>

// atlwin.h needs this for the definition of psh1
#ifndef _DLGSH_INCLUDED_
#include <dlgs.h>
#endif

#if (_ATL_VER < 0x0300)
#include <atlwin21.h>
#endif //(_ATL_VER < 0x0300)

#include <atltmp.h>
#include <atlctrls.h>
#include <atlgdi.h>
#include <atlapp.h>

/////////////////////////////////////////////////////////////////////////////
// ATL Snap-In Classes
/////////////////////////////////////////////////////////////////////////////

#include <atlsnap.h>

/////////////////////////////////////////////////////////////////////////////

#include <clusapi.h>

#ifndef ASSERT
#define ASSERT _ASSERTE
#endif

#include "WaitCrsr.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "MMCApp.inl"
#include "CluAdMMC.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(__STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\snapabout.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		SnapAbout.h
//
//	Abstract:
//		Definition of the CClusterAdminAbout class.
//
//	Implementation File:
//		SnapAbout.cpp
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SNAPABOUT_H_
#define __SNAPABOUT_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAdminAbout;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_
#include "CompData.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusterAdminAbout
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CClusterAdminAbout :
	public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CClusterAdminAbout, &CLSID_ClusterAdminAbout >
{
public:
	DECLARE_REGISTRY(
		CClusterAdminAbout,
		_T("ClusterAdminAbout.1"),
		_T("ClusterAdminAbout"),
		IDS_CLUSTERADMIN_DESC,
		THREADFLAGS_BOTH
		);

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP(CClusterAdminAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	//
	// ISnapinAbout methods
	//

	STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CLUSTERADMIN_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR * lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CLUSTERADMIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CLUSTERADMIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON * hAppIcon)
	{
		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(
		HBITMAP * hSmallImage,
		HBITMAP * hSmallImageOpen,
		HBITMAP * hLargeImage,
		COLORREF * cMask
		)
	{
		*hSmallImage = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_CLUSTER_16));
		if (*hSmallImage != NULL)
		{
			*hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_CLUSTER_16));
			if (*hSmallImageOpen != NULL)
			{
				*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_CLUSTER_32));
				if (*hLargeImage == NULL)
				{
					ATLTRACE(_T("Error %d loading the large bitmap # %d\n"), GetLastError(), IDB_CLUSTER_32);
					return E_FAIL;
				}
			}
			else
			{
				ATLTRACE(_T("Error %d loading the small open bitmap # %d\n"), GetLastError(), IDB_CLUSTER_16);
				return E_FAIL;
			}
		}
		else
		{
			ATLTRACE(_T("Error %d loading the small bitmap # %d\n"), GetLastError(), IDB_CLUSTER_16);
			return E_FAIL;
		}

		*cMask = RGB(255, 0, 255);

		return S_OK;
	}

}; // class CClusterAdminAbout

/////////////////////////////////////////////////////////////////////////////

#endif // __SNAPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\types\idl\makefile.inc ===
CopyTLB :  CLUADMMC_TLB

CLUADMMC_TLB : $(O)\CluAdMMC.tlb
    copy $** ..\..\src\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	Dec 20, 1998
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2000 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.h
//
//  Description:
//      Defines the clases for creating clusters and adding nodes to
//      clusters.
//
//  Maintained By:
//      David Potter    (DavidP)    16-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <list>
#include <CritSec.h>

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

class CBaseClusCfg;
class CCreateCluster;
class CAddNodesToCluster;

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

struct STaskToDescription
{
    CLSID   taskidMajor;
    CLSID   taskidMinor;
    BSTR    bstrNodeName;
    BSTR    bstrDescription;

    STaskToDescription( void )
        : bstrNodeName( NULL )
        , bstrDescription( NULL )
    {
    }

}; //*** struct STaskToDescription

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusCfg
//
//  Description:
//      Base class for creating clusters or adding nodes to clusters.
//
//////////////////////////////////////////////////////////////////////////////
class CBaseClusCfg
    : public IClusCfgCallback
{
    friend class CCreateCluster;
    friend class CAddNodesToCluster;

private:
    BOOL                        m_fVerbose:1;           // Should we do verbose spew?
    int                         m_cSpins;               // Count of spins for UI progress

    CCritSec                    m_critsec;              // Critical section for notifications.

    IServiceProvider *          m_psp;                  // Service Manager
    IObjectManager *            m_pom;                  // Object Manager
    ITaskManager *              m_ptm;                  // Task Manager
    IConnectionPointContainer * m_pcpc;                 // Notification Manager's Connection Point Container interface
    OBJECTCOOKIE                m_cookieCluster;        // Cluster cookie

    std::list< STaskToDescription > m_lttd;             // List for translating tasks to descriptions

    //  IUnknown
    LONG                        m_cRef;                 // Reference count

    //  IClusCfgCallback
    ITaskAnalyzeCluster *       m_ptac;                 // Analyze Cluster Task
    ITaskCommitClusterChanges * m_ptccc;                // Commit Cluster Changes Task
    OBJECTCOOKIE                m_cookieCompletion;     // Completion cookie
    BOOL                        m_fTaskDone:1;          // Is the task done yet?
    HRESULT                     m_hrResult;             // Result of the analyze task
    HANDLE                      m_hEvent;               // Event handle to signal completion

    // Methods
    void
        ReportProgress( LPCWSTR pcwszFmtIn, ... );

    STaskToDescription *
        PttdFindTask(
              CLSID     taskidMajorIn
            , CLSID     taskidMinorIn
            , LPCWSTR   pcwszNodeName
            );

    HRESULT
        HrInsertTask(
              CLSID                 taskidMajorIn
            , CLSID                 taskidMinorIn
            , LPCWSTR               pcwszNodeNameIn
            , LPCWSTR               pcwszDescriptionIn
            , STaskToDescription ** ppttd
            );

public:
    CBaseClusCfg( void );
    virtual ~CBaseClusCfg( void );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
          LPCWSTR       pcszNodeNameIn
        , CLSID         clsidTaskMajorIn
        , CLSID         clsidTaskMinorIn
        , ULONG         ulMinIn
        , ULONG         ulMaxIn
        , ULONG         ulCurrentIn
        , HRESULT       hrStatusIn
        , LPCWSTR       pcszDescriptionIn
        , FILETIME *    pftTimeIn
        , LPCWSTR       pcszReferenceIn
        );

}; //*** class CBaseClusCfg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCreateCluster
//
//  Description:
//      Class for creating clusters.
//
//////////////////////////////////////////////////////////////////////////////
class CCreateCluster
    : public CBaseClusCfg
{
private:
    HRESULT
        HrFindNetwork(
              OBJECTCOOKIE              cookieNodeIn
            , LPCWSTR                   pcwszNetworkIn
            , IClusCfgNetworkInfo **    pccniOut
            );

    HRESULT
        HrMatchNetworkInfo(
              OBJECTCOOKIE              cookieNodeIn
            , ULONG                     ulIPAddressIn
            , ULONG *                   pulIPSubnetOut
            , IClusCfgNetworkInfo **    pccniOut
            );

public:
    CCreateCluster( void )
    {
    }

    HRESULT
        HrCreateCluster(
              BOOL      fVerboseIn
            , LPCWSTR   pcszClusterNameIn
            , LPCWSTR   pcszNodeNameIn
            , LPCWSTR   pcszUserAccountIn
            , LPCWSTR   pcszUserDomainIn
            , LPCWSTR   pcszUserPasswordIn
            , LPCWSTR   pcwszIPAddressIn
            , LPCWSTR   pcwszIPSubnetIn
            , LPCWSTR   pcwszNetworkIn
            );

    HRESULT
        HrInvokeWizard(
              LPCWSTR   pcszClusterNameIn
            , LPCWSTR   pcszNodeNameIn
            , LPCWSTR   pcszUserAccountIn
            , LPCWSTR   pcszUserDomainIn
            , LPCWSTR   pcszUserPasswordIn
            , LPCWSTR   pcwszIPAddressIn
            , LPCWSTR   pcwszIPSubnetIn
            , LPCWSTR   pcwszNetworkIn
            );

}; //*** class CCreateCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAddNodesToCluster
//
//  Description:
//      Class for adding nodes to clusters.
//
//////////////////////////////////////////////////////////////////////////////
class CAddNodesToCluster
    : public CBaseClusCfg
{
public:
    CAddNodesToCluster( void )
    {
    }

    HRESULT
        HrAddNodesToCluster(
              BOOL      fVerboseIn
            , LPCWSTR   pcszClusterNameIn
            , BSTR      rgbstrNodesIn[]
            , DWORD     cNodesIn
            , LPCWSTR   pcszUserPasswordIn
            );

    HRESULT
        HrInvokeWizard(
              LPCWSTR   pcszClusterNameIn
            , BSTR      rgbstrNodesIn[]
            , DWORD     cNodesIn
            , LPCWSTR   pcszUserPasswordIn
            );

}; //*** class CAddNodesToCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Definition of the CTraceTag class.
//
//	Implementation File:
//		TraceTag.cpp
//
//	Author:
//		David Potter (davidp)	May 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag;
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define TRACE_TAG_REG_SECTION		TEXT("Debug")
#define TRACE_TAG_REG_SECTION_FMT	TRACE_TAG_REG_SECTION TEXT("\\%s")
#define TRACE_TAG_REG_FILE			TEXT("Trace File")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CTraceTag
//
//	Purpose:
//		Object containing a specific set of trace settings allowing trace
//		output to go to multiple outputs.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag : public CString
{
	friend class CTraceDialog;
	friend void InitAllTraceTags(void);
	friend void CleanupAllTraceTags(void);

public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL);
	~CTraceTag(void);

	enum	TraceFlags
	{
		tfCom2		= 1,
		tfFile		= 2,
		tfDebug		= 4,
		tfBreak		= 8
	};

// Attributes
protected:
	UINT		m_uiFlags;
	UINT		m_uiFlagsDialog;
	UINT		m_uiFlagsDefault;
	UINT		m_uiFlagsDialogStart;	// of Selection...

	LPCTSTR		m_pszSubsystem;
	LPCTSTR		m_pszName;

	LPCTSTR		PszSubsystem(void)					{ return m_pszSubsystem; }
	LPCTSTR		PszName(void)						{ return m_pszName; }

	void		ConstructRegState(OUT CString & rstr);

	void		SetFlags(IN UINT tf, IN BOOL bEnable);
	void		SetFlagsDialog(IN UINT tf, IN BOOL bEnable);

	void		SetBCom2(IN BOOL bEnable)			{ SetFlags(tfCom2, bEnable); }
	void		SetBCom2Dialog(IN BOOL bEnable)		{ SetFlagsDialog(tfCom2, bEnable); }
	BOOL		BCom2Dialog(void) const				{ return m_uiFlagsDialog & tfCom2 ? TRUE : FALSE; }

	void		SetBFile(IN BOOL bEnable)			{ SetFlags(tfFile, bEnable); }
	void		SetBFileDialog(IN BOOL bEnable)		{ SetFlagsDialog(tfFile, bEnable); }
	BOOL		BFileDialog(void) const				{ return m_uiFlagsDialog & tfFile ? TRUE : FALSE; }

	void		SetBDebug(IN BOOL bEnable)			{ SetFlags(tfDebug, bEnable); }
	void		SetBDebugDialog(IN BOOL bEnable)	{ SetFlagsDialog(tfDebug, bEnable); }
	BOOL		BDebugDialog(void) const			{ return m_uiFlagsDialog & tfDebug ? TRUE : FALSE; }

	void		SetBBreak(IN BOOL bEnable)			{ SetFlags(tfBreak, bEnable); }
	void		SetBBreakDialog(IN BOOL bEnable)	{ SetFlagsDialog(tfBreak, bEnable); }
	BOOL		BBreakDialog(void) const			{ return m_uiFlagsDialog & tfBreak ? TRUE : FALSE; }

public:
	BOOL		BCom2(void) const					{ return m_uiFlags & tfCom2 ? TRUE : FALSE; }
	BOOL		BFile(void) const					{ return m_uiFlags & tfFile ? TRUE : FALSE; }
	BOOL		BDebug(void) const					{ return m_uiFlags & tfDebug ? TRUE : FALSE; }
	BOOL		BBreak(void) const					{ return m_uiFlags & tfBreak ? TRUE : FALSE; }
	BOOL		BAny(void) const					{ return m_uiFlags != 0; }

// Operations
public:

// Implementation
public:
	void				TraceV(IN LPCTSTR pszFormat, va_list);

protected:
	void				Init(void);

	static LPCTSTR		s_pszCom2;
	static LPCTSTR		s_pszFile;
	static LPCTSTR		s_pszDebug;
	static LPCTSTR		s_pszBreak;

	static LPCTSTR		PszFile(void);

	static CTraceTag *	s_ptagFirst;
	static CTraceTag *	s_ptagLast;
	CTraceTag *			m_ptagNext;
//	static HANDLE			s_hfileCom2;

	static CRITICAL_SECTION	s_critsec;
	static BOOL				s_bCritSecValid;

	static BOOL				BCritSecValid(void) { return s_bCritSecValid; }

};  //*** class CTraceTag

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 extern		CTraceTag				g_tagAlways;
 extern		CTraceTag				g_tagError;
 void		Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...);
 void		TraceError(IN OUT CException & rexcept);
 void		TraceError(IN LPCTSTR pszModule, IN SC sc);
 void		InitAllTraceTags(void);
 void		CleanupAllTraceTags(void);
 void		TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix);

// extern		LPTSTR		g_pszTraceIniFile;
 extern		CString		g_strTraceFile;
 extern		BOOL		g_bBarfDebug;

#else // _DEBUG

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
 inline void TraceError(IN OUT CException & rexcept)	{ }
 inline void TraceError(IN LPCTSTR pszModule, IN SC sc)	{ }
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 inline void InitAllTraceTags(void)						{ }
 inline void CleanupAllTraceTags(void)					{ }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.cpp
//
//  Description:
//      Implementation of classes used to create new clusters or add nodes
//      to existing clusters.
//
//  Maintained By:
//      David Potter    (DavidP)    16-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <clusrtl.h>
#include <commctrl.h>
#include "ClusCfg.h"
#include "Util.h"
#include "Resource.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  __inline
//  void
//  FlipIpAddress(
//        ULONG *   pulAddrOut
//      , ULONG     ulAddrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
__inline
void
FlipIpAddress(
      ULONG *   pulAddrOut
    , ULONG     ulAddrIn
    )
{
    *pulAddrOut = ( FIRST_IPADDRESS( ulAddrIn ) )
                | ( SECOND_IPADDRESS( ulAddrIn ) << 8 )
                | ( THIRD_IPADDRESS( ulAddrIn ) << 16 )
                | ( FOURTH_IPADDRESS( ulAddrIn ) << 24 );

} //*** FlipIpAddress()

//****************************************************************************
//
//  class CBaseClusCfg
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::CBaseClusCfg( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusCfg::CBaseClusCfg( void )
    : m_fVerbose( FALSE )
    , m_cSpins( 0 )
    , m_psp( NULL )
    , m_pom( NULL )
    , m_ptm( NULL )
    , m_pcpc( NULL )
    , m_cookieCluster( 0 )
    , m_cRef( 0 )
    , m_ptac( NULL )
    , m_cookieCompletion( 0 )
    , m_fTaskDone( FALSE )
    , m_hrResult( S_OK )
    , m_hEvent( NULL )
{
} //*** CBaseClusCfg::CBaseClusCfg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::~CBaseClusCfg( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusCfg::~CBaseClusCfg( void )
{
    if ( m_psp != NULL )
    {
        m_psp->Release();
    }
    if ( m_pom != NULL )
    {
        m_pom->Release();
    }
    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    }
    if ( m_pcpc != NULL )
    {
        m_pcpc->Release();
    }
    if ( m_ptac != NULL )
    {
        m_ptac->Release();
    }
    if ( m_hEvent != NULL )
    {
        CloseHandle( m_hEvent );
    }

    _ASSERTE( m_cRef == 0 );

} //*** CBaseClusCfg::~CBaseClusCfg()

//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusCfg::ReportProgress(
//        LPCWSTR   pcwszFmtIn
//      , ...
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusCfg::ReportProgress(
      LPCWSTR   pcwszFmtIn
    , ...
    )
{
    if ( m_fVerbose )
    {
        va_list vlMarker;
        va_start( vlMarker, pcwszFmtIn );
        vwprintf( pcwszFmtIn, vlMarker );
        va_end( vlMarker );

    } // if: verbose reporting is on

} //*** CBaseClusCfg::ReportProgress()

//****************************************************************************
//
//  class CBaseClusCfg [IUnknown]
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  [IUnknown]
//  STDMETHODIMP_( ULONG )
//  CBaseClusCfg::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBaseClusCfg::AddRef( void )
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;

} //*** CBaseClusCfg::AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  [IUnknown]
//  STDMETHODIMP_( ULONG )
//  CBaseClusCfg::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBaseClusCfg::Release( void )
{
    LONG    cRef = m_cRef;
    InterlockedDecrement( &m_cRef );
    return --cRef;

} //*** CBaseClusCfg::Release()

//////////////////////////////////////////////////////////////////////////////
//
//  [IUnknown]
//  STDMETHODIMP
//  CBaseClusCfg::QueryInterface(
//        REFIID    riid
//      , LPVOID *  ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBaseClusCfg::QueryInterface(
      REFIID    riid
    , LPVOID *  ppv
    )
{
    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = this;
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = this;
        hr   = S_OK;
    } // else if: IClusCfgCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    return hr;

} //*** CBaseClusCfg::QueryInterface()

//****************************************************************************
//
//  class CBaseClusCfg [IClusCfgCallback]
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgCallback]
//  STDMETHODIMP
//  CBaseClusCfg::SendStatusReport(
//        LPCWSTR       pcszNodeNameIn
//      , CLSID         clsidTaskMajorIn
//      , CLSID         clsidTaskMinorIn
//      , ULONG         ulMinIn
//      , ULONG         ulMaxIn
//      , ULONG         ulCurrentIn
//      , HRESULT       hrStatusIn
//      , LPCWSTR       pcszDescriptionIn
//      , FILETIME *    pftTimeIn
//      , LPCWSTR       pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBaseClusCfg::SendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    HRESULT                 hr      = S_OK;
    CString                 strMsg;
    CString                 strMajorMsg;
    CString                 strMinorMsg;
    LPCWSTR                 pszErrorPad;
    UINT                    idsTask;
    int                     idx;
    STaskToDescription *    pttd    = NULL;

    struct  STaskIDToIDS
    {
        const GUID *    guid;
        UINT            ids;
    };
    static STaskIDToIDS s_ttiMajor[] =
    {
         { &TASKID_Major_Checking_For_Existing_Cluster, IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER }
       , { &TASKID_Major_Establish_Connection,          IDS_TASKID_MAJOR_ESTABLISH_CONNECTION }
       , { &TASKID_Major_Check_Node_Feasibility,        IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY }
       , { &TASKID_Major_Find_Devices,                  IDS_TASKID_MAJOR_FIND_DEVICES }
       , { &TASKID_Major_Check_Cluster_Feasibility,     IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY }
       , { &TASKID_Major_Reanalyze,                     IDS_TASKID_MAJOR_REANALYZE }
       , { &TASKID_Major_Configure_Cluster_Services,    IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES }
       , { &TASKID_Major_Configure_Resource_Types,      IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES }
       , { &TASKID_Major_Configure_Resources,           IDS_TASKID_MAJOR_CONFIGURE_RESOURCES }
       , { NULL, 0 }
    };
    static CLSID    s_taskidMajor = { 0 };

    // Make sure no one else is in this routine at the same time.
    m_critsec.Lock();

    m_cSpins++;

    if ( ! m_fVerbose )
    {
        putwchar( L'.' );
        goto Cleanup;
    }

    //
    // Don't display this report if it is only intended for a log file.
    //

    if (    IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_Log )
        ||  IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log )
        ||  IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_And_Server_Log )
        ||  IsEqualIID( clsidTaskMajorIn, IID_NULL )
        )
    {
        goto Cleanup;
    } // if: log-only message

    //
    // Translate the major ID to a string ID.
    //

    // Find the major ID in the table.
    idsTask = IDS_TASKID_UNKNOWN;
    for ( idx = 0 ; s_ttiMajor[ idx ].guid != NULL ; idx++ )
    {
        if ( IsEqualIID( clsidTaskMajorIn, *s_ttiMajor[ idx ].guid ) )
        {
            idsTask = s_ttiMajor[ idx ].ids;
            break;
        }
    } // for: each task ID in the table

    // Display the text for the major ID.
    strMsg.LoadString( idsTask );
    strMajorMsg.Format( L"\n  %ls", strMsg );

    //
    // Display the description if it is specified.
    // If it is not specified, search the minor task list for the minor task
    // ID and display the saved description for that node/task ID combination.
    //

    if ( pcszDescriptionIn != NULL )
    {
        //
        // If a node was specified, prefix the message with the node name.
        //

        if ( ( pcszNodeNameIn != NULL )
          && ( *pcszNodeNameIn != L'\0' ) )
        {
            LPWSTR  psz;

            //  Shorten the FDQN DNS name to only the hostname.
            psz = wcschr( pcszNodeNameIn, L'.' );
            if ( psz != NULL )
            {
                *psz = L'\0';
            }

            // Construct the message.
            strMinorMsg.Format( L"\n    %ls: %ls", pcszNodeNameIn, pcszDescriptionIn );

            // Restore the dot we removed from the FQDN.
            if ( psz != NULL )
            {
                *psz = L'.';
            }
        } // if: a node name was specified
        else
        {
            strMinorMsg.Format( L"\n    %ls", pcszDescriptionIn );
        }

        pszErrorPad = L"\n      ";

        //
        // Save the description in the list.
        //

        hr = HrInsertTask(
                  clsidTaskMajorIn
                , clsidTaskMinorIn
                , pcszNodeNameIn
                , strMinorMsg
                , &pttd
                );
        if ( FAILED( hr ) )
        {
        }
    } // if: description specified
    else
    {
        //
        // Find the node/task-ID combination in the list.
        //

        pttd = PttdFindTask( clsidTaskMajorIn, clsidTaskMinorIn, pcszNodeNameIn );
        if ( pttd != NULL )
        {
            strMinorMsg = pttd->bstrDescription;
            pszErrorPad = L"\n      ";
        }
        else
        {
            pszErrorPad = L"\n    ";
        }
    } // else: no description specified

    // If this is a different major task, display the major task information.
    if ( ! IsEqualIID( clsidTaskMajorIn, s_taskidMajor )
      || ( strMinorMsg.GetLength() == 0 ) )
    {
        PrintString( strMajorMsg );
    }
    CopyMemory( &s_taskidMajor, &clsidTaskMajorIn, sizeof( s_taskidMajor ) );

    // If there is a minor task message, display it.
    if ( strMinorMsg.GetLength() > 0 )
    {
        PrintString( strMinorMsg );
    }

    // Display the progress information.
    strMsg.Format( IDS_CLUSCFG_PROGRESS_FORMAT, ulCurrentIn, ulMaxIn );
    PrintString( strMsg );

    // If an error occurred, display the text translation.
    if ( FAILED( hrStatusIn ) )
    {
        PrintSystemError( hrStatusIn, pszErrorPad );
    }

Cleanup:
    m_critsec.Unlock();
    return hr;

} //*** CBaseClusCfg::SendStatusReport()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STaskToDescription *
//  CBaseClusCfg::PttdFindTask(
//        CLSID     taskidMajorIn
//      , CLSID     taskidMinorIn
//      , LPCWSTR   pcwszNodeName
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STaskToDescription *
CBaseClusCfg::PttdFindTask(
      CLSID     taskidMajorIn
    , CLSID     taskidMinorIn
    , LPCWSTR   pcwszNodeNameIn
    )
{
    std::list< STaskToDescription >::iterator   itCurValue  = m_lttd.begin();
    std::list< STaskToDescription >::iterator   itLast      = m_lttd.end();
    STaskToDescription *                        pttd        = NULL;
    STaskToDescription *                        pttdNext    = NULL;

    for ( ; itCurValue != itLast ; itCurValue++ )
    {
        pttdNext = &(*itCurValue);
        if ( IsEqualIID( pttdNext->taskidMajor, taskidMajorIn )
          && IsEqualIID( pttdNext->taskidMinor, taskidMinorIn )
          && ( ( pttdNext->bstrNodeName == pcwszNodeNameIn )
            || ( ( pcwszNodeNameIn != NULL )
              && ( _wcsicmp( pttdNext->bstrNodeName, pcwszNodeNameIn ) == 0 ) ) )
            )
        {
            pttd = pttdNext;
            break;
        } // if: found a match
    } // for: each item in the list

    return pttd;

} //*** CBaseClusCfg::PttdFindTask()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CBaseClusCfg::HrInsertTask(
//        CLSID                 taskidMajorIn
//      , CLSID                 taskidMinorIn
//      , LPCWSTR               pcwszNodeNameIn
//      , LPCWSTR               pcwszDescriptionIn
//      , STaskToDescription ** ppttd
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBaseClusCfg::HrInsertTask(
      CLSID                 taskidMajorIn
    , CLSID                 taskidMinorIn
    , LPCWSTR               pcwszNodeNameIn
    , LPCWSTR               pcwszDescriptionIn
    , STaskToDescription ** ppttd
    )
{
    HRESULT                                     hr              = S_OK;
    std::list< STaskToDescription >::iterator   itCurValue      = m_lttd.begin();
    std::list< STaskToDescription >::iterator   itLast          = m_lttd.end();
    BSTR                                        bstrDescription = NULL;
    STaskToDescription *                        pttdNext        = NULL;
    STaskToDescription                          ttd;

    _ASSERTE( pcwszDescriptionIn != NULL );
    _ASSERTE( ppttd != NULL );

    // Find the task to see if all we need to do is replace the description.
    for ( ; itCurValue != itLast ; itCurValue++ )
    {
        pttdNext = &(*itCurValue);
        if ( IsEqualIID( pttdNext->taskidMajor, taskidMajorIn )
          && IsEqualIID( pttdNext->taskidMinor, taskidMinorIn )
          && ( ( pttdNext->bstrNodeName == pcwszNodeNameIn )
            || ( _wcsicmp( pttdNext->bstrNodeName, pcwszNodeNameIn ) == 0 ) )
            )
        {
            bstrDescription = SysAllocString( pcwszDescriptionIn );
            if ( bstrDescription == NULL )
                goto OutOfMemory;
            SysFreeString( pttdNext->bstrDescription );
            pttdNext->bstrDescription = bstrDescription;
            bstrDescription = NULL;     // prevent cleanup after transfering ownership
            *ppttd = pttdNext;
            goto Cleanup;
        } // if: found a match
    } // for: each item in the list

    //
    // The task was not found in the list.  Insert a new entry.
    //

    CopyMemory( &ttd.taskidMajor, &taskidMajorIn, sizeof( ttd.taskidMajor ) );
    CopyMemory( &ttd.taskidMinor, &taskidMinorIn, sizeof( ttd.taskidMinor ) );
    if ( pcwszNodeNameIn == NULL )
    {
        ttd.bstrNodeName = NULL;
    }
    else
    {
        ttd.bstrNodeName = SysAllocString( pcwszNodeNameIn );
        if ( ttd.bstrNodeName == NULL )
            goto OutOfMemory;
    }
    ttd.bstrDescription = SysAllocString( pcwszDescriptionIn );
    if ( ttd.bstrDescription == NULL )
        goto OutOfMemory;
    itCurValue = m_lttd.insert( m_lttd.end(), ttd );
    ttd.bstrNodeName = NULL;
    ttd.bstrDescription = NULL;
    *ppttd = &(*itCurValue);

Cleanup:
    if ( bstrDescription != NULL )
    {
        SysFreeString( bstrDescription );
    }
    if ( ttd.bstrNodeName != NULL )
    {
        SysFreeString( ttd.bstrNodeName );
    }
    if ( ttd.bstrDescription != NULL )
    {
        SysFreeString( ttd.bstrDescription );
    }

    return hr;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CBaseClusCfg::HrInsertTask()

//****************************************************************************
//
//  class CCreateCluster
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCreateCluster::HrCreateCluster(
//        BOOL      fVerbose
//      , LPCWSTR   pcszClusterNameIn
//      , LPCWSTR   pcszNodeNameIn
//      , LPCWSTR   pcszUserAccountIn
//      , LPCWSTR   pcszUserDomainIn
//      , LPCWSTR   pcszUserPasswordIn
//      , LPCWSTR   pcwszIPAddressIn
//      , LPCWSTR   pcwszIPSubnetIn
//      , LPCWSTR   pcwszNetworkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrCreateCluster(
      BOOL      fVerbose
    , LPCWSTR   pcszClusterNameIn
    , LPCWSTR   pcszNodeNameIn
    , LPCWSTR   pcszUserAccountIn
    , LPCWSTR   pcszUserDomainIn
    , LPCWSTR   pcszUserPasswordIn
    , LPCWSTR   pcwszIPAddressIn
    , LPCWSTR   pcwszIPSubnetIn
    , LPCWSTR   pcwszNetworkIn
    )
{
    HRESULT                 hr      = S_OK;
    DWORD                   dwStatus;
    DWORD                   dwAdviseCookie = 0;
    IUnknown *              punk    = NULL;
    IClusCfgClusterInfo *   pccci   = NULL;
    IClusCfgNetworkInfo *   pccni   = NULL;
    IClusCfgCredentials *   pccc    = NULL;
    IConnectionPoint *      pcp     = NULL;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;
    OBJECTCOOKIE            cookieNode;
    CString                 strMsg;

    m_fVerbose = fVerbose;

    //
    // Summarize what we are doing.
    //

    strMsg.FormatMessage(
          IDS_CLUSCFG_PREPARING_TO_CREATE_CLUSTER
        , pcszClusterNameIn
        , pcszNodeNameIn
        , pcszUserDomainIn
        , pcszUserAccountIn
        );
    wprintf( L"%ls", strMsg );

    //
    // Get the service manager.
    //

    hr = CoCreateInstance(
                  CLSID_ServiceManager
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IServiceProvider
                , reinterpret_cast< void ** >( &m_psp )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the object manager.
    //

    hr = m_psp->QueryService(
                  CLSID_ObjectManager
                , IID_IObjectManager
                , reinterpret_cast< void ** >( &m_pom )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the notification manager.
    //

    hr = m_psp->QueryService(
                  CLSID_NotificationManager
                , IID_IConnectionPointContainer
                , reinterpret_cast< void ** >( &m_pcpc )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Set the callback interface so the middle tier can report errors
    // back to the UI layer, in this case, cluster.exe.
    //

    hr = m_pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) ;
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = pcp->Advise( this, &dwAdviseCookie );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the cluster cookie.
    // This also starts the middle-tier searching for the specified cluster.
    //

    hr = m_pom->FindObject(
                  CLSID_ClusterConfigurationType
                , NULL
                , pcszClusterNameIn
                , DFGUID_ClusterConfigurationInfo
                , &m_cookieCluster
                , &punk // dummy
                );
    _ASSERTE( punk == NULL );
    if ( hr == MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE ) )
    {
        hr = S_OK;  // ignore it - we could be forming
    }
    else if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
        goto Cleanup;

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    // Get the task manager.
    //

    hr = m_psp->QueryService(
                  CLSID_TaskManager
                , IID_ITaskManager
                , reinterpret_cast< void ** >( &m_ptm )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a new Analyze task.
    //

    // Create the task.
    hr = m_ptm->CreateTask( TASK_AnalyzeCluster, &punk );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskAnalyzeCluster, reinterpret_cast< void ** >( &m_ptac ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set a cookie to the cluster into the task.
    hr = m_ptac->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Set the node as a child of the cluster.
    // This also starts the middle-teir searching for the specified node.
    //

    hr = m_pom->FindObject(
                  CLSID_NodeType
                , m_cookieCluster
                , pcszNodeNameIn
                , DFGUID_NodeInformation
                , &cookieNode
                , &punk // dummy
                );
    if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
        goto Cleanup;

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    // Execute the Analyze task and wait for it to complete.
    //

    strMsg.LoadString( IDS_CLUSCFG_ANALYZING );
    wprintf( L"\n%ls", strMsg );

    hr = m_ptac->BeginTask();
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the cluster configuration object interface
    // and indicate that we are forming.
    //

    // Get a punk from the cookie.
    hr = m_pom->GetObject(
                      DFGUID_ClusterConfigurationInfo
                    , m_cookieCluster
                    , &punk
                    );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Query for the IClusCfgClusterInfo interface.
    hr = punk->QueryInterface(
                      IID_IClusCfgClusterInfo
                    , reinterpret_cast< void ** >( &pccci )
                    );
    if ( FAILED( hr ) )
        goto Cleanup;
    punk->Release();
    punk = NULL;

    // Indicate that we are creating a cluster
    hr = pccci->SetCommitMode( cmCREATE_CLUSTER );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Set the network information.
    //

    // Specify the IP address info.
    {
        //ULONG   ulIPTemp;

        //dwStatus = ClRtlTcpipStringToAddress( pcwszIPAddressIn, &ulIPTemp );
        dwStatus = ClRtlTcpipStringToAddress( pcwszIPAddressIn, &ulIPAddress );
        if ( dwStatus != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwStatus );
            goto Cleanup;
        }

        // KB: 09-NOV-2000 DavidP   DontFlipIP
        //      Flipping IP addresses is no longer necessary due to some
        //      changes that were made to the middle tier.
        //FlipIpAddress( &ulIPAddress, ulIPTemp );
    }

    hr = pccci->SetIPAddress( ulIPAddress );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( ( pcwszIPSubnetIn != NULL )
      && ( *pcwszIPSubnetIn != L'\0' ) )
    {
        // Set the subnet mask.
        {
            //ULONG   ulIPTemp;

            //dwStatus = ClRtlTcpipStringToAddress( pcwszIPSubnetIn, &ulIPTemp );
            dwStatus = ClRtlTcpipStringToAddress( pcwszIPSubnetIn, &ulIPSubnet );
            if ( dwStatus != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwStatus );
                goto Cleanup;
            }

            // KB: 09-NOV-2000 DavidP   DontFlipIP
            //      Flipping IP addresses is no longer necessary due to some
            //      changes that were made to the middle tier.
            //FlipIpAddress( &ulIPSubnet, ulIPTemp );
        }

        hr = pccci->SetSubnetMask( ulIPSubnet );
        if ( FAILED( hr ) )
            goto Cleanup;

        // Find the network object for the specified network.
        _ASSERTE( pcwszNetwork != NULL );
        hr = HrFindNetwork( cookieNode, pcwszNetworkIn, &pccni );
        if ( FAILED( hr ) )
            goto Cleanup;

        // Set the network.
        hr = pccci->SetNetworkInfo( pccni );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: subnet was specified
    else
    {
        // Find a matching subnet mask and network.
        hr = HrMatchNetworkInfo( cookieNode, ulIPAddress, &ulIPSubnet, &pccni );
        if ( FAILED( hr ) )
            goto Cleanup;

        // Set the subnet mask.
        hr = pccci->SetSubnetMask( ulIPSubnet );
        if ( FAILED( hr ) )
            goto Cleanup;

        // Set the network.
        hr = pccci->SetNetworkInfo( pccni );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // else: no subnet specified

    //
    // Set service account credentials.
    //

    // Get the credentials object.
    hr = pccci->GetClusterServiceAccountCredentials( &pccc );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set the new credentials.
    hr = pccc->SetCredentials( pcszUserAccountIn, pcszUserDomainIn, pcszUserPasswordIn );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Create the Commit Cluster Changes task.
    //

    // Create the task.
    hr = m_ptm->CreateTask( TASK_CommitClusterChanges, &punk );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskCommitClusterChanges, reinterpret_cast< void ** >( &m_ptccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set a cookie to the cluster into the task.
    hr = m_ptccc->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // (jfranco, bug 352181)
    // Reset the proper codepage to use for CRT routines.
    // KB: somehow the locale gets screwed up in the preceding code.  Don't know why, but this fixes it.
    //
    MatchCRTLocaleToConsole( ); // okay to proceed if this fails?
    
    //
    // Create the cluster.
    //

    strMsg.LoadString( IDS_CLUSCFG_CREATING );
    wprintf( L"\n%ls", strMsg );

    m_fTaskDone = FALSE;    // reset before commiting task

    hr = m_ptccc->BeginTask();
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( ! FAILED( hr ) )
    {
        strMsg.LoadString( IDS_CLUSCFG_DONE );
        wprintf( L"\n%ls", strMsg );
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccc != NULL )
    {
        pccc->Release();
    }
    if ( pcp != NULL )
    {
        if ( dwAdviseCookie != 0 )
        {
            pcp->Unadvise( dwAdviseCookie );
        }

        pcp->Release( );
    }

    wprintf( L"\n" );

    return hr;

} //*** CCreateCluster::HrCreateCluster()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCreateCluster::HrInvokeWizard(
//        LPCWSTR      pcszClusterNameIn
//      , LPCWSTR      pcszNodeNameIn
//      , LPCWSTR      pcszUserAccountIn
//      , LPCWSTR      pcszUserDomainIn
//      , LPCWSTR      pcszUserPasswordIn
//      , LPCWSTR   pcwszIPAddressIn
//      , LPCWSTR   pcwszIPSubnetIn
//      , LPCWSTR   pcwszNetworkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrInvokeWizard(
      LPCWSTR      pcszClusterNameIn
    , LPCWSTR      pcszNodeNameIn
    , LPCWSTR      pcszUserAccountIn
    , LPCWSTR      pcszUserDomainIn
    , LPCWSTR      pcszUserPasswordIn
    , LPCWSTR   pcwszIPAddressIn
    , LPCWSTR   pcwszIPSubnetIn
    , LPCWSTR   pcwszNetworkIn
    )
{
    HRESULT             hr          = S_OK;
    IClusCfgWizard *    piWiz       = NULL;
    BOOL                fCommitted  = FALSE;
    BSTR                bstr        = NULL;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance( CLSID_ClusCfgWizard, NULL, CLSCTX_INPROC_SERVER, IID_IClusCfgWizard, (LPVOID *) &piWiz );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set the cluster name.
    if ( ( pcszClusterNameIn != NULL )
      && ( *pcszClusterNameIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszClusterNameIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ClusterName( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: cluster name specified

    // Set the node name.
    if ( ( pcszNodeNameIn != NULL )
      && ( *pcszNodeNameIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszNodeNameIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->AddComputer( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: node name specified

    // Set the service account name.
    if ( ( pcszUserAccountIn != NULL )
      && ( *pcszUserAccountIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszUserAccountIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ServiceAccountUserName( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: service account name specified

    // Set the service account password.
    if ( ( pcszUserPasswordIn != NULL )
      && ( *pcszUserPasswordIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszUserPasswordIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ServiceAccountPassword( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: service account password specified

    // Set the service account domain.
    if ( ( pcszUserDomainIn != NULL )
      && ( *pcszUserDomainIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszUserDomainIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ServiceAccountDomainName( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: service account domain specified

    // Set the IP address.
    if ( ( pcwszIPAddressIn != NULL )
      && ( *pcwszIPAddressIn != L'\0' ) )
    {
        bstr = SysAllocString( pcwszIPAddressIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ClusterIPAddress( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: IP address specified

    // Set the IP subnet.
    if ( ( pcwszIPSubnetIn != NULL )
      && ( *pcwszIPSubnetIn != L'\0' ) )
    {
        bstr = SysAllocString( pcwszIPSubnetIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ClusterIPSubnet( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: IP subnet specified

    // Set the IP address network.
    if ( ( pcwszNetworkIn != NULL )
      && ( *pcwszNetworkIn != L'\0' ) )
    {
        bstr = SysAllocString( pcwszNetworkIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ClusterIPAddressNetwork( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: IP address network specified

    // Display the wizard.
    hr = piWiz->CreateCluster( NULL, &fCommitted );
    if ( FAILED( hr ) )
        goto Cleanup;
    if ( ! fCommitted )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
    }

    goto Cleanup;

OutOfMemory:

    hr = E_OUTOFMEMORY;

Cleanup:
    if ( piWiz != NULL )
    {
        piWiz->Release();
    }

    SysFreeString( bstr );

    return hr;

} //*** CCreateCluster::HrInvokeWizard()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCreateCluster::HrFindNetwork(
//        OBJECTCOOKIE              cookieNodeIn,
//      , LPCWSTR                   pcwszNetworkIn
//      , IClusCfgNetworkInfo **    ppccniOut,
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrFindNetwork(
      OBJECTCOOKIE              cookieNodeIn
    , LPCWSTR                   pcwszNetworkIn
    , IClusCfgNetworkInfo **    ppccniOut
    )
{
    HRESULT                 hr      = S_OK;
    IUnknown *              punk    = NULL;
    IEnumClusCfgNetworks *  peccn   = NULL;
    IClusCfgNetworkInfo *   pccni   = NULL;
    OBJECTCOOKIE            cookieDummy;
    CComBSTR                combstr;
    ULONG                   celtDummy;

    _ASSERTE( m_pom != NULL );

    //
    // Get the network enumerator.
    //
    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        hr = m_pom->FindObject(
                      CLSID_NetworkType
                    , cookieNodeIn
                    , NULL
                    , DFGUID_EnumManageableNetworks
                    , &cookieDummy
                    , &punk
                    );
        if ( hr == E_PENDING )
        {
            Sleep( 1000 );  // 1 second
            if ( punk != NULL )
            {
                punk->Release();
                punk = NULL;
            }
            continue;
        }
        if ( FAILED( hr ) )
            goto Cleanup;
    } // while: pending

    // Query for the IEnumClusCfgNetworks interface.
    hr = punk->QueryInterface(
                      IID_IEnumClusCfgNetworks
                    , reinterpret_cast< LPVOID * >( &peccn )
                    );
    if ( FAILED( hr ) )
        goto Cleanup;
    punk->Release();
    punk = NULL;

    //
    // Loop through each network looking for one that matches the
    // one specified.
    //
    for ( ;; )
    {
        // Get the next network.
        hr = peccn->Next( 1, &pccni, &celtDummy );
        if ( FAILED( hr ) )
            goto Cleanup;
        if ( hr == S_FALSE )
            break;

        // Get the name of the network.
        hr = pccni->GetName( &combstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( _wcsicmp( combstr, pcwszNetworkIn ) == 0 )
        {
            // Check to see if this is a public network or not.
            hr = pccni->IsPublic();
            if ( FAILED( hr ) )
                goto Cleanup;
            if ( hr == S_FALSE )
            {
                // Display an error message.
            } // if: not a public network

            *ppccniOut = pccni;
            pccni->AddRef();
            break;
        } // if: found a match
    } // forever

Cleanup:
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    return hr;

} //*** CCreateCluster::HrFindNetwork()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCreateCluster::HrMatchNetworkInfo(
//        OBJECTCOOKIE              cookieNodeIn
//      , ULONG                     ulIPAddressIn
//      , ULONG *                   pulIPSubnetOut
//      , IClusCfgNetworkInfo **    ppccniOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrMatchNetworkInfo(
      OBJECTCOOKIE              cookieNodeIn
    , ULONG                     ulIPAddressIn
    , ULONG *                   pulIPSubnetOut
    , IClusCfgNetworkInfo **    ppccniOut
    )
{
    HRESULT                 hr      = S_OK;
    IUnknown *              punk    = NULL;
    IEnumClusCfgNetworks *  peccn   = NULL;
    IClusCfgNetworkInfo *   pccni   = NULL;
    IClusCfgIPAddressInfo * pccipai = NULL;
    OBJECTCOOKIE            cookieDummy;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;
    ULONG                   celtDummy;

    _ASSERTE( m_pom != NULL );

    //
    // Get the network enumerator.
    //
    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        hr = m_pom->FindObject(
                      CLSID_NetworkType
                    , cookieNodeIn
                    , NULL
                    , DFGUID_EnumManageableNetworks
                    , &cookieDummy
                    , &punk
                    );
        if ( hr == E_PENDING )
        {
            Sleep( 1000 );  // 1 second
            if ( punk != NULL )
            {
                punk->Release();
                punk = NULL;
            }
            continue;
        }
        if ( FAILED( hr ) )
            goto Cleanup;
    } // while: pending

    // Query for the IEnumClusCfgNetworks interface.
    hr = punk->QueryInterface(
                      IID_IEnumClusCfgNetworks
                    , reinterpret_cast< LPVOID * >( &peccn )
                    );
    if ( FAILED( hr ) )
        goto Cleanup;
    punk->Release();
    punk = NULL;

    //
    // Loop through each network looking for one that matches the
    // IP address specified.
    //
    for ( ;; )
    {
        // Get the next network.
        hr = peccn->Next( 1, &pccni, &celtDummy );
        if ( FAILED( hr ) )
            goto Cleanup;
        if ( hr == S_FALSE )
        {
            hr = HRESULT_FROM_WIN32( ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP );
            goto Cleanup;
        } // if: no match found

        // If this is a public network, check its address and subnet.
        hr = pccni->IsPublic();
        if ( FAILED( hr ) )
            goto Cleanup;
        if ( hr == S_OK )
        {
            // Get the IP Address Info for the network.
            hr = pccni->GetPrimaryNetworkAddress( &pccipai );
            if ( FAILED( hr ) )
                goto Cleanup;

            // Get the address and subnet of the network.
            hr = pccipai->GetIPAddress( &ulIPAddress );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = pccipai->GetSubnetMask( &ulIPSubnet );
            if ( FAILED( hr ) )
                goto Cleanup;

            // Determine if these match.
            if ( ClRtlAreTcpipAddressesOnSameSubnet( ulIPAddressIn, ulIPAddress, ulIPSubnet ) )
            {
                *pulIPSubnetOut = ulIPSubnet;
                *ppccniOut = pccni;
                (*ppccniOut)->AddRef();
                break;
            } // if: IP address matches network
        } // if: network is public

    } // forever

Cleanup:
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    if ( *ppccniOut == NULL )
    {
    } // if: no match was found

    return hr;

} //*** CCreateCluster::HrMatchNetworkInfo()

//****************************************************************************
//
//  class CAddNodesToCluster
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAddNodesToCluster::HrAddNodesToCluster(
//        BOOL      fVerboseIn
//      , LPCWSTR   pcszClusterNameIn
//      , BSTR      rgbstrNodesIn[]
//      , DWORD     cNodesIN
//      , LPCWSTR   pcszUserPasswordIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAddNodesToCluster::HrAddNodesToCluster(
      BOOL      fVerboseIn
    , LPCWSTR   pcszClusterNameIn
    , BSTR      rgbstrNodesIn[]
    , DWORD     cNodesIn
    , LPCWSTR   pcszUserPasswordIn
    )
{
    HRESULT                 hr      = S_OK;
    IUnknown *              punk    = NULL;
    IClusCfgClusterInfo *   pccci   = NULL;
    IClusCfgCredentials *   pccc    = NULL;
    IConnectionPoint *      pcp     = NULL;
    OBJECTCOOKIE            cookieNode;
    DWORD                   dwAdviseCookie = 0;
    CString                 strMsg;
    DWORD                   idxNode;
    BSTR                    bstrUserAccount     = NULL;
    BSTR                    bstrUserDomain      = NULL;
    BSTR                    bstrUserPassword    = NULL;

    m_fVerbose = fVerboseIn;

    //
    // Summarize what we are doing.
    //

    strMsg.FormatMessage(
          IDS_CLUSCFG_PREPARING_TO_ADD_NODES
        , pcszClusterNameIn
        );
    wprintf( L"%ls", strMsg );
    for ( idxNode = 0 ; idxNode < cNodesIn ; idxNode++ )
    {
        strMsg.FormatMessage(
                  IDS_CLUSCFG_PREPARING_TO_ADD_NODES_2
                , rgbstrNodesIn[ idxNode ]
                );
        wprintf( L"\n%ls", strMsg );
    } // for: each node

    //
    // Get the service manager.
    //

    hr = CoCreateInstance(
                  CLSID_ServiceManager
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IServiceProvider
                , reinterpret_cast< void ** >( &m_psp )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the object manager.
    //

    hr = m_psp->QueryService(
                  CLSID_ObjectManager
                , IID_IObjectManager
                , reinterpret_cast< void ** >( &m_pom )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the notification manager.
    //

    hr = m_psp->QueryService(
                  CLSID_NotificationManager
                , IID_IConnectionPointContainer
                , reinterpret_cast< void ** >( &m_pcpc )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Set the callback interface so the middle tier can report errors
    // back to the UI layer, in this case, cluster.exe.
    //

    hr = m_pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) ;
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = pcp->Advise( this, &dwAdviseCookie );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the cluster cookie.
    // This also starts the middle-tier searching for the specified cluster.
    //

    hr = m_pom->FindObject(
                  CLSID_ClusterConfigurationType
                , NULL
                , pcszClusterNameIn
                , DFGUID_ClusterConfigurationInfo
                , &m_cookieCluster
                , &punk // dummy
                );
    _ASSERTE( punk == NULL );
    if ( hr == MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE ) )
    {
        hr = S_OK;  // ignore it - we could be forming
    }
    else if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
        goto Cleanup;

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    // Get the task manager.
    //

    hr = m_psp->QueryService(
                  CLSID_TaskManager
                , IID_ITaskManager
                , reinterpret_cast< void ** >( &m_ptm )
                );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a new Analyze task.
    //

    // Create the task.
    hr = m_ptm->CreateTask( TASK_AnalyzeCluster, &punk );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskAnalyzeCluster, reinterpret_cast< void ** >( &m_ptac ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set a cookie to the cluster into the task.
    hr = m_ptac->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Indicate to the task that we want to join.
    hr = m_ptac->SetJoiningMode();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set each the node as a child of the cluster.
    // This also starts the middle-teir searching for the specified node.
    //

    for ( idxNode = 0 ; idxNode < cNodesIn ; idxNode++ )
    {
        hr = m_pom->FindObject(
                      CLSID_NodeType
                    , m_cookieCluster
                    , rgbstrNodesIn[ idxNode ]
                    , DFGUID_NodeInformation
                    , &cookieNode
                    , &punk // dummy
                    );
        if ( hr == E_PENDING )
        {
            hr = S_OK;  // ignore it - we just want the cookie!
        }
        else if ( FAILED( hr ) )
            goto Cleanup;

        if ( punk != NULL )
        {
            punk->Release();
            punk = NULL;
        }
    } // for: each node

    //
    // Execute the Analyze task and wait for it to complete.
    //

    strMsg.LoadString( IDS_CLUSCFG_ANALYZING );
    wprintf( L"\n%ls", strMsg );

    hr = m_ptac->BeginTask();
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the cluster configuration object interface
    // and indicate that we are joining.
    //

    // Get a punk from the cookie.
    hr = m_pom->GetObject(
                      DFGUID_ClusterConfigurationInfo
                    , m_cookieCluster
                    , &punk
                    );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Query for the IClusCfgClusterInfo interface.
    hr = punk->QueryInterface(
                      IID_IClusCfgClusterInfo
                    , reinterpret_cast< void ** >( &pccci )
                    );
    if ( FAILED( hr ) )
        goto Cleanup;
    punk->Release();
    punk = NULL;

    // Indicate that we are adding a node to the cluster
    hr = pccci->SetCommitMode( cmADD_NODE_TO_CLUSTER );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Set service account credentials.
    //

    // Get the credentials object.
    hr = pccci->GetClusterServiceAccountCredentials( &pccc );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get the existing credentials.
    hr = pccc->GetCredentials( &bstrUserAccount, &bstrUserDomain, &bstrUserPassword );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set the new credentials.
    hr = pccc->SetCredentials( bstrUserAccount, bstrUserDomain, pcszUserPasswordIn );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Create the Commit Cluster Changes task.
    //

    // Create the task.
    hr = m_ptm->CreateTask( TASK_CommitClusterChanges, &punk );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskCommitClusterChanges, reinterpret_cast< void ** >( &m_ptccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set a cookie to the cluster into the task.
    hr = m_ptccc->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // (jfranco, bug 352182)
    // KB: somehow the locale gets screwed up in the preceding code.  Don't know why, but this fixes it.
    //
    MatchCRTLocaleToConsole( ); // okay to proceed if this fails?
    
    //
    // Add the nodes to the cluster.
    //

    strMsg.LoadString( IDS_CLUSCFG_ADDING_NODES );
    wprintf( L"\n%ls", strMsg );

    m_fTaskDone = FALSE;    // reset before commiting task

    hr = m_ptccc->BeginTask();
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( ! FAILED( hr ) )
    {
        strMsg.LoadString( IDS_CLUSCFG_DONE );
        wprintf( L"\n%ls", strMsg );
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccc != NULL )
    {
        pccc->Release();
    }
    if ( pcp != NULL )
    {
        if ( dwAdviseCookie != 0 )
        {
            pcp->Unadvise( dwAdviseCookie );
        }

        pcp->Release( );
    }

    SysFreeString( bstrUserAccount );
    SysFreeString( bstrUserDomain );
    SysFreeString( bstrUserPassword );

    wprintf( L"\n" );

    return hr;

} //*** CAddNodesToCluster::HrAddNodesToCluster()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAddNodesToCluster::HrInvokeWizard(
//        LPCWSTR   pcszClusterNameIn
//      , BSTR      rgbstrNodesIn[]
//      , DWORD     cNodesIN
//      , LPCWSTR   pcszUserPasswordIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAddNodesToCluster::HrInvokeWizard(
      LPCWSTR   pcszClusterNameIn
    , BSTR      rgbstrNodesIn[]
    , DWORD     cNodesIn
    , LPCWSTR   pcszUserPasswordIn
    )
{
    HRESULT             hr          = S_OK;
    IClusCfgWizard *    piWiz       = NULL;
    BOOL                fCommitted  = FALSE;
    BSTR                bstr        = NULL;
    DWORD               iNode;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance( CLSID_ClusCfgWizard, NULL, CLSCTX_INPROC_SERVER, IID_IClusCfgWizard, (LPVOID *) &piWiz );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Set the cluster name.
    if ( ( pcszClusterNameIn != NULL )
      && ( *pcszClusterNameIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszClusterNameIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ClusterName( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: cluster name specified

    // Add each node.
    for ( iNode = 0 ; iNode < cNodesIn ; iNode++ )
    {
        hr = piWiz->AddComputer( rgbstrNodesIn[ iNode ] );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: node name specified

    // Set the service account password.
    if ( ( pcszUserPasswordIn != NULL )
      && ( *pcszUserPasswordIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszUserPasswordIn );
        if ( bstr == NULL )
            goto OutOfMemory;

        hr = piWiz->put_ServiceAccountPassword( bstr );
        if ( FAILED( hr ) )
            goto Cleanup;

        SysFreeString( bstr );
        bstr = NULL;
    } // if: service account password specified

    // Display the wizard.
    hr = piWiz->AddClusterNodes( NULL, &fCommitted );
    if ( FAILED( hr ) )
        goto Cleanup;
    if ( ! fCommitted )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
    }

    goto Cleanup;

OutOfMemory:

    hr = E_OUTOFMEMORY;

Cleanup:
    if ( piWiz != NULL )
    {
        piWiz->Release();
    }

    SysFreeString( bstr );

    return hr;

} //*** CAddNodesToCluster::HrInvokeWizard()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmmc\src\tracetag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TraceTag.cpp
//
//	Abstract:
//		Implementation of the CTraceTag class.
//
//	Author:
//		David Potter (davidp)	May 28, 1996
//
//	Revision History:
//
//	Notes:
//
//		TRACE_GetApp() must be defined to return a pointer to an object
//		that defines the GetProfileString() method.
//
//		TRACE_AppMessageBox must be defined and implemented.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winnls.h>
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef	_DEBUG

#ifndef CP_ANSI
#define CP_ANSI 1252
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag	g_tagAlways(_T("Debug"), _T("Always"), CTraceTag::tfDebug);
CTraceTag	g_tagError(_T("Debug"), _T("Error"), CTraceTag::tfDebug);

// g_pszTraceIniFile must be an LPTSTR so it exists before "{" of WinMain.
// If we make it a CString, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
//LPTSTR		g_pszTraceIniFile		= _T("Trace.INI");
CString		g_strTraceFile;
BOOL		g_bBarfDebug			= TRUE;

CRITICAL_SECTION	CTraceTag::s_critsec;
BOOL				CTraceTag::s_bCritSecValid = FALSE;

#endif	// _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTraceTag
/////////////////////////////////////////////////////////////////////////////

#ifdef	_DEBUG

//	Static Variables...

CTraceTag *		CTraceTag::s_ptagFirst	= NULL;
CTraceTag *		CTraceTag::s_ptagLast	= NULL;
//HANDLE			CTraceTag::s_hfileCom2	= NULL;
LPCTSTR			CTraceTag::s_pszCom2	= _T(" com2 ");
LPCTSTR			CTraceTag::s_pszFile	= _T(" file ");
LPCTSTR			CTraceTag::s_pszDebug	= _T(" debug ");
LPCTSTR			CTraceTag::s_pszBreak	= _T(" break ");

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::CTraceTag
//
//	Routine Description:
//		Constructor.  "Initializes" the tag by giving it its name, giving
//		it a startup value (from the registry if possible), and adding it
//		to the list of current tags.
//
//	Arguments:
//		pszSubsystem	[IN] 8 char string to say to what the tag applies
//		pszName			[IN] Description of the tag (~30 chars)
//		uiFlagsDefault	[IN] Default value.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::CTraceTag(
	IN LPCTSTR	pszSubsystem,
	IN LPCTSTR	pszName,
	IN UINT		uiFlagsDefault
	)
{
	//	Store the calling parameters
	m_pszSubsystem = pszSubsystem;
	m_pszName = pszName;
	m_uiFlagsDefault = uiFlagsDefault;
	m_uiFlags = uiFlagsDefault;

	//	Add the tag to the list of tags
	if (s_ptagLast != NULL)
		s_ptagLast->m_ptagNext = this;
	else
		s_ptagFirst = this;

	s_ptagLast = this;
	m_ptagNext = NULL;

	m_uiFlags = 0;

} //*** CTraceTag::CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::~CTraceTag
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::~CTraceTag(void)
{
#ifdef NEVER
	if (s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE))
	{
		::CloseHandle(s_hfileCom2);
		s_hfileCom2 = NULL;
	}
#endif

} //*** CTraceTag::~CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::Init
//
//	Routine Description:
//		Initializes the tag by giving it its name and giving it a startup value
//		(from the registry if possible).
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::Init(void)
{
	CString		strSection;
	CString		strValue;

	//	Get the value from the Registry.
	strSection.Format(TRACE_TAG_REG_SECTION_FMT, m_pszSubsystem);
	strValue = TRACE_GetApp()->GetProfileString(strSection, m_pszName);
	strValue.MakeLower();
	if (strValue.Find(s_pszCom2) != -1)
		m_uiFlags |= tfCom2;
	if (strValue.Find(s_pszFile) != -1)
		m_uiFlags |= tfFile;
	if (strValue.Find(s_pszDebug) != -1)
		m_uiFlags |= tfDebug;
	if (strValue.Find(s_pszBreak) != -1)
		m_uiFlags |= tfBreak;

} //*** CTraceTag::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::ConstructRegState
//
//	Routine Description:
//		Constructs the registry state string.
//
//	Arguments:
//		rstr		[OUT] String in which to return the state string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::ConstructRegState(OUT CString & rstr)
{
	rstr = _T("");
	if (BDebug())
		rstr += s_pszDebug;
	if (BBreak())
		rstr += s_pszBreak;
	if (BCom2())
		rstr += s_pszCom2;
	if (BFile())
		rstr += s_pszFile;

} //*** CTraceTag::ConstructRegState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::SetFlags
//
//	Routine Description:
//		Sets/Resets TraceFlags.
//
//	Arguments:
//		tf			[IN] Flags to set.
//		bEnable		[IN] TRUE = set the flags, FALSE = clear the flags.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlags(IN UINT tf, IN BOOL bEnable)
{
	if (bEnable)
		m_uiFlags |= tf;
	else
		m_uiFlags &= ~tf;

} //*** CTraceTag::SetFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::SetFlagsDialog
//
//	Routine Description:
//		Sets/Resets the "Dialog Settings"  version of the TraceFlags.
//
//	Arguments:
//		tf			[IN] Flags to set.
//		bEnable		[IN] TRUE = set the flags, FALSE = clear the flags.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlagsDialog(IN UINT tf, IN BOOL bEnable)
{
	if (bEnable)
		m_uiFlagsDialog |= tf;
	else
		m_uiFlagsDialog &= ~tf;

} //*** CTraceTag::SetFlagsDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::PszFile
//
//	Routine Description:
//		Returns the name of the file where to write the trace output.
//		The filename is read from the registry if it is unknown.
//
//	Arguments:
//		None.
//
//	Return Value:
//		psz		Name of the file.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CTraceTag::PszFile(void)
{
	static	BOOL	bInitialized	= FALSE;

	if (!bInitialized)
	{
		g_strTraceFile = TRACE_GetApp()->GetProfileString(
										TRACE_TAG_REG_SECTION,
										TRACE_TAG_REG_FILE,
										_T("C:\\Trace.out")
										);
		bInitialized = TRUE;
	}

	return g_strTraceFile;

} //*** CTraceTag::PszFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::TraceV
//
//	Routine Description:
//		Processes a Trace statement based on the flags of the tag.
//
//	Arguments:
//		pszFormat	[IN] printf-style format string.
//		va_list		[IN] Argument block for the format string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::TraceV(IN LPCTSTR pszFormat, va_list marker)
{
	CString		strTraceMsg;
	LPSTR		psz;
	int			cb;
	int			cbActual;
	
	// Get out quick with any formats if we're not turned on
	if (!m_pszName || !BAny())
		return;

	if (BCritSecValid())
		EnterCriticalSection(&s_critsec);

	FormatV(pszFormat, marker);
	strTraceMsg.Format(_T("%s: %s\x0D\x0A"), m_pszName, m_pchData);

	// Send trace output to the debug window.
	if (BDebug())
		OutputDebugString(strTraceMsg);

	if (BCom2() || BFile())
	{
#ifdef _UNICODE
		// Not much point in sending UNICODE output to COMM or file at the moment,
		// so convert to ANSI
		CHAR	aszTraceMsg[256];
		cb = ::WideCharToMultiByte(
					CP_ANSI,
					NULL,
					strTraceMsg,
					strTraceMsg.GetLength(),
					aszTraceMsg,
					sizeof(aszTraceMsg),
					NULL,
					NULL
					);
		psz = aszTraceMsg;
#else
		cb = strTraceMsg.GetLength();
		psz = (LPSTR) (LPCSTR) strTraceMsg;
#endif

		// Send trace output to COM2.
		if (BCom2())
		{
			HANDLE			hfile			= INVALID_HANDLE_VALUE;
			static	BOOL	bOpenFailed		= FALSE;

			if (!bOpenFailed)
			{
				hfile = ::CreateFile(
								_T("COM2:"),
								GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_FLAG_WRITE_THROUGH,
								NULL
								);
			} // if:  not currently in a 'COM2 failed to open' state
			
			if (hfile != INVALID_HANDLE_VALUE)
			{
				_ASSERTE(::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL));
//				_ASSERTE(::FlushFileBuffers(hfile));
				_ASSERTE(::CloseHandle(hfile));
			} // if:  COM2 opened successfully
			else
			{
				if (!bOpenFailed)
				{
					bOpenFailed = TRUE;		// Do this first, so the str.Format
											// do not cause problems with their trace statement.

					TRACE_AppMessageBox(_T("COM2 could not be opened."), MB_OK | MB_ICONINFORMATION);
				} // if:  open file didn't fail
			} // else:  file not opened successfully
		} // if:  sending trace output to COM2

		// Send trace output to a file.
		if (BFile())
		{
			HANDLE			hfile			= INVALID_HANDLE_VALUE;
			static	BOOL	bOpenFailed		= FALSE;

			if (!bOpenFailed)
			{
				hfile = ::CreateFile(
								PszFile(),
								GENERIC_WRITE,
								FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								FILE_FLAG_WRITE_THROUGH,
								NULL
								);
			} // if:  not currently in a 'file failed to open' state

			if (hfile != INVALID_HANDLE_VALUE)
			{
				// Fail these calls silently to avoid recursive failing calls.
				::SetFilePointer(hfile, NULL, NULL, FILE_END);
				::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL);
				::CloseHandle(hfile);
			} // if:  file opened successfully
			else
			{
				if (!bOpenFailed)
				{
					CString		strMsg;

					bOpenFailed = TRUE;		// Do this first, so the str.Format
											// do not cause problems with their trace statement.

					strMsg.Format(_T("The DEBUG ONLY trace log file '%s' could not be opened"), PszFile());
					TRACE_AppMessageBox(strMsg, MB_OK | MB_ICONINFORMATION);
				} // if:  open file didn't fail
			} // else:  file not opened successfully
		} // if:  sending trace output to a file
	} // if:  tracing to com and/or file

	// Do a DebugBreak on the trace.
	if (BBreak())
		DebugBreak();

	if (BCritSecValid())
		LeaveCriticalSection(&s_critsec);

} //*** CTraceTag::TraceFn()

#endif // _DEBUG


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#ifdef	_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Trace
//
//	Routine Description:
//		Maps the Trace statement to the proper method call.  This is needed
//		(instead of doing directly ptag->Trace()) to guarantee that no code
//		is added in the retail build.
//
//	Arguments:
//		rtag		[IN OUT] Tag controlling the debug output
//		pszFormat	[IN] printf style formatting string.
//		...			[IN] printf style parameters, depends on pszFormat
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...)
{
	va_list		marker;

	va_start(marker, pszFormat);
	rtag.TraceV(pszFormat, marker);
	va_end(marker);

} //*** Trace()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	TraceError
//
//	Routine Description:
//		Formats a standard error string and outputs it to all trace outputs.
//
//	Arguments:
//		rexcept		[IN OUT] Exception from which to obtain the message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN OUT CException & rexcept)
{
	TCHAR			szMessage[1024];

	rexcept.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

	Trace(
		g_tagError,
		_T("EXCEPTION: %s"),
		szMessage
		);

} //*** TraceError(CException&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	TraceError
//
//	Routine Description:
//		Formats a standard error string and outputs it to all trace outputs.
//
//	Arguments:
//		pszModule	[IN] Name of module in which error occurred.
//		sc			[IN] NT status code.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN LPCTSTR pszModule, IN SC sc)
{
	TCHAR			szMessage[1024];
	CNTException	nte(sc);

	nte.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

	Trace(
		g_tagError,
		_T("Module %s, SC = %#08lX = %d (10)\r\n = '%s'"),
		pszModule,
		sc,
		sc,
		szMessage
		);

} //*** TraceError(pszModule, sc)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	InitAllTraceTags
//
//	Routine Description:
//		Initializes all trace tags in the tag list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitAllTraceTags(void)
{
	CTraceTag *	ptag;

	// Loop through the tag list.
	for (ptag = CTraceTag::s_ptagFirst ; ptag != NULL ; ptag = ptag->m_ptagNext)
		ptag->Init();

	InitializeCriticalSection(&CTraceTag::s_critsec);
	CTraceTag::s_bCritSecValid = TRUE;

} //*** InitAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupAllTraceTags
//
//	Routine Description:
//		Cleanup after the trace tags.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupAllTraceTags(void)
{
	if (CTraceTag::BCritSecValid())
	{
		DeleteCriticalSection(&CTraceTag::s_critsec);
		CTraceTag::s_bCritSecValid = FALSE;
	} // if:  critical section is valid

} //*** CleanupAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	TraceMenu
//
//	Routine Description:
//		Display information about menus.
//
//	Arguments:
//		rtag		[IN OUT] Trace tag to use to display information.
//		pmenu		[IN] Menu to traverse.
//		pszPrefix	[IN] Prefix string to display.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceMenu(
	IN OUT CTraceTag &	rtag,
	IN const CMenu *	pmenu,
	IN LPCTSTR			pszPrefix
	)
{
	if (rtag.BAny())
	{
		UINT	cItems;
		UINT	iItem;
		UINT	nState;
		CString	strMenu;
#ifndef __AFXWIN_H__
		BSTR	bstrMenu;
#endif
		CString	strPrefix(pszPrefix);
		
		strPrefix += _T("->");

		cItems = pmenu->GetMenuItemCount();
		for (iItem = 0 ; iItem < cItems ; iItem++)
		{
#ifdef __AFXWIN_H__
			pmenu->GetMenuString(iItem, strMenu, MF_BYPOSITION);
#else // __ATLGDI_H__ must be defined
			pmenu->GetMenuString(iItem, bstrMenu, MF_BYPOSITION);
			strMenu = bstrMenu;
			SysFreeString(bstrMenu);
#endif
			nState = pmenu->GetMenuState(iItem, MF_BYPOSITION);
			if (nState & MF_SEPARATOR)
				strMenu += _T("SEPARATOR");
			if (nState & MF_CHECKED)
				strMenu += _T(" (checked)");
			if (nState & MF_DISABLED)
				strMenu += _T(" (disabled)");
			if (nState & MF_GRAYED)
				strMenu += _T(" (grayed)");
			if (nState & MF_MENUBARBREAK)
				strMenu += _T(" (MenuBarBreak)");
			if (nState & MF_MENUBREAK)
				strMenu += _T(" (MenuBreak)");
			if (nState & MF_POPUP)
				strMenu += _T(" (popup)");

			Trace(rtag, _T("(0x%08.8x) %s%s"), pszPrefix, pmenu->m_hMenu, strMenu);

			if (nState & MF_POPUP)
			{
#ifdef __AFXWIN_H__
				TraceMenu(rtag, pmenu->GetSubMenu(iItem), strPrefix);
#else // __ATLGDI_H__ must be defined
				CMenu submenu(pmenu->GetSubMenu(iItem));
				TraceMenu(rtag, &submenu, strPrefix);
			} // if:  popup menu
#endif
		} // for:  each item in the menu
	} // if:  any output is enabled

} //*** TraceMenu()

struct AFX_MAP_MESSAGE
{
	UINT    nMsg;
	LPCSTR  lpszMsg;
};

#include "dde.h"
#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
	DEFINE_MESSAGE(WM_CREATE),
	DEFINE_MESSAGE(WM_DESTROY),
	DEFINE_MESSAGE(WM_MOVE),
	DEFINE_MESSAGE(WM_SIZE),
	DEFINE_MESSAGE(WM_ACTIVATE),
	DEFINE_MESSAGE(WM_SETFOCUS),
	DEFINE_MESSAGE(WM_KILLFOCUS),
	DEFINE_MESSAGE(WM_ENABLE),
	DEFINE_MESSAGE(WM_SETREDRAW),
	DEFINE_MESSAGE(WM_SETTEXT),
	DEFINE_MESSAGE(WM_GETTEXT),
	DEFINE_MESSAGE(WM_GETTEXTLENGTH),
	DEFINE_MESSAGE(WM_PAINT),
	DEFINE_MESSAGE(WM_CLOSE),
	DEFINE_MESSAGE(WM_QUERYENDSESSION),
	DEFINE_MESSAGE(WM_QUIT),
	DEFINE_MESSAGE(WM_QUERYOPEN),
	DEFINE_MESSAGE(WM_ERASEBKGND),
	DEFINE_MESSAGE(WM_SYSCOLORCHANGE),
	DEFINE_MESSAGE(WM_ENDSESSION),
	DEFINE_MESSAGE(WM_SHOWWINDOW),
	DEFINE_MESSAGE(WM_CTLCOLORMSGBOX),
	DEFINE_MESSAGE(WM_CTLCOLOREDIT),
	DEFINE_MESSAGE(WM_CTLCOLORLISTBOX),
	DEFINE_MESSAGE(WM_CTLCOLORBTN),
	DEFINE_MESSAGE(WM_CTLCOLORDLG),
	DEFINE_MESSAGE(WM_CTLCOLORSCROLLBAR),
	DEFINE_MESSAGE(WM_CTLCOLORSTATIC),
	DEFINE_MESSAGE(WM_WININICHANGE),
	DEFINE_MESSAGE(WM_DEVMODECHANGE),
	DEFINE_MESSAGE(WM_ACTIVATEAPP),
	DEFINE_MESSAGE(WM_FONTCHANGE),
	DEFINE_MESSAGE(WM_TIMECHANGE),
	DEFINE_MESSAGE(WM_CANCELMODE),
	DEFINE_MESSAGE(WM_SETCURSOR),
	DEFINE_MESSAGE(WM_MOUSEACTIVATE),
	DEFINE_MESSAGE(WM_CHILDACTIVATE),
	DEFINE_MESSAGE(WM_QUEUESYNC),
	DEFINE_MESSAGE(WM_GETMINMAXINFO),
	DEFINE_MESSAGE(WM_ICONERASEBKGND),
	DEFINE_MESSAGE(WM_NEXTDLGCTL),
	DEFINE_MESSAGE(WM_SPOOLERSTATUS),
	DEFINE_MESSAGE(WM_DRAWITEM),
	DEFINE_MESSAGE(WM_MEASUREITEM),
	DEFINE_MESSAGE(WM_DELETEITEM),
	DEFINE_MESSAGE(WM_VKEYTOITEM),
	DEFINE_MESSAGE(WM_CHARTOITEM),
	DEFINE_MESSAGE(WM_SETFONT),
	DEFINE_MESSAGE(WM_GETFONT),
	DEFINE_MESSAGE(WM_QUERYDRAGICON),
	DEFINE_MESSAGE(WM_COMPAREITEM),
	DEFINE_MESSAGE(WM_COMPACTING),
	DEFINE_MESSAGE(WM_NCCREATE),
	DEFINE_MESSAGE(WM_NCDESTROY),
	DEFINE_MESSAGE(WM_NCCALCSIZE),
	DEFINE_MESSAGE(WM_NCHITTEST),
	DEFINE_MESSAGE(WM_NCPAINT),
	DEFINE_MESSAGE(WM_NCACTIVATE),
	DEFINE_MESSAGE(WM_GETDLGCODE),
	DEFINE_MESSAGE(WM_NCMOUSEMOVE),
	DEFINE_MESSAGE(WM_NCLBUTTONDOWN),
	DEFINE_MESSAGE(WM_NCLBUTTONUP),
	DEFINE_MESSAGE(WM_NCLBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_NCRBUTTONDOWN),
	DEFINE_MESSAGE(WM_NCRBUTTONUP),
	DEFINE_MESSAGE(WM_NCRBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_NCMBUTTONDOWN),
	DEFINE_MESSAGE(WM_NCMBUTTONUP),
	DEFINE_MESSAGE(WM_NCMBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_KEYDOWN),
	DEFINE_MESSAGE(WM_KEYUP),
	DEFINE_MESSAGE(WM_CHAR),
	DEFINE_MESSAGE(WM_DEADCHAR),
	DEFINE_MESSAGE(WM_SYSKEYDOWN),
	DEFINE_MESSAGE(WM_SYSKEYUP),
	DEFINE_MESSAGE(WM_SYSCHAR),
	DEFINE_MESSAGE(WM_SYSDEADCHAR),
	DEFINE_MESSAGE(WM_KEYLAST),
	DEFINE_MESSAGE(WM_INITDIALOG),
	DEFINE_MESSAGE(WM_COMMAND),
	DEFINE_MESSAGE(WM_SYSCOMMAND),
	DEFINE_MESSAGE(WM_TIMER),
	DEFINE_MESSAGE(WM_HSCROLL),
	DEFINE_MESSAGE(WM_VSCROLL),
	DEFINE_MESSAGE(WM_INITMENU),
	DEFINE_MESSAGE(WM_INITMENUPOPUP),
	DEFINE_MESSAGE(WM_MENUSELECT),
	DEFINE_MESSAGE(WM_MENUCHAR),
	DEFINE_MESSAGE(WM_ENTERIDLE),
	DEFINE_MESSAGE(WM_MOUSEMOVE),
	DEFINE_MESSAGE(WM_LBUTTONDOWN),
	DEFINE_MESSAGE(WM_LBUTTONUP),
	DEFINE_MESSAGE(WM_LBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_RBUTTONDOWN),
	DEFINE_MESSAGE(WM_RBUTTONUP),
	DEFINE_MESSAGE(WM_RBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_MBUTTONDOWN),
	DEFINE_MESSAGE(WM_MBUTTONUP),
	DEFINE_MESSAGE(WM_MBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_PARENTNOTIFY),
	DEFINE_MESSAGE(WM_MDICREATE),
	DEFINE_MESSAGE(WM_MDIDESTROY),
	DEFINE_MESSAGE(WM_MDIACTIVATE),
	DEFINE_MESSAGE(WM_MDIRESTORE),
	DEFINE_MESSAGE(WM_MDINEXT),
	DEFINE_MESSAGE(WM_MDIMAXIMIZE),
	DEFINE_MESSAGE(WM_MDITILE),
	DEFINE_MESSAGE(WM_MDICASCADE),
	DEFINE_MESSAGE(WM_MDIICONARRANGE),
	DEFINE_MESSAGE(WM_MDIGETACTIVE),
	DEFINE_MESSAGE(WM_MDISETMENU),
	DEFINE_MESSAGE(WM_CUT),
	DEFINE_MESSAGE(WM_COPY),
	DEFINE_MESSAGE(WM_PASTE),
	DEFINE_MESSAGE(WM_CLEAR),
	DEFINE_MESSAGE(WM_UNDO),
	DEFINE_MESSAGE(WM_RENDERFORMAT),
	DEFINE_MESSAGE(WM_RENDERALLFORMATS),
	DEFINE_MESSAGE(WM_DESTROYCLIPBOARD),
	DEFINE_MESSAGE(WM_DRAWCLIPBOARD),
	DEFINE_MESSAGE(WM_PAINTCLIPBOARD),
	DEFINE_MESSAGE(WM_VSCROLLCLIPBOARD),
	DEFINE_MESSAGE(WM_SIZECLIPBOARD),
	DEFINE_MESSAGE(WM_ASKCBFORMATNAME),
	DEFINE_MESSAGE(WM_CHANGECBCHAIN),
	DEFINE_MESSAGE(WM_HSCROLLCLIPBOARD),
	DEFINE_MESSAGE(WM_QUERYNEWPALETTE),
	DEFINE_MESSAGE(WM_PALETTEISCHANGING),
	DEFINE_MESSAGE(WM_PALETTECHANGED),
	DEFINE_MESSAGE(WM_DDE_INITIATE),
	DEFINE_MESSAGE(WM_DDE_TERMINATE),
	DEFINE_MESSAGE(WM_DDE_ADVISE),
	DEFINE_MESSAGE(WM_DDE_UNADVISE),
	DEFINE_MESSAGE(WM_DDE_ACK),
	DEFINE_MESSAGE(WM_DDE_DATA),
	DEFINE_MESSAGE(WM_DDE_REQUEST),
	DEFINE_MESSAGE(WM_DDE_POKE),
	DEFINE_MESSAGE(WM_DDE_EXECUTE),
	DEFINE_MESSAGE(WM_DROPFILES),
	DEFINE_MESSAGE(WM_POWER),
	DEFINE_MESSAGE(WM_WINDOWPOSCHANGED),
	DEFINE_MESSAGE(WM_WINDOWPOSCHANGING),
#ifdef __AFXWIN_H__
// MFC specific messages
	DEFINE_MESSAGE(WM_SIZEPARENT),
	DEFINE_MESSAGE(WM_SETMESSAGESTRING),
	DEFINE_MESSAGE(WM_IDLEUPDATECMDUI),
	DEFINE_MESSAGE(WM_INITIALUPDATE),
	DEFINE_MESSAGE(WM_COMMANDHELP),
	DEFINE_MESSAGE(WM_HELPHITTEST),
	DEFINE_MESSAGE(WM_EXITHELPMODE),
#endif
	DEFINE_MESSAGE(WM_HELP),
	DEFINE_MESSAGE(WM_NOTIFY),
	DEFINE_MESSAGE(WM_CONTEXTMENU),
	DEFINE_MESSAGE(WM_TCARD),
	DEFINE_MESSAGE(WM_MDIREFRESHMENU),
	DEFINE_MESSAGE(WM_MOVING),
	DEFINE_MESSAGE(WM_STYLECHANGED),
	DEFINE_MESSAGE(WM_STYLECHANGING),
	DEFINE_MESSAGE(WM_SIZING),
	DEFINE_MESSAGE(WM_SETHOTKEY),
	DEFINE_MESSAGE(WM_PRINT),
	DEFINE_MESSAGE(WM_PRINTCLIENT),
	DEFINE_MESSAGE(WM_POWERBROADCAST),
	DEFINE_MESSAGE(WM_HOTKEY),
	DEFINE_MESSAGE(WM_GETICON),
	DEFINE_MESSAGE(WM_EXITMENULOOP),
	DEFINE_MESSAGE(WM_ENTERMENULOOP),
	DEFINE_MESSAGE(WM_DISPLAYCHANGE),
	DEFINE_MESSAGE(WM_STYLECHANGED),
	DEFINE_MESSAGE(WM_STYLECHANGING),
	DEFINE_MESSAGE(WM_GETICON),
	DEFINE_MESSAGE(WM_SETICON),
	DEFINE_MESSAGE(WM_SIZING),
	DEFINE_MESSAGE(WM_MOVING),
	DEFINE_MESSAGE(WM_CAPTURECHANGED),
	DEFINE_MESSAGE(WM_DEVICECHANGE),
	DEFINE_MESSAGE(WM_PRINT),
	DEFINE_MESSAGE(WM_PRINTCLIENT),
// MFC private messages
#ifdef __AFXWIN_H__
	DEFINE_MESSAGE(WM_QUERYAFXWNDPROC),
	DEFINE_MESSAGE(WM_RECALCPARENT),
	DEFINE_MESSAGE(WM_SIZECHILD),
	DEFINE_MESSAGE(WM_KICKIDLE),
	DEFINE_MESSAGE(WM_QUERYCENTERWND),
	DEFINE_MESSAGE(WM_DISABLEMODAL),
	DEFINE_MESSAGE(WM_FLOATSTATUS),
	DEFINE_MESSAGE(WM_ACTIVATETOPLEVEL),
	DEFINE_MESSAGE(WM_QUERY3DCONTROLS),
	DEFINE_MESSAGE(WM_RESERVED_0370),
	DEFINE_MESSAGE(WM_RESERVED_0371),
	DEFINE_MESSAGE(WM_RESERVED_0372),
	DEFINE_MESSAGE(WM_SOCKET_NOTIFY),
	DEFINE_MESSAGE(WM_SOCKET_DEAD),
	DEFINE_MESSAGE(WM_POPMESSAGESTRING),
	DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM),
	DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE),
	DEFINE_MESSAGE(WM_OCC_INITNEW),
	DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM_EX),
	DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE_EX),
	DEFINE_MESSAGE(WM_QUEUE_SENTINEL),
	DEFINE_MESSAGE(WM_RESERVED_037C),
	DEFINE_MESSAGE(WM_RESERVED_037D),
	DEFINE_MESSAGE(WM_RESERVED_037E),
	DEFINE_MESSAGE(WM_RESERVED_037F),
#endif
	{ 0, NULL, }   // end of message list
};

#undef DEFINE_MESSAGE
#define _countof(array) (sizeof(array)/sizeof(array[0]))

void TraceMsg(LPCTSTR lpszPrefix, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	_ASSERTE(lpszPrefix != NULL);

	if (message == WM_MOUSEMOVE || message == WM_NCMOUSEMOVE ||
		message == WM_NCHITTEST || message == WM_SETCURSOR ||
		message == WM_CTLCOLORBTN ||
		message == WM_CTLCOLORDLG ||
		message == WM_CTLCOLOREDIT ||
		message == WM_CTLCOLORLISTBOX ||
		message == WM_CTLCOLORMSGBOX ||
		message == WM_CTLCOLORSCROLLBAR ||
		message == WM_CTLCOLORSTATIC ||
		message == WM_ENTERIDLE || message == WM_CANCELMODE ||
		message == 0x0118)    // WM_SYSTIMER (caret blink)
	{
		// don't report very frequently sent messages
		return;
	}

	LPCSTR lpszMsgName = NULL;
	char szBuf[80];

	// find message name
	if (message >= 0xC000)
	{
		// Window message registered with 'RegisterWindowMessage'
		//  (actually a USER atom)
		if (::GetClipboardFormatNameA(message, szBuf, _countof(szBuf)))
			lpszMsgName = szBuf;
	}
	else if (message >= WM_USER)
	{
		// User message
		wsprintfA(szBuf, "WM_USER+0x%04X", message - WM_USER);
		lpszMsgName = szBuf;
	}
	else
	{
		// a system windows message
		const AFX_MAP_MESSAGE* pMapMsg = allMessages;
		for (/*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++)
		{
			if (pMapMsg->nMsg == message)
			{
				lpszMsgName = pMapMsg->lpszMsg;
				break;
			}
		}
	}

	if (lpszMsgName != NULL)
	{
		AtlTrace(_T("%s: hwnd=0x%04X, msg = %hs (0x%04X, 0x%08lX)\n"),
			lpszPrefix, (UINT)hwnd, lpszMsgName,
			wParam, lParam);
	}
	else
	{
		AtlTrace(_T("%s: hwnd=0x%04X, msg = 0x%04X (0x%04X, 0x%08lX)\n"),
			lpszPrefix, (UINT)hwnd, message,
			wParam, lParam);
	}

//#ifndef _MAC
//	if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST)
//		TraceDDE(lpszPrefix, pMsg);
//#endif

} //*** TraceMsg()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cluscmd.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2000 Microsoft Corporation
//
//  Module Name:
//      ClusCmd.h
//
//  Description:
//      Defines the interface available for functions implemented by the
//      cluster object.
//
//  Maintained By:
//      Vij Vasu (VVasu)    26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "precomp.h"
#include "cmdline.h"

class CClusterCmd
{
public:
    CClusterCmd( const CString & strClusterName, CCommandLine & cmdLine );
    ~CClusterCmd( void );

    // Parse and execute te command line
    DWORD Execute();

protected:

    enum PropertyType {
        PRIVATE,
        COMMON
    };

    DWORD OpenCluster( void );
    void CloseCluster( void );

    // Specifc Commands
    DWORD PrintHelp();
    DWORD PrintClusterVersion( const CCmdLineOption & thisOption ) 
        throw( CSyntaxException );

    DWORD ListClusters( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD RenameCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD QuorumResource( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD PrintQuorumResource();
    DWORD SetQuorumResource( LPCWSTR lpszResourceName, 
                             const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    
    DWORD DoProperties( const CCmdLineOption & thisOption,
                        PropertyType ePropType )
        throw( CSyntaxException );

    DWORD GetProperties( const CCmdLineOption & thisOption,
                         PropertyType ePropType )
        throw( CSyntaxException );

    DWORD SetProperties( const CCmdLineOption & thisOption,
                         PropertyType ePropType )
        throw( CSyntaxException );

    DWORD SetFailureActions( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD RegUnregAdminExtensions( const CCmdLineOption & thisOption, BOOL bRegister )
        throw( CSyntaxException );

    DWORD CreateCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD AddNodesToCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    HRESULT
        HrCollectCreateClusterParameters(
              const CCmdLineOption &    thisOption
            , BOOL *                    pfVerbose
            , BOOL *                    pfWizard
            , BSTR *                    pbstrNodeOut
            , BSTR *                    pbstrUserAccountOut
            , BSTR *                    pbstrUserDomainOut
            , BSTR *                    pbstrUserPasswordOut
            , CString *                 pstrIPAddressOut
            , CString *                 pstrIPSubnetOut
            , CString *                 pstrNetworkOut
            )
            throw( CSyntaxException );

    HRESULT
        HrCollectAddNodesParameters(
              const CCmdLineOption &    thisOption
            , BOOL *                    pfVerbose
            , BOOL *                    pfWizard
            , BSTR **                   ppbstrNodesOut
            , DWORD *                   pcNodes
            , BSTR *                    pbstrUserPasswordOut
            )
            throw( CSyntaxException );

    HRESULT
        HrParseUserInfo(
              LPCWSTR   pcwszParamNameIn
            , LPCWSTR   pcwszValueIn
            , BSTR *    pbstrUserDomainOut
            , BSTR *    pbstrUserAccountOut
            )
            throw( CSyntaxException );

    HRESULT
        CClusterCmd::HrParseIPAddressInfo(
              LPCWSTR                   pcwszParamNameIn
            , const vector< CString > * pvstrValueList
            , CString *                 pstrIPAddressOut
            , CString *                 pstrIPSubnetOut
            , CString *                 pstrNetworkOut
            )
            throw();

    HCLUSTER m_hCluster;
    const CString & m_strClusterName;
    CCommandLine & m_theCommandLine;

}; //*** class CClusterCmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cluscmd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusCmd.cpp
//
//  Description:
//      Cluster Commands
//      Implements commands which may be performed on clusters.
//
//  Maintained By:
//      Vijay Vasu (VVasu)                  26-JUL-2000
//      Michael Burton (t-mburt)            04-AUG-1997
//      Charles Stacy Harris III (stacyh)   20-MAR-1997
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Resource.h"

#include <clusrtl.h>
#include "cluswrap.h"
#include "cluscmd.h"

#include "cmdline.h"
#include "util.h"
#include "ClusCfg.h"

// For NetServerEnum
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>
#include <lmapibuf.h>


#define SERVER_INFO_LEVEL 101
#define MAX_BUF_SIZE 0x00100000 // 1MB

//zap! Temporary hack until windows.h update
#ifndef SV_TYPE_CLUSTER_NT
#define SV_TYPE_CLUSTER_NT 0x01000000
#endif


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::CClusterCmd
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      IN  const CString & strClusterName
//          The name of the cluster being administered
//
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterCmd::CClusterCmd( const CString & strClusterName, CCommandLine & cmdLine )
    : m_strClusterName( strClusterName )
    , m_theCommandLine( cmdLine )
    , m_hCluster( NULL )
{
} //*** CClusterCmd::CClusterCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::~CClusterCmd
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterCmd::~CClusterCmd( void )
{
    CloseCluster();

} //*** CClusterCmd::~CClusterCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::OpenCluster
//
//  Routine Description:
//      Opens the cluster specified in the constructor
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster                  SET
//      m_strClusterName            Specifies cluster name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::OpenCluster( void )
{
    if( m_hCluster )
        return ERROR_SUCCESS;

    m_hCluster = ::OpenCluster( m_strClusterName );

    if( m_hCluster == 0 )
        return GetLastError();

    return ERROR_SUCCESS;

} //*** CClusterCmd::OpenCluster()





/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::CloseCluster
//
//  Routine Description:
//      Closes the cluster specified in the constructor
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterCmd::CloseCluster( void )
{
    if( m_hCluster )
    {
        ::CloseCluster( m_hCluster );
        m_hCluster = 0;
    }

} //*** CClusterCmd::CloseCluster()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::Execute
//
//  Routine Description:
//      Takes tokens from the command line and calls the appropriate
//      handling functions
//
//  Arguments:
//      None.
//
//  Return Value:
//      Whatever is returned by dispatched functions
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::Execute( void )
{
    try
    {
        m_theCommandLine.ParseStageTwo();
    }
    catch( CException & e )
    {
        PrintString( e.m_strErrorMsg );
        return PrintHelp();
    }

    const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

    vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
    vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

    if ( curOption == lastOption )
        return PrintHelp();

    DWORD dwReturnValue = ERROR_SUCCESS;
    BOOL bContinue = TRUE;

    // Process one option after another.
    do
    {
        try
        {
            // Look up the command
            switch( curOption->GetType() )
            {
                case optHelp:
                {
                    // If help is one of the options, process no more options.
                    dwReturnValue = PrintHelp();
                    bContinue = FALSE;
                    break;
                }

                case optVersion:
                {
                    dwReturnValue = PrintClusterVersion( *curOption );
                    break;
                }

                case optList:
                {
                    dwReturnValue = ListClusters( *curOption );
                    break;
                }

                case optRename:
                {
                    dwReturnValue = RenameCluster( *curOption );
                    break;
                }

                case optQuorumResource:
                {
                    dwReturnValue = QuorumResource( *curOption );
                    break;
                }

                case optProperties:
                {
                    dwReturnValue = DoProperties( *curOption, COMMON );
                    break;
                }

                case optPrivateProperties:
                {
                    dwReturnValue = DoProperties( *curOption, PRIVATE );
                    break;
                }

                case optSetFailureActions:
                {
                    dwReturnValue = SetFailureActions( *curOption );
                    break;
                }

                case optRegisterAdminExtensions:
                {
                    dwReturnValue = RegUnregAdminExtensions(
                                        *curOption,
                                        TRUE // Register the extension
                                        );
                    break;
                }

                case optUnregisterAdminExtensions:
                {
                    dwReturnValue = RegUnregAdminExtensions(
                                        *curOption,
                                        FALSE  // Unregister the extension
                                        );
                    break;
                }

                case optCreate:
                {
                    dwReturnValue = CreateCluster( *curOption );
                    break;
                }

                case optAddNodes:
                {
                    dwReturnValue = AddNodesToCluster( *curOption );
                    break;
                }

                default:
                {
                    PrintMessage( IDS_INVALID_OPTION, (LPCTSTR) curOption->GetName() );
                    dwReturnValue = PrintHelp();
                    bContinue = FALSE;
                    break;
                }

            } // switch: based on the type of option

        } // try
        catch ( CSyntaxException & se )
        {
            PrintString( se.m_strErrorMsg );
            dwReturnValue = PrintHelp();
            bContinue = FALSE;
        }

        if ( ( bContinue == FALSE ) || ( dwReturnValue != ERROR_SUCCESS ) )
        {
            break;
        }
        else
        {
            ++curOption;
        }

        if ( curOption != lastOption )
            PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
        else
            break;
    }
    while ( TRUE );

    return dwReturnValue;

} //*** CClusterCmd::Execute()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::PrintHelp
//
//  Routine Description:
//      Prints out the help text for this command
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintMessage()
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::PrintHelp( void )
{
    return PrintMessage( MSG_HELP_CLUSTER );

} //*** CClusterCmd::PrintHelp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::PrintClusterVersion
//
//  Routine Description:
//      Prints out the version of the cluster
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::PrintClusterVersion( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    CLUSTERVERSIONINFO clusinfo;
    LPWSTR lpszName = 0;

    clusinfo.dwVersionInfoSize = sizeof clusinfo;

    dwError = WrapGetClusterInformation( m_hCluster, &lpszName, &clusinfo );

    if( dwError != ERROR_SUCCESS )
        return dwError;

    PrintMessage( MSG_CLUSTER_VERSION,
        lpszName,
        clusinfo.MajorVersion,
        clusinfo.MinorVersion,
        clusinfo.BuildNumber,
        clusinfo.szCSDVersion,
        clusinfo.szVendorId
        );

    if( lpszName )
        LocalFree( lpszName );

    return ERROR_SUCCESS;

} //*** CClusterCmd::PrintClusterVersion()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ListClusters
//
//  Routine Description:
//      Lists all of the clusters on the network.
//      Optionally limit to a specific domain.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//  Note:
//      zap! Must deal with buffer too small issue.
//      zap! Does NetServerEnum return ERROR_MORE_DATA or Err_BufTooSmall?
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::ListClusters( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const vector<CString> & valueList = thisOption.GetValues();

    // This option takes at most one parameter.
    if ( valueList.size() > 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    LPCTSTR pcszDomainName;

    if ( valueList.size() == 0 )
        pcszDomainName = NULL;
    else
        pcszDomainName = valueList[0];

    SERVER_INFO_101 *pServerInfoList = NULL;
    DWORD dwReturnCount = 0;
    DWORD dwTotalServers = 0;

    DWORD dwError = NetServerEnum(
        0,                          // servername = where command executes 0 = local
        SERVER_INFO_LEVEL,          // level = type of structure to return.
        (LPBYTE *)&pServerInfoList, // bufptr = returned array of server info structures
        MAX_BUF_SIZE,               // prefmaxlen = preferred max of returned data
        &dwReturnCount,             // entriesread = number of enumerated elements returned
        &dwTotalServers,            // totalentries = total number of visible machines on the network
        SV_TYPE_CLUSTER_NT,         // servertype = filters the type of info returned
        pcszDomainName,             // domain = domain to limit search
        0 );                        // resume handle


    if( dwError == ERROR_SUCCESS )
    {
        if( dwReturnCount )
            PrintMessage( MSG_CLUSTER_HEADER );

        for( DWORD i = 0; i < dwReturnCount; i++ )
            PrintMessage( MSG_CLUSTER_DETAIL, pServerInfoList[ i ].sv101_name );

        NetApiBufferFree( pServerInfoList );
    }

    return dwError;

} //*** CClusterCmd::ListClusters()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::RenameCluster
//
//  Routine Description:
//      Renames the cluster to the specified name
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      Same as SetClusterName
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::RenameCluster( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const vector<CString> & valueList = thisOption.GetValues();

    // This option takes exactly one value.
    if ( valueList.size() != 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    CString strNewName = valueList[0];

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    return SetClusterName( m_hCluster, strNewName );

} //*** CClusterCmd::RenameCluster()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::QuorumResource
//
//  Routine Description:
//      Sets or Prints the Quorum resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::QuorumResource( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    const vector<CString> & valueList = thisOption.GetValues();

    // This option takes at most one value.
    if ( valueList.size() > 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    if ( ( valueList.size() == 0 ) && ( thisOption.GetParameters().size() == 0 ) )
        dwError = PrintQuorumResource();
    else
    {
        if ( valueList.size() == 0 )
            dwError = SetQuorumResource( TEXT( "" ), thisOption );
        else
            dwError = SetQuorumResource( valueList[0], thisOption );
    }

    return dwError;

} //*** CClusterCmd::QuorumResource()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::PrintQuorumResource
//
//  Routine Description:
//      Prints the quorum resource
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_strClusterName            Specifies cluster name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::PrintQuorumResource( void )
{
    DWORD dwError = ERROR_SUCCESS;

    LPWSTR lpszResourceName = 0;
    LPWSTR lpszDevicePath = 0;
    DWORD dwMaxLogSize = 0;

    // Print the quorum resource information and return.
    dwError = WrapGetClusterQuorumResource(
        m_hCluster,
        &lpszResourceName,
        &lpszDevicePath,
        &dwMaxLogSize );

    if( dwError == ERROR_SUCCESS )
    {
        dwError = PrintMessage( MSG_QUORUM_RESOURCE, lpszResourceName, lpszDevicePath, dwMaxLogSize );

        if( lpszResourceName )
            LocalFree( lpszResourceName );

        if( lpszDevicePath )
            LocalFree( lpszDevicePath );
    }


    return dwError;

} //*** CClusterCmd::PrintQuorumResource()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::SetQuorumResource
//
//  Routine Description:
//      Sets the quorum resource
//
//  Arguments:
//      IN  LPCWSTR lpszResourceName
//          The name of the resource

//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::SetQuorumResource( LPCWSTR lpszResourceName,
                                      const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwError = ERROR_SUCCESS;

    CString strResourceName( lpszResourceName );
    CString strDevicePath;
    CString strMaxLogSize;
    DWORD   dwMaxLogSize = 0;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bPathFound = FALSE;
    BOOL bSizeFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramPath:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bPathFound != FALSE )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strDevicePath = valueList[0];
                bPathFound = TRUE;
                break;

            case paramMaxLogSize:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bSizeFound != FALSE )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strMaxLogSize = valueList[0];

                bSizeFound = TRUE;
                break;

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }
        }

        ++curParam;
    }


    if( strResourceName.IsEmpty() &&
        strDevicePath.IsEmpty() &&
        strMaxLogSize.IsEmpty() )
    {
        PrintMessage( IDS_MISSING_PARAMETERS );
        return PrintHelp();
    }

    {
        LPWSTR pszDevicePath = NULL;
        LPWSTR pszTempResourceName = NULL;

        //
        // Get Default values
        //
        dwError = WrapGetClusterQuorumResource(
                        m_hCluster,
                        &pszTempResourceName,
                        &pszDevicePath,
                        &dwMaxLogSize );

        if( dwError != ERROR_SUCCESS )
        {
            if ( pszTempResourceName != NULL )
            {
                LocalFree( pszTempResourceName );
            }

            if ( pszDevicePath != NULL )
            {
                LocalFree( pszDevicePath );
            }

            return dwError;
        }

        //
        // Get default resource name.
        //
        if ( strResourceName.IsEmpty() != FALSE )
        {
            // The argument to this function is a non empty resource name.
            // Use the resource name got from the WrapGetClusterQuorumResource
            // call.
            strResourceName = pszTempResourceName;
        }

        // Free the memory allocated in WrapGetClusterQuorumResource, if any.
        if ( pszTempResourceName != NULL )
        {
            LocalFree( pszTempResourceName );
        }

        if ( strDevicePath.IsEmpty() != FALSE )
        {
            // The device path parameter has not been specified.
            // Use the device path got from the WrapGetClusterQuorumResource
            // call.
            strDevicePath = pszDevicePath;

            //  Get default device path - the string after the device name.
            strDevicePath = strDevicePath.Mid( strDevicePath.Find( TEXT('\\') ) + 1 );
        }

        // Free the memory allocated in WrapGetClusterQuorumResource, if any.
        if ( pszDevicePath != NULL )
        {
            LocalFree( pszDevicePath );
        }

        if ( strMaxLogSize.IsEmpty() == FALSE )
        {
            dwError = MyStrToDWORD( strMaxLogSize, &dwMaxLogSize );

            if ( dwError != ERROR_SUCCESS )
            {
                return dwError;
            }

            dwMaxLogSize *= 1024; // Expressed in kb
        }
    }

    HRESOURCE hResource = OpenClusterResource( m_hCluster, strResourceName );
    if( hResource == 0 )
        return GetLastError();

    dwError = SetClusterQuorumResource( hResource, strDevicePath, dwMaxLogSize );

    CloseClusterResource( hResource );

    return dwError;

} //*** CClusterCmd::SetQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::DoProperties
//
//  Routine Description:
//      Dispatches the property command to either Get or Set properties
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::DoProperties( const CCmdLineOption & thisOption,
                                 PropertyType ePropertyType )
    throw( CSyntaxException )
{
    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

    // If there are no property-value pairs on the command line,
    // then we print the properties otherwise we set them.
    if( paramList.size() == 0 )
    {
        PrintMessage( ePropertyType==PRIVATE ? MSG_PRIVATE_LISTING : MSG_PROPERTY_LISTING,
            (LPCTSTR) m_strClusterName );
        PrintMessage( MSG_PROPERTY_HEADER_CLUSTER_ALL );

        return GetProperties( thisOption, ePropertyType );
    }
    else
    {
        return SetProperties( thisOption, ePropertyType );
    }

} //*** CClusterCmd::DoProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::GetProperties
//
//  Routine Description:
//      Prints out properties for this cluster
//
//  Arguments:
//      IN  const vector<CCmdLineParameter> & paramList
//          Contains the list of property-value pairs to be set
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::GetProperties( const CCmdLineOption & thisOption,
                                  PropertyType ePropType )
{
    DWORD dwError = ERROR_SUCCESS;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Use the proplist helper class.
    CClusPropList PropList;

    // Get Read Only properties
    DWORD dwControlCode = ( ePropType == PRIVATE )
                          ? CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES
                          : CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES;

    dwError = PropList.ScGetClusterProperties(
        m_hCluster,
        dwControlCode );

    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = ::PrintProperties( PropList, thisOption.GetValues(), READONLY, m_strClusterName );
    if (dwError != ERROR_SUCCESS)
        return dwError;


    // Get Read/Write properties
    dwControlCode = ( ePropType == PRIVATE )
                    ? CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES
                    : CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;


    dwError = PropList.ScGetClusterProperties(
        m_hCluster,
        dwControlCode );

    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = ::PrintProperties( PropList, thisOption.GetValues(), READWRITE, m_strClusterName );

    return dwError;

} //*** CClusterCmd::GetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::SetProperties
//
//  Routine Description:
//      Set the properties for this cluster
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::SetProperties( const CCmdLineOption & thisOption,
                                  PropertyType ePropType )
    throw( CSyntaxException )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwControlCode;
    DWORD dwBytesReturned = 0;

    // Use the proplist helper class.
    CClusPropList CurrentProps;
    CClusPropList NewProps;

    // First get the existing properties...
    dwControlCode = ( ePropType == PRIVATE )
                    ? CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES
                    : CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;

    dwError = CurrentProps.ScGetClusterProperties(
        m_hCluster,
        dwControlCode );

    if( dwError != ERROR_SUCCESS )
        return dwError;

    // If values have been specified with this option, then it means that we want
    // to set these properties to their default values. So, there has to be
    // exactly one parameter and it has to be /USEDEFAULT.
    if ( thisOption.GetValues().size() != 0 )
    {
        const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

        if ( paramList.size() != 1 )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR, thisOption.GetName() );
            throw se;
        }

        if ( paramList[0].GetType() != paramUseDefault )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_INVALID_PARAMETER, paramList[0].GetName() );
            throw se;
        }

        // This parameter does not take any values.
        if ( paramList[0].GetValues().size() != 0 )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_PARAM_NO_VALUES, paramList[0].GetName() );
            throw se;
        }

        dwError = ConstructPropListWithDefaultValues( CurrentProps, NewProps, thisOption.GetValues() );
        if( dwError != ERROR_SUCCESS )
            return dwError;


    } // if: values have been specified with this option.
    else
    {
        dwError = ConstructPropertyList( CurrentProps,
                                         NewProps,
                                         thisOption.GetParameters(),
                                         TRUE /* BOOL bClusterSecurity */
                                       );
        if (dwError != ERROR_SUCCESS)
            return dwError;

    } // else: no values have been specified with this option.

    // Call the set function...
    dwControlCode = ( ePropType == PRIVATE )
                    ? CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES
                    : CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES;

    dwBytesReturned = 0;
    dwError = ClusterControl(
        m_hCluster,
        NULL, // hNode
        dwControlCode,
        NewProps.Plist(),
        NewProps.CbBufferSize(),
        0,
        0,
        &dwBytesReturned );

    return dwError;

} //*** CClusterCmd::SetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::SetFailureActions
//
//  Routine Description:
//      Resets the service controller failure actions back to the installed
//      default for the specified nodes
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS. If an individual reset fails, that is noted but doesn't
//      fail the entire operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::SetFailureActions( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwError;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const vector<CString> & valueList = thisOption.GetValues();

    // If no values are specified then reset all nodes in the cluster
    if ( valueList.size() == 0 )
    {
        DWORD nResourceType;
        DWORD nNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
        CString strNodeName;
        LPWSTR pszNodeNameBuffer;

        // open a handle to the cluster and then open a node enumerator
        DWORD dwError = OpenCluster();
        if( dwError != ERROR_SUCCESS )
            return dwError;

        HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_NODE );
        if( !hEnum )
            return GetLastError();

        // enum the nodes and reset the failure actions on each one
        pszNodeNameBuffer = strNodeName.GetBuffer( nNodeNameBufferSize );
        for( DWORD i = 0; ; ++i )
        {
            dwError = ClusterEnum(hEnum,
                                  i,
                                  &nResourceType,
                                  pszNodeNameBuffer,
                                  &nNodeNameBufferSize);

            if ( dwError == ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            else if ( dwError != ERROR_SUCCESS )
            {
                ClusterCloseEnum( hEnum );
                return dwError;
            }

            PrintMessage( MSG_SETTING_FAILURE_ACTIONS, pszNodeNameBuffer );

            dwError = ClRtlSetSCMFailureActions( pszNodeNameBuffer );
            if ( dwError != ERROR_SUCCESS )
                PrintMessage( MSG_FAILURE_ACTIONS_FAILED, pszNodeNameBuffer, dwError );

            nNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
        }

        ClusterCloseEnum( hEnum );
    }
    else
    {
        // list of nodes was specified. verify that all nodes are part of the
        // target cluster
        DWORD nResourceType;
        DWORD nNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
        CString strNodeName;
        LPWSTR pszNodeNameBuffer;

        // open a handle to the cluster and then open a node enumerator
        DWORD dwError = OpenCluster();
        if( dwError != ERROR_SUCCESS )
            return dwError;

        HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_NODE );
        if( !hEnum )
            return GetLastError();

        pszNodeNameBuffer = strNodeName.GetBuffer( nNodeNameBufferSize );
        for( DWORD nameIndex = 0; nameIndex < valueList.size(); ++nameIndex )
        {
            // get the name of each node in the cluster
            for( DWORD i = 0; ; ++i )
            {
                nNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
                dwError = ClusterEnum(hEnum,
                                      i,
                                      &nResourceType,
                                      pszNodeNameBuffer,
                                      &nNodeNameBufferSize);

                if( dwError == ERROR_NO_MORE_ITEMS )
                {
                    break;
                }
                else if( dwError != ERROR_SUCCESS )
                {
                    ClusterCloseEnum( hEnum );
                    return dwError;
                }

                if( valueList[ nameIndex ].CompareNoCase( pszNodeNameBuffer ) == 0 )
                    break;
            }

            if( dwError == ERROR_NO_MORE_ITEMS ) {
                CString strValueUpcaseName( valueList[ nameIndex ]);
                strValueUpcaseName.MakeUpper();

                PrintMessage( MSG_NODE_NOT_CLUSTER_MEMBER, strValueUpcaseName );
                ClusterCloseEnum( hEnum );
                return ERROR_INVALID_PARAMETER;
            }
        }
        ClusterCloseEnum( hEnum );

        // everything is hunky-dory. go ahead and set the failure actions
        for( DWORD i = 0; i < valueList.size(); ++i )
        {
            CString strUpcaseName( valueList[i] );
            strUpcaseName.MakeUpper();

            PrintMessage( MSG_SETTING_FAILURE_ACTIONS, strUpcaseName );

            dwError = ClRtlSetSCMFailureActions( (LPWSTR)(LPCWSTR)valueList[i] );
            if( dwError != ERROR_SUCCESS )
                PrintMessage( MSG_FAILURE_ACTIONS_FAILED, strUpcaseName, dwError );
        }
    }

    return ERROR_SUCCESS;

} //*** CClusterCmd::SetFailureActions()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::RegUnregAdminExtensions
//
//  Routine Description:
//      Registers or unregisters an admin extension on the specified cluster.
//      The DLL for the admin extension need not actually exist on the cluster
//      nodes. This function just creates or deletes the AdminExtensions key
//      in the cluster database.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//      IN  BOOL bRegister
//          If this parameter is TRUE, the admin extension is registered.
//          Otherwise it is unregistered.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS if the registration or unregistration succeeded.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::RegUnregAdminExtensions( const CCmdLineOption & thisOption, BOOL bRegister )
        throw( CSyntaxException )
{
    DWORD       dwReturnValue = ERROR_SUCCESS;
    int         nNumberOfExts;
    HINSTANCE   hExtModuleHandle = NULL;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    } // if: this option was passed a parameter

    const vector<CString> & valueList = thisOption.GetValues();
    nNumberOfExts = valueList.size();

    // This option takes at least one value.
    if ( nNumberOfExts < 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_AT_LEAST_ONE_VALUE, thisOption.GetName() );
        throw se;
    } // if: this option had less than one value

    do // dummy do-while loop to avoid gotos
    {
        int nExtIndex;

        // Open the cluster.
        dwReturnValue = OpenCluster();
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            break;
        } // if: the cluster could not be opened.

        for ( nExtIndex = 0; nExtIndex < nNumberOfExts; ++nExtIndex )
        {
            typedef HRESULT (*PFREGISTERADMINEXTENSION)(HCLUSTER hcluster);
            typedef HRESULT (*PFREGISTERSERVER)(void);

            const CString &             rstrCurrentExt = valueList[nExtIndex];
            PFREGISTERADMINEXTENSION    pfnRegUnregExtProc;
            PFREGISTERSERVER            pfnRegUnregSvrProc;
            CHAR *                      pszRegUnregExtProcName;
            CHAR *                      pszRegUnregSvrProcName;
            DWORD                       dwMessageId;

            if ( bRegister )
            {
                pszRegUnregExtProcName = "DllRegisterCluAdminExtension";
                pszRegUnregSvrProcName = "DllRegisterServer";
                dwMessageId = MSG_CLUSTER_REG_ADMIN_EXTENSION;
            } // if: register admin extension
            else
            {
                pszRegUnregExtProcName = "DllUnregisterCluAdminExtension";
                pszRegUnregSvrProcName = "DllUnregisterServer";
                dwMessageId = MSG_CLUSTER_UNREG_ADMIN_EXTENSION;

            } // else: unregister admin extension

            //
            PrintMessage(
                dwMessageId,
                static_cast<LPCTSTR>( rstrCurrentExt ),
                static_cast<LPCTSTR>( m_strClusterName )
                );

            // Load the admin extension DLL.
            hExtModuleHandle = LoadLibrary( rstrCurrentExt );
            if ( hExtModuleHandle == NULL )
            {
                dwReturnValue = GetLastError();
                break;
            } // if: load library failed

            // Register or unregister the admin extension with the cluster.
            //
            pfnRegUnregExtProc = reinterpret_cast<PFREGISTERADMINEXTENSION>(
                                    GetProcAddress(
                                        hExtModuleHandle,
                                        pszRegUnregExtProcName
                                        )
                                    );

            if ( pfnRegUnregExtProc == NULL )
            {
                dwReturnValue = GetLastError();
                break;
            } // if: GetProcAddress failed

            dwReturnValue = static_cast<DWORD>( pfnRegUnregExtProc( m_hCluster ) );
            if ( dwReturnValue != ERROR_SUCCESS )
            {
                break;
            } // if: reg/unreg extension failed

            //
            // Register or unregister the admin extension DLL on this machine.
            //
            pfnRegUnregSvrProc = reinterpret_cast<PFREGISTERSERVER>(
                                    GetProcAddress(
                                        hExtModuleHandle,
                                        pszRegUnregSvrProcName
                                        )
                                    );

            if ( pfnRegUnregSvrProc == NULL )
            {
                dwReturnValue = GetLastError();
                break;
            } // if: GetProcAddress failed

            dwReturnValue = static_cast<DWORD>( pfnRegUnregSvrProc( ) );
            if ( dwReturnValue != ERROR_SUCCESS )
            {
                break;
            } // if: reg/unreg server failed

            if ( hExtModuleHandle != NULL )
            {
                FreeLibrary( hExtModuleHandle );
                hExtModuleHandle = NULL;
            } // if: the DLL was loaded successfully

        } // for: loop through all specified admin extensions

    } while ( FALSE ); // dummy do-while loop to avoid gotos

    CloseCluster();

    if ( hExtModuleHandle != NULL )
    {
        FreeLibrary( hExtModuleHandle );
    }

    return dwReturnValue;

} //*** CClusterCmd::RegUnregAdminExtensions


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::CreateCluster
//
//  Description:
//      Creates a new cluster.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      ERROR_SUCCESS if the cluster was created successfully.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::CreateCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException )
{
    HRESULT         hr = S_OK;
    CComBSTR        combstrClusterName;
    CComBSTR        combstrNode;
    CComBSTR        combstrUserAccount;
    CComBSTR        combstrUserDomain;
    CComBSTR        combstrUserPassword;
    CString         strIPAddress;
    CString         strIPSubnet;
    CString         strNetwork;
    CCreateCluster  cc;
    BOOL            fVerbose    = FALSE;
    BOOL            fWizard     = FALSE;

    // No values are support with the option.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    } // if: this option was passed a value

    // Collect parameters from the command line.
    hr = HrCollectCreateClusterParameters(
              thisOption
            , &fVerbose
            , &fWizard
            , &combstrNode
            , &combstrUserAccount
            , &combstrUserDomain
            , &combstrUserPassword
            , &strIPAddress
            , &strIPSubnet
            , &strNetwork
            );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get a FQDN for the cluster name.
    if ( m_strClusterName.GetLength() != 0 )
    {
        hr = HrGetFQDNName( m_strClusterName, &combstrClusterName );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: a cluster name was specified

    // Create the cluster.
    if ( fWizard )
    {
        hr = cc.HrInvokeWizard(
                      combstrClusterName
                    , combstrNode
                    , combstrUserAccount
                    , combstrUserDomain
                    , combstrUserPassword
                    , strIPAddress
                    , strIPSubnet
                    , strNetwork
                    );
    } // if: invoking the wizard
    else
    {
        hr = cc.HrCreateCluster(
                      fVerbose
                    , combstrClusterName
                    , combstrNode
                    , combstrUserAccount
                    , combstrUserDomain
                    , combstrUserPassword
                    , strIPAddress
                    , strIPSubnet
                    , strNetwork
                    );
    } // else: not invoking the wizard

Cleanup:
    return hr;

} //*** CClusterCmd::CreateCluster()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::AddNodesToCluster
//
//  Description:
//      Adds nodes to an existing cluster.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      ERROR_SUCCESS if the specified nodes were added to the cluster successfully.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::AddNodesToCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException )
{
    HRESULT             hr = S_OK;
    CComBSTR            combstrClusterName;
    CComBSTR            combstrUserPassword;
    BSTR *              pbstrNodes = NULL;
    DWORD               cNodes;
    CAddNodesToCluster  antc;
    BOOL                fVerbose    = FALSE;
    BOOL                fWizard     = FALSE;

    // Collect parameters from the command line.
    hr = HrCollectAddNodesParameters(
              thisOption
            , &fVerbose
            , &fWizard
            , &pbstrNodes
            , &cNodes
            , &combstrUserPassword
            );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Get a FQDN for the cluster name.
    if ( m_strClusterName.GetLength() != 0 )
    {
        hr = HrGetFQDNName( m_strClusterName, &combstrClusterName );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: a cluster name was specified

    // Add the nodes to the cluster.
    if ( fWizard )
    {
        hr = antc.HrInvokeWizard(
                      combstrClusterName
                    , pbstrNodes
                    , cNodes
                    , combstrUserPassword
                    );
    } // if: invoking the wizard
    else
    {
        hr = antc.HrAddNodesToCluster(
                      fVerbose
                    , combstrClusterName
                    , pbstrNodes
                    , cNodes
                    , combstrUserPassword
                    );
    } // else: not invoking the wizard

Cleanup:
    if ( pbstrNodes != NULL )
    {
        DWORD   idxNode;

        for ( idxNode = 0 ; idxNode < cNodes ; idxNode++ )
        {
            SysFreeString( pbstrNodes[ idxNode ] );
        } // for: each node name in the array
        delete [] pbstrNodes;
    } // if: nodes array was allocated
    return hr;

} //*** CClusterCmd::AddNodesToCluster()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusterCmd::HrCollectCreateClusterParameters(
//        const CCmdLineOption &    thisOptionIn
//      , BOOL *                    pfVerboseOut
//      , BOOL *                    pfWizardOut
//      , BSTR *                    pbstrNodeOut
//      , BSTR *                    pbstrUserAccountOut
//      , BSTR *                    pbstrUserDomainOut
//      , BSTR *                    pbstrUserPasswordOut
//      , CString *                 pstrIPAddressOut
//      , CString *                 pstrIPSubnetOut
//      , CString *                 pstrNetworkOut
//      )
//
//  Description:
//      Collects the parameters from the command line for the /CREATE switch.
//
//  Arguments:
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK    -- Operation was successful.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrCollectCreateClusterParameters(
      const CCmdLineOption &    thisOptionIn
    , BOOL *                    pfVerboseOut
    , BOOL *                    pfWizardOut
    , BSTR *                    pbstrNodeOut
    , BSTR *                    pbstrUserAccountOut
    , BSTR *                    pbstrUserDomainOut
    , BSTR *                    pbstrUserPasswordOut
    , CString *                 pstrIPAddressOut
    , CString *                 pstrIPSubnetOut
    , CString *                 pstrNetworkOut
    )
    throw( CSyntaxException )
{
    HRESULT hr              = S_OK;
    DWORD   dwStatus;
    bool    fNodeFound      = false;
    bool    fUserFound      = false;
    bool    fPasswordFound  = false;
    bool    fIPFound        = false;
    bool    fVerboseFound   = false;
    bool    fWizardFound    = false;

    const vector< CCmdLineParameter > &         vecParamList = thisOptionIn.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();

    while( itCurParam != itLast )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch( itCurParam->GetType() )
        {
            case paramNodeName:
                // Exactly one value must be specified.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fNodeFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Save the value.
                // Make sure the value is a FQDN.
                hr = HrGetFQDNName( vstrValueList[ 0 ], pbstrNodeOut );
                if ( FAILED( hr ) )
                    goto Cleanup;

                fNodeFound = TRUE;
                break;

            case paramUser:
                // Exactly one value must be specified.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fUserFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Get the user domain and account.
                hr = HrParseUserInfo(
                          itCurParam->GetName()
                        , vstrValueList[ 0 ]
                        , pbstrUserDomainOut
                        , pbstrUserAccountOut
                        );
                if ( FAILED( hr ) )
                    goto Cleanup;

                fUserFound = TRUE;
                break;

            case paramPassword:
                // Exactly one value must be specified.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fPasswordFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Save the value.
                *pbstrUserPasswordOut = SysAllocString( vstrValueList[ 0 ] );
                if ( *pbstrUserPasswordOut == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                fPasswordFound = TRUE;
                break;

            case paramIPAddress:
                // Exactly one or exactly three values must be specified
                if ( ( vstrValueList.size() != 1 ) && ( vstrValueList.size() != 3 ) )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fIPFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Get the user domain and account.
                hr = HrParseIPAddressInfo(
                          itCurParam->GetName()
                        , &vstrValueList
                        , pstrIPAddressOut
                        , pstrIPSubnetOut
                        , pstrNetworkOut
                        );
                if ( FAILED( hr ) )
                    goto Cleanup;

                fIPFound = TRUE;
                break;

            case paramVerbose:
                // No values may be specified
                if ( vstrValueList.size() != 0 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                    throw se;
                }

                // Not compatible with /Wizard
                if ( fVerboseFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fVerboseFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                fVerboseFound = TRUE;
                *pfVerboseOut = TRUE;
                break;

            case paramWizard:
                // No values may be specified
                if ( vstrValueList.size() != 0 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                    throw se;
                }

                // Not compatible with /Verbose
                if ( fVerboseFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fWizardFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                fWizardFound = TRUE;
                *pfWizardOut = TRUE;
                break;

            default:
            {
                CSyntaxException    se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }
        } // switch: type of parameter

        // Move to the next parameter.
        itCurParam++;

    } // while: more parameters

    //
    // Make sure required parameters were specified.
    //
    if ( ! *pfWizardOut )
    {
        // Make sure a cluster name has been specified.
        if ( m_strClusterName.GetLength() == 0 )
        {
            CSyntaxException    se;
            se.LoadMessage( IDS_NO_CLUSTER_NAME );
            throw se;
        } // if: not invoking the wizard and no cluster name specified

        if ( ( pstrIPAddressOut->GetLength() == 0 )
          || ( *pbstrUserAccountOut == NULL ) )
        {
            CSyntaxException se;
            se.LoadMessage( IDS_MISSING_PARAMETERS, NULL );
            throw se;
        } // if: required parameters were not specified

        //
        // If no password was specified, prompt for it.
        //
        if ( *pbstrUserPasswordOut == NULL )
        {
            WCHAR   wszPassword[ 1024 ];
            CString strPassword;

            strPassword.LoadString( IDS_PASSWORD_PROMPT );

            // Get the password.
            wprintf( L"%ls: ", strPassword );
            dwStatus = DwGetPassword( wszPassword, sizeof( wszPassword ) / sizeof( wszPassword[ 0 ] ) );
            if ( dwStatus != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwStatus );
                goto Cleanup;
            }

            // Convert the password to a BSTR.
            *pbstrUserPasswordOut = SysAllocString( wszPassword );
            if ( *pbstrUserPasswordOut == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        } // if: no password was specified

        //
        // Default the the node name if it wasn't specified.
        //
        if ( *pbstrNodeOut == NULL )
        {
            hr = HrGetLocalNodeFQDNName( pbstrNodeOut );
            if ( *pbstrNodeOut == NULL )
                goto Cleanup;
        } // if: no node was specified
    } // if: not invoking the wizard

Cleanup:
    return hr;

} //*** CClusterCmd::HrCollectCreateClusterParameters()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusterCmd::HrCollectAddNodesParameters(
//        const CCmdLineOption &    thisOptionIn
//      , BOOL *                    pfVerboseOut
//      , BOOL *                    pfWizardOut
//      , BSTR **                   ppbstrNodesOut
//      , DWORD *                   pcNodesOut
//      , BSTR *                    pbstrUserPasswordOut
//      )
//
//  Description:
//      Collects the parameters from the command line for the /ADDNODES
//      switch.
//
//  Arguments:
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK    -- Operation was successful.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrCollectAddNodesParameters(
      const CCmdLineOption &    thisOptionIn
    , BOOL *                    pfVerboseOut
    , BOOL *                    pfWizardOut
    , BSTR **                   ppbstrNodesOut
    , DWORD *                   pcNodesOut
    , BSTR *                    pbstrUserPasswordOut
    )
    throw( CSyntaxException )
{
    HRESULT hr              = S_OK;
    DWORD   dwStatus;
    DWORD   idxNode;
    DWORD   cNodes;
    bool    fPasswordFound  = false;
    bool    fVerboseFound   = false;
    bool    fWizardFound    = false;
    bool    fThrowException = false;
    CSyntaxException    se;

    //
    // Parse the node names.
    //
    {
        const vector< CString > &           vstrValues  = thisOptionIn.GetValues();
        vector< CString >::const_iterator   itCurValue  = vstrValues.begin();
        vector< CString >::const_iterator   itLast      = vstrValues.end();

        // Get the number of nodes.  If no nodes were specified, we still want
        // to allocate space for at least one so we can default to the local node.
        cNodes = vstrValues.size();
        if ( cNodes == 0 )
        {
            cNodes = 1;
        }

        // Allocate the node name array.
        *ppbstrNodesOut = new BSTR[ cNodes ];
        if ( *ppbstrNodesOut == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        ZeroMemory( *ppbstrNodesOut, sizeof( BSTR ) * cNodes );

        // If no nodes were specified, default to the local node.
        if ( vstrValues.size() == 0 )
        {
            hr = HrGetLocalNodeFQDNName( *ppbstrNodesOut );
            if ( *ppbstrNodesOut == NULL )
                goto Error;
        } // if: no nodes were specified
        else
        {
            BSTR    bstrNode = NULL;

            // Loop through the values and add each node name to the array.
            for ( idxNode = 0 ; idxNode < cNodes ; idxNode++ )
            {
                // Make sure the node name is an FQDN
                hr = HrGetFQDNName( vstrValues[ idxNode ], &(*ppbstrNodesOut)[ idxNode ] );
                if ( FAILED( hr ) )
                    goto Error;
            } // for: each node
        } // else: nodes were specified

        *pcNodesOut = cNodes;
    } // Parse the node names

    //
    // Get parameter values.
    //
    {
        const vector< CCmdLineParameter > &         vecParamList = thisOptionIn.GetParameters();
        vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
        vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();

        while( itCurParam != itLast )
        {
            const vector< CString > & vstrValueList = itCurParam->GetValues();

            switch( itCurParam->GetType() )
            {
                case paramPassword:
                    // Exactly one value must be specified.
                    if ( vstrValueList.size() != 1 )
                    {
                        se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fPasswordFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Save the value.
                    *pbstrUserPasswordOut = SysAllocString( vstrValueList[ 0 ] );
                    if ( *pbstrUserPasswordOut == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        goto Error;
                    }
                    fPasswordFound = TRUE;
                    break;

                case paramVerbose:
                    // No values may be specified
                    if ( vstrValueList.size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Not compatible with /Wizard
                    if ( fVerboseFound )
                    {
                        se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fVerboseFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    fVerboseFound = TRUE;
                    *pfVerboseOut = TRUE;
                    break;

                case paramWizard:
                    // No values may be specified
                    if ( vstrValueList.size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Not compatible with /Verbose
                    if ( fVerboseFound )
                    {
                        se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fWizardFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    fWizardFound = TRUE;
                    *pfWizardOut = TRUE;
                    break;

                default:
                {
                    se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                }
            } // switch: type of parameter

            // Move to the next parameter.
            itCurParam++;

        } // while: more parameters
    } // Get parameter values

    if ( ! *pfWizardOut )
    {
        // Make sure a cluster name has been specified.
        if ( m_strClusterName.GetLength() == 0 )
        {
            CSyntaxException    se;
            se.LoadMessage( IDS_NO_CLUSTER_NAME );
            throw se;
        } // if: not invoking the wizard and no cluster name specified

        //
        // If no password was specified, prompt for it.
        //
        if ( *pbstrUserPasswordOut == NULL )
        {
            WCHAR   wszPassword[ 1024 ];
            CString strPassword;

            strPassword.LoadString( IDS_PASSWORD_PROMPT );

            // Get the password.
            wprintf( L"%ls: ", strPassword );
            dwStatus = DwGetPassword( wszPassword, sizeof( wszPassword ) / sizeof( wszPassword[ 0 ] ) );
            if ( dwStatus != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwStatus );
                goto Error;
            }

            // Convert the password to a BSTR.
            *pbstrUserPasswordOut = SysAllocString( wszPassword );
            if ( *pbstrUserPasswordOut == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        } // if: no password was specified
    } // if: not invoking the wizard

Cleanup:
    return hr;

Error:
    for ( idxNode = 0 ; idxNode < cNodes ; idxNode++ )
    {
        if ( (*ppbstrNodesOut)[ idxNode ] != NULL )
        {
            SysFreeString( (*ppbstrNodesOut)[ idxNode ] );
        }
    } // for: each node
    delete [] *ppbstrNodesOut;
    if ( fThrowException )
    {
        throw se;
    }
    goto Cleanup;

} //*** CClusterCmd::HrCollectAddNodesParameters()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusterCmd::HrParseUserInfo(
//        LPCWSTR   pcwszParamNameIn
//      , LPCWSTR * pcwszValueIn
//      , BSTR *    pbstrUserDomainOut
//      , BSTR *    pbstrUserAccountOut
//      )
//
//  Description:
//      Parse the user domain and account from a single string using the
//      domain\account syntax or the user@domain syntax.
//
//  Arguments:
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK    -- Operation was successful.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrParseUserInfo(
      LPCWSTR   pcwszParamNameIn
    , LPCWSTR   pcwszValueIn
    , BSTR *    pbstrUserDomainOut
    , BSTR *    pbstrUserAccountOut
    )
    throw( CSyntaxException )
{
    HRESULT hr          = S_OK;
    LPWSTR  pwszUser    = NULL;
    LPWSTR  pwszSlash;
    LPWSTR  pwszAtSign;
    CString strValue;

    // If a not in domain\user format check for user@domain format.  If none of these then use
    // the currently-logged-on user's domain.
    strValue = pcwszValueIn;
    pwszUser = strValue.GetBuffer( 0 );
    pwszSlash = wcschr( pwszUser, L'\\' );
    if ( pwszSlash == NULL )
    {
        pwszAtSign = wcschr( pwszUser, L'@' );
        if ( pwszAtSign == NULL )
        {
            hr = HrGetLoggedInUserDomain( pbstrUserDomainOut );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            *pbstrUserAccountOut = SysAllocString( pwszUser );
            if ( *pbstrUserAccountOut == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else
            {
            // An @ was specified.  Check to make sure that a domain
            // was specified after the @.
            if ( *(pwszAtSign + 1) == L'\0' )
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, pcwszParamNameIn );
                throw se;
            }

            // Truncate at the @ and create the user BSTR.
            *pwszAtSign = L'\0';
            *pbstrUserAccountOut = SysAllocString( pwszUser );
            if ( *pbstrUserAccountOut == NULL )
            {
                *pwszAtSign = L'@';
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Create the domain BSTR.
            *pbstrUserDomainOut = SysAllocString( pwszAtSign + 1 );
            if ( *pbstrUserDomainOut == NULL )
            {
                *pwszAtSign = L'@';
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        } // else:
    } // if: no slash specified
    else
    {
        // A slash was specified.  Check to make sure that a user account
        // was specified after the slash.
        if ( *(pwszSlash + 1) == L'\0' )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_INVALID_PARAMETER, pcwszParamNameIn );
            throw se;
        }

        // Truncate at the slash and create the domain BSTR.
        *pwszSlash = L'\0';
        *pbstrUserDomainOut = SysAllocString( pwszUser );
        if ( *pbstrUserDomainOut == NULL )
        {
            *pwszSlash = L'\\';
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // Create the account BSTR.
        *pbstrUserAccountOut = SysAllocString( pwszSlash + 1 );
        if ( *pbstrUserAccountOut == NULL )
        {
            *pwszSlash = L'\\';
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    } // else: slash specified

Cleanup:
    return hr;

} //*** CClusterCmd::HrParseUserInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusterCmd::HrParseIPAddressInfo(
//        LPCWSTR                   pcwszParamNameIn
//      , const vector< CString > * pvstrValueList
//      , CString *                 pstrIPAddressOut
//      , CString *                 pstrIPSubnetOut
//      , CString *                 pstrNetworkOut
//      )
//
//  Description:
//      Parse the IP address, subnet, and network from multiple values.
//
//  Arguments:
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK    -- Operation was successful.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrParseIPAddressInfo(
      LPCWSTR                   pcwszParamNameIn
    , const vector< CString > * pvstrValueList
    , CString *                 pstrIPAddressOut
    , CString *                 pstrIPSubnetOut
    , CString *                 pstrNetworkOut
    )
    throw()
{
    HRESULT hr  = S_OK;

    // Create the IP address BSTR.
    *pstrIPAddressOut = (*pvstrValueList)[ 0 ];

    // If a subnet was specified, create the BSTR for it.
    if ( pvstrValueList->size() >= 3 )
    {
        // Create the BSTR for the subnet.
        *pstrIPSubnetOut = (*pvstrValueList)[ 1 ];

        // Create the BSTR for the network.
        *pstrNetworkOut = (*pvstrValueList)[ 2 ];
    } // if: subnet and network were specified

    return hr;

} //*** CClusterCmd::HrParseIPAddressInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cluster.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      cluster.cpp
//
//  Description:
//      Cluster.exe main source file.
//      Implements the first level of parsing and hands off execution
//      to appropriate modules.
//
//  Maintained By:
//      David Potter (DavidP                20-ARP-2001
//      Michael Burton (t-mburt)            04-Aug-1997
//      Charles Stacy Harris III (stacyh)   20-March-1997
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <atlimpl.cpp>

#include "cmdline.h"

#include "cluswrap.h"
#include "cluscmd.h"

#include "nodecmd.h"
#include "resgcmd.h"
#include "rescmd.h"

#include "restcmd.h"
#include "netcmd.h"
#include "neticmd.h"

#include "util.h"

CComModule _Module;

#include <atlcom.h>

#include <initguid.h>
#include "Guids.h"      // for minor TASK IDs

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DispatchCommand
//
//  Routine Description:
//      Identifies the command type and instantiates a class of the
//      specified type to handle remaining options.
//
//  Arguments:
//      IN  CCommandLine & theCmdLine
//          This object contains the parsed command line.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DispatchCommand( CCommandLine & theCmdLine )
{
    DWORD dwReturnValue = ERROR_SUCCESS;
    CString strClusterName( theCmdLine.GetClusterName() );

    if ( strClusterName.GetLength() >= MAX_PATH )
    {
        return PrintMessage(MSG_NAMED_PARAMETER_TOO_LONG, (LPCTSTR) strClusterName,
                            MAX_PATH - 1 );
    }

    // Special case: If user enters "." as the name of the cluster, pass ""
    // as the name of the cluster.
    if ( strClusterName.CompareNoCase( TEXT( "." ) ) == 0 )
        strClusterName.Empty();

    switch( theCmdLine.GetObjectType() )
    {
        case objCluster:
            // Create new scope for command object...
            {
                CClusterCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objNode:
            // Create new scope for command object...
            {
                CNodeCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objGroup:
            // Create new scope for command object...
            {
                CResGroupCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objResource:
            // Create new scope for command object...
            {
                CResourceCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objResourceType:
            // Create new scope for command object...
            {
                CResTypeCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objNetwork:
            // Create new scope for command object...
            {
                CNetworkCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
           break;

        case objNetInterface:
            // Create new scope for command object...
            {
                CNetInterfaceCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }

            break;

        default:
        {
            const CString & strObjectName = theCmdLine.GetObjectName();

            if ( strObjectName.IsEmpty() == FALSE )
                PrintMessage( IDS_INVALID_OBJECT_TYPE, strObjectName );

            dwReturnValue = PrintMessage( MSG_HELP_CLUSTER );
        }
    }


    if ( dwReturnValue > 0 ) // usage errors are < ERROR_SUCCESS
    {
        if ( HRESULT_FACILITY( dwReturnValue ) == FACILITY_WIN32 )
        {
            dwReturnValue = HRESULT_CODE( dwReturnValue );
        }
        PrintSystemError( dwReturnValue );
    }

    return dwReturnValue;

} //*** DispatchCommand()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  wmain
//
//  Routine Description:
//      Gets the command line, calls functions to parse it and pass the control
//      to the appropriate command handlers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Same as DispatchCommand
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C" int __cdecl wmain()
{
    int             nReturnValue;
    CString         cmdLine = GetCommandLine();
    CCommandLine    cmd( cmdLine );
    HRESULT         hr = S_OK;

    _Module.Init( ObjectMap, GetModuleHandle( NULL ) );
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( FAILED( hr ) )
    {
        nReturnValue = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    hr = CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    );
    if ( FAILED( hr ) )
    {
        nReturnValue = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    //
    // Set the proper codepage to use for CRT routines.
    //
    MatchCRTLocaleToConsole( ); // okay to proceed if this fails?

    try
    {
        cmd.ParseStageOne();
        nReturnValue = DispatchCommand( cmd );
    }
    catch( CException & e )
    {
        PrintString( e.m_strErrorMsg );
        nReturnValue = PrintMessage( MSG_HELP_CLUSTER );
    }

Cleanup:

    CoUninitialize();

    return nReturnValue;

} //*** wmain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cmdline.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		cmdline.cpp
//
//	Abstract:
//		Implementation of the CCommandLine class.
//
//	Author:
//		Vijayendra Vasu (vvasu)		October 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//	Include files
/////////////////////////////////////////////////////////////////////////////
#include "cmdline.h"
#include "token.h"
#include "cmderror.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::CParseState
//
//	Routine Description:
//		Constructor of the CParseState class
//
//	Arguments:
//		IN	LPCTSTR pszCmdLine
//			The command line passed to cluster.exe
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CParseState::CParseState( LPCTSTR pszCmdLine )  : m_pszCommandLine( pszCmdLine ),
												  m_pszCurrentPosition( pszCmdLine ),
												  m_ttNextTokenType( ttInvalid ),
												  m_bNextTokenReady( FALSE )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::~CParseState
//
//	Routine Description:
//		Destructor of the CParseState class
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CParseState::~CParseState( )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::CParseState
//
//	Routine Description:
//		Copy constructor of the CParseState class
//
//	Arguments:
//		IN	const CParseState & ps
//			The source of the copy.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CParseState::CParseState( const CParseState & ps ) :
	m_bNextTokenReady( ps.m_bNextTokenReady ),
	m_ttNextTokenType( ps.m_ttNextTokenType ),
	m_strNextToken( ps.m_strNextToken ),	
	m_pszCommandLine( ps.m_pszCommandLine ),
	m_pszCurrentPosition( ps.m_pszCurrentPosition )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::operator=
//
//	Routine Description:
//		Assignment operator of the CParseState class
//
//	Arguments:
//		IN	const CParseState & ps
//			The source of the assignment.
//
//	Return Value:
//		The assignee.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CParseState & CParseState::operator=( const CParseState & ps )
{
	m_bNextTokenReady = ps.m_bNextTokenReady;
	m_ttNextTokenType = ps.m_ttNextTokenType;
	m_strNextToken = ps.m_strNextToken;	
	const_cast<LPCTSTR>( m_pszCommandLine ) = ps.m_pszCommandLine;
	m_pszCurrentPosition = ps.m_pszCurrentPosition;

	return *this;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::ReadQuotedToken
//
//	Routine Description:
//		Reads the token till the end of the quote is found.
//
//	Arguments:
//		OUT	CString & strNextToken
//			The string to which the quoted string is appended.
//
//	Return Value:
//		None
//
//	Exceptions:
//		CParseException
//			This exception is thrown when a matching '"' is not found.
//
//	Notes:
//		This function assumes that m_pszCurrentPosition points to the first
//		character after the opening quote (that is, the opening quote has
//		already been parsed.
//
//		Embedded quotes are allowed and are represented by two consecutive
//		'"' characters.
//		
//--
/////////////////////////////////////////////////////////////////////////////
void CParseState::ReadQuotedToken( CString & strToken ) 
	throw( CParseException )
{
	BOOL bInQuotes = TRUE;

	TCHAR cCurChar = *m_pszCurrentPosition;

	while ( cCurChar != TEXT('\0') )
	{
		++m_pszCurrentPosition;

		// Embedded quote (represented by two consecutive '"'s.
		// Or the end of this quoted token.
		if ( cCurChar == TEXT('"') )
		{
			if ( *m_pszCurrentPosition == TEXT('"') )
			{
				strToken += cCurChar;
				++m_pszCurrentPosition;

			} // if: an embedded quote character.
			else
			{
				bInQuotes = FALSE;
				break;

			} // else: end of quoted token

		} // if: we have found another quote character
		else
		{
			strToken += cCurChar;

		} // else: the current character is not a quote

		cCurChar = *m_pszCurrentPosition;

	} // while: we are not at the end of the command line

	// Error: The end of the input was reached but the quoted token 
	// has not ended.
	if ( bInQuotes != FALSE )
	{
		m_bNextTokenReady = FALSE;

		CParseException pe; 
		pe.LoadMessage( MSG_MISSING_QUOTE, strToken );
		throw pe;
	}
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::ReadToken
//
//	Routine Description:
//		Reads a token till a delimiter is found.
//		Assumes that the character pointed to by m_pszCurrentPosition is not
//		a delimiter.
//
//	Arguments:
//		OUT	CString & strNextToken
//			The string to which the new token is appended.
//			This string is not cleared before the token is stored into it.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CParseState::ReadToken( CString & strToken ) 
{
	TCHAR cCurChar = *m_pszCurrentPosition;

	do
	{
		// The beginning of a quoted token.
		if ( cCurChar == TEXT('"') )
		{
			++m_pszCurrentPosition;
			ReadQuotedToken( strToken );
			
            // There is no need to break out of the token reading loop here
            // because the end of a quoted token need not mean the end of the
            // token. A quoted token is appended to the preceding token as if
            // nothing had happened and the parsing continues.
            // For example: hel"lo wor"ld will equate to the token 'hello world'

		} // if: we have encountered a quoted token
		else
		{
			// This character is a whitespace or one of the delimiter characters.
			// We have reached the end of this token.
			if ( ( _istspace( cCurChar ) != 0 ) ||
				 ( DELIMITERS.Find( cCurChar ) != -1 ) )
			{
				break;
			}

			// This character is not a special character. Append it to the token.
			strToken += cCurChar;
			++m_pszCurrentPosition;

		} // else: the current character is not a quote

		cCurChar = *m_pszCurrentPosition;

	}
	while ( cCurChar != TEXT('\0') );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::PreviewNextToken
//
//	Routine Description:
//		Gets the next token without changing the state of the parsing.
//
//	Arguments:
//		OUT	CString & strNextToken
//			The next token in the command line.
//
//	Return Value:
//		The type of the retrieved token.
//
//	Exceptions:
//		CParseException
//			Passes on exception thrown by ReadQuotedToken
//
//	Notes:
//		This function "caches" the token that is previewed, so that the next
//		call to GetNextToken returns this token without any parsing.
//--
/////////////////////////////////////////////////////////////////////////////
TypeOfToken CParseState::PreviewNextToken( CString & strNextToken )
	throw( CParseException )
{
	// The next token has already been parsed. No need to parse again.
	if ( m_bNextTokenReady != FALSE )
	{
		strNextToken = m_strNextToken;
		return m_ttNextTokenType;
	}

	m_bNextTokenReady = TRUE;

	// Skip white spaces
	while ( ( *m_pszCurrentPosition != TEXT('\0') ) && 
			( _istspace( *m_pszCurrentPosition ) != 0 ) )
	{
		++m_pszCurrentPosition;
	}

	strNextToken.Empty();


	TCHAR cCurChar = *m_pszCurrentPosition;

	// This do-while loop is not necessary. It is there only to avoid nested ifs.
	// With this loop, if-break can be used instead.
	do
	{
		// The end of the command line has been reached.
		if ( cCurChar == TEXT('\0') )
		{
			m_ttNextTokenType = ttEndOfInput;
			strNextToken.Empty();
			break;
		}

		// The current character is a seperator between options
		if ( OPTION_SEPARATOR.Find( cCurChar ) != -1 )
		{
			m_ttNextTokenType = ttOption;

			// Skip the seperator.
			++m_pszCurrentPosition;
			cCurChar = *m_pszCurrentPosition;

			if ( ( cCurChar == TEXT('\0') ) || ( _istspace( cCurChar ) != 0 ) )
			{
				CParseException pe; 
				pe.LoadMessage( MSG_OPTION_NAME_EXPTECTED, 
								CString( *( m_pszCurrentPosition - 1 ) ),
								m_pszCurrentPosition - 
								m_pszCommandLine + 1 );

				throw pe;
			}

			// The next character cannot be a whitespace, end of input,
			// another seperator or delimiter.
			if ( ( SEPERATORS.Find( cCurChar ) != -1 ) ||
				 ( DELIMITERS.Find( cCurChar ) != -1 ) )
			{
				CParseException pe; 
				pe.LoadMessage( MSG_UNEXPECTED_TOKEN, CString( cCurChar ), 
								SEPERATORS,
								m_pszCurrentPosition - 
								m_pszCommandLine + 1 );

				throw pe;
			}

			ReadToken( strNextToken );
			break;

		} // if: the current character is an option seperator.

		// The current character is a seperator between the option name and the parameter
		if ( OPTION_VALUE_SEPARATOR.Find( cCurChar ) != -1 )
		{
			m_ttNextTokenType = ttOptionValueSep;
			strNextToken = cCurChar;
			++m_pszCurrentPosition;
			break;
		}

		// The current character is a seperator between the parameter and its value(s).
		if ( PARAM_VALUE_SEPARATOR.Find( cCurChar ) != -1 )
		{
			m_ttNextTokenType = ttParamValueSep;
			strNextToken = cCurChar;
			++m_pszCurrentPosition;
			break;
		}

		// The current character is a seperator between values.
		if ( VALUE_SEPARATOR.Find( cCurChar ) != -1 )
		{
			m_ttNextTokenType = ttValueSep;
			strNextToken = cCurChar;
			++m_pszCurrentPosition;
			break;
		}

		m_ttNextTokenType = ttNormal;
		ReadToken( strNextToken );
	}
	while( FALSE );

	m_strNextToken = strNextToken;
	return m_ttNextTokenType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParseState::GetNextToken
//
//	Routine Description:
//		Gets the next token from the command line
//
//	Arguments:
//		OUT	CString & strNextToken
//			The next token in the command line.
//
//	Return Value:
//		The type of the retrieved token.
//
//	Exceptions:
//		CParseException
//			Passes on exception thrown by ReadQuotedToken
//
//
//--
/////////////////////////////////////////////////////////////////////////////
TypeOfToken CParseState::GetNextToken( CString & strNextToken )
	throw( CParseException )
{
	TypeOfToken ttReturnValue = PreviewNextToken( strNextToken );
	m_bNextTokenReady = FALSE;

	return ttReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CException::LoadMessage
//
//	Routine Description:
//		Loads a formatted string into the exception object member variable.
//
//	Arguments:
//		IN	DWORD dwMessage
//			The message identifier
//
//	Return Value:
//		ERROR_SUCCESS is all is well.
//		A Win32 error code otherwise.
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CException::LoadMessage( DWORD dwMessage, ... )
{
	DWORD dwError = ERROR_SUCCESS;

	va_list args;
	va_start( args, dwMessage );

	HMODULE hModule = GetModuleHandle(0);
	DWORD dwLength;
	LPWSTR lpMessage = NULL;

	dwLength = FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
		(LPCVOID) hModule,
		dwMessage,
		MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),	// Default language,
		(LPWSTR) &lpMessage,
		0,
		&args );

	if( dwLength == 0 )
	{
		// Keep as local for debug
		dwError = GetLastError();
		m_strErrorMsg.Empty();
		return dwError;
	}

	m_strErrorMsg = lpMessage;

	LocalFree( lpMessage );

	va_end( args );

	return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CParser::ParseValues
//
//	Routine Description:
//		Parses a list of values from the command line.
//		For example: cluster myCluster group myGroup /setowners:owner1,owner2
//		This functions assumes that the first token that it gets is the 
//		seperator (':' in the example). This is extracted and discarded.
//		The list of values is then parsed.
//
//	Arguments:
//		IN	CParseState & parseState
//			Contains the command line string and related data
//
//		OUT	vector<CString> & vstrValues
//			A vector containing the extracted values.
//
//	Return Value:
//		None.
//
//	Exceptions:
//		CParseException
//			Passes on exception thrown by ReadQuotedToken
//
//--
/////////////////////////////////////////////////////////////////////////////
void CParser::ParseValues( CParseState & parseState, vector<CString> & vstrValues )
{
	CString strToken;

	// This parameter has values associated with it.
	do
	{
		CString strSep;
		TypeOfToken ttTokenType;

		// Get and discard the seperator.
		parseState.GetNextToken( strSep );

		ttTokenType = parseState.PreviewNextToken( strToken );

		// If there is a separator, there has to be a value.
		if ( ttTokenType == ttEndOfInput )
		{
			CParseException pe; 
			pe.LoadMessage( MSG_VALUE_EXPECTED, strSep, 
							parseState.m_pszCurrentPosition - 
							parseState.m_pszCommandLine + 1 );

			throw pe;
		}

		if ( ttTokenType != ttNormal )
		{
			CParseException pe; 
			pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
							SEPERATORS,
							parseState.m_pszCurrentPosition - 
							parseState.m_pszCommandLine + 1 );

			throw pe;
		}

		parseState.GetNextToken( strToken );
		vstrValues.push_back( strToken );

	}
	while ( parseState.PreviewNextToken( strToken ) == ttValueSep );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::CCmdLineParameter
//
//	Routine Description:
//		Constructor of the CCmdLineParameter class
//
//	Arguments:
//		None.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineParameter::CCmdLineParameter()
{
	Reset();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::~CCmdLineParameter
//
//	Routine Description:
//		Destructor of the CCmdLineParameter class
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineParameter::~CCmdLineParameter()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::GetType
//
//	Routine Description:
//		Gets the type of this parameter.
//
//	Arguments:
//		None
//
//	Return Value:
//		The type of this parameter.
//
//--
/////////////////////////////////////////////////////////////////////////////
ParameterType CCmdLineParameter::GetType() const
{
	return m_paramType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::GetValueFormat
//
//	Routine Description:
//		Gets the format of the values that this parameter can take.
//
//	Arguments:
//		None
//
//	Return Value:
//		The format of the values that this parameter can take.
//
//--
/////////////////////////////////////////////////////////////////////////////
ValueFormat CCmdLineParameter::GetValueFormat() const
{
	return m_valueFormat;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::GetValueFormatName
//
//	Routine Description:
//		Gets the string that specifies the format of the values that this 
//		parameter can take.
//
//	Arguments:
//		None
//
//	Return Value:
//		The value format specifier string.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCmdLineParameter::GetValueFormatName() const
{
	return m_strValueFormatName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::GetName
//
//	Routine Description:
//		Gets the name of this parameter.
//
//	Arguments:
//		None
//
//	Return Value:
//		The name of this parameter.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCmdLineParameter::GetName() const
{
	return m_strParamName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::GetValues
//
//	Routine Description:
//		Gets the values associated with this parameter.
//
//	Arguments:
//		None
//
//	Return Value:
//		A vector of strings which contain the values.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CString> & CCmdLineParameter::GetValues() const
{
	return m_vstrValues;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::GetValuesMultisz
//
//	Routine Description:
//		Get the values associated with this parameter as a MULTI_SZ string.
//
//	Arguments:
//		OUT CString &strReturnValue		
//			The string that contains the concatenation of the value strings
//			(including their NULL terminators) with an extra NULL 
//			character after	the NULL of the last string.
//
//	Return Value:
//		None.
//
//	Remarks:
//		The result is not returned in a parameter (not as a return value)
//		because we do not know how the copy constructors of CString handle
//		strings with multiple null characters in them.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineParameter::GetValuesMultisz( CString & strReturnValue ) const
{
	UINT nNumberOfValues, nTotalLength;

	strReturnValue = "";
	
	nNumberOfValues = m_vstrValues.size();

	nTotalLength = 0;
	for (int i = 0; i < nNumberOfValues; ++i)
		nTotalLength += m_vstrValues[i].GetLength();

	// Add the space required for the nNumberOfValues '\0's and the 
	// extra '\0' at the end.
	nTotalLength += nNumberOfValues + 1;

	LPTSTR lpmultiszBuffer = strReturnValue.GetBuffer(nTotalLength);

	for (i = 0; i < nNumberOfValues; ++i)
	{
		const CString & strCurString = m_vstrValues[i];
		UINT nCurStrLen = strCurString.GetLength() + 1;

		lstrcpyn(lpmultiszBuffer, strCurString, nCurStrLen);
		lpmultiszBuffer += nCurStrLen;
	}

	*lpmultiszBuffer = TEXT('\0');

	strReturnValue.ReleaseBuffer(nTotalLength - 1);
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::ReadKnownParameter
//
//	Routine Description:
//		This function reads "known" parameters. Known parameters are those
//		which are specified in the ParameterType enumeration (and in the 
//		paramLookupTable). Their syntax is the same as those for options,
//		but they are treated as parameters to the previous option.
//
//	Arguments:
//		IN	CParseState & parseState
//			Contains the command line string and related data
//
//	Exceptions:
//		CParseException
//			Thrown for errors during parsing.
//
//	Return Value:
//		Returns TRUE if this token is a parameter.
//		Returns FALSE if it an option..
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCmdLineParameter::ReadKnownParameter( CParseState & parseState ) throw( CParseException )
{
	CString strToken;
	TypeOfToken ttTokenType;
	ParameterType ptCurType;

	Reset();

	ttTokenType = parseState.PreviewNextToken( strToken );

	if ( ttTokenType != ttOption )
	{
		CParseException pe; 
		pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
						SEPERATORS,
						parseState.m_pszCurrentPosition - 
						parseState.m_pszCommandLine + 1 );
		throw pe;

	} // if: this token is not an option seperator

	ptCurType = LookupType( strToken, paramLookupTable, paramLookupTableSize );
	if ( ptCurType == paramUnknown )
	{
		// This is not a parameter.
		return FALSE;
	}

	// This is the name of the parameter.
	parseState.GetNextToken( m_strParamName );
	m_paramType = ptCurType;

	if ( parseState.PreviewNextToken( strToken ) == ttOptionValueSep )
	{
		// This parameter has values associated with it.
		ParseValues( parseState, m_vstrValues );

	} // if: this token is a option-value seperator.

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::Parse
//
//	Routine Description:
//		Parse the command line and extract one parameter.
//
//	Arguments:
//		IN	CParseState & parseState
//			Contains the command line string and related data
//
//	Exceptions:
//		CParseException
//			Thrown for errors during parsing.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineParameter::Parse( CParseState & parseState ) throw( CParseException )
{
	CString strToken;
	TypeOfToken ttTokenType;

	Reset();

	ttTokenType = parseState.PreviewNextToken( strToken );

	if ( ttTokenType == ttEndOfInput )
	{
		// We are done parsing.
		return;
	}

	if ( ttTokenType != ttNormal )
	{
		CParseException pe; 
		pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
						SEPERATORS,
						parseState.m_pszCurrentPosition - 
						parseState.m_pszCommandLine + 1 );

		throw pe;
	}

	// This is the name of the parameter.
	parseState.GetNextToken( m_strParamName );
	m_paramType = paramUnknown;

	if ( parseState.PreviewNextToken( strToken ) == ttParamValueSep )
	{
		// This parameter has values associated with it.
		ParseValues( parseState, m_vstrValues );

		// See if this parameter has a value format field associated with it.
		// For example: cluster myCluster res myResource /priv size=400:DWORD

		// We actually need to have a different token type for this. 
		// But since, in the current grammar, the option-value separator is 
		// the same as the value-format separator, we are reusing this 
		// token type.
		if ( parseState.PreviewNextToken( strToken ) == ttOptionValueSep )
		{
			// Get and discard the separator.
			parseState.GetNextToken( strToken );

			if ( parseState.PreviewNextToken( strToken ) != ttNormal )
			{
				CParseException pe; 
				pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
								SEPERATORS,
								parseState.m_pszCurrentPosition - 
								parseState.m_pszCommandLine + 1 );

				throw pe;
			}

			parseState.GetNextToken( m_strValueFormatName );
			m_valueFormat = LookupType( strToken, formatLookupTable, 
										formatLookupTableSize );

		} // if: A value format has been specified.
		else
		{
			// A value format has not been specified.
			m_valueFormat = vfUnspecified;

		} // else: A value format has not been specified.

	} // if: this token is a param-value seperator.
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineParameter::Reset
//
//	Routine Description:
//		Resets all the member variables to their default states.
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineParameter::Reset()
{
	m_strParamName.Empty();
	m_paramType = paramUnknown;
	m_valueFormat = vfInvalid;
	m_strValueFormatName.Empty();
	m_vstrValues.clear();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::CCmdLineOption
//
//	Routine Description:
//		Constructor of the CCmdLineOption class
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineOption::CCmdLineOption()
{
	Reset();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::~CCmdLineOption
//
//	Routine Description:
//		Destructor of the CCmdLineOption class
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineOption::~CCmdLineOption()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::GetName
//
//	Routine Description:
//		Gets the name of this option.
//
//	Arguments:
//		None
//
//	Return Value:
//		The name of this option.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCmdLineOption::GetName() const
{
	return m_strOptionName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::GetType
//
//	Routine Description:
//		Gets the type of this option.
//
//	Arguments:
//		None
//
//	Return Value:
//		The type of this option.
//
//--
/////////////////////////////////////////////////////////////////////////////
OptionType CCmdLineOption::GetType() const
{
	return m_optionType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::GetValues
//
//	Routine Description:
//		Gets the values associated with this option.
//
//	Arguments:
//		None
//
//	Return Value:
//		A vector of CString.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CString> & CCmdLineOption::GetValues() const
{
	return m_vstrValues;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::GetParameters
//
//	Routine Description:
//		Gets the parameters associated with this option.
//
//	Arguments:
//		None
//
//	Return Value:
//		A vector of CCmdLineParameter.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CCmdLineParameter> & CCmdLineOption::GetParameters() const
{
	return m_vparParameters;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::Reset
//
//	Routine Description:
//		Resets all the member variables to their default states.
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineOption::Reset()
{
	m_optionType = optInvalid;
	m_strOptionName.Empty();
	m_vparParameters.clear();
	m_vstrValues.clear();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCmdLineOption::Parse
//
//	Routine Description:
//		Parse the command line and extract one option with all its parameters.
//
//	Arguments:
//		IN	CParseState & parseState
//			Contains the command line string and related data
//
//	Exceptions:
//		CParseException
//			Thrown for errors during parsing.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineOption::Parse( CParseState & parseState ) throw( CParseException )
{
	CString strToken;
	TypeOfToken ttNextTokenType;

	Reset();

	switch ( parseState.PreviewNextToken( strToken ) )
	{
		case ttNormal:
		{
			// The type of this option is 'optDefault'. That is the name of
			// the option is not specified with the /optionName switch.
			// Only the parameters are specified.
			// For example: cluster myClusterName node myNodeName
			
			m_optionType = optDefault;

			break;
		}

		case ttOption:
		{
			// This is actually a parameter to the default option.
			if ( LookupType( strToken, paramLookupTable, paramLookupTableSize ) != paramUnknown )
			{
				m_optionType = optDefault;
				break;
			}

			// Get the name of the option.
			parseState.GetNextToken( m_strOptionName );
			m_optionType = LookupType( m_strOptionName, optionLookupTable, 
									   optionLookupTableSize );

			// See if there is a option-parameter seperator.
			// For example: cluster myClusterName /rename:newClusterName
			if ( parseState.PreviewNextToken( strToken ) == ttOptionValueSep )
			{
				ParseValues( parseState, m_vstrValues );
			}
			break;

		} // case ttOption

		case ttEndOfInput:
		{
			// We are done parsing.
			return;
		}

		default:
		{
			CParseException pe; 
			pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
							SEPERATORS,
							parseState.m_pszCurrentPosition - 
							parseState.m_pszCommandLine + 1 );
			throw pe;
		}

	} // switch: based on the type of the retrieved token

	CCmdLineParameter oneParam;
	ttNextTokenType = parseState.PreviewNextToken( strToken );

	// While there are still tokens and we have not reached the next option,
	// read in the tokens as parameters to this option.
	while ( ttNextTokenType != ttEndOfInput )
	{
		// Many of the options in the previous version of cluster.exe
		// are actually treated as parameters and not as options.
		// For the sake of backwards comapatability, these parameters
		// can still be specified as if it were an option. Check for this.
		if ( ttNextTokenType == ttOption )
		{
			// This is really the next option, not a "known" parameter.
			if ( oneParam.ReadKnownParameter( parseState ) == FALSE )
			{
				break;
			}

		} // if: this token is an option separator
		else
		{
			oneParam.Parse( parseState );

		} // else: this token is not an option separator.

		m_vparParameters.push_back( oneParam );
		oneParam.Reset();

		ttNextTokenType =  parseState.PreviewNextToken( strToken );
	}
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::CCommandLine
//
//	Routine Description:
//		Constructor of the CCommandLine class. The entire command line is parsed
//		in this function.
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCommandLine::CCommandLine( const CString & strCommandLine ) :
	m_objectType( objInvalid ),
    m_parseState( strCommandLine )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::~CCommandLine
//
//	Routine Description:
//		Destructor of the CCommandLine class
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCommandLine::~CCommandLine()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::GetClusterName
//
//	Routine Description:
//		Get the name of the cluster specified on the command line
//
//	Arguments:
//		None
//
//	Return Value:
//		The name of the cluster
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCommandLine::GetClusterName() const
{
	return m_strClusterName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::GetObjectName
//
//	Routine Description:
//		Get the name of the object specified on the cluster.exe command line.
//
//	Arguments:
//		None
//
//	Return Value:
//		The name of the object specfied.
//		An empty string if none is specified.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCommandLine::GetObjectName() const
{
	return m_strObjectName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::GetObjectType
//
//	Routine Description:
//		Get the type of the object specified on the cluster.exe command line.
//
//	Arguments:
//		None
//
//	Return Value:
//		The type of the object specified.
//		objCluster is returned if no object name is specified.
//--
/////////////////////////////////////////////////////////////////////////////
ObjectType CCommandLine::GetObjectType() const
{
	return m_objectType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::GetOptions
//
//	Routine Description:
//		Get the options specified on the cluster.exe command line.
//
//	Arguments:
//		None
//
//	Return Value:
//		A list of CCmdLineOption objects.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CCmdLineOption> & CCommandLine::GetOptions() const
{
	return m_voptOptionList;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::Reset
//
//	Routine Description:
//		Resets all the state variables to their default states.
//
//	Arguments:
//		None
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::Reset()
{
	m_objectType = objInvalid;
	m_strObjectName.Empty();
	m_strClusterName.Empty();
	m_voptOptionList.clear();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::ParseStageOne
//
//	Routine Description:
//		Parse the command line till the name of the object is got.
//      For example: cluster myCluster res /status
//      This command parses upto and including the token 'res'
//
//	Arguments:
//		None
//
//	Exceptions:
//		CParseException
//			Thrown for errors during parsing.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::ParseStageOne() 
	throw( CParseException, CSyntaxException )
{
	// This is a big function :) 
	// The three main steps in this function are as follows 
	// (they are also labelled as such in the code below)
	//		1. Get the name of the executable from the command line and discard it.
	//		2. Get the name of the cluster to administer.
	//		3. Get the type of object (node, res, restype, etc.)


	/////////////////////////////////////////////////////////////////////////////
	//	Step 1. Get the name of the executable from the command line and discard it.
	/////////////////////////////////////////////////////////////////////////////

	Reset();

	// The first white space delimited token in the command line is the name 
	// of the executable. Discard it.

	TCHAR cCurChar = *m_parseState.m_pszCurrentPosition;

	while ( cCurChar != TEXT('\0') ) 
	{
		if ( cCurChar == TEXT('"') ) 
		{
			// Skip the opening quote
			++m_parseState.m_pszCurrentPosition;

			CString strJunkString;

			m_parseState.ReadQuotedToken( strJunkString );
			break;

		} // if:  found quote character
		else
		{
			if ( _istspace( cCurChar ) != FALSE )
			{
				break;
			}
			else
			{
				++m_parseState.m_pszCurrentPosition;
			}

		} // else: the current character is not a quote

		cCurChar = *m_parseState.m_pszCurrentPosition;

	} // while: not at the end of the command line.


	/////////////////////////////////////////////////////////////////////////////
	//	Step 2. Get the name of the cluster to administer.
	/////////////////////////////////////////////////////////////////////////////

	CString strFirstToken;

	// Preview the next token and make decisions based on its type.
	switch ( m_parseState.PreviewNextToken( strFirstToken ) )
	{
		// This could be the name of the cluster or of an object.
		case ttNormal:
		{
			ObjectType firstObjType = LookupType( strFirstToken, objectLookupTable, 
												  objectLookupTableSize );

			if ( firstObjType == objInvalid )
			{
				// This token is not a valid object name.
				// For example: cluster myClusterName node /status
				// Assume that it is the name of the cluster.
				m_parseState.GetNextToken( m_strClusterName );

			} // if: the first token on the command line is not a known object name
			else
			{
				// This token is a valid object name.
				// Is it the name of a cluster? Or is it actually an object name?

				CString strSecondToken;
				ObjectType secondObjectType;

				// Get the token that we previewed and thus advance the parse state.
				m_parseState.GetNextToken( strFirstToken );

				if ( ( m_parseState.PreviewNextToken( strSecondToken ) == ttNormal ) &&
					 ( ( secondObjectType = LookupType( strSecondToken, objectLookupTable,
														objectLookupTableSize ) ) != objInvalid ) )
				{
					// We now have two consecutive valid object names.
					// For example: cluster node node /status
					// This command now means "get the status of all nodes on the
					// cluster named 'node'"
					// To see the status of a node called 'node' on the default cluster
					// the command "cluster . node node /status" can be used.

					// If we assume that the second 'node' is the node name, then there will
					// be no way to see the status of all nodes on a cluster named
					// 'node'

					m_parseState.GetNextToken( strSecondToken );

					m_strClusterName = strFirstToken;
					m_objectType = secondObjectType;
					m_strObjectName = strSecondToken;

				} // if: the second token is also a valid object name.
				else
				{
					// The second token is not a valid object name.
					// For example: cluster node Foo
					// Therefore, no cluster name has been specified.

					m_strClusterName.Empty();
					m_objectType = firstObjType;
					m_strObjectName = strFirstToken;

				} // else: the second token is not a valid object name.

			} // else: the second token on the command line is a known object name

			break;

		} // case: a normal token (not a seperator) was got.

		case ttOption:
		{
			// An option is found directly after the executable name.
			// For example: cluster /ver

			// Check if the name of the cluster is being specified
			CCmdLineParameter oneParam;

			if ( oneParam.ReadKnownParameter( m_parseState ) == FALSE )
			{
				// This is really the next option, not the name of the cluster.
				m_objectType = objCluster;
			}
			else
			{
				// The cluster name is being specified.
				if ( oneParam.GetType() != paramCluster )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_INVALID_PARAMETER, oneParam.GetName() );
					throw se;
				}

				if ( oneParam.GetValues().size() != 1 )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, oneParam.GetName() );
					throw se;
				}

				m_strClusterName = ( oneParam.GetValues() )[0];
				m_objectType = objInvalid;
			}

			break;

		} // case: an option was found.

		case ttEndOfInput:
		{
			// We are done parsing.
			return;
		}

		default:
		{
			CParseException pe; 
			pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strFirstToken, 
							SEPERATORS,
							m_parseState.m_pszCurrentPosition - 
							m_parseState.m_pszCommandLine + 1 );
			throw pe;
		}

	} // switch: based on the type of the first retrieved token.


	// At this point, the name of the cluster and maybe the type of the 
	// object have been retrieved from the command line.

	// If the object type has not yet been retrieved from the command line,
	// get it now.
	if ( m_objectType == objInvalid )
	{
		/////////////////////////////////////////////////////////////////////////////
		//	Step 3. Get the type of object (node, res, restype, etc.)
		/////////////////////////////////////////////////////////////////////////////

		switch ( m_parseState.PreviewNextToken( strFirstToken ) )
		{
			case ttNormal:
			{
				// We have the cluster name and now another token which is not
				// an option. This has to be a known object type.
				// For example: cluster myClusterName node /status
				m_parseState.GetNextToken( m_strObjectName );
				m_objectType = LookupType( m_strObjectName, objectLookupTable,
										   objectLookupTableSize );

				break;
			}

			case ttOption:
			{
				// We have hit the options already. No object type has been specified.
				// For example: cluster myClusterName /ver
				m_objectType = objCluster;

				break;
			}

			case ttEndOfInput:
			{
				// We are done parsing.
				return;
			}

			default:
			{
				CParseException pe; 
				pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strFirstToken, 
								SEPERATORS,
								m_parseState.m_pszCurrentPosition - 
								m_parseState.m_pszCommandLine + 1 );
				throw pe;
			}

		} // switch: based on the type of the retrieved token
		

	} // if: the object type has not yet been retrieved
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::ParseStageTwo
//
//	Routine Description:
//		Parse the command line to get the options, parameters and values.
//      For example: cluster myCluster res /status
//      This function assumes that the command line has been parsedupto and 
//      including the token 'res'. It then parses the rest of the command line.
//
//	Arguments:
//		None
//
//	Exceptions:
//		CParseException
//			Thrown for errors during parsing.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::ParseStageTwo() 
	throw( CParseException, CSyntaxException )
{
	/////////////////////////////////////////////////////////////////////////////
	//	Get the options for this object (/status, /ver, etc.)
	/////////////////////////////////////////////////////////////////////////////

	CCmdLineOption oneOption;
    CString strToken;

	while ( m_parseState.PreviewNextToken( strToken ) != ttEndOfInput )
	{
		oneOption.Parse( m_parseState );
		m_voptOptionList.push_back( oneOption );
		oneOption.Reset();
	}
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCommandLine::Parse
//
//	Routine Description:
//      Calls functions for both stages of parsing.
//
//	Arguments:
//		IN	CParseState & parseState
//			Contains the command line string and related data
//
//	Exceptions:
//		CParseException
//			Thrown for errors during parsing.
//
//	Return Value:
//		None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::Parse( CParseState & parseState ) 
	throw( CParseException, CSyntaxException )
{
    m_parseState = parseState;

    ParseStageOne();
    ParseStageTwo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\intrfc.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

	intrfc.cpp

Abstract:

	Commands for modules which have a Network Interface
	(nodes and networks).  Implements the ListInterfaces command


Author:

	Michael Burton (t-mburt)			25-Aug-1997


Revision History:


--*/


#include "intrfc.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::CHasInterfaceModuleCmd
//
//	Routine Description:
//		Default Constructor
//		Initializes all the DWORD parameters to UNDEFINED and
//		all the pointers to cluster functions to NULL.
//		*ALL* these variables must be defined in any derived class.
//
//	Arguments:
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		m_dwMsgStatusListInterface		SET
//		m_dwClusterEnumModuleNetInt 	SET
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CHasInterfaceModuleCmd::CHasInterfaceModuleCmd( CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	m_dwMsgStatusListInterface	 = UNDEFINED;
	m_dwClusterEnumModuleNetInt  = UNDEFINED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::Execute
//
//	Routine Description:
//		Takes a command line option and determines which command to
//		execute.  If no command line option specified, gets the next one
//		automatically.	If the token is not identied as being handle-able
//		in this class, the token is passed up to CGenericModuleCmd::Execute
//		unless DONT_PASS_HIGHER is specified as the second parameter,
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	ExecuteOption eEOpt							
//			OPTIONAL enum, either DONT_PASS_HIGHER or
//			PASS_HIGHER_ON_ERROR (default)
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::Execute( const CCmdLineOption & option, 
									   ExecuteOption eEOpt )
	throw( CSyntaxException )
{
	// Look up the command
	if ( option.GetType() == optListInterfaces )
		return ListInterfaces( option );

	if (eEOpt == PASS_HIGHER_ON_ERROR)
		return CGenericModuleCmd::Execute( option );
	else
		return ERROR_NOT_HANDLED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::ListInterfaces
//
//	Routine Description:
//		Lists the network interfaces attached to the device specified
//		by the instantiated derived class
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_strModuleName 				Name of the module
//		m_dwClusterEnumModuleNetInt 	Command identifier for m_pfnClusterOpenEnum()
//		m_dwMsgStatusListInterface		Message identifier for PrintMessage()
//		m_pfnClusterOpenEnum()			Function to open an enumeration
//		m_pfnWrapClusterEnum()			Wrapper function to enumerate through netints
//		m_pfnClusterCloseEnum() 		Function to close an enumeration
//		m_hCluster						SET (by OpenCluster)
//		m_hModule						SET (by OpenModule)
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::ListInterfaces( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	DWORD dwIndex = 0;
	DWORD dwType = 0;
	DWORD dwError = ERROR_SUCCESS;
	LPWSTR lpszName = 0;

	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	// Open the network and cluster, in case this hasn't
	// been done yet
	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;


	assert(m_pfnClusterOpenEnum);
	HCLUSENUM hEnum = m_pfnClusterOpenEnum( m_hModule, m_dwClusterEnumModuleNetInt );

	if( !hEnum )
		return GetLastError();

	assert(m_dwMsgStatusListInterface != UNDEFINED);
	PrintMessage( m_dwMsgStatusListInterface, (LPCTSTR) m_strModuleName);
	PrintMessage( MSG_NETINTERFACE_STATUS_HEADER );

	assert(m_pfnWrapClusterEnum);
	for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
	{

		dwError = m_pfnWrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

		if( dwError == ERROR_SUCCESS )
			PrintStatusLineForNetInterface( lpszName );
		if( lpszName )
			LocalFree( lpszName );
	}


	if( dwError == ERROR_NO_MORE_ITEMS )
		dwError = ERROR_SUCCESS;

	assert(m_pfnClusterCloseEnum);
	m_pfnClusterCloseEnum( hEnum );

	return dwError;

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::PrintStatusLineForNetInterface
//
//	Routine Description:
//		Prints out a line indicating the status of an individual
//		network interface
//
//	Arguments:
//		lpszNetInterfaceName			Name of network interface
//
//	Member variables used / set:
//		m_lpszNetworkName			(used by GetNetworkName)
//		m_lpszNodeName				(used by GetNodeName)
//
//	Return Value:
//		Same as PrintStatusNetInterface
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::PrintStatusLineForNetInterface( LPWSTR lpszNetInterfaceName )
{
	DWORD dwError = ERROR_SUCCESS;
	LPWSTR lpszNodeName;
	LPWSTR lpszNetworkName;

	// Open the Net Interface handle
	HNETINTERFACE hNetInterface = OpenClusterNetInterface( m_hCluster, lpszNetInterfaceName );
	if( !hNetInterface )
		return GetLastError();

	lpszNodeName = GetNodeName(lpszNetInterfaceName);
	lpszNetworkName = GetNetworkName(lpszNetInterfaceName);

	if (lpszNodeName && lpszNetworkName)
	{
		dwError = PrintStatusOfNetInterface( hNetInterface, lpszNodeName, lpszNetworkName );
		LocalFree(lpszNodeName);
		LocalFree(lpszNetworkName);
	}
	else
	{
		dwError = PrintStatusOfNetInterface( hNetInterface, L"", L"" );
		LocalFree(lpszNodeName);
		LocalFree(lpszNetworkName);
	}

	CloseClusterNetInterface( hNetInterface );

	return dwError;
}




/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::PrintStatusOfNetInterface
//
//	Routine Description:
//		Prints out a the actual status of the specified network interface
//
//	Arguments:
//		hNetInterface					The specified network interface
//		lpszNetworkName 				Name of network (for printing)
//		lpszNodeName					Name of node	(for printing)
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::PrintStatusOfNetInterface( HNETINTERFACE hNetInterface, LPWSTR lpszNodeName, LPWSTR lpszNetworkName)
{
	DWORD dwError = ERROR_SUCCESS;

	CLUSTER_NETINTERFACE_STATE nState;

	nState = GetClusterNetInterfaceState( hNetInterface );

	if( nState == ClusterNetInterfaceStateUnknown )
		return GetLastError();

	LPWSTR lpszStatus = 0;

	switch( nState )
	{
		case ClusterNetInterfaceUnavailable:
			LoadMessage( MSG_STATUS_UNAVAILABLE, &lpszStatus );
			break;

		case ClusterNetInterfaceFailed:
			LoadMessage( MSG_STATUS_FAILED, &lpszStatus );
			break;

		case ClusterNetInterfaceUnreachable:
		   LoadMessage( MSG_STATUS_UNREACHABLE, &lpszStatus );
		   break;

		case ClusterNetInterfaceUp:
			LoadMessage( MSG_STATUS_UP, &lpszStatus );
			break;

		case ClusterNetInterfaceStateUnknown:
		default:
			LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
	}

	dwError = PrintMessage( MSG_NETINTERFACE_STATUS, lpszNodeName, lpszNetworkName, lpszStatus );

	// Since Load/FormatMessage uses LocalAlloc...
	LocalFree( lpszStatus );

	return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::GetNodeName
//
//	Routine Description:
//		Returns the name of the node for the specified network interface.
//		*Caller must LocalFree memory*
//
//	Arguments:
//		lpszInterfaceName			Name of the network interface
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//
//	Return Value:
//		Name of the node			on success
//		NULL						on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CHasInterfaceModuleCmd::GetNodeName (LPWSTR lpszInterfaceName)
{
	DWORD dwError;
	DWORD cLength = 0;
	LPWSTR lpszNodeName;
	HNETINTERFACE hNetInterface;

	// Open the cluster and netinterface if it hasn't been done
	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return NULL;

	// Open an hNetInterface for the specified lpszInterfaceName
	hNetInterface = OpenClusterNetInterface( m_hCluster, lpszInterfaceName );
	if( hNetInterface == 0 )
		return NULL;

	// Find out how much memory to allocate
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NODE,
		0,
		0,
		NULL,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
		return NULL;

	lpszNodeName = (LPWSTR) LocalAlloc( LMEM_FIXED,sizeof(WCHAR)*(++cLength) );
	if (!lpszNodeName) return NULL;

	// Get the node name and store it in a temporary
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NODE,
		0,
		0,
		(LPVOID) lpszNodeName,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
	{
		if (lpszNodeName) LocalFree (lpszNodeName);
		return NULL;
	}

	CloseClusterNetInterface( hNetInterface );

	return lpszNodeName;
}




/////////////////////////////////////////////////////////////////////////////
//++
//
//	CHasInterfaceModuleCmd::GetNetworkName
//
//	Routine Description:
//		Returns the name of the network for the specified network interface.
//		*Caller must LocalFree memory*
//
//	Arguments:
//		lpszInterfaceName			Name of the network interface
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//
//	Return Value:
//		Name of the network 		on success
//		NULL						on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CHasInterfaceModuleCmd::GetNetworkName (LPWSTR lpszInterfaceName)
{
	DWORD dwError;
	DWORD cLength = 0;
	LPWSTR lpszNetworkName;
	HNETINTERFACE hNetInterface;

	// Open the cluster and netinterface if it hasn't been done
	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return NULL;

	// Open an hNetInterface for the specified lpszInterfaceName (don't call
	// OpenNetInterface because that opens m_hNetInterface)
	hNetInterface = OpenClusterNetInterface( m_hCluster, lpszInterfaceName );
	if( hNetInterface == 0 )
		return NULL;

	// Find out how much memory to allocate
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NETWORK,
		0,
		0,
		NULL,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
		return NULL;

	lpszNetworkName = (LPWSTR) LocalAlloc( LMEM_FIXED,sizeof(WCHAR)*(++cLength) );
	if (!lpszNetworkName) return NULL;

	// Get the node name and store it in a temporary
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NETWORK,
		0,
		0,
		(LPVOID) lpszNetworkName,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
	{
		if (lpszNetworkName) LocalFree (lpszNetworkName);
		return NULL;
	}

	CloseClusterNetInterface( hNetInterface );

	return lpszNetworkName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\intrfc.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    intrfc.h

Abstract:

    This module defines the interface available for modules
	which support the ListInterface command
	
Revision History:

--*/

#ifndef __INTRFC_H__
#define __INTRFC_H__

#include "modcmd.h"

class CHasInterfaceModuleCmd : virtual public CGenericModuleCmd
{
public:
	CHasInterfaceModuleCmd( CCommandLine & cmdLine );

protected:
	virtual DWORD  PrintStatusLineForNetInterface( LPWSTR lpszNetInterfaceName );
	virtual DWORD  PrintStatusOfNetInterface( HNETINTERFACE hNetInterface, LPWSTR lpszNodeName, LPWSTR lpszNetworkName);
	virtual LPWSTR GetNodeName (LPWSTR lpszInterfaceName);
	virtual LPWSTR GetNetworkName (LPWSTR lpszInterfaceName);

	// Additional Commands
	virtual DWORD Execute( const CCmdLineOption & option, 
						   ExecuteOption eEOpt = PASS_HIGHER_ON_ERROR  )
		throw( CSyntaxException );

	virtual DWORD ListInterfaces( const CCmdLineOption & thisOption )
		throw( CSyntaxException );

	DWORD     m_dwMsgStatusListInterface;
	DWORD     m_dwClusterEnumModuleNetInt;
}; 

#endif // __INTRFC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\modcmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	modcmd.h

Abstract:

	This module defines the interface available for functions
	implemented by most every module
	
Revision History:

--*/

#ifndef __MODCMD_H__
#define __MODCMD_H__

#include "precomp.h"

#include "token.h"
#include "cluswrap.h"
#include "cmderror.h"

#include "cmdline.h"
#include "util.h"



#ifdef UNDEFINED
#undef UNDEFINED
#endif

//
// number of bytes to allocate to hold average sized property list
//
#define DEFAULT_PROPLIST_BUFFER_SIZE    1024

// I hope that -1 is not a valid number for any of these constants,
// otherwise the asserts will fail
#define UNDEFINED ((ULONG)-1)

const DWORD ERROR_NOT_HANDLED = !ERROR_SUCCESS; // An error returned by
												// Execute.  Don't care what
												// the value is as long as it's
												// not ERROR_SUCCESS

// HCLUSMODULE will be the generic way we refer to
// HCLUSTER, HNETWORK, HNODE, HRESOURCE, etc (each is a pointer)
typedef void* HCLUSMODULE;


class CGenericModuleCmd
{
public:
	enum PropertyType {
		PRIVATE,
		COMMON
	};
	enum ExecuteOption {
		DONT_PASS_HIGHER,
		PASS_HIGHER_ON_ERROR
	};


	CGenericModuleCmd( CCommandLine & cmdLine );
	virtual ~CGenericModuleCmd();

protected:
	// Primary entry point into module
	virtual DWORD Execute( const CCmdLineOption & option )
		throw( CSyntaxException );

	// Help facilities
	virtual DWORD PrintHelp();

	// Commands Available in all modules
	virtual DWORD Status( const CCmdLineOption * pOption )
		throw( CSyntaxException );

	virtual DWORD DoProperties( const CCmdLineOption & thisOption,
								PropertyType ePropertyType )
		throw( CSyntaxException );

	virtual DWORD GetProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType, LPCWSTR lpszModuleName );

	virtual DWORD SetProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType )
		throw( CSyntaxException );


	virtual DWORD AllProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType ) 
		throw( CSyntaxException );


	virtual DWORD OpenCluster();
	virtual void  CloseCluster();

	virtual DWORD OpenModule();
	virtual void  CloseModule();

	virtual DWORD PrintStatus( LPCWSTR lpszModuleName ) = 0;


	CString m_strClusterName;
	CString m_strModuleName;
	CCommandLine & m_theCommandLine;

	HCLUSTER	m_hCluster;
	HCLUSMODULE m_hModule;


	// Various constant parameters which must be different
	// for each derived class
	DWORD m_dwMsgStatusList;
	DWORD m_dwMsgStatusListAll;
	DWORD m_dwMsgStatusHeader;
	DWORD m_dwMsgPrivateListAll;
	DWORD m_dwMsgPropertyListAll;
	DWORD m_dwMsgPropertyHeaderAll;
	DWORD m_dwCtlGetPrivProperties;
	DWORD m_dwCtlGetCommProperties;
	DWORD m_dwCtlGetROPrivProperties;
	DWORD m_dwCtlGetROCommProperties;
	DWORD m_dwCtlSetPrivProperties;
	DWORD m_dwCtlSetCommProperties;
	DWORD m_dwClusterEnumModule;
	HCLUSMODULE (*m_pfnOpenClusterModule) (HCLUSTER, LPCWSTR);
	BOOL		(*m_pfnCloseClusterModule) (HCLUSMODULE);
	DWORD		(*m_pfnClusterModuleControl) (HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD);
	HCLUSENUM	(*m_pfnClusterOpenEnum) (HCLUSMODULE,DWORD);
	DWORD		(*m_pfnClusterCloseEnum) (HCLUSENUM);
	DWORD		(*m_pfnWrapClusterEnum) (HCLUSENUM,DWORD,LPDWORD,LPWSTR*);
};


#endif // __MODCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\modcmd.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    modcmd.cpp

Abstract:

    Generic commands for nearly all modules


Author:

    Michael Burton (t-mburt)            25-Aug-1997


Revision History:


--*/


#include "modcmd.h"



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::CGenericModuleCmd
//
//  Routine Description:
//      Default Constructor.
//      Initializes all the DWORD parameters to UNDEFINED and
//      all the pointers to cluster functions to NULL.
//      *ALL* these variables must be defined in any derived class.
//
//  Arguments:
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      A bunch.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericModuleCmd::CGenericModuleCmd( CCommandLine & cmdLine ) :
    m_theCommandLine( cmdLine )
{
    m_hCluster = NULL;
    m_hModule  = NULL;

    // These constant integers contain commands and enumerations
    // which must be defined for derived classes of CGenericModuleCmd
    m_dwMsgStatusList          = UNDEFINED;
    m_dwMsgStatusListAll       = UNDEFINED;
    m_dwMsgStatusHeader        = UNDEFINED;
    m_dwMsgPrivateListAll      = UNDEFINED;
    m_dwMsgPropertyListAll     = UNDEFINED;
    m_dwMsgPropertyHeaderAll   = UNDEFINED;
    m_dwCtlGetPrivProperties   = UNDEFINED;
    m_dwCtlGetCommProperties   = UNDEFINED;
    m_dwCtlGetROPrivProperties = UNDEFINED;
    m_dwCtlGetROCommProperties = UNDEFINED;
    m_dwCtlSetPrivProperties   = UNDEFINED;
    m_dwCtlSetCommProperties   = UNDEFINED;
    m_dwClusterEnumModule      = UNDEFINED;
    m_pfnOpenClusterModule     = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) NULL;
    m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  NULL;
    m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) NULL;
    m_pfnClusterOpenEnum       = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) NULL;
    m_pfnClusterCloseEnum      = (DWORD(*)(HCLUSENUM)) NULL;
    m_pfnWrapClusterEnum         = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) NULL;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::~CGenericModuleCmd
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hModule               (used by CloseModule)
//      m_hCluster              (used by CloseCluster)
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericModuleCmd::~CGenericModuleCmd()
{
    CloseModule();
    CloseCluster();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::OpenCluster
//
//  Routine Description:
//      Opens a handle to the cluster
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_strClusterName            The name of the cluster
//      m_hCluster                  The handle to the cluster
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::OpenCluster()
{
    if( m_hCluster )
        return ERROR_SUCCESS;

    m_hCluster = ::OpenCluster( m_strClusterName );

    if( !m_hCluster )
        return GetLastError();

    return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::CloseCluster
//
//  Routine Description:
//      Closes the handle to the cluster
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster                  The handle to the cluster
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericModuleCmd::CloseCluster()
{
    if( m_hCluster )
    {
        ::CloseCluster( m_hCluster );
        m_hCluster = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::OpenModule
//
//  Routine Description:
//      Opens a handle to the module
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_strModuleName             The name of the module
//      m_hModule                   The handle to the module
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::OpenModule()
{
    assert(m_pfnOpenClusterModule);

    if (!m_strModuleName )
        return ERROR_INVALID_PARAMETER;

    m_hModule = m_pfnOpenClusterModule( m_hCluster, m_strModuleName );

    if( !m_hModule )
        return GetLastError();

    return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::CloseModule
//
//  Routine Description:
//      Closes the handle to the module
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hModule                   The handle to the module
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericModuleCmd::CloseModule()
{
    if( m_hModule )
    {
        assert(m_pfnCloseClusterModule);
        m_pfnCloseClusterModule( m_hModule );
        m_hModule = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::Execute
//
//  Routine Description:
//      Takes a command line option and determines which command to
//      execute.  If no command line option specified, gets the next one
//      automatically.  If the token is not identied as being handle-able
//      in this class, the token is passed up to CGenericModuleCmd::Execute
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::Execute( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // Look up the command
    switch( thisOption.GetType() )
    {
        case optHelp:
            return PrintHelp();

        case optProperties:
            return DoProperties( thisOption, COMMON );

        case optPrivateProperties:
            return DoProperties( thisOption, PRIVATE );

        case optStatus:
            return Status( &thisOption );

        default:
        {
            CSyntaxException se;
            se.LoadMessage( IDS_INVALID_OPTION, thisOption.GetName() );
            throw se;

            // Needed only to prevent compiler error.
            // error C2202: not all control paths return a value
            return E_UNEXPECTED;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::PrintHelp
//
//  Routine Description:
//      Prints out the generic help message for the cluster.exe tool
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintMessage
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::PrintHelp()
{
    return PrintMessage( MSG_HELP_CLUSTER );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::Status
//
//  Routine Description:
//      Prints out the status of the module.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strModuleName             Name of module.  If non-NULL, Status() prints
//                                  out the status of the specified module.
//                                  Otherwise, prints status of all modules.
//      m_dwMsgStatusList           Field titles for listing status of module
//      m_dwMsgStatusHeader         Header for statuses
//      m_dwClusterEnumModule       Command for opening enumeration
//      m_dwMsgStatusListAll        Message for listing status of multiple modules
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::Status( const CCmdLineOption * pOption )
    throw( CSyntaxException )
{
    DWORD dwError = ERROR_SUCCESS;

    // pOption will be NULL if this function has been called as the
    // default action.
    if ( pOption != NULL )
    {
        // This option takes no values.
        if ( pOption->GetValues().size() != 0 )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_OPTION_NO_VALUES, pOption->GetName() );
            throw se;
        }

        // This option takes no parameters.
        if ( pOption->GetParameters().size() != 0 )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, pOption->GetName() );
            throw se;
        }
    }

    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    // if m_strModuleName is non-empty, print out the status
    // of the current module and return.
    if( m_strModuleName.IsEmpty() == FALSE )
    {
        assert( m_dwMsgStatusList != UNDEFINED &&  m_dwMsgStatusHeader != UNDEFINED);
        PrintMessage( m_dwMsgStatusList, (LPCTSTR) m_strModuleName );
        PrintMessage( m_dwMsgStatusHeader );
        return PrintStatus( m_strModuleName );
    }


    // Otherwise, print out the status of all modules.

    assert( m_dwClusterEnumModule != UNDEFINED );
    HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, m_dwClusterEnumModule );

    if( !hEnum )
        return GetLastError();

    assert( m_dwMsgStatusListAll != UNDEFINED &&  m_dwMsgStatusHeader != UNDEFINED);
    PrintMessage( m_dwMsgStatusListAll );
    PrintMessage( m_dwMsgStatusHeader );

    DWORD dwIndex = 0;
    DWORD dwType = 0;
    LPWSTR lpszName = NULL;

    dwError = ERROR_SUCCESS;

    for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
    {

        dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

        if( dwError == ERROR_SUCCESS )
        {
            dwError = PrintStatus( lpszName );
            if (dwError != ERROR_SUCCESS)
                PrintSystemError(dwError);
        }


        if( lpszName )
            LocalFree( lpszName );
    }


    if( dwError == ERROR_NO_MORE_ITEMS )
        dwError = ERROR_SUCCESS;

    ClusterCloseEnum( hEnum );

    return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::DoProperties
//
//  Routine Description:
//      Dispatches the property command to either Get or Set properties
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of module.  If non-NULL, prints
//                                  out properties for the specified module.
//                                  Otherwise, prints props for all modules.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::DoProperties( const CCmdLineOption & thisOption,
                                       PropertyType ePropertyType )
    throw( CSyntaxException )
{
    // If no module name was specified, assume we want
    // to list the properties for all modules of this type
    if ( m_strModuleName.IsEmpty() != FALSE )
        return AllProperties( thisOption, ePropertyType );

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

    // If there are no property-value pairs on the command line,
    // then we print the properties otherwise we set them.
    if( paramList.size() == 0 )
    {
        PrintMessage( ePropertyType==PRIVATE ? MSG_PRIVATE_LISTING : MSG_PROPERTY_LISTING,
            (LPCTSTR) m_strModuleName );
        PrintMessage( m_dwMsgPropertyHeaderAll );

        return GetProperties( thisOption, ePropertyType, m_strModuleName );
    }
    else
    {
        return SetProperties( thisOption, ePropertyType );
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::AllProperties
//
//  Routine Description:
//      Prints out properties for all modules
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strModuleName             Name of module.  If non-NULL, prints
//                                  out properties for the specified module.
//                                  Otherwise, prints props for all modules.
//      m_dwClusterEnumModule       Command for opening enumeration
//      m_dwMsgPrivateListAll       Fields header for private prop listing of all modules
//      m_dwMsgPropertyListAll      Fields header for property listing of all modules
//      m_dwMsgPropertyHeaderAll    Header for prop listing of all modules
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::AllProperties( const CCmdLineOption & thisOption,
                                        PropertyType ePropType )
    throw( CSyntaxException )
{
    DWORD dwError;
    DWORD dwIndex;
    DWORD dwType;
    LPWSTR lpszName;

    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Enumerate the resources
    assert( m_dwClusterEnumModule != UNDEFINED );
    HCLUSENUM hEnum = ClusterOpenEnum(m_hCluster, m_dwClusterEnumModule);
    if (!hEnum)
        return GetLastError();

    assert( m_dwMsgPrivateListAll != UNDEFINED &&
            m_dwMsgPropertyListAll != UNDEFINED &&
            m_dwMsgPropertyHeaderAll != UNDEFINED );

    // Print the header
    PrintMessage( ePropType==PRIVATE ? m_dwMsgPrivateListAll : m_dwMsgPropertyListAll );
    PrintMessage( m_dwMsgPropertyHeaderAll );

    // Print out status for all resources
    dwError = ERROR_SUCCESS;
    for (dwIndex=0; dwError != ERROR_NO_MORE_ITEMS; dwIndex++)
    {
        dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

        if( dwError == ERROR_SUCCESS )
        {
            dwError = GetProperties( thisOption, ePropType, lpszName );
            if (dwError != ERROR_SUCCESS)
                PrintSystemError(dwError);
        }

        if( lpszName )
            LocalFree( lpszName );
    }


    ClusterCloseEnum( hEnum );

    return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::GetProperties
//
//  Routine Description:
//      Prints out properties for the specified module
//
//  Arguments:
//      IN  const vector<CCmdLineParameter> & paramList
//          Contains the list of property-value pairs to be set
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//      IN  LPCWSTR lpszModuleName
//          Name of the module
//
//  Member variables used / set:
//      m_hModule                   Module handle
//      m_dwCtlGetROPrivProperties  Control code for read only private properties
//      m_dwCtlGetROCommProperties  Control code for read only common properties
//      m_dwCtlGetPrivProperties    Control code for private properties
//      m_dwCtlGetCommProperties    Control code for common properties
//      m_pfnOpenClusterModule      Function to open a module
//      m_pfnClusterModuleControl   Function to conrol a module
//
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::GetProperties( const CCmdLineOption & thisOption,
                                        PropertyType ePropType, LPCWSTR lpszModuleName )
{
    DWORD dwError = ERROR_SUCCESS;
    HCLUSMODULE hModule;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // If no lpszModuleName specified, use current module,
    // otherwise open the specified module
    if (!lpszModuleName)
    {
        hModule = m_hModule;
    }
    else
    {
        assert(m_pfnOpenClusterModule);
        hModule = m_pfnOpenClusterModule( m_hCluster, lpszModuleName );
        if( !hModule )
            return GetLastError();
    }


    // Use the proplist helper class.
    CClusPropList PropList;

    // allocate a reasonably sized buffer
    dwError = PropList.ScAllocPropList( DEFAULT_PROPLIST_BUFFER_SIZE );
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    DWORD nBytesReturned = 0;

    // Get R/O properties
    assert( m_dwCtlGetROPrivProperties != UNDEFINED && m_dwCtlGetROCommProperties != UNDEFINED );
    DWORD dwControlCode = ePropType==PRIVATE ? m_dwCtlGetROPrivProperties
                             : m_dwCtlGetROCommProperties;

    assert(m_pfnClusterModuleControl);
    dwError = m_pfnClusterModuleControl(
        hModule,
        NULL, // hNode
        dwControlCode,
        0, // &InBuffer,
        0, // nInBufferSize,
        PropList.Plist(),
        PropList.CbBufferSize(),
        &nBytesReturned );

    if(  dwError == ERROR_MORE_DATA ) {

        // our original size is not large enough; ask for more
        dwError = PropList.ScAllocPropList( nBytesReturned );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = m_pfnClusterModuleControl(
                      hModule,
                      NULL, // hNode
                      dwControlCode,
                      0, // &InBuffer,
                      0, // nInBufferSize,
                      PropList.Plist(),
                      PropList.CbBufferSize(),
                      &nBytesReturned );
    }

    if ( dwError != ERROR_SUCCESS ) {
        return dwError;
    }

    PropList.InitSize( nBytesReturned );
    dwError = ::PrintProperties( PropList, thisOption.GetValues(), READONLY, lpszModuleName );
    if (dwError != ERROR_SUCCESS)
        return dwError;


    // Get R/W properties
    PropList.ClearPropList();

    assert( m_dwCtlGetPrivProperties != UNDEFINED && m_dwCtlGetCommProperties != UNDEFINED );
    dwControlCode = ePropType==PRIVATE ? m_dwCtlGetPrivProperties
                               : m_dwCtlGetCommProperties;

    dwError = m_pfnClusterModuleControl(
        hModule,
        NULL, // hNode
        dwControlCode,
        0, // &InBuffer,
        0, // nInBufferSize,
        PropList.Plist(),
        PropList.CbBufferSize(),
        &nBytesReturned );

    if( dwError == ERROR_MORE_DATA ) {

        dwError = PropList.ScAllocPropList( nBytesReturned );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = m_pfnClusterModuleControl(
                      hModule,
                      NULL, // hNode
                      dwControlCode,
                      0, // &InBuffer,
                      0, // nInBufferSize,
                      PropList.Plist(),
                      PropList.CbBufferSize(),
                      &nBytesReturned );
    }

    if( dwError != ERROR_SUCCESS ) {
        return dwError;
    }

    PropList.InitSize( nBytesReturned );
    dwError = ::PrintProperties( PropList, thisOption.GetValues(), READWRITE, lpszModuleName );

    return dwError;

} //*** CGenericModuleCmd::GetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::SetProperties
//
//  Routine Description:
//      Set the properties for the specified module
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hModule                   Module handle
//      m_dwCtlGetPrivProperties    Control code for private properties
//      m_dwCtlGetCommProperties    Control code for common properties
//      m_dwCtlSetROPrivProperties  Control code for read only private properties
//      m_dwCtlSetROCommProperties  Control code for read only common properties
//      m_dwCtlSetPrivProperties    Control code for private properties
//      m_dwCtlSetCommProperties    Control code for common properties
//      m_pfnOpenClusterModule      Function to open a module
//      m_pfnClusterModuleControl   Function to conrol a module
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::SetProperties( const CCmdLineOption & thisOption,
                                        PropertyType ePropType )
    throw( CSyntaxException )
{
    assert (m_hModule);

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwControlCode;
    DWORD dwBytesReturned = 0;

    CClusPropList NewProps;
    CClusPropList CurrentProps;

    // First get the existing properties...
    assert( m_dwCtlGetPrivProperties != UNDEFINED && m_dwCtlGetCommProperties != UNDEFINED );
    dwControlCode = ePropType==PRIVATE ? m_dwCtlGetPrivProperties
                                       : m_dwCtlGetCommProperties;

    // Use the proplist helper class.
    dwError = CurrentProps.ScAllocPropList( DEFAULT_PROPLIST_BUFFER_SIZE );
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    assert(m_pfnClusterModuleControl);
    dwError = m_pfnClusterModuleControl(
        m_hModule,
        NULL, // hNode
        dwControlCode,
        0, // &InBuffer,
        0, // nInBufferSize,
        CurrentProps.Plist(),
        CurrentProps.CbBufferSize(),
        &dwBytesReturned );

    if ( dwError == ERROR_MORE_DATA ) {
        dwError = CurrentProps.ScAllocPropList( dwBytesReturned );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = m_pfnClusterModuleControl(
                      m_hModule,
                      NULL, // hNode
                      dwControlCode,
                      0, // &InBuffer,
                      0, // nInBufferSize,
                      CurrentProps.Plist(),
                      CurrentProps.CbBufferSize(),
                      &dwBytesReturned );
    } 

    if ( dwError != ERROR_SUCCESS ) {
        return dwError;
    }

    CurrentProps.InitSize( dwBytesReturned );

    // If values have been specified with this option, then it means that we want
    // to set these properties to their default values. So, there has to be
    // exactly one parameter and it has to be /USEDEFAULT.
    if ( thisOption.GetValues().size() != 0 )
    {
        const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

        if ( paramList.size() != 1 )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR, thisOption.GetName() );
            throw se;
        }

        if ( paramList[0].GetType() != paramUseDefault )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_INVALID_PARAMETER, paramList[0].GetName() );
            throw se;
        }

        // This parameter does not take any values.
        if ( paramList[0].GetValues().size() != 0 )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_PARAM_NO_VALUES, paramList[0].GetName() );
            throw se;
        }

        dwError = ConstructPropListWithDefaultValues( CurrentProps, NewProps, thisOption.GetValues() );
        if( dwError != ERROR_SUCCESS )
            return dwError;

    } // if: values have been specified with this option.
    else
    {
        dwError = NewProps.ScAllocPropList( DEFAULT_PROPLIST_BUFFER_SIZE );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = ConstructPropertyList( CurrentProps, NewProps, thisOption.GetParameters() );
        if (dwError != ERROR_SUCCESS)
            return dwError;

    } // else: no values have been specified with this option.

    // Call the set function...
    assert( m_dwCtlSetPrivProperties != UNDEFINED && m_dwCtlSetCommProperties != UNDEFINED );
    dwControlCode = ePropType==PRIVATE ? m_dwCtlSetPrivProperties
                             : m_dwCtlSetCommProperties;

    dwBytesReturned = 0;
    assert(m_pfnClusterModuleControl);
    dwError = m_pfnClusterModuleControl(
        m_hModule,
        NULL, // hNode
        dwControlCode,
        NewProps.Plist(),
        NewProps.CbBufferSize(),
        0,
        0,
        &dwBytesReturned );

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\netcmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	netcmd.h

Abstract:

	Interface for functions which may be performed
	on a network object

Revision History:

--*/

#ifndef __NETCMD_H__
#define __NETCMD_H__

#include "intrfc.h"
#include "rename.h"


class CCommandLine;

class CNetworkCmd : public CHasInterfaceModuleCmd,
					public CRenamableModuleCmd
{
public:
	CNetworkCmd( LPCWSTR lpszClusterName, CCommandLine & cmdLine );
	DWORD Execute();

protected:

	DWORD PrintHelp();
	DWORD PrintStatus( LPCWSTR lpszNetworkName );

};



#endif //__NETCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\cmdline.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  Module Name:
//      CmdLine.h
//
//  Abstract:
//      Definition of the CCommandLine and related class.
//
//  Implementation File:
//      CmdLine.cpp
//
//  Author:
//      Vijayendra Vasu (vvasu) October 20, 1998
//
//  Revision History:
//      001. The class CCommandLine has been drastically changed from the previous
//      version. Previously, the function GetNextOption was being used to get the
//      next token from the command line and parsing was done by each of the command
//      handling classes (like CResourceCmd). Now GetNextOption gets the next option
//      along with all the parameters to the option. No parsing need be done by the
//      command handling classes.
//
//  Examples: 
//      cluster res "Cluster IP Address" /status
//      Here, the option "status" has no parameters and no values
//
//      cluster res /node:vvasu-node-1
//      Here, the option "node" has one value "vvasu-node-1". This value
//      is separated from the name of the option by a ":" 
//
//      cluster res "Cluster IP Address" /priv Network="Corporate Address" EnableNetBIOS=1
//      Here, the /priv option has two paramters, "Network" and "EnableNetBIOS"
//      The parameters are separated from each other by white spaces.
//      Each of these parameters take a value. The value is separated from
//      the parameter by a '='. If a parameter takes multiple values, these
//      values are separated from each other by ','.
//
//      cluster group myGroup /moveto:myNode /wait:10
//      In the previous example "Network" and "EnableNetBIOS" were unknown parameters.
//      Known parameters, such as "wait" are preceded by a '/' and separated from their
//      values by a ':'. They look like options, but they are actually treated as
//      parameters to the previous option.
//
//      The separator characters mentioned in the examples above are not 
//      hard coded.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CMDLINE_H__
#define __CMDLINE_H__

/////////////////////////////////////////////////////////////////////////////
//  Include files
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include <vector>

using namespace std;


/////////////////////////////////////////////////////////////////////////////
//  External variable declarations
/////////////////////////////////////////////////////////////////////////////
extern const WORD ValueFormatToClusPropFormat[];


/////////////////////////////////////////////////////////////////////////////
//  Enumerations and type definitions
/////////////////////////////////////////////////////////////////////////////

// Types of objects that can be administered using cluster.exe
enum ObjectType
{
    objInvalid,
    objCluster,
    objNode,
    objGroup,
    objResource,
    objResourceType,
    objNetwork,
    objNetInterface
};


// Options that are available for each of the above object types
enum OptionType
{
    optInvalid,
    optDefault,

    //   Common options
    optCluster,
    optCreate,
    optDelete,
    optHelp,
    optMove,
    optList,
    optListOwners,
    optOnline,
    optOffline,
    optProperties,
    optPrivateProperties,
    optRename,
    optStatus,

    // Cluster options
    optQuorumResource,
    optVersion,
    optSetFailureActions,
    optRegisterAdminExtensions,
    optUnregisterAdminExtensions,
    optAddNodes,

    // Node options
    optPause,
    optResume,
    optEvict,
    optForceCleanup,
    optStartService,
    optStopService,

    // Group options
    optSetOwners,

    // Resource options
    optAddCheckPoints,
    optAddCryptoCheckPoints,
    optAddDependency,
    optAddOwner,
    optFail,
    optGetCheckPoints,
    optGetCryptoCheckPoints,
    optListDependencies,
    optRemoveDependency,
    optRemoveOwner,
    optRemoveCheckPoints,
    optRemoveCryptoCheckPoints,

    // Network options
    optListInterfaces
};


// Parameters that can be passed with each of the above options
enum ParameterType
{
    paramUnknown,
    paramCluster,
    paramDisplayName,
    paramDLLName,
    paramGroupName,
    paramIsAlive,
    paramLooksAlive,
    paramMaxLogSize,
    paramNetworkName,
    paramNodeName,
    paramPath,
    paramResType,
    paramSeparate,
    paramUseDefault,
    paramWait,
    paramUser,
    paramPassword,
    paramIPAddress,
    paramVerbose,
    paramWizard
};


// Format of the values that can be passed to parameters
enum ValueFormat
{
    vfInvalid = -2,
    vfUnspecified = -1,
    vfBinary = 0,
    vfDWord,
    vfSZ,
    vfExpandSZ,
    vfMultiSZ,
    vfULargeInt,
    vfSecurity
};


// The types of token retrieved during parsing.
enum TypeOfToken
{
    ttInvalid,
    ttEndOfInput,
    ttNormal,
    ttOption,
    ttOptionValueSep,
    ttParamValueSep,
    ttValueSep
};


/////////////////////////////////////////////////////////////////////////////
//  Forward declaration
/////////////////////////////////////////////////////////////////////////////
class CParseException;


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CParseState
//
//  Purpose:
//      Stores the current state of the parsing of the command line
//
/////////////////////////////////////////////////////////////////////////////
class CParseState
{
private:
    // If the next token has already been previewed, m_bNextTokenReady is set
    // to TRUE. The token and its type are cached.
    BOOL m_bNextTokenReady;             // Has the next token been viewed already?
    TypeOfToken m_ttNextTokenType;      // The type of the cached token
    CString m_strNextToken;             // The cached token

    void ReadToken( CString & strToken );

public:

    const LPCTSTR m_pszCommandLine;     // The original command line
    LPCTSTR m_pszCurrentPosition;       // The position for parsing the next token

    CParseState( LPCTSTR pszCmdLine );
    CParseState( const CParseState & ps );
    ~CParseState();

    const CParseState & operator=( const CParseState & ps );

    TypeOfToken PreviewNextToken( CString & strNextToken ) throw( CParseException );
    TypeOfToken GetNextToken( CString & strNextToken ) throw( CParseException );

    void ReadQuotedToken( CString & strToken ) throw( CParseException );
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CException
//
//  Purpose:
//      Exception base class.
//
/////////////////////////////////////////////////////////////////////////////
class CException
{
public:

    // Default constructor.
    CException( void ) {}

    // Copy constructor
    CException( const CException & srcException ) 
        : m_strErrorMsg( srcException.m_strErrorMsg ) {}

    // Destructor
    virtual ~CException( void ) { }
    
    DWORD LoadMessage( DWORD dwMessage, ... );

    CString m_strErrorMsg;
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CParseException
//
//  Purpose:
//      This is the exception that is thrown if there is a parsing error.
//
/////////////////////////////////////////////////////////////////////////////
class CParseException : public CException
{
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CSyntaxException
//
//  Purpose:
//      This exception is thrown if there is a syntax error.
//
/////////////////////////////////////////////////////////////////////////////
class CSyntaxException : public CException
{
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CParser
//
//  Purpose:
//      The base class of all classes capable of parsing the command line
//
/////////////////////////////////////////////////////////////////////////////
class CParser
{
protected:
    virtual void ParseValues( CParseState & parseState, vector<CString> & vstrValues );

public:
    CParser()
    {
    }

    virtual ~CParser()
    {
    }

    virtual void Parse( CParseState & parseState ) throw( CParseException ) = 0;
    virtual void Reset() = 0;
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CCmdLineParameter
//
//  Purpose:
//      Parses and stores one command line parameter
//
/////////////////////////////////////////////////////////////////////////////
class CCmdLineParameter : public CParser
{
private:
    CString m_strParamName;
    ParameterType m_paramType;
    ValueFormat m_valueFormat;
    CString m_strValueFormatName;
    vector<CString> m_vstrValues;

public:
    CCmdLineParameter();
    ~CCmdLineParameter();

    ParameterType GetType() const;
    ValueFormat GetValueFormat() const;
    const CString & GetValueFormatName() const;
    const CString & GetName() const;
    const vector<CString> & GetValues() const;
    void GetValuesMultisz( CString &strReturnValue ) const;

    BOOL ReadKnownParameter( CParseState & parseState ) throw( CParseException );
    void Parse( CParseState & parseState ) throw( CParseException );
    void Reset();
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CCmdLineOption
//
//  Purpose:
//      Parses and stores one command line option and all its parameters
//
/////////////////////////////////////////////////////////////////////////////
class CCmdLineOption : public CParser
{
private:
    OptionType m_optionType;
    CString m_strOptionName;
    vector<CString> m_vstrValues;
    vector<CCmdLineParameter> m_vparParameters;

public:
    CCmdLineOption();
    ~CCmdLineOption();

    OptionType GetType() const;
    const CString & GetName() const;
    const vector<CString> & GetValues() const;
    const vector<CCmdLineParameter> & GetParameters() const;

    void Parse( CParseState & parseState ) throw( CParseException );
    void Reset();
};


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CCommandLine
//
//  Purpose:
//      Handles all the parsing of the entire command line
//
/////////////////////////////////////////////////////////////////////////////
class CCommandLine : public CParser
{
private:
    CString m_strClusterName;
    CString m_strObjectName;
    ObjectType m_objectType;
    vector<CCmdLineOption> m_voptOptionList;
    CParseState m_parseState;

public:
    CCommandLine( const CString & strCommandLine );
    ~CCommandLine();

    const CString & GetClusterName() const;
    ObjectType GetObjectType() const;
    const CString & GetObjectName() const;
    const vector<CCmdLineOption> & GetOptions() const;

    void ParseStageOne() throw( CParseException, CSyntaxException );
    void ParseStageTwo() throw( CParseException, CSyntaxException );
    void Parse( CParseState & parseState ) throw( CParseException, CSyntaxException );
    void Reset();
};

#endif // __CMDLINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\netcmd.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

	netcmd.cpp

Abstract:

	Network Commands
	Implements commands which may be performed on networks

Author:

	Charles Stacy Harris III (stacyh)	20-March-1997
	Michael Burton (t-mburt)			04-Aug-1997


Revision History:


--*/



#include "precomp.h"

#include "cluswrap.h"
#include "netcmd.h"

#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::CNetworkCmd
//
//	Routine Description:
//		Constructor
//		Initializes all the DWORD params used by CGenericModuleCmd and
//		CHasInterfaceModuleCmd to provide generic functionality.
//
//	Arguments:
//		IN	LPCWSTR lpszClusterName 			
//			Cluster name. If NULL, opens default cluster.
//
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkCmd::CNetworkCmd( LPCWSTR lpszClusterName, CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine ), CHasInterfaceModuleCmd( cmdLine ), 
	CRenamableModuleCmd( cmdLine )
{
	m_strClusterName = lpszClusterName;
	m_strModuleName.Empty();

	m_hCluster = NULL;
	m_hModule  = NULL;

	m_dwMsgStatusList		   = MSG_NETWORK_STATUS_LIST;
	m_dwMsgStatusListAll	   = MSG_NETWORK_STATUS_LIST_ALL;
	m_dwMsgStatusHeader 	   = MSG_NETWORK_STATUS_HEADER;
	m_dwMsgPrivateListAll	   = MSG_PRIVATE_LISTING_NETWORK_ALL;
	m_dwMsgPropertyListAll	   = MSG_PROPERTY_LISTING_NETWORK_ALL;
	m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_NETWORK_ALL;
	m_dwCtlGetPrivProperties   = CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES;
	m_dwCtlGetCommProperties   = CLUSCTL_NETWORK_GET_COMMON_PROPERTIES;
	m_dwCtlGetROPrivProperties = CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES;
	m_dwCtlGetROCommProperties = CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES;
	m_dwCtlSetPrivProperties   = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;
	m_dwCtlSetCommProperties   = CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;
	m_dwClusterEnumModule	   = CLUSTER_ENUM_NETWORK;
	m_pfnOpenClusterModule	   = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterNetwork;
	m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterNetwork;
	m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterNetworkControl;

	// ListInterface Parameters
	m_dwMsgStatusListInterface	 = MSG_NET_LIST_INTERFACE;
	m_dwClusterEnumModuleNetInt  = CLUSTER_NETWORK_ENUM_NETINTERFACES;
	m_pfnClusterOpenEnum		 = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterNetworkOpenEnum;
	m_pfnClusterCloseEnum		 = (DWORD(*)(HCLUSENUM)) ClusterNetworkCloseEnum;
	m_pfnWrapClusterEnum		 = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterNetworkEnum;

	// Renamable Properties
	m_dwMsgModuleRenameCmd	  = MSG_NETWORKCMD_RENAME;
	m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) SetClusterNetworkName;

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::Execute
//
//	Routine Description:
//		Gets the next command line parameter and calls the appropriate
//		handler.  If the command is not recognized, calls Execute of
//		parent classes (first CRenamableModuleCmd, then CHasInterfaceModuleCmd)
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::Execute()
{
	try
	{
		m_theCommandLine.ParseStageTwo();
	}
	catch( CException & e )
	{
		PrintString( e.m_strErrorMsg );
		return PrintHelp();
	}

	DWORD dwReturnValue = ERROR_SUCCESS;

	const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

	vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
	vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

	if ( curOption == lastOption )
		return Status( NULL );

	try
	{
		BOOL bContinue = TRUE;

		do
		{
			switch ( curOption->GetType() )
			{
				case optHelp:
				{
					// If help is one of the options, process no more options.
					dwReturnValue = PrintHelp();
					bContinue = FALSE;
					break;
				}

				case optDefault:
				{
					const vector<CCmdLineParameter> & paramList = curOption->GetParameters();

					if ( ( paramList.size() != 1 ) ||
						 ( paramList[0].GetType() != paramUnknown ) )
					{
						dwReturnValue = PrintHelp();
						bContinue = FALSE;

					} // if: this option has the wrong number of values or parameters
					else
					{
						const CCmdLineParameter & param = paramList[0];

						// This parameter takes no values.
						if ( param.GetValues().size() != 0 )
						{
							CSyntaxException se; 
							se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
							throw se;
						}

						m_strModuleName = param.GetName();

						// No more options are provided, just show status.
						// For example: cluster myCluster node myNode
						if ( ( curOption + 1 ) == lastOption )
						{
							dwReturnValue = Status( NULL );
						}

					} // else: this option has the right number of values and parameters

					break;

				} // case optDefault

				default:
				{
					dwReturnValue = CRenamableModuleCmd::Execute( *curOption, DONT_PASS_HIGHER );

					if (dwReturnValue == ERROR_NOT_HANDLED)
						dwReturnValue = CHasInterfaceModuleCmd::Execute( *curOption );
				}

			} // switch: based on the type of option

			if ( ( bContinue == FALSE ) || ( dwReturnValue != ERROR_SUCCESS ) )
				break;
			else
				++curOption;

			if ( curOption != lastOption )
				PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
			else
				break;
		}
		while ( TRUE );

	}
	catch ( CSyntaxException & se )
	{
		PrintString( se.m_strErrorMsg );
		dwReturnValue = PrintHelp();
	}

	return dwReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::PrintHelp
//
//	Routine Description:
//		Prints help for Networks
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::PrintHelp()
{
	return PrintMessage( MSG_HELP_NETWORK );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::PrintStatus
//
//	Routine Description:
//		Interprets the status of the module and prints out the status line
//		Required for any derived non-abstract class of CGenericModuleCmd
//
//	Arguments:
//		lpszNetworkName 			Name of the module
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::PrintStatus( LPCWSTR lpszNetworkName )
{
	DWORD dwError = ERROR_SUCCESS;

	CLUSTER_NETWORK_STATE nState;

	HNETWORK hNetwork = OpenClusterNetwork(m_hCluster, lpszNetworkName);
	if (!hNetwork)
		return GetLastError();

	nState = GetClusterNetworkState( hNetwork );

	if( nState == ClusterNetworkStateUnknown )
		return GetLastError();

	LPWSTR lpszStatus = NULL;

	switch( nState )
	{
		case ClusterNetworkUnavailable:
			LoadMessage( MSG_STATUS_UNAVAILABLE, &lpszStatus );
			break;

		case ClusterNetworkDown:
			LoadMessage( MSG_STATUS_DOWN, &lpszStatus );
			break;

		case ClusterNetworkPartitioned:
			LoadMessage( MSG_STATUS_PARTITIONED, &lpszStatus );
			break;

		case ClusterNetworkUp:
			LoadMessage( MSG_STATUS_UP, &lpszStatus );
			break;

		case ClusterNetworkStateUnknown:
		default:
			LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
	}

	dwError = PrintMessage( MSG_NETWORK_STATUS, lpszNetworkName, lpszStatus );

	// Since Load/FormatMessage uses LocalAlloc...
	if( lpszStatus )
		LocalFree( lpszStatus );

	CloseClusterNetwork(hNetwork);

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\neticmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	neticmd.h

Abstract:

	Interface for functions which may be performed
	on a network interface object

Revision History:

--*/

#ifndef __NETINTCMD_H__
#define __NETINTCMD_H__

#include "modcmd.h"

class CCommandLine;

class CNetInterfaceCmd : public CGenericModuleCmd
{
public:
	CNetInterfaceCmd( const CString & strClusterName, CCommandLine & cmdLine );
	~CNetInterfaceCmd();

	// Parse and execute the command line
	DWORD Execute();

protected:
	CString m_strNodeName;
	CString m_strNetworkName;
	
	// Specific Commands
	DWORD PrintHelp();

	DWORD Status( const CCmdLineOption * pOption )
		throw( CSyntaxException );

	DWORD DoProperties( const CCmdLineOption & thisOption,
						PropertyType ePropertyType )
		throw( CSyntaxException );

	DWORD PrintStatus ( LPCWSTR lpszNetInterfaceName );
	DWORD PrintStatus( HNETINTERFACE hNetInterface, LPCWSTR lpszNodeName, LPCWSTR lpszNetworkName);

	DWORD GetProperties( const CCmdLineOption & thisOption,
						 PropertyType ePropType, LPWSTR lpszNetIntName = NULL );

	DWORD AllProperties( const CCmdLineOption & thisOption,
						 PropertyType ePropType ) 
		throw( CSyntaxException );

	void   InitializeModuleControls();
	DWORD  SetNetInterfaceName();

	LPWSTR GetNodeName(LPCWSTR lpszNetInterfaceName);
	LPWSTR GetNetworkName(LPCWSTR lpszNetInterfaceName);
};

#endif //__NETINTCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\nodecmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      NodeCmd.h
//
//  Description:
//      Node commands.
//      Implements commands which may be performed on network nodes.
//
//  Maintained By:
//      David Potter (davidp)               20-NOV-2000
//      Michael Burton (t-mburt)            04-Aug-1997
//      Charles Stacy Harris III (stacyh)   20-March-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include <stdio.h>
#include <clusudef.h>
#include <clusrtl.h>

#include "cluswrap.h"
#include "nodecmd.h"

#include "token.h"
#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::CNodeCmd
//
//  Routine Description:
//      Constructor
//      Initializes all the DWORD params used by CGenericModuleCmd and
//      CHasInterfaceModuleCmd to provide generic functionality.
//
//  Arguments:
//      IN  LPCWSTR lpszClusterName
//          Cluster name. If NULL, opens default cluster.
//
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodeCmd::CNodeCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine ), CHasInterfaceModuleCmd( cmdLine )
{
    m_strModuleName.Empty();
    m_strClusterName = strClusterName;

    m_hCluster = 0;
    m_hModule = 0;

    // Generic Parameters
    m_dwMsgStatusList          = MSG_NODE_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_NODE_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_NODE_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_NODE_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_NODE_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_NODE_ALL;
    m_dwCtlGetPrivProperties   = CLUSCTL_NODE_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_NODE_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_NODE_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_NODE;
    m_pfnOpenClusterModule      = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterNode;
    m_pfnCloseClusterModule     = (BOOL(*)(HCLUSMODULE))  CloseClusterNode;
    m_pfnClusterModuleControl   = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterNodeControl;

    // ListInterface Parameters
    m_dwMsgStatusListInterface   = MSG_NODE_LIST_INTERFACE;
    m_dwClusterEnumModuleNetInt  = CLUSTER_ENUM_NODE;
    m_pfnClusterOpenEnum         = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterNodeOpenEnum;
    m_pfnClusterCloseEnum        = (DWORD(*)(HCLUSENUM)) ClusterNodeCloseEnum;
    m_pfnWrapClusterEnum         = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterNodeEnum;

} //*** CNodeCmd::CNodeCmd()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent classes (first CRenamableModuleCmd, then CHasInterfaceModuleCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::Execute( void )
{
    DWORD   sc          = ERROR_SUCCESS;
    BOOL    fContinue   = TRUE;

    try
    {
        m_theCommandLine.ParseStageTwo();
    }
    catch( CException & e )
    {
        PrintString( e.m_strErrorMsg );
        sc = PrintHelp();
        goto Cleanup;
    }

    const vector< CCmdLineOption > & rvcoOptionList = m_theCommandLine.GetOptions();

    vector< CCmdLineOption >::const_iterator itCurOption  = rvcoOptionList.begin();
    vector< CCmdLineOption >::const_iterator itLastOption = rvcoOptionList.end();

    if ( itCurOption == itLastOption )
    {
        sc = Status( NULL );
        goto Cleanup;
    }

    try
    {
        // Process one option after another.
        do
        {
            // Look up the command
            switch ( itCurOption->GetType() )
            {
                case optHelp:
                {
                    // If help is one of the options, process no more options.
                    sc = PrintHelp();
                    fContinue = FALSE;
                    break;
                }

                case optPause:
                {
                    sc = PauseNode( *itCurOption );
                    break;
                }

                case optResume:
                {
                    sc = ResumeNode( *itCurOption );
                    break;
                }

                case optEvict:
                {
                    sc = EvictNode( *itCurOption );
                    break;
                }

                case optForceCleanup:
                {
                    sc = ForceCleanup( *itCurOption );
                    break;
                }

                case optStartService:
                {
                    sc = StartService( *itCurOption );
                    break;
                }

                case optStopService:
                {
                    sc = StopService( *itCurOption );
                    break;
                }

                case optDefault:
                {
                    const vector< CCmdLineParameter > & rvclpParamList = itCurOption->GetParameters();

                    if (    ( rvclpParamList.size() != 1 )
                        ||  ( rvclpParamList[ 0 ].GetType() != paramUnknown )
                        )
                    {
                        sc = PrintHelp();
                        fContinue = FALSE;

                    } // if: this option has the wrong number of values or parameters
                    else
                    {
                        const CCmdLineParameter & rclpParam = rvclpParamList[ 0 ];

                        // This parameter takes no values.
                        if ( rclpParam.GetValues().size() != 0 )
                        {
                            CSyntaxException se;
                            se.LoadMessage( MSG_PARAM_NO_VALUES, rclpParam.GetName() );
                            throw se;
                        }

                        m_strModuleName = rclpParam.GetName();

                        // No more options are provided, just show status.
                        // For example: cluster myCluster node myNode
                        if ( ( itCurOption + 1 ) == itLastOption )
                        {
                            sc = Status( NULL );
                        }

                    } // else: this option has the right number of values and parameters

                    break;

                } // case optDefault

                default:
                {
                    sc = CHasInterfaceModuleCmd::Execute( *itCurOption );
                }

            } // switch: based on the type of option

            if ( ( fContinue == FALSE ) || ( sc != ERROR_SUCCESS ) )
            {
                goto Cleanup;
            }
            else
            {
                ++itCurOption;
            }

            if ( itCurOption != itLastOption )
            {
                PrintMessage( MSG_OPTION_FOOTER, itCurOption->GetName() );
            }
            else
            {
                goto Cleanup;
            }
        } while ( TRUE );
    } // try
    catch ( CSyntaxException & se )
    {
        PrintString( se.m_strErrorMsg );
        sc = PrintHelp();
    }

Cleanup:

    return sc;

} //*** CNodeCmd::Execute()




/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Nodes
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::PrintHelp( void )
{
    return PrintMessage( MSG_HELP_NODE );

} //*** CNodeCmd::PrintHelp()





/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszNodeName                Name of the module
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::PrintStatus( LPCWSTR lpszNodeName )
{
    DWORD   sc          = ERROR_SUCCESS;
    HNODE   hNode       = NULL;
    LPWSTR  lpszNodeId  = NULL;
    LPWSTR  lpszStatus  = NULL;

    hNode = OpenClusterNode(m_hCluster, lpszNodeName);
    if ( hNode == NULL )
    {
        goto Win32Error;
    }

    CLUSTER_NODE_STATE nState = GetClusterNodeState( hNode );

    if ( nState == ClusterNodeStateUnknown )
    {
        goto Win32Error;
    }

    sc = WrapGetClusterNodeId( hNode, &lpszNodeId );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    switch ( nState )
    {
        case ClusterNodeUp:
            LoadMessage( MSG_STATUS_UP, &lpszStatus );
            break;

        case ClusterNodeDown:
            LoadMessage( MSG_STATUS_DOWN, &lpszStatus );
            break;

        case ClusterNodePaused:
            LoadMessage( MSG_STATUS_PAUSED, &lpszStatus  );
            break;

        case ClusterNodeJoining:
            LoadMessage( MSG_STATUS_JOINING, &lpszStatus  );
            break;

        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
    } // switch: node state


    sc = PrintMessage( MSG_NODE_STATUS, lpszNodeName, lpszNodeId, lpszStatus );

    goto Cleanup;

Win32Error:

    sc = GetLastError();

Cleanup:

    // Since Load/FormatMessage uses LocalAlloc...
    LocalFree( lpszStatus );
    LocalFree( lpszNodeId );

    if ( hNode != NULL )
    {
        CloseClusterNode( hNode );
    }

    return sc;

} //*** CNodeCmd::PrintStatus()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::PauseNode
//
//  Routine Description:
//      Pauses the cluster node
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Node Name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::PauseNode( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage( MSG_NODECMD_PAUSE, (LPCTSTR) m_strModuleName );

    sc = PauseClusterNode( (HNODE) m_hModule );

    PrintMessage( MSG_NODE_STATUS_HEADER );
    PrintStatus( m_strModuleName );

Cleanup:

    return sc;

} //*** CNodeCmd::PauseNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::ResumeNode
//
//  Routine Description:
//      Resume the paused cluster node
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Node Name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::ResumeNode( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage( MSG_NODECMD_RESUME, (LPCTSTR) m_strModuleName );

    sc = ResumeClusterNode( (HNODE) m_hModule );

    PrintMessage( MSG_NODE_STATUS_HEADER );
    PrintStatus( m_strModuleName );

Cleanup:

    return sc;

} //*** CNodeCmd::ResumeNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::EvictNode
//
//  Routine Description:
//      Evict the cluster node
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Node Name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::EvictNode( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD                                       sc           = ERROR_SUCCESS;
    HRESULT                                     hrCleanupStatus;
    DWORD                                       dwWait       = INFINITE;
    const vector< CCmdLineParameter > &         vecParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();
    bool                                        fWaitFound   = false;

    while ( itCurParam != itLast )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                int nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        dwWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        dwWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage( MSG_NODECMD_EVICT, (LPCTSTR) m_strModuleName );

    sc = EvictClusterNodeEx( (HNODE) m_hModule, dwWait, &hrCleanupStatus );
    if ( sc == ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP )
    {
        sc = HRESULT_CODE( hrCleanupStatus );
    } // if: evict was successful

Cleanup:

    return sc;

} //*** CNodeCmd::EvictNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::ForceCleanup
//
//  Routine Description:
//      Forcibly "unconfigure" a node that has been evicted.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::ForceCleanup(
    const CCmdLineOption & thisOption
    ) throw( CSyntaxException )
{
    DWORD                                       sc = ERROR_SUCCESS;
    DWORD                                       dwWait = INFINITE;
    const vector< CCmdLineParameter > &         vecParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();
    bool                                        fWaitFound   = false;

    while ( itCurParam != itLast )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                int nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        dwWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        dwWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    // Cleanup the node.
    PrintMessage( MSG_NODECMD_CLEANUP, (LPCWSTR) m_strModuleName );
    sc = ClRtlAsyncCleanupNode( m_strModuleName, 0, dwWait );

    if ( sc == RPC_S_CALLPENDING )
    {
        if ( dwWait > 0 )
        {
            PrintMessage( MSG_NODECMD_CLEANUP_TIMEDOUT );
        } // if: waiting was required
        else
        {
            // No need to wait for the call to complete
            PrintMessage( MSG_NODECMD_CLEANUP_INITIATED );
        } // else: no wait was required

        sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if: we timed out before the call completed

    // The status code could be an HRESULT, so see if it is an error.
    if ( FAILED( sc ) )
    {
        goto Cleanup;
    } // if: something went wrong cleaning up the node

    PrintMessage( MSG_NODECMD_CLEANUP_COMPLETED );

Cleanup:

    return sc;

} //*** CNodeCmd::ForceCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::StartService
//
//  Routine Description:
//      Start the cluster service on a node.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::StartService(
    const CCmdLineOption & thisOption
    ) throw( CSyntaxException )
{
    DWORD       sc          = ERROR_SUCCESS;
    SC_HANDLE   schSCM      = NULL;
    SC_HANDLE   schClusSvc  = NULL;
    bool        fWaitFound  = false;
    UINT        uiWait      = INFINITE;
    CString     strNodeName;
    bool        fStarted    = false;
    DWORD       cQueryCount = 0;
    UINT        uiQueryInterval = 1000; // milliseconds, arbitrarily chosen

    const vector< CCmdLineParameter > &         vecParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLastParam  = vecParamList.end();

    //////////////////////////////////////////////////////////////////////////
    //
    //  Parse the parameters on the command line.
    //
    //////////////////////////////////////////////////////////////////////////

    while ( itCurParam != itLastParam )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                int nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        uiWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        uiWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    //  Start the service.
    //
    //////////////////////////////////////////////////////////////////////////

    // If a node was not specified, use the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        // Get the local computer name so that we can print out the message.
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer

        PrintMessage( MSG_NODECMD_STARTING_SERVICE, (LPCWSTR) m_strModuleName );

        // No need to do anything else with m_strModuleName.
        // The call to OpenSCManager below will use an empty string in this
        // case, which instructs it to connect to the local machine.

    }  // if: no node name was specified
    else
    {
        PrintMessage( MSG_NODECMD_STARTING_SERVICE, (LPCWSTR) m_strModuleName );

        // SCM needs the node name to be prefixed with two backslashes.
        strNodeName = L"\\\\" + m_strModuleName;
    } // else: a node name is specified

    // Open a handle to the service control manager.
    // This string will be empty if no node name was specified.
    schSCM = OpenSCManager(
                  strNodeName
                , SERVICES_ACTIVE_DATABASE
                , SC_MANAGER_ALL_ACCESS
                );
    if ( schSCM == NULL )
    {
        goto Win32Error;
    } // if: we could not open a handle to the service control manager on the target node

    // Open a handle to the cluster service.
    schClusSvc = OpenService( schSCM, CLUSTER_SERVICE_NAME, SERVICE_START | SERVICE_QUERY_STATUS );
    if ( schClusSvc == NULL )
    {
        goto Win32Error;
    } // if: we could not open a handle to the cluster service

    // Try and start the service.
    if ( ::StartService( schClusSvc, 0, NULL ) == 0 )
    {
        sc = GetLastError();
        if ( sc == ERROR_SERVICE_ALREADY_RUNNING )
        {
            // The service is already running. Change the error code to success.
            sc = ERROR_SUCCESS;
            PrintMessage( MSG_NODECMD_SEVICE_ALREADY_RUNNING );
        } // if: the service is already running.

        // There is nothing else to do.
        goto Cleanup;
    } // if: an error occurred trying to start the service.

    //////////////////////////////////////////////////////////////////////////
    //
    //  Wait for the service to start.
    //
    //////////////////////////////////////////////////////////////////////////

    // If we are here, then the service may not have started yet.

    // Divide our wait interval into cQueryCount slots.
    cQueryCount = ( ( DWORD ) uiWait ) / uiQueryInterval;

    // Has the user requested that we wait for the service to start?
    if ( cQueryCount == 0 )
    {
        PrintMessage( MSG_NODECMD_SEVICE_START_ISSUED );
        goto Cleanup;
    } // if: no waiting is required.

    // Loop for querying the service status cQueryCount times.
    do
    {
        SERVICE_STATUS  ssStatus;

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );

        // Query the service for its status.
         if ( QueryServiceStatus( schClusSvc, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            break;
        } // if: we could not query the service for its status.

        // Check if the service has posted an error.
        if ( ssStatus.dwWin32ExitCode != ERROR_SUCCESS )
        {
            sc = ssStatus.dwWin32ExitCode;
            break;
        } // if: the service itself has posted an error.

        if ( ssStatus.dwCurrentState == SERVICE_RUNNING )
        {
            fStarted = true;
            break;
        } // if: the service is running.

        // Check if the timeout has expired
        if ( cQueryCount <= 0 )
        {
            sc = ERROR_IO_PENDING;
            break;
        } // if: number of queries has exceeded the maximum specified

        --cQueryCount;

        putwchar( L'.' );

        // Wait for the specified time.
        Sleep( uiQueryInterval );
    }
    while ( true ); // while: service not started and not timed out

    //////////////////////////////////////////////////////////////////////////
    //
    //  Handle errors.
    //
    //////////////////////////////////////////////////////////////////////////

    if ( cQueryCount == 0 )
    {
        sc = ERROR_IO_PENDING;
    }

    if ( sc != ERROR_SUCCESS )
    {
        _putws( L"\r\n" );
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStarted )
    {
        PrintMessage( MSG_NODECMD_SEVICE_START_ISSUED );
    } // if: the maximum number of queries have been made and the service is not running.
    else
    {
        PrintMessage( MSG_NODECMD_SEVICE_STARTED );
    } // else: the service has started

    goto Cleanup;

Win32Error:

    sc = GetLastError();

Cleanup:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if: we had opened a handle to the SCM

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if: we had opened a handle to the cluster service

    return sc;

} //*** CNodeCmd::StartService


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::StopService
//
//  Routine Description:
//      Stop the cluster service on a node.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::StopService(
    const CCmdLineOption & thisOption
    ) throw( CSyntaxException )
{
    DWORD           sc          = ERROR_SUCCESS;
    SC_HANDLE       schSCM      = NULL;
    SC_HANDLE       schClusSvc  = NULL;
    bool            fWaitFound  = false;
    UINT            uiWait      = INFINITE;
    CString         strNodeName;
    SERVICE_STATUS  ssStatus;
    bool            fStopped    = false;
    DWORD           cQueryCount = 0;
    UINT            uiQueryInterval = 1000; // milliseconds, arbitrarily chosen

    const vector< CCmdLineParameter > &         vecParamList    = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam      = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLastParam     = vecParamList.end();

    //////////////////////////////////////////////////////////////////////////
    //
    //  Parse the parameters on the command line.
    //
    //////////////////////////////////////////////////////////////////////////

    while ( itCurParam != itLastParam )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                int nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        uiWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        uiWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    //  Stop the service.
    //
    //////////////////////////////////////////////////////////////////////////

    // If a node was not specified, use the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        // Get the local computer name so that we can print out the message.
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer

        PrintMessage( MSG_NODECMD_STOPPING_SERVICE, (LPCWSTR) m_strModuleName );

        // No need to do anything else with m_strModuleName.
        // The call to OpenSCManager below will use an empty string in this
        // case, which instructs it to connect to the local machine.

    } // if: no node name is specified
    else
    {
        PrintMessage( MSG_NODECMD_STOPPING_SERVICE, (LPCWSTR) m_strModuleName );

        // SCM needs the node name to be prefixed with two backslashes.
        strNodeName = L"\\\\" + m_strModuleName;
    } // else: a node name is specified

    // Open a handle to the service control mananger.
    schSCM = OpenSCManager(
                  strNodeName
                , SERVICES_ACTIVE_DATABASE
                , SC_MANAGER_ALL_ACCESS
                );
    if ( schSCM == NULL )
    {
        goto Win32Error;
    } // if: we could not open a handle to the service control manager on the target node

    // Open a handle to the cluster service.
    schClusSvc = OpenService(
          schSCM
        , CLUSTER_SERVICE_NAME
        , SERVICE_STOP | SERVICE_QUERY_STATUS
        );
    if ( schClusSvc == NULL )
    {
        goto Win32Error;
    } // if: the handle to the service could not be opened.

    // Query the service for its initial state.
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );
    if ( QueryServiceStatus( schClusSvc, &ssStatus ) == 0 )
    {
        goto Win32Error;
    } // if: we could not query the service for its status.

    // If the service has stopped, we have nothing more to do.
    if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
    {
        // The service is already stopped. Change the error code to success.
        PrintMessage( MSG_NODECMD_SEVICE_ALREADY_STOPPED );
        sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if: the service has stopped.

    // If the service is stopping on its own.
    // No need to send the stop control code.
    if ( ssStatus.dwCurrentState != SERVICE_STOP_PENDING )
    {
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( ControlService( schClusSvc, SERVICE_CONTROL_STOP, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            if ( sc == ERROR_SERVICE_NOT_ACTIVE )
            {
                // The service is not running. Change the error code to success.
                PrintMessage( MSG_NODECMD_SEVICE_ALREADY_STOPPED );
                sc = ERROR_SUCCESS;
            } // if: the service is not running.

            // There is nothing else to do.
            goto Cleanup;
        } // if: an error occurred trying to stop the service.
    } // if: the service has to be instructed to stop

    //////////////////////////////////////////////////////////////////////////
    //
    //  Wait for the service to stop.
    //
    //////////////////////////////////////////////////////////////////////////

    // Divide our wait interval into cQueryCount slots.
    cQueryCount = ( ( DWORD ) uiWait ) / uiQueryInterval;

    // Has the user requested that we wait for the service to stop?
    if ( cQueryCount == 0 )
    {
        PrintMessage( MSG_NODECMD_SEVICE_STOP_ISSUED );
        goto Cleanup;
    } // if: no waiting is required.

    // Query the service for its state now and wait till the timeout expires
    do
    {
        // Query the service for its status.
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( QueryServiceStatus( schClusSvc, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            break;
        } // if: we could not query the service for its status.

        // If the service has stopped, we have nothing more to do.
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            // Nothing needs to be done here.
            fStopped = true;
            sc = ERROR_SUCCESS;
            break;
        } // if: the service has stopped.

        // Check if the timeout has expired
        if ( cQueryCount <= 0 )
        {
            sc = ERROR_IO_PENDING;
            break;
        } // if: number of queries has exceeded the maximum specified

        --cQueryCount;

        putwchar( L'.' );

        // Wait for the specified time.
        Sleep( uiQueryInterval );

    }
    while ( true ); // while: service not stopped and not timed out

    //////////////////////////////////////////////////////////////////////////
    //
    //  Handle errors.
    //
    //////////////////////////////////////////////////////////////////////////

    if ( sc != ERROR_SUCCESS )
    {
        _putws( L"\r\n" );
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStopped )
    {
        PrintMessage( MSG_NODECMD_SEVICE_STOP_ISSUED );
    } // if: the maximum number of queries have been made and the service is still running.
    else
    {
        PrintMessage( MSG_NODECMD_SEVICE_STOPPED );
    } // else: the service has stopped

    goto Cleanup;

Win32Error:

    sc = GetLastError();

Cleanup:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if: we had opened a handle to the SCM

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if: we had opened a handle to the cluster service

    return sc;

} //*** CNodeCmd::StopService


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::DwGetLocalComputerName()
//
//  Routine Description:
//      Get the name of the local computer.
//
//  Arguments:
//      OUT CString & rstrComputerNameOut
//          Reference to the string that will contain the name of this
//          computer.
//
//  Exceptions:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::DwGetLocalComputerName( CString & rstrComputerNameOut )
{
    DWORD       sc;
    DWORD       cchBufferSize = 256;        // arbitrary starting buffer size
    CString     strOutput;
    DWORD       cchRequiredSize = cchBufferSize;

    do
    {
        sc = ERROR_SUCCESS;

        if (    GetComputerNameEx(
                      ComputerNameNetBIOS
                    , strOutput.GetBuffer( cchBufferSize )
                    , &cchRequiredSize
                    )
             == FALSE
           )
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                cchBufferSize = cchRequiredSize;
            } // if: the input buffer is not big enough

        } // if: GetComputerNameEx() failed

        strOutput.ReleaseBuffer();
    }
    while( sc == ERROR_MORE_DATA ); // loop while the buffer is not big enough

    if ( sc == ERROR_SUCCESS )
    {
        rstrComputerNameOut = strOutput;
    } // if: everything went well
    else
    {
        rstrComputerNameOut.Empty();
    } // else: something went wrong

    return sc;

} //*** CNodeCmd::DwGetLocalComputerName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\neticmd.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

	neticmd.cpp

Abstract:

	Network Interface Commands
	Implements commands which may be performed on
		network interfaces

Author:

	Charles Stacy Harris III (stacyh)	20-March-1997
	Michael Burton (t-mburt)			04-Aug-1997


Revision History:

--*/


#include "precomp.h"

#include "cluswrap.h"
#include "neticmd.h"

#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::CNetInterfaceCmd
//
//	Routine Description:
//		Constructor
//		Because Network Interfaces do not fit into the CGenericModuleCmd
//		model very well (they don't have an m_strModuleName, but rather
//		they have a m_strNetworkName and m_strNodeName), almost all of
//		the functionality is implemented here instead of in CGenericModuleCmd.
//
//	Arguments:
//		IN	LPCWSTR lpszClusterName
//			Cluster name. If NULL, opens default cluster.
//
//		IN	CCommandLine & cmdLine
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaceCmd::CNetInterfaceCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	InitializeModuleControls();

	m_strClusterName = strClusterName;

	m_hCluster = NULL;
	m_hModule = NULL;
}




/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::InitializeModuleControls
//
//	Routine Description:
//		Initializes all the DWORD commands used bye CGenericModuleCmd.
//		Usually these are found in the constructor, but it was easier to
//		put them all in one place in this particular case.
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		All Module Controls.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterfaceCmd::InitializeModuleControls()
{
	m_dwMsgStatusList		   = MSG_NETINT_STATUS_LIST;
	m_dwMsgStatusListAll	   = MSG_NETINT_STATUS_LIST_ALL;
	m_dwMsgStatusHeader 	   = MSG_NETINTERFACE_STATUS_HEADER;
	m_dwMsgPrivateListAll	   = MSG_PRIVATE_LISTING_NETINT_ALL;
	m_dwMsgPropertyListAll	   = MSG_PROPERTY_LISTING_NETINT_ALL;
	m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_NETINT;
	m_dwCtlGetPrivProperties   = CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES;
	m_dwCtlGetCommProperties   = CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;
	m_dwCtlGetROPrivProperties = CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES;
	m_dwCtlGetROCommProperties = CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;
	m_dwCtlSetPrivProperties   = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
	m_dwCtlSetCommProperties   = CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;
	m_dwClusterEnumModule	   = CLUSTER_ENUM_NETINTERFACE;
	m_pfnOpenClusterModule	   = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterNetInterface;
	m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterNetInterface;
	m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterNetInterfaceControl;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::~CNetInterfaceCmd
//
//	Routine Description:
//		Destructor
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		m_hModule					Module Handle
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaceCmd::~CNetInterfaceCmd()
{
	CloseModule();
	CloseCluster();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::Execute
//
//	Routine Description:
//		Gets the next command line parameter and calls the appropriate
//		handler.  If the command is not recognized, calls Execute of
//		parent class (CGenericModuleCmd)
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::Execute()
{
	try
	{
		m_theCommandLine.ParseStageTwo();
	}
	catch( CException & e )
	{
		PrintString( e.m_strErrorMsg );
		return PrintHelp();
	}

	const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

	vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
	vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

	// No options specified. Execute the default command.
	if ( curOption == lastOption )
		return Status( NULL );

	DWORD dwReturnValue = ERROR_SUCCESS;

	try
	{
		BOOL bContinue = TRUE;

		// Process one option after another.
		do
		{
			// Look up the command
			switch( curOption->GetType() )
			{
				case optHelp:
				{
					// If help is one of the options, process no more options.
					dwReturnValue = PrintHelp();
					bContinue = FALSE;
					break;
				}

				case optDefault:
				{
					// The node and network names can be specified in two ways.
					// Either as: cluster netint myNetName myNodeName /status
					// Or as: cluster netint /node:myNodeName /net:myNetName /status

					if ( curOption->GetParameters().size() != 2 )
					{
						dwReturnValue = PrintHelp();
						bContinue = FALSE;
						break;

					} // if: this option has the wrong number of values or parameters

					const vector<CCmdLineParameter> & paramList = curOption->GetParameters();
					const CCmdLineParameter *pParam1 = &paramList[0];
					const CCmdLineParameter *pParam2 = &paramList[1];

					// Swap the parameter pointers if necessary, so that the node
					// name parameter is pointed to by pParam1.
					if ( ( pParam1->GetType() == paramNetworkName ) ||
						 ( pParam2->GetType() == paramNodeName ) )
					{
						const CCmdLineParameter * pParamTemp = pParam1;
						pParam1 = pParam2;
						pParam2 = pParamTemp;
					}

					// Get the node name.
					if ( pParam1->GetType() == paramUnknown )
					{
						// No parameters are accepted if /node: is not specified.
						if ( pParam1->GetValues().size() != 0 )
						{
							CSyntaxException se;
							se.LoadMessage( MSG_PARAM_NO_VALUES, pParam1->GetName() );
							throw se;
						}

						m_strNodeName = pParam1->GetName();
					}
					else
					{
						if (pParam1->GetType() == paramNodeName )
						{
							const vector<CString> & values = pParam1->GetValues();

							if ( values.size() != 1 )
							{
								CSyntaxException se;
								se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, pParam1->GetName() );
								throw se;
							}

							m_strNodeName = values[0];
						}
						else
						{
							CSyntaxException se;
							se.LoadMessage( MSG_INVALID_PARAMETER, pParam1->GetName() );
							throw se;

						} // else: the type of this parameter is not paramNodeName

					} // else: the type of this parameter is known

					// Get the network name.
					if ( pParam2->GetType() == paramUnknown )
					{
						// No parameters are accepted if /network: is not specified.
						if ( pParam2->GetValues().size() != 0 )
						{
							CSyntaxException se;
							se.LoadMessage( MSG_PARAM_NO_VALUES, pParam2->GetName() );
							throw se;
						}

						m_strNetworkName = pParam2->GetName();
					}
					else
					{
						if (pParam2->GetType() == paramNetworkName )
						{
							const vector<CString> & values = pParam2->GetValues();

							if ( values.size() != 1 )
							{
								CSyntaxException se;
								se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, pParam2->GetName() );
								throw se;
							}

							m_strNetworkName = values[0];
						}
						else
						{
							CSyntaxException se;
							se.LoadMessage( MSG_INVALID_PARAMETER, pParam2->GetName() );
							throw se;

						} // else: the type of this parameter is not paramNetworkName

					} // else: the type of this parameter is known

					// We have the node and the network names.
					// Get the network interface name and store it in m_strModuleName.
					SetNetInterfaceName();

					// No more options are provided, just show status.
					// For example: cluster myCluster node myNode
					if ( ( curOption + 1 ) == lastOption )
					{
						dwReturnValue = Status( NULL );
					}

					break;

				} // case optDefault

				default:
				{
					dwReturnValue = CGenericModuleCmd::Execute( *curOption );
				}

			} // switch: based on the type of option

			if ( ( bContinue == FALSE ) || ( dwReturnValue != ERROR_SUCCESS ) )
				break;
			else
				++curOption;

			if ( curOption != lastOption )
				PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
			else
				break;
		}
		while ( TRUE );

	} // try
	catch ( CSyntaxException & se )
	{
		PrintString( se.m_strErrorMsg );
		dwReturnValue = PrintHelp();
	}

	return dwReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::PrintHelp
//
//	Routine Description:
//		Prints help for Network Interfaces
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::PrintHelp()
{
	return PrintMessage( MSG_HELP_NETINTERFACE );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::Status
//
//	Routine Description:
//		Prints out the status of the module.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_strModuleName 			Name of module.  If non-NULL, Status() prints
//									out the status of the specified module.
//									Otherwise, prints status of all modules.
//		m_strNetworkName			Name of Network
//		m_strNodeName				Name of Node
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::Status( const CCmdLineOption * pOption )
	throw( CSyntaxException )
{
	DWORD dwError = ERROR_SUCCESS;

	// pOption will be NULL if this function has been called as the
	// default action.
	if ( pOption != NULL )
	{
		// This option takes no values.
		if ( pOption->GetValues().size() != 0 )
		{
			CSyntaxException se;
			se.LoadMessage( MSG_OPTION_NO_VALUES, pOption->GetName() );
			throw se;
		}

		// This option takes no parameters.
		if ( pOption->GetParameters().size() != 0 )
		{
			CSyntaxException se;
			se.LoadMessage( MSG_OPTION_NO_PARAMETERS, pOption->GetName() );
			throw se;
		}
	}

	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	if( m_strModuleName.IsEmpty() == FALSE )
	{
		if ( m_strNodeName.IsEmpty() != FALSE )
		{
			LPTSTR lpszNodeName = GetNodeName( m_strModuleName );
			m_strNodeName = lpszNodeName;
			LocalFree( lpszNodeName );
		}

		if ( m_strNetworkName.IsEmpty() != FALSE )
		{
			LPTSTR lpszNetworkName = GetNetworkName( m_strModuleName );
			m_strNetworkName = lpszNetworkName;
			LocalFree( lpszNetworkName );
		}

		PrintMessage( MSG_NETINT_STATUS_LIST, m_strNodeName, m_strNetworkName );
		PrintMessage( MSG_NETINTERFACE_STATUS_HEADER );
		return PrintStatus( m_strModuleName );
	}

	HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_NETINTERFACE );

	if( !hEnum )
		return GetLastError();

	PrintMessage( MSG_NETINT_STATUS_LIST_ALL);
	PrintMessage( MSG_NETINTERFACE_STATUS_HEADER );

	DWORD dwIndex = 0;
	DWORD dwType = 0;
	LPWSTR lpszName = 0;

	dwError = ERROR_SUCCESS;

	for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
	{

		dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

		if( dwError == ERROR_SUCCESS )
			PrintStatus( lpszName );
		if( lpszName )
			LocalFree( lpszName );
	}


	if( dwError == ERROR_NO_MORE_ITEMS )
		dwError = ERROR_SUCCESS;

	ClusterCloseEnum( hEnum );

	return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::PrintStatus
//
//	Routine Description:
//		Interprets the status of the module and prints out the status line
//		Required for any derived non-abstract class of CGenericModuleCmd
//
//	Arguments:
//		lpszNetInterfaceName		Name of the module
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		Same as PrintStatus(HNETINTERFACE,LPCWSTR,LPCWSTR)
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::PrintStatus( LPCWSTR lpszNetInterfaceName )
{
	DWORD dwError = ERROR_SUCCESS;
	LPWSTR lpszNodeName;
	LPWSTR lpszNetworkName;

	// Open the Net Interface handle
	HNETINTERFACE hNetInterface = OpenClusterNetInterface( m_hCluster, lpszNetInterfaceName );
	if( !hNetInterface )
		return GetLastError();

	lpszNodeName = GetNodeName(lpszNetInterfaceName);
	lpszNetworkName = GetNetworkName(lpszNetInterfaceName);

	if (lpszNodeName && lpszNetworkName)
	{
		dwError = PrintStatus( hNetInterface, lpszNodeName, lpszNetworkName );
		LocalFree(lpszNodeName);
		LocalFree(lpszNetworkName);
	}
	else
	{
		dwError = PrintStatus( hNetInterface, L"", L"" );
	}


	CloseClusterNetInterface( hNetInterface );

	return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::PrintStatus
//
//	Routine Description:
//		Interprets the status of the module and prints out the status line
//		Required for any derived non-abstract class of CGenericModuleCmd
//
//	Arguments:
//		hNetInterface				Handle to network interface
//		lpszNodeName				Name of the node
//		lpszNetworkName 			Name of network
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::PrintStatus( HNETINTERFACE hNetInterface, LPCWSTR lpszNodeName, LPCWSTR lpszNetworkName)
{
	DWORD dwError = ERROR_SUCCESS;

	CLUSTER_NETINTERFACE_STATE nState;

	nState = GetClusterNetInterfaceState( hNetInterface );

	if( nState == ClusterNetInterfaceStateUnknown )
		return GetLastError();

	LPWSTR lpszStatus = 0;

	switch( nState )
	{
		case ClusterNetInterfaceUnavailable:
			LoadMessage( MSG_STATUS_UNAVAILABLE, &lpszStatus );
			break;

		case ClusterNetInterfaceFailed:
			LoadMessage( MSG_STATUS_FAILED, &lpszStatus );
			break;

		case ClusterNetInterfaceUnreachable:
		   LoadMessage( MSG_STATUS_UNREACHABLE, &lpszStatus );
		   break;

		case ClusterNetInterfaceUp:
			LoadMessage( MSG_STATUS_UP, &lpszStatus );
			break;

		case ClusterNetInterfaceStateUnknown:
		default:
			LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
	}

	dwError = PrintMessage( MSG_NETINTERFACE_STATUS, lpszNodeName, lpszNetworkName, lpszStatus );

	// Since Load/FormatMessage uses LocalAlloc...
	if( lpszStatus )
		LocalFree( lpszStatus );

	return dwError;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::DoProperties
//
//	Routine Description:
//		Dispatches the property command to either Get or Set properties
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	PropertyType ePropertyType
//			The type of property, PRIVATE or COMMON
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::DoProperties( const CCmdLineOption & thisOption,
									  PropertyType ePropType )
	throw( CSyntaxException )
{
	if ( ( m_strNodeName.IsEmpty() != FALSE ) &&
		 ( m_strNetworkName.IsEmpty() != FALSE ) )
		return AllProperties( thisOption, ePropType );

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;


	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

	// If there are no property-value pairs on the command line,
	// then we print the properties otherwise we set them.
	if( paramList.size() == 0 )
	{
		assert( m_strNodeName.IsEmpty() == FALSE  );
		assert( m_strNetworkName.IsEmpty() == FALSE );
		PrintMessage( MSG_PROPERTY_NETINT_LISTING, m_strNodeName, m_strNetworkName );
		PrintMessage( MSG_PROPERTY_HEADER_NETINT );
		return GetProperties( thisOption, ePropType );
	}
	else
	{
		return SetProperties( thisOption, ePropType );
	}
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::GetProperties
//
//	Routine Description:
//		Prints out properties for the specified module
//
//	Arguments:
//		IN	const vector<CCmdLineParameter> & paramList
//			Contains the list of property-value pairs to be set
//
//		IN	PropertyType ePropertyType
//			The type of property, PRIVATE or COMMON
//
//		IN	LPCWSTR lpszNetIntName
//			Name of the module
//
//	Member variables used / set:
//		m_hModule					Module handle
//
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::GetProperties( const CCmdLineOption & thisOption,
									   PropertyType ePropType, LPWSTR lpszNetIntName )
{
	LPWSTR lpszNodeName;
	LPWSTR lpszNetworkName;

	DWORD dwError = ERROR_SUCCESS;
	HNETINTERFACE hNetInt;

	// If no lpszNetIntName specified, use current network interface,
	// otherwise open the specified netint
	if (!lpszNetIntName)
	{
		hNetInt = (HNETINTERFACE) m_hModule;

		// These must be localalloced (they're localfreed later)
		lpszNodeName = (LPWSTR) LocalAlloc( LMEM_FIXED, sizeof(WCHAR)* m_strNodeName.GetLength() );
		if (!lpszNodeName) return GetLastError();
		lpszNetworkName = (LPWSTR) LocalAlloc( LMEM_FIXED, sizeof(WCHAR)* m_strNetworkName.GetLength() );
		if (!lpszNetworkName)
		{
			LocalFree( lpszNodeName );
			return GetLastError();
		}
		lstrcpy(lpszNodeName, m_strNodeName);
		lstrcpy(lpszNetworkName, m_strNetworkName);
	}
	else
	{
		hNetInt = OpenClusterNetInterface( m_hCluster, lpszNetIntName);
		if( hNetInt == 0 )
			return GetLastError();

		lpszNodeName = GetNodeName(lpszNetIntName);
		lpszNetworkName = GetNetworkName(lpszNetIntName);
		if (!lpszNodeName || !lpszNetworkName)
			return ERROR_INVALID_HANDLE;				// zap! improve error handling
	}


	// Use the proplist helper class.
	CClusPropList PropList;
	dwError = PropList.ScAllocPropList( 8192 );
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	// Get R/O properties
	DWORD dwControlCode = ePropType==PRIVATE ? CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES
							 : CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;

	dwError = PropList.ScGetNetInterfaceProperties( hNetInt, dwControlCode );

	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = PrintProperties( PropList, thisOption.GetValues(), READONLY,
							   lpszNodeName, lpszNetworkName );

	if (dwError != ERROR_SUCCESS)
		return dwError;


	// Get R/W properties
	dwControlCode = ePropType==PRIVATE ? CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
							   : CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;

	dwError = PropList.ScGetNetInterfaceProperties( hNetInt, dwControlCode );

	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = PrintProperties( PropList, thisOption.GetValues(), READWRITE,
							   lpszNodeName, lpszNetworkName );

	LocalFree(lpszNodeName);
	LocalFree(lpszNetworkName);

	return dwError;

} //*** CNetInterfaceCmd::GetProperties()



/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::AllProperties
//
//	Routine Description:
//		Prints out properties for all modules
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	PropertyType ePropertyType
//			The type of property, PRIVATE or COMMON
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_strModuleName 			Name of module.  If non-NULL, prints
//									out properties for the specified module.
//									Otherwise, prints props for all modules.
//
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::AllProperties( const CCmdLineOption & thisOption,
									   PropertyType ePropType )
	throw( CSyntaxException )
{
	DWORD dwError;
	DWORD dwIndex;
	DWORD dwType;
	LPWSTR lpszName;

	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se;
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	// Enumerate the resources
	HCLUSENUM hNetIntEnum = ClusterOpenEnum(m_hCluster, CLUSTER_ENUM_NETINTERFACE);
	if (!hNetIntEnum)
		return GetLastError();

	// Print the header
	PrintMessage( ePropType==PRIVATE ? MSG_PRIVATE_LISTING_NETINT_ALL : MSG_PROPERTY_LISTING_NETINT_ALL );
	PrintMessage( MSG_PROPERTY_HEADER_NETINT );

	// Print out status for all resources
	dwError = ERROR_SUCCESS;
	for (dwIndex=0; dwError != ERROR_NO_MORE_ITEMS; dwIndex++)
	{
		dwError = WrapClusterEnum( hNetIntEnum, dwIndex, &dwType, &lpszName );

		if( dwError == ERROR_SUCCESS )
		{
			dwError = GetProperties( thisOption, ePropType, lpszName );
			if (dwError != ERROR_SUCCESS)
				PrintSystemError(dwError);
		}

		if( lpszName )
			LocalFree( lpszName );
	}


	ClusterCloseEnum( hNetIntEnum );

	return ERROR_SUCCESS;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::GetNodeName
//
//	Routine Description:
//		Returns the name of the node for the specified network interface.
//		*Caller must LocalFree memory*
//
//	Arguments:
//		lpszInterfaceName			Name of the network interface
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//
//	Return Value:
//		Name of the node			on success
//		NULL						on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CNetInterfaceCmd::GetNodeName (LPCWSTR lpszInterfaceName)
{
	DWORD dwError;
	DWORD cLength = 0;
	LPWSTR lpszNodeName;
	HNETINTERFACE hNetInterface;

	// Open the cluster and netinterface if it hasn't been done
	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return NULL;

	// Open an hNetInterface for the specified lpszInterfaceName (don't call
	// OpenModule because that opens m_hModule)
	hNetInterface = OpenClusterNetInterface( m_hCluster, lpszInterfaceName );
	if( hNetInterface == 0 )
		return NULL;

	// Find out how much memory to allocate
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NODE,
		0,
		0,
		NULL,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
		return NULL;

	lpszNodeName = (LPWSTR) LocalAlloc( LMEM_FIXED,sizeof(WCHAR)*(++cLength) );
	if (!lpszNodeName) return NULL;

	// Get the node name and store it in a temporary
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NODE,
		0,
		0,
		(LPVOID) lpszNodeName,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
	{
		if (lpszNodeName) LocalFree (lpszNodeName);
		return NULL;
	}

	CloseClusterNetInterface( hNetInterface );

	return lpszNodeName;
}





/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::GetNetworkName
//
//	Routine Description:
//		Returns the name of the network for the specified network interface.
//		*Caller must LocalFree memory*
//
//	Arguments:
//		lpszInterfaceName			Name of the network interface
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//
//	Return Value:
//		Name of the node			on success
//		NULL						on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CNetInterfaceCmd::GetNetworkName (LPCWSTR lpszInterfaceName)
{
	DWORD dwError;
	DWORD cLength = 0;
	LPWSTR lpszNetworkName;
	HNETINTERFACE hNetInterface;

	// Open the cluster and netinterface if it hasn't been done
	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return NULL;

	// Open an hNetInterface for the specified lpszInterfaceName (don't call
	// OpenModule because that opens m_hModule)
	hNetInterface = OpenClusterNetInterface( m_hCluster, lpszInterfaceName );
	if( hNetInterface == 0 )
		return NULL;

	// Find out how much memory to allocate
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NETWORK,
		0,
		0,
		NULL,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
		return NULL;

	lpszNetworkName = (LPWSTR) LocalAlloc( LMEM_FIXED,sizeof(WCHAR)*(++cLength) );
	if (!lpszNetworkName) return NULL;

	// Get the node name and store it in a temporary
	dwError = ClusterNetInterfaceControl(
		hNetInterface,
		NULL, // hNode
		CLUSCTL_NETINTERFACE_GET_NETWORK,
		0,
		0,
		(LPVOID) lpszNetworkName,
		cLength,
		&cLength );

	if (dwError != ERROR_SUCCESS)
	{
		if (lpszNetworkName) LocalFree (lpszNetworkName);
		return NULL;
	}

	CloseClusterNetInterface( hNetInterface );

	return lpszNetworkName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceCmd::SetNetInterfaceName
//
//	Routine Description:
//		Sets the network interface name by looking up the node
//		name and network name.	If either one is unknown, returns
//		ERROR_SUCCESS without doing anything.
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		m_strNodeName				Node name
//		m_strNetworkName			Network name
//		m_strModuleName 			SET
//
//	Return Value:
//		ERROR_SUCCESS				on success or when nothing done
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::SetNetInterfaceName()
{
	DWORD dwError;
	DWORD cInterfaceName;
	LPWSTR lpszInterfaceName = NULL;

	// Don't do anything if either netname or nodename don't exist
	if ( ( m_strNetworkName.IsEmpty() != FALSE ) ||
		 ( m_strNodeName.IsEmpty() != FALSE ) )
		return ERROR_SUCCESS;

	// Open the cluster if necessary
	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	// First get the size
	cInterfaceName = 0;
	dwError = GetClusterNetInterface(m_hCluster,
									 m_strNodeName,
									 m_strNetworkName,
									 NULL,
									 &cInterfaceName
									 );

	if (dwError != ERROR_SUCCESS)
		return dwError;

	// Allocate the proper amount of memory
	lpszInterfaceName = new WCHAR[++cInterfaceName];
	if (!lpszInterfaceName)
		return GetLastError();

	// Get the InterfaceName
	dwError = GetClusterNetInterface(m_hCluster,
									 m_strNodeName,
									 m_strNetworkName,
									 lpszInterfaceName,
									 &cInterfaceName
									 );


	if (dwError == ERROR_SUCCESS)
	{
		m_strModuleName = lpszInterfaceName;
		delete lpszInterfaceName;
		return ERROR_SUCCESS;
	}

	if (lpszInterfaceName) delete [] lpszInterfaceName;

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\pragmas.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    pragmas.h

Abstract:

	C preprocessor settings for the project and other
	miscellaneous pragmas

Revision History:

--*/

#pragma warning (disable:4201)		// nonstandard extension used : nameless struct/union
#pragma warning (disable:4250)		// 'class1' : inherits 'class2::member' via dominance
#pragma warning (disable:4702)		// unreachable code -
									// zap! This warning only crops up when using
									// build (not using VC4)

#ifndef _UNICODE
#define _UNICODE
#endif

#ifndef UNICODE
#define UNICODE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		Galen Barbee	(GalenB)	20-Dec-1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <PropList.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		precomp.h
//
//	Abstract:
//		This file contains some standard headers used by files in the
//		cluster.exe project. Putting them all in one file (when precompiled headers
//		are used) speeds up the compilation process.
//
//	Implementation File:
//		The CComModule _Module declared in this file is instantiated in cluster.cpp
//
//	Author:
//		Vijayendra Vasu (vvasu)	September 16, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PRECOMP_H__
#define __PRECOMP_H__


/////////////////////////////////////////////////////////////////////////////
//	Preprocessor settings for the project and other
//	miscellaneous pragmas
/////////////////////////////////////////////////////////////////////////////

// nonstandard extension used : nameless struct/union
#pragma warning (disable:4201)

// 'class1' : inherits 'class2::member' via dominance
#pragma warning (disable:4250)

// unreachable code - This warning only crops up when using build (not using VC4)
#pragma warning (disable:4702)

#ifndef _UNICODE
#define _UNICODE
#endif

#ifndef UNICODE
#define UNICODE
#endif


/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

//
// Enable cluster debug reporting
//
#if DBG
#define CLRTL_INCLUDE_DEBUG_REPORTING
#endif // DBG
#include "ClRtlDbg.h"
#define ASSERT _CLRTL_ASSERTE
#define ATLASSERT ASSERT

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <assert.h>

#include <clusapi.h>

#include <atlbase.h>

extern CComModule _Module;

#include <atlapp.h>
#include <atltmp.h>

// For cluster configuration server COM objects.
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>


#endif // __PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\nodecmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	nodecmd.h

Abstract:

	Interface for functions which may be performed
	on a network node object

Revision History:

--*/

#ifndef __NODECMD_H__
#define __NODECMD_H__

#include "intrfc.h"

class CCommandLine;

class CNodeCmd : virtual public CHasInterfaceModuleCmd
{
public:
	CNodeCmd( const CString & strClusterName, CCommandLine & cmdLine );

	DWORD Execute();

protected:
	
	DWORD PrintStatus( LPCWSTR lpszNodeName );
	DWORD PrintHelp();

	DWORD PauseNode( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD ResumeNode( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD EvictNode( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD ForceCleanup( const CCmdLineOption & thisOption ) throw( CSyntaxException );
    DWORD StartService( const CCmdLineOption & thisOption ) throw( CSyntaxException );
    DWORD StopService( const CCmdLineOption & thisOption ) throw( CSyntaxException );

    DWORD DwGetLocalComputerName( CString & rstrComputerNameOut );
};



#endif // __NODECMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\rename.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

	rename.cpp

Abstract:

	Commands for modules which renamable


Author:

	Michael Burton (t-mburt)			25-Aug-1997


Revision History:
	

--*/


#include "rename.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRenamableModuleCmd::CRenamableModuleCmd
//
//	Routine Description:
//		Default Constructor
//		Initializes all the DWORD parameters to UNDEFINED and
//		all the pointers to cluster functions to NULL.
//		*ALL* these variables must be defined in any derived class.
//
//	Arguments:
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		m_dwMsgModuleRenameCmd			SET to UNDEFINED
//		m_pfnSetClusterModuleName		SET to NULL
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRenamableModuleCmd::CRenamableModuleCmd( CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	m_dwMsgModuleRenameCmd	  = UNDEFINED;
	m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) NULL;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRenamableModuleCmd::Execute
//
//	Routine Description:
//		Takes a command line option and determines which command to
//		execute.  If no command line option specified, gets the next one
//		automatically.	If the token is not identifed as being handle-able
//		in this class, the token is passed up to CGenericModuleCmd::Execute
//		unless DONT_PASS_HIGHER is specified as the second parameter, 
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	ExecuteOption eEOpt							
//			OPTIONAL enum, either DONT_PASS_HIGHER or
//			PASS_HIGHER_ON_ERROR (default)
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRenamableModuleCmd::Execute( const CCmdLineOption & option, 
									ExecuteOption eEOpt )
	throw( CSyntaxException )
{
	// Look up the command
	if ( option.GetType() == optRename )
		return Rename( option );

	if (eEOpt == PASS_HIGHER_ON_ERROR)
		return CGenericModuleCmd::Execute( option );
	else
		return ERROR_NOT_HANDLED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRenamableModuleCmd::Rename
//
//	Routine Description:
//		Renames the specified module to the new name
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Module name
//		m_dwMsgModuleRenameCmd		Command Control to rename module
//		m_dwMsgStatusHeader 		Listing header
//		m_pfnSetClusterModuleName	Function to set module name
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRenamableModuleCmd::Rename( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes exactly one value.
	if ( thisOption.GetValues().size() != 1 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	const CString & strNewName = ( thisOption.GetValues() )[0];

	assert(m_dwMsgModuleRenameCmd != UNDEFINED);
	PrintMessage( m_dwMsgModuleRenameCmd, (LPCTSTR) m_strModuleName );

	assert(m_pfnSetClusterModuleName);
	dwError = m_pfnSetClusterModuleName( m_hModule, strNewName );

	assert(m_dwMsgStatusHeader != UNDEFINED);
	PrintMessage( m_dwMsgStatusHeader );
	PrintStatus( strNewName );

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\rescmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	rescmd.h

Abstract:

	Interface for functions which may be performed
	on a resource object

Revision History:

--*/

#ifndef __RESCMD_H__
#define __RESCMD_H__

#include "resumb.h"
#include "rename.h"

class CCommandLine;

class CResourceCmd :	public CRenamableModuleCmd,
						public CResourceUmbrellaCmd
{
public:
	CResourceCmd( const CString & strClusterName, CCommandLine & cmdLine );

	DWORD Execute();

private:
	DWORD Create( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Move( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD Online( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Offline( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD FailResource( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD AddDependency( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveDependency( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD ListDependencies( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD AddOwner( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveOwner( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD AddCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetChkPointsForResource( const CString & strResourceName );

	DWORD AddCryptoCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveCryptoCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetCryptoCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetCryptoChkPointsForResource( const CString & strResourceName );

	DWORD PrintHelp();
	DWORD PrintStatus( LPCWSTR lpszResourceName );
	DWORD PrintStatus2( LPCWSTR lpszResourceName, LPCWSTR lpszNodeName );

};



#endif //__RESCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\rename.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    rescmd.h

Abstract:

    This module defines the interface available for modules
	which are renamable
	
Revision History:

--*/

#ifndef __RENAME_H__
#define __RENAME_H__

#include "modcmd.h"

class CRenamableModuleCmd : virtual public CGenericModuleCmd
{
public:
	CRenamableModuleCmd( CCommandLine & cmdLine );

protected:
	// Additional Commands
	// Additional Commands
	virtual DWORD Execute( const CCmdLineOption & option, 
						   ExecuteOption eEOpt = PASS_HIGHER_ON_ERROR  )
		throw( CSyntaxException );

	virtual DWORD Rename( const CCmdLineOption & thisOption )
		throw( CSyntaxException );


	DWORD   m_dwMsgModuleRenameCmd;
	DWORD (*m_pfnSetClusterModuleName) (HCLUSMODULE,LPCWSTR);
};


#endif // __RENAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\rescmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      rescmd.cpp
//
//  Abstract:
//      Resource Commands
//      Implements commands which may be performed on resources
//
//  Author:
//      Charles Stacy Harris III (stacyh)   20-March-1997
//      Michael Burton (t-mburt)            04-Aug-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////


#include "precomp.h"

#include "cluswrap.h"
#include "rescmd.h"

#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::CResourceCmd
//
//  Routine Description:
//      Constructor
//      Initializes all the DWORD params used by CGenericModuleCmd,
//      CRenamableModuleCmd, and CResourceUmbrellaCmd to
//      provide generic functionality.
//
//  Arguments:
//      IN  const CString & strClusterName
//          Name of the cluster being administered
//
//      IN  CCommandLine & cmdLine              
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceCmd::CResourceCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine ), CRenamableModuleCmd( cmdLine ),
    CResourceUmbrellaCmd( cmdLine )
{
    m_strClusterName = strClusterName;
    m_strModuleName.Empty();

    m_hCluster = NULL;
    m_hModule = NULL;

    m_dwMsgStatusList          = MSG_RESOURCE_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_RESOURCE_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_RESOURCE_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_RES_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_RES_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_RES_ALL;
    m_dwCtlGetPrivProperties   = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_RESOURCE;
    m_pfnOpenClusterModule     = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterResource;
    m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterResource;
    m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterResourceControl;
    m_pfnClusterOpenEnum       = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterResourceOpenEnum;
    m_pfnClusterCloseEnum      = (DWORD(*)(HCLUSENUM)) ClusterResourceCloseEnum;
    m_pfnWrapClusterEnum         = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterResourceEnum;
    
    // Renamable Properties
    m_dwMsgModuleRenameCmd    = MSG_RESCMD_RENAME;
    m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) SetClusterResourceName;

    // Resource Umbrella Properties
    m_dwMsgModuleStatusListForNode  = MSG_RESOURCE_STATUS_LIST_FOR_NODE;
    m_dwClstrModuleEnumNodes        = CLUSTER_RESOURCE_ENUM_NODES;
    m_dwMsgModuleCmdListOwnersList  = MSG_RESCMD_OWNERS;
    m_dwMsgModuleCmdListOwnersHeader= MSG_NODELIST_HEADER;
    m_dwMsgModuleCmdListOwnersDetail= MSG_NODELIST_DETAIL;
    m_dwMsgModuleCmdDelete          = MSG_RESCMD_DELETE;
    m_pfnDeleteClusterModule        = (DWORD(*)(HCLUSMODULE)) DeleteClusterResource;

} //*** CResourceCmd::CResourceCmd() 


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent classes (first CRenamableModuleCmd, then CRsourceUmbrellaCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Execute()
{
    try
    {
        m_theCommandLine.ParseStageTwo();
    }
    catch( CException & e )
    {
        PrintString( e.m_strErrorMsg );
        return PrintHelp();
    }

    DWORD dwReturnValue = ERROR_SUCCESS;

    const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

    vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
    vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

    if ( curOption == lastOption )
        return Status( NULL );

    try
    {
        BOOL bContinue = TRUE;

        do
        {
            switch ( curOption->GetType() )
            {
                case optDefault:
                {
                    if ( curOption->GetParameters().size() != 1 )
                    {
                        dwReturnValue = PrintHelp();
                        bContinue = FALSE;
                        break;

                    } // if: this option has the wrong number of values or parameters

                    const CCmdLineParameter & param = (curOption->GetParameters())[0];

                    // If we are here, then it is either because /node:nodeName
                    // has been specified or because a group name has been given.
                    // Note that the /node:nodeName switch is not treated as an option.
                    // It is really a parameter to the implicit /status command.

                    if ( param.GetType() == paramNodeName )
                    {
                        const vector<CString> & valueList = param.GetValues();

                        // This parameter takes exactly one value.
                        if ( valueList.size() != 1 )
                        {
                            CSyntaxException se; 
                            se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, param.GetName() );
                            throw se;
                        }

                        m_strModuleName.Empty();
                        dwReturnValue = Status( valueList[0], TRUE /* bNodeStatus */ );

                    } // if: A node name has been specified
                    else
                    {
                        if ( param.GetType() != paramUnknown )
                        {
                            dwReturnValue = PrintHelp();
                            bContinue = FALSE;
                            break;
                        }

                        // This parameter takes no values.
                        if ( param.GetValues().size() != 0 )
                        {
                            CSyntaxException se; 
                            se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
                            throw se;
                        }

                        m_strModuleName = param.GetName();

                        // No more options are provided, just show status.
                        // For example: cluster myCluster node myNode
                        if ( ( curOption + 1 ) == lastOption )
                        {
                            dwReturnValue = Status( m_strModuleName, FALSE /* bNodeStatus */ );
                        }

                    } // else: No node name has been specified.

                    break;

                } // case optDefault

                case optStatus:
                {
                    // This option takes no values.
                    if ( curOption->GetValues().size() != 0 )
                    {
                        CSyntaxException se; 
                        se.LoadMessage( MSG_OPTION_NO_VALUES, curOption->GetName() );
                        throw se;
                    }

                    // This option takes no parameters.
                    if ( curOption->GetParameters().size() != 0 )
                    {
                        CSyntaxException se; 
                        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, curOption->GetName() );
                        throw se;
                    }

                    dwReturnValue = Status( m_strModuleName,  FALSE /* bNodeStatus */ );
                    break;
                }

                case optOnline:
                {
                    dwReturnValue = Online( *curOption );
                    break;
                }

                case optFail:
                {
                    dwReturnValue = FailResource( *curOption );
                    break;
                }

                case optAddDependency:
                {
                    dwReturnValue = AddDependency( *curOption );
                    break;
                }

                case optRemoveDependency:
                {
                    dwReturnValue = RemoveDependency( *curOption );
                    break;
                }

                case optListDependencies:
                {
                    dwReturnValue = ListDependencies( *curOption );
                    break;
                }

                case optAddOwner:
                {
                    dwReturnValue = AddOwner( *curOption );
                    break;
                }

                case optRemoveOwner:
                {
                    dwReturnValue = RemoveOwner( *curOption );
                    break;
                }

                case optAddCheckPoints:
                {
                    dwReturnValue = AddCheckPoints( *curOption );
                    break;
                }

                case optRemoveCheckPoints:
                {
                    dwReturnValue = RemoveCheckPoints( *curOption );
                    break;
                }

                case optGetCheckPoints:
                {
                    dwReturnValue = GetCheckPoints( *curOption );
                    break;
                }

                case optAddCryptoCheckPoints:
                {
                    dwReturnValue = AddCryptoCheckPoints( *curOption );
                    break;
                }

                case optRemoveCryptoCheckPoints:
                {
                    dwReturnValue = RemoveCryptoCheckPoints( *curOption );
                    break;
                }

                case optGetCryptoCheckPoints:
                {
                    dwReturnValue = GetCryptoCheckPoints( *curOption );
                    break;
                }

                default:
                {
                    dwReturnValue = CRenamableModuleCmd::Execute( *curOption, DONT_PASS_HIGHER );

                    if ( dwReturnValue == ERROR_NOT_HANDLED )
                        dwReturnValue = CResourceUmbrellaCmd::Execute( *curOption );
                }

            } // switch: based on the type of option

            if ( ( bContinue == FALSE ) || ( dwReturnValue != ERROR_SUCCESS ) )
                break;
            else
                ++curOption;

            if ( curOption != lastOption )
                PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
            else
                break;
        }
        while ( TRUE );

    }
    catch ( CSyntaxException & se )
    {
        PrintString( se.m_strErrorMsg );
        dwReturnValue = PrintHelp();
    }

    return dwReturnValue;

} //*** CResourceCmd::Execute()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Resources
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::PrintHelp()
{
    return PrintMessage( MSG_HELP_RESOURCE );

} //*** CResourceCmd::PrintHelp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszResourceName                Name of the module
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintStatus2
//
//--
/////////////////////////////////////////////////////////////////////////////
inline DWORD CResourceCmd::PrintStatus( LPCWSTR lpszResourceName )
{
    return PrintStatus2(lpszResourceName, NULL);

} //*** CResourceCmd::PrintStatus()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintStatus2
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszResourceName            Name of the module
//      lpszNodeName                Name of the node
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::PrintStatus2( LPCWSTR lpszResourceName, LPCWSTR lpszNodeName )
{
    DWORD dwError = ERROR_SUCCESS;

    CLUSTER_RESOURCE_STATE nState;

    LPWSTR lpszResNodeName = NULL;

    LPWSTR lpszResGroupName = NULL;

    HRESOURCE hResource = OpenClusterResource( m_hCluster, lpszResourceName );
    if (!hResource)
        return GetLastError();

    nState = WrapGetClusterResourceState( hResource, &lpszResNodeName, &lpszResGroupName );

    if( nState == ClusterResourceStateUnknown )
        return GetLastError();

    //zap! Check the group name also! needs to be passed in...

    // if the node names don't match just return.
    if( lpszNodeName && *lpszNodeName )  // non-null and non-empty
        if( lstrcmpi( lpszResNodeName, lpszNodeName ) != 0 )
        {
            LocalFree( lpszResNodeName );
            LocalFree( lpszResGroupName );
            return ERROR_SUCCESS;
        }


    LPWSTR lpszStatus = 0;

    switch( nState )
    {
        case ClusterResourceInherited:
            LoadMessage( MSG_STATUS_INHERITED, &lpszStatus );
            break;

        case ClusterResourceInitializing:
            LoadMessage( MSG_STATUS_INITIALIZING, &lpszStatus );
            break;

        case ClusterResourceOnline:
            LoadMessage( MSG_STATUS_ONLINE, &lpszStatus );
            break;

        case ClusterResourceOffline:
            LoadMessage( MSG_STATUS_OFFLINE, &lpszStatus );
            break;

        case ClusterResourceFailed:
            LoadMessage( MSG_STATUS_FAILED, &lpszStatus );
            break;

        case ClusterResourcePending:
            LoadMessage( MSG_STATUS_PENDING, &lpszStatus );
            break;

        case ClusterResourceOnlinePending:
            LoadMessage( MSG_STATUS_ONLINEPENDING, &lpszStatus );
            break;

        case ClusterResourceOfflinePending:
            LoadMessage( MSG_STATUS_OFFLINEPENDING, &lpszStatus );
            break;

        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
    }

    dwError = PrintMessage( MSG_RESOURCE_STATUS, lpszResourceName, lpszResGroupName, 
        lpszResNodeName, lpszStatus );

    // Since Load/FormatMessage uses LocalAlloc...
    if( lpszStatus )
        LocalFree( lpszStatus );

    if( lpszResNodeName )
        LocalFree( lpszResNodeName );

    if( lpszResGroupName )
        LocalFree( lpszResGroupName );

    CloseClusterResource( hResource );

    return dwError;

} //*** CResourceCmd::PrintStatus2()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Create
//
//  Routine Description:
//      Create a resource.  Reads the command line to get
//      additional options
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_hModule                   Resource Handle
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Create( const CCmdLineOption & thisOption ) 
    throw( CSyntaxException )
{
    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    CString strGroupName;
    CString strResType;
    DWORD dwFlags = 0;

    strGroupName.Empty();
    strResType.Empty();

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bGroupNameFound = FALSE, bTypeFound = FALSE, bSeparateFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramGroupName:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bGroupNameFound != FALSE )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strGroupName = valueList[0];
                bGroupNameFound = TRUE;
                break;

            case paramResType:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bTypeFound != FALSE )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strResType = valueList[0];
                bTypeFound = TRUE;
                break;

            case paramSeparate:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 0 )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_NO_VALUES, curParam->GetName() );
                    throw se;
                }

                if ( bSeparateFound != FALSE )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                dwFlags |= CLUSTER_RESOURCE_SEPARATE_MONITOR;  // treat as bit mask for future
                bSeparateFound = TRUE;
                break;

            default:
            {
                CSyntaxException se; 
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }
        }

        ++curParam;
    }


    if( strGroupName.IsEmpty() || strResType.IsEmpty() )
    {
        PrintMessage( IDS_MISSING_PARAMETERS );
        return PrintHelp();
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    HGROUP hGroup = OpenClusterGroup( m_hCluster, strGroupName );

    if( !hGroup )
        return GetLastError();

    PrintMessage( MSG_RESCMD_CREATE, (LPCTSTR) m_strModuleName );

    m_hModule = CreateClusterResource( hGroup, m_strModuleName, strResType, dwFlags );


    if( !m_hModule )
        return GetLastError();

    PrintMessage( MSG_RESOURCE_STATUS_HEADER );
    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::Create()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Move
//
//  Routine Description:
//      Move the resource to a new group.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Move( const CCmdLineOption & thisOption ) 
    throw( CSyntaxException )
{
    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strGroupName = (thisOption.GetValues())[0];

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    // Check to see if there is a value for the destination node.
    HGROUP hDestGroup = 0;

    hDestGroup = OpenClusterGroup( m_hCluster, strGroupName );
    
    if( !hDestGroup )
        return GetLastError();


    PrintMessage( MSG_RESCMD_MOVE, (LPCTSTR) m_strModuleName, strGroupName );

    dwError = ChangeClusterResourceGroup( (HRESOURCE) m_hModule, hDestGroup );

    CloseClusterGroup( hDestGroup );


    if( dwError != ERROR_SUCCESS )
        return dwError;


    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    dwError = PrintStatus( m_strModuleName );


    return dwError;

} //*** CResourceCmd::Move()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Online
//
//  Routine Description:
//      Bring a resource online with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Online( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // Finish command line parsing
    DWORD dwWait = 0;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                int nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                CSyntaxException se; 
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    // Execute command
    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    PrintMessage( MSG_RESCMD_ONLINE, (LPCTSTR) m_strModuleName );

    dwError = OnlineClusterResource( (HRESOURCE) m_hModule );

    if( dwWait && dwError == ERROR_IO_PENDING )
    {
        // If wait is specified open a notify port.
        CClusterNotifyPort port;
        dwError = port.Create( (HCHANGE)INVALID_HANDLE_VALUE, m_hCluster );
        // If notify port fails, should we issue the command?
        port.Register( CLUSTER_CHANGE_RESOURCE_STATE, m_hModule );

        // Check the state before we check the notification port.
        CLUSTER_RESOURCE_STATE crs = GetClusterResourceState( (HRESOURCE) m_hModule, NULL, NULL, NULL, NULL );
        dwError = ERROR_SUCCESS;
        while ( (--dwWait != 0) &&
                (crs == ClusterResourceOnlinePending) )
        {
            dwError = port.GetNotify();
            crs = GetClusterResourceState( (HRESOURCE) m_hModule, NULL, NULL, NULL, NULL );
            if( crs == ClusterResourceOnlinePending )
            {
                dwError = ERROR_IO_PENDING;
            }
            else
            {
                if ( crs == ClusterResourceOnline )
                {
                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    // The cluster resource could not be brought online.
                    // We do not know what the actual error was, so at least 
                    // we don't return ERROR_SUCCESS.
                    dwError = ERROR_RESMON_ONLINE_FAILED;
                }
            }
        }
    }

    if( dwError != ERROR_SUCCESS )
        return dwError;

    // Print status
    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::Online()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Offline
//
//  Routine Description:
//      Take a resource offline with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Offline( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // Finish command line parsing
    DWORD dwWait = 0;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                int nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                CSyntaxException se; 
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    // Execute command
    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    PrintMessage( MSG_RESCMD_OFFLINE, (LPCTSTR) m_strModuleName );

    dwError = OfflineClusterResource( (HRESOURCE) m_hModule );

    if( dwWait && dwError == ERROR_IO_PENDING )
    {
        // If wait is specified open a notify port.
        CClusterNotifyPort port;
        dwError = port.Create( (HCHANGE)INVALID_HANDLE_VALUE, m_hCluster );
        // If notify port fails, should we issue the command?
        port.Register( CLUSTER_CHANGE_RESOURCE_STATE, m_hModule );

        // Check the state before we check the notification port.
        CLUSTER_RESOURCE_STATE crs = GetClusterResourceState( (HRESOURCE) m_hModule, NULL, NULL, NULL, NULL );
        dwError = ERROR_SUCCESS;
        while ( (--dwWait!=0) &&
                (crs == ClusterResourceOfflinePending) )
        {
            dwError = port.GetNotify();
            crs = GetClusterResourceState( (HRESOURCE) m_hModule, NULL, NULL, NULL, NULL );
            if( crs == ClusterResourceOfflinePending )
                dwError = ERROR_IO_PENDING;
            else
                dwError = ERROR_SUCCESS;
        }
    }

    if( dwError != ERROR_SUCCESS )
        return dwError;

    // Print status
    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::Offline()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Fail
//
//  Routine Description:
//      Fail a resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::FailResource( const CCmdLineOption & thisOption ) 
    throw( CSyntaxException )
{
    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    PrintMessage( MSG_RESCMD_FAIL, (LPCTSTR) m_strModuleName );

    dwError = FailClusterResource( (HRESOURCE) m_hModule );

    if( dwError != ERROR_SUCCESS )
        return dwError;

    PrintMessage( MSG_RESOURCE_STATUS_HEADER );
    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::FailResource()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::AddDependency
//
//  Routine Description:
//      Add a resource dependency to the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddDependency( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strDependResource = ( thisOption.GetValues() )[0];

    if( strDependResource.IsEmpty() != FALSE )
    {
        PrintMessage( MSG_NO_NODE_NAME );
        return PrintHelp();
    }


    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HRESOURCE hResourceDep = OpenClusterResource( m_hCluster, strDependResource );

    if( !hResourceDep )
        return GetLastError();

    PrintMessage( MSG_RESCMD_ADDDEP, (LPCTSTR) m_strModuleName, strDependResource );

    dwError = AddClusterResourceDependency( (HRESOURCE) m_hModule, hResourceDep );

    CloseClusterResource( hResourceDep );

    return dwError;

} //*** CResourceCmd::AddDependency()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::RemoveDependency
//
//  Routine Description:
//      Remove a resource dependency
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveDependency( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }


    const CString & strDependResource = ( thisOption.GetValues() )[0];

    if( strDependResource.IsEmpty() != FALSE )
    {
        PrintMessage( MSG_NO_NODE_NAME );
        return PrintHelp();
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    HRESOURCE hResourceDep = OpenClusterResource( m_hCluster, strDependResource );

    if( !hResourceDep )
        return GetLastError();

    PrintMessage( MSG_RESCMD_REMOVEDEP, (LPCTSTR) m_strModuleName, strDependResource );

    dwError = RemoveClusterResourceDependency( (HRESOURCE) m_hModule, hResourceDep );

    CloseClusterResource( hResourceDep );

    return dwError;

} //*** CResourceCmd::RemoveDependency()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::ListDependency
//
//  Routine Description:
//      List the resource depencies
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::ListDependencies( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HRESENUM hEnum = ClusterResourceOpenEnum( (HRESOURCE) m_hModule, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if( !hEnum )
        return GetLastError();


    PrintMessage( MSG_RESCMD_LISTDEP, (LPCTSTR) m_strModuleName );

    PrintMessage( MSG_RESOURCE_STATUS_HEADER );


    DWORD dwIndex = 0;
    DWORD dwType = 0;
    LPWSTR lpszName = 0;

    dwError = ERROR_SUCCESS;

    for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
    {
        dwError = WrapClusterResourceEnum( hEnum, dwIndex, &dwType, &lpszName );
        
        if( dwError == ERROR_SUCCESS )
            PrintStatus( lpszName );

        if( lpszName )
            LocalFree( lpszName );
    }


    if( dwError == ERROR_NO_MORE_ITEMS )
        dwError = ERROR_SUCCESS;

    ClusterResourceCloseEnum( hEnum );

    return dwError;

} //*** CResourceCmd::ListDependencies()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::AddOwner
//
//  Routine Description:
//      Add an owner to the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddOwner( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strNodeName = ( thisOption.GetValues() )[0];

    if( strNodeName.IsEmpty() != FALSE )
    {
        PrintMessage( MSG_NO_NODE_NAME );
        return PrintHelp();
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HNODE hNode = OpenClusterNode( m_hCluster, strNodeName );

    if( !hNode )
        return GetLastError();

    PrintMessage( MSG_RESCMD_ADDNODE, (LPCTSTR) m_strModuleName, strNodeName );

    dwError = AddClusterResourceNode( (HRESOURCE) m_hModule, hNode );

    CloseClusterNode( hNode );

    return dwError;

} //*** CResourceCmd::AddOwner()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::RemoveOwner
//
//  Routine Description:
//      Remove an owner from the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveOwner( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strNodeName = ( thisOption.GetValues() )[0];

    if( strNodeName.IsEmpty() != FALSE )
    {
        PrintMessage( MSG_NO_NODE_NAME );
        return PrintHelp();
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HNODE hNode = OpenClusterNode( m_hCluster, strNodeName );

    if( !hNode )
        return GetLastError();

    PrintMessage( MSG_RESCMD_REMOVENODE, (LPCTSTR) m_strModuleName, strNodeName );

    dwError = RemoveClusterResourceNode( (HRESOURCE) m_hModule, hNode );

    CloseClusterNode( hNode );

    return dwError;

} //*** CResourceCmd::RemoveOwner()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::AddCheckPoints
//
//  Routine Description:
//      Add registry checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were added successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    int nNumberOfCheckPoints = valueList.size();


    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        PrintMessage( IDS_NO_RESOURCE_NAME );
        return PrintHelp();
    }

    dwRetVal = OpenCluster();
    if( dwRetVal != ERROR_SUCCESS )
        return dwRetVal;

    dwRetVal = OpenModule();
    if( dwRetVal != ERROR_SUCCESS )
    {
        CloseCluster();
        return dwRetVal;
    }

    for ( int i = 0; i < nNumberOfCheckPoints; ++i )
    {
        const CString & strCurrentCheckPoint = valueList[i];
        LPCTSTR lpcszInBuffer = strCurrentCheckPoint;

        PrintMessage( 
            MSG_RESCMD_ADDING_REG_CHECKPOINT,
            (LPCTSTR) m_strModuleName, 
            (LPCTSTR) strCurrentCheckPoint 
            );

        dwRetVal = ClusterResourceControl( 
            ( HRESOURCE ) m_hModule, 
            NULL,
            CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT, 
            (LPVOID) ( (LPCTSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( *lpcszInBuffer ), 
            NULL, 
            0, 
            NULL 
            );

        if ( dwRetVal != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return dwRetVal;

} //*** CResourceCmd::AddCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::RemoveCheckPoints
//
//  Routine Description:
//      Remove registry checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were removed successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    int nNumberOfCheckPoints = valueList.size();

    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        PrintMessage( IDS_NO_RESOURCE_NAME );
        return PrintHelp();
    }

    dwRetVal = OpenCluster();
    if( dwRetVal != ERROR_SUCCESS )
        return dwRetVal;

    dwRetVal = OpenModule();
    if( dwRetVal != ERROR_SUCCESS )
    {
        CloseCluster();
        return dwRetVal;
    }

    for ( int i = 0; i < nNumberOfCheckPoints; ++i )
    {
        const CString & strCurrentCheckPoint = valueList[i];

        PrintMessage( 
            MSG_RESCMD_REMOVING_REG_CHECKPOINT,
            (LPCTSTR) m_strModuleName, 
            (LPCTSTR) strCurrentCheckPoint 
            );

        dwRetVal = ClusterResourceControl( 
            ( HRESOURCE ) m_hModule, 
            NULL,
            CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT, 
            (LPVOID) ( (LPCTSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( TCHAR ), 
            NULL, 
            0, 
            NULL 
            );

        if ( dwRetVal != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return dwRetVal;

} //***CResourceCmd::RemoveCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetCheckPoints
//
//  Routine Description:
//      Gets a list of registry checkpoints for one or more resources
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    dwRetVal = OpenCluster();
    if( dwRetVal != ERROR_SUCCESS )
        return dwRetVal;

    // If no resource name is specified list the checkpoints of all resources.
    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        HCLUSENUM hResourceEnum;

        hResourceEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESOURCE  );
        if ( NULL == hResourceEnum )
        {
            dwRetVal = GetLastError();
        }
        else
        {
            CString strCurResName;
            LPWSTR pszNodeNameBuffer;

            // Emperically allocate space for MAX_PATH characters.
            DWORD nResNameBufferSize = MAX_PATH;
            pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );

            PrintMessage( MSG_RESCMD_LISTING_ALL_REG_CHECKPOINTS );
            PrintMessage( MSG_PROPERTY_HEADER_REG_CHECKPOINT );

            for ( DWORD dwIndex = 0; ERROR_SUCCESS == dwRetVal;  )
            {
                DWORD dwObjectType;
                DWORD nInOutBufferSize = nResNameBufferSize;

                dwRetVal = ClusterEnum( hResourceEnum, dwIndex, &dwObjectType, 
                    pszNodeNameBuffer, &nInOutBufferSize );

                // We have enumerated all resources.
                if ( ERROR_NO_MORE_ITEMS == dwRetVal )
                {
                    dwRetVal = ERROR_SUCCESS;
                    break;
                }

                if ( ERROR_MORE_DATA == dwRetVal )
                {
                    dwRetVal = ERROR_SUCCESS;
                    strCurResName.ReleaseBuffer();

                    nResNameBufferSize = nInOutBufferSize + 1;
                    pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );
                }
                else
                {
                    ++dwIndex;

                    if ( ( ERROR_SUCCESS == dwRetVal ) &&
                         ( CLUSTER_ENUM_RESOURCE == dwObjectType ) )
                    {
                        dwRetVal =  GetChkPointsForResource( pszNodeNameBuffer );

                    } // if: we successfully got the name of a resource.

                } // else: We got all the data that ClusterEnum wanted to return.

            } // While there are more resources to be enumerated.

            strCurResName.ReleaseBuffer();

            ClusterCloseEnum( hResourceEnum );
        } // else: hResourceEnum is not NULL.

    } // if: m_strModuleName is empty.
    else
    {
        PrintMessage( MSG_RESCMD_LISTING_REG_CHECKPOINTS, (LPCTSTR) m_strModuleName );
        PrintMessage( MSG_PROPERTY_HEADER_REG_CHECKPOINT );

        dwRetVal = GetChkPointsForResource( m_strModuleName );

    } // else: m_strModuleName is not empty.

    CloseCluster();

    return dwRetVal;

} //*** CResourceCmd::GetCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetChkPointsForResource
//
//  Routine Description:
//      Gets a list of registry checkpoints for one resource
//
//  Arguments:
//      strResourceName [IN]        The name of the resource whose checkpoints 
//                                  are to be listed.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//  Remarks:
//      m_hCluster should contain a valid handle to an open cluster before this
//      function is called.
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetChkPointsForResource( const CString & strResourceName )
{
    DWORD dwRetVal = ERROR_SUCCESS;
    HRESOURCE hCurrentResource;

    hCurrentResource = OpenClusterResource( m_hCluster, strResourceName );
    if ( NULL == hCurrentResource )
    {
        return GetLastError();
    }

    LPTSTR lpmszOutBuffer;
    // Emperically allocate space for MAX_PATH characters. If more is required, we will reallocate.
    DWORD nBufferSize = MAX_PATH * sizeof( *lpmszOutBuffer );
    DWORD nRequiredSize;

    do 
    {
        lpmszOutBuffer = (LPTSTR) LocalAlloc( LMEM_FIXED, nBufferSize );

        if ( NULL == lpmszOutBuffer )
        {
            dwRetVal = GetLastError();
            break;
        }

        dwRetVal = ClusterResourceControl( 
            hCurrentResource, 
            NULL,
            CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS, 
            NULL,
            0, 
            (LPVOID) lpmszOutBuffer, 
            nBufferSize, 
            &nRequiredSize 
            );

        if ( ERROR_MORE_DATA == dwRetVal )
        {
            nBufferSize = nRequiredSize;
            LocalFree( lpmszOutBuffer );
        }
        else
        {
            break;
        }

    } while ( TRUE );

    // We have retrieved the checkpoints successfully.
    if ( ERROR_SUCCESS == dwRetVal )
    {
        LPTSTR pmszCheckPoints = lpmszOutBuffer;

        // There are no checkpoints for this resource.
        if ( 0 == nRequiredSize )
        {
            PrintMessage( MSG_RESCMD_NO_REG_CHECKPOINTS_PRESENT, (LPCTSTR) strResourceName );
        }
        else
        {
            while ( *pmszCheckPoints != L'\0' )
            {
                PrintMessage( MSG_REG_CHECKPOINT_STATUS, (LPCTSTR) strResourceName, pmszCheckPoints );

                // Move to next checkpoint.
                do
                {
                    ++pmszCheckPoints;
                } while ( *pmszCheckPoints != L'\0' );


                // Move past the L'\0'
                ++pmszCheckPoints;

            } // while: There still are checkpoints to be displayed.

        } // else: There is at least one checkpoint to be displayed.

    } // if: ( ERROR_SUCCESS == dwRetVal )


    // LocalFree on NULL is not a problem.
    LocalFree( lpmszOutBuffer );

    CloseClusterResource( hCurrentResource );

    return dwRetVal;

} //*** CResourceCmd::GetChkPointsForResource()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::AddCryptoCheckPoints
//
//  Routine Description:
//      Add crypto key checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were added successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddCryptoCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    int nNumberOfCheckPoints = valueList.size();


    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        PrintMessage( IDS_NO_RESOURCE_NAME );
        return PrintHelp();
    }

    dwRetVal = OpenCluster();
    if( dwRetVal != ERROR_SUCCESS )
        return dwRetVal;

    dwRetVal = OpenModule();
    if( dwRetVal != ERROR_SUCCESS )
    {
        CloseCluster();
        return dwRetVal;
    }

    for ( int i = 0; i < nNumberOfCheckPoints; ++i )
    {
        const CString & strCurrentCheckPoint = valueList[i];
        LPCTSTR lpcszInBuffer = strCurrentCheckPoint;

        PrintMessage( 
            MSG_RESCMD_ADDING_CRYPTO_CHECKPOINT,
            (LPCTSTR) m_strModuleName, 
            (LPCTSTR) strCurrentCheckPoint 
            );

        dwRetVal = ClusterResourceControl( 
            ( HRESOURCE ) m_hModule, 
            NULL,
            CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT, 
            (LPVOID) ( (LPCTSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( *lpcszInBuffer ), 
            NULL, 
            0, 
            NULL 
            );

        if ( dwRetVal != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return dwRetVal;

} //*** AddCryptoCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::RemoveCryptoCheckPoints
//
//  Routine Description:
//      Remove crypto key checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were removed successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveCryptoCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    int nNumberOfCheckPoints = valueList.size();

    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        PrintMessage( IDS_NO_RESOURCE_NAME );
        return PrintHelp();
    }

    dwRetVal = OpenCluster();
    if( dwRetVal != ERROR_SUCCESS )
        return dwRetVal;

    dwRetVal = OpenModule();
    if( dwRetVal != ERROR_SUCCESS )
    {
        CloseCluster();
        return dwRetVal;
    }

    for ( int i = 0; i < nNumberOfCheckPoints; ++i )
    {
        const CString & strCurrentCheckPoint = valueList[i];

        PrintMessage( 
            MSG_RESCMD_REMOVING_CRYPTO_CHECKPOINT,
            (LPCTSTR) m_strModuleName, 
            (LPCTSTR) strCurrentCheckPoint 
            );

        dwRetVal = ClusterResourceControl( 
            ( HRESOURCE ) m_hModule, 
            NULL,
            CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT, 
            (LPVOID) ( (LPCTSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( TCHAR ), 
            NULL, 
            0, 
            NULL 
            );

        if ( dwRetVal != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return dwRetVal;

} //*** CResourceCmd::RemoveCryptoCheckPoints(()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetCryptoCheckPoints
//
//  Routine Description:
//      Gets a list of crypto key checkpoints for one or more resources
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetCryptoCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwRetVal = ERROR_SUCCESS;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se; 
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    dwRetVal = OpenCluster();
    if( dwRetVal != ERROR_SUCCESS )
        return dwRetVal;

    // If no resource name is specified list the checkpoints of all resources.
    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        HCLUSENUM hResourceEnum;

        hResourceEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESOURCE  );
        if ( NULL == hResourceEnum )
        {
            dwRetVal = GetLastError();
        }
        else
        {
            CString strCurResName;
            LPWSTR pszNodeNameBuffer;

            // Emperically allocate space for MAX_PATH characters.
            DWORD nResNameBufferSize = MAX_PATH;
            pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );

            PrintMessage( MSG_RESCMD_LISTING_ALL_CRYPTO_CHECKPOINTS );
            PrintMessage( MSG_PROPERTY_HEADER_CRYPTO_CHECKPOINT );

            for ( DWORD dwIndex = 0; ERROR_SUCCESS == dwRetVal;  )
            {
                DWORD dwObjectType;
                DWORD nInOutBufferSize = nResNameBufferSize;

                dwRetVal = ClusterEnum( hResourceEnum, dwIndex, &dwObjectType, 
                    pszNodeNameBuffer, &nInOutBufferSize );

                // We have enumerated all resources.
                if ( ERROR_NO_MORE_ITEMS == dwRetVal )
                {
                    dwRetVal = ERROR_SUCCESS;
                    break;
                }

                if ( ERROR_MORE_DATA == dwRetVal )
                {
                    dwRetVal = ERROR_SUCCESS;
                    strCurResName.ReleaseBuffer();

                    nResNameBufferSize = nInOutBufferSize + 1;
                    pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );
                }
                else
                {
                    ++dwIndex;

                    if ( ( ERROR_SUCCESS == dwRetVal ) &&
                         ( CLUSTER_ENUM_RESOURCE == dwObjectType ) )
                    {
                        dwRetVal =  GetCryptoChkPointsForResource( pszNodeNameBuffer );

                    } // if: we successfully got the name of a resource.

                } // else: We got all the data that ClusterEnum wanted to return.

            } // While there are more resources to be enumerated.

            strCurResName.ReleaseBuffer();

            ClusterCloseEnum( hResourceEnum );

        } // else: hResourceEnum is not NULL.

    } // if: m_strModuleName is empty.
    else
    {
        PrintMessage( MSG_RESCMD_LISTING_CRYPTO_CHECKPOINTS, (LPCTSTR) m_strModuleName );
        PrintMessage( MSG_PROPERTY_HEADER_CRYPTO_CHECKPOINT );

        dwRetVal = GetCryptoChkPointsForResource( m_strModuleName );

    } // else: m_strModuleName is not empty.

    CloseCluster();

    return dwRetVal;

} //*** CResourceCmd::GetCryptoCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetCryptoChkPointsForResource
//
//  Routine Description:
//      Gets a list of crypto key checkpoints for one resource
//
//  Arguments:
//      strResourceName [IN]        The name of the resource whose checkpoints 
//                                  are to be listed.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//  Remarks:
//      m_hCluster should contain a valid handle to an open cluster before this
//      function is called.
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetCryptoChkPointsForResource( const CString & strResourceName )
{
    DWORD dwRetVal = ERROR_SUCCESS;
    HRESOURCE hCurrentResource;

    hCurrentResource = OpenClusterResource( m_hCluster, strResourceName );
    if ( NULL == hCurrentResource )
    {
        return GetLastError();
    }

    LPTSTR lpmszOutBuffer;
    // Emperically allocate space for MAX_PATH characters. If more is required, we will reallocate.
    DWORD nBufferSize = MAX_PATH * sizeof( *lpmszOutBuffer );
    DWORD nRequiredSize;

    do 
    {
        lpmszOutBuffer = (LPTSTR) LocalAlloc( LMEM_FIXED, nBufferSize );

        if ( NULL == lpmszOutBuffer )
        {
            dwRetVal = GetLastError();
            break;
        }

        dwRetVal = ClusterResourceControl( 
            hCurrentResource, 
            NULL,
            CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS, 
            NULL,
            0, 
            (LPVOID) lpmszOutBuffer, 
            nBufferSize, 
            &nRequiredSize 
            );

        if ( ERROR_MORE_DATA == dwRetVal )
        {
            nBufferSize = nRequiredSize;
            LocalFree( lpmszOutBuffer );
        }
        else
        {
            break;
        }

    } while ( TRUE );

    // We have retrieved the checkpoints successfully.
    if ( ERROR_SUCCESS == dwRetVal )
    {
        LPTSTR pmszCheckPoints = lpmszOutBuffer;

        // There are no checkpoints for this resource.
        if ( 0 == nRequiredSize )
        {
            PrintMessage( MSG_RESCMD_NO_CRYPTO_CHECKPOINTS_PRESENT, (LPCTSTR) strResourceName );
        }
        else
        {
            while ( *pmszCheckPoints != L'\0' )
            {
                PrintMessage( MSG_CRYPTO_CHECKPOINT_STATUS, (LPCTSTR) strResourceName, pmszCheckPoints );

                // Move to next checkpoint.
                do
                {
                    ++pmszCheckPoints;
                } while ( *pmszCheckPoints != L'\0' );


                // Move past the L'\0'
                ++pmszCheckPoints;

            } // while: There still are checkpoints to be displayed.

        } // else: There is at least one checkpoint to be displayed.

    } // if: ( ERROR_SUCCESS == dwRetVal )


    // LocalFree on NULL is not a problem.
    LocalFree( lpmszOutBuffer );

    CloseClusterResource( hCurrentResource );

    return dwRetVal;

} //*** CResourceCmd::GetCryptoChkPointsForResource()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\resgcmd.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

	resgcmd.cpp

Abstract:

	Resource Group Commands
	Implements commands which may be performed on groups

Author:

	Charles Stacy Harris III (stacyh)	20-March-1997
	Michael Burton (t-mburt)			04-Aug-1997


Revision History:


--*/


#include "precomp.h"

#include "cluswrap.h"
#include "resgcmd.h"

#include "cmdline.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::CResGroupCmd
//
//	Routine Description:
//		Constructor
//		Initializes all the DWORD params used by CGenericModuleCmd,
//		CRenamableModuleCmd, and CResourceUmbrellaCmd to
//		provide generic functionality.
//
//	Arguments:
//		IN	const CString & strClusterName
//			Name of the cluster being administered
//
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////

CResGroupCmd::CResGroupCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine ), CRenamableModuleCmd( cmdLine ),
	CResourceUmbrellaCmd( cmdLine )
{
	m_strClusterName = strClusterName;
	m_strModuleName.IsEmpty();

	m_hCluster = NULL;
	m_hModule = NULL;

	m_dwMsgStatusList		   = MSG_GROUP_STATUS_LIST;
	m_dwMsgStatusListAll	   = MSG_GROUP_STATUS_LIST_ALL;
	m_dwMsgStatusHeader 	   = MSG_GROUP_STATUS_HEADER;
	m_dwMsgPrivateListAll	   = MSG_PRIVATE_LISTING_GROUP_ALL;
	m_dwMsgPropertyListAll	   = MSG_PROPERTY_LISTING_GROUP_ALL;
	m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_GROUP_ALL;
	m_dwCtlGetPrivProperties   = CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES;
	m_dwCtlGetCommProperties   = CLUSCTL_GROUP_GET_COMMON_PROPERTIES;
	m_dwCtlGetROPrivProperties = CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES;
	m_dwCtlGetROCommProperties = CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES;
	m_dwCtlSetPrivProperties   = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
	m_dwCtlSetCommProperties   = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
	m_dwClusterEnumModule	   = CLUSTER_ENUM_GROUP;
	m_pfnOpenClusterModule	   = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterGroup;
	m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterGroup;
	m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterGroupControl;
	m_pfnClusterOpenEnum	   = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterGroupOpenEnum;
	m_pfnClusterCloseEnum	   = (DWORD(*)(HCLUSENUM)) ClusterGroupCloseEnum;
	m_pfnWrapClusterEnum		 = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterGroupEnum;

	// Renamable Properties
	m_dwMsgModuleRenameCmd	  = MSG_GROUPCMD_RENAME;
	m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) SetClusterGroupName;

	// Resource Umbrella Properties
	m_dwMsgModuleStatusListForNode	= MSG_GROUP_STATUS_LIST_FOR_NODE;
	m_dwClstrModuleEnumNodes		= CLUSTER_GROUP_ENUM_NODES;
	m_dwMsgModuleCmdListOwnersList	= MSG_GROUPCMD_LISTOWNERS_LIST;
	m_dwMsgModuleCmdListOwnersHeader= MSG_GROUPCMD_LISTOWNERS_HEADER;
	m_dwMsgModuleCmdListOwnersDetail= MSG_GROUPCMD_LISTOWNERS_DETAIL;
	m_dwMsgModuleCmdDelete			= MSG_GROUPCMD_DELETE;
	m_pfnDeleteClusterModule		= (DWORD(*)(HCLUSMODULE)) DeleteClusterGroup;

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::Execute
//
//	Routine Description:
//		Gets the next command line parameter and calls the appropriate
//		handler.  If the command is not recognized, calls Execute of
//		parent classes (first CRenamableModuleCmd, then CRsourceUmbrellaCmd)
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Execute()
{
	try
	{
		m_theCommandLine.ParseStageTwo();
	}
	catch( CException & e )
	{
		PrintString( e.m_strErrorMsg );
		return PrintHelp();
	}

	DWORD dwReturnValue = ERROR_SUCCESS;

	const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

	vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
	vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

	if ( curOption == lastOption )
		return Status( NULL );

	try
	{
		BOOL bContinue = TRUE;

		do
		{
			switch ( curOption->GetType() )
			{
				case optDefault:
				{
					if ( curOption->GetParameters().size() != 1 )
					{
						dwReturnValue = PrintHelp();
						bContinue = FALSE;
						break;

					} // if: this option has the wrong number of values or parameters

					const CCmdLineParameter & param = (curOption->GetParameters())[0];

					// If we are here, then it is either because /node:nodeName
					// has been specified or because a group name has been given.
					// Note that the /node:nodeName switch is not treated as an option.
					// It is really a parameter to the implicit /status command.

					if ( param.GetType() == paramNodeName )
					{
						const vector<CString> & valueList = param.GetValues();

						// This parameter takes exactly one value.
						if ( valueList.size() != 1 )
						{
							CSyntaxException se; 
							se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, param.GetName() );
							throw se;
						}

						m_strModuleName.Empty();
						dwReturnValue = Status( valueList[0], TRUE /* bNodeStatus */ );

					} // if: A node name has been specified
					else
					{
						if ( param.GetType() != paramUnknown )
						{
							dwReturnValue = PrintHelp();
							bContinue = FALSE;
							break;
						}

						// This parameter takes no values.
						if ( param.GetValues().size() != 0 )
						{
							CSyntaxException se; 
							se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
							throw se;
						}

						m_strModuleName = param.GetName();

						// No more options are provided, just show status.
						// For example: cluster myCluster node myNode
						if ( ( curOption + 1 ) == lastOption )
						{
							dwReturnValue = Status( m_strModuleName, FALSE /* bNodeStatus */ );
						}

					} // else: No node name has been specified.

					break;

				} // case optDefault

				case optStatus:
				{
					// This option takes no values.
					if ( curOption->GetValues().size() != 0 )
					{
						CSyntaxException se; 
						se.LoadMessage( MSG_OPTION_NO_VALUES, curOption->GetName() );
						throw se;
					}

					// This option takes no parameters.
					if ( curOption->GetParameters().size() != 0 )
					{
						CSyntaxException se; 
						se.LoadMessage( MSG_OPTION_NO_PARAMETERS, curOption->GetName() );
						throw se;
					}

					dwReturnValue = Status( m_strModuleName,  FALSE /* bNodeStatus */ );
					break;
				}

				case optSetOwners:
				{
					dwReturnValue = SetOwners( *curOption );
					break;
				}

				case optOnline:
				{
					dwReturnValue = Online( *curOption );
					break;
				}

				default:
				{
					dwReturnValue = CRenamableModuleCmd::Execute( *curOption, DONT_PASS_HIGHER );

					if ( dwReturnValue == ERROR_NOT_HANDLED )
						dwReturnValue = CResourceUmbrellaCmd::Execute( *curOption );
				}

			} // switch: based on the type of option

			if ( ( bContinue == FALSE ) || ( dwReturnValue != ERROR_SUCCESS ) )
				break;
			else
				++curOption;

			if ( curOption != lastOption )
				PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
			else
				break;
		}
		while ( TRUE );

	}
	catch ( CSyntaxException & se )
	{
		PrintString( se.m_strErrorMsg );
		dwReturnValue = PrintHelp();
	}

	return dwReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::PrintHelp
//
//	Routine Description:
//		Prints help for Resource Groups
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::PrintHelp()
{
	return PrintMessage( MSG_HELP_GROUP );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::PrintStatus
//
//	Routine Description:
//		Interprets the status of the module and prints out the status line
//		Required for any derived non-abstract class of CGenericModuleCmd
//
//	Arguments:
//		lpszGroupName				Name of the module
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		Same as PrintStatus2
//
//--
/////////////////////////////////////////////////////////////////////////////
inline DWORD CResGroupCmd::PrintStatus( LPCWSTR lpszGroupName )
{
	return PrintStatus2(lpszGroupName, NULL);
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceCmd::PrintStatus2
//
//	Routine Description:
//		Interprets the status of the module and prints out the status line
//		Required for any derived non-abstract class of CGenericModuleCmd
//
//	Arguments:
//		lpszGroupName				Name of the module
//		lpszNodeName				Name of the node
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::PrintStatus2( LPCWSTR lpszGroupName, LPCWSTR lpszNodeName )
{
	DWORD _sc = ERROR_SUCCESS;

	CLUSTER_GROUP_STATE nState;
	LPWSTR lpszGroupNodeName = NULL;

	HGROUP hModule = OpenClusterGroup( m_hCluster, lpszGroupName );
	if (!hModule)
		return GetLastError();

	nState = WrapGetClusterGroupState( hModule, &lpszGroupNodeName );

	if( nState == ClusterGroupStateUnknown )
		return GetLastError();

	// if the node names don't match just return.
	if( lpszNodeName && *lpszNodeName )  // non-null and non-empty
		if( lstrcmpi( lpszGroupNodeName, lpszNodeName ) != 0 )
		{
			LocalFree( lpszGroupNodeName );
			return ERROR_SUCCESS;
		}


	LPWSTR lpszStatus = 0;

	switch( nState )
	{
		case ClusterGroupOnline:
			LoadMessage( MSG_STATUS_ONLINE, &lpszStatus );
			break;

		case ClusterGroupOffline:
			LoadMessage( MSG_STATUS_OFFLINE, &lpszStatus );
			break;

		case ClusterGroupFailed:
			LoadMessage( MSG_STATUS_FAILED, &lpszStatus );
			break;

		case ClusterGroupPartialOnline:
			LoadMessage( MSG_STATUS_PARTIALONLINE, &lpszStatus );
			break;

		case ClusterGroupPending:
			LoadMessage( MSG_STATUS_PENDING, &lpszStatus );
			break;

		default:
			LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
	}

	_sc = PrintMessage( MSG_GROUP_STATUS, lpszGroupName, lpszGroupNodeName, lpszStatus );

	// Since Load/FormatMessage uses LocalAlloc...
	if( lpszStatus )
		LocalFree( lpszStatus );

	if( lpszGroupNodeName )
		LocalFree( lpszGroupNodeName );

	if (hModule)
		CloseClusterGroup(hModule);

	return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::SetOwners
//
//	Routine Description:
//		Set the owner of a resource to the specified nodes
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::SetOwners( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	const vector<CString> & valueList = thisOption.GetValues();

	// This option needs at least one value.
	if ( valueList.size() < 1 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_AT_LEAST_ONE_VALUE, thisOption.GetName() );
		throw se;
	}

	DWORD _sc = OpenCluster();
	if( _sc != ERROR_SUCCESS )
		return _sc;

	_sc = OpenModule();
	if( _sc != ERROR_SUCCESS )
		return _sc;

	UINT nNodeCount = valueList.size();

	HNODE * phNodes = new HNODE[ nNodeCount ];
	if( !phNodes )
		return ERROR_OUTOFMEMORY;

	ZeroMemory( phNodes, nNodeCount * sizeof (HNODE) );


	// Open all the nodes.
	for( UINT i = 0; i < nNodeCount && _sc == ERROR_SUCCESS; i++ )
	{
		phNodes[ i ] = OpenClusterNode( m_hCluster, valueList[i] );
		if( !phNodes[ i ] )
			_sc = GetLastError();
	}

	if( _sc != ERROR_SUCCESS ) 
	{
		delete [] phNodes;
		return _sc;
	}

	// Do the set.
	_sc = SetClusterGroupNodeList( (HGROUP) m_hModule, nNodeCount, phNodes );


	// Close all the nodes.
	for( i = 0; i < nNodeCount; i++ )
		if( phNodes[ i ] )
			CloseClusterNode( phNodes[ i ] );

	delete[] phNodes;

	return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::Create
//
//	Routine Description:
//		Create a resource group.  Does not allow any additional
//		command line parameters (unlike CResourceCmd)
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//		m_hModule					Resource Group Handle
//		m_strModuleName 			Name of resource
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Create( const CCmdLineOption & thisOption ) 
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD _sc = OpenCluster();
	if( _sc != ERROR_SUCCESS )
		return _sc;


	PrintMessage( MSG_GROUPCMD_CREATE, (LPCTSTR) m_strModuleName );

	m_hModule = CreateClusterGroup( m_hCluster, m_strModuleName );

	if( m_hModule == 0 )
	{
		_sc = GetLastError();
		return _sc;
	}

	PrintMessage( MSG_GROUP_STATUS_HEADER );
	PrintStatus( m_strModuleName );

	return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::Move
//
//	Routine Description:
//		Move the resource group to a new node
//		with optional response timeout value.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Move( const CCmdLineOption & thisOption ) 
	throw( CSyntaxException )
{
	DWORD dwWait = 0;			// in seconds
	DWORD _sc;
	CLUSTER_GROUP_STATE oldCgs = ClusterGroupStateUnknown;
	LPWSTR pwszOldNode = NULL;		// Old Node
	HNODE hDestNode = NULL;

	CString strNodeName;
	const vector<CString> & valueList = thisOption.GetValues();
	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
	vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
	vector<CCmdLineParameter>::const_iterator last = paramList.end();
	BOOL bWaitFound = FALSE;

	while( curParam != last )
	{
		const vector<CString> & valueList = curParam->GetValues();

		switch( curParam->GetType() )
		{
			case paramWait:
			{
				if ( bWaitFound != FALSE )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				int nValueCount = valueList.size();

				// This parameter must have exactly one value.
				if ( nValueCount > 1 )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}
				else
				{
					if ( nValueCount == 0 )
						dwWait = CLUS_DEFAULT_TIMEOUT;		// in seconds
					else
						dwWait = _wtoi( valueList[0] );
				}

				bWaitFound = TRUE;
				break;
			}

			default:
			{
				CSyntaxException se; 
				se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
				throw se;
			}

		} // switch: based on the type of the parameter.

		++curParam;
	}


	// This option takes one values.
	if ( valueList.size() > 1 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
		throw se;
	}
	else
	{
		if ( valueList.size() == 0 )
			strNodeName.Empty();
		else
			strNodeName = valueList[0];
	}


	// dummy do-while to avoid gotos
	do
	{
		_sc = OpenCluster();
		if( _sc != ERROR_SUCCESS )
			break;

		_sc = OpenModule();
		if( _sc != ERROR_SUCCESS )
			break;

		// Check to see if there is a value for the destination node and open it
		if( strNodeName.IsEmpty() == FALSE )
		{
			hDestNode = OpenClusterNode( m_hCluster, strNodeName );

			if( hDestNode == NULL )
			{
				_sc = GetLastError();
				break;
			}
		}

		PrintMessage( MSG_GROUPCMD_MOVE, (LPCTSTR) m_strModuleName );
		oldCgs = WrapGetClusterGroupState( (HGROUP) m_hModule, &pwszOldNode );

		if ( oldCgs == ClusterGroupStateUnknown )
		{
			// Some error occurred in WrapGetClusterGroupState.
			// Get this error. Assumes that the error code been preserved by
			// WrapGetClusterGroupState.
			_sc = GetLastError();
			break;
		}

		// If we're moving to the same node, then don't bother.
		if( strNodeName.CompareNoCase( pwszOldNode ) == 0 ) 
		{
			PrintMessage( MSG_GROUP_STATUS_HEADER );
			PrintStatus( m_strModuleName );

			_sc = ERROR_SUCCESS;
			break;
		}

		_sc = ScWrapMoveClusterGroup( m_hCluster, (HGROUP) m_hModule, hDestNode, dwWait );
		if ( _sc != ERROR_SUCCESS )
		{
			break;
		}

		PrintMessage( MSG_GROUP_STATUS_HEADER );
		PrintStatus( m_strModuleName );
	}
	while ( FALSE ); // dummy do-while to avoid gotos

	// LocalFree on NULL is ok.
	LocalFree(pwszOldNode);

	if( hDestNode != NULL )
	{
		CloseClusterNode( hDestNode );
	}

	return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::Online
//
//	Routine Description:
//		Bring a resource group online with optional response timeout value.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Online( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	DWORD dwWait = 0;			// in seconds

	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
	vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
	vector<CCmdLineParameter>::const_iterator last = paramList.end();
	BOOL bWaitFound = FALSE;

	while( curParam != last )
	{
		const vector<CString> & valueList = curParam->GetValues();

		switch( curParam->GetType() )
		{
			case paramWait:
			{
				if ( bWaitFound != FALSE )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				int nValueCount = valueList.size();

				// This parameter must have exactly one value.
				if ( nValueCount > 1 )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}
				else
				{
					if ( nValueCount == 0 )
						dwWait = CLUS_DEFAULT_TIMEOUT;		// in seconds
					else
						dwWait = _wtoi( valueList[0] );
				}

				bWaitFound = TRUE;
				break;
			}

			default:
			{
				CSyntaxException se; 
				se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
				throw se;
			}

		} // switch: based on the type of the parameter.

		++curParam;
	}

	const vector<CString> & valueList = thisOption.GetValues();
	CString strNodeName;

	if ( valueList.size() > 1 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
		throw se;
	}
	else
	{
		if ( valueList.size() == 0 )
			strNodeName.Empty();
		else
			strNodeName = valueList[0];
	}

	// Execute command.
	DWORD _sc = OpenCluster();
	if( _sc != ERROR_SUCCESS )
		return _sc;

	_sc = OpenModule();
	if( _sc != ERROR_SUCCESS )
		return _sc;

	HNODE hDestNode = 0;
	// Check to see if there is a value for the destination node.
	if( strNodeName.IsEmpty() == FALSE )
	{
		hDestNode = OpenClusterNode( m_hCluster, strNodeName );

		if( !hDestNode )
			return GetLastError();
	}

	PrintMessage( MSG_GROUPCMD_ONLINE, (LPCTSTR) m_strModuleName );
	_sc = ScWrapOnlineClusterGroup( m_hCluster, (HGROUP) m_hModule, hDestNode, dwWait );

	if ( _sc == ERROR_SUCCESS )
	{
		PrintMessage( MSG_GROUP_STATUS_HEADER );
		PrintStatus( m_strModuleName );
	}

	if( hDestNode )
		CloseClusterNode( hDestNode );

	return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResGroupCmd::Offline
//
//	Routine Description:
//		Bring a resource group offline with optional response timeout value.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Offline( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// Finish command line parsing
	DWORD dwWait = 0;

	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
	vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
	vector<CCmdLineParameter>::const_iterator last = paramList.end();
	BOOL bWaitFound = FALSE;

	while( curParam != last )
	{
		const vector<CString> & valueList = curParam->GetValues();

		switch( curParam->GetType() )
		{
			case paramWait:
			{
				if ( bWaitFound != FALSE )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				int nValueCount = valueList.size();

				// This parameter must have exactly one value.
				if ( nValueCount > 1 )
				{
					CSyntaxException se; 
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}
				else
				{
					if ( nValueCount == 0 )
						dwWait = CLUS_DEFAULT_TIMEOUT;		// in seconds
					else
						dwWait = _wtoi( valueList[0] );
				}

				bWaitFound = TRUE;
				break;
			}

			default:
			{
				CSyntaxException se; 
				se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
				throw se;
			}

		} // switch: based on the type of the parameter.

		++curParam;
	}

	DWORD _sc = OpenCluster();
	if( _sc != ERROR_SUCCESS )
		return _sc;

	_sc = OpenModule();
	if( _sc != ERROR_SUCCESS )
		return _sc;

	PrintMessage( MSG_GROUPCMD_OFFLINE, (LPCTSTR) m_strModuleName );

	_sc = ScWrapOfflineClusterGroup( m_hCluster, (HGROUP) m_hModule, dwWait );

	if ( _sc == ERROR_SUCCESS )
	{
		PrintMessage( MSG_GROUP_STATUS_HEADER );
		PrintStatus( m_strModuleName );
	}

	return _sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\resgcmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	resgcmd.h

Abstract:

	Interface for functions which may be performed
	on a resource group object

Revision History:

--*/

#ifndef __RESGCMD_H__
#define __RESGCMD_H__

#include "resumb.h"
#include "rename.h"

class CCommandLine;

class CResGroupCmd :	public CRenamableModuleCmd,
						public CResourceUmbrellaCmd
{
public:
	CResGroupCmd( const CString & strClusterName, CCommandLine & cmdLine );

	// Parse and execute the command line
	DWORD Execute();

protected:
	// Specific Commands
	DWORD PrintHelp();

	DWORD PrintStatus( LPCWSTR lpszGroupName );
	DWORD PrintStatus2( LPCWSTR lpszGroupName, LPCWSTR lpszNodeName );

	DWORD SetOwners( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Create( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Delete( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Move( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Online( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Offline( const CCmdLineOption & thisOption ) throw( CSyntaxException );

};



#endif //__RESGCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cluster.rc
//

#define IDS_PASSWORD_PROMPT             1000

#define IDS_CLUSCFG_PROGRESS_FORMAT             1050
#define IDS_CLUSCFG_PREPARING_TO_CREATE_CLUSTER 1051
#define IDS_CLUSCFG_PREPARING_TO_ADD_NODES      1052
#define IDS_CLUSCFG_PREPARING_TO_ADD_NODES_2    1053
#define IDS_CLUSCFG_ANALYZING                   1054
#define IDS_CLUSCFG_CREATING                    1055
#define IDS_CLUSCFG_ADDING_NODES                1056

#define IDS_CLUSCFG_DONE                        1060

#define IDS_TASKID_UNKNOWN                              1100

#define IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER  1101
#define IDS_TASKID_MAJOR_ESTABLISH_CONNECTION           1102
#define IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY         1103
#define IDS_TASKID_MAJOR_FIND_DEVICES                   1104
#define IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY      1105
#define IDS_TASKID_MAJOR_REANALYZE                      1106
#define IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES     1107
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES       1108
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCES            1109

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\restcmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		restcmd.cpp
//
//	Description:
//		Resource Type Commands.
//		Implements commands which may be performed on resource types
//
//	Author:
//		Charles Stacy Harris III (stacyh)	20-March-1997
//		Michael Burton (t-mburt)			04-Aug-1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include "clusudef.h"
#include <cluswrap.h>
#include <ResTypeUtils.h>
#include "restcmd.h"

#include "cmdline.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::CResTypeCmd
//
//	Routine Description:
//		Constructor
//		Initializes all the DWORD params used by CGenericModuleCmd to
//		provide generic functionality.
//
//	Arguments:
//		IN	LPCWSTR lpszClusterName
//			Cluster name. If NULL, opens default cluster.
//
//		IN	CCommandLine & cmdLine
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypeCmd::CResTypeCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	m_hCluster = 0;
	m_strClusterName = strClusterName;
	m_strDisplayName.Empty();

	m_dwMsgStatusList		   = MSG_RESTYPE_STATUS_LIST;
	m_dwMsgStatusListAll	   = MSG_RESTYPE_STATUS_LIST_ALL;
	m_dwMsgStatusHeader 	   = MSG_RESTYPE_STATUS_HEADER;
	m_dwMsgPrivateListAll	   = MSG_PRIVATE_LISTING_RESTYPE_ALL;
	m_dwMsgPropertyListAll	   = MSG_PROPERTY_LISTING_RESTYPE_ALL;
	m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_RESTYPE_ALL;
	m_dwCtlGetPrivProperties   = CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES;
	m_dwCtlGetCommProperties   = CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;
	m_dwCtlGetROPrivProperties = CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES;
	m_dwCtlGetROCommProperties = CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES;
	m_dwCtlSetPrivProperties   = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;
	m_dwCtlSetCommProperties   = CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;
	m_dwClusterEnumModule	   = CLUSTER_ENUM_RESTYPE;
	m_pfnOpenClusterModule	   = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) NULL;
	m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  NULL;
	m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterResourceTypeControl;

} //*** CResTypeCmd::CResTypeCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::~CResTypeCmd
//
//	Routine Description:
//		Destructor
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypeCmd::~CResTypeCmd( void )
{
	CloseCluster();

} //*** CResTypeCmd::~CResTypeCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::OpenModule
//
//	Routine Description:
//		This function does not really open a resource type since resource types
//		don't have handles. It actaully just converts the "display name" of a resource
//		to a type name.
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		m_strModuleName 			The name of the module
//		m_hModule					The handle to the module
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		ERROR_INVALID_DATA			if no display name was specified
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::OpenModule( void )
{
	DWORD _sc = ERROR_SUCCESS;

	// The command line uses the display name of the resource
	if ( m_strDisplayName.IsEmpty() == FALSE )
	{
		LPWSTR _pszTypeName = NULL;

		_sc = ScResDisplayNameToTypeName( m_hCluster, m_strDisplayName, &_pszTypeName );

		if ( _sc == ERROR_SUCCESS )
		{
			m_strModuleName = _pszTypeName;
			LocalFree( _pszTypeName );
		} // if: name converted successfully

	} // if: display name specified
	else
	{
		_sc = ERROR_INVALID_DATA;
	} // else: no display name specified

	return _sc;

} //*** CResTypeCmd::OpenModule()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::Execute
//
//	Routine Description:
//		Gets the next command line parameter and calls the appropriate
//		handler.  If the command is not recognized, calls Execute of
//		parent classes (first CRenamableModuleCmd, then CRsourceUmbrellaCmd)
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::Execute( void )
{
	try
	{
		m_theCommandLine.ParseStageTwo();
	}
	catch( CException & e )
	{
		PrintString( e.m_strErrorMsg );
		return PrintHelp();
	}

	const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

	vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
	vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

	// No options specified. Execute the default command.
	if ( curOption == lastOption )
		return ListResTypes( NULL );

	DWORD dwReturnValue = ERROR_SUCCESS;

	try
	{
		BOOL bContinue = TRUE;

		// Process one option after another.
		do
		{
			// Look up the command
			switch( curOption->GetType() )
			{
				case optHelp:
				{
					// If help is one of the options, process no more options.
					dwReturnValue = PrintHelp();
					bContinue = FALSE;
					break;
				}

				case optDefault:
				{
					const vector<CCmdLineParameter> & paramList = curOption->GetParameters();

					if ( ( paramList.size() != 1 ) ||
						 ( paramList[0].GetType() != paramUnknown ) )
					{
						dwReturnValue = PrintHelp();
						bContinue = FALSE;

					} // if: this option has the wrong number of values or parameters
					else
					{
						const CCmdLineParameter & param = paramList[0];

						// This parameter takes no values.
						if ( param.GetValues().size() != 0 )
						{
							CSyntaxException se;
							se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
							throw se;
						}

						m_strDisplayName = param.GetName();

						// No more options are provided, just show status.
						// For example: cluster myCluster restype myResourceType
						if ( ( curOption + 1 ) == lastOption )
						{
							dwReturnValue = ListResTypes( NULL );
						}

					} // else: this option has the right number of values and parameters

					break;

				} // case optDefault

				case optList:
				{
					dwReturnValue = ListResTypes( curOption );
					break;
				}

				case optCreate:
				{
					dwReturnValue = Create( *curOption );
					break;
				}

				case optDelete:
				{
					dwReturnValue = Delete( *curOption );
					break;
				}

				case optListOwners:
				{
					dwReturnValue = ShowPossibleOwners( *curOption );
					break;
				}

				// ResType does not support the /status option. So, don't pass it
				// on to the base class (which tries to handle /status).
				case optStatus:
				{
					PrintMessage( IDS_INVALID_OPTION, curOption->GetName() );
					dwReturnValue = PrintHelp();
					bContinue = FALSE;
					break;
				}

				default:
				{
					dwReturnValue = CGenericModuleCmd::Execute( *curOption );
				}

			} // switch: based on the type of option

			if ( ( bContinue == FALSE ) || ( dwReturnValue != ERROR_SUCCESS ) )
				break;
			else
				++curOption;

			if ( curOption != lastOption )
				PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
			else
				break;
		}
		while ( TRUE );

	} // try
	catch ( CSyntaxException & se )
	{
		PrintString( se.m_strErrorMsg );
		dwReturnValue = PrintHelp();
	}

	return dwReturnValue;

} //*** CResTypeCmd::Execute()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::PrintHelp
//
//	Routine Description:
//		Prints help for Resource Types
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::PrintHelp( void )
{
	return PrintMessage( MSG_HELP_RESTYPE );

} //*** CResTypeCmd::PrintHelp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::Create
//
//	Routine Description:
//		Create a resource type.  Reads the command line to get
//		additional options
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//		m_hModule					Resource Type Handle
//		m_strDisplayName			Display name of resource type
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::Create( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se;
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	CString strDLLName;
	CString strTypeName;
	DWORD dwLooksAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
	DWORD dwIsAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;

	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
	vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
	vector<CCmdLineParameter>::const_iterator last = paramList.end();
	BOOL bDLLNameFound = FALSE, bTypeFound = FALSE,
		 bIsAliveFound = FALSE, bLooksAliveFound = FALSE;

	while( curParam != last )
	{
		const vector<CString> & valueList = curParam->GetValues();

		switch( curParam->GetType() )
		{
			case paramDLLName:
				// Each of the parameters must have exactly one value.
				if ( valueList.size() != 1 )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}

				if ( bDLLNameFound != FALSE )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				strDLLName = valueList[0];
				bDLLNameFound = TRUE;
				break;

			case paramResType:
				// Each of the parameters must have exactly one value.
				if ( valueList.size() != 1 )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}

				if ( bTypeFound != FALSE )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				strTypeName = valueList[0];
				bTypeFound = TRUE;
				break;

			case paramLooksAlive:
				// Each of the parameters must have exactly one value.
				if ( valueList.size() != 1 )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}

				if ( bLooksAliveFound != FALSE )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				dwLooksAlivePollInterval = _wtol( valueList[0] );
				bLooksAliveFound = TRUE;
				break;

			case paramIsAlive:
				// Each of the parameters must have exactly one value.
				if ( valueList.size() != 1 )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
					throw se;
				}

				if ( bIsAliveFound != FALSE )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				dwIsAlivePollInterval = _wtoi( valueList[0] );
				bIsAliveFound = TRUE;
				break;

			default:
			{
				CSyntaxException se;
				se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
				throw se;
			}
		}

		++curParam;
	}


	// Check for missing parameters.
	if ( strDLLName.IsEmpty() )
	{
		CSyntaxException se;
		se.LoadMessage( MSG_MISSING_DLLNAME );
		throw se;
	}

	if ( strTypeName.IsEmpty() )
		strTypeName = m_strDisplayName;

	// Execute command
	DWORD dwError = OpenCluster();
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = CreateClusterResourceType(
		m_hCluster,
		strTypeName,
		m_strDisplayName,
		strDLLName,
		dwLooksAlivePollInterval,
		dwIsAlivePollInterval );

	if ( dwError == ERROR_SUCCESS )
		PrintMessage( MSG_RESTCMD_CREATE, m_strDisplayName );

	return dwError;

} //*** CResTypeCmd::Create()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::Delete
//
//	Routine Description:
//		Delete a resource type.  Accepts an optional /TYPE parameter
//		to denote that the specified name is a resource type name
//		and not a display name
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//		m_hModule					Resource Type Handle
//		m_strDisplayName			Display name of resource type
//		m_strModuleName 			Name of resource type
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::Delete( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se;
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	CString strResTypeName;

	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
	vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
	vector<CCmdLineParameter>::const_iterator last = paramList.end();
	BOOL bTypeFound = FALSE;

	while( curParam != last )
	{
		const vector<CString> & valueList = curParam->GetValues();

		switch( curParam->GetType() )
		{
			case paramResType:
			{
				// Each of the parameters must have exactly one value.
				if ( valueList.size() != 0 )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_NO_VALUES, curParam->GetName() );
					throw se;
				}

				if ( bTypeFound != FALSE )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				strResTypeName = m_strDisplayName;
				bTypeFound = TRUE;
				break;
			}

			default:
			{
				CSyntaxException se;
				se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
				throw se;
			}

		} // switch: based on the type of the parameter

		++curParam;
	}


	if ( strResTypeName.IsEmpty() != FALSE )
	{
		dwError = OpenModule();
		if ( dwError != ERROR_SUCCESS )
			return dwError;
		strResTypeName = m_strModuleName;
	}

	dwError = DeleteClusterResourceType( m_hCluster, strResTypeName );

	if ( dwError == ERROR_SUCCESS )
		return PrintMessage( MSG_RESTCMD_DELETE, strResTypeName );

	return dwError;

} //*** CResTypeCmd:Delete()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::ShowPossibleOwners
//
//	Routine Description:
//		Display the nodes which can own a resource type.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//		m_hModule					Resource Type Handle
//		m_strDisplayName			Display name of resource type
//		m_strModuleName 			Name of resource type
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::ShowPossibleOwners( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se;
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	CString strResTypeName;

	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
	vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
	vector<CCmdLineParameter>::const_iterator last = paramList.end();
	BOOL bTypeFound = FALSE;

	while( curParam != last )
	{
		const vector<CString> & valueList = curParam->GetValues();

		switch( curParam->GetType() )
		{
			case paramResType:
			{
				// This parameter does not take a value.
				if ( valueList.size() != 0 )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_NO_VALUES, curParam->GetName() );
					throw se;
				}

				if ( bTypeFound != FALSE )
				{
					CSyntaxException se;
					se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
					throw se;
				}

				strResTypeName = m_strDisplayName;
				bTypeFound = TRUE;
				break;
			}

			default:
			{
				CSyntaxException se;
				se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
				throw se;
			}

		} // switch: based on the type of the parameter

		++curParam;
	}


	// The /type switch has not been specified and a display name has been given.
	if ( ( bTypeFound == FALSE ) && ( m_strDisplayName.IsEmpty() == FALSE ) )
	{
		dwError = OpenModule();
		if ( dwError != ERROR_SUCCESS )
			return dwError;
		strResTypeName = m_strModuleName;
	}

	if ( strResTypeName.IsEmpty() != FALSE )
	{
		// No type name is given. Show possible owners of all resource types.

		// If the type name is not specified, no other parameters are allowed.
		if ( thisOption.GetParameters().size() != 0 )
		{
			CSyntaxException se;
			se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
			throw se;
		}

		// Open an enumeration of the resource types.
		HCLUSENUM hClusEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESTYPE );
		if ( hClusEnum == NULL )
		{
			return GetLastError();
		}

		DWORD dwType;
		LPTSTR pszNameBuffer;
		DWORD dwNameBufferSize = 256; // some arbitrary starting buffer size
		DWORD dwRequiredSize = dwNameBufferSize;

		// Allocate a buffer for holding the name of the resource types.
		pszNameBuffer = (LPTSTR) LocalAlloc( LMEM_FIXED, dwNameBufferSize * sizeof( *pszNameBuffer ) );
		if ( pszNameBuffer == NULL )
		{
			ClusterCloseEnum( hClusEnum );
			return GetLastError();
		}

		PrintMessage( MSG_RESTYPE_POSSIBLE_OWNERS_LIST_ALL );
		PrintMessage( MSG_HEADER_RESTYPE_POSSIBLE_OWNERS );

		DWORD dwIndex = 0;
		do
		{
			dwRequiredSize = dwNameBufferSize;
			dwError = ClusterEnum( hClusEnum, dwIndex, &dwType,
								   pszNameBuffer, &dwRequiredSize );

			// Buffer space is insufficient. Allocate some more.
			if ( dwError == ERROR_MORE_DATA )
			{
				// Make space for the NULL character.
				++dwRequiredSize;

				LPTSTR pszNewMemory = (LPTSTR) LocalReAlloc( pszNameBuffer,
															 dwRequiredSize * sizeof( *pszNameBuffer ),
															 LMEM_FIXED );
				if ( pszNewMemory == NULL )
				{
					dwError = GetLastError();
					break;
				}

				pszNameBuffer = pszNewMemory;
				dwNameBufferSize = dwRequiredSize;

				dwError = ClusterEnum( hClusEnum, dwIndex, &dwType,
									   pszNameBuffer, &dwRequiredSize );

			} // if: more buffer space is needed
			else
			{
				// We are finished with the enumeration.
				if ( dwError == ERROR_NO_MORE_ITEMS )
				{
					dwError = ERROR_SUCCESS;
					break;
				}

				// Something went wrong. Don't proceed.
				if ( dwError != ERROR_SUCCESS )
				{
					break;
				}

				dwError = ResTypePossibleOwners( pszNameBuffer );

			} // else: buffer space was sufficient.

			++dwIndex;
		}
		while ( dwError == ERROR_SUCCESS );

		LocalFree( pszNameBuffer );
		ClusterCloseEnum( hClusEnum );

	} // if: no resource type has been specified.
	else
	{
		// Type name found. Show possible owner owners for this resource type only.

		PrintMessage( MSG_RESTYPE_POSSIBLE_OWNERS_LIST, strResTypeName );
		PrintMessage( MSG_HEADER_RESTYPE_POSSIBLE_OWNERS );
		dwError = ResTypePossibleOwners( strResTypeName );

	} // else: resource type name has been specified.


	return dwError;

} //*** CResTypeCmd::ShowPossibleOwners()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::ResTypePossibleOwners
//
//	Routine Description:
//		Display the nodes which can own this particular resource type.
//
//	Arguments:
//		IN	const CString & strResTypeName
//			The possible owners of this resource type are displayed.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::ResTypePossibleOwners( const CString & strResTypeName )
{
	HRESTYPEENUM hResTypeEnum = NULL;
	DWORD dwError = ERROR_SUCCESS;

	hResTypeEnum = ClusterResourceTypeOpenEnum( m_hCluster,
												strResTypeName,
												CLUSTER_RESOURCE_TYPE_ENUM_NODES );

	// Could not open the resource type enumeration
	if ( hResTypeEnum == NULL )
	{
		return GetLastError();
	}

	DWORD dwType;
	LPTSTR pszNameBuffer;
	DWORD dwNameBufferSize = 256; // some arbitrary starting buffer size
	DWORD dwRequiredSize = dwNameBufferSize;

	// Allocate a buffer for holding the name of the possible owner node.
	pszNameBuffer = (LPTSTR) LocalAlloc( LMEM_FIXED, dwNameBufferSize * sizeof( *pszNameBuffer ) );
	if ( pszNameBuffer == NULL )
	{
		ClusterResourceTypeCloseEnum( hResTypeEnum );
		return GetLastError();
	}

	DWORD dwIndex = 0;
	do
	{
		dwRequiredSize = dwNameBufferSize;
		dwError = ClusterResourceTypeEnum( hResTypeEnum, dwIndex, &dwType,
										   pszNameBuffer, &dwRequiredSize );

		// Buffer space is insufficient. Allocate some more.
		if ( dwError == ERROR_MORE_DATA )
		{
			// Make space for the NULL character.
			++dwRequiredSize;

			LPTSTR pszNewMemory = (LPTSTR) LocalReAlloc( pszNameBuffer,
														 dwRequiredSize * sizeof( *pszNameBuffer ),
														 LMEM_FIXED );
			if ( pszNewMemory == NULL )
			{
				dwError = GetLastError();
				break;
			}

			pszNameBuffer = pszNewMemory;
			dwNameBufferSize = dwRequiredSize;

			dwError = ClusterResourceTypeEnum( hResTypeEnum, dwIndex, &dwType,
											   pszNameBuffer, &dwRequiredSize );

		} // if: more buffer space is needed
		else
		{
			// We are finished with the enumeration.
			if ( dwError == ERROR_NO_MORE_ITEMS )
			{
				dwError = ERROR_SUCCESS;
				break;
			}

			// Something went wrong. Don't proceed.
			if ( dwError != ERROR_SUCCESS )
			{
				break;
			}

			PrintMessage( MSG_RESTYPE_POSSIBLE_OWNERS, strResTypeName, pszNameBuffer );

		} // else: buffer space was sufficient.

		++dwIndex;
	}
	while ( TRUE );

	LocalFree( pszNameBuffer );

	ClusterResourceTypeCloseEnum( hResTypeEnum );

	return dwError;

} // CResTypeCmd::ResTypePossibleOwners(

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::DoProperties
//
//	Routine Description:
//		Dispatches the property command to either Get, Set, or All properties
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	PropertyType ePropertyType
//			The type of property, PRIVATE or COMMON
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strDisplayName			Name of module.  If non-NULL, prints
//									out properties for the specified module.
//									Otherwise, prints props for all modules.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::DoProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType )
	throw( CSyntaxException )
{
	DWORD dwError;

	if ( m_strDisplayName.IsEmpty() != FALSE )
		return AllProperties( thisOption, ePropType );

	dwError = OpenCluster();
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

	// If there are no property-value pairs on the command line,
	// then we print the properties otherwise we set them.
	if( paramList.size() == 0 )
	{
		PrintMessage( ePropType==PRIVATE ? MSG_PRIVATE_LISTING : MSG_PROPERTY_LISTING,
			(LPCTSTR) m_strModuleName );
		PrintMessage( m_dwMsgPropertyHeaderAll );
		return GetProperties( thisOption, ePropType, m_strModuleName);
	}
	else
		return SetProperties( thisOption, ePropType );

} //*** CResTypeCmd::DoProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::GetProperties
//
//	Routine Description:
//		Prints out properties for the specified module
//		Needs to take into account the fact that it doesn't actually
//		open a handle to a resource type, so this function overrides the
//		default in CGenericModuleCmd
//
//	Arguments:
//		IN	const vector<CCmdLineParameter> & paramList
//			Contains the list of property-value pairs to be set
//
//		IN	PropertyType ePropertyType
//			The type of property, PRIVATE or COMMON
//
//		IN	LPCWSTR lpszResTypeName
//			Name of the module
//
//	Member variables used / set:
//		m_hModule					Module handle
//		m_strModuleName 			Name of resource type
//
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::GetProperties( const CCmdLineOption & thisOption,
								  PropertyType ePropType, LPCWSTR lpszResTypeParam )
{
	assert( m_hCluster != NULL );

	DWORD dwError = ERROR_SUCCESS;
	LPCWSTR lpszResTypeName;

	// If no lpszResTypeName specified, use current resource type,
	if ( ! lpszResTypeParam )
	{
		lpszResTypeName = m_strModuleName;
	}
	else
	{
		lpszResTypeName = lpszResTypeParam;
	}


	// Use the proplist helper class.
	CClusPropList PropList;


	// Get R/O properties
	DWORD dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES
							 : CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES;

	dwError = PropList.ScGetResourceTypeProperties(
		m_hCluster,
		lpszResTypeName,
		dwControlCode
		);

	if ( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = PrintProperties( PropList, thisOption.GetValues(), READONLY, lpszResTypeParam );
	if ( dwError != ERROR_SUCCESS )
		return dwError;

	// Get R/W properties
	dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
							   : CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;

	dwError = PropList.ScGetResourceTypeProperties(
		m_hCluster,
		lpszResTypeName,
		dwControlCode
		);

	if ( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = PrintProperties( PropList, thisOption.GetValues(), READWRITE, lpszResTypeParam );

	return dwError;

} //*** CResTypeCmd::GetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::SetProperties
//
//	Routine Description:
//		Set the properties for the specified module
//		Needs to take into account the fact that it doesn't actually
//		open a handle to a resource type, so this function overrides the
//		default in CGenericModuleCmd
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	PropertyType ePropertyType
//			The type of property, PRIVATE or COMMON
//
//	Member variables used / set:
//		m_hModule					Module handle
//		m_strModuleName 			Name of resource type
//
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::SetProperties( const CCmdLineOption & thisOption,
								  PropertyType ePropType )
	throw( CSyntaxException )
{
	assert( m_hCluster != NULL );

	DWORD dwError = ERROR_SUCCESS;
	DWORD dwControlCode;
	DWORD dwBytesReturned = 0;


	// Use the proplist helper class.
	CClusPropList CurrentProps;
	CClusPropList NewProps;

	LPCWSTR lpszResTypeName = m_strModuleName;

	// First get the existing properties...
	dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
									   : CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;

	dwError = CurrentProps.ScGetResourceTypeProperties(
		m_hCluster,
		lpszResTypeName,
		dwControlCode
		);

	if ( dwError != ERROR_SUCCESS )
		return dwError;


	// If values have been specified with this option, then it means that we want
	// to set these properties to their default values. So, there has to be
	// exactly one parameter and it has to be /USEDEFAULT.
	if ( thisOption.GetValues().size() != 0 )
	{
		const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

		if ( paramList.size() != 1 )
		{
			CSyntaxException se;

			se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR, thisOption.GetName() );
			throw se;
		}

		if ( paramList[0].GetType() != paramUseDefault )
		{
			CSyntaxException se;

			se.LoadMessage( MSG_INVALID_PARAMETER, paramList[0].GetName() );
			throw se;
		}

		// This parameter does not take any values.
		if ( paramList[0].GetValues().size() != 0 )
		{
			CSyntaxException se;

			se.LoadMessage( MSG_PARAM_NO_VALUES, paramList[0].GetName() );
			throw se;
		}

		dwError = ConstructPropListWithDefaultValues( CurrentProps, NewProps, thisOption.GetValues() );
		if( dwError != ERROR_SUCCESS )
			return dwError;

	} // if: values have been specified with this option.
	else
	{
		dwError = ConstructPropertyList( CurrentProps, NewProps, thisOption.GetParameters() );
		if ( dwError != ERROR_SUCCESS )
			return dwError;
	}


	// Call the set function...
	dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES
							 : CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;

	dwBytesReturned = 0;
	dwError = ClusterResourceTypeControl(
		m_hCluster,
		lpszResTypeName,
		NULL, // hNode
		dwControlCode,
		NewProps.Plist(),
		NewProps.CbBufferSize(),
		0,
		0,
		&dwBytesReturned );

	return dwError;

} //*** CResTypeCmd::SetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::ListResTypes
//
//	Routine Description:
//		Prints out all the available resource types.  Akin to Status
//		for most other modules
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_strDisplayName			Name of module.  If non-NULL, prints
//									out info for the specified module.
//									Otherwise, prints props for all modules.
//
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::ListResTypes( const CCmdLineOption * pOption )
	throw( CSyntaxException )
{
	DWORD			dwError				= ERROR_SUCCESS;

	// pOption will be NULL if this function has been called as the
	// default action.
	if ( pOption != NULL )
	{
		// This option takes no values.
		if ( pOption->GetValues().size() != 0 )
		{
			CSyntaxException se;
			se.LoadMessage( MSG_OPTION_NO_VALUES, pOption->GetName() );
			throw se;
		}

		// This option takes no parameters.
		if ( pOption->GetParameters().size() != 0 )
		{
			CSyntaxException se;
			se.LoadMessage( MSG_OPTION_NO_PARAMETERS, pOption->GetName() );
			throw se;
		}
	}

	// dummy do-while loop to avoid gotos
	do
	{
		HCLUSENUM	hEnum;
		DWORD		dwIndex;
		DWORD		dwType			= 0;
		LPWSTR		pszName			= NULL;

		dwError = ERROR_SUCCESS;

		dwError = OpenCluster();
		if ( dwError != ERROR_SUCCESS )
		{
			break;
		}

		if ( m_strDisplayName.IsEmpty() == FALSE )
		{
			PrintMessage( MSG_RESTYPE_STATUS_LIST, m_strDisplayName );
			PrintMessage( MSG_RESTYPE_STATUS_HEADER );
			dwError = PrintResTypeInfo( m_strDisplayName );
			break;
		}

		hEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESTYPE );
		if( hEnum == NULL )
		{
			dwError = GetLastError();
			break;
		}

		PrintMessage( MSG_RESTYPE_STATUS_LIST_ALL );
		PrintMessage( MSG_RESTYPE_STATUS_HEADER );

		for ( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
		{
			dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &pszName );
			if ( dwError == ERROR_SUCCESS )
			{
				PrintResTypeInfo( pszName ); // option.svValue == nodename
			}

			// LocalFree on NULL is ok.
			LocalFree( pszName );
		}

		if( dwError == ERROR_NO_MORE_ITEMS )
			dwError = ERROR_SUCCESS;

		ClusterCloseEnum( hEnum );
	}
	while ( FALSE ); // dummy do-while loop to avoid gotos

	return dwError;

} //*** CResTypeCmd::ListResTypes()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeCmd::PrintResTypeInfo
//
//	Routine Description:
//		Prints out info for the specified resource type
//
//	Arguments:
//		pszResTypeName 				Name of the resource type
//
//	Member variables used / set:
//		m_hCluster					Cluster handle
//
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::PrintResTypeInfo( LPCWSTR pszResTypeName )
{
	DWORD	_sc				= ERROR_SUCCESS;
	LPWSTR	_pszDisplayName	= NULL;

	_sc = ScResTypeNameToDisplayName( m_hCluster, pszResTypeName, &_pszDisplayName );
	if ( _sc == ERROR_SUCCESS )
	{
		PrintMessage( MSG_RESTYPE_STATUS, _pszDisplayName, pszResTypeName );
	} // if:  resource type name information retrieved successfully
	else
	{
		PrintMessage( MSG_RESTYPE_STATUS_ERROR, pszResTypeName );
	}

	LocalFree( _pszDisplayName );

	return _sc;

} //*** CResTypeCmd::PrintResTypeInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\resumb.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	cluscmd.h

Abstract:

	This module defines the interface available for several
	additional generic functions available to resource modules
	
Revision History:

--*/

#ifndef __RESUMB_H__
#define __RESUMB_H__

#include "modcmd.h"

class CResourceUmbrellaCmd : virtual public CGenericModuleCmd
{
public:
	CResourceUmbrellaCmd( CCommandLine & cmdLine );

protected:
	virtual DWORD Execute( const CCmdLineOption & option, 
						   ExecuteOption eEOpt = PASS_HIGHER_ON_ERROR  )
		throw( CSyntaxException );

	DWORD Status( const CCmdLineOption * pOption ) throw( CSyntaxException )
	{
		return CGenericModuleCmd::Status( pOption );
	}

	DWORD Status( const CString & strName, BOOL bNodeStatus );

	DWORD Delete( const CCmdLineOption & Command ) throw( CSyntaxException );
	DWORD ListOwners( const CCmdLineOption & Command ) throw( CSyntaxException );

	virtual DWORD Create( const CCmdLineOption & Command ) throw( CSyntaxException ) = 0;
	virtual DWORD Offline( const CCmdLineOption & Command ) throw( CSyntaxException ) = 0;
	virtual DWORD Move( const CCmdLineOption & Command ) throw( CSyntaxException ) = 0;

	virtual DWORD PrintStatus2( LPCWSTR lpszModuleName, LPCWSTR lpszNodeName ) = 0;

	DWORD m_dwMsgModuleStatusListForNode;
	DWORD m_dwMsgModuleCmdListOwnersList;
	DWORD m_dwMsgModuleCmdListOwnersDetail;
	DWORD m_dwMsgModuleCmdListOwnersHeader;
	DWORD m_dwClstrModuleEnumNodes;
	DWORD m_dwMsgModuleCmdDelete;
	DWORD (*m_pfnDeleteClusterModule)(HCLUSMODULE);

};


#endif // __RESUMB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\restcmd.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

	restcmd.h

Abstract:

	Interface for functions which may be performed
	on a resource type object

Revision History:

--*/

#ifndef __RESTCMD_H__
#define __RESTCMD_H__

#include "modcmd.h"

class CCommandLine;

class CResTypeCmd : public CGenericModuleCmd
{
public:
	CResTypeCmd( const CString & strClusterName, CCommandLine & cmdLine );
	~CResTypeCmd();

	// Parse and execute the command line
	DWORD Execute() throw( CSyntaxException );

protected:
	CString m_strDisplayName;

	DWORD OpenModule();

	// Specifc Commands
	DWORD PrintHelp();

	DWORD Create( const CCmdLineOption & thisOption ) 
		throw( CSyntaxException );

	DWORD Delete( const CCmdLineOption & thisOption ) 
		throw( CSyntaxException );

	DWORD CResTypeCmd::ResTypePossibleOwners( const CString & strResTypeName ) ;

	DWORD ShowPossibleOwners( const CCmdLineOption & thisOption ) 
		throw( CSyntaxException );

	DWORD PrintStatus( LPCWSTR ) {return ERROR_SUCCESS;}
	
	DWORD DoProperties( const CCmdLineOption & thisOption,
						PropertyType ePropType )
		throw( CSyntaxException );

	DWORD GetProperties( const CCmdLineOption & thisOption, PropertyType ePropType, 
						 LPCWSTR lpszResTypeName );

	DWORD SetProperties( const CCmdLineOption & thisOption,
						 PropertyType ePropType )
		throw( CSyntaxException );


	DWORD ListResTypes( const CCmdLineOption * pOption )
		throw( CSyntaxException );

	DWORD PrintResTypeInfo( LPCWSTR lpszResTypeName );

};


#endif // __RESTCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\token.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  Module Name:
//      token.cpp
//
//  Abstract:
//      Definition of valid token strings.
//
//  Author:
//      Vijayendra Vasu (vvasu)     October 20, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  Include files
/////////////////////////////////////////////////////////////////////////////
#include "token.h"
#include <clusapi.h>

/////////////////////////////////////////////////////////////////////////////
//  Global variables
/////////////////////////////////////////////////////////////////////////////

// Separator and delimiters.

// Seperators are special types of tokens.
const CString OPTION_SEPARATOR( TEXT("/-") );
const CString OPTION_VALUE_SEPARATOR( TEXT(":") );
const CString PARAM_VALUE_SEPARATOR( TEXT("=") );
const CString VALUE_SEPARATOR( TEXT(",") );

const CString SEPERATORS( OPTION_SEPARATOR +
                          OPTION_VALUE_SEPARATOR +
                          PARAM_VALUE_SEPARATOR +
                          VALUE_SEPARATOR );        

// Delimiters mark the end of a token.
// Whitespaces and end of input are also delimiters.
// Note: "-" and "/" are not delimiters. They can occur in a token.
// For example: cluster-1 is a valid token.
const CString DELIMITERS( OPTION_VALUE_SEPARATOR + 
                          PARAM_VALUE_SEPARATOR +
                          VALUE_SEPARATOR );


// Lookup tables and their sizes.

const LookupStruct<ObjectType> objectLookupTable[] =
{
    // Default value
    { TEXT("Invalid Object"),   objInvalid },

    // Node
    { TEXT("Node"),             objNode },

    // Group
    { TEXT("ResourceGroup"),    objGroup },
    { TEXT("ResGroup"),         objGroup },
    { TEXT("Group"),            objGroup },

    // Resource
    { TEXT("Resource"),         objResource },
    { TEXT("Res"),              objResource },

    { TEXT("ResourceType"),     objResourceType },
    { TEXT("ResType"),          objResourceType },
    { TEXT("Type"),             objResourceType },

    // Network
    { TEXT("Network"),          objNetwork },
    { TEXT("Net"),              objNetwork },
    
    // Network Interface
    { TEXT("NetInt"),           objNetInterface },
    { TEXT("NetInterface"),     objNetInterface }
};

const int objectLookupTableSize = sizeof( objectLookupTable ) / 
                                  sizeof( objectLookupTable[0] );


const LookupStruct<OptionType> optionLookupTable[] =
{
    { TEXT("Invalid Option"),       optInvalid },

    //   Common options
    { TEXT("?"),                    optHelp },
    { TEXT("Help"),                 optHelp },

    { TEXT("Create"),               optCreate },

    { TEXT("Delete"),               optDelete },
    { TEXT("Del"),                  optDelete },

    { TEXT("Move"),                 optMove },
    { TEXT("MoveTo"),               optMove },

    { TEXT("List"),                 optList },

    { TEXT("ListOwners"),           optListOwners },

    { TEXT("Online"),               optOnline },
    { TEXT("On"),                   optOnline },

    { TEXT("Offline"),              optOffline },
    { TEXT("Off"),                  optOffline },

    { TEXT("Properties"),           optProperties },
    { TEXT("Prop"),                 optProperties },
    { TEXT("Props"),                optProperties },

    { TEXT("PrivProperties"),       optPrivateProperties },
    { TEXT("PrivProp"),             optPrivateProperties },
    { TEXT("PrivProps"),            optPrivateProperties },
    { TEXT("Priv"),                 optPrivateProperties },

    { TEXT("Rename"),               optRename },
    { TEXT("Ren"),                  optRename },

    { TEXT("Status"),               optStatus },
    { TEXT("State"),                optStatus },
    { TEXT("Stat"),                 optStatus },


    // Cluster options
    { TEXT("Quorum"),               optQuorumResource },
    { TEXT("QuorumResource"),       optQuorumResource },

    { TEXT("Version"),              optVersion },
    { TEXT("Ver"),                  optVersion },

    { TEXT("SetFail"),              optSetFailureActions },
    { TEXT("SetFailureActions"),    optSetFailureActions },

    { TEXT("RegExt"),               optRegisterAdminExtensions },
    { TEXT("RegAdminExt"),          optRegisterAdminExtensions },

    { TEXT("UnRegExt"),             optUnregisterAdminExtensions },
    { TEXT("UnRegAdminExt"),        optUnregisterAdminExtensions },

    { TEXT("Add"),                  optAddNodes },
    { TEXT("AddNode"),              optAddNodes },
    { TEXT("AddNodes"),             optAddNodes },

    // Node options
    { TEXT("Pause"),                optPause },

    { TEXT("Resume"),               optResume },

    { TEXT("Evict"),                optEvict },

    { TEXT("Force"),                optForceCleanup },
    { TEXT("ForceCleanup"),         optForceCleanup },

    { TEXT("Start"),                optStartService },

    { TEXT("Stop"),                 optStopService },


    // Group options
    { TEXT("SetOwners"),            optSetOwners },

    
    // Resource options 
    { TEXT("AddChk"),               optAddCheckPoints },
    { TEXT("AddCheck"),             optAddCheckPoints },
    { TEXT("AddChkPoints"),         optAddCheckPoints },
    { TEXT("AddCheckPoints"),       optAddCheckPoints },

    { TEXT("AddCryptoChk"),         optAddCryptoCheckPoints },
    { TEXT("AddCryptoCheck"),       optAddCryptoCheckPoints },
    { TEXT("AddCryptoChkPoints"),   optAddCryptoCheckPoints },
    { TEXT("AddCryptoCheckPoints"), optAddCryptoCheckPoints },

    { TEXT("AddDep"),               optAddDependency },
    { TEXT("AddDependency"),        optAddDependency },

    { TEXT("AddOwner"),             optAddOwner },

    { TEXT("Fail"),                 optFail },

    { TEXT("Chk"),                  optGetCheckPoints },
    { TEXT("Check"),                optGetCheckPoints },
    { TEXT("ChkPoints"),            optGetCheckPoints },
    { TEXT("CheckPoints"),          optGetCheckPoints },

    { TEXT("CryptoChk"),            optGetCryptoCheckPoints },
    { TEXT("CryptoCheck"),          optGetCryptoCheckPoints },
    { TEXT("CryptoChkPoints"),      optGetCryptoCheckPoints },
    { TEXT("CryptoCheckPoints"),    optGetCryptoCheckPoints },

    { TEXT("ListDep"),              optListDependencies },
    { TEXT("ListDependencies"),     optListDependencies },

    { TEXT("RemoveDep"),            optRemoveDependency },
    { TEXT("RemoveDependency"),     optRemoveDependency },

    { TEXT("RemoveOwner"),          optRemoveOwner },
    { TEXT("RemOwner"),             optRemoveOwner },

    { TEXT("RemoveChk"),            optRemoveCheckPoints },
    { TEXT("RemoveCheck"),          optRemoveCheckPoints },
    { TEXT("RemoveChkPoints"),      optRemoveCheckPoints },
    { TEXT("RemoveCheckPoints"),    optRemoveCheckPoints },


    { TEXT("RemoveCryptoChk"),          optRemoveCryptoCheckPoints },
    { TEXT("RemoveCryptoCheck"),        optRemoveCryptoCheckPoints },
    { TEXT("RemoveCryptoChkPoints"),    optRemoveCryptoCheckPoints },
    { TEXT("RemoveCryptoCheckPoints"),  optRemoveCryptoCheckPoints },


    // Resource type options
    { TEXT("ListOwners"),           optListOwners },


    // Network options
    { TEXT("ListInt"),              optListInterfaces },
    { TEXT("ListInterface"),        optListInterfaces },
    { TEXT("ListInterfaces"),       optListInterfaces }

};

const int optionLookupTableSize = sizeof( optionLookupTable ) / 
                                  sizeof( optionLookupTable[0] );


const LookupStruct<ParameterType> paramLookupTable[] =
{
    { TEXT("Unknown parameter"),    paramUnknown },
    { TEXT("C"),                    paramCluster },
    { TEXT("Cluster"),              paramCluster },
    { TEXT("DisplayName"),          paramDisplayName },
    { TEXT("DLL"),                  paramDLLName },
    { TEXT("DLLName"),              paramDLLName },
    { TEXT("Group"),                paramGroupName },
    { TEXT("IsAlive"),              paramIsAlive },
    { TEXT("LooksAlive"),           paramLooksAlive },
    { TEXT("MaxLogSize"),           paramMaxLogSize },
    { TEXT("Net"),                  paramNetworkName },
    { TEXT("Network"),              paramNetworkName },
    { TEXT("Node"),                 paramNodeName },
    { TEXT("Path"),                 paramPath },
    { TEXT("ResourceType"),         paramResType },
    { TEXT("ResType"),              paramResType },
    { TEXT("Type"),                 paramResType },
    { TEXT("Separate"),             paramSeparate },
    { TEXT("UseDefault"),           paramUseDefault },
    { TEXT("Wait"),                 paramWait },
    { TEXT("User"),                 paramUser },
    { TEXT("Password"),             paramPassword },
    { TEXT("Pass"),                 paramPassword },
    { TEXT("IPAddress"),            paramIPAddress },
    { TEXT("IPAddr"),               paramIPAddress },
    { TEXT("Verbose"),              paramVerbose },
    { TEXT("Verb"),                 paramVerbose },
    { TEXT("Wiz"),                  paramWizard },
    { TEXT("Wizard"),               paramWizard }
};

const int paramLookupTableSize = sizeof( paramLookupTable ) / 
                                 sizeof( paramLookupTable[0] );


const LookupStruct<ValueFormat> formatLookupTable[] =
{
    { TEXT(""),                     vfInvalid },
    { TEXT("BINARY"),               vfBinary },
    { TEXT("DWORD"),                vfDWord },
    { TEXT("STR"),                  vfSZ },
    { TEXT("STRING"),               vfSZ },
    { TEXT("EXPANDSTR"),            vfExpandSZ },
    { TEXT("EXPANDSTRING"),         vfExpandSZ },
    { TEXT("MULTISTR"),             vfMultiSZ },
    { TEXT("MULTISTRING"),          vfMultiSZ },
    { TEXT("SECURITY"),             vfSecurity },
    { TEXT("ULARGE"),               vfULargeInt }
};

const int formatLookupTableSize = sizeof( formatLookupTable ) / 
                                  sizeof( formatLookupTable[0] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\token.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		token.h
//
//	Abstract:
//		This file contains the declaration of the tokens that are valid on the
//		command line of cluster.exe
//
//	Implementation File:
//		token.cpp
//
//	Author:
//		Vijayendra Vasu (vvasu)	October 20, 1998
//
//	Revision History:
//		001. This  has been drastically changed from the previous version.
//			 The tokens have now been categorized into three types: objects,
//			 options and parameters (enumerated in the file cmdline.h). This
//			 functions in this file help categorize tokens into these 
//			 categories.
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __TOKEN_H__
#define __TOKEN_H__


/////////////////////////////////////////////////////////////////////////////
//	Include files
/////////////////////////////////////////////////////////////////////////////
#include "cmdline.h"


/////////////////////////////////////////////////////////////////////////////
//	Type definitions
/////////////////////////////////////////////////////////////////////////////
template <class EnumType> struct LookupStruct
{
	LPCTSTR pszName;
	EnumType type;
};


/////////////////////////////////////////////////////////////////////////////
//	External variable declarations
/////////////////////////////////////////////////////////////////////////////

extern const LookupStruct<ObjectType> objectLookupTable[];
extern const LookupStruct<OptionType> optionLookupTable[];
extern const LookupStruct<ParameterType> paramLookupTable[];
extern const LookupStruct<ValueFormat> formatLookupTable[];

extern const int objectLookupTableSize;
extern const int optionLookupTableSize;
extern const int paramLookupTableSize;
extern const int formatLookupTableSize;


// Separator character constants.
extern const CString OPTION_SEPARATOR;
extern const CString OPTION_VALUE_SEPARATOR;
extern const CString PARAM_VALUE_SEPARATOR;
extern const CString VALUE_SEPARATOR;

extern const CString SEPERATORS;
extern const CString DELIMITERS;


/////////////////////////////////////////////////////////////////////////////
//	Template function definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	LookupType
//
//	Routine Description:
//		This template function looks up a particular token in a lookup table
//		and returns the type of the token if found.
//
//	Arguments:
//		IN	const CString & strToken
//			The token to be looked up
//
//		IN	struct LookupStruct<EnumType> lookupTable[]
//			The lookup table. This table must have at least one entry and the 
//			first entry must be the default type (the type to be returned if
//			the given token is not found.
//
//		IN	const int nTableSize
//			Size of the lookup table.
//
//	Return Value:
//		The type of the token if it is found or the type specified in the first
//		entry of the lookup table if it is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
template <class EnumType>
EnumType LookupType( const CString & strToken, 
					 const LookupStruct<EnumType> lookupTable[],
					 const int nTableSize )
{
	for ( int i = 1; i < nTableSize; ++i )
	{
		if ( strToken.CompareNoCase( lookupTable[i].pszName ) == 0 )
			return lookupTable[i].type;
	}
	
	// The given token is not found in the lookup table
	// lookupTable[0].type contains the default return value.
	return lookupTable[0].type;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	LookupName
//
//	Routine Description:
//		This template function looks up a particular type in a lookup table
//		and returns the name of the type if found.
//
//	Arguments:
//		IN	EnumType type
//			The type whose name is to be looked up
//
//		IN	struct LookupStruct<EnumType> lookupTable[]
//			The lookup table. This table must have at least one entry and the 
//			first entry must be the default type (the type to be returned if
//			the given token is not found.
//
//		IN	const int nTableSize
//			Size of the lookup table.
//
//	Return Value:
//		The name of the token if it is found or the name specified in the first
//		entry of the lookup table if it is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
template <class EnumType>
LPCTSTR LookupName( EnumType type, 
					const LookupStruct<EnumType> lookupTable[],
					const int nTableSize )
{
	for ( int i = 1; i < nTableSize; ++i )
	{
		if ( type == lookupTable[i].type )
			return lookupTable[i].pszName;
	}
	
	// The given type is not found in the lookup table
	// lookupTable[0].pszName contains the default return value.
	return lookupTable[0].pszName;
}

#endif //__TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\resumb.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

	resumb.cpp

Abstract:

	Universal resource commands supported by multiple
	resource modules


Author:

	Michael Burton (t-mburt)			25-Aug-1997


Revision History:
	

--*/

#include "resumb.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::CResourceUmbrellaCmd
//
//	Routine Description:
//		Default Constructor
//		Initializes all the DWORD parameters to UNDEFINED and
//		all the pointers to cluster functions to NULL.
//		*ALL* these variables must be defined in any derived class.
//
//	Arguments:
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		A bunch.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceUmbrellaCmd::CResourceUmbrellaCmd( CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	m_dwMsgModuleStatusListForNode	= UNDEFINED;
	m_dwClstrModuleEnumNodes		= UNDEFINED;
	m_dwMsgModuleCmdListOwnersList	= UNDEFINED;
	m_dwMsgModuleCmdDelete			= UNDEFINED;
	m_dwMsgModuleCmdListOwnersHeader= UNDEFINED;
	m_dwMsgModuleCmdListOwnersDetail= UNDEFINED;
	m_pfnDeleteClusterModule		= (DWORD(*)(HCLUSMODULE)) NULL;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::Execute
//
//	Routine Description:
//		Takes a command line option and determines which command to
//		execute.  If no command line option specified, gets the next one
//		automatically.	If the token is not identied as being handle-able
//		in this class, the token is passed up to CGenericModuleCmd::Execute
//		unless DONT_PASS_HIGHER is specified as the second parameter, 
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	ExecuteOption eEOpt							
//			OPTIONAL enum, either DONT_PASS_HIGHER or
//			PASS_HIGHER_ON_ERROR (default)
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::Execute( const CCmdLineOption & option, 
									 ExecuteOption eEOpt )
	throw( CSyntaxException )
{
	// Look up the command
	switch( option.GetType() )
	{
		case optCreate:
			return Create( option );

		case optDelete:
			return Delete( option );

		case optMove:
			return Move( option );

		case optOffline:
			return Offline( option );

		case optListOwners:
			return ListOwners( option );

		default:
			if ( eEOpt == PASS_HIGHER_ON_ERROR )
				return CGenericModuleCmd::Execute( option );
			else
				return ERROR_NOT_HANDLED;
	}
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::Status
//
//	Routine Description:
//		Prints out the status of the module.  Differs from
//		CGenericModuleCmd::Status in that it accepts additional
//		parameters.
//
//	Arguments:
//		IN	const CString & strName
//			This string contains either the name of a node or of a group,
//			depending on the next argument.
//
//		IN	BOOL bNodeStatus
//			TRUE if we want the status at a particular node.
//			FALSE otherwise.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_strModuleName 			Name of module.  If non-NULL, Status() prints
//									out the status of the specified module.
//									Otherwise, prints status of all modules.
//		m_dwMsgStatusList			Field titles for listing status of module
//		m_dwMsgStatusHeader 		Header for statuses
//		m_dwClusterEnumModule		Command for opening enumeration
//		m_dwMsgStatusListAll		Message for listing status of multiple modules
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::Status( const CString & strName, BOOL bNodeStatus )
{
	DWORD dwError = ERROR_SUCCESS;

	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	if ( bNodeStatus == FALSE )
	{
		// List one resource
		if( m_strModuleName.IsEmpty() == FALSE )
		{
			assert(m_dwMsgStatusList != UNDEFINED && m_dwMsgStatusHeader != UNDEFINED);
			PrintMessage( m_dwMsgStatusList, (LPCTSTR) m_strModuleName );
			PrintMessage( m_dwMsgStatusHeader );
			return PrintStatus( m_strModuleName );
		}

	} // if: we don't want the status only at a particular node.
	else
	{
		// List all modules.
		HNODE hTargetNode;

		hTargetNode = OpenClusterNode( m_hCluster, strName );

		// Error if the given node does not exist.
		if ( NULL == hTargetNode )
		{
			return GetLastError();
		}
		else
		{
			CloseClusterNode( hTargetNode );
		}

	} // else: we want the status at a particular node.

	HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, m_dwClusterEnumModule );

	if( !hEnum )
		return GetLastError();


	if ( bNodeStatus != FALSE )
		PrintMessage( m_dwMsgModuleStatusListForNode, strName );
	else
		PrintMessage( m_dwMsgStatusListAll );

	PrintMessage( m_dwMsgStatusHeader );


	DWORD dwIndex = 0;
	DWORD dwType = 0;
	LPWSTR lpszName = NULL;

	dwError = ERROR_SUCCESS;

	for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
	{

		dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );
			
		if( dwError == ERROR_SUCCESS )
			PrintStatus2( lpszName, strName );

		if( lpszName )
			LocalFree( lpszName );
	}


	if( dwError == ERROR_NO_MORE_ITEMS )
		dwError = ERROR_SUCCESS;

	ClusterCloseEnum( hEnum );

	return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::Delete
//
//	Routine Description:
//		Delete a resource module.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource type
//		m_dwMsgModuleCmdDelete		Delete module message
//		m_pfnDeleteClusterModule	Function to delete cluster module
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::Delete( const CCmdLineOption & thisOption ) 
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;


	assert(m_dwMsgModuleCmdDelete != UNDEFINED);
	PrintMessage( m_dwMsgModuleCmdDelete, (LPCTSTR) m_strModuleName );

	assert(m_pfnDeleteClusterModule);
	return m_pfnDeleteClusterModule( m_hModule );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::ListOwners
//
//	Routine Description:
//		List the owners of a module.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource type
//		m_pfnClusterOpenEnum		Function to open an enumeration
//		m_dwClstrModuleEnumNodes	Command to enumerate nodes
//		m_dwMsgModuleCmdListOwnersList	List owners for module field header
//		m_dwMsgModuleCmdListOwnersHeader List owners for module header
//		m_pfnWrapClusterEnum		Function to enumeration wrapper
//		m_dwMsgModuleCmdListOwnersDetail List owners detail list
//		m_pfnClusterCloseEnum		Function to close enumeration
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::ListOwners( const CCmdLineOption & thisOption ) 
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
		CSyntaxException se; 
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;


	assert(m_pfnClusterOpenEnum);
	assert(m_dwClstrModuleEnumNodes != UNDEFINED);
	HCLUSENUM hEnum = m_pfnClusterOpenEnum( m_hModule, m_dwClstrModuleEnumNodes );
	if( !hEnum )
		return GetLastError();

	assert (m_strModuleName);
	PrintMessage( m_dwMsgModuleCmdListOwnersList, (LPCTSTR) m_strModuleName);
	PrintMessage( m_dwMsgModuleCmdListOwnersHeader );

	DWORD dwIndex = 0;
	DWORD dwType = 0;
	LPWSTR lpszName = 0;

	dwError = ERROR_SUCCESS;

	assert(m_pfnWrapClusterEnum);
	assert(m_dwMsgModuleCmdListOwnersDetail != UNDEFINED);
	for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
	{
		dwError = m_pfnWrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );
			
		if( dwError == ERROR_SUCCESS )
			PrintMessage( m_dwMsgModuleCmdListOwnersDetail, lpszName );

		if( lpszName )
			LocalFree( lpszName );
	}


	if( dwError == ERROR_NO_MORE_ITEMS )
		dwError = ERROR_SUCCESS;

	assert(m_pfnClusterCloseEnum);
	m_pfnClusterCloseEnum( hEnum );

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\util.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2000 Microsoft Corporation
//
//  Module Name:
//      Util.h
//
//  Description:
//      Utility funtions and structures.
//
//  Maintained By:
//      Vij Vasu (VVasu)    26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <aclapi.h>
#include "cmderror.h"
#include "PropList.h"
#include "cluswrap.h"
#include "cmdline.h"

enum PropertyAttrib
{
    READONLY,
    READWRITE
};

DWORD PrintString( LPCWSTR lpszMessage );

DWORD PrintSystemError( DWORD dwError, LPCWSTR pszPad = NULL );

DWORD PrintMessage( DWORD dwMessage, ... );

DWORD LoadMessage( DWORD dwMessage, LPWSTR * ppMessage );

DWORD PrintProperties( CClusPropList &PropList,
                       const vector<CString> & vstrFilterList,
                       PropertyAttrib eReadOnly,
                       LPCWSTR lpszOwnerName = NULL,
                       LPCWSTR lpszNetIntSpecific = NULL);

DWORD ConstructPropListWithDefaultValues(
    CClusPropList &             CurrentProps,
    CClusPropList &             newPropList,
    const vector< CString > &   vstrPropNames
    );

DWORD ConstructPropertyList( CClusPropList &CurrentProps, CClusPropList &NewProps,
                             const vector<CCmdLineParameter> & paramList,
                             BOOL bClusterSecurity = FALSE )
    throw( CSyntaxException );

DWORD
WaitGroupQuiesce(
    IN HCLUSTER hCluster,
    IN HGROUP   hGroup,
    IN LPWSTR   lpszGroupName,
    IN DWORD    dwWaitTime
    );

DWORD CheckForRequiredACEs(
            PSECURITY_DESCRIPTOR pSD
          ) 
          throw( CSyntaxException );

void MakeExplicitAccessList( 
        const vector<CString> & vstrValues,
        vector<EXPLICIT_ACCESS> &vExplicitAccess,
        BOOL bClusterSecurity = FALSE
        )
        throw( CSyntaxException );

DWORD ScMakeSecurityDescriptor(  
            const CString & strPropName,
            CClusPropList & CurrentProps,
            const vector<CString> & vstrValues,
            PSECURITY_DESCRIPTOR * pSelfRelativeSD,
            BOOL bClusterSecurity = FALSE
          ) 
          throw( CSyntaxException );

DWORD MyStrToULongLong( LPCWSTR lpszNum, ULONGLONG * pullValue );
DWORD MyStrToBYTE( LPCWSTR lpszNum, BYTE * pByte );
DWORD MyStrToDWORD( LPCWSTR lpszNum, DWORD * dwVal );
DWORD MyStrToLONG( LPCWSTR lpszNum, LONG * lVal );
BOOL isNegativeNum( LPWSTR lpszNum );
BOOL isValidNum( LPWSTR lpszNum );

HRESULT
HrGetFQDNName(
      LPCWSTR   pcwszNameIn
    , BSTR *    pbstrFQDNOut
    );

HRESULT
HrGetLocalNodeFQDNName(
    BSTR *  pbstrFQDNOut
    );

HRESULT
HrGetLoggedInUserDomain(
    BSTR * pbstrDomainOut
    );

DWORD
DwGetPassword(
      LPWSTR    pwszPasswordOut
    , DWORD     cchPasswordIn
    );

BOOL
MatchCRTLocaleToConsole( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluster\util.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      util.cpp
//
//  Description:
//      Utility functions and structures.
//
//  Maintained By:
//      David Potter (DavidP)               04-MAY-2001
//      Michael Burton (t-mburt)            04-Aug-1997
//      Charles Stacy Harris III (stacyh)   20-March-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include <limits.h>     // ULONG_MAX, LONG_MIN, LONG_MAX
#include <errno.h>      // errno

#include <clusrtl.h>
#include "cluswrap.h"
#include "util.h"
#include "token.h"

#include <dnslib.h>     // DNS_MAX_NAME_BUFFER_LENGTH
#include <security.h>   // GetUserNameEx
#include <Wincon.h>     // ReadConsole, etc.
#include <Dsgetdc.h>
#include <Lm.h>

/////////////////////////////////////////////////////////////////////////////
//  Lookup tables
/////////////////////////////////////////////////////////////////////////////

const LookupStruct<CLUSTER_PROPERTY_FORMAT> formatCharLookupTable[] =
{
    { TEXT(""),                     CLUSPROP_FORMAT_UNKNOWN },
    { TEXT("B"),                    CLUSPROP_FORMAT_BINARY },
    { TEXT("D"),                    CLUSPROP_FORMAT_DWORD },
    { TEXT("S"),                    CLUSPROP_FORMAT_SZ },
    { TEXT("E"),                    CLUSPROP_FORMAT_EXPAND_SZ },
    { TEXT("M"),                    CLUSPROP_FORMAT_MULTI_SZ },
    { TEXT("I"),                    CLUSPROP_FORMAT_ULARGE_INTEGER },
    { TEXT("L"),                    CLUSPROP_FORMAT_LONG },
    { TEXT("X"),                    CLUSPROP_FORMAT_EXPANDED_SZ },
    { TEXT("U"),                    CLUSPROP_FORMAT_USER }
};

const int formatCharLookupTableSize = sizeof( formatCharLookupTable ) /
                                      sizeof( formatCharLookupTable[0] );


const LookupStruct<CLUSTER_PROPERTY_FORMAT> cluspropFormatLookupTable[] =
{
    { TEXT("UNKNOWN"),              CLUSPROP_FORMAT_UNKNOWN },
    { TEXT("BINARY"),               CLUSPROP_FORMAT_BINARY },
    { TEXT("DWORD"),                CLUSPROP_FORMAT_DWORD },
    { TEXT("STRING"),               CLUSPROP_FORMAT_SZ },
    { TEXT("EXPANDSTRING"),         CLUSPROP_FORMAT_EXPAND_SZ },
    { TEXT("MULTISTRING"),          CLUSPROP_FORMAT_MULTI_SZ },
    { TEXT("ULARGE"),               CLUSPROP_FORMAT_ULARGE_INTEGER }
};

const int cluspropFormatLookupTableSize = sizeof( cluspropFormatLookupTable ) /
                                          sizeof( cluspropFormatLookupTable[0] );


const ValueFormat ClusPropToValueFormat[] =
{
    vfInvalid,
    vfBinary,
    vfDWord,
    vfSZ,
    vfExpandSZ,
    vfMultiSZ,
    vfULargeInt,
    vfInvalid,
    vfInvalid
};

const LookupStruct<ACCESS_MODE> accessModeLookupTable[] =
{
    { _T( "" ),         NOT_USED_ACCESS },
    { _T( "GRANT" ),    GRANT_ACCESS    },
    { _T( "DENY" ),     DENY_ACCESS     },
    { _T( "SET" ),      SET_ACCESS      },
    { _T( "REVOKE" ),   REVOKE_ACCESS   }
};

// Access right specifier characters.
const TCHAR g_FullAccessChar = _T('F');
const TCHAR g_ReadAccessChar = _T('R');
const TCHAR g_ChangeAccessChar = _T('C');


const int accessModeLookupTableSize = sizeof( accessModeLookupTable ) /
                                      sizeof( accessModeLookupTable[0] );



#define MAX_BUF_SIZE 2048

DWORD
PrintProperty(
    LPCWSTR                 pwszPropName,
    CLUSPROP_BUFFER_HELPER  PropValue,
    PropertyAttrib          eReadOnly,
    LPCWSTR                 lpszOwnerName,
    LPCWSTR                 lpszNetIntSpecific
    );


#ifdef UNICODE
PWCHAR
PaddedString(
    IN LONG Size,
    IN PWCHAR String
    );

LONG
SizeOfHalfWidthString(
    IN PWCHAR String
    );

BOOL
IsFullWidth(
    IN WCHAR Char
    );
#endif // def UNICODE

//
// Local functions.
//

/////////////////////////////////////////////////////////////////////////////
//++
//
//  MyPrintMessage
//
//  Routine Description:
//      Replacement printing routine.
//
//  Arguments:
//      IN  struct _iobuf * lpOutDevice
//          The output stream.
//
//      IN  LPCWSTR lpMessage
//          The message to print.
//
//  Return Value:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
MyPrintMessage(
    struct _iobuf *lpOutDevice,
    LPCWSTR lpMessage
    )

{
    DWORD   _sc = ERROR_SUCCESS;
    DWORD   dwStrlen;
    PCHAR   lpMultiByteStr;
    DWORD   cchMultiByte;

#ifdef UNICODE
    dwStrlen = WideCharToMultiByte( CP_OEMCP,
                                    0,
                                    lpMessage,
                                    -1,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
    if ( dwStrlen == 0 ) {
        _sc = GetLastError();
        return(_sc);
    }

#if 0
    paddedMessage = PaddedString( dwStrlen,
                                  lpMessage );
#endif
    lpMultiByteStr = (PCHAR)LocalAlloc( LMEM_FIXED, dwStrlen );
    if ( lpMultiByteStr == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    cchMultiByte = dwStrlen;

    dwStrlen = WideCharToMultiByte( CP_OEMCP,
                                    0,
                                    lpMessage,
                                    -1,
                                    lpMultiByteStr,
                                    cchMultiByte,
                                    NULL,
                                    NULL );
    if ( dwStrlen == 0 ) {
        LocalFree( lpMultiByteStr );
        _sc = GetLastError();
        return(_sc);
    }

    //zap! print to stderr or stdout depending on severity...
    fprintf( lpOutDevice, "%s", lpMultiByteStr );

    LocalFree( lpMultiByteStr );

#else

    //zap! print to stderr or stdout depending on severity...
    fwprintf( dwOutDevice, L"%s", lpMessage );

#endif

    return(_sc);

} //*** MyPrintMessage()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintSystemError
//
//  Routine Description:
//      Print a system error.
//
//  Arguments:
//      IN  DWORD dwError
//          The system error code.
//
//      IN  LPCWSTR pszPad
//          Padding to add before displaying the message.
//
//  Return Value:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintSystemError( DWORD dwError, LPCWSTR pszPad )
{
    DWORD   _cch;
    TCHAR   _szError[512];
    DWORD   _sc = ERROR_SUCCESS;

//  if( IS_ERROR( dwError ) ) why doesn't this work...

    // Don't display "System error ..." if all that happened was the user
    // canceled the wizard.
    if ( dwError != ERROR_CANCELLED )
    {
        if ( pszPad != NULL )
        {
            MyPrintMessage( stdout, pszPad );
        }
        if ( dwError == ERROR_RESOURCE_PROPERTIES_STORED )
        {
            PrintMessage( MSG_WARNING, dwError );
        } // if:
        else
        {
            PrintMessage( MSG_ERROR, dwError );
        } // else:
    } // if: not ERROR_CANCELLED

    // Format the NT status code from the system.
    _cch = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    _szError,
                    sizeof(_szError) / sizeof(TCHAR),
                    0
                    );
    if (_cch == 0)
    {
        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ::GetModuleHandle(_T("NTDLL.DLL")),
                        dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                        _szError,
                        sizeof(_szError) / sizeof(TCHAR),
                        0
                        );

        if (_cch == 0)    
        {
            // One last chance: see if ACTIVEDS.DLL can format the status code
            HMODULE activeDSHandle = ::LoadLibrary(_T("ACTIVEDS.DLL"));

            _cch = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            activeDSHandle,
                            dwError,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                            _szError,
                            sizeof(_szError) / sizeof(TCHAR),
                            0
                            );

            ::FreeLibrary( activeDSHandle );
        }  // if:  error formatting status code from NTDLL
    }  // if:  error formatting status code from system

    if (_cch == 0)
    {
        _sc = GetLastError();
        PrintMessage( MSG_ERROR_CODE_ERROR, _sc, dwError );
    }  // if:  error formatting the message
    else
    {
#if 0 // TODO: 29-AUG-2000 DAVIDP Need to print only once.
        if ( pszPad != NULL )
        {
            MyPrintMessage( stdout, pszPad );
        }
        MyPrintMessage( stdout, _szError );
#endif
        MyPrintMessage( stderr, _szError );
    } // else: message formatted without problems   

    return _sc;

} //*** PrintSystemError()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintMessage
//
//  Routine Description:
//      Print a message with substitution strings to stdout.
//
//  Arguments:
//      IN  DWORD dwMessage
//          The ID of the message to load from the resource file.
//
//      ... Any parameters to FormatMessage.
//
//  Return Value:
//      Any status codes from MyPrintMessage.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintMessage( DWORD dwMessage, ... )
{
    DWORD _sc = ERROR_SUCCESS;

    va_list args;
    va_start( args, dwMessage );

    HMODULE hModule = GetModuleHandle(0);
    DWORD dwLength;
    LPWSTR  lpMessage = 0;

    dwLength = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        (LPCVOID)hModule,
        dwMessage,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language,
        (LPWSTR)&lpMessage,
        0,
        &args );

    if( dwLength == 0 )
    {
        // Keep as local for debug
        _sc = GetLastError();
        return _sc;
    }

    _sc = MyPrintMessage( stdout, lpMessage );

    LocalFree( lpMessage );

    va_end( args );

    return _sc;

} //*** PrintMessage()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  LoadMessage
//
//  Routine Description:
//      Load a message from the resource file.
//
//  Arguments:
//      IN  DWORD dwMessage
//          The ID of the message to load.
//
//      OUT LPWSTR * ppMessage
//          Pointer in which to return the buffer allocated by this routine.
//          The caller must call LocalFree on the resulting buffer.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was successful.
//      Other Win32 codes.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD LoadMessage( DWORD dwMessage, LPWSTR * ppMessage )
{
    DWORD _sc = ERROR_SUCCESS;

    HMODULE hModule = GetModuleHandle(0);
    DWORD dwLength;
    LPWSTR  lpMessage = 0;

    dwLength = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        (LPCVOID)hModule,
        dwMessage,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language,
        (LPWSTR)&lpMessage,
        0,
        0 );

    if( dwLength == 0 )
    {
        // Keep as local for debug
        _sc = GetLastError();
        return _sc;
    }

    *ppMessage = lpMessage;

    return _sc;

} //*** LoadMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintString
//
//  Routine Description:
//      Print a string to stdout.
//
//  Arguments:
//      IN  LPCWSTR lpszMessage
//          The message to print.
//
//  Return Value:
//      Any status codes from MyPrintMessage.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintString( LPCWSTR lpszMessage )
{
    return MyPrintMessage( stdout, lpszMessage );

} //*** PrintString()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  MakeExplicitAccessList
//
//  Routine Description:
//      This function takes a list of strings in the format:
//        trustee1,accessMode1,[accessMask1],trustee2,accessMode2,[accessMask2], ...
//      and creates an vector or EXPLICIT_ACCESS structures.
//
//  Arguments:
//      IN  const CString & strPropName
//          Name of the property whose value is the old SD
//
//      IN  BOOL bClusterSecurity
//          Indicates that access list is being created for the security descriptor
//          of a cluster.
//          Default value is false.
//
//      OUT vector<EXPLICIT_ACCESS> &vExplicitAccess
//          A vector of EXPLICIT_ACCESS structures each containing access control
//          information for one trustee.
//
//  Return Value:
//      None
//
//  Exceptions:
//      CSyntaxException
//
//--
/////////////////////////////////////////////////////////////////////////////
void MakeExplicitAccessList(
        const vector<CString> & vstrValues,
        vector<EXPLICIT_ACCESS> &vExplicitAccess,
        BOOL bClusterSecurity
        )
        throw( CSyntaxException )
{
    int nNumberOfValues = vstrValues.size();
    vExplicitAccess.clear();

    int nIndex = 0;
    while ( nIndex < nNumberOfValues )
    {
        // Trustee name is at position nIndex in the vector of values.
        const CString & curTrustee = vstrValues[nIndex];
        DWORD dwInheritance;

        ++nIndex;
        // If there are no more values, it is an error. The access mode has
        // to be specified when the user name has been specified.
        if ( nIndex >= nNumberOfValues )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_PARAM_SECURITY_MODE_ERROR,
                            curTrustee );

            throw se;
        }

        // Get the access mode.
        const CString & strAccessMode = vstrValues[nIndex];
        ACCESS_MODE amode = LookupType(
                                strAccessMode,
                                accessModeLookupTable,
                                accessModeLookupTableSize );

        if ( amode == NOT_USED_ACCESS )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_PARAM_SECURITY_MODE_ERROR,
                            curTrustee );

            throw se;
        }

        ++nIndex;

        DWORD dwAccessMask = 0;

        // If the specified access mode was REVOKE_ACCESS then no further values
        // are required. Otherwise atleast one more value must exist.
        if ( amode != REVOKE_ACCESS )
        {
            if ( nIndex >= nNumberOfValues )
            {
                CSyntaxException se;
                se.LoadMessage( MSG_PARAM_SECURITY_MISSING_RIGHTS,
                                curTrustee );

                throw se;
            }

            LPCTSTR pstrRights = vstrValues[nIndex];
            ++nIndex;

            while ( *pstrRights != _T('\0') )
            {
                TCHAR cRight = towupper( *pstrRights );

                switch ( cRight )
                {
                    // Read Access
                    case g_ReadAccessChar:
                    {
                        // If bClusterSecurity is TRUE, then full access is the only valid
                        // access right that can be specified.
                        if ( bClusterSecurity != FALSE )
                        {
                            CSyntaxException se;
                            se.LoadMessage( MSG_PARAM_SECURITY_FULL_ACCESS_ONLY,
                                            curTrustee,
                                            *pstrRights,
                                            g_FullAccessChar );

                            throw se;
                        }

                        dwAccessMask = FILE_GENERIC_READ | FILE_EXECUTE;
                    }
                    break;

                    // Change Access
                    case g_ChangeAccessChar:
                    {
                        // If bClusterSecurity is TRUE, then full access is the only valid
                        // access right that can be specified.
                        if ( bClusterSecurity != FALSE )
                        {
                            CSyntaxException se;
                            se.LoadMessage( MSG_PARAM_SECURITY_FULL_ACCESS_ONLY,
                                            curTrustee,
                                            *pstrRights,
                                            g_FullAccessChar );

                            throw se;
                        }

                        dwAccessMask = SYNCHRONIZE | READ_CONTROL | DELETE |
                                       FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA |
                                       FILE_APPEND_DATA | FILE_WRITE_DATA;
                    }
                    break;

                    // Full Access
                    case 'F':
                    {
                        if ( bClusterSecurity != FALSE )
                        {
                            dwAccessMask = CLUSAPI_ALL_ACCESS;
                        }
                        else
                        {
                            dwAccessMask = FILE_ALL_ACCESS;
                        }
                    }
                    break;

                    default:
                    {
                        CSyntaxException se;
                        se.LoadMessage( MSG_PARAM_SECURITY_RIGHTS_ERROR,
                                        curTrustee );

                        throw se;
                    }

                } // switch: Based on the access right type

                ++pstrRights;

            } // while: there are more access rights specified

        } // if: access mode is not REVOKE_ACCESS

        dwInheritance = NO_INHERITANCE;

        EXPLICIT_ACCESS oneACE;
        BuildExplicitAccessWithName(
            &oneACE,
            const_cast<LPTSTR>( (LPCTSTR) curTrustee ),
            dwAccessMask,
            amode,
            dwInheritance );

        vExplicitAccess.push_back( oneACE );

    } // while: There are still values to be processed in the value list.
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CheckForRequiredACEs
//
//  Description:
//      This function makes sure that the security that is passed in has
//      access allowed ACES for thosee accounts required to have access to
//      a cluster.
//
//  Arguments:
//      IN  const SECURITY_DESCRIPTOR *pSD
//          Pointer to the Security Descriptor to be checked.
//          This is assumed to point to a valid Security Descriptor.
//
//  Return Value:
//      Return ERROR_SUCCESS on success or an error code indicating failure.
//
//  Exceptions:
//      CSyntaxException is thrown if the required ACEs are missing.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CheckForRequiredACEs(
            PSECURITY_DESCRIPTOR pSD
          )
          throw( CSyntaxException )
{
    DWORD                   _sc = ERROR_SUCCESS;
    CSyntaxException        se;
    PSID                    vpRequiredSids[] = { NULL, NULL };
    DWORD                   vmsgAceNotFound[] = {
                                                  MSG_PARAM_SYSTEM_ACE_MISSING,
                                                  MSG_PARAM_ADMIN_ACE_MISSING
                                                };
    int                     nSidIndex;
    int                     nRequiredSidCount = sizeof( vpRequiredSids ) / sizeof( vpRequiredSids[0] );
    BOOL                    bRequiredSidsPresent = FALSE;

    do // dummy do-while to avoid gotos
    {
        PACL                        pDACL           = NULL;
        BOOL                        bHasDACL        = FALSE;
        BOOL                        bDaclDefaulted  = FALSE;
        ACL_SIZE_INFORMATION        asiAclSize;
        ACCESS_ALLOWED_ACE *        paaAllowedAce = NULL;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;


        if ( ( AllocateAndInitializeSid(            // Allocate System SID
                    &siaNtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &vpRequiredSids[0]
             ) == 0 ) ||
             ( AllocateAndInitializeSid(            // Allocate Domain Admins SID
                    &siaNtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &vpRequiredSids[1]
             ) == 0 ) )
        {
            _sc = GetLastError();
            break;
        }

        if ( GetSecurityDescriptorDacl( pSD, &bHasDACL, &pDACL, &bDaclDefaulted ) == 0 )
        {
            _sc = GetLastError();
            break;
        }

        // SD does not have DACL. No access is denied for everyone.
        if ( bHasDACL == FALSE )
        {
            break;
        }

        // NULL DACL means access is allowed to everyone.
        if ( pDACL == NULL )
        {
            bRequiredSidsPresent = TRUE;
            break;
        }

        if ( IsValidAcl( pDACL ) == FALSE )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        }

        if ( GetAclInformation(
                pDACL,
                (LPVOID) &asiAclSize,
                sizeof( asiAclSize ),
                AclSizeInformation
                ) == 0 )
        {
            _sc = GetLastError();
            break;
        }

            // Check for the required SIDs.
        for ( nSidIndex = 0; ( nSidIndex < nRequiredSidCount ) && ( _sc == ERROR_SUCCESS ); ++nSidIndex )
        {
            bRequiredSidsPresent = FALSE;

            // Search the ACL for the required SIDs.
            for ( DWORD nAceCount = 0; nAceCount < asiAclSize.AceCount; nAceCount++ )
            {
                if ( GetAce( pDACL, nAceCount, (LPVOID *) &paaAllowedAce ) == 0 )
                {
                    _sc = GetLastError();
                    break;
                }

                if ( paaAllowedAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
                {
                    if ( EqualSid( &paaAllowedAce->SidStart, vpRequiredSids[nSidIndex] ) != FALSE)
                    {
                        bRequiredSidsPresent = TRUE;
                        break;

                    } // if: EqualSid

                } // if: is this an access allowed ace?

            } // for: loop through all the ACEs in the DACL.

            // This required SID is not present.
            if ( bRequiredSidsPresent == FALSE )
            {
                se.LoadMessage( vmsgAceNotFound[nSidIndex] );
                break;
            }
        } // for: loop through all SIDs that need to be checked.
    }
    while ( FALSE ); // dummy do-while to avoid gotos

    // Free the allocated Sids.
    for ( nSidIndex = 0; nSidIndex < nRequiredSidCount; ++nSidIndex )
    {
        if ( vpRequiredSids[nSidIndex] != NULL )
        {
            FreeSid( vpRequiredSids[nSidIndex] );
        }
    }

    if ( bRequiredSidsPresent == FALSE )
    {
        throw se;
    }

    return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScMakeSecurityDescriptor
//
//  Description:
//      This function takes a list of strings in the format:
//        trustee1,accessMode1,[accessMask1],trustee2,accessMode2,[accessMask2], ...
//      and creates an access control list (ACL). It then adds this ACL to
//      the ACL in the security descriptor (SD) given as a value of the
//      property strPropName in the property list CurrentProps.
//      This updated SD in the self relative format is returned.
//
//  Arguments:
//      IN  const CString & strPropName
//          Name of the property whose value is the old SD
//
//      IN  const CClusPropList & CurrentProps
//          Property list containing strPropName and its value
//
//      IN  const vector<CString> & vstrValues
//          User specified list of trustees, access modes and access masks
//
//      OUT PSECURITY_DESCRIPTOR * pSelfRelativeSD
//          A pointer to the pointer which stores the address of the newly
//          created SD in self relative format. The caller has to free this
//          memory using LocalFree on successful compeltion of this funciton.
//
//      IN  BOOL bClusterSecurity
//          Indicates that access list is being created for the security descriptor
//          of a cluster.
//          Default value is false.
//
//  Return Value:
//      Return ERROR_SUCCESS on success or an error code indicating failure.
//
//  Exceptions:
//      CSyntaxException
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScMakeSecurityDescriptor(
            const CString & strPropName,
            CClusPropList & CurrentProps,
            const vector<CString> & vstrValues,
            PSECURITY_DESCRIPTOR * ppSelfRelativeSD,
            BOOL bClusterSecurity  /* = FALSE */
          )
          throw( CSyntaxException )
{
    ASSERT( ppSelfRelativeSD != NULL );

    DWORD                   _sc = ERROR_SUCCESS;

    BYTE                    newSD[ SECURITY_DESCRIPTOR_MIN_LENGTH ];
    PSECURITY_DESCRIPTOR    psdNewSD = reinterpret_cast< PSECURITY_DESCRIPTOR >( &newSD );

    PEXPLICIT_ACCESS        explicitAccessArray = NULL;
    PACL                    paclNewDacl = NULL;
    int                     nCountOfExplicitEntries;

    PACL                    paclExistingDacl = NULL;
    BOOL                    bDaclPresent = TRUE;        // We will set the ACL in this function.
    BOOL                    bDaclDefaulted = FALSE;     // So these two flags have these values.

    PACL                    paclExistingSacl = NULL;
    BOOL                    bSaclPresent = FALSE;
    BOOL                    bSaclDefaulted = TRUE;

    PSID                    pGroupSid = NULL;
    BOOL                    bGroupDefaulted = TRUE;

    PSID                    pOwnerSid = NULL;
    BOOL                    bOwnerDefaulted = TRUE;

    // Dummy do-while loop to transfer control without using goto.
    do
    {
        // Initialize a new security descriptor.
        if ( InitializeSecurityDescriptor(
                psdNewSD,
                SECURITY_DESCRIPTOR_REVISION
                ) == 0 )
        {
            _sc = ::GetLastError();
            break;
        }


        {
            vector< EXPLICIT_ACCESS > vExplicitAccess;
            MakeExplicitAccessList( vstrValues, vExplicitAccess, bClusterSecurity );

            // Take the vector of EXPLICIT_ACCESS structures and coalesce it into an array
            // since an array is required by the SetEntriesInAcl function.
            // MakeExplicitAccessList either makes a list with at least on element or
            // throws an exception.
            nCountOfExplicitEntries = vExplicitAccess.size();
            explicitAccessArray = ( PEXPLICIT_ACCESS ) LocalAlloc(
                                                            LMEM_FIXED,
                                                            sizeof( explicitAccessArray[0] ) *
                                                            nCountOfExplicitEntries
                                                            );

            if ( explicitAccessArray == NULL )
            {
                return ::GetLastError();
            }

            for ( int nIndex = 0; nIndex < nCountOfExplicitEntries; ++nIndex )
            {
                explicitAccessArray[nIndex] = vExplicitAccess[nIndex];
            }

            // vExplicitAccess goes out of scope here, freeing up memory.
        }

        // This property already exists in the property list and contains valid data.
        _sc = CurrentProps.ScMoveToPropertyByName( strPropName );
        if ( ( _sc == ERROR_SUCCESS ) &&
             ( CurrentProps.CbhCurrentValue().pBinaryValue->cbLength > 0 ) )
        {
            PSECURITY_DESCRIPTOR pExistingSD =
                reinterpret_cast< PSECURITY_DESCRIPTOR >( CurrentProps.CbhCurrentValue().pBinaryValue->rgb );

            if ( IsValidSecurityDescriptor( pExistingSD ) == 0 )
            {
                // Return the most appropriate error code, since IsValidSecurityDescriptor
                // does not provide extended error information.
                _sc = ERROR_INVALID_DATA;
                break;

            } // if: : the exisiting SD is not valid
            else
            {
                // Get the DACL, SACL, Group and Owner information of the existing SD

                if ( GetSecurityDescriptorDacl(
                        pExistingSD,        // address of security descriptor
                        &bDaclPresent,      // address of flag for presence of DACL
                        &paclExistingDacl,  // address of pointer to the DACL
                        &bDaclDefaulted     // address of flag for default DACL
                        ) == 0 )
                {
                    _sc = GetLastError();
                    break;
                }

                if ( GetSecurityDescriptorSacl(
                        pExistingSD,        // address of security descriptor
                        &bSaclPresent,      // address of flag for presence of SACL
                        &paclExistingSacl,  // address of pointer to the SACL
                        &bSaclDefaulted     // address of flag for default SACL
                        ) == 0 )
                {
                    _sc = GetLastError();
                    break;
                }

                if ( GetSecurityDescriptorGroup(
                        pExistingSD,        // address of security descriptor
                        &pGroupSid,         // address of the pointer to the Group SID
                        &bGroupDefaulted    // address of the flag for default Group
                        ) == 0 )
                {
                    _sc = GetLastError();
                    break;
                }

                if ( GetSecurityDescriptorOwner(
                        pExistingSD,        // address of security descriptor
                        &pOwnerSid,         // address of the pointer to the Owner SID
                        &bOwnerDefaulted    // address of the flag for default Owner
                        ) == 0 )
                {
                    _sc = GetLastError();
                    break;
                }

            } // else: the exisiting SD is valid

        } // if: Current property already exists in the property list and has valid data.
        else
        {
            _sc = ERROR_SUCCESS;

        } // else: Current property is a new property.

        // Add the newly created DACL to the existing DACL
        _sc = SetEntriesInAcl(
                            nCountOfExplicitEntries,
                            explicitAccessArray,
                            paclExistingDacl,
                            &paclNewDacl
                            );

        if ( _sc != ERROR_SUCCESS )
        {
            break;
        }


        // Add the DACL, SACL, Group and Owner information to the new SD
        if ( SetSecurityDescriptorDacl(
                psdNewSD,           // pointer to security descriptor
                bDaclPresent,       // flag for presence of DACL
                paclNewDacl,        // pointer to the DACL
                bDaclDefaulted      // flag for default DACL
                ) == 0 )
        {
            _sc = GetLastError();
            break;
        }

        if ( SetSecurityDescriptorSacl(
                psdNewSD,           // pointer to security descriptor
                bSaclPresent,       // flag for presence of DACL
                paclExistingSacl,   // pointer to the SACL
                bSaclDefaulted      // flag for default SACL
                ) == 0 )
        {
            _sc = GetLastError();
            break;
        }

        if ( SetSecurityDescriptorGroup(
                psdNewSD,           // pointer to security descriptor
                pGroupSid,          // pointer to the Group SID
                bGroupDefaulted     // flag for default Group SID
                ) == 0 )
        {
            _sc = GetLastError();
            break;
        }

        if ( SetSecurityDescriptorOwner(
                psdNewSD,           // pointer to security descriptor
                pOwnerSid,          // pointer to the Owner SID
                bOwnerDefaulted     // flag for default Owner SID
                ) == 0 )
        {
            _sc = GetLastError();
            break;
        }

        if ( bClusterSecurity == FALSE )
        {

#if(_WIN32_WINNT >= 0x0500)

            // If we are not setting the cluster security, set the
            // SE_DACL_AUTO_INHERIT_REQ flag too.

            if ( SetSecurityDescriptorControl(
                    psdNewSD,
                    SE_DACL_AUTO_INHERIT_REQ,
                    SE_DACL_AUTO_INHERIT_REQ
                    ) == 0 )
            {
                _sc = GetLastError();
                break;
            }

#endif /* _WIN32_WINNT >=  0x0500 */

        } // if: bClusterSecurity == FALSE

        // Arbitrary size. MakeSelfRelativeSD tell us the required size on failure.
        DWORD dwSDSize = 256;

        // This memory is freed by the caller.
        *ppSelfRelativeSD = ( PSECURITY_DESCRIPTOR ) LocalAlloc( LMEM_FIXED, dwSDSize );

        if ( *ppSelfRelativeSD == NULL )
        {
            _sc = GetLastError();
            break;
        }

        if ( MakeSelfRelativeSD( psdNewSD, *ppSelfRelativeSD, &dwSDSize ) == 0 )
        {
            // MakeSelfReltiveSD may have failed due to insufficient buffer size.
            // Try again with indicated buffer size.
            LocalFree( *ppSelfRelativeSD );

            // This memory is freed by the caller.
            *ppSelfRelativeSD = ( PSECURITY_DESCRIPTOR ) LocalAlloc( LMEM_FIXED, dwSDSize );

            if ( *ppSelfRelativeSD == NULL )
            {
                _sc = GetLastError();
                break;
            }

            if ( MakeSelfRelativeSD( psdNewSD, *ppSelfRelativeSD, &dwSDSize ) == 0 )
            {
                _sc = GetLastError();
                break;
            }

        } // if: MakeSelfRelativeSD fails

        break;

    }
    while ( FALSE ); // do-while: dummy do-while loop to avoid goto's.

    LocalFree( paclNewDacl );
    LocalFree( explicitAccessArray );

    if ( _sc == ERROR_INVALID_PARAMETER )
    {
        PrintMessage( MSG_ACL_ERROR );
    }

    return _sc;

} //*** ScMakeSecurityDescriptor()


///////////////////////////////////////////////////////////////////////////////////////////
// Property list helpers...
//
// These functions are used by all of the command classes to manipulate property lists.
// Since these are common functions, I should consider putting them into a class or
// making them part of a base class for the command classes...
//

/*
    PrintProperties
    ~~~~~~~~~~~~~~~
    This function will print the property name/value pairs.
    The reason that this function is not in the CClusPropList class is
    that is is not generic. The code in cluswrap.cpp is intended to be generic.
*/
DWORD PrintProperties(
    CClusPropList &             PropList,
    const vector< CString > &   vstrFilterList,
    PropertyAttrib              eReadOnly,
    LPCWSTR                     pszOwnerName,
    LPCWSTR                     pszNetIntSpecific
    )
{
    DWORD _sc = PropList.ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        int _nFilterListSize = vstrFilterList.size();

        do
        {
            LPCWSTR _pszCurPropName = PropList.PszCurrentPropertyName();

            // If property names are provided in the filter list then it means that only those
            // properties whose names are listed are to be displayed.
            if ( _nFilterListSize != 0 )
            {
                // Check if the current property is to be displayed or not.
                BOOL _bFound = FALSE;
                int _idx;

                for ( _idx = 0 ; _idx < _nFilterListSize ; ++_idx )
                {
                    if ( vstrFilterList[ _idx ].CompareNoCase( _pszCurPropName ) == 0 )
                    {
                        _bFound = TRUE;
                        break;
                    }

                } // for: the number of entries in the filter list.

                if ( _bFound == FALSE )
                {
                    // This property need not be displayed.

                    // Advance to the next property.
                    _sc = PropList.ScMoveToNextProperty();

                    continue;
                }

            } // if: properties need to be filtered.

            do
            {
                _sc = PrintProperty(
                        PropList.PszCurrentPropertyName(),
                        PropList.CbhCurrentValue(),
                        eReadOnly,
                        pszOwnerName,
                        pszNetIntSpecific
                        );

                if ( _sc != ERROR_SUCCESS )
                    return _sc;

                //
                // Advance to the next property.
                //
                _sc = PropList.ScMoveToNextPropertyValue();
            } while ( _sc == ERROR_SUCCESS );

            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _sc = PropList.ScMoveToNextProperty();
            } // if: exited loop because all values were enumerated
        } while ( _sc == ERROR_SUCCESS );
    } // if: move to first prop succeeded.  Would fail if empty!

    if ( _sc == ERROR_NO_MORE_ITEMS )
    {
        _sc = ERROR_SUCCESS;
    } // if: exited loop because all properties were enumerated

    return _sc;

} //*** PrintProperties()




DWORD PrintProperty(
    LPCWSTR                 pwszPropName,
    CLUSPROP_BUFFER_HELPER  PropValue,
    PropertyAttrib          eReadOnly,
    LPCWSTR                 pszOwnerName,
    LPCWSTR                 pszNetIntSpecific
    )
{
    DWORD _sc = ERROR_SUCCESS;

    LPWSTR  _pszValue = NULL;
    LPCTSTR _pszFormatChar = LookupName( (CLUSTER_PROPERTY_FORMAT) PropValue.pValue->Syntax.wFormat,
                                        formatCharLookupTable, formatCharLookupTableSize );

    PrintMessage( MSG_PROPERTY_FORMAT_CHAR, _pszFormatChar );

    if ( eReadOnly == READONLY )
        PrintMessage( MSG_READONLY_PROPERTY );
    else
        PrintMessage( MSG_READWRITE_PROPERTY );

    switch( PropValue.pValue->Syntax.wFormat )
    {
        case CLUSPROP_FORMAT_SZ:
        case CLUSPROP_FORMAT_EXPAND_SZ:
        case CLUSPROP_FORMAT_EXPANDED_SZ:
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_STRING_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pStringValue->sz
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                            MSG_PROPERTY_STRING_WITH_OWNER,
                            pszOwnerName,
                            pwszPropName,
                            PropValue.pStringValue->sz
                            );
                }
                else
                {
                    _sc = PrintMessage(
                            MSG_PROPERTY_STRING,
                            pwszPropName,
                            PropValue.pStringValue->sz
                            );
                }
            }
            break;

        case CLUSPROP_FORMAT_MULTI_SZ:
            _pszValue = PropValue.pStringValue->sz;

            do
            {
                if (    ( pszOwnerName != NULL )
                    &&  ( pszNetIntSpecific != NULL ) )
                {
                    PrintMessage(
                        MSG_PROPERTY_STRING_WITH_NODE_AND_NET,
                        pszOwnerName,
                        pszNetIntSpecific,
                        pwszPropName,
                        _pszValue
                        );
                }
                else
                {
                    if ( pszOwnerName != NULL )
                    {
                        PrintMessage(
                            MSG_PROPERTY_STRING_WITH_OWNER,
                            pszOwnerName,
                            pwszPropName,
                            _pszValue
                            );
                    }
                    else
                    {
                        PrintMessage(
                            MSG_PROPERTY_STRING,
                            pwszPropName,
                            _pszValue
                            );
                    }
                }


                while ( *_pszValue != L'\0' )
                    _pszValue++;
                _pszValue++; // Skip the NULL

                if ( *_pszValue != L'\0' )
                {
                    PrintMessage( MSG_PROPERTY_FORMAT_CHAR, _pszFormatChar );

                    if ( eReadOnly == READONLY )
                        PrintMessage( MSG_READONLY_PROPERTY );
                    else
                        PrintMessage( MSG_READWRITE_PROPERTY );
                }
                else
                {
                    break;
                }
            }
            while ( TRUE );

            break;

        case CLUSPROP_FORMAT_BINARY:
        {
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_BINARY_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_BINARY_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName
                                );
                }
                else
                {
                    _sc = PrintMessage( MSG_PROPERTY_BINARY, pwszPropName );
                }
            }

            int _nCount = PropValue.pBinaryValue->cbLength;
            int _idx;

            // Display a maximum of 4 bytes.
            if ( _nCount > 4 )
                _nCount = 4;

            for ( _idx = 0 ; _idx < _nCount ; ++_idx )
            {
                PrintMessage( MSG_PROPERTY_BINARY_VALUE, PropValue.pBinaryValue->rgb[ _idx ] );
            }

            PrintMessage( MSG_PROPERTY_BINARY_VALUE_COUNT, PropValue.pBinaryValue->cbLength );

            break;
        }

        case CLUSPROP_FORMAT_DWORD:
            if ( ( pszOwnerName != NULL ) && ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_DWORD_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pDwordValue->dw
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_DWORD_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName,
                                PropValue.pDwordValue->dw
                                );
                }
                else
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_DWORD,
                                pwszPropName,
                                PropValue.pDwordValue->dw
                                );
                }
            }
            break;

        case CLUSPROP_FORMAT_LONG:
            if ( ( pszOwnerName != NULL ) && ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_LONG_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pLongValue->l
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_LONG_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName,
                                PropValue.pLongValue->l
                                );
                }
                else
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_LONG,
                                pwszPropName,
                                PropValue.pLongValue->l
                                );
                }
            }
            break;

        case CLUSPROP_FORMAT_ULARGE_INTEGER:
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_ULARGE_INTEGER_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pULargeIntegerValue->li
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_ULARGE_INTEGER_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName,
                                PropValue.pULargeIntegerValue->li
                                );
                }
                else
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_ULARGE_INTEGER,
                                pwszPropName,
                                PropValue.pULargeIntegerValue->li
                                );
                }
            }
            break;


        default:
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_UNKNOWN_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_UNKNOWN_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName
                                );
                }
                else
                {
                    _sc = PrintMessage( MSG_PROPERTY_UNKNOWN, pwszPropName );
                }
            }

            break;
    }


    return _sc;

} //*** PrintProperty()


// Constructs a property list in which all the properties named in vstrPropName
// are set to their default values.
DWORD ConstructPropListWithDefaultValues(
    CClusPropList &             CurrentProps,
    CClusPropList &             newPropList,
    const vector< CString > &   vstrPropNames
    )
{
    DWORD _sc = ERROR_SUCCESS;

    int _nListSize = vstrPropNames.size();
    int _nListBufferNeeded = 0;
    int _idx;
    int _nPropNameLen;

    // Precompute the required size of the property list to prevent resizing
    // every time a property is added.
    // Does not matter too much if this value is wrong.

    for ( _idx = 0 ; _idx < _nListSize ; ++_idx )
    {
        _nPropNameLen = ( vstrPropNames[ _idx ].GetLength() + 1 ) * sizeof( TCHAR );

        _nListBufferNeeded += sizeof( CLUSPROP_PROPERTY_NAME ) +
                                sizeof( CLUSPROP_VALUE ) +
                                sizeof( CLUSPROP_SYNTAX ) +
                                ALIGN_CLUSPROP( _nPropNameLen ) +   // Length of the property name
                                ALIGN_CLUSPROP( 0 );                // Length of the data
    }

    _sc = newPropList.ScAllocPropList( _nListBufferNeeded );
    if ( _sc != ERROR_SUCCESS )
        return _sc;

    for ( _idx = 0 ; _idx < _nListSize ; ++_idx )
    {
        const CString & strCurrent = vstrPropNames[ _idx ];

        // Search for current property in the list of existing properties.
        _sc = CurrentProps.ScMoveToPropertyByName( strCurrent );

        // If the current property does not exist, nothing needs to be done.
        if ( _sc != ERROR_SUCCESS )
            continue;

        _sc = newPropList.ScSetPropToDefault( strCurrent, CurrentProps.CpfCurrentValueFormat() );
        if ( _sc != ERROR_SUCCESS )
            return _sc;
    }

    return _sc;

} //*** ConstructPropListWithDefaultValues()


DWORD ConstructPropertyList(
    CClusPropList &CurrentProps,
    CClusPropList &NewProps,
    const vector<CCmdLineParameter> & paramList,
    BOOL bClusterSecurity /* = FALSE */
    )
    throw( CSyntaxException )
{
    // Construct a list checking name and type against the current properties.
    DWORD _sc = ERROR_SUCCESS;

    vector< CCmdLineParameter >::const_iterator curParam = paramList.begin();
    vector< CCmdLineParameter >::const_iterator last = paramList.end();

    // Add each property to the property list.
    for( ; ( curParam != last )  && ( _sc == ERROR_SUCCESS ); ++curParam )
    {
        const CString & strPropName = curParam->GetName();
        const vector< CString > & vstrValues = curParam->GetValues();
        BOOL  bKnownProperty = FALSE;

        if ( curParam->GetType() != paramUnknown )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_INVALID_OPTION, strPropName );
            throw se;
        }

        // All properties must must have at least one value.
        if ( vstrValues.size() <= 0 )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, strPropName );
            throw se;
        }

        if ( curParam->GetValueFormat() == vfInvalid )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_PARAM_INVALID_FORMAT, strPropName, curParam->GetValueFormatName() );
            throw se;
        }

        ValueFormat vfGivenFormat;

        // Look up property to determine format
        _sc = CurrentProps.ScMoveToPropertyByName( strPropName );
        if ( _sc == ERROR_SUCCESS )
        {
            WORD wActualClusPropFormat = CurrentProps.CpfCurrentValueFormat();
            ValueFormat vfActualFormat = ClusPropToValueFormat[ wActualClusPropFormat ];

            if ( curParam->GetValueFormat() == vfUnspecified )
            {
                vfGivenFormat = vfActualFormat;

            } // if: no format was specififed.
            else
            {
                vfGivenFormat = curParam->GetValueFormat();

                // Special Case:
                // Don't check to see if the given format matches with the actual format
                // if the given format is security and the actual format is binary.
                if ( ( vfGivenFormat != vfSecurity ) || ( vfActualFormat != vfBinary ) )
                {
                    if ( vfActualFormat != vfGivenFormat )
                    {
                        CSyntaxException se;
                        se.LoadMessage( MSG_PARAM_INCORRECT_FORMAT,
                                        strPropName,
                                        curParam->GetValueFormatName(),
                                        LookupName( (CLUSTER_PROPERTY_FORMAT) wActualClusPropFormat,
                                                    cluspropFormatLookupTable,
                                                    cluspropFormatLookupTableSize ) );
                        throw se;
                    }
                } // if: given format is not Security or actual format is not binary

            } // else: a format was specified.

            bKnownProperty = TRUE;
        } // if: the current property is a known property
        else
        {

            // The current property is user defined property.
            // CurrentProps.ScMoveToPropertyByName returns ERROR_NO_MORE_ITEMS in this case.
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                // This is not a predefined property.
                if ( curParam->GetValueFormat() == vfUnspecified )
                {
                    // If the format is unspecified, assume it to be a string.
                    vfGivenFormat = vfSZ;
                }
                else
                {
                    // Otherwise, use the specified format.
                    vfGivenFormat = curParam->GetValueFormat();
                }

                bKnownProperty = FALSE;
                _sc = ERROR_SUCCESS;

            } // if: CurrentProps.ScMoveToPropertyByName returned ERROR_NO_MORE_ITEMS
            else
            {
                // An error occurred - quit.
                break;

            } // else: an error occurred

        } // else: the current property is not a known property


        switch( vfGivenFormat )
        {
            case vfSZ:
            {
                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                _sc = NewProps.ScAddProp( strPropName, vstrValues[ 0 ], CurrentProps.CbhCurrentValue().psz );
                break;
            }

            case vfExpandSZ:
            {
                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                _sc = NewProps.ScAddExpandSzProp( strPropName, vstrValues[ 0 ] );
                break;
            }

            case vfMultiSZ:
            {
                CString strMultiszString;

                curParam->GetValuesMultisz( strMultiszString );
                _sc = NewProps.ScAddMultiSzProp( strPropName, strMultiszString, CurrentProps.CbhCurrentValue().pMultiSzValue->sz );
            }
            break;

            case vfDWord:
            {
                DWORD dwOldValue;

                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                DWORD dwValue = 0;

                _sc = MyStrToDWORD( vstrValues[ 0 ], &dwValue );
                if (_sc != ERROR_SUCCESS)
                {
                    break;
                }

                if ( bKnownProperty )
                {
                    // Pass the old value only if this property already exists.
                    dwOldValue = CurrentProps.CbhCurrentValue().pDwordValue->dw;
                }
                else
                {
                    // Otherwise pass a value different from the new value.
                    dwOldValue = dwValue - 1;
                }
                _sc = NewProps.ScAddProp( strPropName, dwValue, dwOldValue );
            }
            break;

            case vfBinary:
            {
                DWORD   cbValues = vstrValues.size();

                // Get the bytes to be stored.
                BYTE *pByte = (BYTE *) ::LocalAlloc( LMEM_FIXED, cbValues * sizeof( *pByte ) );

                if ( pByte == NULL )
                {
                    _sc = ::GetLastError();
                    break;
                }

                for ( int idx = 0 ; idx < cbValues ; )
                {
                   // If this value is an empty string, ignore it.
                   if ( vstrValues[ idx ].IsEmpty() )
                   {
                      --cbValues;
                      continue;
                   }

                    _sc = MyStrToBYTE( vstrValues[ idx ], &pByte[ idx ] );
                    if ( _sc != ERROR_SUCCESS )
                    {
                        ::LocalFree( pByte );
                        break;
                    }

                     ++idx;
                }

                if ( _sc == ERROR_SUCCESS )
                {
                    _sc = NewProps.ScAddProp(
                                strPropName,
                                pByte,
                                cbValues,
                                CurrentProps.CbhCurrentValue().pb,
                                CurrentProps.CbCurrentValueLength()
                                 );
                    ::LocalFree( pByte );
                }
            }
            break;

            case vfULargeInt:
            {
                ULONGLONG ullValue = 0;
                ULONGLONG ullOldValue;

                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                _sc = MyStrToULongLong( vstrValues[ 0 ], &ullValue );
                if ( _sc != ERROR_SUCCESS )
                {
                    break;
                }

                if ( bKnownProperty )
                {
                   // Pass the old value only if this property already exists.
                    ullOldValue = CurrentProps.CbhCurrentValue().pULargeIntegerValue->li.QuadPart;
                }
                else
                {
                   // Otherwise pass a value different from the new value.
                    ullOldValue = ullValue - 1;
                }
                _sc = NewProps.ScAddProp( strPropName, ullValue, ullOldValue );
            }
            break;

            case vfSecurity:
            {
                PBYTE pSelfRelativeSD = NULL;

                do // dummy do-while to avoid gotos
                {
                    _sc = ScMakeSecurityDescriptor(
                                strPropName,
                                CurrentProps,
                                vstrValues,
                                reinterpret_cast< PSECURITY_DESCRIPTOR * >( &pSelfRelativeSD ),
                                bClusterSecurity
                              );

                    if ( _sc != ERROR_SUCCESS )
                    {
                        break;
                    }

                    if ( bClusterSecurity != FALSE )
                    {
                        try
                        {
                            _sc = CheckForRequiredACEs( pSelfRelativeSD );
                            if ( _sc != ERROR_SUCCESS )
                            {
                                break;
                            }
                        }
                        catch ( CSyntaxException & se )
                        {
                            ::LocalFree( pSelfRelativeSD );
                            throw se;
                        }
                    }

                    _sc = NewProps.ScAddProp(
                                strPropName,
                                pSelfRelativeSD,
                                ::GetSecurityDescriptorLength( static_cast< PSECURITY_DESCRIPTOR >( pSelfRelativeSD ) ),
                                CurrentProps.CbhCurrentValue().pb,
                                CurrentProps.CbCurrentValueLength()
                                );

                }
                while ( FALSE ); // dummy do-while to avoid gotos

                ::LocalFree( pSelfRelativeSD );
            }
            break;

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_PARAM_CANNOT_SET_PARAMETER,
                                strPropName,
                                curParam->GetValueFormatName() );
                throw se;
            }
        }
    }

    return _sc;

} //*** ConstructPropertyList()


DWORD MyStrToULongLong( LPCWSTR lpszNum, ULONGLONG * pullValue )
{
    // This string stores any extra characters that may be present in
    // lpszNum. The presence of extra characters after the integer
    // is a error.
    TCHAR szExtraCharBuffer[ 2 ];

    *pullValue = 0;

    // Check for valid params
    if (!lpszNum || !pullValue)
        return ERROR_INVALID_PARAMETER;

    // Do the conversion
    int nFields = swscanf( lpszNum, L"%I64u %1s", pullValue, szExtraCharBuffer );

    // check if there was an overflow
    if ( ( errno == ERANGE ) || ( *pullValue > _UI64_MAX ) ||
         ( nFields != 1 ) )
        return ERROR_INVALID_PARAMETER;

    return ERROR_SUCCESS;
}


DWORD MyStrToBYTE(LPCWSTR lpszNum, BYTE *pByte )
{
    DWORD dwValue = 0;
    LPWSTR lpszEndPtr;

    *pByte = 0;

    // Check for valid params
    if (!lpszNum || !pByte)
        return ERROR_INVALID_PARAMETER;

    // Do the conversion
    dwValue = _tcstoul( lpszNum,  &lpszEndPtr, 0 );

    // check if there was an overflow
    if ( ( errno == ERANGE ) || ( dwValue > UCHAR_MAX ) )
        return ERROR_INVALID_PARAMETER;

    if (dwValue == 0 && lpszNum == lpszEndPtr)
    {
        // wcsto[u]l was unable to perform the conversion
        return ERROR_INVALID_PARAMETER;
    }

    // Skip whitespace characters, if any, at the end of the input.
    while ( ( *lpszEndPtr != TEXT('\0') && ( ::_istspace( *lpszEndPtr ) != 0 ) ) )
    {
        ++lpszEndPtr;
    }

    // Check if there are additional junk characters in the input.
    if (*lpszEndPtr != TEXT('\0') )
    {
        // wcsto[u]l was able to partially convert the number,
        // but there was extra junk on the end
        return ERROR_INVALID_PARAMETER;
    }

    *pByte = dwValue;
    return ERROR_SUCCESS;
}


DWORD MyStrToDWORD (LPCWSTR lpszNum, DWORD *lpdwVal )
{
    DWORD dwTmp;
    LPWSTR lpszEndPtr;

    // Check for valid params
    if (!lpszNum || !lpdwVal)
        return ERROR_INVALID_PARAMETER;

    // Do the conversion
    if (lpszNum[0] != L'-')
    {
        dwTmp = wcstoul(lpszNum, &lpszEndPtr, 0);
        if (dwTmp == ULONG_MAX)
        {
            // check if there was an overflow
            if (errno == ERANGE)
                return ERROR_ARITHMETIC_OVERFLOW;
        }
    }
    else
    {
        dwTmp = wcstol(lpszNum, &lpszEndPtr, 0);
        if (dwTmp == LONG_MAX || dwTmp == LONG_MIN)
        {
            // check if there was an overflow
            if (errno == ERANGE)
                return ERROR_ARITHMETIC_OVERFLOW;
        }
    }

    if (dwTmp == 0 && lpszNum == lpszEndPtr)
    {
        // wcsto[u]l was unable to perform the conversion
        return ERROR_INVALID_PARAMETER;
    }

    // Skip whitespace characters, if any, at the end of the input.
    while ( ( *lpszEndPtr != TEXT('\0') && ( ::_istspace( *lpszEndPtr ) != 0 ) ) )
    {
        ++lpszEndPtr;
    }

    // Check if there are additional junk characters in the input.
    if (*lpszEndPtr != TEXT('\0') )
    {
        // wcsto[u]l was able to partially convert the number,
        // but there was extra junk on the end
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwVal = dwTmp;
    return ERROR_SUCCESS;
}

DWORD MyStrToLONG (LPCWSTR lpszNum, LONG *lplVal )
{
    LONG    lTmp;
    LPWSTR  lpszEndPtr;

    // Check for valid params
    if (!lpszNum || !lplVal)
        return ERROR_INVALID_PARAMETER;

    lTmp = wcstol(lpszNum, &lpszEndPtr, 0);
    if (lTmp == LONG_MAX || lTmp == LONG_MIN)
    {
        // check if there was an overflow
        if (errno == ERANGE)
            return ERROR_ARITHMETIC_OVERFLOW;
    }

    if (lTmp == 0 && lpszNum == lpszEndPtr)
    {
        // wcstol was unable to perform the conversion
        return ERROR_INVALID_PARAMETER;
    }

    // Skip whitespace characters, if any, at the end of the input.
    while ( ( *lpszEndPtr != TEXT('\0') && ( ::_istspace( *lpszEndPtr ) != 0 ) ) )
    {
        ++lpszEndPtr;
    }

    // Check if there are additional junk characters in the input.
    if (*lpszEndPtr != TEXT('\0') )
    {
        // wcstol was able to partially convert the number,
        // but there was extra junk on the end
        return ERROR_INVALID_PARAMETER;
    }

    *lplVal = lTmp;
    return ERROR_SUCCESS;
}



DWORD
WaitGroupQuiesce(
    IN HCLUSTER hCluster,
    IN HGROUP   hGroup,
    IN LPWSTR   lpszGroupName,
    IN DWORD    dwWaitTime
    )

/*++

Routine Description:

    Waits for a group to quiesce, i.e. the state of all resources to
    transition to a stable state.

Arguments:

    hCluster - the handle to the cluster.

    lpszGroupName - the name of the group.

    dwWaitTime - the wait time (in seconds) to wait for the group to stabilize.
               Zero implies a default wait interval.

Return Value:

    Status of the wait.
    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD       _sc;
    HRESOURCE   hResource;
    LPWSTR      lpszName;
    DWORD       dwIndex;
    DWORD       dwType;

    LPWSTR      lpszEnumGroupName;
    LPWSTR      lpszEnumNodeName;

    CLUSTER_RESOURCE_STATE nState;

    if ( dwWaitTime == 0 ) {
        return(ERROR_SUCCESS);
    }

    HCLUSENUM   hEnum = ClusterOpenEnum( hCluster,
                                         CLUSTER_ENUM_RESOURCE );
    if ( !hEnum ) {
        return GetLastError();
    }

    // Wait for a group state change event
    CClusterNotifyPort port;
    _sc = port.Create( (HCHANGE)INVALID_HANDLE_VALUE, hCluster );
    if ( _sc != ERROR_SUCCESS ) {
        return(_sc);
    }

    port.Register( CLUSTER_CHANGE_GROUP_STATE, hGroup );

retry:
    for ( dwIndex = 0; (--dwWaitTime !=0 );  dwIndex++ ) {

        _sc = WrapClusterEnum( hEnum,
                                   dwIndex,
                                   &dwType,
                                   &lpszName );
        if ( _sc == ERROR_NO_MORE_ITEMS ) {
            _sc = ERROR_SUCCESS;
            break;
        }

        if ( _sc != ERROR_SUCCESS ) {
            break;
        }
        hResource = OpenClusterResource( hCluster,
                                         lpszName );
        //LocalFree( lpszName );
        if ( !hResource ) {
            _sc = GetLastError();
            LocalFree( lpszName );
            break;
        }

        nState = WrapGetClusterResourceState( hResource,
                                              &lpszEnumNodeName,
                                              &lpszEnumGroupName );
        LocalFree( lpszEnumNodeName );
        //LocalFree( lpszName );
        if ( nState == ClusterResourceStateUnknown ) {
            _sc = GetLastError();
            CloseClusterResource( hResource );
            LocalFree( lpszEnumGroupName );
            LocalFree( lpszName );
            break;
        }

        CloseClusterResource( hResource );

        _sc = ERROR_SUCCESS;
        //
        // If this group is the correct group make sure the resource state
        // is stable...
        //
        if ( lpszEnumGroupName && *lpszEnumGroupName &&
             (lstrcmpiW( lpszGroupName, lpszEnumGroupName ) == 0) &&
             (nState >= ClusterResourceOnlinePending) ) {
            LocalFree( lpszEnumGroupName );
            LocalFree( lpszName );
            port.GetNotify();
            goto retry;
        }
        LocalFree( lpszName );
        LocalFree( lpszEnumGroupName );
    }

    ClusterCloseEnum( hEnum );

    return(_sc);

} // WaitGroupQuiesce


#ifdef UNICODE
WCHAR   PaddingBuffer[MAX_BUF_SIZE];

PWCHAR
PaddedString(
    IN LONG Size,
    IN PWCHAR String
    )

/*++

Routine Description:

    Realize the string, left aligned and padded on the right to the field
    width/precision specified.

    This routine uses a static buffer for the returned buffer.

    This means that only 1 print can happen at time! No multi-threading!

Arguments:

    Size - the size of the buffer

    String - the string to align.

Return Value:

    Padded buffer string.

--*/

{
    DWORD  realSize;
    BOOL   fEllipsis = FALSE;
    PWCHAR buffer = PaddingBuffer;

    if (Size < 0) {
        fEllipsis = TRUE;
        Size = -Size;
    }
    realSize = _snwprintf(buffer, MAX_BUF_SIZE, L"%-*.*ws", Size, Size, String );

    if ( realSize == 0 ) {
        return NULL;
    }

    if ( SizeOfHalfWidthString(buffer) > Size ) {
        do {
            buffer[--realSize] = L'\0';
        } while ( SizeOfHalfWidthString(buffer) > Size );

        if ( fEllipsis &&
            (buffer[realSize-1] != L' ') ) {
            buffer[realSize-1] = L'.';
            buffer[realSize-2] = L'.';
            buffer[realSize-3] = L'.';
        }
    } else {
        buffer[wcslen(String)] = L'\0';
    }

    return(buffer);

} // PaddedString



LONG
SizeOfHalfWidthString(
    IN PWCHAR String
    )

/*++

Routine Description:

    Determine size of the given Unicode string, adjusting for half-width chars.

Arguments:

    String - the unicode string.

Return Value:

    Size of buffer.

--*/

{
    DWORD   count=0;
    DWORD   codePage;


    switch ( codePage=GetConsoleOutputCP() ) {
    case 932:
    case 936:
    case 949:
    case 950:
        while ( *String ) {
            if (IsFullWidth(*String)) {
                count += 2;
            } else {
                count++;
            }
            String++;
        }
        return(count);

    default:
        return wcslen(String);
    }

} // SizeOfHalfWidthString



BOOL
IsFullWidth(
    IN WCHAR Char
    )

/*++

Routine Description:

    Determine if the given Unicode char is fullwidth or not.

Arguments:

    Char - character to check

Return Value:

    TRUE if character is UNICODE,
    FALSE Otherwise.

--*/

{
    /* Assert cp == double byte codepage */
    if ( (Char <= 0x007f) ||
         (Char >= 0xff60) &&
         (Char <= 0xff9f) ) {
        return(FALSE);  // Half width.
    } else if ( Char >= 0x300 ) {
        return(TRUE);   // Full width.
    } else {
        return(FALSE);  // Half width.
    }

} // IsFullWidth

#endif // def UNICODE

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetFQDNName(
//      LPCWSTR pcwszNameIn,
//      BSTR *  pbstrFQDNOut
//      )
//
//  Description:
//      Gets the FQDN for a specified name.  If no domain name is specified,
//      the domain of the local machine will be used.
//      
//  Arguments:
//      pcwszNameIn     -- Name to convert to a FQDN.
//      pbstrFQDNOut    -- FQDN being returned.  Caller must free using
//                          SysFreeString().
//
//  Exceptions:
//      None.
//
//  Return Values:
//      S_OK    -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetFQDNName(
      LPCWSTR   pcwszNameIn
    , BSTR *    pbstrFQDNOut
    )
{
    HRESULT hr          = S_OK;
    LPCWSTR pcwszDomain = NULL;
    WCHAR   wszFQDN[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PDOMAIN_CONTROLLER_INFO pdci = NULL;

    // Copy the name into the FQDN buffer.
    wcscpy( wszFQDN, pcwszNameIn );

    // Find the domain name in the specified name.
    pcwszDomain = wcschr( pcwszNameIn, L'.' );
    if ( pcwszDomain == NULL )
    {
        BOOL    fReturn;
        DWORD   cch;
        DWORD   dwErr;

        //
        // DsGetDcName will give us access to a usable domain name, regardless of whether we are
        // currently in a W2k or a NT4 domain. On W2k and above, it will return a DNS domain name,
        // on NT4 it will return a NetBIOS name.
        //
        dwErr = DsGetDcName(
                          NULL
                        , NULL
                        , NULL
                        , NULL
                        , DS_DIRECTORY_SERVICE_PREFERRED
                        , &pdci
                        );
        if ( dwErr != NO_ERROR )
        {
            goto Cleanup;
        } // if: DsGetDcName failed
        
        // Add the local domain onto the end of the name passed in.
        cch = wcslen( wszFQDN );
        if ( cch + wcslen( pdci->DomainName ) + 1 > sizeof( wszFQDN ) / sizeof( wszFQDN[ 0 ] ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
            goto Cleanup;
        }
        wszFQDN[ cch++ ] = L'.';
        wcscpy( &wszFQDN[ cch ], pdci->DomainName );
    }

    // Construct the BSTR.
    *pbstrFQDNOut = SysAllocString( wszFQDN );
    if ( *pbstrFQDNOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if ( pdci != NULL )
    {
        NetApiBufferFree( pdci );
    }
    return hr;

} //*** HrGetFQDNName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetLocalNodeFQDNName(
//      BSTR *  pbstrFQDNOut
//      )
//
//  Description:
//      Gets the FQDN for the local node.
//      
//  Arguments:
//      pbstrFQDNOut    -- FQDN being returned.  Caller must free using
//                          SysFreeString().
//
//  Exceptions:
//      None.
//
//  Return Values:
//      S_OK    -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetLocalNodeFQDNName(
    BSTR *  pbstrFQDNOut
    )
{
    HRESULT hr          = S_OK;
    LPCWSTR pcwszDomain = NULL;
    WCHAR   wszHostname[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   cchHostname   = sizeof( wszHostname ) / sizeof( wszHostname[ 0 ] );
    BOOL    fReturn;
    DWORD   cch;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    DWORD dwErr;


    //
    // DsGetDcName will give us access to a usable domain name, regardless of whether we are
    // currently in a W2k or a NT4 domain. On W2k and above, it will return a DNS domain name,
    // on NT4 it will return a NetBIOS name.
    //
    fReturn = GetComputerNameEx( ComputerNamePhysicalDnsHostname, wszHostname, &cchHostname );
    if ( ! fReturn )
        goto Win32Error;

    dwErr = DsGetDcName(
                      NULL
                    , NULL
                    , NULL
                    , NULL
                    , DS_DIRECTORY_SERVICE_PREFERRED
                    , &pdci
                    );
    if ( dwErr != NO_ERROR )
    {
        goto Cleanup;
    } // if: DsGetDcName failed

    // 
    // now, append the domain name (might be either NetBIOS or DNS style, depending on whether or nor
    // we are in a legacy domain)
    //
    if ( ( wcslen( pdci->DomainName ) + cchHostname + 1 ) > DNS_MAX_NAME_BUFFER_LENGTH )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

    wcscat( wszHostname, L"." );
    wcscat( wszHostname, pdci->DomainName );

    // Construct the BSTR.
    *pbstrFQDNOut = SysAllocString( wszHostname );
    if ( *pbstrFQDNOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if ( pdci != NULL )
    {
        NetApiBufferFree( pdci );
    }
    return hr;

Win32Error:
    hr = HRESULT_FROM_WIN32( GetLastError() );
    goto Cleanup;

} //*** HrGetLocalNodeFQDNName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetLoggedInUserDomain(
//      BSTR *  pbstrDomainOut
//      )
//
//  Description:
//      Gets the domain name of the currently logged in user.
//      
//  Arguments:
//      pbstrDomainOut  -- Domain being returned.  Caller must free using
//                          SysFreeString().
//
//  Exceptions:
//      None.
//
//  Return Values:
//      S_OK    -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetLoggedInUserDomain(
    BSTR * pbstrDomainOut
    )
{
    HRESULT hr          = S_OK;
    DWORD   dwStatus;
    BOOL    fSuccess;
    LPWSTR  pwszSlash;
    LPWSTR  pwszUser    = NULL;
    ULONG   nSize       = 0;

    // Get the size of the user.
    fSuccess = GetUserNameEx( NameSamCompatible, NULL, &nSize );
    dwStatus = GetLastError();
    if ( dwStatus != ERROR_MORE_DATA )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    }

    // Allocate the name buffer.
    pwszUser = (LPWSTR) LocalAlloc( LMEM_FIXED, nSize * sizeof( *pwszUser ) );
    if ( pwszUser == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get the username with domain.
    fSuccess = GetUserNameEx( NameSamCompatible, pwszUser, &nSize );
    if ( ! fSuccess )
    {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32( hr );
        goto Cleanup;
    }

    // Find the end of the domain name and truncate.
    pwszSlash = wcschr( pwszUser, L'\\' );
    if ( pwszSlash == NULL )
    {
        // we're in trouble
    }
    *pwszSlash = L'\0';

    // Create the BSTR.
    *pbstrDomainOut = SysAllocString( pwszUser );
    if ( *pbstrDomainOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if ( pwszUser != NULL )
    {
        LocalFree( pwszUser );
    }
    return hr;

} //*** HrGetLoggedInUserDomain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwGetPassword(
//        LPWSTR    pwszPasswordOut
//      , DWORD     cchPasswordIn
//      )
//
//  Description:
//      Reads a password from the console.
//      
//  Arguments:
//      pwszPasswordOut -- Buffer in which to return the password.
//      cchPasswordIn   -- Size of password buffer.
//
//  Exceptions:
//      None.
//
//  Return Values:
//      ERROR_SUCCESS   -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
DwGetPassword(
      LPWSTR    pwszPasswordOut
    , DWORD     cchPasswordIn
    )
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cchRead;
    DWORD   cchMax;
    DWORD   cchTotal    = 0;
    WCHAR   wch;
    WCHAR * pwsz;
    BOOL    fSuccess;
    DWORD   dwConsoleMode;

    cchMax = cchPasswordIn - 1;     // Make room for the terminating NULL.
    pwsz = pwszPasswordOut;

    // Set the console mode to prevent echoing characters typed.
    GetConsoleMode( GetStdHandle( STD_INPUT_HANDLE ), &dwConsoleMode );
    SetConsoleMode(
          GetStdHandle( STD_INPUT_HANDLE )
        , dwConsoleMode & ~( ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT )
        );

    // Read from the console.
    while ( TRUE )
    {
        fSuccess = ReadConsoleW(
                          GetStdHandle( STD_INPUT_HANDLE )
                        , &wch
                        , 1
                        , &cchRead
                        , NULL
                        );
        if ( ! fSuccess || ( cchRead != 1 ) )
        {
            wch = 0xffff;
        }

        if ( ( wch == L'\r' ) || ( wch == 0xffff ) )    // end of the line
            break;

        if ( wch == L'\b' )                             // back up one or two
        {
            //
            // IF pwsz == pwszPasswordOut then we are at the
            // beginning of the line and the next two lines are
            // a no op.
            //
            if ( pwsz != pwszPasswordOut )
            {
                pwsz--;
                cchTotal--;
            }
        } // if: BACKSPACE
        else
        {
            *pwsz = wch;

            if ( cchTotal < cchMax )
            {
                pwsz++;     // don't overflow buf
            }
            cchTotal++;     // always increment len
        } // else: not BACKSPACE
    } // while TRUE

    // Reset the console mode and NUL-terminate the string.
    SetConsoleMode( GetStdHandle( STD_INPUT_HANDLE ), dwConsoleMode );
    *pwsz = L'\0';
    putwchar( L'\n' );

    return dwStatus;

} //*** DwGetPassword()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  MatchCRTLocaleToConsole( void )
//
//  Description:
//      Set's C runtime library's locale to match the console's output code page.
//      
//  Exceptions:
//      None.
//
//  Return Values:
//      TRUE   -- Operation was successful.
//      FALSE  -- _wsetlocale returned null, indicating an error.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
MatchCRTLocaleToConsole( void )
{
    UINT    nCodepage;
    WCHAR   szCodepage[ 16 ] = L".OCP"; // Defaults to the current OEM
                                        // code page obtained from the
                                        // operating system in case the
                                        // logic below fails.
    WCHAR*  wszResult = NULL;

    nCodepage = GetConsoleOutputCP();
    if ( nCodepage != 0 )
    {
        wsprintfW( szCodepage, L".%u", nCodepage );
    }

    wszResult = _wsetlocale( LC_ALL, szCodepage );
    return ( wszResult != NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\admcommonres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AdmCommonRes.h
//
//  Abstract:
//      Definition of resource constants used with the cluster admin
//      common directory.
//
//  Implementation File:
//      AdmCommonRes.rc
//
//  Author:
//      David Potter (davidp)   February 20, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#define __ADMCOMMONRES_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define ADMC_IDS_REQUIRED_FIELD_EMPTY   0xD000
#define ADMC_IDS_PATH_IS_INVALID        0xD001
#define ADMC_IDS_EMPTY_RIGHT_LIST       0xD002
#define ADMC_IDS_CLSIDFROMSTRING_ERROR  0xD003
#define ADMC_IDS_EXT_CREATE_INSTANCE_ERROR 0xD004
#define ADMC_IDS_EXT_ADD_PAGES_ERROR    0xD005
#define ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR 0xD006
#define ADMC_IDS_INSERT_MENU_ERROR      0xD007
#define ADMC_IDS_ADD_PAGE_TO_PROP_SHEET_ERROR 0xD008
#define ADMC_IDS_ADD_FIRST_PAGE_TO_PROP_SHEET_ERROR 0xD009
#define ADMC_IDS_CREATE_EXT_PAGE_ERROR  0xD00A
#define ADMC_IDS_ADD_PAGE_TO_WIZARD_ERROR 0xD00B
#define ADMC_IDS_INIT_EXT_PAGES_ERROR   0xD00C

#define ADMC_IDS_RESCLASS_UNKNOWN       0xD050
#define ADMC_IDS_RESCLASS_STORAGE       0xD051

#define ADMC_ID_MENU_PROPERTIES         0xD100
#define ADMC_ID_MENU_WHATS_THIS         0xD101

#define ADMC_IDC_LCP_NOTE               0xD200
#define ADMC_IDC_LCP_LEFT_LABEL         0xD201
#define ADMC_IDC_LCP_LEFT_LIST          0xD202
#define ADMC_IDC_LCP_ADD                0xD203
#define ADMC_IDC_LCP_REMOVE             0xD204
#define ADMC_IDC_LCP_RIGHT_LABEL        0xD205
#define ADMC_IDC_LCP_RIGHT_LIST         0xD206
#define ADMC_IDC_LCP_MOVE_UP            0xD207
#define ADMC_IDC_LCP_MOVE_DOWN          0xD208
#define ADMC_IDC_LCP_PROPERTIES         0xD209

// Property Sheet control id's (determined with Spy++ by MFC)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025

/////////////////////////////////////////////////////////////////////////////

#endif // __ADMCOMMONRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\admnetutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AdmNetUtils.cpp
//
//	Abstract:
//		Declaration of network utility functions.
//
//	Implementation File:
//		AdmNetUtils.cpp
//
//	Author:
//		David Potter (davidp)	February 19, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMNETUTILS_H_
#define __ADMNETUTILS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

BOOL BIsValidIpAddress(IN LPCWSTR pszAddress);
BOOL BIsValidSubnetMask(IN LPCWSTR pszMask);
BOOL BIsValidIpAddressAndSubnetMask(IN LPCWSTR pszAddress, IN LPCWSTR pszMask);
BOOL BIsIpAddressInUse(IN LPCWSTR pszAddress);

/////////////////////////////////////////////////////////////////////////////

#endif // __ADMNETUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\admnetutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AdmNetUtils.cpp
//
//	Abstract:
//		Implementation of network utility functions.
//
//	Author:
//		David Potter (davidp)	February 19, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <wtypes.h>
#include "clusrtl.h"
#include "AdmNetUtils.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsValidIpAddress
//
//	Routine Description:
//		Determine if the specified string is a valid IP address.
//
//	Arguments:
//		pszAddress	[IN] Address string to validate.
//
//	Return Value:
//		TRUE		String is valid IP address.
//		FALSE		String is not a valid IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsValidIpAddress( IN LPCWSTR pszAddress )
{
	ULONG	nAddress;
	DWORD	nStatus;
	BOOL	bIsValid = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
	if ( nStatus == ERROR_SUCCESS )
	{
		bIsValid = ClRtlIsValidTcpipAddress( nAddress );
	} // if:  converted address successfully

	return bIsValid;

}  //*** BIsValidIpAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsValidSubnetMask
//
//	Routine Description:
//		Determine if the specified string is a valid IP subnet mask.
//
//	Arguments:
//		pszMask	[IN] Subnet mask string to validate.
//
//	Return Value:
//		TRUE		String is a valid subnet mask.
//		FALSE		String is not a valid subnet mask.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsValidSubnetMask( IN LPCWSTR pszMask )
{
	ULONG	nMask;
	DWORD	nStatus;
	BOOL	bIsValid = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszMask, &nMask );
	if ( nStatus == ERROR_SUCCESS )
	{
		bIsValid = ClRtlIsValidTcpipSubnetMask( nMask );
	} // if:  converted mask successfully

	return bIsValid;

}  //*** BIsValidSubnetMask()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsValidIpAddressAndSubnetMask
//
//	Routine Description:
//		Determine if the specified IP address and subnet mask strings are
//		valid when used together.
//
//	Arguments:
//		pszAddress	[IN] Address string to validate.
//		pszMask	[IN] Subnet mask string to validate.
//
//	Return Value:
//		TRUE		Address and mask are valid together.
//		FALSE		Address and mask are not valid when used together.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsValidIpAddressAndSubnetMask( IN LPCWSTR pszAddress, IN LPCWSTR pszMask )
{
	ULONG	nAddress;
	ULONG	nMask;
	DWORD	nStatus;
	BOOL	bIsValid = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
	if ( nStatus == ERROR_SUCCESS )
	{
		nStatus = ClRtlTcpipStringToAddress( pszMask, &nMask );
		if ( nStatus == ERROR_SUCCESS )
		{
			bIsValid = ClRtlIsValidTcpipAddressAndSubnetMask( nAddress, nMask );
		} // if:  converted mask successfully
	} // if:  converted address successfully

	return bIsValid;

}  //*** BIsValidIpAddressAndSubnetMask()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsIpAddressInUse
//
//	Routine Description:
//		Determine if the specified IP address is already in use (exists
//		on the network).
//
//	Arguments:
//		pszAddress	[IN] Address string to check.
//
//	Return Value:
//		TRUE		Address is already in use.
//		FALSE		Address is available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsIpAddressInUse( IN LPCWSTR pszAddress )
{
	ULONG	nAddress;
	DWORD	nStatus;
	BOOL	bIsInUse = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
	if ( nStatus == ERROR_SUCCESS )
	{
		bIsInUse = ClRtlIsDuplicateTcpipAddress( nAddress );
	} // if:  converted address successfully

	return bIsInUse;

} //*** BIsIpAddressInUse()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbaseapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseApp.h
//
//	Description:
//		Definition of the CBaseApp class.
//
//	Author:
//		Galen Barbee (galenb)	May 21, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEAPP_H_
#define __ATLBASEAPP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseApp
//
//	Description:
//		Base application class.  The following functionality is provided:
//		-- Help file support.
//
//	Inheritance:
//		CBaseApp
//		CComModule
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBaseApp : public CComModule
{
public:
	//
	// Construction.
	//

	// Default constructor
	CBaseApp( void )
		: m_pszHelpFilePath( NULL )
	{
	} //*** CBaseApp()

	// Destructor
	~CBaseApp( void )
	{
		delete m_pszHelpFilePath;

	} //*** ~CBaseApp()

	// Return the path to the help file, generate if necessary
	virtual LPCTSTR PszHelpFilePath( void )
	{
		//
		// If no help file path has been specified yet, generate
		// it from the module path name.
		//
		if ( m_pszHelpFilePath == NULL )
		{
			TCHAR szPath[_MAX_PATH];
			TCHAR szDrive[_MAX_PATH]; // not _MAX_DRIVE so we can support larger device names
			TCHAR szDir[_MAX_DIR];

			//
			// Get the path to this module.  Split out the drive and
			// directory and set the help file path to that combined
			// with the help file name.
			//
			if ( ::GetModuleFileName( GetModuleInstance(), szPath, _MAX_PATH ) > 0 )
			{
				_tsplitpath( szPath, szDrive, szDir, NULL, NULL );
				_tmakepath( szPath, szDrive, szDir, PszHelpFileName(), NULL );

				m_pszHelpFilePath = new TCHAR [lstrlen( szPath ) + 1];
				ATLASSERT( m_pszHelpFilePath != NULL );
				if ( m_pszHelpFilePath != NULL )
				{
					lstrcpy( m_pszHelpFilePath, szPath );
				} // if:  buffer allocated successfully
			} // if:  module path obtained successfully
		} // if:  no help file path specified yet

		return m_pszHelpFilePath;

	} //*** PszHelpFilePath()

	// Return the name of the help file
	virtual LPCTSTR PszHelpFileName( void )
	{
		//
		// Override this method or no help file name will
		// be specified for this application.
		//
		return NULL;

	} //*** PszHelpFileName()

private:
	LPTSTR	m_pszHelpFilePath;

}; //*** class CBaseApp

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseDlg.h
//
//	Desription:
//		Definition of the CBaseDlg class.
//
//	Author:
//		David Potter (davidp)	February 9, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEDLG_H_
#define __ATLBASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T > class CBaseDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for DBG_xxx routines
#endif

#ifndef __ATLPOPUPHELP_H_
#include "AtlPopupHelp.h"	// for COnlineHelp
#endif

#ifndef __CTRLUTIL_H
#include "DlgItemUtils.h"	// for CDlgItemUtils
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseDlg
//
//	Description:
//		Base dialog class.  Provides the following features:
//		-- Popup help.
//		-- Dialog item utilities.
//		-- Debugging support.
//
//	Inheritance:
//		CBaseDlg< T >
//		CDialogImpl< T >, CPopupHelp< T >, CDlgItemUtils
//
//--
/////////////////////////////////////////////////////////////////////////////

template< class T >
class CBaseDlg
	: public CDialogImpl< T >
	, public CPopupHelp< T >
	, public CDlgItemUtils
{
	typedef CBaseDlg< T > thisClass;
	typedef CDialogImpl< T > baseClass;

public:
	//
	// Construction
	//

	// Constructor taking a string pointer for the title
	CBaseDlg(
		IN OUT LPCTSTR	lpszTitle = NULL
		)
	{
		if ( lpszTitle != NULL )
		{
			m_strTitle = lpszTitle;
		} // if:  title specified

	} //*** CBaseDlg( lpszTitle )

	// Constructor taking a resource ID for the title
	CBaseDlg( IN UINT nIDTitle )
	{
		m_strTitle.LoadString( nIDTitle );

	} //*** CBaseDlg( nIDTitle )

	// Initialize the page
	virtual BOOL BInit( void )
	{
		return TRUE;

	} //*** BInit()

protected:
	//
	// CBasePage helper methods.
	//

	// Attach a control to a dialog item.
	void AttachControl( CWindow & rwndControl, UINT idc )
	{
		HWND hwndControl = GetDlgItem( idc );
		ATLASSERT( hwndControl != NULL );
		rwndControl.Attach( hwndControl );

	} //*** AttachControl()

public:
	//
	// CBaseDlg public methods to override.
	//

	// Update data on or from the page
	virtual BOOL UpdateData( BOOL bSaveAndValidate )
	{
		return TRUE;

	} //*** UpdateData()

public:
	//
	// Message handler functions.
	//

	BEGIN_MSG_MAP( CBaseDlg< T > )
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
#if DBG
#ifdef _DBG_MSG
		MESSAGE_RANGE_HANDLER( 0, 0xffffffff, OnMsg )
#endif // _DBG_MSG
#ifdef _DBG_MSG_NOTIFY
		MESSAGE_HANDLER( WM_NOTIFY, OnNotify )
#endif // _DBG_MSG_NOTIFY
#ifdef _DBG_MSG_COMMAND
		MESSAGE_HANDLER( WM_COMMAND, OnCommand )
#endif // _DBG_MSG_COMMAND
#endif // DBG
		CHAIN_MSG_MAP( CPopupHelp< T > )
	END_MSG_MAP()

	// Handler for the WM_INITDIALOG message
	LRESULT OnInitDialog(
				UINT	uMsg,
				WPARAM	wParam,
				LPARAM	lParam,
				BOOL &	bHandled
				)
	{
		T * pT = static_cast< T * >( this );
		return pT->OnInitDialog();

	} //*** OnInitDialog()

	// Handler for the WM_INITDIALOG message
	LRESULT OnInitDialog( void )
	{
		return TRUE;

	} //*** OnInitDialog()

#if DBG && defined( _DBG_MSG )
	// Handler for any message
	LRESULT OnMsg( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnMsg( uMsg, wParam, lParam, bHandled, T::s_pszClassName );

	} //*** OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
	// Handler for the WM_NOTIFY message
	LRESULT OnNotify( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnNotify( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
	// Handler for the WM_COMMAND message
	LRESULT OnCommand( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnCommand( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )

// Implementation
protected:
	CString m_strTitle;		// Used to support resource IDs for the title.

	const CString & StrTitle( void ) const	{ return m_strTitle; }

}; //*** class CBaseDlg

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbaseproppage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBasePropPage.cpp
//
//	Description:
//		Definition of the CBasePropertyPageWindow and CBasePropertyPageImpl
//		classes.
//
//	Implementation File:
//		None.
//
//	Author:
//		David Potter (davidp)	February 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPROPPAGE_H_
#define __ATLBASEPROPPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPageWindow;
class CStaticPropertyPageWindow;
class CDynamicPropertyPageWindow;
class CExtensionPropertyPageWindow;
template < class T, class TWin > class CBasePropertyPageImpl;
template < class T > class CStaticPropertyPageImpl;
template < class T > class CDynamicPropertyPageImpl;
template < class T > class CExtensionPropertyPageImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheetWindow;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPAGE_H_
#include "AtlBasePage.h"	// for CBasePageWindow, CBasePageImpl
#endif

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for debugging definitions
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef std::list< CBasePropertyPageWindow * > CPropertyPageList;
typedef std::list< CStaticPropertyPageWindow * > CStaticPropertyPageList;
typedef std::list< CDynamicPropertyPageWindow * > CDynamicPropertyPageList;
typedef std::list< CExtensionPropertyPageWindow * > CExtensionPropertyPageList;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertyPageWindow
//
//	Description:
//		Base property sheet page window for standard property sheets.
//
//	Inheritance:
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPageWindow : public CBasePageWindow
{
	typedef CBasePageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CBasePropertyPageWindow()

public:
	//
	// Message handler functions.
	//

	// Handler for PSN_KILLACTIVE
	BOOL OnKillActive( void )
	{
		return UpdateData( TRUE /*bSaveAndValidate*/ );

	} //*** OnKillActive()

// Implementation
protected:
	// Return pointer to the base sheet object
	CBasePropertySheetWindow * Pbsht( void ) const
	{
		return (CBasePropertySheetWindow *) Psht();

	} //*** Pbsht()

public:

}; //*** class CBasePropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticPropertyPageWindow
//
//	Description:
//		Base property sheet page window for pages added to a standard
//		property sheet before the call to PropertySheet().  This page cannot
//		be removed from the sheet.
//
//	Inheritance:
//		CStaticPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CStaticPropertyPageWindow : public CBasePropertyPageWindow
{
	typedef CBasePropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CStaticPropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CStaticPropertyPageWindow()

}; //*** class CStaticPropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicPropertyPageWindow
//
//	Description:
//		Base property sheet page window for pages added to a standard
//		property sheet after the call to PropertySheet().  This page may be
//		removed from the sheet.
//
//	Inheritance:
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDynamicPropertyPageWindow : public CBasePropertyPageWindow
{
	typedef CBasePropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CDynamicPropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_hpage( NULL )
		, m_bPageAddedToSheet( FALSE )
	{
	} //*** CDynamicPropertyPageWindow()

	// Destructor
	~CDynamicPropertyPageWindow( void )
	{
		//
		// Destroy the page if it hasn't been added to the sheet yet.
		// If it has been added to the sheet, the sheet will destroy it.
		//
		if (   (m_hpage != NULL)
			&& ! m_bPageAddedToSheet )
		{
			DestroyPropertySheetPage( m_hpage );
			m_hpage = NULL;
		} // if:  page not deleted yet

	} //*** ~CDynamicPropertyPageWindow()

	// Create the page
	virtual DWORD ScCreatePage( void ) = 0;

protected:
	HPROPSHEETPAGE	m_hpage;
	BOOL			m_bPageAddedToSheet;

public:
	// Property page handle
	HPROPSHEETPAGE Hpage( void ) const { return m_hpage; }

	// Set whether the page has been added to the sheet or not
	void SetPageAdded( IN BOOL bAdded = TRUE )
	{
		m_bPageAddedToSheet = bAdded;
		if ( ! bAdded )
		{
			m_hpage = NULL;
		} // if:  removing page

	} //*** SetPageAdded()

}; //*** class CDynamicPropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizardPageWindow
//
//	Description:
//		Base property sheet page window for pages added to a standard
//		property sheet after the call to PropertySheet() identified as an
//		extension to the list of standard pages (whether static or dynamic).
//		This page may be removed from the sheet.
//
//	Inheritance:
//		CExtensionPropertyPageWindow
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CExtensionPropertyPageWindow : public CDynamicPropertyPageWindow
{
	typedef CDynamicPropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CExtensionPropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CExtensionPropertyPageWindow()

}; //*** class CExtensionPropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for standard property sheets.
//
//	Inheritance:
//		CBasePropertyPageImpl< T, TWin >
//		CBasePageImpl< T, TWin >
//		CPropertyPageImpl< T, TWin >
//		<TWin>
//		...
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TWin = CBasePropertyPageWindow >
class CBasePropertyPageImpl : public CBasePageImpl< T, TWin >
{
	typedef CBasePropertyPageImpl< T, TWin > thisClass;
	typedef CBasePageImpl< T, TWin > baseClass;

public:

	//
	// Construction
	//

	// Standard constructor
	CBasePropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CBasePropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CBasePropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CBasePropertyPageImpl( nIDCaption )

	// Initialize the page
	virtual BOOL BInit( CBaseSheetWindow * psht )
	{
		if ( ! baseClass::BInit( psht ) )
			return FALSE;
		return TRUE;

	} //*** BInit()

public:
	//
	// Message handler functions.
	//

	// Handler for PSN_KILLACTIVE
	BOOL OnKillActive( void )
	{
		// Call the TWin method
		return TWin::OnKillActive();

	} //*** OnKillActive()

// Implementation
protected:

public:

}; //*** class CBasePropertyPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticPropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for pages added to a standard
//		property sheet before the call to PropertySheet().  This page cannot
//		be removed from the sheet.
//
//	Inheritance:
//		CStaticPropertyPageImpl< T >
//		CBasePropertyPageImpl< T, CStaticPropertyPageWindow >
//		CBasePageImpl< T, CStaticPropertyPageWindow >
//		CPropertyPageImpl< T, CStaticPropertyPageWindow >
//		CStaticPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CStaticPropertyPageImpl : public CBasePropertyPageImpl< T, CStaticPropertyPageWindow >
{
	typedef CStaticPropertyPageImpl< T > thisClass;
	typedef CBasePropertyPageImpl< T, CStaticPropertyPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CStaticPropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CStaticPropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CStaticPropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CStaticPropertyPageImpl( nIDTitle )

}; //*** class CStaticPropertyPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicPropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for pages added to a standard
//		property sheet after the call to PropertySheet() identified as an
//		Extension to the list of standard pages (whether static or dynamic).
//		This page may be removed from the sheet.
//
//	Inheritance:
//		CDynamicPropertyPageImpl< T >
//		CBasePropertyPageImpl< T, CDynamicPropertyPageWindow >
//		CBasePageImpl< T, CDynamicPropertyPageWindow >
//		CPropertyPageImpl< T, CDynamicPropertyPageWindow >
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CDynamicPropertyPageImpl : public CBasePropertyPageImpl< T, CDynamicPropertyPageWindow >
{
	typedef CDynamicPropertyPageImpl< T > thisClass;
	typedef CBasePropertyPageImpl< T, CDynamicPropertyPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CDynamicPropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CDynamicPropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CDynamicPropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CDynamicPropertyPageImpl( nIDTitle )

	// Create the page
	DWORD ScCreatePage( void )
	{
		ATLASSERT( m_hpage == NULL );

		m_hpage = CreatePropertySheetPage( &m_psp );
		if ( m_hpage == NULL )
		{
			return GetLastError();
		} // if:  error creating the page

		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CDynamicPropertyPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionPropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for pages added to a standard
//		property sheet after the call to PropertySheet() identified as an
//		extension to the list of standard pages (whether static or dynamic).
//		This page may be removed from the sheet.
//
//	Inheritance:
//		CExtensionPropertyPageImpl< T >
//		CBasePropertyPageImpl< T, CExtensionPropertyPageWindow >
//		CBasePageImpl< T, CExtensionPropertyPageWindow >
//		CPropertyPageImpl< T, CExtensionPropertyPageWindow >
//		CExtensionPropertyPageWindow
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CExtensionPropertyPageImpl : public CBasePropertyPageImpl< T, CExtensionPropertyPageWindow >
{
	typedef CExtensionPropertyPageImpl< T > thisClass;
	typedef CBasePropertyPageImpl< T, CExtensionPropertyPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CExtensionPropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CExtensionPropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CExtensionPropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CExtensionPropertyPageImpl( nIDTitle )

}; //*** class CExtensionPropertyPageImpl


/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEPROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasepropsheet.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AtlBasePropSheet.cpp
//
//  Abstract:
//      Implementation of the CBasePropertySheetWindow class.
//
//  Author:
//      David Potter (davidp)   February 26, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlBasePropSheet.h"
#include "AtlBasePropPage.h"
#include "AtlExtDll.h"
#include "StlUtils.h"
#include "ExcOper.h"
#include "AdmCommonRes.h"

/////////////////////////////////////////////////////////////////////////////
// class CBasePropertySheetWindow
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::~CBasePropertySheetWindow
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertySheetWindow::~CBasePropertySheetWindow( void )
{
    //
    // Delete pages from the page list.
    //
    if ( m_plppPages != NULL )
    {
        DeleteAllPtrListItems( m_plppPages );
        delete m_plppPages;
    } // if:  page array has been allocated

} //*** CBasePropertySheetWindow::~CBasePropertySheetWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::BInit
//
//  Routine Description:
//      Initialize the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Property sheet initialized successfully.
//      FALSE   Error initializing the property sheet.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheetWindow::BInit( void )
{
    ATLASSERT( PlppPages()->size() > 0 );
    ATLASSERT( m_hWnd == NULL );

    BOOL                        bSuccess = TRUE;
    CPropertyPageList::iterator itCurrent = PlppPages()->begin();
    CPropertyPageList::iterator itLast = PlppPages()->end();
    CStaticPropertyPageWindow * pspp;

    //
    // Add static pages.
    //
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        //
        // If this is a static page, add it to the list.
        //
        pspp = dynamic_cast< CStaticPropertyPageWindow * >( *itCurrent );
        if ( pspp != NULL )
        {
            //
            // Initialize the page.
            //
            bSuccess = pspp->BInit( this );
            if ( ! bSuccess )
            {
                break;
            } // if:  error initializing the page

            //
            // Add the page.
            //
            bSuccess = AddPage( pspp->Ppsp() );
            if ( ! bSuccess )
            {
                CNTException nte(
                    GetLastError(),
                    ADMC_IDS_ADD_PAGE_TO_PROP_SHEET_ERROR,
                    NULL,
                    NULL,
                    FALSE
                    );
                nte.ReportError();
                break;
            } // if:  error adding the page
        } // if:  static page
    }  // for:  each page

    return bSuccess;

} //*** CBasePropertySheetWindow::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::BAddPage
//
//  Routine Description:
//      Add a page to the page list.
//
//  Arguments:
//      ppp     [IN] Property page to add.
//
//  Return Value:
//      TRUE    Page added successfully.
//      FALSE   Error adding page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheetWindow::BAddPage( IN CBasePropertyPageWindow * ppp )
{
    ATLASSERT( ppp != NULL );

    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate the page array if it doesn't exist yet.
        //
        if ( m_plppPages == NULL )
        {
            m_plppPages = new CPropertyPageList;
            ATLASSERT( m_plppPages != NULL );
            if ( m_plppPages == NULL )
            {
                CNTException nte(
                    GetLastError(),
                    ADMC_IDS_ADD_FIRST_PAGE_TO_PROP_SHEET_ERROR,
                    NULL,
                    NULL,
                    FALSE
                    );
                nte.ReportError();
                break;
            } // if:  error allocating page list
        } // if:  no page array yet

        //
        // Insert the page at the end of the list.
        //
        PlppPages()->insert( PlppPages()->end(), ppp );

        bSuccess = TRUE;
    } while ( 0 );

    return bSuccess;

} //*** CBasePropertySheetWindow::BAddPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::OnSheetInitialized
//
//  Routine Description:
//      Handler for PSCB_INITIALIZED.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::OnSheetInitialized( void )
{
    //
    // Add dynamic pages, including extension pages.
    //
    {
        //
        // Get pointers to beginning and end of list.
        //
        CPropertyPageList::iterator itCurrent = PlppPages()->begin();
        CPropertyPageList::iterator itLast = PlppPages()->end();

        //
        // Loop through the list and add each dynamic page.
        //
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicPropertyPageWindow * pdpp = dynamic_cast< CDynamicPropertyPageWindow * >( *itCurrent );
            if ( pdpp != NULL )
            {
                if ( pdpp->Hpage() != NULL )
                {
                    AddPage( pdpp->Hpage() );
                    pdpp->SetPageAdded( TRUE );
                } // if:  page has already been created
            } // if:  dynamic page found
        } // for:  each item in the list

    } // Add dynamic pages, including extension pages

    //
    // Call the base class method.
    //
    CBaseSheetWindow::OnSheetInitialized();

} //*** CBasePropertySheetWindow::OnSheetInitialized()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      hfont       [IN] Font to use for the extension pages.
//      hicon       [IN] Icon to use for the extension pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::AddExtensionPages(
    IN HFONT    hfont,
    IN HICON    hicon
    )
{
    ATLASSERT( PcoObjectToExtend() != NULL );

    //
    // Add extension pages if there any extensions.
    //
    if (   (PcoObjectToExtend()->PlstrAdminExtensions() != NULL)
        && (PcoObjectToExtend()->PlstrAdminExtensions()->size() > 0) )
    {
        //
        // Get the currently selected page so we can reset it when we're done.
        //
        CTabCtrl tabc( GetTabControl() );
        int nCurPage = tabc.GetCurSel();

        //
        // Prepare to add extension pages.
        //
        CDynamicPropertyPageList ldpp;
        PrepareToAddExtensionPages( ldpp );

        //
        // If no extensions object has been created yet, create it now.
        //
        if ( Pext() == NULL )
        {
            m_pext = new CCluAdmExtensions;
            ATLASSERT( m_pext != NULL );
        } // if:  no extensions list yet

        //
        // Enclose the loading of the extension in a try/catch block so
        // that the loading of the extension won't prevent all pages
        // from being displayed.
        //
        try
        {
            Pext()->CreatePropertySheetPages(
                    this,
                    *PcoObjectToExtend()->PlstrAdminExtensions(),
                    PcoObjectToExtend(),
                    hfont,
                    hicon
                    );
        } // try
        catch (...)
        {
        } // catch:  anything

        //
        // Complete the process of adding extension pages.
        //
        CompleteAddingExtensionPages( ldpp );

        //
        // Restore the current selection.
        // This has to be done because sometimes the above process causes
        // the current page to be set to the last page added, which prevents
        // the next page from being displayed.
        //
        SetActivePage( nCurPage );
    } // if:  object has extensions
    else
    {
        //
        // Remove extension pages.
        //
        RemoveAllExtensionPages();
    } // else:  object doesn't have extensions

}  //*** CBasePropertySheetWindow::AddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::PrepareToAddExtensionPages
//
//  Routine Description:
//      Prepare to add extension pages by deleting existing extension
//      pages and removing dynamic pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::PrepareToAddExtensionPages(
    CDynamicPropertyPageList & rldpp
    )
{
    //
    // Delete all extension pages.
    //
    RemoveAllExtensionPages();

    //
    // Move all dynamic pages to the temporary list.
    //
    ATLASSERT( rldpp.size() == 0);
    MovePtrListItems< CBasePropertyPageWindow *, CDynamicPropertyPageWindow * >( PlppPages(), &rldpp );

    //
    // Remove all pages in the temporary list from the property sheet.
    // The page must have already been created because we don't have
    // any access to the PROPSHEETPAGE structure to create it
    // during the completion phase.
    //
    {
        CDynamicPropertyPageList::iterator itCurrent;
        CDynamicPropertyPageList::iterator itLast;

        itCurrent = rldpp.begin();
        itLast = rldpp.end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicPropertyPageWindow * pdpp = *itCurrent;
            ATLASSERT( pdpp != NULL );
            if ( pdpp->Hpage() != NULL )
            {
                RemovePage( pdpp->Hpage() );
                pdpp->SetPageAdded( FALSE );
            } // if:  page already created
        } // for:  each page in the list
    } // Remove dynamic pages

} //*** CBasePropertySheetWindow::PrepareToAddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::HrAddExtensionPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      ppage       [IN OUT] Page to be added.
//
//  Return Value:
//      S_OK        Page added successfully.
//      S_FALSE     Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertySheetWindow::HrAddExtensionPage( IN CBasePageWindow * ppage )
{
    ATLASSERT( ppage != NULL );

    HRESULT hr = S_OK;

    CExtensionPropertyPageWindow * pepp = dynamic_cast< CExtensionPropertyPageWindow * >( ppage );
    ATLASSERT( pepp != NULL );

    if (   (ppage == NULL)
        || (pepp == NULL ) )
    {
        return S_FALSE;
    } // if:  invalid arguments

    //
    // Add the page to the sheet.
    //
    if ( m_hWnd != NULL )
    {
        AddPage( pepp->Hpage() );
        pepp->SetPageAdded( TRUE );
    } // if:  sheet is being displayed

    //
    // Add the page to the end of the list.
    //
    PlppPages()->insert( PlppPages()->end(), reinterpret_cast< CBasePropertyPageWindow * >( ppage ) );

    return hr;

}  //*** CBasePropertySheetWindow::HrAddExtensionPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::CompleteAddingExtensionPages
//
//  Routine Description:
//      Complete the process of adding extension pages to the sheet by
//      re-adding dynamic pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::CompleteAddingExtensionPages(
    CDynamicPropertyPageList & rldpp
    )
{
    DWORD                           sc;
    CDynamicPropertyPageWindow *    pdpp;

    //
    // Move all pages from the temporary list to the real list and
    // add them to the end of the sheet.
    //
    CDynamicPropertyPageList::iterator itCurrent = rldpp.begin();
    CDynamicPropertyPageList::iterator itLast = rldpp.end();
    while ( itCurrent != itLast )
    {
        pdpp = *itCurrent;
        ATLASSERT( pdpp != NULL );

        //
        // Create the page.
        //
        sc = pdpp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, ADMC_IDS_CREATE_EXT_PAGE_ERROR, NULL, NULL, FALSE );
            delete pdpp;
            itCurrent = rldpp.erase( itCurrent );
            continue;
        } // if:  error creating the page

        //
        // Add the page to the sheet.
        //
        ATLASSERT( pdpp->Hpage() != NULL );
        AddPage( pdpp->Hpage() );
        pdpp->SetPageAdded( TRUE );

        //
        // Move the page to real list.
        //
        PlppPages()->insert( PlppPages()->end(), pdpp );
        itCurrent = rldpp.erase( itCurrent );
    } // while:  not at last page

} //*** CBasePropertySheetWindow::CompleteAddingExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::RemoveAllExtensionPages
//
//  Routine Description:
//      Remove all extension pages from the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::RemoveAllExtensionPages( void )
{
    //
    // Remove the extension pages.
    //
    CExtensionPropertyPageList lepp;
    MovePtrListItems< CBasePropertyPageWindow *, CExtensionPropertyPageWindow * >( PlppPages(), &lepp );
    CExtensionPropertyPageList::iterator itCurrent = lepp.begin();
    CExtensionPropertyPageList::iterator itLast = lepp.end();
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        CExtensionPropertyPageWindow * pepp = *itCurrent;
        ATLASSERT( pepp != NULL );
        if ( pepp->Hpage() != NULL )
        {
            RemovePage( pepp->Hpage() );
            pepp->SetPageAdded( FALSE );
        } // if:  page already created
    } // for:  each page in the list
    DeleteAllPtrListItems( &lepp );

} //*** CBasePropertySheetWindow::RemoveAllExtensionPages()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasepropsheet.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBasePropSheet.h
//
//	Implementation File:
//		AtlBasePropSheet.cpp.
//
//	Description:
//		Definition of the CBasePropertySheetWindow and CBasePropertySheetImpl
//		classes.
//
//	Author:
//		David Potter (davidp)	February 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPROPSHEET_H_
#define __ATLBASEPROPSHEET_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters in the browser information

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheetWindow;
template < class T, class TBase > class CBasePropertySheetImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASESHEET_H_
#include "AtlBaseSheet.h"		// for CBaseSheetWindow;
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"	// for CPropertyPageList
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertySheetWindow
//
//	Description:
//		Base standard property sheet window.
//
//	Inheritance:
//		CBasePropertySheetWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheetWindow : public CBaseSheetWindow
{
	typedef CBaseSheetWindow baseClass;

	friend class CBasePropertyPageWindow;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePropertySheetWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_plppPages( NULL )
		, m_pcoObjectToExtend( NULL )
	{
	} //*** CBasePropertySheetWindow()

	// Destructor
	~CBasePropertySheetWindow( void );

	// Initialize the sheet
	BOOL BInit( void );

protected:
	CPropertyPageList *	m_plppPages;			// List of pages in the sheet.
	CClusterObject *	m_pcoObjectToExtend;	// Cluster object to extend.

public:
	// Access list of pages in the sheet
	CPropertyPageList * PlppPages( void )
	{
		ATLASSERT( m_plppPages != NULL );
		return m_plppPages;

	} //*** PlppPages()

	// Access the cluster object to extend
	CClusterObject * PcoObjectToExtend( void ) { return m_pcoObjectToExtend; }

	// Set the object to extend
	void SetObjectToExtend( IN CClusterObject * pco )
	{
		ATLASSERT( pco != NULL );
		m_pcoObjectToExtend = pco;

	} //*** SetObjectToExtend()

public:
	// Add a page (required to get to base class method)
	void AddPage( HPROPSHEETPAGE hPage )
	{
		baseClass::AddPage( hPage );

	} //*** AddPage( hPage )

	// Add a page (required to get to base class method)
	BOOL AddPage( LPCPROPSHEETPAGE pPage )
	{
		return baseClass::AddPage( pPage );

	} //*** AddPage( pPage )

	// Add a page to sheet
	BOOL BAddPage( IN CBasePropertyPageWindow * ppp );

public:
	//
	// Overrides of abstract methods.
	//

	// Add extension pages to the sheet
	virtual void AddExtensionPages( IN HFONT hfont, IN HICON hicon );

	// Add a page (called by extension)
	virtual HRESULT HrAddExtensionPage( IN CBasePageWindow * ppage );

public:
	//
	// Message handler functions.
	//

	// Handler for PSCB_INITIALIZED
	void OnSheetInitialized( void );

// Implementation
protected:
	// Prepare to add exension pages to the sheet
	void PrepareToAddExtensionPages( CDynamicPropertyPageList & rldpp );

	// Complete the process of adding extension pages
	void CompleteAddingExtensionPages( CDynamicPropertyPageList & rldpp );

	// Remove all extension pages from the property sheet
	void RemoveAllExtensionPages( void );

}; //*** class CBasePropertySheetWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertySheetImpl
//
//	Description:
//		Base standard property sheet implementation.
//
//	Inheritance:
//		CBasePropertySheetImpl< T, TBase >
//		CBaseSheetImpl< T, TBase >
//		CPropertySheetImpl< T, TBase >
//		<TBase>
//		...
//		CBasePropertySheetWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CBasePropertySheetWindow >
class CBasePropertySheetImpl : public CBaseSheetImpl< T, TBase >
{
	typedef CBasePropertySheetImpl< T, TBase > thisClass;
	typedef CBaseSheetImpl< T, TBase > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePropertySheetImpl(
		IN LPCTSTR	lpszTitle = NULL,
		IN UINT		uStartPage = 0
		)
		: baseClass( lpszTitle, uStartPage )
	{
		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CBasePropertySheetWindow( lpszTitle )

	// Constructor taking a resource ID for the title
	CBasePropertySheetImpl(
		IN UINT nIDTitle,
		IN UINT uStartPage = 0
		)
		: baseClass( NULL, uStartPage )
	{
		m_strTitle.LoadString( nIDTitle );
		m_psh.pszCaption = m_strTitle;

		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CBasePropertySheetImpl( nIDTitle )

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( thisClass )
//		CHAIN_MSG_MAP( baseClass );
//	END_MSG_MAP()

	//
	// Message handler functions.
	//

// Implementation
protected:
	CString				m_strTitle;		// Used to support resource IDs for the title.

public:
	const CString &		StrTitle( void ) const					{ return m_strTitle; }
	void				SetTitle( LPCTSTR lpszText, UINT nStyle = 0 )
	{
		baseClass::SetTitle( lpszText, nStyle );
		m_strTitle = lpszText;

	} //*** SetTitle()

}; //*** class CBasePropertySheetImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEPROPSHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBasePage.h
//
//	Description:
//		Definition of the CBasePageWindow and CBasePageImpl classes.
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPAGE_H_
#define __ATLBASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePageWindow;
template < class T, class TBase > class CBasePageImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseSheetWindow;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for DBG_xxx routines
#endif

#ifndef __DLGITEMUTILS_H_
#include "DlgItemUtils.h"	// for CDlgItemUtils
#endif

#ifndef __ATLBASESHEET_H_
#include "AtlBaseSheet.h"	// for CBaseSheetWindow for BReadOnly()
#endif

#ifndef __ATLPOPUPHELP_H_
#include "AtlPopupHelp.h"	// for COnlineHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePageWindow
//
//	Description:
//		Base property sheet page window for all kinds of property sheets.
//
//	Inheritance:
//		CBasePageWindow
//		CPropertyPageWindow, CDlgItemUtils
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePageWindow
	: public CPropertyPageWindow
	, public CDlgItemUtils
{
	typedef CPropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_bReadOnly( FALSE )
		, m_psht( NULL )
		, m_ppsp( NULL )
	{
	} //*** CBasePageWindow()

	// Destructor
	virtual ~CBasePageWindow( void )
	{
		//
		// This must be virtual so that a pointer to an object
		// of type CBasePropertyPageWindow can be held and then later
		// deleted.  That way the derived class's destructor will
		// be called.
		//

	} //*** ~CBasePageWindow()

	// Initialize the page
	virtual BOOL BInit( IN CBaseSheetWindow * psht )
	{
		ATLASSERT( psht != NULL );
		ATLASSERT( m_psht == NULL );
		m_psht = psht;
		return TRUE;

	} //*** BInit()

protected:
	//
	// CBasePageWindow helper methods.
	//

	// Attach a control to a dialog item.
	void AttachControl( CWindow & rwndControl, UINT idc )
	{
		HWND hwndControl = GetDlgItem( idc );
		ATLASSERT( hwndControl != NULL );
		rwndControl.Attach( hwndControl );

	} //*** AttachControl()

public:
	//
	// CBasePageWindow public methods to override.
	//

	// Update data on or from the page
	virtual BOOL UpdateData( IN BOOL bSaveAndValidate )
	{
		return TRUE;

	} //*** UpdateData()

	// Apply changes made on this page to the sheet
	virtual BOOL BApplyChanges( void )
	{
		return TRUE;

	} //*** BApplyChanges()

public:
	//
	// Message handler functions.
	//

	// Handler for WM_INITDIALOG
	BOOL OnInitDialog( void )
	{
		return TRUE;

	} //*** OnInitDialog()

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void )
	{
		return UpdateData( FALSE /*bSaveAndValidate*/ );

	} //*** OnSetActive()

	// Handler for PSN_APPLY
	BOOL OnApply( void )
	{
		// Update the data in the class from the page.
		if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
		{
			return FALSE;
		} // if:  error updating data

		// Save the data in the sheet.
		if ( ! BApplyChanges() )
		{
			return FALSE;
		} // if:  error applying changes

		return TRUE;

	} //*** OnApply()

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;

	} //*** OnWizardNext()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		return TRUE;

	} //*** OnWizardFinish()

	// Handler for PSN_RESET
	void OnReset( void )
	{
	} //*** OnReset()

// Implementation
protected:
	PROPSHEETPAGE * 	m_ppsp; 		// Pointer to property sheet header in impl class.
	CBaseSheetWindow *	m_psht; 		// Pointer to sheet this page belongs to.
	BOOL				m_bReadOnly;	// Set if the page cannot be changed.
	CString 			m_strTitle; 	// Used to support resource IDs for the title.

	CBaseSheetWindow *	Psht( void ) const		{ return m_psht; }
	BOOL				BReadOnly( void ) const { return m_bReadOnly || Psht()->BReadOnly(); }
	const CString & 	StrTitle( void ) const	{ return m_strTitle; }

public:
	// Return a pointer to the property page header
	PROPSHEETPAGE * Ppsp( void ) const
	{
		ATLASSERT( m_ppsp != NULL );
		return m_ppsp;

	} //*** Ppsp()

}; //*** class CBasePageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePageImpl
//
//	Purpose:
//		Base property sheet page implementation for all kinds of property
//		sheets.
//
//	Inheritance:
//		CBasePageImpl< T, TBase >
//		CPropertyPageImpl< T, TBase >, CPopupHelp< T >
//		<TBase>
//		...
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CBasePageWindow >
class CBasePageImpl
	: public CPropertyPageImpl< T, TBase >
	, public CPopupHelp< T >
{
	typedef CBasePageImpl< T, TBase > thisClass;
	typedef CPropertyPageImpl< T, TBase > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePageImpl(
		LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CBasePageImpl()

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
#if DBG
#ifdef _DBG_MSG
		MESSAGE_RANGE_HANDLER( 0, 0xffffffff, OnMsg )
#endif // _DBG_MSG
#ifdef _DBG_MSG_NOTIFY
		MESSAGE_HANDLER( WM_NOTIFY, OnNotify )
#endif // _DBG_MSG_NOTIFY
#ifdef _DBG_MSG_COMMAND
		MESSAGE_HANDLER( WM_COMMAND, OnCommand )
#endif // _DBG_MSG_COMMAND
#endif // DBG
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		CHAIN_MSG_MAP( CPopupHelp< T > )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

#if DBG && defined( _DBG_MSG )
	// Handler for any message
	LRESULT OnMsg( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnMsg( uMsg, wParam, lParam, bHandled, T::s_pszClassName );

	} //*** OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
	// Handler for the WM_NOTIFY message
	LRESULT OnNotify( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnNotify( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
	// Handler for the WM_COMMAND message
	LRESULT OnCommand( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnCommand( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )

	//
	// Message handler functions.
	//

	// Handler for WM_INITDIALOG
	LRESULT OnInitDialog(
				UINT	uMsg,
				WPARAM	wParam,
				LPARAM	lParam,
				BOOL &	bHandled
				)
	{
		T * pT = static_cast< T * >( this );
		return pT->OnInitDialog();

	} //*** OnInitDialog()

	// Handler for WM_INITDIALOG
	BOOL OnInitDialog( void )
	{
		return baseClass::OnInitDialog();

	} //*** OnInitDialog()

	//
	// These notification handlers are needed because CPropertyPageImpl
	// implements them itself, which prevents the call from making it
	// to the window class.
	//

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnSetActive();

	} //*** OnSetActive()

	// Handler for PSN_APPLY
	BOOL OnApply( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnApply();

	} //*** OnApply()

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnWizardBack();

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnWizardNext();

	} //*** OnWizardNext()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnWizardFinish();

	} //*** OnWizardFinish()

	// Handler for PSN_RESET
	void OnReset( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		TBase::OnReset();

	} //*** OnReset()

// Implementation
protected:

public:

}; //*** class CBasePageImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasesheet.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseSheet.cpp
//
//	Abstract:
//		Implementation of the CBaseSheetWindow class.
//
//	Author:
//		David Potter (davidp)	December 4, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlBaseSheet.h"
#include "AtlExtDll.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static LPCTSTR g_pszDefaultFontFaceName = _T("MS Shell Dlg");

/////////////////////////////////////////////////////////////////////////////
// class CBaseSheetWindow
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheetWindow::~CBaseSheetWindow
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheetWindow::~CBaseSheetWindow( void )
{
	//
	// Delete the extension information.
	//
	delete m_pext;

} //*** CBaseSheetWindow::~CBaseSheetWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	static
//	CBaseSheetWindow::BCreateFont
//
//	Routine Description:
//		Create a font with only point size and type face name.
//
//	Arguments:
//		rfont		[OUT] Font to create.
//		nPoints		[IN] Point size.
//		pszFaceName	[IN] Font face name.  Defaults to "MS Shell Dlg".
//		bBold		[IN] Font should be bold.
//		bItalic		[IN] Font should be italic.
//		bUnderline	[IN] Font should be underline.
//
//	Return Value:
//		TRUE		Font created successfully.
//		FALSE		Error creating font.  Call GetLastError() for more details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheetWindow::BCreateFont(
	OUT CFont &	rfont,
	IN LONG		nPoints,
	IN LPCTSTR	pszFaceName,	// = _T("MS Shell Dlg")
	IN BOOL		bBold,			// = FALSE
	IN BOOL		bItalic,		// = FALSE
	IN BOOL		bUnderline		// = FALSE
	)
{
	//
	// Get non-client metrics for basing the new font off of.
	//
	NONCLIENTMETRICS ncm = { 0 };
	ncm.cbSize = sizeof( ncm );
	SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );

	//
	// Copy the message font and set the face name and point size to what
	// was passed in.  The point size needs to be multiplied by 10 due to how
	// the CFont::CreatePointFontIndirect calculates the actual font height.
	//
	LOGFONT lfNewFont = ncm.lfMessageFont;
	if ( pszFaceName == NULL )
	{
		pszFaceName = g_pszDefaultFontFaceName;
	} // if:  no type face name specified
	ATLASSERT( lstrlen( pszFaceName ) + 1 < sizeof( lfNewFont.lfFaceName ) );
	lstrcpy( lfNewFont.lfFaceName, pszFaceName );
	lfNewFont.lfHeight = nPoints * 10;

	//
	// Set bold, italic, and underline values.
	//
	if ( bBold )
	{
		lfNewFont.lfWeight = FW_BOLD;
	} // if:  bold font requested
	if ( bItalic )
	{
		lfNewFont.lfItalic = TRUE;
	} // if:  italic font requested
	if ( bUnderline )
	{
		lfNewFont.lfUnderline = TRUE;
	} // if:  underlined font requested

	//
	// Create the font.
	//
	HFONT hfont = rfont.CreatePointFontIndirect( &lfNewFont );

	return ( hfont != NULL );

}  //*** BCreateFont()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	static
//	CBaseSheetWindow::BCreateFont
//
//	Routine Description:
//		Create a font with only point size and type face name.
//
//	Arguments:
//		rfont		[OUT] Font to create.
//		idsPoints	[IN] Resource ID for the font point size.
//		idsFaceName	[IN] Resource ID for the font face name.  Defaults to "MS Shell Dlg".
//		bBold		[IN] Font should be bold.
//		bItalic		[IN] Font should be italic.
//		bUnderline	[IN] Font should be underline.
//
//	Return Value:
//		TRUE		Font created successfully.
//		FALSE		Error creating font.  Call GetLastError() for more details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheetWindow::BCreateFont(
	OUT CFont &	rfont,
	IN UINT		idsPoints,
	IN UINT		idsFaceName,
	IN BOOL		bBold,			// = FALSE
	IN BOOL		bItalic,		// = FALSE
	IN BOOL		bUnderline		// = FALSE
	)
{
	BOOL	bSuccess;
	CString	strFaceName;
	CString	strPoints;
	LONG	nPoints;

	//
	// Load the face name.
	//
	bSuccess = strFaceName.LoadString( idsFaceName );
	ATLASSERT( bSuccess );
	if ( ! bSuccess )
	{
		strFaceName = g_pszDefaultFontFaceName;
	} // if:  no errors loading the string

	//
	// Load the point size.
	//
	bSuccess = strPoints.LoadString( idsPoints );
	ATLASSERT( bSuccess );
	if ( ! bSuccess)
	{
		nPoints = 12;
	} // if:  no errors loading the string
	else
	{
        nPoints = _tcstoul( strPoints, NULL, 10 );
	} // else:  error loading the string

	//
	// Create the font.
	//
	return BCreateFont( rfont, nPoints, strFaceName, bBold, bItalic, bUnderline );

}  //*** CBaseSheetWindow::BCreateFont()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasesheet.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBaseSheet.h
//
//	Implementation File:
//		AtlBaseSheet.cpp
//
//	Description:
//		Definition of the CBaseSheetWindow and CBaseSheetImpl classes.
//
//	Author:
//		David Potter (davidp)	December 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASESHEET_H_
#define __ATLBASESHEET_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseSheetWindow;
template < class T, class TBase > class CBaseSheetImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExtensions;
class CBasePageWindow;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for DBG_xxx routines
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseSheetWindow
//
//	Description:
//		Base property sheet window for all kinds of property sheets.
//
//	Inheritance:
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBaseSheetWindow : public CPropertySheetWindow
{
	typedef CPropertySheetWindow baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CBaseSheetWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_bReadOnly( FALSE )
		, m_bNeedToLoadExtensions( TRUE )
		, m_ppsh( NULL )
		, m_pext( NULL )
	{
	} //*** CBaseSheetWindow()

	// Destructor
	virtual ~CBaseSheetWindow( void );
		//
		// This must be virtual so that a pointer to an object
		// of type CBaseSheetWindow can be held and then later
		// deleted.  That way the derived class's destructor will
		// be called.
		//

	// Initialize the sheet
	BOOL BInit( void )
	{
		return TRUE;
	}

public:
	//
	// CPropertySheetWindow methods.
	//

	// Add a page (allows other AddPage method to be virtual)
	void AddPage( HPROPSHEETPAGE hPage )
	{
		baseClass::AddPage( hPage );

	} //*** AddPage( hPage )

	// Add a page (virtual so this class can call derived class method)
	virtual BOOL AddPage( LPCPROPSHEETPAGE pPage )
	{
		return baseClass::AddPage( pPage );

	} //*** AddPage( pPage )

	// Add a page to the propsheetheader page list
	virtual BAddPageToSheetHeader( IN HPROPSHEETPAGE hPage ) = 0;

public:
	//
	// CBaseSheetWindow public methods.
	//

	// Create a font for use on the sheet
	static BOOL BCreateFont(
					OUT CFont &	rfont,
					IN LONG		nPoints,
					IN LPCTSTR	pszFaceName	= _T("MS Shell Dlg"),
					IN BOOL		bBold		= FALSE,
					IN BOOL		bItalic		= FALSE,
					IN BOOL		bUnderline	= FALSE
					);

	// Create a font for use on the sheet
	static BOOL BCreateFont(
					OUT CFont &	rfont,
					IN UINT		idsPoints,
					IN UINT		idsFaceName,
					IN BOOL		bBold		= FALSE,
					IN BOOL		bItalic		= FALSE,
					IN BOOL		bUnderline	= FALSE
					);

public:
	//
	// Abstract override methods.
	//

	// Add extension pages to the sheet
	virtual void AddExtensionPages( IN HFONT hfont, IN HICON hicon ) = 0;

	// Add a page (called by extension)
	virtual HRESULT HrAddExtensionPage( IN CBasePageWindow * ppage ) = 0;

public:
	//
	// Message handler functions.
	//

	// Handler for PSCB_INITIALIZED
	void OnSheetInitialized( void )
	{
	} //*** OnSheetInitialized()

// Implementation
protected:
	PROPSHEETHEADER *	m_ppsh;
	BOOL				m_bReadOnly;	// Set if the sheet cannot be changed.
	BOOL				m_bNeedToLoadExtensions;
	CCluAdmExtensions *	m_pext;

public:
	BOOL				BNeedToLoadExtensions( void ) const		{ return m_bNeedToLoadExtensions; }
	BOOL				BReadOnly( void ) const					{ return m_bReadOnly; }
	void				SetReadOnly( IN BOOL bReadOnly = TRUE )	{ m_bReadOnly = bReadOnly; }

	// Return a pointer to the property sheet header
	PROPSHEETHEADER * Ppsh( void ) const
	{
		ATLASSERT( m_ppsh != NULL );
		return m_ppsh;

	} //*** Ppsh()

	CCluAdmExtensions *	Pext( void ) const { return m_pext; }

}; //*** class CBaseSheetWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseSheetImpl
//
//	Description:
//		Base property sheet implementation for all kinds of property sheets.
//
//	Inheritance
//		CBaseSheetImpl< T, TBase >
//		CPropertySheetImpl< T, TBase >
//		<TBase>
//		...
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CBaseSheetWindow >
class CBaseSheetImpl : public CPropertySheetImpl< T, TBase >
{
	typedef CBaseSheetImpl< T, TBase > thisClass;
	typedef CPropertySheetImpl< T, TBase > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CBaseSheetImpl(
		IN LPCTSTR	lpszTitle = NULL,
		IN UINT		uStartPage = 0,
		IN HWND		hWndParent = NULL
		)
		: baseClass( lpszTitle, uStartPage, hWndParent )
	{
	} //*** CBaseSheetImpl()

	static int CALLBACK PropSheetCallback( HWND hWnd, UINT uMsg, LPARAM lParam )
	{
		//
		// If we are initialized, let the sheet do further initialization.
		// We have to subclass here because otherwize we won't have a
		// pointer to the class instance.
		//
		if ( uMsg == PSCB_INITIALIZED )
		{
			ATLASSERT( hWnd != NULL );
			T * pT = static_cast< T * >( _Module.ExtractCreateWndData() );
			ATLASSERT( pT != NULL );
			pT->SubclassWindow(hWnd);
			pT->OnSheetInitialized();
		} // if:  sheet has been initialized

		return 0;

	} //*** PropSheetCallback()

public:
	//
	// CPropertySheetImpl methods.
	//

	// Add a page to the propsheetheader page list
	virtual BAddPageToSheetHeader( IN HPROPSHEETPAGE hPage )
	{
		return AddPage( hPage );

	} //*** BAddPageToHeader()

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
#if DBG
#ifdef _DBG_MSG
		MESSAGE_RANGE_HANDLER( 0, 0xffffffff, OnMsg )
#endif // _DBG_MSG
#ifdef _DBG_MSG_NOTIFY
		MESSAGE_HANDLER( WM_NOTIFY, OnNotify )
#endif // _DBG_MSG_NOTIFY
#ifdef _DBG_MSG_COMMAND
		MESSAGE_HANDLER( WM_COMMAND, OnCommand )
#endif // _DBG_MSG_COMMAND
#endif // DBG
//		CHAIN_MSG_MAP( baseClass ) // doesn't work because base class doesn't have a message map
	END_MSG_MAP()

public:
	//
	// Message handler functions.
	//

#if DBG && defined( _DBG_MSG )
	// Handler for any message
	LRESULT OnMsg( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnMsg( uMsg, wParam, lParam, bHandled, T::s_pszClassName );

	} //*** OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
	// Handler for the WM_NOTIFY message
	LRESULT OnNotify( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnNotify( uMsg, wParam, lParam, bHandled, T::s_pszClassName, NULL );

	} //*** OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
	// Handler for the WM_COMMAND message
	LRESULT OnCommand( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnCommand( uMsg, wParam, lParam, bHandled, T::s_pszClassName, NULL );

	} //*** OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )

// Implementation
protected:

public:

}; //*** class CBaseSheetImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASESHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasewiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AtlBaseWiz.cpp
//
//  Abstract:
//      Implementation of the CWizardWindow class.
//
//  Author:
//      David Potter (davidp)   December 2, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlBaseWiz.h"
#include "AtlBaseWizPage.h"
#include "AtlExtDll.h"
#include "StlUtils.h"
#include "ExcOper.h"
#include "AdmCommonRes.h"

/////////////////////////////////////////////////////////////////////////////
// Local Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardGuardPage
//
//  Purpose:
//      Guard page transferring control between the main wizard and the
//      alternate extension wizard.
//
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CAltExtWizardGuardPage
    : public CExtensionWizardPageImpl< T >
{
    typedef CAltExtWizardGuardPage< T > thisClass;
    typedef CExtensionWizardPageImpl< T > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardGuardPage(
        DLGTEMPLATE * pdt
        )
        : m_pdt( pdt )
    {
        ATLASSERT( pdt != NULL );

    } //*** CAltExtWizardGuardPage()

    // Destructor
    ~CAltExtWizardGuardPage( void )
    {
        delete m_pdt;

    } //*** ~CAltExtWizardGuardPage()

    WIZARDPAGE_HEADERTITLEID( 0 )
    WIZARDPAGE_HEADERSUBTITLEID( 0 )

    enum { IDD = 0 };
    DECLARE_CLASS_NAME()

    // Return the help ID map
    static const DWORD * PidHelpMap( void )
    {
        static const DWORD s_aHelpIDs[] = { 0, 0 };
        return s_aHelpIDs;

    } //*** PidHelpMap()

    // Create the page
    DWORD ScCreatePage( void )
    {
        ATLASSERT( m_hpage == NULL );

        m_psp.dwFlags |= PSP_DLGINDIRECT;
        m_psp.pResource = m_pdt;

        m_hpage = CreatePropertySheetPage( &m_psp );
        if ( m_hpage == NULL )
        {
            return GetLastError();
        } // if:  error creating the page

        return ERROR_SUCCESS;

    } //*** ScCreatePage()

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        MESSAGE_HANDLER( WM_ACTIVATE, OnActivate )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for the WM_ACTIVATE message
    LRESULT OnActivate(
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL & bHandled
        )
    {
        //
        // Don't allow us to be activated.
        //
        WORD fActive = LOWORD( wParam );
        HWND hwndPrevious = (HWND) lParam;
        if ( wParam != WA_INACTIVE )
        {
            ::SetActiveWindow( hwndPrevious );
        }
        return 0;

    } //*** OnActivate()

    //
    // Message handler override functions.
    //

protected:
    DLGTEMPLATE *   m_pdt;

}; //*** class CAltExtWizardGuardPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPreLauncherPage
//
//  Purpose:
//      Extension launcher wizard page used to display Wizard97 pages in
//      a non-Wizard97 sheet or vice-versa.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPreLauncherPage
    : public CAltExtWizardGuardPage< CAltExtWizardPreLauncherPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPreLauncherPage > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardPreLauncherPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPreLauncherPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPreLauncherPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler overrides functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

}; //*** class CAltExtWizardPreLauncherPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPostLauncherPage
//
//  Purpose:
//      Page use to switch between the main wizard and the alternate
//      extension wizard when moving backwards.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPostLauncherPage
    : public CAltExtWizardGuardPage< CAltExtWizardPostLauncherPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPostLauncherPage > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardPostLauncherPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPostLauncherPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPostLauncherPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler override functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

}; //*** class CAltExtWizardPostLauncherPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizard
//
//  Purpose:
//      Dummy wizard to host pages that are not of the same type as the main
//      wizard, e.g. non-Wizard97 pages in a Wizard97 wizard.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizard : public CWizardImpl< CAltExtWizard >
{
    typedef CWizardImpl< CAltExtWizard > baseClass;

    friend class CWizardWindow;
    friend class CAltExtWizardPreLauncherPage;
    friend class CAltExtWizardPostLauncherPage;
    friend class CAltExtWizardPrefixPage;
    friend class CAltExtWizardPostfixPage;

public:
    //
    // Construction
    //

    // Standard constructor
    CAltExtWizard( void )
        : CWizardImpl< CAltExtWizard >( _T("") )
        , m_pwizMain( NULL )
        , m_bWindowMoved( FALSE )
        , m_bExitMsgLoop( FALSE )
        , m_nExitButton( 0 )
    {
    } //*** CExtensionAltWizard()

    // Initialize the sheet
    BOOL BInit( IN CWizardWindow * pwiz );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CAltExtWizard )
        COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnCancel )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for BN_CLICKED on the Cancel button
    LRESULT OnCancel(
        WORD wNotifyCode,
        WORD idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        //
        // Notify the main wizard that the user pressed the cancel button.
        //
        ExitMessageLoop( PSBTN_CANCEL );
        bHandled = FALSE;
        return 0;

    } //*** OnCancel()

    //
    // Message handler override functions.
    //

    // Handler for the final message after WM_DESTROY
    void OnFinalMessage( HWND hWnd )
    {
        PwizMain()->DeleteAlternateWizard();

    } //*** OnFinalMessage()

protected:
    CWizardWindow * m_pwizMain;     // Pointer to the main wizard.
    BOOL            m_bWindowMoved; // Indicates whether this window has been
                                    //   repositioned over main wizard or not.
    BOOL            m_bExitMsgLoop; // Indicates whether the message loop
                                    //   should be exited or not.
    DWORD           m_nExitButton;  // Button to press after exiting.

protected:
    // Return a pointer to the main wizard
    CWizardWindow * PwizMain( void ) { return m_pwizMain; }

    // Return whether the wizard has been moved yet
    BOOL BWindowMoved( void ) const { return m_bWindowMoved; }

    // Return whether the message loop should be exited or not
    BOOL BExitMessageLoop( void ) const { return m_bExitMsgLoop; }

    // Change whether the message loop should be exited or not
    void ExitMessageLoop( IN DWORD nButton )
    {
        ATLASSERT( (nButton == PSBTN_BACK) || (nButton == PSBTN_NEXT) || (nButton == PSBTN_CANCEL) );
        m_bExitMsgLoop = TRUE;
        m_nExitButton = nButton;

    } //*** ExitMessageLoop()

    // Return the button to press in the main wizard after exiting
    DWORD NExitButton( void ) const { return m_nExitButton; }

protected:
    // Add the prefix page
    BOOL BAddPrefixPage( IN WORD cx, IN WORD cy );

    // Add the postfix page
    BOOL BAddPostfixPage( IN WORD cx, IN WORD cy );

    // Display the alternate wizard
    void DisplayAlternateWizard( void );

    // Display the main wizard
    void DisplayMainWizard( void );

    // Destroy the alternate extension wizard
    void DestroyAlternateWizard( void );

    // Message loop for the modeless wizard
    void MessageLoop( void );

}; //*** class CAltExtWizard

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPrefixPage
//
//  Purpose:
//      Wizard page which precedes the first alternate page.  This page
//      handles transferring control between the main wizard and the
//      alternate wizard.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPrefixPage
    : public CAltExtWizardGuardPage< CAltExtWizardPrefixPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPrefixPage > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardPrefixPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPrefixPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPrefixPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler override functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

protected:
    // Return the alternate wizard object
    CAltExtWizard * PwizThis( void ) { return (CAltExtWizard *) Pwiz(); }

}; //*** class CAltExtWizardPrefixPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPostfixPage
//
//  Purpose:
//      Wizard page which follows the last alternate page.  This page
//      handles transferring control between the main wizard and the
//      alternate wizard.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPostfixPage
    : public CAltExtWizardGuardPage< CAltExtWizardPostfixPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPostfixPage > baseClass;

public:
    //
    // Construction.
    //
    // Standard constructor
    CAltExtWizardPostfixPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPostfixPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPostfixPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler override functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

protected:
    // Return the alternate wizard object
    CAltExtWizard * PwizThis( void ) { return (CAltExtWizard *) Pwiz(); }

}; //*** class CAltExtWizardPostfixPage


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CWizardWindow
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::~CWizardWindow
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardWindow::~CWizardWindow( void )
{
    //
    // Delete the alternate wizard, if it exists.
    //
    if ( (PwizAlternate() != NULL) && (PwizAlternate()->m_hWnd != NULL) )
    {
        reinterpret_cast< CAltExtWizard * >( PwizAlternate() )->DestroyAlternateWizard();
    } // if:  alternate wizard exists

    //
    // Delete pages from the page list.
    //
    if ( m_plwpPages != NULL )
    {
        DeleteAllPtrListItems( m_plwpPages );
        delete m_plwpPages;
    } // if:  page array has been allocated

    if ( m_plewpNormal != NULL )
    {
        DeleteAllPtrListItems( m_plewpNormal );
        delete m_plewpNormal;
    } // if:  list already exists

    if ( m_plewpAlternate != NULL )
    {
        DeleteAllPtrListItems( m_plewpAlternate );
        delete m_plewpAlternate;
    } // if:  list already exists

} //*** CWizardWindow::~CWizardWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::BAddPage
//
//  Routine Description:
//      Add a page to the page list.  If it is the first page, it won't have
//      a BACK button.  If it isn't the first page, the last page will have
//      its FINISH button changed to a NEXT button and this page will have
//      both a FINISH button and a BACK button.
//
//  Arguments:
//      pwp     [IN] Wizard page to add.
//
//  Return Value:
//      TRUE    Page added successfully.
//      FALSE   Error adding page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardWindow::BAddPage( IN CWizardPageWindow * pwp )
{
    ATLASSERT( pwp != NULL );

    // Make sure specified page hasn't already been added.
    ATLASSERT( (m_plwpPages == NULL)
            || (std::find( PlwpPages()->begin(), PlwpPages()->end(), pwp ) == PlwpPages()->end()) );

    BOOL bSuccess = FALSE;
    ULONG fWizardButtons = PSWIZB_FINISH;
    ULONG fPrevWizardButtons;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate the page list if it doesn't exist yet.
        //
        if ( m_plwpPages == NULL )
        {
            m_plwpPages = new CWizardPageList;
            if ( m_plwpPages == NULL )
            {
                CNTException nte(
                                E_OUTOFMEMORY,
                                ADMC_IDS_ADD_FIRST_PAGE_TO_PROP_SHEET_ERROR,
                                NULL,   // pszOperArg1
                                NULL,   // pszOperArg2
                                FALSE   // bAutoDelete
                                );
                nte.ReportError();
                break;
            } // if:  error allocating page list
        } // if:  no page array yet

        //
        // If this is not the first page in the list, set the previous
        // page's wizard buttons to have a NEXT button instead of a
        // FINISH button and set this page to have a BACK button.
        //
        if ( PlwpPages()->size() > 0 )
        {
            //
            // Get the current last page.
            //
            CWizardPageList::iterator itFirst = PlwpPages()->begin();
            CWizardPageList::iterator itLast  = PlwpPages()->end();
            ATLASSERT( itFirst != itLast );
            CWizardPageWindow * pwpPrev = *(--PlwpPages()->end());
            ATLASSERT( pwpPrev != NULL );

            //
            // Set the wizard buttons on that page.
            //
            fPrevWizardButtons = pwpPrev->FWizardButtons();
            fPrevWizardButtons &= ~PSWIZB_FINISH;
            fPrevWizardButtons |= PSWIZB_NEXT;
            pwpPrev->SetDefaultWizardButtons( fPrevWizardButtons );

            fWizardButtons |= PSWIZB_BACK;
        } // if:  not the first page added

        pwp->SetDefaultWizardButtons( fWizardButtons );

        //
        // Insert the page at the end of the list.
        //
        PlwpPages()->insert( PlwpPages()->end(), pwp );

        //
        // Add the page to the sheet.  If the sheet hasn't been created yet,
        // add it to the sheet header list.  If the sheet has been created,
        // add it to the sheet dynamically.  Note that the page must not be a
        // static page.
        //
        if ( m_hWnd == NULL )
        {
            //
            // If this is a dynamic page, add it using its hpage.  Otherwise
            // it must be a static page.  Add it by its property sheet page header.
            //
            CDynamicWizardPageWindow * pdwp = dynamic_cast< CDynamicWizardPageWindow * >( pwp );
            if ( pdwp != NULL )
            {
                if ( pdwp->Hpage() != NULL )
                {
                    ATLASSERT( ! pdwp->BPageAddedToSheet() );
                    bSuccess = BAddPageToSheetHeader( pdwp->Hpage() );
                    if ( ! bSuccess )
                    {
                        CNTException nte(
                            GetLastError(),
                            ADMC_IDS_ADD_PAGE_TO_WIZARD_ERROR,
                            NULL,
                            NULL,
                            FALSE
                            );
                        nte.ReportError();
                        break;
                    } // if:  error adding the page to the sheet header
                    pdwp->SetPageAdded( TRUE );
                } // if:  page already created
            } // if:  dynamic page
            else
            {
                // Must be static page
                ATLASSERT( dynamic_cast< CStaticWizardPageWindow * >( pwp ) != NULL );

                //
                // Initialize the page.
                //
                bSuccess = pwp->BInit( this );
                if ( ! bSuccess )
                {
                    break;
                } // if:  error initializing the page

                //
                // Add the page.
                //
                bSuccess = AddPage( pwp->Ppsp() );
                if ( ! bSuccess )
                {
                    CNTException nte(
                        GetLastError(),
                        ADMC_IDS_ADD_PAGE_TO_WIZARD_ERROR,
                        NULL,
                        NULL,
                        FALSE
                        );
                    nte.ReportError();
                    break;
                } // if:  error adding the page
            } // else:  not dynamic page
        } // if:  sheet has been created
        else
        {
            // Can't be static page.  Must be dynamic page.
            ATLASSERT( dynamic_cast< CStaticWizardPageWindow * >( pwp ) == NULL );
            CDynamicWizardPageWindow * pdwp = dynamic_cast< CDynamicWizardPageWindow * >( pwp );
            ATLASSERT( pdwp != NULL );
            AddPage( pdwp->Hpage() );
            pdwp->SetPageAdded( TRUE );
        } // else:  sheet already created

        //
        // If we get to here we are successfully.
        //
        bSuccess = TRUE;
    } while ( 0 );
        
    return bSuccess;

} //*** CWizardWindow::BAddPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::OnSheetInitialized
//
//  Routine Description:
//      Handler for PSCB_INITIALIZED.
//      Add pages that haven't been added yet, which will only be dynamic
//      pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::OnSheetInitialized( void )
{
    //
    // Remove the system menu.
    //
    ModifyStyle( WS_SYSMENU, 0 );

    //
    // Add dynamic pages, including extension pages, if not added yet.
    //
    {
        //
        // Get pointers to beginning and end of list.
        //
        CWizardPageList::iterator itCurrent = PlwpPages()->begin();
        CWizardPageList::iterator itLast = PlwpPages()->end();

        //
        // Loop through the list and add each dynamic page.
        //
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicWizardPageWindow * pdwp = dynamic_cast< CDynamicWizardPageWindow * >( *itCurrent );
            if ( pdwp != NULL )
            {
                if ( ! pdwp->BPageAddedToSheet() && (pdwp->Hpage() != NULL) )
                {
                    AddPage( pdwp->Hpage() );
                    pdwp->SetPageAdded( TRUE );
                } // if:  page not added yet and page has already been created
            } // if:  dynamic page found
        } // for:  each item in the list

    } // Add dynamic pages, including extension pages

    //
    // Call the base class method.
    //
    CBaseSheetWindow::OnSheetInitialized();

} //*** CWizardWindow::OnSheetInitialized()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::SetNextPage
//
//  Routine Description:
//      Set the next page to be displayed.
//
//  Arguments:
//      pwCurrentPage   [IN] Current page whose next page is to be enabled.
//      pszNextPage     [IN] Page ID.
//
//  Return Value:
//      pwizpg
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::SetNextPage(
    IN CWizardPageWindow *  pwCurrentPage,
    IN LPCTSTR              pszNextPage
    )
{
    ATLASSERT( pwCurrentPage != NULL );
    ATLASSERT( pszNextPage != NULL );

    BOOL                        bFoundCurrent = FALSE;
    CWizardPageWindow *         pwPage;
    CWizardPageList::iterator   itCurrent = PlwpPages()->begin();
    CWizardPageList::iterator   itLast = PlwpPages()->end();

    //
    // Skip pages until the current page is found.
    //
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pwPage = *itCurrent;
        if ( pwPage == pwCurrentPage )
        {
            bFoundCurrent = TRUE;
            break;
        } // if:  found the current page
    } // for:  each page in the list

    ATLASSERT( bFoundCurrent );

    //
    // Disable all succeeding pages until the desired next page
    // is found.  Enable that page and then exit.
    //
    for ( itCurrent++ ; itCurrent != itLast ; itCurrent++ )
    {
        if ( (*itCurrent)->Ppsp()->pszTemplate == pszNextPage )
        {
            (*itCurrent)->EnablePage( TRUE );
            break;
        } // if:  found the page
        (*itCurrent)->EnablePage( FALSE );
    } // for:  each page in the list

    ATLASSERT( itCurrent != itLast );

} //*** CWizardWindow::SetNextPage( pszNextPage )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      hfont       [IN] Font to use for the extension pages.
//      hicon       [IN] Icon to use for the extension pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::AddExtensionPages( IN HFONT hfont, IN HICON hicon )
{
    ATLASSERT( PcoObjectToExtend() != NULL );

    //
    // Add extension pages if there any extensions.
    //
    if (   (PcoObjectToExtend()->PlstrAdminExtensions() != NULL)
        && (PcoObjectToExtend()->PlstrAdminExtensions()->size() > 0) )
    {
        //
        // Get the currently selected page so we can reset it when we're done.
        //
        CTabCtrl tabc( GetTabControl() );
        int nCurPage = tabc.GetCurSel();

        //
        // Prepare to add extension pages.
        //
        CDynamicWizardPageList ldwp;
        PrepareToAddExtensionPages( ldwp );

        //
        // If no extensions object has been created yet, create it now.
        //
        if ( Pext() == NULL )
        {
            m_pext = new CCluAdmExtensions;
            ATLASSERT( m_pext != NULL );
            if ( m_pext == NULL )
            {
                return;
            } // if: error allocating the extension object
        } // if:  no extensions list yet

        //
        // Enclose the loading of the extension in a try/catch block so
        // that a failure to load the extension won't prevent all pages
        // from being displayed.
        //
        try
        {
            if ( BWizard97() )
            {
                Pext()->CreateWizard97Pages(
                        this,
                        *PcoObjectToExtend()->PlstrAdminExtensions(),
                        PcoObjectToExtend(),
                        hfont,
                        hicon
                        );
            } // if:  Wizard97 wizard
            else
            {
                Pext()->CreateWizardPages(
                        this,
                        *PcoObjectToExtend()->PlstrAdminExtensions(),
                        PcoObjectToExtend(),
                        hfont,
                        hicon
                        );
            } // else:  non-Wizard97 wizard
        } // try
        catch (...)
        {
        } // catch:  anything

        //
        // Complete the process of adding extension pages.
        //
        CompleteAddingExtensionPages( ldwp );

        //
        // Restore the current selection.
        // This has to be done because sometimes the above process causes
        // the current page to be set to the last page added, which prevents
        // the next page from being displayed.
        //
        SetActivePage( nCurPage );
    } // if:  object has extensions
    else
    {
        //
        // Remove extension pages.
        //
        RemoveAllExtensionPages();
    } // else:  object doesn't have extensions

}  //*** CWizardWindow::AddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::PrepareToAddExtensionPages
//
//  Routine Description:
//      Prepare to add extension pages by deleting existing extension
//      pages and removing dynamic pages.
//
//  Arguments:
//      rldwp       [IN OUT] List of dynamic wizard pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::PrepareToAddExtensionPages(
    IN OUT CDynamicWizardPageList & rldwp
    )
{
    //
    // Delete all extension pages from this wizard.  This also
    // includes destroy the alternate wizard if it exists.
    //
    RemoveAllExtensionPages();

    //
    // Delete the lists of extension pages and make sure the lists exist.
    //
    if ( PlewpNormal() != NULL )
    {
        DeleteAllPtrListItems( PlewpNormal() );
    } // if:  list already exists
    else
    {
        m_plewpNormal = new CExtensionWizardPageList;
        if ( m_plewpNormal == NULL )
        {
            return;
        } // if: error allocating the page list
    } // else:  list doesn't exist yet
    if ( PlewpAlternate() != NULL )
    {
        DeleteAllPtrListItems( PlewpAlternate() );
    } // if:  list already exists
    else
    {
        m_plewpAlternate = new CExtensionWizardPageList;
        if ( m_plewpAlternate == NULL )
        {
            return;
        } // if: error allocating the page list
    } // else:  list doesn't exist yet

    //
    // Move all dynamic pages to the temporary list.
    //
    ATLASSERT( rldwp.size() == 0 );
    MovePtrListItems< CWizardPageWindow *, CDynamicWizardPageWindow * >( PlwpPages(), &rldwp );

    //
    // Remove all pages in the temporary list from the wizard.
    //
    {
        CDynamicWizardPageList::iterator itCurrent;
        CDynamicWizardPageList::iterator itLast;

        itCurrent = rldwp.begin();
        itLast = rldwp.end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicWizardPageWindow * pdwp = *itCurrent;
            ATLASSERT( pdwp != NULL );
            if ( pdwp->Hpage() != NULL )
            {
                RemovePage( pdwp->Hpage() );
                pdwp->SetPageAdded( FALSE );
            } // if:  page already created
        } // for:  each page in the list
    } // Remove dynamic pages

} //*** CWizardWindow::PrepareToAddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::HrAddExtensionPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      ppage       [IN] Page to be added.
//
//  Return Value:
//      S_OK        Page added successfully.
//      S_FALSE     Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CWizardWindow::HrAddExtensionPage( IN CBasePageWindow * ppage )
{
    ATLASSERT( ppage != NULL );

    HRESULT hr = S_OK;

    //
    // Make sure this is an extension wizard page object.
    //
    CExtensionWizardPageWindow * pewp = dynamic_cast< CExtensionWizardPageWindow * >( ppage );
    ATLASSERT( pewp != NULL );

    if (   (ppage == NULL)
        || (pewp == NULL ) )
    {
        return S_FALSE;
    } // if:  invalid arguments

    //
    // If the page is not the same as the type of wizard, add it to the
    // alternate list of extension pages and indicate we need a dummy sheet.
    // Otherwise, add it to the standard list of extension pages.
    //
    CExtensionWizard97PageWindow * pew97p = dynamic_cast< CExtensionWizard97PageWindow * >( ppage );
    if (   ((pew97p != NULL) && ! BWizard97())
        || ((pew97p == NULL) && BWizard97()) )
    {
        PlewpAlternate()->insert( PlewpAlternate()->end(), pewp );
    } // if:  trying to add the wrong type of page
    else
    {
        PlewpNormal()->insert( PlewpNormal()->end(), pewp );
    } // else:  adding page of matching type

    return hr;

}  //*** CWizardWindow::HrAddExtensionPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::CompleteAddingExtensionPages
//
//  Routine Description:
//      Complete the process of adding extension pages to the wizard by
//      re-adding dynamic pages.
//
//  Arguments:
//      rldwp       [IN OUT] List of dynamic wizard pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::CompleteAddingExtensionPages(
    IN OUT CDynamicWizardPageList & rldwp
    )
{
    //
    // If there are any normal pages, add them here.
    // There will be normal pages if pages of the same type as the wizard
    // were added.
    //
    if ( PlewpNormal()->size() > 0 )
    {
        //
        // Add pages to the sheet.
        //
        if ( m_hWnd != NULL )
        {
            CExtensionWizardPageList::iterator itCurrent = PlewpNormal()->begin();
            CExtensionWizardPageList::iterator itLast = PlewpNormal()->end();

            for ( ; itCurrent != itLast ; itCurrent++ )
            {
                CExtensionWizardPageWindow * pewp = *itCurrent;
                ATLASSERT( pewp != NULL );
                BAddPage( pewp );
            } // for:  each page in the list
        } // if:  sheet is currently being displayed
    } // if:  there are normal pages

    //
    // If there are any alternate pages, add a pre-extension launcher page
    // and a post-extension launcher page.  The pre-extension launcher page
    // will display an alternate wizard of the appropriate type and hide the
    // main wizard before displaying these pages.  After the final page it
    // will display the original sheet and hide the other sheet.  The
    // post-extension launcher page is used to transition between the main
    // wizard and the alternate wizard when moving backwards into the
    // alternate wizard.
    //
    if ( PlewpAlternate()->size() > 0 )
    {
        DLGTEMPLATE *                   pdt         = NULL;
        CAltExtWizardPreLauncherPage *  pelwpPre    = NULL;
        CAltExtWizardPostLauncherPage * pelwpPost   = NULL;

        // Loop to avoid goto's
        do
        {
            //
            // Add the pre-extension launcher page.
            //
            {
                //
                // Create the dialog template.
                //
                pdt = PdtCreateDummyPageDialogTemplate( 10, 10 );
                ATLASSERT( pdt != NULL );
                if ( pdt == NULL )
                {
                    break;
                } // if: error creating the dialog template

                //
                // Allocate and initialize the launcher page.
                //
                pelwpPre = new CAltExtWizardPreLauncherPage( pdt );
                ATLASSERT( pelwpPre != NULL );
                if ( pelwpPre == NULL )
                {
                    break;
                } // if: error allocating the page
                pdt = NULL;
                if ( ! pelwpPre->BInit( this ) )
                {
                    break;
                } // if:  error initializing the page

                //
                // Create the launcher page.
                //
                DWORD sc = pelwpPre->ScCreatePage();
                if ( sc != ERROR_SUCCESS )
                {
                    CNTException nte(
                        sc,
                        ADMC_IDS_INIT_EXT_PAGES_ERROR,
                        NULL,
                        NULL,
                        FALSE
                        );
                    nte.ReportError();
                    break;
                } // if:  error creating the page

                //
                // Add the launcher page to the wizard.
                //
                BAddPage( pelwpPre );
                pelwpPre = NULL;
            } // Add the pre-extension launcher page

            //
            // Add the post-extension launcher page
            //
            {
                //
                // Create the dialog template.
                //
                pdt = PdtCreateDummyPageDialogTemplate( 10, 10 );
                ATLASSERT( pdt != NULL );
                if ( pdt == NULL )
                {
                    break;
                } // if: error creating the dialog template

                //
                // Allocate and initialize the launcher page.
                //
                pelwpPost = new CAltExtWizardPostLauncherPage( pdt );
                ATLASSERT( pelwpPost != NULL );
                if ( pelwpPost == NULL )
                {
                    break;
                } // if: error allocating page
                pdt = NULL;
                if ( ! pelwpPost->BInit( this ) )
                {
                    break;
                } // if:  error initializing the page

                //
                // Create the launcher page.
                //
                DWORD sc = pelwpPost->ScCreatePage();
                if ( sc != ERROR_SUCCESS )
                {
                    CNTException nte(
                        sc,
                        ADMC_IDS_INIT_EXT_PAGES_ERROR,
                        NULL,
                        NULL,
                        FALSE
                        );
                    nte.ReportError();
                    break;
                } // if:  error creating the page

                //
                // Add the launcher page to the wizard.
                //
                BAddPage( pelwpPost );
                pelwpPost = NULL;
            } // Add the post-extension launcher page
        } while ( 0 );

        //
        // Cleanup;
        //
        delete pelwpPre;
        delete pelwpPost;
        delete pdt;
        
    } // if:  there are alternate pages

    //
    // Move all pages from the temporary list to the real list and
    // add them to the end of the wizard.
    //
    CDynamicWizardPageList::iterator itCurrent = rldwp.begin();
    CDynamicWizardPageList::iterator itLast = rldwp.end();
    while ( itCurrent != itLast )
    {
        CDynamicWizardPageWindow * pdwp = *itCurrent;
        ATLASSERT( pdwp != NULL );

        //
        // Create the page.
        //
        DWORD sc = pdwp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte(
                sc,
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            delete pdwp;
            itCurrent = rldwp.erase( itCurrent );
            continue;
        } // if:  error creating the page

        //
        // Add the page to the wizard.
        // This adds it to the real page list as well.
        //
        BAddPage( pdwp );

        //
        // Remove the page from the temporary list.
        //
        itCurrent = rldwp.erase( itCurrent );
    } // while:  not at last page

} //*** CWizardWindow::CompleteAddingExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::RemoveAllExtensionPages
//
//  Routine Description:
//      Remove all extension pages from the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::RemoveAllExtensionPages( void )
{
    //
    // Delete the alternate extension wizard.
    //
    if ( PwizAlternate() != NULL )
    {
        reinterpret_cast< CAltExtWizard * >( PwizAlternate() )->DestroyAlternateWizard();
    } // if:  alternate wizard being displayed

    //
    // Remove the extension pages.
    //
    CExtensionWizardPageList lewp;
    MovePtrListItems< CWizardPageWindow *, CExtensionWizardPageWindow * >( PlwpPages(), &lewp );
    CExtensionWizardPageList::iterator itCurrent = lewp.begin();
    CExtensionWizardPageList::iterator itLast = lewp.end();
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        CExtensionWizardPageWindow * pewp = *itCurrent;
        ATLASSERT( pewp != NULL );
        if ( pewp->Hpage() != NULL )
        {
            RemovePage( pewp->Hpage() );
            pewp->SetPageAdded( FALSE );
        } // if:  page already created
    } // for:  each page in the list
    DeleteAllPtrListItems( &lewp );

} //*** CWizardWindow::RemoveAllExtensionPages()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPreLauncherPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPreLauncherPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page will be displayed if there are pages that are not of the
//      same type as the wizard (e.g. non-Wizard97 pages in a Wizard97
//      wizard).
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPreLauncherPage::OnSetActive( void )
{
    UINT            idsReturn = ID_WIZNEXT;
    CAltExtWizard * pwizAlt;

    //
    // When moving forward, create the alternate extension wizard and return
    // TRUE so that the main wizard will wait here.  The alternate wizard
    // will cause the proper button to be pressed so we can do the proper
    // thing when we're done.
    //
    // When moving backward, just return FALSE so we won't be displayed.
    //

    //
    // Create the alternate wizard if moving forward.
    //
    if ( Pwiz()->BNextPressed() )
    {
        // We could have got here by pressing 'Back' on the alternate wizard,
        // and then pressing 'Next' on the normal wizard. So, first check if
        // the alternate wizard has already been created.
        if ( Pwiz()->PwizAlternate() == NULL )
        {
            //
            // Create the alternate extension wizard.
            // It is expected that the wizard doesn't exist yet and that there are
            // alternate extension pages to be displayed.
            //
            ATLASSERT( Pwiz()->PlewpAlternate()->size() > 0 );
            pwizAlt = new CAltExtWizard;
            ATLASSERT( pwizAlt != NULL );
            if ( pwizAlt == NULL )
            {
                return FALSE;
            } // if: error allocating the alternate wizard
            Pwiz()->SetAlternateWizard( pwizAlt );

            //
            // Initialize the alternate extension wizard.
            //
            if ( pwizAlt->BInit( Pwiz() ) )
            {
                //
                // Display the alternate extension wizard.
                // The alternate extension wizard is being displayed as a modeless
                // wizard so that when the user presses the Next button in the
                // wizard and then presses the Back button on the next main wizard
                // page we need the wizard to still exist.
                //
                pwizAlt->Create( GetActiveWindow() );

                //
                // Execute the alternate wizard message loop.
                // This required so that tabs and accelerator keys will work.
                //
                pwizAlt->MessageLoop();
            } // if:  wizard initialized successfully

            return TRUE;
        } // if:    alternate wizard does not exist
        else
        {
            //
            // Display the existing alternate wizard.
            // Press the alternate wizard's Next button because it is waiting at 
            // the prefix page.
            //
            CAltExtWizard * pwizAlt = reinterpret_cast< CAltExtWizard * >( Pwiz()->PwizAlternate() );
            pwizAlt->PressButton( PSBTN_NEXT );
            pwizAlt->DisplayAlternateWizard();

            //
            // Execute the alternate wizard message loop.
            // This required so that tabs and accelerator keys will work.
            //
            pwizAlt->MessageLoop();

            return TRUE;
        } // else: alternate wizard exists already
    } // if:  next button pressed
    else
    {
        ATLASSERT( Pwiz()->BBackPressed() );
        return FALSE;
    } // else:  back button pressed

} //*** CAltExtWizardPreLauncherPage::OnSetActive()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPostLauncherPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPostLauncherPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page will be displayed if there are pages that are not of the
//      same type as the wizard (e.g. non-Wizard97 pages in a Wizard97
//      wizard).
//             
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPostLauncherPage::OnSetActive( void )
{
    //
    // When moving forward just return FALSE so that we won't be displayed.
    //
    // When moving backward, display the alternate extension wizard and
    // return TRUE so that we will be waiting for the alternate wizard to
    // move us to the right place.  Press the alternate wizard's Back button
    // because it is waiting at the postfix page.
    //

    if ( Pwiz()->BNextPressed() )
    {
        return FALSE;
    } // if:  moving forward
    else
    {
        ATLASSERT( Pwiz()->BBackPressed() );

        //
        // Display the alternate wizard.
        //
        CAltExtWizard * pwizAlt = reinterpret_cast< CAltExtWizard * >( Pwiz()->PwizAlternate() );
        pwizAlt->PressButton( PSBTN_BACK );
        pwizAlt->DisplayAlternateWizard();

        //
        // Execute the alternate wizard message loop.
        // This required so that tabs and accelerator keys will work.
        //
        pwizAlt->MessageLoop();

        return TRUE;
    } // else:  moving backward

} //*** CAltExtWizardPostLauncherPage::OnSetActive()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizard
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//      This wizard is used to display extension pages that are different
//      than the type of the main wizard, e.g. displaying non-Wizard97 pages
//      in a Wizard97 wizard.  This wizard will have a dummy prefix page
//      and a dummy postfix page, which are only here to handle entering and
//      exiting the wizard.  This routine will add the prefix page, add the
//      alternate extension pages from the main wizard, then add the postfix
//      page.
//
//  Arguments:
//      pwizMain    [IN] Main wizard.
//
//  Return Value:
//      TRUE        Wizard initialized successfully.
//      FALSE       Error initializing wizard.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizard::BInit( IN CWizardWindow * pwizMain )
{
    ATLASSERT( pwizMain != NULL );
    ATLASSERT( m_pwizMain == NULL );

    BOOL bSuccess;

    m_pwizMain = pwizMain;

    //
    // Setup the type of wizard to be the opposite of the main wizard.
    //
    m_psh.dwFlags &= ~PSH_PROPSHEETPAGE; // Using HPROPSHEETPAGEs.
    if ( ! PwizMain()->BWizard97() )
    {
        // Don't add a watermark since we don't have a watermark bitmap.
        m_psh.dwFlags &= ~(PSH_WIZARD
                            | PSH_WATERMARK
                            );
        m_psh.dwFlags |= (PSH_WIZARD97
                            | PSH_HEADER
                            );
    } // if:  Wizard97 wizard
    else
    {
        m_psh.dwFlags |= PSH_WIZARD;
        m_psh.dwFlags &= ~(PSH_WIZARD97
                            | PSH_WATERMARK
                            | PSH_HEADER
                            );
    } // else:  non-Wizard97 wizard

    // Loop to avoid goto's
    do
    {
        //
        // Get the first page in the main wizard.
        //
        HWND hwndChild = PwizMain()->GetWindow( GW_CHILD );
        ATLASSERT( hwndChild != NULL );

        //
        // Get the current width and height of the child window.
        //
        CRect rect;
        bSuccess = ::GetClientRect( hwndChild, &rect );

        if ( ! bSuccess )
        {
            CNTException nte(
                GetLastError(),
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            nte.ReportError();
            break;
        } // if:  error getting client rectangle

        //
        // Add a prefix page.
        //
        bSuccess = BAddPrefixPage( (WORD)rect.Width(), (WORD)rect.Height() );

        if ( ! bSuccess )
        {
            break;
        } // if:  error adding the prefix page

        //
        // Add alternate pages from the main wizard to the wizard page list.
        // They will be added to the wizard at sheet initialization time.
        //
        CExtensionWizardPageList::iterator itCurrent = PwizMain()->PlewpAlternate()->begin();
        CExtensionWizardPageList::iterator itLast = PwizMain()->PlewpAlternate()->end();

        while ( itCurrent != itLast )
        {
            CExtensionWizardPageWindow * pewp = *itCurrent;
            ATLASSERT( pewp != NULL );
            PlwpPages()->insert( PlwpPages()->end(), pewp );
            PwizMain()->PlewpAlternate()->erase( itCurrent );
            itCurrent = PwizMain()->PlewpAlternate()->begin();
        } // for:  each page in the list

        //
        // Add a postfix page.
        //
        bSuccess = BAddPostfixPage( (WORD) rect.Width(), (WORD) rect.Height() );
        if ( ! bSuccess )
        {
            break;
        } // if:  error adding the postfix page
    } while ( 0 );

    //
    // Call the base class.
    //
    if ( ! baseClass::BInit() )
    {
        return FALSE;
    } // if:  error initializing the base class

    return bSuccess;

} //*** CAltExtWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::BAddPrefixPage
//
//  Routine Description:
//      Add a prefix page to the wizard.
//
//  Arguments:
//      cx          [IN] Width of the page.
//      cy          [IN] Height of the page.
//
//  Return Value:
//      TRUE        Page added successfully.
//      FALSE       Error adding the page.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizard::BAddPrefixPage( IN WORD cx, IN WORD cy )
{
    ATLASSERT( cx > 0 );
    ATLASSERT( cy > 0 );

    BOOL                        bSuccess;
    DLGTEMPLATE *               pdt = NULL;
    CAltExtWizardPrefixPage *   pwp = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Create the dialog template for the page.
        //
        pdt = PdtCreateDummyPageDialogTemplate( cx, cy );
        ATLASSERT( pdt != NULL );
        if ( pdt == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error creating the dialog template

        //
        // Adjust the page size so that we will be creating the same size
        // wizard as the main wizard.  Non-Wizard97 wizards add padding
        // (7 DLUs on each side) whereas Wizard97 wizards add no padding
        // to the first page, which is where we are expecting these
        // dimensions to come from.
        //
        if ( BWizard97() )
        {
            pdt->cx += 7 * 2;
            pdt->cy += 7 * 2;
        } // if:  Wizard97 wizard
        else
        {
            pdt->cx -= 7 * 2;
            pdt->cy -= 7 * 2;
        } // else:  non-Wizard97 wizard

        //
        // Allocate and initialize the page.
        //
        pwp = new CAltExtWizardPrefixPage( pdt );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error allocating the page
        pdt = NULL;
        bSuccess = pwp->BInit( this );
        if ( ! bSuccess )
        {
            break;
        } // if:  error initializing the page

        //
        // Create the page.
        //
        DWORD sc = pwp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte(
                sc,
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            nte.ReportError();
            bSuccess = FALSE;
            break;
        } // if:  error creating the page

        //
        // Add the page to the wizard.
        //
        bSuccess = BAddPage( pwp );
        pwp = NULL;
    } while ( 0 );

    delete pwp;
    delete pdt;

    return bSuccess;

} //*** CAltExtWizard::BAddPrefixPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::BAddPostfixPage
//
//  Routine Description:
//      Add a postfix page to the wizard.
//
//  Arguments:
//      cx          [IN] Width of the page.
//      cy          [IN] Height of the page.
//
//  Return Value:
//      TRUE        Page added successfully.
//      FALSE       Error adding the page.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizard::BAddPostfixPage( IN WORD cx, IN WORD cy )
{
    ATLASSERT( cx > 0 );
    ATLASSERT( cy > 0 );

    BOOL                        bSuccess;
    DLGTEMPLATE *               pdt = NULL;
    CAltExtWizardPostfixPage *  pwp = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Create the dialog template for the page.
        //
        pdt = PdtCreateDummyPageDialogTemplate( cx, cy );
        ATLASSERT( pdt != NULL );
        if ( pdt == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error creating the dialog template

        //
        // Adjust the page size so that we will be creating the same size
        // wizard as the main wizard.  Non-Wizard97 wizards add padding
        // (7 DLUs on each side) whereas Wizard97 wizards add no padding
        // to the first page, which is where we are expecting these
        // dimensions to come from.
        //
        if ( BWizard97() )
        {
            pdt->cx += 7 * 2;
            pdt->cy += 7 * 2;
        } // if:  Wizard97 wizard
        else
        {
            pdt->cx -= 7 * 2;
            pdt->cy -= 7 * 2;
        } // else:  non-Wizard97 wizard

        //
        // Allocate and initialize the page.
        //
        pwp = new CAltExtWizardPostfixPage( pdt );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error allocating the page
        pdt = NULL;
        bSuccess = pwp->BInit( this );
        if ( ! bSuccess )
        {
            break;
        } // if:  error initializing the page

        //
        // Create the page.
        //
        DWORD sc = pwp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte(
                sc,
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            nte.ReportError();
            bSuccess = FALSE;
            break;
        } // if:  error creating the page

        //
        // Add the page to the page list.  It will be added to the wizard
        // at sheet initialization time.
        //
        PlwpPages()->insert( PlwpPages()->end(), pwp );
        pwp = NULL;

        bSuccess = TRUE;
    } while ( 0 );

    delete pwp;
    delete pdt;

    return bSuccess;

} //*** CAltExtWizard::BAddPostfixPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::DisplayAlternateWizard
//
//  Routine Description:
//      Display the alternate wizard.  This involved the following steps:
//      -- Move the alternate wizard to the position of the main wizard.
//      -- Show the alternate wizard.
//      -- Hide the main wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::DisplayAlternateWizard( void )
{
    //
    // Move the alternate wizard to where the main wizard is positioned.
    //
    CRect rectMain;
    CRect rectAlt;
    CRect rectNew;
    if ( PwizMain()->GetWindowRect( &rectMain ) )
    {
        if ( GetWindowRect( &rectAlt ) )
        {
            //ATLTRACE( _T("CAltExtWizard::DisplayAlternateWizard() - Main = (%d,%d) (%d,%d) Alt = (%d,%d) (%d,%d)\n"),
            //  rectMain.left, rectMain.right, rectMain.top, rectMain.bottom,
            //  rectAlt.left, rectAlt.right, rectAlt.top, rectAlt.bottom );
            rectNew.left = rectMain.left;
            rectNew.top = rectMain.top;
            rectNew.right = rectNew.left + rectAlt.Width();
            rectNew.bottom = rectNew.top + rectAlt.Height();
            MoveWindow( &rectNew );
        } // if:  got the alternate wizard's window rectangle successfully
    } // if:  got the main wizard's window rectangle successfully

    //
    // Show the alternate wizard and hide the main wizard.
    //
    ShowWindow( SW_SHOW );
    PwizMain()->ShowWindow( SW_HIDE );
    SetActiveWindow();
    PwizMain()->SetCurrentWizard( this );

} //*** CAltExtWizard::DisplayAlternateWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::DisplayMainWizard
//
//  Routine Description:
//      Display the main wizard.  This involved the following steps:
//      -- Move the main wizard to the position of the alternate wizard.
//      -- Show the main wizard.
//      -- Hide the alternate wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::DisplayMainWizard( void )
{
    //
    // Move the main wizard to where the alternate wizard is positioned.
    //
    CRect rectMain;
    CRect rectAlt;
    CRect rectNew;
    if ( PwizMain()->GetWindowRect( &rectMain ) )
    {
        if ( GetWindowRect( &rectAlt ) )
        {
            //ATLTRACE( _T("CAltExtWizard::DisplayMainWizard() - Main = (%d,%d) (%d,%d) Alt = (%d,%d) (%d,%d)\n"),
            //  rectMain.left, rectMain.right, rectMain.top, rectMain.bottom,
            //  rectAlt.left, rectAlt.right, rectAlt.top, rectAlt.bottom );
            rectNew.left = rectAlt.left;
            rectNew.top = rectAlt.top;
            rectNew.right = rectNew.left + rectMain.Width();
            rectNew.bottom = rectNew.top + rectMain.Height();
            PwizMain()->MoveWindow( &rectNew );
        } // if:  got the alternate wizard's window rectangle successfully
    } // if:  got the main wizard's window rectangle successfully

    //
    // Show the main wizard and hide the alternate wizard.
    //
    PwizMain()->ShowWindow( SW_SHOW );
    PwizMain()->SetActiveWindow();
    ShowWindow( SW_HIDE );
    PwizMain()->SetCurrentWizard( PwizMain() );

} //*** CAltExtWizard::DisplayMainWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::DestroyAlternateWizard
//
//  Routine Description:
//      Destroy the alternate extension wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::DestroyAlternateWizard( void )
{
    ATLASSERT( m_hWnd != NULL );

    //
    // Press the Cancel button on the alternate wizard.
    //
    PressButton( PSBTN_CANCEL );

    //
    // Destroy the wizard.
    //
    DestroyWindow();

} //*** CAltExtWizard::DestroyAlternateWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::MessageLoop
//
//  Routine Description:
//      Message loop for this wizard as a modeless wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::MessageLoop( void )
{
    MSG     msg;

    m_bExitMsgLoop = FALSE;
    while (    (GetActivePage() != NULL)
            && GetMessage( &msg, NULL, 0, 0 ) )
    {
        //
        // Ask the wizard if it wants to process it.  If not, go ahead
        // and translate it and dispatch it.
        //
        if ( ! IsDialogMessage( &msg ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        } // if:  not a property sheet dialog message

        //
        // If the dialog is done, exit this loop.
        //
        if ( BExitMessageLoop() )
        {
            DisplayMainWizard();
            PwizMain()->PostMessage( PSM_PRESSBUTTON, NExitButton(), 0 );
            break;
        } // if:  exiting the wizard
    } // while:  active page and not quitting

} //*** CAltExtWizard::MessageLoop()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPrefixPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPrefixPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page manages the transfer of control between the main wizard
//      and the first page of the alternate wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPrefixPage::OnSetActive( void )
{
    //
    // When moving forward, display the alternate wizard and return FALSE
    // so that this page won't be displayed.
    //
    // When moving backward, display the main wizard and return TRUE so that
    // we'll be waiting for the main wizard to do something with us.
    //

    if ( Pwiz()->BBackPressed() )
    {
        PwizThis()->ExitMessageLoop( PSBTN_BACK );
        return TRUE;
    } // if:  moving backward
    else
    {
        PwizThis()->DisplayAlternateWizard();
        return FALSE;
    } // if:  moving forward

} //*** CAltExtWizardPrefixPage::OnSetActive()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPostfixPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPostfixPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page manages the transfer of control between the main wizard
//      and the last page of the alternate wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPostfixPage::OnSetActive( void )
{
    //
    // When moving forward display the main wizard and return TRUE so that
    // we'll be waiting for the main wizard to tell us what to do next.
    //
    // This routine should never be called when moving backward.
    //

    ATLASSERT( Pwiz()->BNextPressed() );

    //
    // Display the main wizard.
    //
    PwizThis()->ExitMessageLoop( PSBTN_NEXT );
    return TRUE;

} //*** CAltExtWizardPostfixPage::OnSetActive()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  PdtCreateDummyPageDialogTemplate
//
//  Routine Description:
//      Create a dialog template in memory for use on a dummy page.
//
//  Arguments:
//      cx              [IN] Width of the dialog in pixels.
//      cy              [IN] Height of the dialog in pixels.
//
//  Return Value:
//      ppDlgTemplate   Dialog template.
//
//--
/////////////////////////////////////////////////////////////////////////////
DLGTEMPLATE * PdtCreateDummyPageDialogTemplate( IN WORD cx, IN WORD cy )
{
    static const WCHAR s_szFontName[] = L"MS Shell Dlg";
    struct FULLDLGTEMPLATE : public DLGTEMPLATE
    {
        WORD        nMenuID;
        WORD        nClassID;
        WORD        nTitle;
        WORD        nFontSize;
        WCHAR       szFontName[sizeof(s_szFontName) / sizeof(WCHAR)];
    };

    FULLDLGTEMPLATE * pDlgTemplate = new FULLDLGTEMPLATE;
    ATLASSERT( pDlgTemplate != NULL );
    if ( pDlgTemplate != NULL )
    {
        pDlgTemplate->style = WS_CHILD | WS_DISABLED | WS_SYSMENU | DS_SETFONT;
        pDlgTemplate->dwExtendedStyle = 0;
        pDlgTemplate->cdit = 0;
        pDlgTemplate->x = 0;
        pDlgTemplate->y = 0;
        pDlgTemplate->cx = ((cx * 2) + (3 / 2)) / 3; // round off
        pDlgTemplate->cy = ((cy * 8) + (13 / 2)) / 13; // round off
        pDlgTemplate->nMenuID = 0;
        pDlgTemplate->nClassID = 0;
        pDlgTemplate->nTitle = 0;
        pDlgTemplate->nFontSize = 8;
        lstrcpyW( pDlgTemplate->szFontName, s_szFontName );
    } // if: dialog template allocated successfully

    return pDlgTemplate;

} //*** PdtCreateDummyPageDialogTemplate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasewizpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizPage.cpp
//
//	Abstract:
//		Implementation of wizard page classes
//
//	Author:
//		David Potter (davidp)	May 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlBaseWizPage.h"

/////////////////////////////////////////////////////////////////////////////
// class CWizardPageList
///////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizardPageList::PwpageFromID
//
//	Routine Description:
//		Get a pointer to a page from a dialog ID.
//
//	Arguments:
//		psz		[IN] Dialog ID.
//
//	Return Value:
//		pwpage	Pointer to page corresponding to the dialog ID.
//		NULL	Page wasn't found.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardPageWindow * CWizardPageList::PwpageFromID( IN LPCTSTR psz )
{
	ATLASSERT( psz != NULL );

	CWizardPageWindow * pwpage = NULL;
	iterator itCurrent = begin();
	iterator itLast = end();
	for ( ; itCurrent != itLast ; itCurrent++ )
	{
		ATLASSERT( *itCurrent != NULL );
		if ( (*itCurrent)->Ppsp()->pszTemplate == psz )
		{
			pwpage = *itCurrent;
			break;
		} // if:  found match
	} // for:  each item in the list

	return pwpage;

} //*** CWizardPageList::PwpageFromID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizardPageList::PwpageFromID
//
//	Routine Description:
//		Get a pointer to the next page from a dialog ID.
//
//	Arguments:
//		psz		[IN] Dialog ID.
//
//	Return Value:
//		pwpage	Pointer to page corresponding to the dialog ID.
//		NULL	Page wasn't found.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardPageWindow * CWizardPageList::PwpageNextFromID( IN LPCTSTR psz )
{
	ATLASSERT( psz != NULL );

	CWizardPageWindow * pwpage = NULL;
	iterator itCurrent = begin();
	iterator itLast = end();
	for ( ; itCurrent != itLast ; itCurrent++ )
	{
		ATLASSERT( *itCurrent != NULL );
		if ( (*itCurrent)->Ppsp()->pszTemplate == psz )
		{
			itCurrent++;
			if ( itCurrent != end() )
			{
				pwpage = *itCurrent;
			} // if:  not last page
			break;
		} // if:  found match
	} // for:  each item in the list

	return pwpage;

} //*** CWizardPageList::PwpageNextFromID()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasewizpage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizPage.h
//
//	Implementation File:
//		AtlBaseWizPage.cpp
//
//	Description:
//		Definition of the CWizardPageWindow and CWizardPageImpl classes.
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEWIZPAGE_H_
#define __ATLBASEWIZPAGE_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters in the browser information

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CStaticWizardPageList;
class CDynamicWizardPageList;
class CExtensionWizardPageList;
class CExtensionWizard97PageList;
class CWizardPageList;
class CWizardPageWindow;
class CStaticWizardPageWindow;
class CDynamicWizardPageWindow;
class CExtensionWizardPageWindow;
class CExtensionWizard97PageWindow;
template < class T, class TWin > class CWizardPageImpl;
template < class T > class CStaticWizardPageImpl;
template < class T > class CDynamicWizardPageImpl;
template < class T > class CExtensionWizardPageImpl;
template < class T > class CExtensionWizard97PageImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardWindow;
class CCluAdmExDll;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPAGE_H_
#include "AtlBasePage.h"	// for CBasePageWindow, CBasePageImpl
#endif

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for debugging definitions
#endif

#ifndef __ATLBASEWIZ_H_
#include "AtlBaseWiz.h"		// for CWizardWindow (Pwiz() usage)
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

class CStaticWizardPageList : public std::list< CStaticWizardPageWindow * >
{
}; //*** class CStaticWizardPageList

class CDynamicWizardPageList : public std::list< CDynamicWizardPageWindow * >
{
}; //*** class CDynamicWizardPageList

class CExtensionWizardPageList : public std::list< CExtensionWizardPageWindow * >
{
}; //*** class CExtensionWizardPageList

class CExtensionWizard97PageList : public std::list< CExtensionWizard97PageWindow * >
{
}; //*** class CExtensionWizard97PageList

#define WIZARDPAGE_HEADERTITLEID( ids ) \
static UINT GetWizardPageHeaderTitleId(void) \
{ \
	return ids; \
}

#define WIZARDPAGE_HEADERSUBTITLEID( ids ) \
static UINT GetWizardPageHeaderSubTitleId(void) \
{ \
	return ids; \
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardPageList
//
//	Description:
//		List of wizard pages.
//
//	Inheritance:
//		CWizardPageList
//		std::list< CWizardPageWindow * >
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWizardPageList : public std::list< CWizardPageWindow * >
{
	typedef std::list< CWizardPageWindow * > baseClass;

public:
	// Find page by resource ID
	CWizardPageWindow * PwpageFromID( IN LPCTSTR psz );

	// Find next page by resource ID
	CWizardPageWindow * PwpageNextFromID( IN LPCTSTR psz );

}; //*** class CWizardPageList

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window.
//
//	Inheritance:
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWizardPageWindow : public CBasePageWindow
{
	typedef CBasePageWindow baseClass;

	friend CWizardWindow;
	friend CCluAdmExDll;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_fWizardButtons( 0 )
		, m_bBackPressed( FALSE )
		, m_bIsPageEnabled( FALSE )
		, m_bIsNextPageSet( FALSE )
	{
	} //*** CWizardPageWindow()

	// Destructor
	virtual ~CWizardPageWindow( void )
	{
	} //*** ~CWizardPageWindow()

public:
	//
	// CWizardPageWindow public methods.
	//

	// Enable or disable the Next button
	void EnableNext( IN BOOL bEnable = TRUE )
	{
		ATLASSERT( Pwiz() != NULL );

		//
		// Ask the wizard to enable or disable the Next button.
		//
		Pwiz()->EnableNext( bEnable, FWizardButtons() );

	} //*** EnableNext()

	// Set the next page to be enabled
	void SetNextPage( IN LPCTSTR pszNextPage )
	{
		Pwiz()->SetNextPage( this, pszNextPage );
		m_bIsNextPageSet = TRUE;

	} //*** SetNextPage()

	// Set the next page to be enabled from a dialog ID
	void SetNextPage( IN UINT idNextPage )
	{
		Pwiz()->SetNextPage( this, idNextPage );
		m_bIsNextPageSet = TRUE;

	} //*** SetNextPage()

public:
	//
	// Message handler functions.
	//

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void )
	{
		if ( ! m_bIsPageEnabled )
		{
			return FALSE;
		} // if:  page is not enabled to be displayed

		SetWizardButtons();
		m_bBackPressed = FALSE;

		return baseClass::OnSetActive();

	} //*** OnSetActive()

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		m_bBackPressed = TRUE;
		int nResult = baseClass::OnWizardBack();
		if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
		{
			nResult = -1;
		} // if:  error updating data
		if ( nResult == -1 ) // if not successful
		{
			m_bBackPressed = FALSE;
		} // if:  failure occurred
		else if ( nResult == 0 ) // defaulting to go to next page
		{
		} // else if:  no next page specified

		return nResult;

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		// Update the data in the class from the page.
		if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
		{
			return -1;
		} // if:  error updating data

		// Save the data in the sheet.
		if ( ! BApplyChanges() )
		{
			return -1;
		} // if:  error applying changes

		int nResult = baseClass::OnWizardNext();

		return nResult;

	} //*** OnWizardNext()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		if ( BIsPageEnabled() )
		{
			// Update the data in the class from the page.
			if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
			{
				return FALSE;
			} // if:  error updating data

			// Save the data in the sheet.
			if ( ! BApplyChanges() )
			{
				return FALSE;
			} // if:  error applying changes
		} // if: page is enabled

		return baseClass::OnWizardFinish();

	} //*** OnWizardFinish()

	// Handler for PSN_RESET
	void OnReset( void )
	{
		Pwiz()->OnReset();
		baseClass::OnReset();

	} //*** OnReset()

// Implementation
protected:
	DWORD			m_fWizardButtons;
	BOOL			m_bBackPressed;
	BOOL			m_bIsPageEnabled;
	BOOL			m_bIsNextPageSet;
	CString			m_strHeaderTitle;
	CString			m_strHeaderSubTitle;

	DWORD			FWizardButtons( void ) const	{ return m_fWizardButtons; }
	BOOL			BBackPressed( void ) const		{ return m_bBackPressed; }
	BOOL			BIsPageEnabled( void ) const	{ return m_bIsPageEnabled; }
	BOOL			BIsNextPageSet( void ) const	{ return m_bIsNextPageSet; }
	const CString &	StrHeaderTitle( void ) const	{ return m_strHeaderTitle; }
	const CString &	StrHeaderSubTitle( void ) const	{ return m_strHeaderSubTitle; }

	CWizardWindow *	Pwiz( void ) const				{ return (CWizardWindow *) Psht(); }

	// Set default wizard buttons to be displayed with page
	void SetDefaultWizardButtons( IN DWORD fWizardButtons )
	{
		ATLASSERT( fWizardButtons != 0 );
		m_fWizardButtons = fWizardButtons;

	} //*** SetDefaultWizardButtons()

public:
	// Set wizard buttons on the wizard
	void SetWizardButtons( void )
	{
		ATLASSERT( m_fWizardButtons != 0 );
		Pwiz()->SetWizardButtons( m_fWizardButtons );

	} //*** SetWizardButtons()

	// Enable or disable the page
	void EnablePage( IN BOOL bEnable = TRUE )
	{
		m_bIsPageEnabled = bEnable;

	} //*** EnablePage()

}; //*** class CWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet before the call to PropertySheet().  This page cannot
//		be removed from the sheet.
//
//	Inheritance:
//		CStaticWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CStaticWizardPageWindow : public CWizardPageWindow
{
	typedef CWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CStaticWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CStaticWizardPageWindow()

}; //*** class CStaticWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet after the call to PropertySheet().  This page may be
//		removed from the sheet.
//
//	Inheritance:
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

class CDynamicWizardPageWindow : public CWizardPageWindow
{
	typedef CWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CDynamicWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_hpage( NULL )
		, m_bPageAddedToSheet( FALSE )
	{
	} //*** CDynamicWizardPageWindow()

	// Destructor
	~CDynamicWizardPageWindow( void )
	{
		//
		// Destroy the page if it hasn't been added to the sheet yet.
		// If it has been added to the sheet, the sheet will destroy it.
		//
		if (   (m_hpage != NULL)
			&& ! m_bPageAddedToSheet )
		{
			DestroyPropertySheetPage( m_hpage );
			m_hpage = NULL;
		} // if:  page not deleted yet and not added to the sheet

	} //*** ~CDynamicWizardPageWindow()

	// Create the page
	virtual DWORD ScCreatePage( void ) = 0;

protected:
	HPROPSHEETPAGE	m_hpage;
	BOOL			m_bPageAddedToSheet;

public:
	// Property page handle
	HPROPSHEETPAGE Hpage( void ) const { return m_hpage; }

	// Returns whether page has been added to the sheet or not
	BOOL BPageAddedToSheet( void ) const { return m_bPageAddedToSheet; }

	// Set whether the page has been added to the sheet or not
	void SetPageAdded( IN BOOL bAdded = TRUE )
	{
		m_bPageAddedToSheet = bAdded;
		if ( ! bAdded )
		{
			m_hpage = NULL;
		} // if:  removing page

	} //*** SetPageAdded()

}; //*** class CDynamicWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet after the call to PropertySheet() identified as a
//		non-Wizard97 extension to the list of standard pages.  This page may
//		be removed from the sheet.
//
//	Inheritance:
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

class CExtensionWizardPageWindow : public CDynamicWizardPageWindow
{
	typedef CDynamicWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CExtensionWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CExtensionWizardPageWindow()

}; //*** class CExtensionWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizard97PageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet after the call to PropertySheet() identified as a
//		Wizard97 extension to the list of standard pages.  This page may be
//		removed from the sheet.
//
//	Inheritance:
//		CExtensionWizard97PageWindow
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

class CExtensionWizard97PageWindow : public CExtensionWizardPageWindow
{
	typedef CExtensionWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CExtensionWizard97PageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CExtensionWizard97PageWindow()

}; //*** class CExtensionWizard97PageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation.
//
//	Inheritance:
//		CWizardPageImpl< T, TWin >
//		CBasePageImpl< T, TWin >
//		CPropertyPageImpl< T, TWin >
//		<TWin>
//		...
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TWin = CWizardPageWindow >
class CWizardPageImpl : public CBasePageImpl< T, TWin >
{
	typedef CWizardPageImpl< T, TWin > thisClass;
	typedef CBasePageImpl< T, TWin > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CWizardPageImpl( nIDTitle )

	// Initialize the page
	virtual BOOL BInit( IN CBaseSheetWindow * psht )
	{
		if ( ! baseClass::BInit( psht ) )
		{
			return FALSE;
		} // if:  base class failed
		if (   (Pwiz()->Ppsh()->dwFlags & PSH_WIZARD97)
			&& (Pwiz()->Ppsh()->dwFlags & PSH_HEADER) )
		{
			//
			// Get the header title.
			//
			UINT idsTitle = T::GetWizardPageHeaderTitleId();
			if ( idsTitle != 0 )
			{
				m_strHeaderTitle.LoadString( idsTitle );
				m_psp.pszHeaderTitle = m_strHeaderTitle;
				m_psp.dwFlags |= PSP_USEHEADERTITLE;
				m_psp.dwFlags &= ~PSP_HIDEHEADER;

				//
				// Get the header subtitle.
				//
				UINT idsSubTitle = T::GetWizardPageHeaderSubTitleId();
				if ( idsSubTitle != 0 )
				{
					m_strHeaderSubTitle.LoadString( idsSubTitle );
					m_psp.pszHeaderSubTitle = m_strHeaderSubTitle;
					m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
				} // if:  subtitle specified
			} // if:  title specified
			else
			{
				m_psp.dwFlags |= PSP_HIDEHEADER;
			} // else:  no title specified
		} // if:  Wizard97 with a header

		return TRUE;

	} //*** BInit()

public:
	//
	// CWizardPageImpl public methods.
	//

	// Get the next page we're going to
	CWizardPageWindow * PwizpgNext( IN LPCTSTR psz = NULL )
	{
		ATLASSERT( psz != (LPCTSTR) -1 );
		CWizardPageWindow * ppage = NULL;
		if ( psz == NULL )
		{
			//
			// There will not be a resource ID for extension pages, so check
			// for that before calling PwpageNextFromID.  This allows us to
			// leave the assert in there for a non-NULL resource.
			//
			if ( T::IDD != 0 )
			{
				ppage = Pwiz()->PlwpPages()->PwpageNextFromID( MAKEINTRESOURCE( T::IDD ) );
			} // if:  there is a resource ID for this page
		} // if:  no next page specified
		else
		{
			ppage = Pwiz()->PlwpPages()->PwpageFromID( psz );
		} // else:  next page specified
		return ppage;

	} //*** PwizpgNext()

	// Enable or disable the next page
	void EnableNextPage( IN BOOL bEnable = TRUE )
	{
		CWizardPageWindow * pwp = PwizpgNext();
		if ( pwp != NULL )
		{
			pwp->EnablePage( bEnable );
		} // if:  next page found

	} //*** EnableNextPage()

public:
	//
	// Message handler functions.
	//

	//
	// Message handler override functions.
	//

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		//
		// Make sure back button is marked as last button pressed.
		//
		Pwiz()->SetLastWizardButton( ID_WIZBACK );

		return baseClass::OnWizardBack();

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		//
		// Make sure next button is marked as last button pressed.
		//
		Pwiz()->SetLastWizardButton( ID_WIZNEXT );

		int nResult = baseClass::OnWizardNext();
		if ( nResult != -1 )
		{
			if ( ! BIsNextPageSet() )
			{
				EnableNextPage();
			} // if:  next page not set yet
			m_bIsNextPageSet = FALSE;
		} // if:  changing pages

		return nResult;

	} //*** OnWizardNext()

// Implementation
protected:

public:

}; //*** class CWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet before the call to PropertySheet().  This page
//		cannot be removed from the sheet.
//
//	Inheritance:
//		CStaticWizardPageImpl< T >
//		CWizardPageImpl< T, CStaticWizardPageWindow >
//		CBasePageImpl< T, CStaticWizardPageWindow >
//		CPropertyPageImpl< T, CStaticWizardPageWindow >
//		CStaticWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CStaticWizardPageImpl : public CWizardPageImpl< T, CStaticWizardPageWindow >
{
	typedef CStaticWizardPageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CStaticWizardPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CStaticWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CStaticWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CStaticWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CStaticWizardPageImpl( nIDTitle )

}; //*** class CStaticWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet after the call to PropertySheet().  This page
//		may be removed from the sheet.
//
//	Inheritance:
//		CDynamicWizardPageImpl< T >
//		CWizardPageImpl< T, CDynamicWizardPageWindow >
//		CBasePageImpl< T, CDynamicWizardPageWindow >
//		CPropertyPageImpl< T, CDynamicWizardPageWindow >
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CDynamicWizardPageImpl : public CWizardPageImpl< T, CDynamicWizardPageWindow >
{
	typedef CDynamicWizardPageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CDynamicWizardPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CDynamicWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CDynamicWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CDynamicWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CDynamicWizardPageImpl( nIDTitle )

	// Create the page
	DWORD ScCreatePage( void )
	{
		ATLASSERT( m_hpage == NULL );

		m_hpage = CreatePropertySheetPage( &m_psp );
		if ( m_hpage == NULL )
		{
			return GetLastError();
		} // if:  error creating the page

		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CDynamicWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet after the call to PropertySheet() identified
//		as a non-Wizard97 extension to the list of standard pages.  This
//		page may be removed from the sheet.
//
//	Inheritance:
//		CExtensionWizardPageImpl< T >
//		CWizardPageImpl< T, CExtensionWizardPageWindow >
//		CBasePageImpl< T, CExtensionWizardPageWindow >
//		CPropertyPageImpl< T, CExtensionWizardPageWindow >
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CExtensionWizardPageImpl : public CWizardPageImpl< T, CExtensionWizardPageWindow >
{
	typedef CExtensionWizardPageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CExtensionWizardPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CExtensionWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CExtensionWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CExtensionWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CExtensionWizardPageImpl( nIDTitle )

}; //*** class CExtensionWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizard97PageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet after the call to PropertySheet() identified
//		as a Wizard97 extension to the list of standard pages.  This page
//		may be removed from the sheet.
//
//	Inheritance:
//		CExtensionWizard97PageImpl< T >
//		CWizardPageImpl< T, CExtensionWizard97PageWindow >
//		CBasePageImpl< T, CExtensionWizard97PageWindow >
//		CPropertyPageImpl< T, CExtensionWizard97PageWindow >
//		CExtensionWizard97PageWindow
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CExtensionWizard97PageImpl : public CWizardPageImpl< T, CExtensionWizard97PageWindow >
{
	typedef CExtensionWizard97PageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CExtensionWizard97PageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CExtensionWizard97PageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CExtensionWizard97PageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CExtensionWizard97PageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CExtensionWizard97PageImpl( nIDTitle )

}; //*** class CExtensionWizard97PageImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEWIZPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlbasewiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWiz.h
//
//	Implementation File:
//		AtlBaseWiz.cpp
//
//	Description:
//		Definition of the CWizardWindow and CWizardImpl classes.
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEWIZ_H_
#define __ATLBASEWIZ_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters in the browser information

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardWindow;
template < class T, class TBase > class CWizardImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardPageWindow;
class CWizardPageList;
class CDynamicWizardPageList;
class CExtensionWizardPageList;
class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#include "AdmCommonRes.h"	// for ID_WIZNEXT, etc.
#endif

#ifndef __ATLBASESHEET_H_
#include "AtlBaseSheet.h"	// for CBaseSheetWindow
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardWindow
//
//	Description:
//		Base wizard property sheet window.
//
//	Inheritance:
//		CWizardWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWizardWindow : public CBaseSheetWindow
{
	typedef CBaseSheetWindow baseClass;

	friend class CWizardPageWindow;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_plwpPages( NULL )
		, m_plewpNormal( NULL )
		, m_plewpAlternate( NULL )
		, m_pwizAlternate( NULL )
		, m_pcoObjectToExtend( NULL )
		, m_nLastWizardButton( 0 )
	{
		m_pwizCurrent = this;

	} //*** CWizardWindow()

	// Destructor
	~CWizardWindow( void );

protected:
	CWizardPageList *			m_plwpPages;			// List of pages in the wizard.
	CExtensionWizardPageList *	m_plewpNormal;			// List of normal extension pages.
	CExtensionWizardPageList *	m_plewpAlternate;		// List of alternate extension pages.
	CWizardWindow *				m_pwizAlternate;		// Alternate extension wizard.
	CWizardWindow *				m_pwizCurrent;			// Currently visible wizard.
	CClusterObject *			m_pcoObjectToExtend;	// Cluster object to extend.
	int							m_nLastWizardButton;	// Indicates the last wizard button pressed.

public:
	//
	// Access methods.
	//

	// Access list of pages in the wizard
	CWizardPageList * PlwpPages( void )
	{
		ATLASSERT( m_plwpPages != NULL );
		return m_plwpPages;

	} //*** PlwpPages()

	// Access list of normal extension pages
	CExtensionWizardPageList * PlewpNormal( void ) { return m_plewpNormal; }

	// Access list of alternate extension pages
	CExtensionWizardPageList * PlewpAlternate( void ) { return m_plewpAlternate; }

	// Access alternate extension wizard
	CWizardWindow * PwizAlternate( void ) { return m_pwizAlternate; }

	// Access currently visible wizard
	CWizardWindow * PwizCurrent( void ) { return m_pwizCurrent; }

	// Set the current wizard
	void SetCurrentWizard( CWizardWindow * pwizCurrent )
	{
		ATLASSERT( pwizCurrent != NULL );
		ATLASSERT( ( pwizCurrent == this ) || ( pwizCurrent == m_pwizAlternate ) );
		m_pwizCurrent = pwizCurrent;

	} //*** SetCurrentWizard()

	// Set the alternate extension wizard
	void SetAlternateWizard( IN CWizardWindow * pwiz )
	{
		ATLASSERT( pwiz != NULL );
		m_pwizAlternate = pwiz;

	} //*** SetAlternateWizard()

	// Delete the alternate extension wizard
	void DeleteAlternateWizard( void )
	{
		ATLASSERT( m_pwizAlternate != NULL );
		ATLASSERT( m_pwizCurrent != m_pwizAlternate );
		delete m_pwizAlternate;
		m_pwizAlternate = NULL;

	} //*** ClearAlternateWizard()

	// Access the cluster object to extend
	CClusterObject * PcoObjectToExtend( void ) { return m_pcoObjectToExtend; }

	// Set the object to extend
	void SetObjectToExtend( IN CClusterObject * pco )
	{
		ATLASSERT( pco != NULL );
		m_pcoObjectToExtend = pco;

	} //*** SetObjectToExtend()

	// Returns the last wizard button pressed
	int NLastWizardButton( void ) const { return m_nLastWizardButton; }

	// Set the last wizard button pressed
	void SetLastWizardButton( IN int idCtrl )
	{
		ATLASSERT( (idCtrl == ID_WIZBACK) || (idCtrl == ID_WIZNEXT) || (idCtrl == IDCANCEL) );
		m_nLastWizardButton = idCtrl;

	} //*** SetLastWizardButton()

	// Returns whether the Back button was pressed
	BOOL BBackPressed( void ) const { return (m_nLastWizardButton == ID_WIZBACK); }

	// Returns whether the Next button was pressed
	BOOL BNextPressed( void ) const { return (m_nLastWizardButton == ID_WIZNEXT); }

	// Returns whether the Cancel button was pressed
	BOOL BCancelPressed( void ) const { return (m_nLastWizardButton == IDCANCEL); }

	// Returns whether the wizard is Wizard97 compliant or not
	BOOL BWizard97( void ) const { return (Ppsh()->dwFlags & PSH_WIZARD97) == PSH_WIZARD97; }

public:
	// Add a page (required to get to base class method)
	void AddPage( HPROPSHEETPAGE hPage )
	{
		CBaseSheetWindow::AddPage( hPage );

	} //*** AddPage( hPage )

	// Add a page (required to get to base class method)
	BOOL AddPage( LPCPROPSHEETPAGE pPage )
	{
		return CBaseSheetWindow::AddPage( pPage );

	} //*** AddPage( pPage )

	// Add a page to wizard
	BOOL BAddPage( IN CWizardPageWindow * pwp );

	// Set the next page to be displayed
	void SetNextPage( IN CWizardPageWindow * pwCurrentPage, IN LPCTSTR pszNextPage );

	// Set the next page to be displayed from a dialog ID
	void SetNextPage( IN CWizardPageWindow * pwCurrentPage, IN UINT idNextPage )
	{
		SetNextPage( pwCurrentPage, MAKEINTRESOURCE( idNextPage ) );

	} //*** SetNextPage( idNextPage )

	// Handler for BN_CLICKED for ID_WIZFINISH
	LRESULT OnWizFinish(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		EnumChildWindows( m_hWnd, &ECWCallback, (LPARAM) this );

		if ( m_pwizAlternate != NULL )
		{
			return m_pwizAlternate->OnWizFinish( wNotifyCode, idCtrl, hwndCtrl, bHandled );
		} // if: alternate wizard exists

		bHandled = FALSE;
		return FALSE;

	} //*** OnWizFinish()

	static BOOL CALLBACK ECWCallback( HWND hWnd, LPARAM lParam )
	{
		CWizardWindow *pww = (CWizardWindow *) lParam;
		NMHDR nmhdr;

		// If we enumerated ourself, skip
		if ( pww->m_hWnd == hWnd )
		{
			return TRUE;
		} // if: enumerating ourself

		nmhdr.hwndFrom = pww->m_hWnd;
		nmhdr.idFrom = 0;
		nmhdr.code = PSN_WIZFINISH;

		SendMessage( hWnd, WM_NOTIFY, 0, (LPARAM) &nmhdr );

		return TRUE;

	} //*** ECWCallback()


public:
	//
	// CWizardWindow methods.
	//

	// Enable or disable the Next button
	void EnableNext( IN BOOL bEnable, IN DWORD fDefaultWizardButtons )
	{
		ATLASSERT( fDefaultWizardButtons != 0 );

		//
		// If there is an alternate wizard, send this message to it.
		//
		if ( PwizCurrent() == PwizAlternate() )
		{
			PwizAlternate()->EnableNext( bEnable, fDefaultWizardButtons );
		} // if:  there is an alternate wizard
		else
		{
			//
			// Get the buttons for the wizard.
			//
			DWORD fWizardButtons = fDefaultWizardButtons;

			//
			// If the Next button is to be disabled, make sure we show a
			// disabled Finish button if the Finish button is supposed to be
			// displayed.  Otherwise a disabled Next button will be displayed.
			//
			if ( ! bEnable )
			{
				fWizardButtons &= ~(PSWIZB_NEXT | PSWIZB_FINISH);
				if ( fDefaultWizardButtons & PSWIZB_FINISH )
				{
					fWizardButtons |= PSWIZB_DISABLEDFINISH;
				} // if:  finish button displayed
			}  // if:  disabling the button

			//
			// Set the new button states.
			//
			SetWizardButtons( fWizardButtons );

		} // else:  no alternate wizard

	} //*** EnableNext()

public:
	//
	// Overrides of abstract methods.
	//

	// Add extension pages to the sheet
	virtual void AddExtensionPages( IN HFONT hfont, IN HICON hicon );

	// Add a page (called by extension)
	virtual HRESULT HrAddExtensionPage( IN CBasePageWindow * ppage );

	// Handle a reset from one of the pages
	virtual void OnReset( void )
	{
	} //*** OnReset()

public:
	//
	// Message handler functions.
	//

	// Handler for PSCB_INITIALIZED
	void OnSheetInitialized( void );

// Implementation
protected:
	// Prepare to add exension pages to the wizard
	void PrepareToAddExtensionPages( IN OUT CDynamicWizardPageList & rldwp );

	// Complete the process of adding extension pages
	void CompleteAddingExtensionPages( IN OUT CDynamicWizardPageList & rldwp );

	// Remove all extension pages from the wizard
	void RemoveAllExtensionPages( void );

}; //*** class CWizardWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardImpl
//
//	Description:
//		Base wizard property sheet implementation.
//
//	Inheritance:
//		CWizardImpl< T, TBase >
//		CBaseSheetImpl< T, TBase >
//		CPropertySheetImpl< T, TBase >
//		<TBase>
//		...
//		CWizardWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CWizardWindow >
class CWizardImpl : public CBaseSheetImpl< T, TBase >
{
	typedef CWizardImpl< T, TBase > thisClass;
	typedef CBaseSheetImpl< T, TBase > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardImpl(
		IN LPCTSTR	lpszTitle = NULL,
		IN UINT		uStartPage = 0
		)
		: CBaseSheetImpl< T, TBase >( lpszTitle, uStartPage )
	{
		// Make this sheet a wizard.
		SetWizardMode();

		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CWizardImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CWizardImpl(
		IN UINT nIDTitle,
		IN UINT uStartPage = 0
		)
		: CBaseSheetImpl< T, TBase >( NULL, uStartPage )
	{
		m_strTitle.LoadString( nIDTitle );
		m_psh.pszCaption = m_strTitle;

		// Make this sheet a wizard.
		SetWizardMode();

		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CWizardImpl( nIDTitle )

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
		COMMAND_HANDLER( ID_WIZBACK, BN_CLICKED, OnButtonPressed )
		COMMAND_HANDLER( ID_WIZNEXT, BN_CLICKED, OnButtonPressed )
		COMMAND_HANDLER( ID_WIZFINISH, BN_CLICKED, OnWizFinish )
		COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnButtonPressed )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	//
	// Message handler functions.
	//

	// Handler for BN_CLICKED on wizard buttons
	LRESULT OnButtonPressed(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_nLastWizardButton = idCtrl;
		bHandled = FALSE;
		return 0;

	} //*** OnButtonPressed()

// Implementation
protected:
	CString			m_strTitle;				// Used to support resource IDs for the title.

public:
	const CString &	StrTitle( void ) const			{ return m_strTitle; }

	// Set the title of the sheet
	void SetTitle( LPCTSTR lpszText, UINT nStyle = 0 )
	{
		baseClass::SetTitle( lpszText, nStyle );
		m_strTitle = lpszText;

	} //*** SetTitle()

}; //*** class CWizardImpl

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

// Create a dialog template for use with a dummy page
DLGTEMPLATE * PdtCreateDummyPageDialogTemplate( IN WORD cx, IN WORD cy );

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atldbgwin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlDbgWin.cpp
//
//	Abstract:
//		Implementation of the ATL window debugging functions.
//
//	Author:
//		David Potter (davidp)	June 2, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlDbgWin.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
extern const ID_MAP_ENTRY s_rgmapWindowMsgs[];
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapWindowMsgs[] =
{
	DECLARE_ID_STRING( WM_NULL )
	DECLARE_ID_STRING( WM_CREATE )
	DECLARE_ID_STRING( WM_DESTROY )
	DECLARE_ID_STRING( WM_MOVE )
	DECLARE_ID_STRING( WM_SIZE )
	DECLARE_ID_STRING( WM_ACTIVATE )
	DECLARE_ID_STRING( WM_SETFOCUS )
	DECLARE_ID_STRING( WM_KILLFOCUS )
	DECLARE_ID_STRING( WM_ENABLE )
	DECLARE_ID_STRING( WM_SETREDRAW )
	DECLARE_ID_STRING( WM_SETTEXT )
	DECLARE_ID_STRING( WM_GETTEXT )
	DECLARE_ID_STRING( WM_GETTEXTLENGTH )
	DECLARE_ID_STRING( WM_PAINT )
	DECLARE_ID_STRING( WM_CLOSE )
#ifndef _WIN32_WCE
	DECLARE_ID_STRING( WM_QUERYENDSESSION )
	DECLARE_ID_STRING( WM_QUERYOPEN )
	DECLARE_ID_STRING( WM_ENDSESSION )
#endif // _WIN32_WCE
	DECLARE_ID_STRING( WM_QUIT )
	DECLARE_ID_STRING( WM_ERASEBKGND )
	DECLARE_ID_STRING( WM_SYSCOLORCHANGE )
	DECLARE_ID_STRING( WM_SHOWWINDOW )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING_EX( WM_WININICHANGE, _T(" / WM_SETTINGCHANGE") )
#else
	DECLARE_ID_STRING( WM_WININICHANGE )
#endif // (WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_DEVMODECHANGE )
	DECLARE_ID_STRING( WM_ACTIVATEAPP )
	DECLARE_ID_STRING( WM_FONTCHANGE )
	DECLARE_ID_STRING( WM_TIMECHANGE )
	DECLARE_ID_STRING( WM_CANCELMODE )
	DECLARE_ID_STRING( WM_SETCURSOR )
	DECLARE_ID_STRING( WM_MOUSEACTIVATE )
	DECLARE_ID_STRING( WM_CHILDACTIVATE )
	DECLARE_ID_STRING( WM_QUEUESYNC )
	DECLARE_ID_STRING( WM_GETMINMAXINFO )
	DECLARE_ID_STRING( WM_PAINTICON )
	DECLARE_ID_STRING( WM_ICONERASEBKGND )
	DECLARE_ID_STRING( WM_NEXTDLGCTL )
	DECLARE_ID_STRING( WM_SPOOLERSTATUS )
	DECLARE_ID_STRING( WM_DRAWITEM )
	DECLARE_ID_STRING( WM_MEASUREITEM )
	DECLARE_ID_STRING( WM_DELETEITEM )
	DECLARE_ID_STRING( WM_VKEYTOITEM )
	DECLARE_ID_STRING( WM_CHARTOITEM )
	DECLARE_ID_STRING( WM_SETFONT )
	DECLARE_ID_STRING( WM_GETFONT )
	DECLARE_ID_STRING( WM_SETHOTKEY )
	DECLARE_ID_STRING( WM_GETHOTKEY )
	DECLARE_ID_STRING( WM_QUERYDRAGICON )
	DECLARE_ID_STRING( WM_COMPAREITEM )
#if(WINVER >= 0x0500)
#ifndef _WIN32_WCE
	DECLARE_ID_STRING( WM_GETOBJECT )
#endif // _WIN32_WCE
#endif // (WINVER >= 0x0500)
	DECLARE_ID_STRING( WM_COMPACTING )
	DECLARE_ID_STRING( WM_COMMNOTIFY )
	DECLARE_ID_STRING( WM_WINDOWPOSCHANGING )
	DECLARE_ID_STRING( WM_WINDOWPOSCHANGED )
	DECLARE_ID_STRING( WM_POWER )
	DECLARE_ID_STRING( WM_COPYDATA )
	DECLARE_ID_STRING( WM_CANCELJOURNAL )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_NOTIFY )
	DECLARE_ID_STRING( WM_INPUTLANGCHANGEREQUEST )
	DECLARE_ID_STRING( WM_INPUTLANGCHANGE )
	DECLARE_ID_STRING( WM_TCARD )
	DECLARE_ID_STRING( WM_HELP )
	DECLARE_ID_STRING( WM_USERCHANGED )
	DECLARE_ID_STRING( WM_NOTIFYFORMAT )
	DECLARE_ID_STRING( WM_CONTEXTMENU )
	DECLARE_ID_STRING( WM_STYLECHANGING )
	DECLARE_ID_STRING( WM_STYLECHANGED )
	DECLARE_ID_STRING( WM_DISPLAYCHANGE )
	DECLARE_ID_STRING( WM_GETICON )
	DECLARE_ID_STRING( WM_SETICON )
#endif // (WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_NCCREATE )
	DECLARE_ID_STRING( WM_NCDESTROY )
	DECLARE_ID_STRING( WM_NCCALCSIZE )
	DECLARE_ID_STRING( WM_NCHITTEST )
	DECLARE_ID_STRING( WM_NCPAINT )
	DECLARE_ID_STRING( WM_NCACTIVATE )
	DECLARE_ID_STRING( WM_GETDLGCODE )
#ifndef _WIN32_WCE
	DECLARE_ID_STRING( WM_SYNCPAINT )
#endif // _WIN32_WCE
	DECLARE_ID_STRING( WM_NCMOUSEMOVE )
	DECLARE_ID_STRING( WM_NCLBUTTONDOWN )
	DECLARE_ID_STRING( WM_NCLBUTTONUP )
	DECLARE_ID_STRING( WM_NCLBUTTONDBLCLK )
	DECLARE_ID_STRING( WM_NCRBUTTONDOWN )
	DECLARE_ID_STRING( WM_NCRBUTTONUP )
	DECLARE_ID_STRING( WM_NCRBUTTONDBLCLK )
	DECLARE_ID_STRING( WM_NCMBUTTONDOWN )
	DECLARE_ID_STRING( WM_NCMBUTTONUP )
	DECLARE_ID_STRING( WM_NCMBUTTONDBLCLK )
	DECLARE_ID_STRING( WM_KEYDOWN )
	DECLARE_ID_STRING( WM_KEYUP )
	DECLARE_ID_STRING( WM_CHAR )
	DECLARE_ID_STRING( WM_DEADCHAR )
	DECLARE_ID_STRING( WM_SYSKEYDOWN )
	DECLARE_ID_STRING( WM_SYSKEYUP )
	DECLARE_ID_STRING( WM_SYSCHAR )
	DECLARE_ID_STRING( WM_SYSDEADCHAR )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_IME_STARTCOMPOSITION )
	DECLARE_ID_STRING( WM_IME_ENDCOMPOSITION )
	DECLARE_ID_STRING( WM_IME_COMPOSITION )
#endif // (WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_INITDIALOG )
	DECLARE_ID_STRING( WM_COMMAND )
	DECLARE_ID_STRING( WM_SYSCOMMAND )
	DECLARE_ID_STRING( WM_TIMER )
	DECLARE_ID_STRING( WM_HSCROLL )
	DECLARE_ID_STRING( WM_VSCROLL )
	DECLARE_ID_STRING( WM_INITMENU )
	DECLARE_ID_STRING( WM_INITMENUPOPUP )
	DECLARE_ID_STRING( WM_MENUSELECT )
	DECLARE_ID_STRING( WM_MENUCHAR )
	DECLARE_ID_STRING( WM_ENTERIDLE )
#if(WINVER >= 0x0500)
#ifndef _WIN32_WCE
	DECLARE_ID_STRING( WM_MENURBUTTONUP )
	DECLARE_ID_STRING( WM_MENUDRAG )
	DECLARE_ID_STRING( WM_MENUGETOBJECT )
	DECLARE_ID_STRING( WM_UNINITMENUPOPUP )
	DECLARE_ID_STRING( WM_MENUCOMMAND )
#ifndef _WIN32_WCE
#if(_WIN32_WINNT >= 0x0500)
	DECLARE_ID_STRING( WM_KEYBOARDCUES )
#endif // (_WIN32_WINNT >= 0x0500)
#endif // _WIN32_WCE
#endif // _WIN32_WCE
#endif // (WINVER >= 0x0500)
	DECLARE_ID_STRING( WM_CTLCOLORMSGBOX )
	DECLARE_ID_STRING( WM_CTLCOLOREDIT )
	DECLARE_ID_STRING( WM_CTLCOLORLISTBOX )
	DECLARE_ID_STRING( WM_CTLCOLORBTN )
	DECLARE_ID_STRING( WM_CTLCOLORDLG )
	DECLARE_ID_STRING( WM_CTLCOLORSCROLLBAR )
	DECLARE_ID_STRING( WM_CTLCOLORSTATIC )
	DECLARE_ID_STRING( WM_MOUSEMOVE )
	DECLARE_ID_STRING( WM_LBUTTONDOWN )
	DECLARE_ID_STRING( WM_LBUTTONUP )
	DECLARE_ID_STRING( WM_LBUTTONDBLCLK )
	DECLARE_ID_STRING( WM_RBUTTONDOWN )
	DECLARE_ID_STRING( WM_RBUTTONUP )
	DECLARE_ID_STRING( WM_RBUTTONDBLCLK )
	DECLARE_ID_STRING( WM_MBUTTONDOWN )
	DECLARE_ID_STRING( WM_MBUTTONUP )
	DECLARE_ID_STRING( WM_MBUTTONDBLCLK )
#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS >= 0x0400)
	DECLARE_ID_STRING( WM_MOUSEWHEEL )
#endif // (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS >= 0x0400)
	DECLARE_ID_STRING( WM_PARENTNOTIFY )
	DECLARE_ID_STRING( WM_ENTERMENULOOP )
	DECLARE_ID_STRING( WM_EXITMENULOOP )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_NEXTMENU )
	DECLARE_ID_STRING( WM_SIZING )
	DECLARE_ID_STRING( WM_CAPTURECHANGED )
	DECLARE_ID_STRING( WM_MOVING )
#endif // (WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_POWERBROADCAST )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_DEVICECHANGE )
#endif // (WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_MDICREATE )
	DECLARE_ID_STRING( WM_MDIDESTROY )
	DECLARE_ID_STRING( WM_MDIACTIVATE )
	DECLARE_ID_STRING( WM_MDIRESTORE )
	DECLARE_ID_STRING( WM_MDINEXT )
	DECLARE_ID_STRING( WM_MDIMAXIMIZE )
	DECLARE_ID_STRING( WM_MDITILE )
	DECLARE_ID_STRING( WM_MDICASCADE )
	DECLARE_ID_STRING( WM_MDIICONARRANGE )
	DECLARE_ID_STRING( WM_MDIGETACTIVE )
	DECLARE_ID_STRING( WM_MDISETMENU )
	DECLARE_ID_STRING( WM_ENTERSIZEMOVE )
	DECLARE_ID_STRING( WM_EXITSIZEMOVE )
	DECLARE_ID_STRING( WM_DROPFILES )
	DECLARE_ID_STRING( WM_MDIREFRESHMENU )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_IME_SETCONTEXT )
	DECLARE_ID_STRING( WM_IME_NOTIFY )
	DECLARE_ID_STRING( WM_IME_CONTROL )
	DECLARE_ID_STRING( WM_IME_COMPOSITIONFULL )
	DECLARE_ID_STRING( WM_IME_SELECT )
	DECLARE_ID_STRING( WM_IME_CHAR )
#endif // (WINVER >= 0x0400)
#if(WINVER >= 0x0500)
	DECLARE_ID_STRING( WM_IME_REQUEST )
#endif // (WINVER >= 0x0500)
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_IME_KEYDOWN )
	DECLARE_ID_STRING( WM_IME_KEYUP )
#endif // (WINVER >= 0x0400)
#if(_WIN32_WINNT >= 0x0400)
	DECLARE_ID_STRING( WM_MOUSEHOVER )
	DECLARE_ID_STRING( WM_MOUSELEAVE )
#endif // (_WIN32_WINNT >= 0x0400)
#if(WINVER >= 0x0500)
	DECLARE_ID_STRING( WM_NCMOUSEHOVER )
	DECLARE_ID_STRING( WM_NCMOUSELEAVE )
#endif // (WINVER >= 0x0500)
	DECLARE_ID_STRING( WM_CUT )
	DECLARE_ID_STRING( WM_COPY )
	DECLARE_ID_STRING( WM_PASTE )
	DECLARE_ID_STRING( WM_CLEAR )
	DECLARE_ID_STRING( WM_UNDO )
	DECLARE_ID_STRING( WM_RENDERFORMAT )
	DECLARE_ID_STRING( WM_RENDERALLFORMATS )
	DECLARE_ID_STRING( WM_DESTROYCLIPBOARD )
	DECLARE_ID_STRING( WM_DRAWCLIPBOARD )
	DECLARE_ID_STRING( WM_PAINTCLIPBOARD )
	DECLARE_ID_STRING( WM_VSCROLLCLIPBOARD )
	DECLARE_ID_STRING( WM_SIZECLIPBOARD )
	DECLARE_ID_STRING( WM_ASKCBFORMATNAME )
	DECLARE_ID_STRING( WM_CHANGECBCHAIN )
	DECLARE_ID_STRING( WM_HSCROLLCLIPBOARD )
	DECLARE_ID_STRING( WM_QUERYNEWPALETTE )
	DECLARE_ID_STRING( WM_PALETTEISCHANGING )
	DECLARE_ID_STRING( WM_PALETTECHANGED )
	DECLARE_ID_STRING( WM_HOTKEY )
#if(WINVER >= 0x0400)
	DECLARE_ID_STRING( WM_PRINT )
	DECLARE_ID_STRING( WM_PRINTCLIENT )
	DECLARE_ID_STRING_2( WM_AFXFIRST+0, WM_QUERYAFXWNDPROC )
	DECLARE_ID_STRING_2( WM_AFXFIRST+1, WM_SIZEPARENT )
	DECLARE_ID_STRING_2( WM_AFXFIRST+2, WM_SETMESSAGESTRING )
	DECLARE_ID_STRING_2( WM_AFXFIRST+3, WM_IDLEUPDATECMDUI )
	DECLARE_ID_STRING_2( WM_AFXFIRST+4, WM_INITIALUPDATE )
	DECLARE_ID_STRING_2( WM_AFXFIRST+5, WM_COMMANDHELP )
	DECLARE_ID_STRING_2( WM_AFXFIRST+6, WM_HELPHITTEST )
	DECLARE_ID_STRING_2( WM_AFXFIRST+7, WM_EXITHELPMODE )
	DECLARE_ID_STRING_2( WM_AFXFIRST+8, WM_RECALCPARENT )
	DECLARE_ID_STRING_2( WM_AFXFIRST+9, WM_SIZECHILD )
	DECLARE_ID_STRING_2( WM_AFXFIRST+10, WM_KICKIDLE )
	DECLARE_ID_STRING_2( WM_AFXFIRST+11, WM_QUERYCENTERWND )
	DECLARE_ID_STRING_2( WM_AFXFIRST+12, WM_DISABLEMODAL )
	DECLARE_ID_STRING_2( WM_AFXFIRST+13, WM_FLOATSTATUS )
	DECLARE_ID_STRING_2( WM_AFXFIRST+14, WM_ACTIVATETOPLEVEL )
	DECLARE_ID_STRING_2( WM_AFXFIRST+15, WM_QUERY3DCONTROLS )
	DECLARE_ID_STRING_2( WM_AFXFIRST+16, WM_RESERVED_0370 )
	DECLARE_ID_STRING_2( WM_AFXFIRST+17, WM_RESERVED_0371 )
	DECLARE_ID_STRING_2( WM_AFXFIRST+18, WM_RESERVED_0372 )
	DECLARE_ID_STRING_2( WM_AFXFIRST+19, WM_SOCKET_NOTIFY )
	DECLARE_ID_STRING_2( WM_AFXFIRST+20, WM_SOCKET_DEAD )
	DECLARE_ID_STRING_2( WM_AFXFIRST+21, WM_POPMESSAGESTRING )
	DECLARE_ID_STRING_2( WM_AFXFIRST+22, WM_OCC_LOADFROMSTREAM )
	DECLARE_ID_STRING_2( WM_AFXFIRST+23, WM_OCC_LOADFROMSTORAGE )
	DECLARE_ID_STRING_2( WM_AFXFIRST+24, WM_OCC_INITNEW )
	DECLARE_ID_STRING_2( WM_AFXFIRST+25, WM_OCC_LOADFROMSTREAM_EX )
	DECLARE_ID_STRING_2( WM_AFXFIRST+26, WM_OCC_LOADFROMSTORAGE_EX )
	DECLARE_ID_STRING_2( WM_AFXFIRST+27, WM_QUEUE_SENTINEL )
	DECLARE_ID_STRING_2( WM_AFXFIRST+28, WM_RESERVED_037C )
	DECLARE_ID_STRING_2( WM_AFXFIRST+29, WM_RESERVED_037D )
	DECLARE_ID_STRING_2( WM_AFXFIRST+30, WM_RESERVED_037E )
	DECLARE_ID_STRING_2( WM_AFXFIRST+31, WM_RESERVED_037F )
	DECLARE_ID_STRING( WM_APP )
#endif // (WINVER >= 0x0400)
	{ NULL, 0 }
};
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_COMMAND )
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapButtonMsgs[] =
{
	DECLARE_ID_STRING( BN_CLICKED )
	DECLARE_ID_STRING( BN_PAINT )
	DECLARE_ID_STRING_EX( BN_HILITE, _T(" / BN_PUSHED") )
	DECLARE_ID_STRING_EX( BN_UNHILITE, _T(" / BN_UNPUSHED") )
	DECLARE_ID_STRING( BN_DISABLE )
	DECLARE_ID_STRING( BN_DOUBLECLICKED )
	DECLARE_ID_STRING( BN_SETFOCUS )
	DECLARE_ID_STRING( BN_KILLFOCUS )
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapComboBoxMsgs[] =
{
	DECLARE_ID_STRING_2( (UINT) CBN_ERRSPACE, CBN_ERRSPACE )
	DECLARE_ID_STRING( CBN_SELCHANGE )
	DECLARE_ID_STRING( CBN_DBLCLK )
	DECLARE_ID_STRING( CBN_SETFOCUS )
	DECLARE_ID_STRING( CBN_KILLFOCUS )
	DECLARE_ID_STRING( CBN_EDITCHANGE )
	DECLARE_ID_STRING( CBN_EDITUPDATE )
	DECLARE_ID_STRING( CBN_DROPDOWN )
	DECLARE_ID_STRING( CBN_CLOSEUP )
	DECLARE_ID_STRING( CBN_SELENDOK )
	DECLARE_ID_STRING( CBN_SELENDCANCEL )
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapEditMsgs[] =
{
	DECLARE_ID_STRING( EN_SETFOCUS )
	DECLARE_ID_STRING( EN_KILLFOCUS )
	DECLARE_ID_STRING( EN_CHANGE )
	DECLARE_ID_STRING( EN_UPDATE )
	DECLARE_ID_STRING( EN_ERRSPACE )
	DECLARE_ID_STRING( EN_MAXTEXT )
	DECLARE_ID_STRING( EN_HSCROLL )
	DECLARE_ID_STRING( EN_VSCROLL )
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapListBoxMsgs[] =
{
	DECLARE_ID_STRING( LBN_ERRSPACE )
	DECLARE_ID_STRING( LBN_SELCHANGE )
	DECLARE_ID_STRING( LBN_DBLCLK )
	DECLARE_ID_STRING( LBN_SELCANCEL )
	DECLARE_ID_STRING( LBN_SETFOCUS )
	DECLARE_ID_STRING( LBN_KILLFOCUS )
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapScrollBarMsgs[] =
{
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapStaticMsgs[] =
{
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapListViewMsgs[] =
{
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapTreeViewMsgs[] =
{
	{ NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapIPAddressMsgs[] =
{
	DECLARE_ID_STRING( IPN_FIELDCHANGE )
	DECLARE_ID_STRING_EX( EN_SETFOCUS, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_KILLFOCUS, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_CHANGE, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_UPDATE, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_ERRSPACE, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_MAXTEXT, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_HSCROLL, _T(" (IPN)") )
	DECLARE_ID_STRING_EX( EN_VSCROLL, _T(" (IPN)") )
	{ NULL, 0 }
};
#endif // DBG && defined( _DBG_MSG_COMMAND )

#if DBG && defined( _DBG_MSG_NOTIFY )
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapPropSheetNotifyMsgs[] =
{
	DECLARE_ID_STRING( PSN_SETACTIVE )
	DECLARE_ID_STRING( PSN_KILLACTIVE )
	DECLARE_ID_STRING( PSN_APPLY )
	DECLARE_ID_STRING( PSN_RESET )
	DECLARE_ID_STRING( PSN_HELP )
	DECLARE_ID_STRING( PSN_WIZBACK )
	DECLARE_ID_STRING( PSN_WIZNEXT )
	DECLARE_ID_STRING( PSN_WIZFINISH )
	DECLARE_ID_STRING( PSN_QUERYCANCEL )
	{ NULL, 0 }
};
#endif // DBG && defined( _DBG_MSG_NOTIFY )

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
/////////////////////////////////////////////////////////////////////////////
//++
//
//	DBG_OnMsg
//
//	Routine Description:
//		Debug handler for any message.
//
//	Arguments:
//		uMsg			[IN] Message causing this function to be called.
//		wParam			[IN] Message specific parameter.
//		lParam			[IN] Message specific parameter.
//		bHandled		[IN OUT] TRUE = message has been handled (we set to FALSE).
//		pszClassName	[IN] Name of class calling this function.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT DBG_OnMsg(
	UINT	uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL &	bHandled,
	LPCTSTR	pszClassName
	)
{
	ATLASSERT( pszClassName != NULL );

	const ID_MAP_ENTRY * pmap;

	//
	// Display the message code.
	//
	ATLTRACE( _T("%s::OnMsg() - Message = %08.8X"), pszClassName, uMsg );
	pmap = s_rgmapWindowMsgs;
	if (   (WM_USER <= uMsg)
		&& (uMsg < WM_APP) )
	{
		ATLTRACE( _T(" (WM_USER + %d)"), uMsg - WM_USER );
	} // if:  user message
#if(WINVER >= 0x0400)
	else if (  (WM_HANDHELDFIRST <= uMsg)
			&& (uMsg <= WM_HANDHELDLAST) )
	{
		ATLTRACE( _T(" (WM_HANDHELDFIRST + %d)"), uMsg - WM_HANDHELDFIRST );
	} // else if:  handheld PC message
#endif // (WINVER >= 0x0400)
	else if (  (WM_PENWINFIRST <= uMsg)
			&& (uMsg <= WM_PENWINLAST) )
	{
		ATLTRACE( _T(" (WM_PENWINFIRST + %d)"), uMsg - WM_PENWINFIRST );
	} // else if:  pen windows message
	else
	{
		for ( ; pmap->pszName != NULL ; pmap++ )
		{
			if ( uMsg == pmap->id )
			{
				ATLTRACE( _T(" (%s)"), pmap->pszName );
				break;
			} // if:  message found
		} // for:  each code in the map
	} // else:  not range message
	if (   (WM_AFXFIRST <= uMsg)
		&& (uMsg <= WM_AFXLAST) )
	{
		ATLTRACE( _T(" (WM_AFXFIRST + %d)"), uMsg - WM_AFXFIRST );
	} // if:  MFC message
	ATLTRACE( _T("\n") );

	bHandled = FALSE;
	return 1;

} //*** DBG_OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
/////////////////////////////////////////////////////////////////////////////
//++
//
//	DBG_OnNotify
//
//	Routine Description:
//		Debug handler for the WM_NOTIFY message.
//
//	Arguments:
//		uMsg			[IN] Message causing this function to be called (WM_NOTIFY).
//		wParam			[IN] Unused.
//		lParam			[IN] Pointer to notification message header (NMHDR).
//		bHandled		[IN OUT] TRUE = message has been handled (we set to FALSE).
//		pszClassName	[IN] Name of class calling this function.
//		pmapCtrlNames	[IN] Map of control IDs to control names.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT DBG_OnNotify(
	UINT			uMsg,
	WPARAM			wParam,
	LPARAM			lParam,
	BOOL &			bHandled,
	LPCTSTR			pszClassName,
	ID_MAP_ENTRY *	pmapCtrlNames
	)
{
	ATLASSERT( ::IsWindow( m_hWnd ) );
	ATLASSERT( pszClassName != NULL );

	NMHDR * pNMHDR = (NMHDR *) lParam;
	const ID_MAP_ENTRY * pmap;

	//
	// Display the control ID.
	//
	ATLTRACE( _T("%s::OnNotify() - idFrom = %d"), pszClassName, pNMHDR->idFrom );
	if ( pmapCtrlNames != NULL )
	{
		pmap = pmapCtrlNames;
		for ( ; pmap->pszName != NULL ; pmap++ )
		{
			if ( pNMHDR->idFrom == pmap->id )
			{
				ATLTRACE( _T(" (%s)"), pmap->pszName );
			} // if:  control ID found
		} // for:  each control in the map
	} // if:  control names array specified

	//
	// Display the notification code.
	//
	ATLTRACE( _T(" code = %08.8X"), pNMHDR->code );
	pmap = s_rgmapPropSheetNotifyMsgs;
	for ( ; pmap->pszName != NULL ; pmap++ )
	{
		if ( pNMHDR->code == pmap->id )
		{
			ATLTRACE( _T(" (%s)"), pmap->pszName );
			break;
		} // if:  code found
	} // for:  each code in the map
	ATLTRACE( _T("\n") );

	bHandled = FALSE;
	return 1;

} //*** DBG_OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
/////////////////////////////////////////////////////////////////////////////
//++
//
//	DBG_OnCommand
//
//	Routine Description:
//		Debug handler for the WM_COMMAND message.
//
//	Arguments:
//		uMsg			[IN] Message causing this function to be called (WM_COMMAND).
//		wParam			[IN] Notification code and control ID.
//		lParam			[IN] Window handle to the control.
//		bHandled		[IN OUT] TRUE = message has been handled (we set to FALSE).
//		pszClassName	[IN] Name of class calling this function.
//		pmapCtrlNames	[IN] Map of control IDs to control names.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT DBG_OnCommand(
	UINT			uMsg,
	WPARAM			wParam,
	LPARAM			lParam,
	BOOL &			bHandled,
	LPCTSTR			pszClassName,
	ID_MAP_ENTRY *	pmapCtrlNames
	)
{
	ATLASSERT( pszClassName != NULL );

	WORD wNotifyCode = HIWORD( wParam );
	WORD idCtrl = LOWORD ( wParam );
	HWND hwndCtrl = (HWND) lParam;
	const ID_MAP_ENTRY * pmap;

	//
	// Display the control ID.
	//
	ATLTRACE( _T("%s::OnCommand() - idCtrl = %d"), pszClassName, idCtrl );
	if ( pmapCtrlNames != NULL )
	{
		pmap = pmapCtrlNames;
		for ( ; pmap->pszName != NULL ; pmap++ )
		{
			if ( idCtrl == pmap->id )
			{
				ATLTRACE( _T(" (%s)"), pmap->pszName );
			} // if:  control ID found
		} // for:  each control in the map
	} // if:  control names array specified

	//
	// Get the window class.
	//
	TCHAR szWindowClass[256];
	::GetClassName( hwndCtrl, szWindowClass, (sizeof( szWindowClass ) / sizeof( TCHAR )) - 1 );
	ATLTRACE( _T(" (%s)"), szWindowClass );

	//
	// Display the notification code.
	//
	ATLTRACE( _T(" wNotifyCode = %04.4X"), wNotifyCode );
	if ( lstrcmp( szWindowClass, _T("Button") ) == 0 )
	{
		pmap = s_rgmapButtonMsgs;
	}
	else if ( lstrcmp( szWindowClass, _T("ComboBox") ) == 0 )
	{
		pmap = s_rgmapComboBoxMsgs;
	}
	else if ( lstrcmp( szWindowClass, _T("Edit") ) == 0 )
	{
		pmap = s_rgmapEditMsgs;
	}
	else if ( lstrcmp( szWindowClass, _T("ListBox")) == 0 )
	{
		pmap = s_rgmapListBoxMsgs;
	}
	else if ( lstrcmp(szWindowClass, _T("ScrollBar")) == 0 )
	{
		pmap = s_rgmapScrollBarMsgs;
	}
	else if ( lstrcmp(szWindowClass, _T("Static")) == 0 )
	{
		pmap = s_rgmapStaticMsgs;
	}
	else if ( lstrcmp(szWindowClass, WC_LISTVIEW) == 0 )
	{
		pmap = s_rgmapListViewMsgs;
	}
	else if ( lstrcmp(szWindowClass, WC_TREEVIEW) == 0 )
	{
		pmap = s_rgmapTreeViewMsgs;
	}
	else if ( lstrcmp(szWindowClass, WC_IPADDRESS) == 0 )
	{
		pmap = s_rgmapIPAddressMsgs;
	}
	else
	{
		pmap = NULL;
	}
	if ( pmap != NULL )
	{
		for ( ; pmap->pszName != NULL ; pmap++ )
		{
			if ( wNotifyCode == pmap->id )
			{
				ATLTRACE( _T(" (%s)"), pmap->pszName );
				break;
			} // if:  code found
		} // for:  each code in the map
	} // if:  known control

	ATLTRACE( _T("\n") );

	bHandled = FALSE;
	return 1;

} //*** DBG_OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlextdll.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlExtDll.h
//
//	Implementation File:
//		AtlExtDll.cpp
//
//	Description:
//		Definition of the Cluster Administrator extension classes.
//
//	Author:
//		David Potter (davidp)	May 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLEXTDLL_H_
#define __ATLEXTDLL_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters ni the browser information

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>			// for extension DLL definitions
#endif

#ifndef __cluadmexhostsvr_h__
#include "CluAdmExHostSvr.h"	// for CLSIDs
#endif

#ifndef __CLUADMEXDATAOBJ_H_
#include "CluAdmExDataObj.h"	// for CCluAdmExDataObject
#endif

//#ifndef _TRACETAG_H_
//#include "TraceTag.h"			// for CTraceTag, Trace
//#endif

#ifndef __ATLEXTMENU_H_
#include "AtlExtMenu.h"			// for CCluAdmExMenuItemList
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"	// for CBasePropertyPageImpl
#endif

#ifndef __ATLBASEWIZPAGE_H_
#include "AtlBaseWizPage.h"		// for CBaseWizardPageImpl
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExtensions;
class CCluAdmExDll;
class CCluAdmExPropPage;
class CCluAdmExWizPage;
class CCluAdmExWiz97Page;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;
class CBaseSheetWindow;
class CBasePropertySheetWindow;
class CWizardWindow;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define CAEXT_MENU_FIRST_ID		35000

typedef CComObject< CCluAdmExDll > CComCluAdmExDll;
typedef std::list< CComCluAdmExDll * > CCluAdmExDllList;
typedef std::list< CString > CStringList;

/////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
/////////////////////////////////////////////////////////////////////////////

//#if DBG
//extern CTraceTag g_tagExtDll;
//extern CTraceTag g_tagExtDllRef;
//#endif // DBG

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExtensions
//
//	Description:
//		Encapsulates access to a list of extension DLLs.
//
//	Inheritance:
//		CCluAdmExtensions
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExtensions
{
	friend class CCluAdmExDll;

public:
	//
	// Construction.
	//

	// Default constructor
	CCluAdmExtensions( void )
		: m_pco( NULL )
		, m_hfont( NULL )
		, m_hicon( NULL )

		, m_pdoData( NULL )
		, m_plextdll( NULL )
		, m_psht( NULL )
		, m_pmenu( NULL )
		, m_plMenuItems( NULL )

		, m_nFirstCommandID( (ULONG) -1 )
		, m_nNextCommandID( (ULONG) -1 )
		, m_nFirstMenuID( (ULONG) -1 )
		, m_nNextMenuID( (ULONG) -1 )
	{
	} //*** CCluAdmExtensions()

	// Destructor
	virtual ~CCluAdmExtensions( void )
	{
		UnloadExtensions();

	} //*** ~CCluAdmExtensions()

protected:
	// Initialize the list
	void Init(
			IN const CStringList &	rlstrExtensions,
			IN OUT CClusterObject *	pco,
			IN HFONT				hfont,
			IN HICON				hicon
			);

	// Unload all the extensions
	void UnloadExtensions( void );

// Attributes
private:
	const CStringList *	m_plstrExtensions;	// List of extensions.
	CClusterObject *	m_pco;				// Cluster item being administered.
	HFONT				m_hfont;			// Font for dialog text.
	HICON				m_hicon;			// Icon for upper left corner.

protected:
	//
	// Accessor methods.
	//

	const CStringList * PlstrExtensions( void ) const	{ return m_plstrExtensions; }
	CClusterObject *	Pco( void ) const				{ return m_pco; }
	HFONT				Hfont( void ) const				{ return m_hfont; }
	HICON				Hicon( void ) const				{ return m_hicon; }

// Operations
public:
	//
	// IWEExtendPropertySheet methods.
	//

	// Create extension property sheet pages
	void CreatePropertySheetPages(
			IN OUT CBasePropertySheetWindow *	psht,
			IN const CStringList &				rlstrExtensions,
			IN OUT CClusterObject *				pco,
			IN HFONT							hfont,
			IN HICON							hicon
			);

public:
	//
	// IWEExtendWizard methods.
	//

	// Create extension wizard pages
	void CreateWizardPages(
			IN OUT CWizardWindow *	psht,
			IN const CStringList &	rlstrExtensions,
			IN OUT CClusterObject *	pco,
			IN HFONT				hfont,
			IN HICON				hicon
			);

public:
	//
	// IWEExtendWizard97 methods.
	//

	// Create extension Wizard97 wizard pages
	void CreateWizard97Pages(
			IN OUT CWizardWindow *	psht,
			IN const CStringList &	rlstrExtensions,
			IN OUT CClusterObject *	pco,
			IN HFONT				hfont,
			IN HICON				hicon
			);

public:
	//
	// IWEExtendContextMenu methods.
	//

	// Add extension context menu items
	void AddContextMenuItems(
			IN OUT CMenu *				pmenu,
			IN const CStringList &		rlstrExtensions,
			IN OUT CClusterObject *		pco
			);

	// Execute an extension context menu item
	BOOL BExecuteContextMenuItem( IN ULONG nCommandID );

	// Get a command string to display on the status bar
	BOOL BGetCommandString( IN ULONG nCommandID, OUT CString & rstrMessage );

	// Set the GetResNetName function pointer
	void SetPfGetResNetName( PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext )
	{
		if ( Pdo() != NULL )
		{
			Pdo()->SetPfGetResNetName( pfGetResNetName, pvContext );
		} // if:  data object specified

	} //*** SetPfGetResNetName()

// Implementation
private:
	CComObject< CCluAdmExDataObject > *	m_pdoData;	// Data object for exchanging data.
	CCluAdmExDllList *			m_plextdll;			// List of extension DLLs.
	CBaseSheetWindow *			m_psht;				// Property sheet for IWEExtendPropertySheet.
	CMenu *						m_pmenu;			// Menu for IWEExtendContextMenu.
	CCluAdmExMenuItemList *		m_plMenuItems;

	ULONG						m_nFirstCommandID;
	ULONG						m_nNextCommandID;
	ULONG						m_nFirstMenuID;
	ULONG						m_nNextMenuID;

protected:
	CComObject< CCluAdmExDataObject > *	Pdo( void )				{ return m_pdoData; }
	CCluAdmExDllList *			Plextdll( void ) const			{ return m_plextdll; }
	CBaseSheetWindow *			Psht( void ) const				{ return m_psht; }
	CMenu *						Pmenu( void ) const				{ return m_pmenu; }
	CCluAdmExMenuItemList *		PlMenuItems( void ) const		{ return m_plMenuItems; }
	CCluAdmExMenuItem *			PemiFromCommandID( ULONG nCommandID ) const;
#if DBG
	CCluAdmExMenuItem *			PemiFromExtCommandID( ULONG nExtCommandID ) const;
#endif // DBG
	ULONG						NFirstCommandID( void ) const	{ return m_nFirstCommandID; }
	ULONG						NNextCommandID( void ) const	{ return m_nNextCommandID; }
	ULONG						NFirstMenuID( void ) const		{ return m_nFirstMenuID; }
	ULONG						NNextMenuID( void ) const		{ return m_nNextMenuID; }

	// Get the wizard page pointer from an HPROPSHEETPAGE
	CWizardPageWindow *			PwpPageFromHpage( IN HPROPSHEETPAGE hpage );

public:
//	void						OnUpdateCommand( CCmdUI * pCmdUI );
//	BOOL						OnCmdMsg( UINT nID, int nCode, void * pExtra, AFX_CMDHANDLERINFO * pHandlerInfo );

}; //*** class CCluAdmExtensions

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExDll
//
//	Description:
//		Encapsulates access to an extension DLL.
//
//	Inheritance:
//		CCluAdmExDll
//		CComObjectRootEx<>, CComCoClass<>, <interface classes>
//
//--
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CCluAdmExDll :
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CCluAdmExDll, &CLSID_CoCluAdmExHostSvr >,
	public ISupportErrorInfo,
	public IWCPropertySheetCallback,
	public IWCWizardCallback,
	public IWCWizard97Callback,
	public IWCContextMenuCallback
{
	friend class CCluAdmExtensions;

public:
	//
	// Object construction and destruction.
	//

	// Default constructor
	CCluAdmExDll( void )
		: m_piExtendPropSheet( NULL )
		, m_piExtendWizard( NULL )
		, m_piExtendWizard97( NULL )
		, m_piExtendContextMenu( NULL )
		, m_piInvokeCommand( NULL )
		, m_pext( NULL )
	{
	} //*** CCluAdmExDll()

	// Destructor
	virtual ~CCluAdmExDll( void )
	{
		UnloadExtension();

	} //*** ~CCluAdmExDll()

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CCluAdmExDll )
		COM_INTERFACE_ENTRY( IWCPropertySheetCallback )
		COM_INTERFACE_ENTRY( IWCWizardCallback )
		COM_INTERFACE_ENTRY( IWCWizard97Callback )
		COM_INTERFACE_ENTRY( IWCContextMenuCallback )
		COM_INTERFACE_ENTRY( ISupportErrorInfo )
	END_COM_MAP()

	DECLARE_NO_REGISTRY()

	DECLARE_NOT_AGGREGATABLE( CCluAdmExDll ) 

// Attributes
private:
	CString m_strCLSID;		// Name of extension DLL.

protected:
	const CString &		StrCLSID( void ) const	{ return m_strCLSID; }
	CClusterObject *	Pco( void ) const		{ return Pext()->Pco(); }

// Operations
public:

	void Init(
			IN const CString &			rstrExtension,
			IN OUT CCluAdmExtensions *	pext
			);

	IUnknown * LoadInterface( IN const REFIID riid );
	void UnloadExtension( void );

public:
	//
	// IWEExtendPropertySheet methods.
	//

	// Create extension property sheet pages
	void CreatePropertySheetPages( void );

public:
	//
	// IWEExtendWizard methods.
	//

	// Create extension wizard pages
	void CreateWizardPages( void );

public:
	//
	// IWEExtendWizard97 methods.
	//

	// Create extension wizard pages
	void CreateWizard97Pages( void );

public:
	//
	// IWEExtendContextMenu methods.
	//

	// Add extension context menu items
	void AddContextMenuItems( void );

public:
	//
	// ISupportsErrorInfo methods.
	//

	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

public:
	//
	// IWCPropertySheetCallback methods.
	//

	// Callback to add extension property sheet pages
	STDMETHOD( AddPropertySheetPage )(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);

public:
	//
	// IWCWizardCallback methods.
	//

	// Callback to add extension wizard pages
	STDMETHOD( AddWizardPage )(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);

public:
	//
	// IWCWizard97Callback methods.
	//

	// Callback to add extension wizard 97 pages
	STDMETHOD( AddWizard97Page )(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);

public:
	//
	// IWCWizardCallback and IWCWizard97Callback methods.
	//

	// Callback to enable the next button
	STDMETHOD( EnableNext )(
					IN LONG *		hpage,
					IN BOOL			bEnable
					);

public:
	//
	// IWCContextMenuCallback methods.
	//

	// Callback to add extension context menu items
	STDMETHOD( AddExtensionMenuItem )(
					IN BSTR		lpszName,
					IN BSTR		lpszStatusBarText,
					IN ULONG	nCommandID,
					IN ULONG	nSubmenuCommandID,
					IN ULONG	uFlags
					);

// Implementation
private:
	CCluAdmExtensions *			m_pext;
	CLSID						m_clsid;
	IWEExtendPropertySheet *	m_piExtendPropSheet;	// Pointer to an IWEExtendPropertySheet interface.
	IWEExtendWizard *			m_piExtendWizard;		// Pointer to an IWEExtendWizard interface.
	IWEExtendWizard97 *			m_piExtendWizard97;		// Pointer to an IWEExtendWizard97 interface.
	IWEExtendContextMenu *		m_piExtendContextMenu;	// Pointer to an IWEExtendContextMenu interface.
	IWEInvokeCommand *			m_piInvokeCommand;		// Pointer to an IWEInvokeCommand interface.

protected:
	CCluAdmExtensions *			Pext( void ) const					{ ATLASSERT( m_pext != NULL ); return m_pext; }
	const CLSID &				Rclsid( void ) const				{ return m_clsid; }
	IWEExtendPropertySheet *	PiExtendPropSheet( void ) const		{ return m_piExtendPropSheet; }
	IWEExtendWizard *			PiExtendWizard( void ) const		{ return m_piExtendWizard; }
	IWEExtendWizard97 *			PiExtendWizard97( void ) const		{ return m_piExtendWizard97; }
	IWEExtendContextMenu *		PiExtendContextMenu( void ) const	{ return m_piExtendContextMenu; }
	IWEInvokeCommand *			PiInvokeCommand( void ) const		{ return m_piInvokeCommand; }

	CComObject< CCluAdmExDataObject > *	Pdo( void ) const			{ return Pext()->Pdo(); }
	CBaseSheetWindow *			Psht( void ) const					{ return Pext()->Psht(); }
	CMenu *						Pmenu( void ) const					{ return Pext()->Pmenu(); }
	CCluAdmExMenuItemList *		PlMenuItems( void ) const			{ return Pext()->PlMenuItems(); }
	ULONG						NFirstCommandID( void ) const		{ return Pext()->NFirstCommandID(); }
	ULONG						NNextCommandID( void ) const		{ return Pext()->NNextCommandID(); }
	ULONG						NFirstMenuID( void ) const			{ return Pext()->NFirstMenuID(); }
	ULONG						NNextMenuID( void ) const			{ return Pext()->NNextMenuID(); }

	void ReleaseInterface(
			IN OUT IUnknown ** ppi
#if DBG
			, IN LPCTSTR szClassName
#endif
			)
	{
		ATLASSERT( ppi != NULL );
		if ( *ppi != NULL )
		{
#if DBG
			ULONG ulNewRefCount;

//			Trace( g_tagExtDllRef, _T("Releasing %s"), szClassName );
			ulNewRefCount =
#endif // DBG
			(*ppi)->Release();
			*ppi = NULL;
#if DBG
//			Trace( g_tagExtDllRef, _T("  Reference count = %d"), ulNewRefCount );
//			Trace( g_tagExtDllRef, _T("ReleaseInterface() - %s = %08.8x"), szClassName, *ppi );
#endif // DBG
		}  // if:  interface specified
	} //*** ReleaseInterface( IUnknown )

	void ReleaseInterface( IN OUT IWEExtendPropertySheet ** ppi )
	{
		ReleaseInterface(
			(IUnknown **) ppi
#if DBG
			, _T("IWEExtendPropertySheet")
#endif // DBG
			);
	} //*** ReleaseInterface( IWEExtendPropertySheet )

	void ReleaseInterface( IN OUT IWEExtendWizard ** ppi )
	{
		ReleaseInterface(
			(IUnknown **) ppi
#if DBG
			, _T("IWEExtendWizard")
#endif // DBG
			);
	} //*** ReleaseInterface( IWEExtendWizard )

	void ReleaseInterface( IN OUT IWEExtendWizard97 ** ppi )
	{
		ReleaseInterface(
			(IUnknown **) ppi
#if DBG
			, _T("IWEExtendWizard97")
#endif // DBG
			);
	} //*** ReleaseInterface( IWEExtendWizard97 )

	void ReleaseInterface( IN OUT IWEExtendContextMenu ** ppi )
	{
		ReleaseInterface(
			(IUnknown **) ppi
#if DBG
			, _T("IWEExtendContextMenu")
#endif // DBG
			);
	} //*** ReleaseInterface( IWEExtendContextMenu )

	void ReleaseInterface( IN OUT IWEInvokeCommand ** ppi )
	{
		ReleaseInterface(
			(IUnknown **) ppi
#if DBG
			, _T("IWEInvokeCommand")
#endif // DBG
			);
	} //*** ReleaseInterface( IWEInvokeCommand )

}; //*** class CCluAdmExDll

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExPropPage
//
//	Description:
//		Encapsulates an extension property page.
//
//	Inheritance:
//		CCluAdmExPropPage
//		CExtensionPropertyPageImpl< CCluAdmExPropPage >
//		CBasePropertyPageImpl< CCluAdmExPropPage, CExtensionPropertyPageWindow >
//		CBasePageImpl< CCluAdmExPropPage, CExtensionPropertyPageWindow >
//		CPropertyPageImpl< CCluAdmExPropPage, CExtensionPropertyPageWindow >
//		CExtensionPropertyPageWindow
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExPropPage : public CExtensionPropertyPageImpl< CCluAdmExPropPage >
{
public:
	//
	// Construction.
	//

	// Standard constructor
	CCluAdmExPropPage(
		HPROPSHEETPAGE hpage
		)
	{
		ATLASSERT( hpage != NULL );
		m_hpage = hpage;

	} //*** CCluAdmExPropPage()

	enum { IDD = 0 };
	DECLARE_CLASS_NAME()

	// Return the help ID map
	static const DWORD * PidHelpMap( void )
	{
		static const DWORD s_aHelpIDs[] = { 0, 0 };
		return s_aHelpIDs;

	} //*** PidHelpMap()

	// Create the page
	DWORD ScCreatePage( void )
	{
		//
		// This method is required by CDynamicPropertyPageWindow.
		//
		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CCluAdmExPropPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExWizPage
//
//	Description:
//		Encapsulates an extension wizard page.
//
//	Inheritance:
//		CCluAdmExWizPage
//		CExtensionWizardPageImpl< CCluAdmExWizPage >
//		CWizardPageImpl< CCluAdmExWizPage, CExtensionWizardWindow >
//		CBasePageImpl< CCluAdmExWizPage, CExtensionWizardWindow >
//		CPropertyPageImpl< CCluAdmExWizPage, CExtensionWizardWindow >
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExWizPage : public CExtensionWizardPageImpl< CCluAdmExWizPage >
{
public:
	//
	// Construction.
	//

	// Standard constructor
	CCluAdmExWizPage(
		HPROPSHEETPAGE hpage
		)
	{
		ATLASSERT( hpage != NULL );
		m_hpage = hpage;

	} //*** CCluAdmExWizPage()

	WIZARDPAGE_HEADERTITLEID( 0 )
	WIZARDPAGE_HEADERSUBTITLEID( 0 )

	enum { IDD = 0 };
	DECLARE_CLASS_NAME()

	// Return the help ID map
	static const DWORD * PidHelpMap( void )
	{
		static const DWORD s_aHelpIDs[] = { 0, 0 };
		return s_aHelpIDs;

	} //*** PidHelpMap()

	// Create the page
	DWORD ScCreatePage( void )
	{
		//
		// This method is required by CDynamicWizardPageWindow.
		//
		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CCluAdmExWizPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExWiz97Page
//
//	Description:
//		Encapsulates an extension Wizard 97 page.
//
//	Inheritance:
//		CCluAdmExWiz97Page
//		CExtensionWizard97PageImpl< CCluAdmExWiz97Page >
//		CWizardPageImpl< CCluAdmExWiz97Page, CExtensionWizard97Window >
//		CBasePageImpl< CCluAdmExWiz97Page, CExtensionWizard97Window >
//		CPropertyPageImpl< CCluAdmExWiz97Page, CExtensionWizard97Window >
//		CExtensionWizard97PageWindow
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExWiz97Page : public CExtensionWizard97PageImpl< CCluAdmExWiz97Page >
{
public:
	//
	// Construction.
	//

	// Standard constructor
	CCluAdmExWiz97Page(
		HPROPSHEETPAGE hpage
		)
	{
		ATLASSERT( hpage != NULL );
		m_hpage = hpage;

	} //*** CCluAdmExWiz97Page()

	WIZARDPAGE_HEADERTITLEID( 0 )
	WIZARDPAGE_HEADERSUBTITLEID( 0 )

	enum { IDD = 0 };
	DECLARE_CLASS_NAME()

	// Return the help ID map
	static const DWORD * PidHelpMap( void )
	{
		static const DWORD s_aHelpIDs[] = { 0, 0 };
		return s_aHelpIDs;

	} //*** PidHelpMap()

	// Create the page
	DWORD ScCreatePage( void )
	{
		//
		// This method is required by CDynamicWizardPageWindow.
		//
		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CCluAdmExWiz97Page

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CCluAdmExPropPage )
DEFINE_CLASS_NAME( CCluAdmExWizPage )
DEFINE_CLASS_NAME( CCluAdmExWiz97Page )

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLEXTDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlextmenu.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlExtMenu.h
//
//	Implementation File:
//		AtlExtMenu.cpp
//
//	Description:
//		Definition of the Cluster Administrator extension menu classes.
//
//	Author:
//		David Potter (davidp)	August 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLEXTMENU_H_
#define __ATLEXTMENU_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters ni the browser information

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExMenuItem;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

interface IWEInvokeCommand;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef std::list< CCluAdmExMenuItem * > CCluAdmExMenuItemList;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExMenuItem
//
//	Description:
//		Represents one extension DLL's menu item.
//
//	Inheritance:
//		CCluAdmExMenuItem
//
//--
/////////////////////////////////////////////////////////////////////////////
class CCluAdmExMenuItem
{
public:
	//
	// Constructors.
	//

	// Default constructor
	CCluAdmExMenuItem( void )
	{
		CommonConstruct();

	} //*** CCluAdmExMenuItem()

	// Fully specified constructor
	CCluAdmExMenuItem(
				IN LPCTSTR				lpszName,
				IN LPCTSTR				lpszStatusBarText,
				IN ULONG				nExtCommandID,
				IN ULONG				nCommandID,
				IN ULONG				nMenuItemID,
				IN ULONG				uFlags,
				IN BOOL					bMakeDefault,
				IN IWEInvokeCommand *	piCommand
				)
	{
		ATLASSERT( piCommand != NULL );

		CommonConstruct();

		m_strName = lpszName;
		m_strStatusBarText = lpszStatusBarText;
		m_nExtCommandID = nExtCommandID;
		m_nCommandID = nCommandID;
		m_nMenuItemID = nMenuItemID;
		m_uFlags = uFlags;
		m_bDefault = bMakeDefault;
		m_piCommand = piCommand;

		// will throw its own exception if it fails
		if ( uFlags & MF_POPUP )
		{
			m_plSubMenuItems = new CCluAdmExMenuItemList;
		} // if:  popup menu

#if DBG
		AssertValid();
#endif // DBG

	} //*** CCluAdmExMenuItem()

	virtual ~CCluAdmExMenuItem( void )
	{
		delete m_plSubMenuItems;

		// Nuke data so it can't be used again
		CommonConstruct();

	} //*** ~CCluAdmExMenuItem()

protected:
	void CommonConstruct( void )
	{
		m_strName.Empty();
		m_strStatusBarText.Empty();
		m_nExtCommandID = (ULONG) -1;
		m_nCommandID = (ULONG) -1;
		m_nMenuItemID = (ULONG) -1;
		m_uFlags = (ULONG) -1;
		m_bDefault = FALSE;
		m_piCommand = NULL;

		m_plSubMenuItems = NULL;
		m_hmenuPopup = NULL;

	} //*** CommonConstruct()

protected:
	//
	// Attributes.
	//

	CString				m_strName;
	CString				m_strStatusBarText;
	ULONG				m_nExtCommandID;
	ULONG				m_nCommandID;
	ULONG				m_nMenuItemID;
	ULONG				m_uFlags;
	BOOL				m_bDefault;
	IWEInvokeCommand *	m_piCommand;

public:
	//
	// Accessor methods.
	//

	const CString &		StrName( void ) const			{ return m_strName; }
	const CString &		StrStatusBarText( void ) const	{ return m_strStatusBarText; }
	ULONG				NExtCommandID( void ) const		{ return m_nExtCommandID; }
	ULONG				NCommandID( void ) const		{ return m_nCommandID; }
	ULONG				NMenuItemID( void ) const		{ return m_nMenuItemID; }
	ULONG				UFlags( void ) const			{ return m_uFlags; }
	BOOL				BDefault( void ) const			{ return m_bDefault; }
	IWEInvokeCommand *	PiCommand( void )				{ return m_piCommand; }

// Operations
public:
	void SetPopupMenuHandle( IN HMENU hmenu ) { m_hmenuPopup = hmenu; }

// Implementation
protected:
	HMENU					m_hmenuPopup;
	CCluAdmExMenuItemList *	m_plSubMenuItems;

public:
	HMENU					HmenuPopup( void ) const		{ return m_hmenuPopup; }
	CCluAdmExMenuItemList *	PlSubMenuItems( void ) const	{ return m_plSubMenuItems; }

protected:
#if DBG
	void AssertValid( void )
	{
		if (   (m_nExtCommandID == -1)
			|| (m_nCommandID == -1)
			|| (m_nMenuItemID == -1)
			|| (m_uFlags == -1)
			|| (((m_uFlags & MF_POPUP) == 0) && (m_plSubMenuItems != NULL))
			|| (((m_uFlags & MF_POPUP) != 0) && (m_plSubMenuItems == NULL))
			)
		{
			ATLASSERT( FALSE );
		}

	}  //*** AssertValid()
#endif // DBG

}; //*** class CCluAdmExMenuItem

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLEXTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atldbgwin.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlDbgWin.cpp
//
//	Description:
//		Definitions for debugging windowing classes.
//
//	Author:
//		David Potter (davidp)	February 10, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#define __ATLDBGWIN_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if DBG
struct ID_MAP_ENTRY
{
	UINT	id;			// control ID
	LPCTSTR	pszName;	// control name

}; //*** struct ID_MAP_ENTRY
#endif // DBG

#if DBG && ( defined( _DBG_MSG_NOTIFY ) || defined( _DBG_MSG_COMMAND ) || defined( _DBG_MSG ) )

// Define the class name for use without a control name map.
#define DECLARE_CLASS_NAME() static LPCTSTR s_pszClassName;

#define DEFINE_CLASS_NAME( T ) \
_declspec( selectany ) LPCTSTR T::s_pszClassName = _T( #T );

// Declaration of a control name map.
#define DECLARE_CTRL_NAME_MAP() \
DECLARE_CLASS_NAME() \
static const ID_MAP_ENTRY s_rgmapCtrlNames[];

// Beginning of a control name map.
#define BEGIN_CTRL_NAME_MAP( T ) \
DEFINE_CLASS_NAME( T ) \
_declspec( selectany ) const ID_MAP_ENTRY T::s_rgmapCtrlNames[] = {

// Entry in a control name map.
#define DEFINE_CTRL_NAME_MAP_ENTRY( id ) { id, _T( #id ) },

// End of a control name map.
#define END_CTRL_NAME_MAP() { 0, NULL } };

#define DECLARE_ID_STRING( _id ) { _id, _T(#_id) },
#define DECLARE_ID_STRING_2( _id1, _id2 ) { _id1, _T(#_id2) },
#define DECLARE_ID_STRING_EX( _id, _t ) { _id, _T(#_id) _t },

#else // DBG && (defined( _DBG_MSG_NOTIFY ) || defined( _DBG_MSG_COMMAND ))

#define DECLARE_CLASS_NAME()
#define DEFINE_CLASS_NAME( T )
#define DECLARE_CTRL_NAME_MAP()
#define BEGIN_CTRL_NAME_MAP( T )
#define DEFINE_CTRL_NAME_MAP_ENTRY( id )
#define END_CTRL_NAME_MAP()

#endif // DBG && (defined( _DBG_MSG_NOTIFY ) || defined( _DBG_MSG_COMMAND ) || defined( _DBG_MSG ))

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
extern const ID_MAP_ENTRY s_rgmapWindowMsgs[];
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_COMMAND )
extern const ID_MAP_ENTRY s_rgmapButtonMsgs[];
extern const ID_MAP_ENTRY s_rgmapComboBoxMsgs[];
extern const ID_MAP_ENTRY s_rgmapEditMsgs[];
extern const ID_MAP_ENTRY s_rgmapListBoxMsgs[];
extern const ID_MAP_ENTRY s_rgmapScrollBarMsgs[];
extern const ID_MAP_ENTRY s_rgmapStaticMsgs[];
extern const ID_MAP_ENTRY s_rgmapListViewMsgs[];
extern const ID_MAP_ENTRY s_rgmapTreeViewMsgs[];
extern const ID_MAP_ENTRY s_rgmapIPAddressMsgs[];
#endif // DBG && defined( _DBG_MSG_COMMAND )

#if DBG && defined( _DBG_MSG_NOTIFY )
extern const ID_MAP_ENTRY s_rgmapPropSheetNotifyMsgs[];
#endif // DBG && defined( _DBG_MSG_NOTIFY )

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
// Debug handler for any message
LRESULT DBG_OnMsg(
	UINT	uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL &	bHandled,
	LPCTSTR	pszClassName
	);
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
// Debug handler for the WM_NOTIFY message
LRESULT DBG_OnNotify(
	UINT			uMsg,
	WPARAM			wParam,
	LPARAM			lParam,
	BOOL &			bHandled,
	LPCTSTR			pszClassName,
	ID_MAP_ENTRY *	pmapCtrlNames
	);
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
// Debug handler for the WM_COMMAND message
LRESULT DBG_OnCommand(
	UINT			uMsg,
	WPARAM			wParam,
	LPARAM			lParam,
	BOOL &			bHandled,
	LPCTSTR			pszClassName,
	ID_MAP_ENTRY *	pmapCtrlNames
	);
#endif // DBG && defined( _DBG_MSG_COMMAND )

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLDBGWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlextdll.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AtlExtDll.cpp
//
//  Abstract:
//      Implementation of the Cluster Administrator extension classes.
//
//  Author:
//      David Potter (davidp)   May 31, 1996
//
//  Revision History:
//
//  Notes:
//      This file is intended to be included in a stub file which includes
//      the ATL header files and defines _Module.  This allos _Module to be
//      defined as an instance of some application-specific class.
//
/////////////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <CluAdmEx.h>
#include "CluAdmExHostSvr.h"
#include "AtlExtDll.h"
#include "AdmCommonRes.h"
#include "AtlExtMenu.h"
//#include "TraceTag.h"
#include "ExcOper.h"
#include "ClusObj.h"
#include "AtlBaseSheet.h"
#include "AtlBasePropSheet.h"
#include "AtlBaseWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#if DBG
//CTraceTag g_tagExtDll(_T("UI"), _T("EXTENSION DLL"), 0);
//CTraceTag g_tagExtDllRef(_T("UI"), _T("EXTENSION DLL References"), 0);
#endif // DBG

/////////////////////////////////////////////////////////////////////////////
// class CCluAdmExtensions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::Init
//
//  Routine Description:
//      Common initializer for all interfaces.
//
//  Arguments:
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::Init(
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ATLASSERT( rlstrExtensions.size() > 0 );
    ATLASSERT( pco != NULL );

    CWaitCursor wc;

    UnloadExtensions();

    //
    // Save parameters.
    //
    m_plstrExtensions = &rlstrExtensions;
    m_pco = pco;
    m_hfont = hfont;
    m_hicon = hicon;

    //
    // Allocate a new Data Object.
    //
    m_pdoData = new CComObject< CCluAdmExDataObject >;
    if ( m_pdoData == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    m_pdoData->AddRef();

    // Construct the Data Object.
    Pdo()->Init( pco, GetUserDefaultLCID(), hfont, hicon );

    // Allocate the extension list.
    m_plextdll = new CCluAdmExDllList;
    if ( m_plextdll == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    ATLASSERT( Plextdll() != NULL );

    //
    // Loop through the extensions and load each one.
    //
    {
        CComCluAdmExDll *           pextdll = NULL;
        CStringList::iterator       itCurrent = rlstrExtensions.begin();
        CStringList::iterator       itLast = rlstrExtensions.end();
        CCluAdmExDllList::iterator  itDll;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            //
            // Allocate an extension DLL object and add it to the list.
            //
            pextdll = new CComCluAdmExDll;
            if ( pextdll == NULL )
            {
                goto MemoryError;
            } // if: error allocating memory
            pextdll->AddRef();
            itDll = Plextdll()->insert( Plextdll()->end(), pextdll );
            try
            {
                pextdll->Init( *itCurrent, this );
            } // try
            catch ( CException * pe )
            {
                pe->ReportError();
                pe->Delete();

                ATLASSERT( itDll != Plextdll()->end() );
                Plextdll()->erase( itDll );
                delete pextdll;
            } // catch:  CException
        } // while:  more items in the list
    } // Loop through the extensions and load each one

Cleanup:
    return;

MemoryError:
    CNTException nte(
                    E_OUTOFMEMORY,
                    ADMC_IDS_INIT_EXT_PAGES_ERROR,
                    NULL,   // pszOperArg1
                    NULL,   // pszOperArg2
                    FALSE   // bAutoDelete
                    );
    nte.ReportError();
    goto Cleanup;

} //*** CCluAdmExtensions::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::UnloadExtensions
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::UnloadExtensions( void )
{
    //
    // Delete all the extension DLL objects.
    //
    if ( Plextdll() != NULL )
    {
        CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
        CCluAdmExDllList::iterator  itLast = Plextdll()->end();
        CComCluAdmExDll *           pextdll;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pextdll = *itCurrent;
            pextdll->AddRef(); // See comment below.
            pextdll->UnloadExtension();
            if ( pextdll->m_dwRef != 2 )
            {
                Trace( g_tagError, _T("CCluAdmExtensions::UnloadExtensions() - Extension DLL has ref count = %d"), pextdll->m_dwRef );
            } // if:  not last reference

            // We added a reference above.  Combined with the reference that
            // was added when the object was created, we typically will need
            // to release two references.  However, due to bogus code
            // generated by earlier versions of the custom AppWizard where the
            // extension was releasing the interface but not zeroing out its
            // pointer in the error case, we may not need to release the
            // second reference.
            if ( pextdll->Release() != 0 )
            {
                pextdll->Release();
            } // if: more references to release
        } // while:  more items in the list
        delete m_plextdll;
        m_plextdll = NULL;
    } // if:  there is a list of extensions

    if ( m_pdoData != NULL )
    {
        if ( m_pdoData->m_dwRef != 1 )
        {
            Trace( g_tagError, _T("CCluAdmExtensions::UnloadExtensions() - Data Object has ref count = %d"), m_pdoData->m_dwRef );
        } // if:  not last reference
        m_pdoData->Release();
        m_pdoData = NULL;
    } // if:  data object allocated

    m_pco = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    //
    // Delete all menu items.
    //
    if ( PlMenuItems() != NULL )
    {
        CCluAdmExMenuItemList::iterator itCurrent = PlMenuItems()->begin();
        CCluAdmExMenuItemList::iterator itLast = PlMenuItems()->end();
        CCluAdmExMenuItem *             pemi;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pemi = *itCurrent;
            delete pemi;
        } // while:  more items in the list
        delete m_plMenuItems;
        m_plMenuItems = NULL;
    } // if:  there is a list of menu items

} //*** CCluAdmExtensions::UnloadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::PwpPageFromHpage
//
//  Routine Description:
//      Get the wizard page pointer from an HPROPSHEETPAGE.
//
//  Arguments:
//      hpage   [IN] Page handle.
//
//  Return Value:
//      pwp     Pointer to wizard page object.
//      NULL    Page not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardPageWindow * CCluAdmExtensions::PwpPageFromHpage( IN HPROPSHEETPAGE hpage )
{
    ATLASSERT( hpage != NULL );

    //
    // Get a pointer to the wizard object so we can traverse the page list.
    //
    CWizardWindow * pwiz = dynamic_cast< CWizardWindow * >( Psht() );
    ATLASSERT( pwiz != NULL );

    //
    // Loop through each page looking for an extension page whose
    // page handle matches the one specified.
    //
    CWizardPageList::iterator itCurrent = pwiz->PlwpPages()->begin();
    CWizardPageList::iterator itLast = pwiz->PlwpPages()->end();
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        CCluAdmExWizPage * pewp = dynamic_cast< CCluAdmExWizPage * >( *itCurrent );
        if ( pewp != NULL )
        {
            if ( pewp->Hpage() == hpage )
            {
                return pewp;
            } // if:  found the matching page
        } // if:  found an extension page
    } // for:  each page in the list

    //
    // Look at the alternate wizard if there is one.
    //
    pwiz = pwiz->PwizAlternate();
    if ( pwiz != NULL )
    {
        itCurrent = pwiz->PlwpPages()->begin();
        itLast = pwiz->PlwpPages()->end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CCluAdmExWizPage * pewp = dynamic_cast< CCluAdmExWizPage * >( *itCurrent );
            if ( pewp != NULL )
            {
                if ( pewp->Hpage() == hpage )
                {
                    return pewp;
                } // if:  found the matching page
            } // if:  found an extension page
        } // for:  each page in the list
    } // if:  alternate wizard exists

    return NULL;

} //*** CCluAdmExtensions::PwpPageFromHpage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::CreatePropertySheetPages(
    IN OUT CBasePropertySheetWindow *   psht,
    IN const CStringList &              rlstrExtensions,
    IN OUT CClusterObject *             pco,
    IN HFONT                            hfont,
    IN HICON                            hicon
    )
{
    ATLASSERT( psht != NULL );
    ATLASSERT( pco != NULL );

    m_psht = psht;

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, hfont, hicon );
    ATLASSERT( Plextdll() != NULL );

    //
    // Let each extension create property pages.
    //
    CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
    CCluAdmExDllList::iterator  itLast = Plextdll()->end();
    CComCluAdmExDll *           pextdll;
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pextdll = *itCurrent;
        try
        {
            pextdll->CreatePropertySheetPages();
        } // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // while:  more items in the list

} //*** CCluAdmExtensions::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::CreateWizardPages(
    IN OUT CWizardWindow *  psht,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ATLASSERT( psht != NULL );
    ATLASSERT( pco != NULL );

    m_psht = psht;

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, hfont, hicon );
    ATLASSERT( Plextdll() != NULL );

    //
    // Let each extension create wizard pages.
    //
    CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
    CCluAdmExDllList::iterator  itLast = Plextdll()->end();
    CComCluAdmExDll *           pextdll;
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pextdll = *itCurrent;
        try
        {
            pextdll->CreateWizardPages();
        } // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // while:  more items in the list

} //*** CCluAdmExtensions::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::CreateWizard97Pages
//
//  Routine Description:
//      Add pages to a Wizard 97 wizard.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::CreateWizard97Pages(
    IN OUT CWizardWindow *  psht,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ATLASSERT( psht != NULL );
    ATLASSERT( pco != NULL );

    m_psht = psht;

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, hfont, hicon );
    ATLASSERT( Plextdll() != NULL );

    //
    // Let each extension create wizard pages.
    //
    CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
    CCluAdmExDllList::iterator  itLast = Plextdll()->end();
    CComCluAdmExDll *           pextdll;
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pextdll = *itCurrent;
        try
        {
            pextdll->CreateWizard97Pages();
        } // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // while:  more items in the list

} //*** CCluAdmExtensions::CreateWizard97Pages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::AddContextMenuItems
//
//  Routine Description:
//      Query the extension DLL for new menu items to be added to the context
//      menu.
//
//  Arguments:
//      pmenu           [IN OUT] Menu to which items are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddContextMenuItems() or
//          CExtMenuItemList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::AddContextMenuItems(
    IN OUT CMenu *          pmenu,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco
    )
{
    ATLASSERT( m_pmenu == NULL );
    ATLASSERT( pmenu != NULL );

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, NULL, NULL );
    ATLASSERT( Plextdll() != NULL );

    m_pmenu = pmenu;
    m_nFirstCommandID = CAEXT_MENU_FIRST_ID;
    m_nNextCommandID = m_nFirstCommandID;
    m_nFirstMenuID = 0;
    m_nNextMenuID = m_nFirstMenuID;

    //
    // Create the list of menu items.
    //
    ATLASSERT( m_plMenuItems == NULL );
    m_plMenuItems = new CCluAdmExMenuItemList;
    if ( m_plMenuItems == NULL )
    {
        CNTException nte(
                        E_OUTOFMEMORY,
                        ADMC_IDS_INIT_EXT_PAGES_ERROR,
                        NULL,   // pszOperArg1
                        NULL,   // pszOperArg2
                        FALSE   // bAutoDelete
                        );
        nte.ReportError();
    } // if: error allocating memory
    else
    {
        CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
        CCluAdmExDllList::iterator  itLast = Plextdll()->end();
        CComCluAdmExDll *           pextdll;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pextdll = *itCurrent;
            try
            {
                pextdll->AddContextMenuItems();
            } // try
            catch ( CException * pe )
            {
                pe->ReportError();
                pe->Delete();
            } // catch:  CException
        } // while:  more items in the list
    } // else: memory allocated successfully

} //*** CCluAdmExtensions::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::BExecuteContextMenuItem
//
//  Routine Description:
//      Execute a command associated with a menu item added to a context menu
//      by the extension DLL.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item chosen by the user.
//
//  Return Value:
//      TRUE            Context menu item was executed.
//      FALSE           Context menu item was not executed.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExceptionDll::BExecuteContextMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluAdmExtensions::BExecuteContextMenuItem( IN ULONG nCommandID )
{
    BOOL                bHandled    = FALSE;
    HRESULT             hr;
    CCluAdmExMenuItem * pemi;

    //
    // Find the item in our list.
    //
    pemi = PemiFromCommandID( nCommandID );
    if ( pemi != NULL )
    {
        ATLASSERT( pemi->PiCommand() != NULL );
        Pdo()->AddRef();
        hr = pemi->PiCommand()->InvokeCommand( pemi->NExtCommandID(), Pdo()->GetUnknown() );
        if ( hr == NOERROR )
        {
            bHandled = TRUE;
        } // if:  no error occurred
    } // if:  found an item for the command ID

    return bHandled;

} //*** CCluAdmExtensions::BExecuteContextMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::BGetCommandString
//
//  Routine Description:
//      Get a command string from a menu ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//      rstrMessage     [OUT] String in which to return the message.
//
//  Return Value:
//      TRUE            String is being returned.
//      FALSE           No string is being returned.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::BGetCommandString().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluAdmExtensions::BGetCommandString(
    IN ULONG        nCommandID,
    OUT CString &   rstrMessage
    )
{
    BOOL                bHandled    = FALSE;
    CCluAdmExMenuItem * pemi;

    //
    // Find the item in our list.
    //
    pemi = PemiFromCommandID( nCommandID );
    if ( pemi != NULL )
    {
        rstrMessage = pemi->StrStatusBarText();
        bHandled = TRUE;
    } // if:  found an item for the command ID

    return bHandled;

} //*** CCluAdmExtensions::BGetCommandString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::OnUpdateCommand
//
//  Routine Description:
//      Determines whether extension DLL menu items should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::BOnUpdateCommand().
//
//--
/////////////////////////////////////////////////////////////////////////////
#if 0
void CCluAdmExtensions::OnUpdateCommand( CCmdUI * pCmdUI )
{
    CCluAdmExMenuItem * pemi;

    ATLASSERT( Plextdll() != NULL );

    //
    // Find the item in our list.
    //
//  Trace( g_tagExtDll, _T("OnUpdateCommand() - ID = %d"), pCmdUI->m_nID );
    pemi = PemiFromCommandID( pCmdUI->m_nID );
    if ( pemi != NULL )
    {
//      Trace( g_tagExtDll, _T("OnUpdateCommand() - Found a match with '%s' ExtID = %d"), pemi->StrName(), pemi->NExtCommandID() );
        pCmdUI->Enable();
    } // if:  found an item for the command ID

} //*** CCluAdmExtensions::OnUpdateCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
#if 0
BOOL CCluAdmExtensions::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    return BExecuteContextMenuItem( nID );

} //*** CCluAdmExtensions::OnCmdMsg()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::PemiFromCommandID
//
//  Routine Description:
//      Find the menu item for the specified command ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluAdmExMenuItem * CCluAdmExtensions::PemiFromCommandID( IN ULONG nCommandID ) const
{
    CCluAdmExMenuItem * pemiReturn = NULL;

    if ( PlMenuItems() != NULL )
    {
        CCluAdmExMenuItemList::iterator itCurrent = PlMenuItems()->begin();
        CCluAdmExMenuItemList::iterator itLast = PlMenuItems()->end();
        CCluAdmExMenuItem *             pemi;
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pemi = *itCurrent;
            if ( pemi->NCommandID() == nCommandID )
            {
                pemiReturn = pemi;
                break;
            } // if:  match was found
        } // while:  more items in the list
    } // if:  item list exists

    return pemiReturn;

} //*** CCluAdmExtensions::PemiFromCommandID()

#if DBG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::PemiFromExtCommandID
//
//  Routine Description:
//      Find the menu item for the specified extension command ID.
//
//  Arguments:
//      nExtCommandID   [IN] Extension command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluAdmExMenuItem * CCluAdmExtensions::PemiFromExtCommandID( IN ULONG nExtCommandID ) const
{
    CCluAdmExMenuItem * pemiReturn = NULL;

    if ( PlMenuItems() != NULL )
    {
        CCluAdmExMenuItemList::iterator itCurrent = PlMenuItems()->begin();
        CCluAdmExMenuItemList::iterator itLast = PlMenuItems()->end();
        CCluAdmExMenuItem *             pemi;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pemi = *itCurrent;
            if ( pemi->NExtCommandID() == nExtCommandID )
            {
                pemiReturn = pemi;
                break;
            } // if:  match was found
        } // while:  more items in the list
    } // if:  item list exists

    return pemiReturn;

} //*** CCluAdmExtensions::PemiFromExtCommandID()
#endif // DBG


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CComObject< CCluAdmExDll >
/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP( AtlExtDll_ObjectMap )
    OBJECT_ENTRY( CLSID_CoCluAdmExHostSvr, CComCluAdmExDll )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::Init
//
//  Routine Description:
//      Initialize this class in preparation for accessing the extension.
//
//  Arguments:
//      rstrCLSID       [IN] CLSID of the extension in string form.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    0 (error converting CLSID from string)
//      Any exceptions thrown by CString::operater=().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::Init(
    IN const CString &          rstrCLSID,
    IN OUT CCluAdmExtensions *  pext
    )
{
    ATLASSERT( pext != NULL );

    HRESULT     hr;
    CWaitCursor wc;

    //
    // Save parameters.
    //
    ATLASSERT( StrCLSID().IsEmpty() || (StrCLSID() == rstrCLSID) );
    m_strCLSID = rstrCLSID;
    m_pext = pext;

    //
    // Convert the CLSID string to a CLSID.
    //
    hr = ::CLSIDFromString( (LPWSTR) (LPCTSTR) rstrCLSID, &m_clsid );
    if ( hr != S_OK )
    {
        ThrowStaticException( hr, ADMC_IDS_CLSIDFROMSTRING_ERROR, rstrCLSID );
    } // if:  error converting CLSID

} //*** CCluAdmExDll::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::LoadInterface
//
//  Routine Description:
//      Load an extension DLL.
//
//  Arguments:
//      riid            [IN] Interface ID.
//
//  Return Value:
//      piUnk           IUnknown interface pointer for interface.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_CREATE_INSTANCE_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
IUnknown * CCluAdmExDll::LoadInterface( IN const REFIID riid )
{
    HRESULT     hr;
    IUnknown *  piUnk;
    CWaitCursor wc;

    //
    // Load the inproc server and get the specified interface pointer.
    //
//  Trace( g_tagExtDllRef, _T("LoadInterface() - Getting interface pointer") );
    hr = ::CoCreateInstance(
                Rclsid(),
                NULL,
                CLSCTX_INPROC_SERVER,
                riid,
                (LPVOID *) &piUnk
                );
    if (   (hr != S_OK)
        && (hr != REGDB_E_CLASSNOTREG)
        && (hr != E_NOINTERFACE)
        )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_CREATE_INSTANCE_ERROR, StrCLSID() );
    } // if:  error creating the object instance

    return piUnk;

} //*** CCluAdmExDll::LoadInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::UnloadExtension
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::UnloadExtension( void )
{
    //
    // Release the interface pointers in the opposite order in which they
    //
    // were obtained.
    ReleaseInterface( &m_piExtendPropSheet );
    ReleaseInterface( &m_piExtendWizard );
    ReleaseInterface( &m_piExtendWizard97 );
    ReleaseInterface( &m_piExtendContextMenu );
    ReleaseInterface( &m_piInvokeCommand );

    m_strCLSID.Empty();

} //*** CCluAdmExDll::UnloadExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::CreatePropertySheetPages( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Psht() != NULL );
    ATLASSERT( m_piExtendPropSheet == NULL );

    HRESULT     hr;

    //
    // Load the interface.
    //
    m_piExtendPropSheet = reinterpret_cast< interface IWEExtendPropertySheet * >( LoadInterface( IID_IWEExtendPropertySheet ) );
    if ( m_piExtendPropSheet == NULL )
    {
        return;
    } // if:  error loading the interface
    ATLASSERT( m_piExtendPropSheet != NULL );

    //
    // Add pages from the extension.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        hr = PiExtendPropSheet()->CreatePropertySheetPages( Pdo()->GetUnknown(), this );
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( (hr != NOERROR) && (hr != E_NOTIMPL) )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_ADD_PAGES_ERROR, StrCLSID() );
    } // if:  error creating property sheet pages

} //*** CCluAdmExDll::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::CreateWizardPages( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Psht() != NULL );
    ATLASSERT( m_piExtendWizard == NULL );
    ATLASSERT( m_piExtendWizard97 == NULL );

    HRESULT     hr;

    //
    // Load the interface.  If it can't be loaded, try to load the
    // Wizard97 interface so that Wizard97 pages can be added.
    //
    m_piExtendWizard = reinterpret_cast< interface IWEExtendWizard * >( LoadInterface( IID_IWEExtendWizard ) );
    if ( m_piExtendWizard == NULL )
    {
        //
        // Try to load the Wizard97 interface.
        //
        m_piExtendWizard97 = reinterpret_cast< interface IWEExtendWizard97 * >( LoadInterface( IID_IWEExtendWizard97 ) );
        if ( m_piExtendWizard97 == NULL )
        {
            return;
        } // if:  error loading the non-Wizard97 interface
    } // if:  error loading the interface
    ATLASSERT( (m_piExtendWizard != NULL) || (m_piExtendWizard97 != NULL) );

    //
    // Add pages from the extension.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        if ( PiExtendWizard() != NULL )
        {
            hr = PiExtendWizard()->CreateWizardPages( Pdo()->GetUnknown(), this );
        } // if:  extension supports non-Wizard97 interface
        else
        {
            ATLASSERT( PiExtendWizard97() != NULL );
            hr = PiExtendWizard97()->CreateWizard97Pages( Pdo()->GetUnknown(), this );
        } // else:  extension doesn't support non-Wizard97 interface
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( (hr != NOERROR) && (hr != E_NOTIMPL) )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_ADD_PAGES_ERROR, StrCLSID() );
    } // if:  error creating wizard pages

} //*** CCluAdmExDll::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::CreateWizard97Pages
//
//  Routine Description:
//      Add pages to a Wizard 97 wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::CreateWizard97Pages( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Psht() != NULL );
    ATLASSERT( m_piExtendWizard == NULL );
    ATLASSERT( m_piExtendWizard97 == NULL );

    HRESULT     hr;

    //
    // Load the interface.  If it can't be loaded, try to load the non-
    // Wizard97 interface so that non-Wizard97 pages can be added.
    //
    m_piExtendWizard97 = reinterpret_cast< interface IWEExtendWizard97 * >( LoadInterface( IID_IWEExtendWizard97 ) );
    if ( m_piExtendWizard97 == NULL )
    {
        //
        // Try to load the non-Wizard97 interface.
        //
        m_piExtendWizard = reinterpret_cast< interface IWEExtendWizard * >( LoadInterface( IID_IWEExtendWizard ) );
        if ( m_piExtendWizard == NULL )
        {
            return;
        } // if:  error loading the non-Wizard97 interface
    } // if:  error loading the Wizard97 interface
    ATLASSERT( (m_piExtendWizard97 != NULL) || (m_piExtendWizard != NULL) );

    //
    // Add pages from the extension.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        if ( PiExtendWizard97() != NULL )
        {
            hr = PiExtendWizard97()->CreateWizard97Pages( Pdo()->GetUnknown(), this );
        } // if:  extension supports Wizard97 interface
        else
        {
            ATLASSERT( PiExtendWizard() != NULL );
            hr = PiExtendWizard()->CreateWizardPages( Pdo()->GetUnknown(), this );
        } // else:  extension doesn't support Wizard97 interface
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( (hr != NOERROR) && (hr != E_NOTIMPL) )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_ADD_PAGES_ERROR, StrCLSID() );
    } // if:  error creating wizard pages

} //*** CCluAdmExDll::CreateWizard97Pages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddContextMenuItems
//
//  Routine Description:
//      Ask the extension DLL to add items to the menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::AddContextMenuItems( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Pmenu() != NULL );
    ATLASSERT( m_piExtendContextMenu == NULL );

    HRESULT     hr;

    //
    // Load the interfaces.
    //
    m_piExtendContextMenu = reinterpret_cast< interface IWEExtendContextMenu * >( LoadInterface( IID_IWEExtendContextMenu ) );
    if ( m_piExtendContextMenu == NULL )
    {
        return;
    } // if:  error loading the interface
    ATLASSERT( m_piExtendContextMenu != NULL );

    hr = PiExtendContextMenu()->QueryInterface( IID_IWEInvokeCommand, (LPVOID *) &m_piInvokeCommand );
    if ( hr != NOERROR )
    {
        PiExtendContextMenu()->Release();
        m_piExtendContextMenu = NULL;
        ThrowStaticException( hr, ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID() );
    } // if:  error getting the InvokeCommand interface

    //
    // Add context menu items.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
//  Trace( g_tagExtDll, _T("CCluAdmExDll::AddContextMenuItem() - Adding context menu items from '%s'"), StrCLSID() );
    try
    {
        hr = PiExtendContextMenu()->AddContextMenuItems( Pdo()->GetUnknown(), this );
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( hr != NOERROR )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID() );
    } // if:  error occurred

    //
    // Add a separator after the extension's items.
    //
//  Trace( g_tagExtDll, _T("CCluAdmExDll::AddContextMenuItem() - Adding separator") );
    try
    {
        hr = AddExtensionMenuItem( NULL, NULL, (ULONG) -1, 0, MF_SEPARATOR );
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( hr != NOERROR )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID() );
    } // if:  error adding a separator

} //*** CCluAdmExDll::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Determines whether the interface supports error info (???).
//
//  Arguments:
//      riid        [IN] Reference to the interface ID.
//
//  Return Value:
//      S_OK        Interface supports error info.
//      S_FALSE     Interface does not support error info.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::InterfaceSupportsErrorInfo( REFIID riid )
{
    static const IID * rgiid[] =
    {
        &IID_IWCPropertySheetCallback,
        &IID_IWCWizardCallback,
        &IID_IWCWizard97Callback,
        &IID_IWCContextMenuCallback,
    };
    int     iiid;

    for ( iiid = 0 ; iiid < sizeof( rgiid ) / sizeof( rgiid[0] ) ; iiid++ )
    {
        if ( InlineIsEqualGUID( *rgiid[iiid], riid ) )
        {
            return S_OK;
        } // if:  found a match
    }
    return S_FALSE;

} //*** CCluAdmExDll::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddPropertySheetPage [IWCPropertySheetCallback]
//
//  Routine Description:
//      Add a page to the property sheet.
//
//  Arguments:
//      plong_hpage     [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CBasePropertySheetWindow::HrAddExtensionPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddPropertySheetPage( IN LONG * plong_hpage )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    HRESULT hr;

    // Loop to avoid goto's.
    do
    {
        //
        // Do this for the release build.
        //
        if (   (plong_hpage == NULL)
            || (Psht() == NULL) )
        {
            hr = E_INVALIDARG;
            break;
        } // if:  no page or sheet

        //
        // Allocate a new page object.
        //
        CCluAdmExPropPage * ppp = new CCluAdmExPropPage( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
        ATLASSERT( ppp != NULL );
        if ( ppp == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory

        //
        // Initialize the page object.
        //
        if ( ! ppp->BInit( Psht() ) )
        {
            delete ppp;
            hr = E_FAIL;
            break;
        } // if:  error initializing the page object

        //
        // Add the page to the sheet.
        //
        CBasePropertySheetWindow * psht = dynamic_cast< CBasePropertySheetWindow * >( Psht() );
        ATLASSERT( psht != NULL );
        hr = psht->HrAddExtensionPage( ppp );
        if ( hr != NOERROR )
        {
            delete ppp;
            break;
        } // if:  error adding the extension page
    } while ( 0 );

    return hr;

} //*** CCluAdmExDll::AddPropertySheetPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddWizardPage [IWCWizardCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      plong_hpage     [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CWizardWindow::HrAddExtensionPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddWizardPage( IN LONG * plong_hpage )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    HRESULT hr;

    // Loop to avoid goto's.
    do
    {
        //
        // Do this for the release build.
        //
        if (   (plong_hpage == NULL)
            || (Psht() == NULL) )
        {
            hr = E_INVALIDARG;
            break;
        } // if:  no page or sheet

        //
        // Allocate a new page object.
        //
        CCluAdmExWizPage * pwp = new CCluAdmExWizPage( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory

        //
        // Initialize the page object.
        //
        if ( ! pwp->BInit( Psht() ) )
        {
            delete pwp;
            hr = E_FAIL;
            break;
        } // if:  error initializing the page object

        //
        // Set the default buttons to display.  This assumes that there is
        // a non-extension page already in the sheet and that there will
        // be a page added after all extension pages have been added.
        //
        pwp->SetDefaultWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

        //
        // Add the page to the sheet.
        //
        CWizardWindow * pwiz = dynamic_cast< CWizardWindow * >( Psht() );
        ATLASSERT( pwiz != NULL );
        hr = pwiz->HrAddExtensionPage( pwp );
        if ( hr != NOERROR )
        {
            delete pwp;
            break;
        } // if:  error adding the extension page
    } while ( 0 );

    return hr;

} //*** CCluAdmExDll::AddWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddWizard97Page [IWCWizard97Callback]
//
//  Routine Description:
//      Add a page to the Wizard97 wizard.
//
//  Arguments:
//      plong_hpage     [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CWizardWindow::HrAddExtensionPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddWizard97Page( IN LONG * plong_hpage )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    HRESULT hr;

    // Loop to avoid goto's.
    do
    {
        //
        // Do this for the release build.
        //
        if (   (plong_hpage == NULL)
            || (Psht() == NULL) )
        {
            hr = E_INVALIDARG;
            break;
        } // if:  no page or sheet

        //
        // Allocate a new page object.
        //
        CCluAdmExWiz97Page * pwp = new CCluAdmExWiz97Page( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory

        //
        // Initialize the page object.
        //
        if ( ! pwp->BInit( Psht() ) )
        {
            delete pwp;
            hr = E_FAIL;
            break;
        } // if:  error initializing the page object

        //
        // Set the default buttons to display.  This assumes that there is
        // a non-extension page already in the sheet and that there will
        // be a page added after all extension pages have been added.
        //
        pwp->SetDefaultWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

        //
        // Add the page to the sheet.
        //
        CWizardWindow * pwiz = dynamic_cast< CWizardWindow * >( Psht() );
        ATLASSERT( pwiz != NULL );
        hr = pwiz->HrAddExtensionPage( pwp );
        if ( hr != NOERROR )
        {
            delete pwp;
            break;
        } // if:  error adding the extension page
    } while ( 0 );

    return hr;

} //*** CCluAdmExDll::AddWizard97Page()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::EnableNext [IWCWizardCallback/IWCWizard97Callback]
//
//  Routine Description:
//      Enable or disable the NEXT button.  If it is the last page, the
//      FINISH button will be enabled or disabled.
//
//  Arguments:
//      hpage           [IN] Page for which the button is being enabled or
//                          disabled.
//      bEnable         [IN] TRUE = Enable the button, FALSE = disable.
//
//  Return Value:
//      NOERROR         Success.
//      E_INVALIDARG    Unknown hpage specified.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::EnableNext(
    IN LONG *   plong_hpage,
    IN BOOL     bEnable
    )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    //
    // Find the page in the extension page list.
    //
    CWizardPageWindow * pwp = Pext()->PwpPageFromHpage( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
    if ( pwp == NULL )
    {
        return E_INVALIDARG;
    } // if:  page not found

    //
    // Let the page enable/disable the Next button.
    //
    pwp->EnableNext( bEnable );

    return NOERROR;

} //*** CCluAdmExDll::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddExtensionMenuItem [IWCContextMenuCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      lpszName            [IN] Name of item.
//      lpszStatusBarText   [IN] Text to appear on the status bar when the
//                              item is highlighted.
//      nCommandID          [IN] ID for the command when menu item is invoked.
//                              Must not be -1.
//      nSubmenuCommandID   [IN] ID for a submenu.
//      uFlags              [IN] Menu flags.  The following are not supported:
//                              MF_OWNERDRAW, MF_POPUP
//
//  Return Value:
//      NOERROR             Item added successfully.
//      E_INVALIDARG        MF_OWNERDRAW or MF_POPUP were specified.
//      E_OUTOFMEMORY       Error allocating the item.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddExtensionMenuItem(
    IN BSTR     lpszName,
    IN BSTR     lpszStatusBarText,
    IN ULONG    nCommandID,
    IN ULONG    nSubmenuCommandID,
    IN ULONG    uFlags
    )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Pmenu() != NULL );
    ATLASSERT( !(uFlags & (MF_OWNERDRAW | MF_POPUP)) );

    HRESULT             hr      = NOERROR;
    CCluAdmExMenuItem * pemi    = NULL;

    //
    // Do this for the release build.
    //
    if ( (uFlags & (MF_OWNERDRAW | MF_POPUP)) != 0 )
    {
        hr = E_INVALIDARG;
    } // if:  invalid menu flags specified
    else
    {
        ATLASSERT( Pext()->PemiFromExtCommandID( nCommandID ) == NULL );

        try
        {
//          Trace( g_tagExtDll, _T("CCluAdmExDll::AddExtensionMenuItem() - Adding menu item '%s', ExtID = %d"), lpszName, nCommandID );

            //
            // Allocate a new item.
            //
            pemi = new CCluAdmExMenuItem(
                            OLE2CT( lpszName ),
                            OLE2CT( lpszStatusBarText ),
                            nCommandID,
                            NNextCommandID(),
                            NNextMenuID(),
                            uFlags,
                            FALSE, /*bMakeDefault*/
                            PiInvokeCommand()
                            );
            if ( pemi == NULL )
            {
                ThrowStaticException( E_OUTOFMEMORY, (UINT) 0 );
            } // if: error allocating memory

            //
            // Insert the item in the menu.
            //
            if ( ! Pmenu()->InsertMenu( NNextMenuID(), MF_BYPOSITION | uFlags, NNextCommandID(), pemi->StrName() ) )
            {
                ThrowStaticException( ::GetLastError(), ADMC_IDS_INSERT_MENU_ERROR, pemi->StrName() );
            } // if:  error inserting the menu

            //
            // Add the item to the tail of the list.
            //
            Pext()->PlMenuItems()->insert( Pext()->PlMenuItems()->end(), pemi );
            pemi = NULL;

            //
            // Update the counters.
            //
            Pext()->m_nNextCommandID++;
            Pext()->m_nNextMenuID++;
        } // try
        catch ( CNTException * pnte )
        {
            hr = pnte->Sc();
            pnte->ReportError();
            pnte->Delete();
        } // catch:  CNTException
        catch ( CException * pe )
        {
            hr = E_OUTOFMEMORY;
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // else:  we can add the item

    delete pemi;
    return hr;

} //*** CCluAdmExDll::AddExtensionMenuItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atllcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AtlLCPair.h
//
//  Implementation File:
//      None.
//
//  Description:
//      Definition of the CListCtrlPair dialog.
//      Derive from CDialogImpl<> or CPropertyPageImpl<>.
//
//  Author:
//      David Potter (davidp)   August 8, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLLCPAIR_H_
#define __ATLLCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T, class ObjT, class BaseT > class CListCtrlPair;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#include "AdmCommonRes.h"   // for ADMC_IDC_LCP_xxx
#endif

#ifndef __ATLUTIL_H_
#include "AtlUtil.h"        // for DDX_xxx
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CLcpColumn
{
    UINT m_idsText;
    int m_nWidth;
};

#define LCPS_SHOW_IMAGES            0x1
#define LCPS_ALLOW_EMPTY            0x2
#define LCPS_CAN_BE_ORDERED         0x4
#define LCPS_ORDERED                0x8
#define LCPS_DONT_OUTPUT_RIGHT_LIST 0x10
#define LCPS_READ_ONLY              0x20
#define LCPS_PROPERTIES_BUTTON      0x40
#define LCPS_MAX                    0x40

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CListCtrlPair
//
//  Description:
//      Class to support dual list box.
//
//  Inheritance:
//      CListCtrlPair< T, ObjT, BaseT >
//      <BaseT>
//      ...
//      CDialogImpl< T >
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class ObjT, class BaseT >
class CListCtrlPair : public BaseT
{
//  friend class CListCtrlPairDlg;
//  friend class CListCtrlPairPage;
//  friend class CListCtrlPairWizPage;

    typedef CListCtrlPair< T, ObjT, BaseT > thisClass;
    typedef std::list< ObjT * >             _objptrlist;
    typedef std::list< ObjT * >::iterator   _objptrlistit;

protected:
    // Column structure and collection.
    typedef std::vector< CLcpColumn > CColumnArray;
    CColumnArray    m_aColumns;

    // Sort information.
    struct SortInfo
    {
        int     m_nDirection;
        int     m_nColumn;
    };

public:
    //
    // Construction
    //

    // Default constructor
    CListCtrlPair( void )
    {
        CommonConstruct();

    } //*** CListCtrlPair()

    // Constructor with style specified
    CListCtrlPair(
        IN DWORD    dwStyle,
        IN LPCTSTR  lpszTitle = NULL
        )
        : BaseT( lpszTitle )
    {
        CommonConstruct();
        m_dwStyle = dwStyle;

    } //*** CListCtrlPair( lpszTitle )

    // Constructor with style specified
    CListCtrlPair(
        IN DWORD    dwStyle,
        IN UINT     nIDTitle
        )
        : BaseT( nIDTitle )
    {
        CommonConstruct();
        m_dwStyle = dwStyle;

    } //*** CListCtrlPair( nIDTitle )

    // Common object construction
    void CommonConstruct( void )
    {
        m_dwStyle = LCPS_ALLOW_EMPTY;
        m_plvcFocusList = NULL;

        // Set the sort info.
        SiLeft().m_nDirection = -1;
        SiLeft().m_nColumn = -1;
        SiRight().m_nDirection = -1;
        SiRight().m_nColumn = -1;

    } //*** CommonConstruct()

public:
    //
    // Functions that are required to be implemented by derived class.
    //

    // Return list of objects for right list control
    _objptrlist * PlpobjRight( void ) const
    {
        ATLTRACE( _T("PlpobjRight() - Define in derived class\n") );
        ATLASSERT( 0 );
        return NULL;

    } //*** PlpobjRight()

    // Return list of objects for left list control
    const _objptrlist * PlpobjLeft( void ) const
    {
        ATLTRACE( _T("PlpobjLeft() - Define in derived class\n") );
        ATLASSERT( 0 );
        return NULL;
    
    } //*** PlpobjLeft()

    // Get column text and image
    void GetColumnInfo(
        IN OUT ObjT *   pobj,
        IN int          iItem,
        IN int          icol,
        OUT CString &   rstr,
        OUT int *       piimg
        )
    {
        ATLTRACE( _T("GetColumnInfo() - Define in derived class\n") );
        ATLASSERT( 0 );

    } //*** GetColumnInfo()

    // Display properties for the object
    int BDisplayProperties( IN OUT ObjT * pobj )
    {
        ATLTRACE( _T("BDisplayProperties() - Define in derived class\n") );
        ATLASSERT( 0 );
        return FALSE;

    } //*** BDisplayProperties()

    // Display an application-wide message box
    virtual int AppMessageBox( LPCWSTR lpszText, UINT fuStyle )
    {
        ATLTRACE( _T("BDisplayProperties() - Define in derived class\n") );
        ATLASSERT( 0 );
        return MessageBox( lpszText, _T(""), fuStyle );

    } //*** AppMessageBox()

    // Display an application-wide message box
    int AppMessageBox( UINT nID, UINT fuStyle )
    {
        CString strMsg;
        strMsg.LoadString( nID );
        return AppMessageBox( strMsg, fuStyle );

    } //*** AppMessageBox()

protected:
    //
    // List control pair style.
    //

    DWORD m_dwStyle;

    BOOL BIsStyleSet( IN DWORD dwStyle ) const  { return (m_dwStyle & dwStyle) == dwStyle; }
    void ModifyStyle( IN DWORD dwRemove, IN DWORD dwAdd )
    {
        ATLASSERT( (dwRemove & dwAdd) == 0 );
        if ( dwRemove != 0 )
        {
            m_dwStyle &= ~dwRemove;
        } // if:  removing some styles
        if ( dwAdd != 0 )
        {
            m_dwStyle |= dwAdd;
        } // if:  adding some styles

    } //*** ModifyStyle()

    DWORD       DwStyle( void ) const               { return m_dwStyle; }
    BOOL        BShowImages( void ) const           { return BIsStyleSet( LCPS_SHOW_IMAGES ); }
    BOOL        BAllowEmpty( void ) const           { return BIsStyleSet( LCPS_ALLOW_EMPTY ); }
    BOOL        BCanBeOrdered( void ) const         { return BIsStyleSet( LCPS_CAN_BE_ORDERED ); }
    BOOL        BOrdered( void ) const              { return BIsStyleSet( LCPS_ORDERED ); }
    BOOL        BReadOnly( void ) const             { return BIsStyleSet( LCPS_READ_ONLY ); }
    BOOL        BPropertiesButton( void ) const     { return BIsStyleSet( LCPS_PROPERTIES_BUTTON ); }

// Operations
public:

    // Add column to list of columns displayed in each list control
    void AddColumn( IN UINT idsText, IN int nWidth )
    {
        CLcpColumn col;

        ATLASSERT( idsText != 0 );
        ATLASSERT( nWidth > 0 );
        ATLASSERT( LpobjRight().empty() );

        col.m_idsText = idsText;
        col.m_nWidth = nWidth;

        m_aColumns.insert( m_aColumns.end(), col );

    } //*** AddColumn()

    // Insert an item in a list control
    int NInsertItemInListCtrl(
            IN int                  iitem,
            IN OUT ObjT *           pobj,
            IN OUT CListViewCtrl &  rlc
            )
    {
        int         iRetItem;
        CString     strText;
        int         iimg = 0;
        int         icol;

        // Insert the first column.
        ((T *) this)->GetColumnInfo( pobj, iitem, 0, strText, &iimg );
        iRetItem = rlc.InsertItem(
                        LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM,    // nMask
                        iitem,                                  // nItem
                        strText,                                // lpszItem
                        0,                                      // nState
                        0,                                      // nStateMask
                        iimg,                                   // nImage
                        (LPARAM) pobj                           // lParam
                        );
        ATLASSERT( iRetItem != -1 );

        for ( icol = 1 ; icol < m_aColumns.size() ; icol++ )
        {
            ((T *) this)->GetColumnInfo( pobj, iRetItem, icol, strText, NULL );
            rlc.SetItemText( iRetItem, icol, strText );
        } // for:  each column

        return iRetItem;

    } //*** NInsertItemInListCtrl()

    // Update data on or from the dialog
    BOOL UpdateData( IN BOOL bSaveAndValidate )
    {
        BOOL bSuccess = TRUE;

        if ( bSaveAndValidate )
        {
            //
            // Verify that the list is not empty.
            //
            if ( ! BAllowEmpty() && (m_lvcRight.GetItemCount() == 0) )
            {
                CString     strMsg;
                CString     strLabel;
                TCHAR *     pszLabel;

                DDX_GetText( m_hWnd, ADMC_IDC_LCP_RIGHT_LABEL, strLabel );

                //
                // Remove ampersands (&) and colons (:).
                //
                pszLabel = strLabel.GetBuffer( 1 );
                CleanupLabel( pszLabel );
                strLabel.ReleaseBuffer();

                //
                // Display an error message.
                //
                strMsg.FormatMessage( ADMC_IDS_EMPTY_RIGHT_LIST, pszLabel );
                AppMessageBox( strMsg, MB_OK | MB_ICONWARNING );

                bSuccess = FALSE;
            } // if:  list is empty and isn't allowed to be
        } // if:  saving data from the dialog
        else
        {
        } // else:  setting data to the dialog

        return bSuccess;

    } //*** UpdateData()

    // Apply changes made on this dialog
    BOOL BApplyChanges( void )
    {
        ATLASSERT( ! BIsStyleSet( LCPS_DONT_OUTPUT_RIGHT_LIST ) );
        ATLASSERT( ! BReadOnly() );

        T * pT = static_cast< T * >( this );

        //
        // Copy the Nodes list.
        //
        *pT->PlpobjRight() = LpobjRight();

        //
        // Call the base class method.
        //
        return BaseT::BApplyChanges();

    } //*** BApplyChanges()

// Implementation
protected:
    _objptrlist     m_lpobjRight;
    _objptrlist     m_lpobjLeft;
    CListViewCtrl   m_lvcRight;
    CListViewCtrl   m_lvcLeft;
    CListViewCtrl * m_plvcFocusList;
    CButton         m_pbAdd;
    CButton         m_pbRemove;
    CButton         m_pbMoveUp;
    CButton         m_pbMoveDown;
    CButton         m_pbProperties;

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        MESSAGE_HANDLER( WM_CONTEXTMENU, OnContextMenu )
        COMMAND_HANDLER( ADMC_IDC_LCP_ADD,        BN_CLICKED, OnAdd )
        COMMAND_HANDLER( ADMC_IDC_LCP_REMOVE,     BN_CLICKED, OnRemove )
        COMMAND_HANDLER( ADMC_IDC_LCP_MOVE_UP,    BN_CLICKED, OnMoveUp )
        COMMAND_HANDLER( ADMC_IDC_LCP_MOVE_DOWN,  BN_CLICKED, OnMoveDown )
        COMMAND_HANDLER( ADMC_IDC_LCP_PROPERTIES, BN_CLICKED, OnProperties )
        COMMAND_HANDLER( IDOK,                    BN_CLICKED, OnOK )
        COMMAND_HANDLER( IDCANCEL,                BN_CLICKED, OnCancel )
        COMMAND_HANDLER( ADMC_ID_MENU_PROPERTIES, 0, OnProperties )
        NOTIFY_HANDLER( ADMC_IDC_LCP_LEFT_LIST,   NM_DBLCLK, OnDblClkList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_RIGHT_LIST,  NM_DBLCLK, OnDblClkList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_LEFT_LIST,   LVN_ITEMCHANGED, OnItemChangedList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_RIGHT_LIST,  LVN_ITEMCHANGED, OnItemChangedList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_LEFT_LIST,   LVN_COLUMNCLICK, OnColumnClickList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_RIGHT_LIST,  LVN_COLUMNCLICK, OnColumnClickList )
        CHAIN_MSG_MAP( BaseT )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for WM_CONTEXTMENU
    LRESULT OnContextMenu(
        IN UINT         uMsg,
        IN WPARAM       wParam,
        IN LPARAM       lParam,
        IN OUT BOOL &   bHandled
        )
    {
        BOOL            bDisplayed  = FALSE;
        CMenu *         pmenu       = NULL;
        HWND            hWnd        = (HWND) wParam;
        WORD            xPos        = LOWORD( lParam );
        WORD            yPos        = HIWORD( lParam );
        CListViewCtrl * plvc;
        CString         strMenuName;
        CWaitCursor     wc;

        //
        // If focus is not in a list control, don't handle the message.
        //
        if ( hWnd == m_lvcLeft.m_hWnd )
        {
            plvc = &m_lvcLeft;
        } // if:  context menu on left list
        else if ( hWnd == m_lvcRight.m_hWnd )
        {
            plvc = &m_lvcRight;
        } // else if:  context menu on right list
        else
        {
            bHandled = FALSE;
            return 0;
        } // else:  focus not in a list control
        ATLASSERT( plvc != NULL );

        //
        // If the properties button is not enabled, don't display a menu.
        //
        if ( ! BPropertiesButton() )
        {
            bHandled = FALSE;
            return 0;
        } // if:  no properties button

        //
        // Create the menu to display.
        //
        pmenu = new CMenu;
        ATLASSERT( pmenu != NULL );
        if ( pmenu == NULL )
        {
            bHandled = FALSE;
            return 0;
        } // if: error allocating memory for the new menu

        if ( pmenu->CreatePopupMenu() )
        {
            UINT nFlags = MF_STRING;

            //
            // If there are no items in the list, disable the menu item.
            //
            if ( plvc->GetItemCount() == 0 )
            {
                nFlags |= MF_GRAYED;
            } // if:  no items in the list

            //
            // Add the Properties item to the menu.
            //
            strMenuName.LoadString( ADMC_ID_MENU_PROPERTIES );
            if ( pmenu->AppendMenu( nFlags, ADMC_ID_MENU_PROPERTIES, strMenuName ) )
            {
                m_plvcFocusList = plvc;
                bDisplayed = TRUE;
            } // if:  successfully added menu item
        }  // if:  menu created successfully

        if ( bDisplayed )
        {
            //
            // Display the menu.
            //
            if ( ! pmenu->TrackPopupMenu(
                            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                            xPos,
                            yPos,
                            m_hWnd
                            ) )
            {
            }  // if:  unsuccessfully displayed the menu
        }  // if:  there is a menu to display

        delete pmenu;
        return 0;

    } //*** OnContextMenu()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_ADD
    LRESULT OnAdd(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        ATLASSERT( ! BReadOnly() );

        //
        // Move selected items from the left list to the right list.
        //
        MoveItems( m_lvcRight, LpobjRight(), m_lvcLeft, LpobjLeft() );

        return 0;

    } //*** OnAdd()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_REMOVE
    LRESULT OnRemove(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        ATLASSERT( ! BReadOnly() );

        //
        // Move selected items from the right list to the left list.
        //
        MoveItems( m_lvcLeft, LpobjLeft(), m_lvcRight, LpobjRight() );

        return 0;

    } //*** OnRemove()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_MOVE_UP
    LRESULT OnMoveUp(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        int     nItem;
        ObjT *  pobj;

        //
        // Find the index of the selected item.
        //
        nItem = m_lvcRight.GetNextItem( -1, LVNI_SELECTED );
        ATLASSERT( nItem != -1 );

        //
        // Get the item pointer.
        //
        pobj = (ObjT *) m_lvcRight.GetItemData( nItem );
        ATLASSERT( pobj != NULL );

        // Remove the selected item from the list and add it back in.
        {
            _objptrlistit   itRemove;
            _objptrlistit   itAdd;

            // Find the position of the item to be removed and the item before
            // which the item is to be inserted.
            itRemove = std::find( LpobjRight().begin(), LpobjRight().end(), pobj );
            ATLASSERT( itRemove != LpobjRight().end() );
            itAdd = itRemove--;
            LpobjRight().insert( itAdd, pobj );
            LpobjRight().erase( itRemove );
        }  // Remove the selected item from the list and add it back in

        // Remove the selected item from the list control and add it back in.
        m_lvcRight.DeleteItem( nItem );
        NInsertItemInListCtrl( nItem - 1, pobj, m_lvcRight );
        m_lvcRight.SetItemState(
            nItem - 1,
            LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED
            );
        m_lvcRight.EnsureVisible( nItem - 1, FALSE /*bPartialOK*/ );
        m_lvcRight.SetFocus();

        return 0;

    }  //*** OnMoveUp()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_MOVE_DOWN
    LRESULT OnMoveDown(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        int     nItem;
        ObjT *  pobj;

        //
        // Find the index of the selected item.
        //
        nItem = m_lvcRight.GetNextItem( -1, LVNI_SELECTED );
        ATLASSERT( nItem != -1 );

        //
        // Get the item pointer.
        //
        pobj = (ObjT *) m_lvcRight.GetItemData( nItem );
        ATLASSERT( pobj != NULL );

        // Remove the selected item from the list and add it back in.
        {
            _objptrlistit   itRemove;
            _objptrlistit   itAdd;

            // Find the position of the item to be removed and the item after
            // which the item is to be inserted.
            itRemove = std::find( LpobjRight().begin(), LpobjRight().end(), pobj );
            ATLASSERT( itRemove != LpobjRight().end() );
            itAdd = itRemove++;
            LpobjRight().insert( itAdd, pobj );
            LpobjRight().erase( itRemove );
        }  // Remove the selected item from the list and add it back in

        // Remove the selected item from the list control and add it back in.
        m_lvcRight.DeleteItem( nItem );
        NInsertItemInListCtrl( nItem + 1, pobj, m_lvcRight );
        m_lvcRight.SetItemState(
            nItem + 1,
            LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED
            );
        m_lvcRight.EnsureVisible( nItem + 1, FALSE /*bPartialOK*/ );
        m_lvcRight.SetFocus();

        return 0;

    }  //*** OnMoveDown()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_PROPERTIES
    LRESULT OnProperties(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        int     iitem;
        ObjT *  pobj;

        ATLASSERT( m_plvcFocusList != NULL );

        // Get the index of the item with the focus.
        iitem = m_plvcFocusList->GetNextItem( -1, LVNI_FOCUSED );
        ATLASSERT( iitem != -1 );

        // Get a pointer to the selected item.
        pobj = (ObjT *) m_plvcFocusList->GetItemData( iitem );
        ATLASSERT( pobj != NULL );

        T * pT = static_cast< T * >( this );

        if ( pT->BDisplayProperties( pobj ) )
        {
            // Update this item.
            {
                CString     strText;
                int         iimg = 0;
                int         icol;

                pT->GetColumnInfo( pobj, iitem, 0, strText, &iimg );
                m_plvcFocusList->SetItem( iitem, 0, LVIF_TEXT /*| LVIF_IMAGE*/, strText, iimg, 0, 0, 0 );

                for ( icol = 1 ; icol < m_aColumns.size() ; icol++ )
                {
                    pT->GetColumnInfo( pobj, iitem, icol, strText, NULL );
                    m_plvcFocusList->SetItemText( iitem, icol, strText );
                } // for:  each column
            } // Update this item
        } // if:  properties changed

        return 0;

    } //*** OnProperties()

    // Handler for BN_CLICKED on IDOK
    LRESULT OnOK(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        //
        // Save dialog data and exit the dialog.
        //
        if ( BSaveChanges() )
        {
            EndDialog( IDOK );
        } // if:  dialgo data saved

        return 0;

    } //*** OnOK()

    // Handler for BN_CLICKED on IDCANCEL
    LRESULT OnCancel(
        IN WORD         wNotifyCode,
        IN WORD         idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        //
        // Exit the dialog.
        //
        EndDialog( IDCANCEL );
        return 0;

    } //*** OnCancel()

    // Handler for NM_DBLCLK on ADMC_IDC_LCP_LEFT_LIST & ADMC_IDC_LCP_RIGHT_LIST
    LRESULT OnDblClkList(
        IN WORD         idCtrl,
        IN LPNMHDR      pnmh,
        IN OUT BOOL &   bHandled
        )
    {
        ATLASSERT( ! BReadOnly() );

        LRESULT lResult;

        if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
        {
            m_plvcFocusList = &m_lvcLeft;
            lResult = OnAdd( BN_CLICKED, idCtrl, pnmh->hwndFrom, bHandled );
        } // if:  double-clicked in left list
        else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
        {
            m_plvcFocusList = &m_lvcRight;
            lResult = OnRemove( BN_CLICKED, idCtrl, pnmh->hwndFrom, bHandled );
        } // else if:  double-clicked in right list
        else
        {
            ATLASSERT( 0 );
            lResult = 0;
        } // else:  double-clicked in an unknown location

        return lResult;

    } //*** OnDblClkList()

    // Handler for LVN_ITEMCHANGED on ADMC_IDC_LCP_LEFT_LIST & ADMC_IDC_LCP_RIGHT_LIST
    LRESULT OnItemChangedList(
        IN int          idCtrl,
        IN LPNMHDR      pnmh,
        IN OUT BOOL &   bHandled
        )
    {
        NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pnmh;
        BOOL            bEnable;
        CButton *       ppb;

        if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
        {
            m_plvcFocusList = &m_lvcLeft;
            ppb = &m_pbAdd;
        } // if:  item changed in left list
        else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
        {
            m_plvcFocusList = &m_lvcRight;
            ppb = &m_pbRemove;
        } // else if:  item changed in right list
        else
        {
            ATLASSERT( 0 );
            bHandled = FALSE;
            return 0;
        } // else:  unknown list
        ATLASSERT( ppb != NULL );

        // If the selection changed, enable/disable the Add button.
        if (   (pNMListView->uChanged & LVIF_STATE)
            && (   (pNMListView->uOldState & LVIS_SELECTED)
                || (pNMListView->uNewState & LVIS_SELECTED) )
            && ! BReadOnly() )
        {
            UINT cSelected = m_plvcFocusList->GetSelectedCount();

            //
            // If there is a selection, enable the Add or Remove button.
            // Otherwise disable it.
            //
            bEnable = (cSelected != 0);
            ppb->EnableWindow( bEnable );
            if ( BPropertiesButton() )
            {
                m_pbProperties.EnableWindow( (cSelected == 1) ? TRUE : FALSE );
            } // if:  dialog has Properties button

            //
            // If the right list is ordered, setup the state of the Up/Down buttons.
            //
            if ( BOrdered() )
            {
                SetUpDownState();
            } // if:  right list is ordered
        }  // if:  selection changed

        return 0;

    } //*** OnItemChangedList()

    // Handler for LVN_COLUMNCLICK on ADMC_IDC_LCP_LEFT_LIST & ADMC_IDC_LCP_RIGHT_LIST
    LRESULT OnColumnClickList(
        IN int          idCtrl,
        IN LPNMHDR      pnmh,
        IN OUT BOOL &   bHandled
        )
    {
        NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pnmh;

        if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
        {
            m_plvcFocusList = &m_lvcLeft;
            m_psiCur = &SiLeft();
        } // if:  column clicked in left list
        else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
        {
            m_plvcFocusList = &m_lvcRight;
            m_psiCur = &SiRight();
        } // else if:  column clicked in right list
        else
        {
            ATLASSERT( 0 );
            bHandled = FALSE;
            return 0;
        } // else:  column clicked in unknown list

        // Save the current sort column and direction.
        if ( pNMListView->iSubItem == m_psiCur->m_nColumn )
        {
            m_psiCur->m_nDirection ^= -1;
        } // if:  sorting same column again
        else
        {
            m_psiCur->m_nColumn = pNMListView->iSubItem;
            m_psiCur->m_nDirection = 0;
        } // else:  different column

        // Sort the list.
        if ( ! m_plvcFocusList->SortItems( CompareItems, (LPARAM) this ) )
        {
            ATLASSERT( 0 );
        } // if:  error sorting items

        return 0;

    } //*** OnColumnClickList

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void )
    {
#if DBG
        T * pT = static_cast< T * >( this );
        ATLASSERT( pT->PlpobjRight() != NULL );
        ATLASSERT( pT->PlpobjLeft() != NULL );
#endif // DBG

        //
        // Attach the controls to control member variables.
        //
        AttachControl( m_lvcRight, ADMC_IDC_LCP_RIGHT_LIST );
        AttachControl( m_lvcLeft, ADMC_IDC_LCP_LEFT_LIST );
        AttachControl( m_pbAdd, ADMC_IDC_LCP_ADD );
        AttachControl( m_pbRemove, ADMC_IDC_LCP_REMOVE );
        if ( BPropertiesButton() )
        {
            AttachControl( m_pbProperties, ADMC_IDC_LCP_PROPERTIES );
        } // if:  dialog has Properties button
        if ( BCanBeOrdered() )
        {
            AttachControl( m_pbMoveUp, ADMC_IDC_LCP_MOVE_UP );
            AttachControl( m_pbMoveDown, ADMC_IDC_LCP_MOVE_DOWN );
        } // if:  left list can be ordered

//      if ( BShowImages() )
//      {
//          CClusterAdminApp * papp = GetClusterAdminApp();
//
//          m_lvcLeft.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//          m_lvcRight.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//      } // if:  showing images

        //
        // Disable buttons by default.
        //
        m_pbAdd.EnableWindow( FALSE );
        m_pbRemove.EnableWindow( FALSE );
        if ( BPropertiesButton() )
        {
            m_pbProperties.EnableWindow( FALSE );
        } // if:  dialog has Properties button

        //
        // Set the right list to sort if not ordered.  Set both to show selection always.
        //
        if ( BOrdered() )
        {
            m_lvcRight.ModifyStyle( 0, LVS_SHOWSELALWAYS, 0 );
        } // if:  right list is ordered
        else
        {
            m_lvcRight.ModifyStyle( 0, LVS_SHOWSELALWAYS | LVS_SORTASCENDING, 0 );
        } // else:  right list is not ordered
        m_lvcLeft.ModifyStyle( 0, LVS_SHOWSELALWAYS, 0 );


        //
        // If this is an ordered list, show the Move buttons.
        // Otherwise, hide them.
        //
        if ( BCanBeOrdered() )
        {
            SetUpDownState();
        } // if:  list can be ordered

        //
        // Change left list view control extended styles.
        //
        m_lvcLeft.SetExtendedListViewStyle(
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
            );

        //
        // Change right list view control extended styles.
        //
        m_lvcRight.SetExtendedListViewStyle(
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
            );

        // Duplicate lists.
        DuplicateLists();

        //
        // Insert all the columns.
        //
        {
            int         icol;
            int         ncol;
            int         nUpperBound = m_aColumns.size();
            CString     strColText;

            ATLASSERT( nUpperBound > 0 );

            for ( icol = 0 ; icol < nUpperBound ; icol++ )
            {
                strColText.LoadString( m_aColumns[icol].m_idsText );
                ncol = m_lvcLeft.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
                ATLASSERT( ncol == icol );
                ncol = m_lvcRight.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
                ATLASSERT( ncol == icol );
            } // for:  each column
        } // Insert all the columns

        //
        // Fill the list controls.
        //
        FillList( m_lvcRight, LpobjRight() );
        FillList( m_lvcLeft, LpobjLeft() );

        //
        // If read-only, set all controls to be either disabled or read-only.
        //
        if ( BReadOnly() )
        {
            m_lvcRight.EnableWindow( FALSE );
            m_lvcLeft.EnableWindow( FALSE );
        } // if:  sheet is read-only

        //
        // Call the base class method.
        //
        return BaseT::OnInitDialog();

    } //*** OnInitDialog()

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void )
    {
        UINT    nSelCount;

        // Set the focus to the left list.
        m_lvcLeft.SetFocus();
        m_plvcFocusList = &m_lvcLeft;

        // Enable/disable the Properties button.
        nSelCount = m_lvcLeft.GetSelectedCount();
        if ( BPropertiesButton() )
        {
            m_pbProperties.EnableWindow( nSelCount == 1 );
        } // if:  dialog has Properties button

        // Enable or disable the other buttons.
        if ( ! BReadOnly() )
        {
            m_pbAdd.EnableWindow( nSelCount > 0 );
            nSelCount = m_lvcRight.GetSelectedCount();
            m_pbRemove.EnableWindow( nSelCount > 0 );
            SetUpDownState();
        } // if:  not read-only page

        return TRUE;

    } //*** OnSetActive()

public:
    _objptrlist & LpobjRight( void )    { return m_lpobjRight; }
    _objptrlist & LpobjLeft( void )     { return m_lpobjLeft; }

protected:
    void DuplicateLists( void )
    {
        LpobjRight().erase( LpobjRight().begin(), LpobjRight().end() );
        LpobjLeft().erase( LpobjLeft().begin(), LpobjLeft().end() );

        T * pT = static_cast< T * >( this );

        if ( (pT->PlpobjRight() == NULL) || (pT->PlpobjLeft() == NULL) )
        {
            return;
        } // if:  either list is empty

        //
        // Duplicate the lists.
        //
        LpobjRight() = *pT->PlpobjRight();
        LpobjLeft() = *pT->PlpobjLeft();

        //
        // Remove all the items that are in the right list from
        // the left list.
        //
        _objptrlistit itRight;
        _objptrlistit itLeft;
        for ( itRight = LpobjRight().begin()
            ; itRight != LpobjRight().end()
            ; itRight++ )
        {
            //
            // Find the item in the left list.
            //
            itLeft = std::find( LpobjLeft().begin(), LpobjLeft().end(), *itRight );
            if ( itLeft != LpobjLeft().end() )
            {
                LpobjLeft().erase( itLeft );
            } // if:  object found in left list
        } // for:  each item in the right list

    } //*** DuplicateLists()

    // Fill a list control
    void FillList( IN OUT CListViewCtrl & rlvc, IN const _objptrlist & rlpobj )
    {
        _objptrlistit   itpobj;
        ObjT *          pobj;
        int             iItem;

        // Initialize the control.
        if ( ! rlvc.DeleteAllItems() )
        {
            ATLASSERT( 0 );
        } // if:  error deleting all items

        rlvc.SetItemCount( rlpobj.size() );

        // Add the items to the list.
        itpobj = rlpobj.begin();
        for ( iItem = 0 ; itpobj != rlpobj.end() ; iItem++, itpobj++ )
        {
            pobj = *itpobj;
            NInsertItemInListCtrl( iItem, pobj, rlvc );
        } // for:  each string in the list

        // If there are any items, set the focus on the first one.
        if ( rlvc.GetItemCount() != 0)
        {
            rlvc.SetItemState( 0, LVIS_FOCUSED, LVIS_FOCUSED );
        } // if:  items were added to the list

    } //*** FillList()

    // Move items from one list to another
    void MoveItems(
            IN OUT CListViewCtrl &  rlvcDst,
            IN OUT _objptrlist &    rlpobjDst,
            IN OUT CListViewCtrl &  rlvcSrc,
            IN OUT _objptrlist &    rlpobjSrc
            )
    {
        int             iSrcItem;
        int             iDstItem;
        int             nItem   = -1;
        ObjT *          pobj;
        _objptrlistit   itpobj;

        ATLASSERT( ! BReadOnly() );

        iDstItem = rlvcDst.GetItemCount();
        while ( (iSrcItem = rlvcSrc.GetNextItem( -1, LVNI_SELECTED )) != -1 )
        {
            // Get the item pointer.
            pobj = (ObjT *) rlvcSrc.GetItemData( iSrcItem );
            ATLASSERT( pobj );

            // Remove the item from the source list.
            itpobj = std::find( rlpobjSrc.begin(), rlpobjSrc.end(), pobj );
            ATLASSERT( itpobj != rlpobjSrc.end() );
            rlpobjSrc.remove( *itpobj );

            // Add the item to the destination list.
            rlpobjDst.insert( rlpobjDst.end(), pobj );

            // Remove the item from the source list control and
            // add it to the destination list control.
            if ( ! rlvcSrc.DeleteItem( iSrcItem ) )
            {
                ATLASSERT( 0 );
            } // if:  error deleting the item
            nItem = NInsertItemInListCtrl( iDstItem++, pobj, rlvcDst );
            rlvcDst.SetItemState(
                nItem,
                LVIS_SELECTED | LVIS_FOCUSED,
                LVIS_SELECTED | LVIS_FOCUSED
                );
        } // while:  more items

        ATLASSERT( nItem != -1 );

        rlvcDst.EnsureVisible( nItem, FALSE /*bPartialOK*/ );
        rlvcDst.SetFocus();

        // Indicate that the data has changed.
        ::SendMessage( GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, NULL );

    } //*** MoveItems()
    BOOL BSaveChanges( void )
    {
        ATLASSERT( ! BIsStyleSet( LCPS_DONT_OUTPUT_RIGHT_LIST ) );
        ATLASSERT( ! BReadOnly() );

        T * pT = static_cast< T * >( this );

        //
        // Update the data first.
        //
        if ( ! pT->UpdateData( TRUE /*bSaveAndValidate*/ ) )
        {
            return FALSE;
        } // if:  error updating data

        //
        // Copy the object list.
        //
        *pT->PlpobjRight() = LpobjRight();

        return TRUE;

    }  //*** BSaveChanges()

    // Set the state of the Up/Down buttons based on the selection.
    void SetUpDownState( void )
    {
        BOOL    bEnableUp;
        BOOL    bEnableDown;

        if (   BOrdered()
            && ! BReadOnly()
            && (m_lvcRight.GetSelectedCount() == 1) )
        {
            int     nItem;

            bEnableUp = TRUE;
            bEnableDown = TRUE;

            //
            // Find the index of the selected item.
            //
            nItem = m_lvcRight.GetNextItem( -1, LVNI_SELECTED );
            ATLASSERT( nItem != -1 );

            //
            // If the first item is selected, can't move up.
            //
            if ( nItem == 0 )
            {
                bEnableUp = FALSE;
            } // if:  first item is selected

            //
            // If the last item is selected, can't move down.
            //
            if ( nItem == m_lvcRight.GetItemCount() - 1 )
            {
                bEnableDown = FALSE;
            } // if:  last item is selected
        }  // if:  only one item selected
        else
        {
            bEnableUp = FALSE;
            bEnableDown = FALSE;
        }  // else:  zero or more than one item selected

        m_pbMoveUp.EnableWindow( bEnableUp );
        m_pbMoveDown.EnableWindow( bEnableDown );

    }  //*** SetUpDownState()
    
    static int CALLBACK CompareItems( LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort )
    {
        ObjT *      pobj1   = reinterpret_cast< ObjT * >( lparam1 );
        ObjT *      pobj2   = reinterpret_cast< ObjT * >( lparam2 );
        T *         plcp    = reinterpret_cast< T * >( lparamSort );
        SortInfo *  psiCur  = plcp->PsiCur();
        int         icol    = psiCur->m_nColumn;
        int         nResult;
        CString     str1;
        CString     str2;

        ATLASSERT( pobj1 != NULL );
        ATLASSERT( pobj2 != NULL );
        ATLASSERT( plcp != NULL );
        ATLASSERT( psiCur->m_nColumn >= 0 );
        ATLASSERT( icol >= 0 );

        plcp->GetColumnInfo( pobj1, 0, icol, str1, NULL );
        plcp->GetColumnInfo( pobj2, 0, icol, str2, NULL );

        nResult = str1.Compare( str2 );

        // Return the result based on the direction we are sorting.
        if ( psiCur->m_nDirection != 0 )
        {
            nResult = -nResult;
        } // if:  sorting in reverse direction

        return nResult;

    } //*** CompareItems()

    SortInfo            m_siLeft;
    SortInfo            m_siRight;
    SortInfo *          m_psiCur;

    SortInfo &          SiLeft( void )          { return m_siLeft; }
    SortInfo &          SiRight( void )         { return m_siRight; }

public:
    SortInfo *          PsiCur( void ) const    { return m_psiCur; }

};  //*** class CListCtrlPair

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLLCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlutil.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlUtil.cpp
//
//	Abstract:
//		Implementation of helper functions for use in an ATL project.
//
//	Author:
//		David Potter (davidp)	December 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlUtil.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_GetText
//
//	Routine Description:
//		Get a text value from a control on a dialog.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] ID of control to get value from.
//		rstrValue	[IN OUT] String in which to return value.
//
//	Return Value:
//		TRUE		Value retrieved successfully.
//		FALSE		Error retrieving value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_GetText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT CString &	rstrValue
	)
{
	ATLASSERT( hwndDlg != NULL );

	//
	// Get the handle for the control.
	//
	HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hwndCtrl != NULL );

	//
	// Get the text from the control.
	//
	int cch = GetWindowTextLength( hwndCtrl );
	if ( cch == 0 )
	{
		rstrValue = _T("");
	} // if:  edit control is empty
	else
	{
		LPTSTR pszValue = rstrValue.GetBuffer( cch + 1 );
		ATLASSERT( pszValue != NULL );
		int cchRet = GetWindowText( hwndCtrl, pszValue, cch + 1 );
		ATLASSERT( cchRet > 0 );
		rstrValue.ReleaseBuffer();
	} // else:  length of text retrieved

	return TRUE;

} //*** DDX_GetText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_SetText
//
//	Routine Description:
//		Set a text value into a control on a dialog.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] ID of control to set value to.
//		rstrValue	[IN] String to set into the dialog.
//
//	Return Value:
//		TRUE		Value set successfully.
//		FALSE		Error setting value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_SetText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN const CString &	rstrValue
	)
{
	ATLASSERT( hwndDlg != NULL );

	//
	// Set the text into the control.
	//
	BOOL bSuccess = SetDlgItemText( hwndDlg, nIDC, rstrValue );
	ATLASSERT( bSuccess );

	return bSuccess;

} //*** DDX_SetText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_SetComboBoxText
//
//	Routine Description:
//		Set a text value into a control on a dialog.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] ID of control to set value to.
//		rstrValue	[IN] String to set into the dialog.
//		bRequired	[IN] TRUE = text must already exist in the combobox.
//
//	Return Value:
//		TRUE		Value set successfully.
//		FALSE		Error setting value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_SetComboBoxText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN const CString &	rstrValue,
	IN BOOL				bRequired
	)
{
	ATLASSERT( hwndDlg != NULL );

	BOOL bSuccess = TRUE;

	//
	// Get the handle for the control.
	//
	HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hwndCtrl != NULL );

#if DBG
	TCHAR szWindowClass[256];
	::GetClassName( hwndCtrl, szWindowClass, (sizeof( szWindowClass ) / sizeof( TCHAR )) - 1 );
	ATLASSERT( lstrcmp( szWindowClass, _T("ComboBox") ) == 0 );
#endif // DBG

	int idx = (int) SendMessage( hwndCtrl, CB_FINDSTRINGEXACT, -1, (LPARAM)(LPCTSTR) rstrValue );
	if ( idx != CB_ERR )
	{
		SendMessage( hwndCtrl, CB_SETCURSEL, idx, 0 );
	} // if:  message sent successfully
	else
	{
		if ( bRequired )
		{
			ATLASSERT( idx != CB_ERR );
		} // if:  string was supposed to be present already
		bSuccess = FALSE;
	} // else if:  error sending message

	return bSuccess;

} //*** DDX_SetComboBoxText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_GetNumber
//
//	Routine Description:
//		Get a numeric value from a control on a dialog.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] ID of control to get value from.
//		rnValue		[IN OUT] Number in which to return value.
//		nMin		[IN] Minimum value.
//		nMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		TRUE		Value retrieved successfully.
//		FALSE		Error retrieving value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_GetNumber(
	IN HWND			hwndDlg,
	IN int			nIDC,
	IN OUT ULONG &	rnValue,
	IN ULONG		nMin,
	IN ULONG		nMax,
	IN BOOL			bSigned
	)
{
	ATLASSERT( hwndDlg != NULL );

	BOOL	bSuccess = TRUE;
	BOOL	bTranslated;
	ULONG	nValue;

	//
	// Get the handle for the control.
	//
	HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hwndCtrl != NULL );

	//
	// Get the number from the control.
	//
	nValue = GetDlgItemInt( hwndDlg, nIDC, &bTranslated, bSigned );

	//
	// If the retrival failed, it is a signed number, and the minimum
	// value is the smallest negative value possible, check the string itself.
	//
	if ( ! bTranslated && bSigned && (nMin == 0x80000000) )
	{
		UINT	cch;
		TCHAR	szNumber[20];

		//
		// See if it is the smallest negative number.
		//
		cch = GetWindowText( hwndCtrl, szNumber, sizeof( szNumber ) / sizeof(TCHAR ) );
		if ( (cch != 0) && (lstrcmp( szNumber, _T("-2147483648") ) == 0) )
		{
			nValue = 0x80000000;
			bTranslated = TRUE;
		}  // if:  text retrieved successfully and is highest negative number
	}  // if:  error translating number and getting signed number

	//
	// If the retrieval failed or the specified number is
	// out of range, display an error.
	//
	if (   ! bTranslated
		|| (bSigned && (((LONG) nValue < (LONG) nMin) || ((LONG) nValue > (LONG) nMax)))
		|| (! bSigned && ((nValue < nMin) || (nValue > nMax)))
		)
	{
		TCHAR szMin[32];
		TCHAR szMax[32];
		CString strPrompt;

		bSuccess = FALSE;
		if ( bSigned )
		{
			wsprintf( szMin, _T("%d%"), nMin );
			wsprintf( szMax, _T("%d%"), nMax );
		}  // if:  signed number
		else
		{
			wsprintf( szMin, _T("%u%"), nMin );
			wsprintf( szMax, _T("%u%"), nMax );
		}  // else:  unsigned number
		strPrompt.FormatMessage( IDP_PARSE_INT_RANGE, szMin, szMax );
		AppMessageBox( hwndDlg, strPrompt, MB_ICONEXCLAMATION );
		SetFocus( hwndCtrl );
	}  // if:  invalid string
	else
	{
		rnValue = nValue;
	} // else:  valid string

	return bSuccess;

} //*** DDX_GetNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_GetNumber
//
//	Routine Description:
//		Set a numeric value into a control on a dialog.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] ID of control to get value from.
//		nValue		[IN] Number value to set into the control.
//		nMin		[IN] Minimum value.
//		nMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		TRUE		Value retrieved successfully.
//		FALSE		Error retrieving value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_SetNumber(
	IN HWND		hwndDlg,
	IN int		nIDC,
	IN ULONG	nValue,
	IN ULONG	nMin,
	IN ULONG	nMax,
	IN BOOL		bSigned
	)
{
	ATLASSERT( hwndDlg != NULL );

	CString		strMinValue;
	CString		strMaxValue;
	UINT		cchMax;

	//
	// Get the handle for the control.
	//
	HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hwndCtrl != NULL );

	//
	// Set the maximum number of characters that can be entered.
	//
	if ( bSigned )
	{
		strMinValue.Format( _T("%d"), nMin );
		strMaxValue.Format( _T("%d"), nMax );
	}  // if:  signed value
	else
	{
		strMinValue.Format( _T("%u"), nMin );
		strMaxValue.Format( _T("%u"), nMax );
	}  // else:  unsigned value
	cchMax = max( strMinValue.GetLength(), strMaxValue.GetLength() );
	SendMessage( hwndCtrl, EM_LIMITTEXT, cchMax, 0 );

	// Set the value into the control.
	BOOL bSuccess = SetDlgItemInt( hwndDlg, nIDC, nValue, bSigned );
	ATLASSERT( bSuccess );

	return bSuccess;

} //*** DDX_SetNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		TRUE		Required value is present.
//		FALSE		Required value is not present.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDV_RequiredText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN int				nIDCLabel,
	IN const CString &	rstrValue
	)
{
	ATLASSERT( hwndDlg != NULL );

	BOOL	bSuccess = TRUE;
	BOOL	bIsBlank;

	//
	// Get the handle for the control.
	//
	HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hwndCtrl != NULL );

	//
	// Get the window class name.
	//
	TCHAR szWindowClass[256];
	GetClassName( hwndCtrl, szWindowClass, (sizeof( szWindowClass ) / sizeof( TCHAR )) - 1 );

	//
	// If this is the IP Address control, send a special message to
	// determine if it is empty or not.
	//
	if ( lstrcmp( szWindowClass, WC_IPADDRESS ) == 0 )
	{
		bIsBlank = SendMessage( hwndCtrl, IPM_ISBLANK, 0, 0 );
	} // if:  IP Address control
	else
	{
		bIsBlank = rstrValue.GetLength() == 0;
	} // else:  edit control

	if ( bIsBlank )
	{
		TCHAR		szLabel[1024];

		bSuccess = FALSE;

		//
		// Get the text of the label.
		//
		GetDlgItemText( hwndDlg, nIDCLabel, szLabel, sizeof( szLabel ) / sizeof( TCHAR ) );

		//
		// Remove ampersands (&) and colons (:).
		//
		CleanupLabel( szLabel );

		//
		// Format and display a message.
		//
		CString strPrompt;
		strPrompt.FormatMessage( IDS_REQUIRED_FIELD_EMPTY, szLabel );
		AppMessageBox( hwndDlg, strPrompt, MB_ICONEXCLAMATION );

		//
		// Set focus to the control.
		HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
		ATLASSERT( hwndCtrl != NULL );
		SetFocus( hwndCtrl );
	}  // if:  field not specified

	return bSuccess;

} //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupLabel
//
//	Routine Description:
//		Prepare a label read from a dialog to be used as a string in a
//		message by removing ampersands (&) and colons (:).
//
//	Arguments:
//		pszLabel	[IN OUT] Label to be cleaned up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel( IN OUT LPTSTR pszLabel )
{
	LPTSTR	pIn, pOut;
	LANGID	langid;
	WORD	primarylangid;
	BOOL	bFELanguage;

	//
	// Get the language ID.
	//
	langid = GetUserDefaultLangID();
	primarylangid = (WORD) PRIMARYLANGID( langid );
	bFELanguage = ((primarylangid == LANG_JAPANESE)
					|| (primarylangid == LANG_CHINESE)
					|| (primarylangid == LANG_KOREAN));

	//
	// Copy the name sans '&' and ':' chars
	//

	pIn = pOut = pszLabel;
	do
	{
		//
		// Strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
		//
		if (   bFELanguage
			&& (pIn[0] == _T('('))
			&& (pIn[1] == _T('&'))
			&& (pIn[2] != _T('\0'))
			&& (pIn[3] == _T(')')))
		{
			pIn += 3;
		} // if:  FE language and parenthesized hotkey present
		else if ( (*pIn != _T('&')) && (*pIn != _T(':')) )
		{
			*pOut++ = *pIn;
		} // if:  found hotkey
	} while ( *pIn++ != _T('\0') ) ;

} //*** CleanupLabel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_GetCheck
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] Control ID.
//		rnValue		[OUT] Value to get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_GetCheck( IN HWND hwndDlg, IN int nIDC, OUT int & rnValue )
{
	ATLASSERT( hwndDlg != NULL );

	//
	// Get the handle for the control.
	//
	HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hWndCtrl != NULL );

	rnValue = (int)::SendMessage( hWndCtrl, BM_GETCHECK, 0, 0L );
	ATLASSERT( (rnValue >= 0) && (rnValue <= 2) );

} //*** DDX_GetCheck()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_SetCheck
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] Control ID.
//		nValue		[IN] Value to set.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_SetCheck( IN HWND hwndDlg, IN int nIDC, IN int nValue )
{
	ATLASSERT( hwndDlg != NULL );

	//
	// Get the handle for the control.
	//
	HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hWndCtrl != NULL );

	ATLASSERT( (nValue >= 0) && (nValue <= 2) );
	if ( (nValue < 0) || (nValue > 2) )
	{
		ATLTRACE( _T("Warning: dialog data checkbox value (%d) out of range.\n"), nValue );
		nValue = 0;  // default to off
	} // if:  value is out of range
	::SendMessage( hWndCtrl, BM_SETCHECK, (WPARAM) nValue, 0L );

} //*** DDX_SetCheck()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_GetRadio
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] Control ID of first radio button in a group.
//		rnValue		[OUT] Value to get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_GetRadio( IN HWND hwndDlg, IN int nIDC, IN int & rnValue )
{
	ATLASSERT( hwndDlg != NULL );

	//
	// Get the handle for the control.
	//
	HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hWndCtrl != NULL );

	ATLASSERT( ::GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP );
	ATLASSERT( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON );

	rnValue = -1;     // value if none found

	// walk all children in group
	int iButton = 0;
	do
	{
		if ( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON )
		{
			// control in group is a radio button
			if ( ::SendMessage( hWndCtrl, BM_GETCHECK, 0, 0L ) != 0 )
			{
				ASSERT( rnValue == -1 );    // only set once
				rnValue = iButton;
			} // if:  button is set
			iButton++;
		} // if:  control is a radio button
		else
		{
			ATLTRACE( _T("Warning: skipping non-radio button in group.\n") );
		} // else:  control is not a radio button
		hWndCtrl = ::GetWindow( hWndCtrl, GW_HWNDNEXT );

	} while ( hWndCtrl != NULL &&
		!(GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP) );

} //*** DDX_GetRadio()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_SetRadio
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		hwndDlg		[IN] Dialog window handle.
//		nIDC		[IN] Control ID of first radio button in a group.
//		nValue		[IN] Value to set.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_SetRadio( IN HWND hwndDlg, IN int nIDC, IN int nValue )
{
	ATLASSERT( hwndDlg != NULL );

	//
	// Get the handle for the control.
	//
	HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
	ATLASSERT( hWndCtrl != NULL );

	ATLASSERT( ::GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP );
	ATLASSERT( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON );

	// walk all children in group
	int iButton = 0;
	do
	{
		if ( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON )
		{
			// control in group is a radio button
			// select button
			::SendMessage( hWndCtrl, BM_SETCHECK, (iButton == nValue), 0L );
			iButton++;
		} // if:  control is a radio button
		else
		{
			ATLTRACE( _T("Warning: skipping non-radio button in group.\n") );
		} // else:  control is not a radio button
		hWndCtrl = ::GetWindow( hWndCtrl, GW_HWNDNEXT );

	} while (  (hWndCtrl != NULL)
			&& ! (GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP) );

} //*** DDX_SetRadio()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlutil.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlUtil.h
//
//	Abstract:
//		Definitions of helper functions for use in an ATL project.
//
//	Implementation File:
//		AtlUtils.cpp
//
//	Author:
//		David Potter (davidp)	December 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLUTIL_H_
#define __ATLUTIL_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

// Get a text value from a control on a dialog
BOOL DDX_GetText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT CString &	rstrValue
	);

// Set a text value into a control on a dialog
BOOL DDX_SetText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN const CString &	rstrValue
	);

// Set a text value into a combobox control on a dialog
BOOL DDX_SetComboBoxText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN const CString &	rstrValue,
	IN BOOL				bRequired = FALSE
	);

// Get a numeric value from a control on a dialog
BOOL DDX_GetNumber(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT ULONG &		rnValue,
	IN ULONG			nMin,
	IN ULONG			nMax,
	IN BOOL				bSigned
	);

// Get a numeric value from a control on a dialog
inline BOOL DDX_GetNumber(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT LONG &		rnValue,
	IN LONG				nMin,
	IN LONG				nMax
	)
{
	return DDX_GetNumber(
		hwndDlg,
		nIDC,
		reinterpret_cast< ULONG & >( rnValue ),
		static_cast< ULONG >( nMin ),
		static_cast< ULONG >( nMax ),
		TRUE /*bSigned*/
		);

} //*** DDX_GetNumber( LONG & )

// Set a numeric value into a control on a dialog dialog
BOOL DDX_SetNumber(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN ULONG			nValue,
	IN ULONG			nMin,
	IN ULONG			nMax,
	IN BOOL				bSigned
	);

// Validate that the dialog string is present
BOOL DDV_RequiredText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN int				nIDCLabel,
	IN const CString &	rstrValue
	);

// Get the value of a checkbox
void DDX_GetCheck( IN HWND hwndDlg, IN int nIDC, OUT int & rnValue );

// Set the value of a checkbox
void DDX_SetCheck( IN HWND hwndDlg, IN int nIDC, IN int nValue );

// Get the number of the radio button that is slected in a group
void DDX_GetRadio( IN HWND hwndDlg, IN int nIDC, OUT int & rnValue );

// Set the radio button states in a group
void DDX_SetRadio( IN HWND hwndDlg, IN int nIDC, IN int nValue );

// Remove ampersands and colons from a label
void CleanupLabel( IN OUT LPTSTR psz );

/////////////////////////////////////////////////////////////////////////////

#endif //__ATLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atllcpair.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlLCPair.cpp
//
//	Abstract:
//		Implementation of the CListCtrlPair class.
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlLCPair.h"
#include "AtlUtil.h"		// for DDX_xxx
#include "AdmCommonRes.h"	// for ADMC_IDC_LCP_xxx

/////////////////////////////////////////////////////////////////////////////
// class CListCtrlPair
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::BInitDialog
//
//	Routine Description:
//		Generic dialog initialization routine.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Dialog was initialized successfully.
//		FALSE	Error initializing the dialog.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
BOOL CListCtrlPair::BInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_lvcRight, ADMC_IDC_LCP_RIGHT_LIST );
	AttachControl( m_lvcLeft, ADMC_IDC_LCP_LEFT_LIST );
	AttachControl( m_pbAdd, ADMC_IDC_LCP_ADD );
	AttachControl( m_pbRemove, ADMC_IDC_LCP_REMOVE );
	if ( BPropertiesButton() )
	{
		AttachControl( m_pbProperties, ADMC_IDC_LCP_PROPERTIES );
	} // if:  dialog has Properties button

//	if ( BShowImages() )
//	{
//		CClusterAdminApp * papp = GetClusterAdminApp();
//
//		m_lvcLeft.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//		m_lvcRight.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//	} // if:  showing images

	//
	// Disable buttons by default.
	//
	m_pbAdd.EnableWindow( FALSE );
	m_pbRemove.EnableWindow( FALSE );
	if ( BPropertiesButton() )
	{
		m_pbProperties.EnableWindow( FALSE );
	} // if:  dialog has Properties button

	//
	// Set the right list to sort.  Set both to show selection always.
	//
	m_lvcRight.ModifyStyle( 0, LVS_SHOWSELALWAYS | LVS_SORTASCENDING, 0 );
	m_lvcLeft.ModifyStyle( 0, LVS_SHOWSELALWAYS, 0 );

	//
	// Change left list view control extended styles.
	//
	m_lvcLeft.SetExtendedListViewStyle(
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
		);

	//
	// Change right list view control extended styles.
	//
	m_lvcRight.SetExtendedListViewStyle(
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
		);

	// Duplicate lists.
	DuplicateLists();

	//
	// Insert all the columns.
	//
	{
		int			icol;
		int			ncol;
		int			nUpperBound = m_aColumns.size();
		CString		strColText;

		ATLASSERT( nUpperBound >= 0 );

		for ( icol = 0 ; icol <= nUpperBound ; icol++ )
		{
			strColText.LoadString( m_aColumns[icol].m_idsText );
			ncol = m_lvcLeft.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
			ATLASSERT( ncol == icol );
			ncol = m_lvcRight.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
			ATLASSERT( ncol == icol );
		} // for:  each column
	} // Insert all the columns

	//
	// Fill the list controls.
	//
	FillList( m_lvcRight, LpobjRight() );
	FillList( m_lvcLeft, LpobjLeft() );

	//
	// If read-only, set all controls to be either disabled or read-only.
	//
	if ( BReadOnly() )
	{
		m_lvcRight.EnableWindow( FALSE );
		m_lvcLeft.EnableWindow( FALSE );
	} // if:  sheet is read-only

	return TRUE;

} //*** CListCtrlPair::BInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
BOOL CListCtrlPair::OnSetActive( void )
{
	UINT	nSelCount;

	// Set the focus to the left list.
	m_lvcLeft.SetFocus();
	m_plvcFocusList = &m_lvcLeft;

	// Enable/disable the Properties button.
	nSelCount = m_lvcLeft.GetSelectedCount();
	if ( BPropertiesButton() )
	{
		m_pbProperties.EnableWindow( nSelCount == 1 );
	} // if:  dialog has Properties button

	// Enable or disable the other buttons.
	if ( ! BReadOnly() )
	{
		m_pbAdd.EnableWindow( nSelCount > 0 );
		nSelCount = m_lvcRight.GetSelectedCount();
		m_pbRemove.EnableWindow( nSelCount > 0 );
	} // if:  not read-only page

	return TRUE;

} //*** CListCtrlPair::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU method.
//
//	Arguments:
//		pWnd		Window in which the user right clicked the mouse.
//		point		Position of the cursor, in screen coordinates.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
LRESULT CListCtrlPair::OnContextMenu(
	IN UINT			uMsg,
	IN WPARAM		wParam,
	IN LPARAM		lParam,
	IN OUT BOOL &	bHandled
	)
{
	BOOL			bDisplayed	= FALSE;
	CMenu *			pmenu		= NULL;
	HWND			hWnd		= (HWND) wParam;
	WORD			xPos		= LOWORD( lParam );
	WORD			yPos		= HIWORD( lParam );
	CListViewCtrl *	plvc;
	CString			strMenuName;
	CWaitCursor		wc;

	//
	// If focus is not in a list control, don't handle the message.
	//
	if ( hWnd == m_lvcLeft.m_hWnd )
	{
		plvc = &m_lvcLeft;
	} // if:  context menu on left list
	else if ( hWnd == m_lvcRight.m_hWnd )
	{
		plvc = &m_lvcRight;
	} // else if:  context menu on right list
	else
	{
		bHandled = FALSE;
		return 0;
	} // else:  focus not in a list control
	ATLASSERT( plvc != NULL );

	//
	// If the properties button is not enabled, don't display a menu.
	//
	if ( ! BPropertiesButton() )
	{
		bHandled = FALSE;
		return 0;
	} // if:  no properties button

	//
	// Create the menu to display.
	//
	pmenu = new CMenu;
	if ( pmenu->CreatePopupMenu() )
	{
		UINT nFlags = MF_STRING;

		//
		// If there are no items in the list, disable the menu item.
		//
		if ( plvc->GetItemCount() == 0 )
		{
			nFlags |= MF_GRAYED;
		} // if:  no items in the list

		//
		// Add the Properties item to the menu.
		//
		strMenuName.LoadString( ADMC_ID_MENU_PROPERTIES );
		if ( pmenu->AppendMenu( nFlags, ADMC_ID_MENU_PROPERTIES, strMenuName ) )
		{
			m_plvcFocusList = plvc;
			bDisplayed = TRUE;
		} // if:  successfully added menu item
	}  // if:  menu created successfully

	if ( bDisplayed )
	{
		//
		// Display the menu.
		//
		if ( ! pmenu->TrackPopupMenu(
						TPM_LEFTALIGN | TPM_RIGHTBUTTON,
						xPos,
						yPos,
						m_hWnd
						) )
		{
		}  // if:  unsuccessfully displayed the menu
	}  // if:  there is a menu to display

	delete pmenu;
	return 0;

} //*** CListCtrlPair::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::OnColumnClickList
//
//	Routine Description:
//		Handler method for the LVN_COLUMNCLICK message on the left or
//		right list.
//
//	Arguments:
//		idCtrl		[IN] ID of control sending the message.
//		pnmh		[IN] Notify header.
//		bHandled	[IN OUT] Indicates if we handled or not.  Defaults to TRUE.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
void CListCtrlPair::OnColumnClickList(
	IN int			idCtrl,
	IN LPNMHDR		pnmh,
	IN OUT BOOL &	bHandled
	)
{
	NM_LISTVIEW *	pNMListView = (NM_LISTVIEW *) pnmh;
	SortInfo *		psi;

	if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
	{
		m_plvcFocusList = &m_lvcLeft;
		m_psiCur = &SiLeft();
	} // if:  column clicked in left list
	else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
	{
		m_plvcFocusList = &m_lvcRight;
		m_psiCur = &SiRight();
	} // else if:  column clicked in right list
	else
	{
		ATLASSERT( 0 );
		bHandled = FALSE;
		return 0;
	} // else:  column clicked in unknown list

	// Save the current sort column and direction.
	if ( pNMListView->iSubItem == psi->m_nColumn )
	{
		m_psiCur->m_nDirection ^= -1;
	} // if:  sorting same column again
	else
	{
		m_psiCur->m_nColumn = pNMListView->iSubItem;
		m_psiCur->m_nDirection = 0;
	} // else:  different column

	// Sort the list.
	if ( ! m_plvcFocusList->SortItems( CompareItems, (LPARAM) this ) )
	{
		ATLASSERT( 0 );
	} // if:  error sorting items

	*pResult = 0;

} //*** CListCtrlPair::OnColumnClickList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\atlpopuphelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		AtlPopusHelp.h
//
//	Implementation File:
//		None.
//
//	Description:
//		Definition of the CPopusHelp
//
//	Author:
//		Galen Barbee (galenb)	May 18, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLPOPUPHELP_H_
#define __ATLPOPUPHELP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID;
template < class T > class CPopupHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#include "AdmCommonRes.h"
#endif // __ADMCOMMONRES_H_

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// struct CMapCtrlToHelpID
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;

}; //*** struct CMapCtrlToHelpID

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CPopupHelp
//
//	Description:
//		Provide popup-help functionality.
//
//	Inheritance:
//		CPopupHelp
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CPopupHelp
{
	typedef CPopupHelp< T > thisClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CPopupHelp( void )
	{
	} //*** CPopupHelp()

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisclass )
		MESSAGE_HANDLER( WM_HELP, LrOnHelp )
		MESSAGE_HANDLER( WM_CONTEXTMENU, LrOnContextMenu )
	END_MSG_MAP()

	//
	// Message handler functions.
	//

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	LrOnContextMenu
	//
	//	Routine Description:
	//		Message handler for WM_CONTEXTMENU
	//
	//	Arguments:
	//		uMsg		[IN]	Message (WM_CONTEXT)
	//		wParam 		[IN]	Window handle of the control being queried
	//		lParam 		[IN]	Pointer coordinates.  LOWORD xPos, HIWORD yPos
	//		bHandled 	[OUT]
	//
	//	Return Value:
	//
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	LRESULT LrOnContextMenu(
		IN UINT		uMsg,
		IN WPARAM	wParam,
		IN LPARAM	lParam,
		OUT BOOL &	bHandled
		)
	{
		DWORD	nHelpID = 0;
		DWORD	nCtrlID = 0;
		CWindow	cwnd( (HWND) wParam );
		WORD	xPos = LOWORD( lParam );
		WORD	yPos = HIWORD( lParam );

		//
		// Only display help if the window is visible.
		//
		if ( cwnd.GetStyle() & WS_VISIBLE )
		{
			nCtrlID = cwnd.GetDlgCtrlID();
			if ( nCtrlID != 0 )
			{
				nHelpID = NHelpFromCtrlID( nCtrlID, reinterpret_cast< const CMapCtrlToHelpID * >( T::PidHelpMap() ) );
			} // if: control has an ID
		}  // if:  over a child window

		//
		// Display a popup menu.
		//
		if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
		{
			bHandled = BContextMenu( cwnd, nHelpID, xPos, yPos );

		}  // if:  over a child window of this dialog with a tabstop

		return 1L;

	} //*** LrOnContextMenu()

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	LrOnHelp
	//
	//	Routine Description:
	//		Message handler for WM_HELP.
	//
	//	Arguments:
	//		uMsg		[IN]	Message (WM_HELP)
	//		wParam 		[IN]
	//		lParam 		[IN]	pointer to a HELPINFO struct
	//		bHandled 	[OUT]
	//
	//	Return Value:
	//
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	LRESULT LrOnHelp(
		IN UINT		uMsg,
		IN WPARAM	wParam,
		IN LPARAM	lParam,
		OUT BOOL &	bHandled
		)
	{
		LPHELPINFO	phi = (LPHELPINFO) lParam;

		if ( phi->iContextType == HELPINFO_WINDOW )
		{
			DWORD	nHelpID = 0;

		 	nHelpID = NHelpFromCtrlID( phi->iCtrlId & 0xFFFF, (const CMapCtrlToHelpID *) T::PidHelpMap() );
			if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
			{
				T * 		pT   = static_cast< T * >( this );
				CBaseApp *	pbap = dynamic_cast< CBaseApp * >( &_Module );
				ATLASSERT( pbap != NULL );

				bHandled = pT->WinHelp( pbap->PszHelpFilePath(), HELP_CONTEXTPOPUP, nHelpID );
			}
		}

		return 1L;

	} //*** LrOnHelp()

protected:

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	NHelpFromCtrlID
	//
	//	Routine Description:
	//		Return the help ID from a control ID.
	//
	//	Arguments:
	//		nCtrlID		[IN] ID of control to search for.
	//
	//	Return Value:
	//		nHelpID		Help ID associated with the control.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	DWORD NHelpFromCtrlID(
		IN DWORD 					nCtrlID,
		IN const CMapCtrlToHelpID *	pMap
		) const
	{
		ASSERT( pMap != NULL );
		ASSERT( nCtrlID != 0 );

		DWORD	nHelpID = 0;

		for ( ; pMap->m_nCtrlID != 0 ; pMap++ )
		{
			if ( pMap->m_nCtrlID == nCtrlID )
			{
				nHelpID = pMap->m_nHelpCtrlID;
				break;
			}  // if:  found a match
		}  // for:  each control

		Trace( g_tagAlways, _T( "NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x" ), nCtrlID, nHelpID );

		return nHelpID;

	}  //*** NHelpFromCtrlID()

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	BContextMenu
	//
	//	Routine Description:
	//		Return the help ID from a control ID.
	//
	//	Arguments:
	//		cwnd		[IN]	- control's window
	//		nHelpID		[IN] 	- help context ID
	//		xPos		[IN] 	- xpos of the context menu
	//		yPos		[IN] 	- ypos of the context menu
	//
	//	Return Value:
	//		TRUE for success, FALSE for failure
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	BOOL BContextMenu(
		IN CWindow &	cwnd,
		IN DWORD		nHelpID,
		IN WORD			xPos,
		IN WORD			yPos
		)
	{
		CString	strMenu;
		CMenu	menu;
		BOOL	bRet = FALSE;

		//
		// The context menu key was pressed.  Get the current mouse position and use that
		//
		if ( ( xPos == 0xffff ) || ( yPos == 0xffff ) )
		{
			POINT	pPos;

			if ( GetCursorPos( &pPos ) )
			{
				xPos = pPos.x;
				yPos = pPos.y;
			} // if:  current cursor position retrieved successfully
		} // if:  context menu key was pressed

		if ( strMenu.LoadString( ADMC_ID_MENU_WHATS_THIS ) )
		{
			if ( menu.CreatePopupMenu() )
			{
				if ( menu.AppendMenu( MF_STRING | MF_ENABLED, ADMC_ID_MENU_WHATS_THIS, strMenu ) )
				{
					DWORD	nCmd;

					nCmd = menu.TrackPopupMenu(
						TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
						xPos,
						yPos,
						cwnd
						);

					if ( nCmd != 0 )
					{
						CBaseApp *	pbap = dynamic_cast< CBaseApp * >( &_Module );
						ATLASSERT( pbap != NULL );

						bRet = cwnd.WinHelp( pbap->PszHelpFilePath(), HELP_CONTEXTPOPUP, nHelpID );
					} // if: any command chosen
					else
					{
						Trace( g_tagError, _T( "OnContextMenu() - Last Error = %x" ), GetLastError() );
					} // else:  unknown command
				}  // if:  menu item added successfully
			}  // if:  popup menu created successfully
		} // if: string could be loaded

		return bRet;

	}  //*** BContextMenu()

}; //*** class CPopupHelp

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLPOPUPHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\clusobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ClusObj.cpp
//
//	Description:
//		Implementation of the CClusterObject classes.
//
//	Author:
//		David Potter (davidp)	September 15, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClusObj.h"
#include "AdmCommonRes.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusResInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResInfo::BRequiredDependenciesPresent
//
//	Routine Description:
//		Determine if the resource contains each required resource for this
//		type of resource.
//
//	Arguments:
//		plpri			[IN] List of resources.  Defaults to this resource's
//							dependency list.
//		rstrMissing		[OUT] String in which to return a missing resource
//							class name or type name.
//		rbMissingTypeName
//						[OUT] TRUE = missing resource type name
//							FALSE = missing resource class
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CString::LoadString() or CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusResInfo::BRequiredDependenciesPresent(
	IN CClusResPtrList const *	plpri,
	OUT CString &				rstrMissing,
	OUT BOOL &					rbMissingTypeName
	)
{
	ATLASSERT( Prti() != NULL );

	BOOL					bFound = TRUE;
	CLUSPROP_BUFFER_HELPER	buf;
	const CClusResInfo *	pri;

	// Loop to avoid goto's.
	do
	{
		//
		// We're done if there are no required dependencies.
		//
		if ( Prti()->Pcrd() == NULL )
		{
			break;
		} // if:  no required dependencies

		//
		// Default the list of resources if none specified.
		//
		if ( plpri == NULL )
		{
			plpri = PlpriDependencies();
		} // if:  no list of dependencies specified

		//
		// Get the list of required dependencies.
		//
		buf.pRequiredDependencyValue = Prti()->Pcrd();

		//
		// Loop through each required dependency and make sure
		// there is a dependency on a resource of that type.
		//
		for ( ; buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK
			  ; buf.pb += sizeof( *buf.pValue ) + ALIGN_CLUSPROP( buf.pValue->cbLength )
			  )
		{
			bFound = FALSE;
			CClusResPtrList::iterator itCurrent = plpri->begin();
			CClusResPtrList::iterator itLast = plpri->end();
			for ( ; itCurrent != itLast ; itCurrent++ )
			{
				pri = *itCurrent;

				//
				// If this is the right type, we've satisfied the
				// requirement so exit the loop.
				//
				if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS )
				{
					if ( buf.pResourceClassValue->rc == pri->ResClass() )
					{
						bFound = TRUE;
					}  // if:  match found
				}  // if:  resource class
				else if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_NAME )
				{
					if ( pri->Prti()->RstrName().CompareNoCase( buf.pStringValue->sz ) == 0 )
					{
						bFound = TRUE;
					}  // if:  match found
				}  // else if:  resource name
				if ( bFound )
				{
					break;
				} // if:  found a match
			}  // while:  more items in the list

			//
			// If a match was not found, changes cannot be applied.
			//
			if ( ! bFound )
			{
				if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS )
				{
					if ( ! rstrMissing.LoadString( ADMC_IDS_RESCLASS_UNKNOWN + buf.pResourceClassValue->rc ) )
					{
						rstrMissing.LoadString( ADMC_IDS_RESCLASS_UNKNOWN );
					} // if:  error loading specific class name
					rbMissingTypeName = FALSE;
				}  // if:  resource class not found
				else if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_NAME )
				{
					rstrMissing = buf.pStringValue->sz;
					rbMissingTypeName = TRUE;
				}  // else if:  resource type name not found
				break;
			}  // if:  not found

		}  // while:  more dependencies required
	} while ( 0 );

	return bFound;

}  //*** CClusResInfo::BRequiredDependenciesPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\cluadmexdataobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		CluAdmExDataObj.h
//
//	Implementation File:
//		CCluAdmExDataObject.cpp
//
//	Description:
//		Definition of the CCluAdmExDataObject class, which is the IDataObject
//		class used to transfer data between a cluster management tool and the
//		extension DLL handlers.
//
//	Author:
//		David Potter (davidp)	June 4, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUADMEXDATAOBJ_H_
#define __CLUADMEXDATAOBJ_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include "CluAdmEx.h"			// for IIDs
#endif

#ifndef __cluadmexhostsvr_h__
#include "CluAdmExHostSvr.h"	// for CLSIDs
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"			// for CClusterObject
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Declarations
/////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFGETRESOURCENETWORKNAME)(
					OUT BSTR lpszNetName,
					IN OUT DWORD * pcchNetName,
					IN OUT PVOID pvContext
					);

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExDataObject;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExDataObject
//
//	Description:
//		Encapsulates the IDataObject interface for exchanging data with
//		extension DLL handlers.
//
//	Inheritance:
//		CCluAdmExDataObject
//		CComObjectRootEx<>, CComCoClass<>, <interface classes>
//
//--
/////////////////////////////////////////////////////////////////////////////
class CCluAdmExDataObject :
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CCluAdmExDataObject, &CLSID_CoCluAdmExHostSvrData >,
	public ISupportErrorInfo,
	public IGetClusterUIInfo,
	public IGetClusterDataInfo,
	public IGetClusterObjectInfo,
	public IGetClusterNodeInfo,
	public IGetClusterGroupInfo,
	public IGetClusterResourceInfo,
	public IGetClusterNetworkInfo,
	public IGetClusterNetInterfaceInfo
{
public:
	//
	// Construction
	//

	// Default constructor
	CCluAdmExDataObject( void )
	{
		m_pco = NULL;
		m_lcid = NULL;
		m_hfont = NULL;
		m_hicon = NULL;

		m_pfGetResNetName = NULL;

//		m_pModuleState = AfxGetModuleState();
//		ATLASSERT( m_pModuleState != NULL );

	} //*** CCluAdmExDataObject()

	// Destructor
	virtual ~CCluAdmExDataObject( void )
	{
//		m_pModuleState = NULL;

	} //*** ~CCluAdmExDataObject()

	// Second-phase constructor.
	void Init(
		IN OUT CClusterObject *	pco,
		IN LCID					lcid,
		IN HFONT				hfont,
		IN HICON				hicon
		)
	{
		ATLASSERT( pco != NULL );
		ATLASSERT( pco->Pci() != NULL );
		ATLASSERT( pco->Pci()->Hcluster() != NULL );

		// Save parameters.
		m_pco = pco;
		m_lcid = lcid;
		m_hfont = hfont;
		m_hicon = hicon;

	} //*** Init()

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CCluAdmExDataObject )
		COM_INTERFACE_ENTRY( IGetClusterUIInfo )
		COM_INTERFACE_ENTRY( IGetClusterDataInfo )
		COM_INTERFACE_ENTRY( IGetClusterObjectInfo )
		COM_INTERFACE_ENTRY( IGetClusterNodeInfo )
		COM_INTERFACE_ENTRY( IGetClusterGroupInfo )
		COM_INTERFACE_ENTRY( IGetClusterResourceInfo )
		COM_INTERFACE_ENTRY( IGetClusterNetworkInfo )
		COM_INTERFACE_ENTRY( IGetClusterNetInterfaceInfo )
		COM_INTERFACE_ENTRY( ISupportErrorInfo )
	END_COM_MAP()

	DECLARE_NOT_AGGREGATABLE( CCluAdmExDataObject )

protected:
	//
	// Properties of this data object.
	//

	CClusterObject *	m_pco;			// Cluster object being extended.
	LCID				m_lcid;			// Locale ID of resources to be loaded by extension.
	HFONT				m_hfont;		// Font for all text.
	HICON				m_hicon;		// Icon for upper left corner.

	PFGETRESOURCENETWORKNAME	m_pfGetResNetName;			// Pointer to static function for getting net name for resource.
	PVOID						m_pvGetResNetNameContext;	// Context for m_pfGetResNetName;

	static const IID * s_rgiid[];		// Array of interface IDs supported by this class.

	//
	// Accessor methods.
	//

	HCLUSTER Hcluster( void ) const
	{
		ATLASSERT( m_pco != NULL );
		ATLASSERT( m_pco->Pci() != NULL );

		return m_pco->Pci()->Hcluster();

	} //*** Hcluster()

	CClusterObject *	Pco( void ) const		{ return m_pco; }
	LCID				Lcid( void ) const		{ return m_lcid; }
	HFONT				Hfont( void ) const		{ return m_hfont; }
	HICON				Hicon( void ) const		{ return m_hicon; }

public:
	PFGETRESOURCENETWORKNAME PfGetResNetName( void ) const { return m_pfGetResNetName; }

	// Set the function pointer for getting the resource name
	void SetPfGetResNetName( PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext )
	{
		m_pfGetResNetName = pfGetResNetName;
		m_pvGetResNetNameContext = pvContext;

	} //*** SetPfGetResNetName()

public:
	//
	// ISupportsErrorInfo methods.
	//

	// Determine if interface supports IErrorInfo
	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid )
	{
		const IID ** piid;

		for ( piid = s_rgiid ; *piid != NULL ; piid++ )
		{
			if ( InlineIsEqualGUID( **piid, riid ) )
			{
				return S_OK;
			} // if:  matching IID found
		}
		return S_FALSE;

	} //*** InterfaceSupportsErrorInfo()

public:
	//
	// IGetClusterUIInfo methods.
	//

	// Get the locale of the running program
	STDMETHOD_( LCID, GetLocale )( void )
	{
		return Lcid();

	} //*** GetLocale()

	// Get the font to use for text on property pages
	STDMETHOD_( HFONT, GetFont )( void )
	{
		return Hfont();

	} //*** GetFont()

	// Get the icon to use for the upper left corner
	STDMETHOD_( HICON, GetIcon )( void )
	{
		return Hicon();

	} //*** GetIcon()

public:
	//
	// IGetClusterDataInfo methods.
	//

	// Get the name of the cluster
	STDMETHOD( GetClusterName )(
		OUT BSTR		lpszName,
		IN OUT LONG *	pcchName
		)
	{
		ATLASSERT( Pco() != NULL );
		ATLASSERT( Pco()->Pci() != NULL );

		HRESULT hr;

		//
		// Validate parameters.
		//
		if ( pcchName == NULL )
		{
			return E_INVALIDARG;
		}

		//
		// Copy the name to the caller's buffer.
		//
		hr = GetStringProperty(
				Pco()->Pci()->RstrName(),
				lpszName,
				pcchName
				);

		return hr;

	} //*** GetClusterName()

	// Get a handle to the cluster
	STDMETHOD_( HCLUSTER, GetClusterHandle )( void )
	{
		return Hcluster();

	} //*** GetClusterHandle()

	// Get the number of objects currently selected
	STDMETHOD_( LONG, GetObjectCount )( void )
	{
		//
		// We only support one selected object at a time for now.
		//
		return 1;

	} //*** GetObjectCount()

public:
	//
	// IGetClusterObjectInfo methods.
	//

	// Get the name of the object at the specified index
	STDMETHOD( GetObjectName )(
		IN LONG			nObjIndex,
		OUT BSTR		lpszName,
		IN OUT LONG *	pcchName
		)
	{
		ATLASSERT( Pco() != NULL );

		HRESULT hr;

		//
		// Validate parameters.
		// We only support one selected object at a time for now.
		//
		if ( (nObjIndex != 0) || (pcchName == NULL) )
		{
			return E_INVALIDARG;
		} // if:  wrong object index or no count buffer

		//
		// Copy the name to the caller's buffer.
		//
		hr = GetStringProperty(
				Pco()->RstrName(),
				lpszName,
				pcchName
				);

		return hr;

	} //*** GetObjectName()

	// Get the type of the object at the specified index
	STDMETHOD_( CLUADMEX_OBJECT_TYPE, GetObjectType )(
		IN LONG nObjIndex
		)
	{
		ATLASSERT( Pco() != NULL );

		//
		// Validate parameters.
		// We only support one selected object at a time for now.
		//
		if ( nObjIndex == 1 )
		{
			SetLastError( (DWORD) E_INVALIDARG );
			return (CLUADMEX_OBJECT_TYPE) -1;
		}  // if:  invalid argument

		return Pco()->Cot();

	} //*** GetObjectType()

public:
	//
	// IGetClusterNodeInfo methods.
	//

	// Get the handle to the node at the specified index
	STDMETHOD_( HNODE, GetNodeHandle )(
		IN LONG nObjIndex
		)
	{
		ATLASSERT( Pco() != NULL );

		//
		// Validate parameters.
		// We only support one selected object at a time for now.
		//
		if (   (nObjIndex == 1)
			|| (Pco()->Cot() != CLUADMEX_OT_NODE) )
		{
			SetLastError( (DWORD) E_INVALIDARG );
			return NULL;
		}  // if:  invalid argument

		CClusNodeInfo * pni = reinterpret_cast< CClusNodeInfo * >( Pco() );
		return pni->Hnode();

	} //*** GetNodeHandle()

public:
	//
	// IGetClusterGroupInfo methods.
	//

	// Get the handle to the group at the specified index
	STDMETHOD_( HGROUP, GetGroupHandle )(
		IN LONG nObjIndex
		)
	{
		ATLASSERT( Pco() != NULL );

		//
		// Validate parameters.
		// We only support one selected object at a time for now.
		//
		if (   (nObjIndex == 1)
			|| (Pco()->Cot() != CLUADMEX_OT_GROUP) )
		{
			SetLastError( (DWORD) E_INVALIDARG );
			return NULL;
		}  // if:  invalid argument

		CClusGroupInfo * pgi = reinterpret_cast< CClusGroupInfo * >( Pco() );
		return pgi->Hgroup();

	} //*** GetGroupHandle()

public:
	//
	// IGetClusterResourceInfo methods.
	//

	// Get the handle to the resource at the specified index
	STDMETHOD_( HRESOURCE, GetResourceHandle )(
		IN LONG nObjIndex
		)
	{
		ATLASSERT( Pco() != NULL );

		//
		// Validate parameters.
		// We only support one selected object at a time for now.
		//
		if (   (nObjIndex == 1)
			|| (Pco()->Cot() != CLUADMEX_OT_RESOURCE) )
		{
			SetLastError( (DWORD) E_INVALIDARG );
			return NULL;
		}  // if:  invalid argument

		CClusResInfo * pri = reinterpret_cast< CClusResInfo * >( Pco() );
		return pri->Hresource();

	} //*** GetResourceHandle()

	// Get the type of the resource at the specified index
	STDMETHOD( GetResourceTypeName )(
		IN LONG			nObjIndex,
		OUT BSTR		lpszResourceTypeName,
		IN OUT LONG *	pcchResTypeName
		)
	{
		ATLASSERT( Pco() != NULL );

		HRESULT			hr;
		CClusResInfo *	pri = reinterpret_cast< CClusResInfo * >( Pco() );

		//
		// Validate parameters.
		// We only support one selected object at a time for now.
		//
		if (   (nObjIndex != 0)
			|| (pcchResTypeName == NULL)
			|| (Pco()->Cot() != CLUADMEX_OT_RESOURCE) )
		{
			return E_INVALIDARG;
		}  // if:  invalid argument

		//
		// Copy the name to the caller's buffer.
		//
		ATLASSERT( pri->Prti() != NULL );
		hr = GetStringProperty(
				pri->Prti()->RstrName(),
				lpszResourceTypeName,
				pcchResTypeName
				);

		return hr;

	} //*** GetResourceTypeName()

	// Get the network name for the resource at the specified index
	STDMETHOD_( BOOL, GetResourceNetworkName )(
		IN LONG			nObjIndex,
		OUT BSTR		lpszNetName,
		IN OUT ULONG *	pcchNetName
		)
	{
		ATLASSERT( Pco() != NULL );

		BOOL			bSuccess = FALSE;
		CClusResInfo *	pri = reinterpret_cast< CClusResInfo * >( Pco() );

		try
		{
			//
			// Validate parameters.
			// We only support one selected object at a time for now.
			//
			if (   (nObjIndex != 0)
				|| (pcchNetName == NULL)
				|| (*pcchNetName < MAX_COMPUTERNAME_LENGTH)
				|| (Pco()->Cot() != CLUADMEX_OT_RESOURCE) )
			{
				SetLastError( (DWORD) E_INVALIDARG );
				return FALSE;
			}  // if:  invalid argument

			//
			// If there is a function for getting this information, call it.
			// Otherwise, handle it ourselves.
			//
			if ( PfGetResNetName() != NULL )
			{
				bSuccess = (*PfGetResNetName())( lpszNetName, pcchNetName, m_pvGetResNetNameContext );
			} // if:  function specified for getting this info
			else
			{
				bSuccess = pri->BGetNetworkName( lpszNetName, pcchNetName );
			} // if:  no function specified for getting this info
		} // try
		catch (...)
		{
			bSuccess = FALSE;
			SetLastError( (DWORD) E_INVALIDARG );
		}  // catch:  anything

		return bSuccess;

	} //*** GetResourceNetworkName()

public:
	//
	// IGetClusterNetworkInfo methods.
	//

	// Get the handle to the network at the specified index
	STDMETHOD_( HNETWORK, GetNetworkHandle )(
		IN LONG nObjIndex
		)
	{
		ATLASSERT( Pco() != NULL );

		// Validate parameters.
		// We only support one selected object at a time for now.
		if (   (nObjIndex == 1)
			|| (Pco()->Cot() != CLUADMEX_OT_NETWORK) )
		{
			SetLastError( (DWORD) E_INVALIDARG );
			return NULL;
		}  // if:  invalid argument

		CClusNetworkInfo * pni = reinterpret_cast< CClusNetworkInfo * >( Pco() );
		return pni->Hnetwork();

	} //*** GetNetworkHandle()

public:
	//
	// IGetClusterNetInterfaceInfo methods.
	//

	// Get the handle to the network interface at the specified index
	STDMETHOD_( HNETINTERFACE, GetNetInterfaceHandle )(
		IN LONG nObjIndex
		)
	{
		ATLASSERT( Pco() != NULL );

		// Validate parameters.
		// We only support one selected object at a time for now.
		if (   (nObjIndex == 1)
			|| (Pco()->Cot() != CLUADMEX_OT_NETINTERFACE) )
		{
			SetLastError( (DWORD) E_INVALIDARG );
			return NULL;
		}  // if:  invalid argument

		CClusNetIFInfo * pnii = reinterpret_cast< CClusNetIFInfo * >( Pco() );
		return pnii->Hnetinterface();

	} //*** GetNetInterfaceHandle()

// Implementation
protected:
//	AFX_MODULE_STATE *			m_pModuleState;			// Required for resetting our state during callbacks.

	// Get a string property
	STDMETHOD( GetStringProperty )(
		IN const CString &	rstrNameSource,
		OUT BSTR			lpszName,
		IN OUT LONG *		pcchName
		)
	{
		ATLASSERT( pcchName != NULL );

		LONG	cchName = 0;
		LPWSTR	pszReturn;

		//
		// Save the length to copy.
		//
		try
		{
			cchName = *pcchName;
			*pcchName = rstrNameSource.GetLength() + 1;
		} // try
		catch (...)
		{
			return E_INVALIDARG;
		}  // catch:  anything

		//
		// If only the length is being requested, return it now.
		//
		if ( lpszName == NULL )
		{
			return NOERROR;
		} // if:  no name buffer specified

		//
		// If a buffer is specified and it is too small, return an error.
		//
		if ( cchName < *pcchName )
		{
			return ERROR_MORE_DATA;
		} // if:  buffer too small

		//
		// Copy the data.
		//
		pszReturn = lstrcpyW( lpszName, rstrNameSource );
		if ( pszReturn == NULL )
		{
			return E_INVALIDARG;
		} // if:  error copying data

		return NOERROR;

	} //*** GetStringProperty()

};  //*** class CCluAdmExDataObject

/////////////////////////////////////////////////////////////////////////////
// Class Data
/////////////////////////////////////////////////////////////////////////////
_declspec( selectany ) const IID * CCluAdmExDataObject::s_rgiid[] = 
{
	&IID_IGetClusterDataInfo,
	&IID_IGetClusterObjectInfo,
	&IID_IGetClusterNodeInfo,
	&IID_IGetClusterGroupInfo,
	&IID_IGetClusterResourceInfo,
	&IID_IGetClusterNetworkInfo,
	&IID_IGetClusterNetInterfaceInfo,
	NULL
};

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUADMEXDATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\clusobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ClusObj.h
//
//	Implementation File:
//		ClusObj.h (this file) and ClusObj.cpp
//
//	Description:
//		Definition of the CClusterObject classes.
//
//	Author:
//		David Potter (davidp)	April 7, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSOBJ_H_
#define __CLUSOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;
class CClusterInfo;
class CClusNodeInfo;
class CClusGroupInfo;
class CClusResInfo;
class CClusResTypeInfo;
class CClusNetworkInfo;
class CClusNetIFInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _LIST_
#include <list>			// for std::list
#endif

#ifndef _CLUSTER_API_
#include <ClusApi.h>	// for cluster types
#endif

#ifndef __cluadmex_h__
#include "CluAdmEx.h"	// for CLUADMEX_OBJECT_TYPE
#endif

#ifndef _CLUSUDEF_H_
#include "ClusUDef.h"	// for default values
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef std::list< CClusterObject * >	CClusObjPtrList;
typedef std::list< CClusterInfo * >		CClusterPtrList;
typedef std::list< CClusNodeInfo * >	CClusNodePtrList;
typedef std::list< CClusGroupInfo * >	CClusGroupPtrList;
typedef std::list< CClusResInfo * >		CClusResPtrList;
typedef std::list< CClusResTypeInfo * >	CClusResTypePtrList;
typedef std::list< CClusNetworkInfo * >	CClusNetworkPtrList;
typedef std::list< CClusNetIFInfo * >	CClusNetIFPtrList;

union CLUSTER_REQUIRED_DEPENDENCY
{
	CLUSTER_RESOURCE_CLASS	rc;
	LPWSTR					pszTypeName;
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusterObject
//
//	Description:
//		Base class for all cluster object classes.  Provides base
//		functionality.
//
//	Inheritance:
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusterObject( IN CLUADMEX_OBJECT_TYPE cot )
	{
		ATLASSERT( cot > CLUADMEX_OT_NONE );

		m_nReferenceCount = 0;
		Reset( NULL, NULL, cot );

	} //*** CClusterObject()

	// Constructor taking group name
	CClusterObject(
		IN CLUADMEX_OBJECT_TYPE	cot,
		IN CClusterInfo *		pci,
		IN LPCTSTR				pszName
		)
	{
		ATLASSERT( cot > CLUADMEX_OT_NONE );

		m_nReferenceCount = 0;
		Reset( pci, pszName, cot );

	} //*** CClusterObject(pszName)

	virtual ~CClusterObject( void )
	{
	} //*** ~CClusterObject()

	// Copy another object into this one.
	void Copy( IN const CClusterObject & rco )
	{
		m_pci = rco.m_pci;
		m_bQueried = rco.m_bQueried;
		m_bCreated = rco.m_bCreated;
		m_cot = rco.m_cot;
		m_strName = rco.m_strName;
		m_strDescription = rco.m_strDescription;

	} //*** Copy()

	// Reset the data back to default values
	void Reset(
		IN CClusterInfo *		pci,
		IN LPCTSTR				pszName = NULL,
		IN CLUADMEX_OBJECT_TYPE	cot = CLUADMEX_OT_NONE
		)
	{
		m_pci = pci;

		m_bQueried = FALSE;
		m_bCreated = FALSE;

		if ( cot != CLUADMEX_OT_NONE )
		{
			m_cot = cot;
		} // if:  valid object type specified

		if ( pszName == NULL )
		{
			m_strName.Empty();
		} // if:  no name specified
		else
		{
			m_strName = pszName;
		} // else:  name specified

		m_strDescription.Empty();

	} //*** Reset()

protected:
	//
	// Reference counting properties.
	//

	ULONG		m_nReferenceCount;

public:
	//
	// Reference counting methods.
	//

	// Get the current count of references
	ULONG NReferenceCount( void ) const { return m_nReferenceCount; }

	// Add a reference to this object
	ULONG AddRef( void )
	{
		ATLASSERT( m_nReferenceCount != (ULONG) -1 );
		return ++m_nReferenceCount;

	} //*** AddRef()

	// Release a reference to this object
	ULONG Release( void )
	{
		ULONG nReferenceCount;

		ATLASSERT( m_nReferenceCount != 0 );

		nReferenceCount = --m_nReferenceCount;
		if ( m_nReferenceCount == 0 )
		{
			delete this;
		} // if:  no more references

		return nReferenceCount;

	} //*** Release()

protected:
	//
	// Properties of a cluster object.
	//

	CClusterInfo *	m_pci;

	BOOL			m_bQueried;
	BOOL			m_bCreated;

	CLUADMEX_OBJECT_TYPE
					m_cot;

	CString			m_strName;
	CString			m_strDescription;

	// Set query state
	BOOL BSetQueried( BOOL bQueried = TRUE )
	{
		BOOL bPreviousValue = m_bQueried;
		m_bQueried = bQueried;
		return bPreviousValue;

	} //*** BSetQueried()

	// Set created state
	BOOL BSetCreated( BOOL bCreated = TRUE )
	{
		BOOL bPreviousValue = m_bCreated;
		m_bCreated = bCreated;
		return bPreviousValue;

	} //*** BSetCreated()

public:
	//
	// Accessor functions for cluster object properties.
	//

	CClusterInfo *	Pci( void ) const				{ ATLASSERT( m_pci != NULL ); return m_pci; }

	BOOL BQueried( void ) const						{ return m_bQueried; }
	BOOL BCreated( void ) const						{ return m_bCreated; }

	CLUADMEX_OBJECT_TYPE Cot( void ) const			{ return m_cot; }

	const CString & RstrName( void ) const			{ return m_strName; }
	const CString & RstrDescription( void ) const	{ return m_strDescription; }

	// Set the cluster info pointer
	void SetClusterInfo( IN CClusterInfo * pci )
	{
		ATLASSERT( pci != NULL );
		ATLASSERT( m_pci == NULL );
		m_pci = pci;

	} //*** SetClusterInfo()

	// Set the name of the cluster object.
	void SetName( IN LPCTSTR pszName )
	{
		ATLASSERT( pszName != NULL );
		m_strName = pszName;

	} //*** SetName()

	// Set the description of the cluster object
	void SetDescription( IN LPCTSTR pszDescription )
	{
		ATLASSERT( pszDescription != NULL );
		m_strDescription = pszDescription;

	} //*** SetDescription()

	// Return the list of extensions for this object
	virtual const std::list< CString > * PlstrAdminExtensions( void ) const { return NULL; }

}; //*** class CClusterObject

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusterInfo
//
//	Description:
//		Class for the information about the cluster object itself.  Treats
//		the cluster as an object like other objects.
//
//	Inheritance:
//		CClusterInfo
//		CClusterObject
//
//	Notes:
//		1)  m_hCluster is not owned by this class.
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusterInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusterInfo( void )
		: CClusterObject( CLUADMEX_OT_CLUSTER )
	{
		Reset();

	} //*** CClusterInfo()

	// Constructor taking cluster name
	CClusterInfo( IN LPCTSTR pszName )
		: CClusterObject( CLUADMEX_OT_CLUSTER, NULL, pszName )
	{
		Reset( pszName );

	} //*** CClusterInfo( pszName )

	// Copy another object into this one.
	void Copy( IN const CClusterInfo & rci )
	{
		CClusterObject::Copy( rci );
		m_hCluster = rci.m_hCluster;

	} //*** Copy()

	// Reset the data back to default values
	void Reset( IN LPCTSTR pszName = NULL )
	{
		CClusterObject::Reset( NULL, pszName, CLUADMEX_OT_CLUSTER );
		m_hCluster = NULL;

	} //*** Reset()

protected:
	//
	// Properties of a cluster.
	//

	HCLUSTER m_hCluster;
	std::list< CString >	m_lstrClusterAdminExtensions;
	std::list< CString >	m_lstrNodesAdminExtensions;
	std::list< CString >	m_lstrGroupsAdminExtensions;
	std::list< CString >	m_lstrResourcesAdminExtensions;
	std::list< CString >	m_lstrResTypesAdminExtensions;
	std::list< CString >	m_lstrNetworksAdminExtensions;
	std::list< CString >	m_lstrNetInterfacesAdminExtensions;

public:
	//
	// Accessor functions for cluster properties.
	//

	HCLUSTER Hcluster( void )
	{
		ATLASSERT( m_hCluster != NULL );
		return m_hCluster;

	} //*** Hcluster()

	// Set the cluster handle managed by this object
	void SetClusterHandle( IN HCLUSTER hCluster )
	{
		ATLASSERT( hCluster != NULL );
		m_hCluster = hCluster;

	} //*** SetClusterHandle()

	const std::list< CString > * PlstrAdminExtensions( void ) const					{ return &m_lstrClusterAdminExtensions; }
	const std::list< CString > * PlstrNodesAdminExtensions( void ) const			{ return &m_lstrNodesAdminExtensions; }
	const std::list< CString > * PlstrGroupsAdminExtensions( void ) const			{ return &m_lstrGroupsAdminExtensions; }
	const std::list< CString > * PlstrResourcesAdminExtensions( void ) const		{ return &m_lstrResourcesAdminExtensions; }
	const std::list< CString > * PlstrResTypesAdminExtensions( void ) const			{ return &m_lstrResTypesAdminExtensions; }
	const std::list< CString > * PlstrNetworksAdminExtensions( void ) const			{ return &m_lstrNetworksAdminExtensions; }
	const std::list< CString > * PlstrNetInterfacesAdminExtensions( void ) const	{ return &m_lstrNetInterfacesAdminExtensions; }

}; //*** class CClusterInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNodeInfo
//
//	Description:
//		Cluster node object.
//
//	Inheritance:
//		CClusNodeInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusNodeInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusNodeInfo( void )
		: CClusterObject( CLUADMEX_OT_NODE )
		, m_hNode( NULL )
	{
		Reset( NULL );

	} //*** CClusNodeInfo()

	// Constructor taking cluster info pointer
	CClusNodeInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_NODE, pci, pszName )
		, m_hNode( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusNodeInfo( pci )

	~CClusNodeInfo( void )
	{
		Close();

	} //*** ~CClusNodeInfo()

	// Operator = is not allowed
	CClusNodeInfo & operator=( IN const CClusNodeInfo & rni )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_NODE );

	} //*** Reset()

protected:
	//
	// Properties of a node.
	//

	HNODE m_hNode;

public:
	//
	// Accessor functions for node properties.
	//

	HNODE Hnode( void ) { return m_hNode; }

	// Return the list of extensions for nodes
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrNodesAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hNode == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hNode = OpenClusterNode( m_pci->Hcluster(), m_strName );
		if ( m_hNode == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusNodeInfo & rni )
	{
		ATLASSERT( rni.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rni );

		//
		// Initialize the object.
		//
		if ( rni.m_hNode != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object opened

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		if ( m_hNode != NULL )
		{
			CloseClusterNode( m_hNode );
		} // if:  node is open
		m_hNode = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusNodeInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusGroupInfo
//
//	Description:
//		Cluster group object.
//
//	Inheritance:
//		CClusGroupInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusGroupInfo( void )
		: CClusterObject( CLUADMEX_OT_GROUP )
		, m_hGroup( NULL )
	{
		Reset( NULL );

	} //*** CClusGroupInfo()

	// Constructor taking cluster info pointer
	CClusGroupInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_GROUP, pci, pszName )
		, m_hGroup( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusGroupInfo( pci )

	// Destructor
	~CClusGroupInfo( void )
	{
		Close();

	} //*** ~CClusGroupInfo()

	// Operator = is not allowed
	CClusGroupInfo & operator=( IN const CClusGroupInfo & rgi )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_GROUP );

		m_bCollectedOwners = FALSE;
		m_bCollectedResources = FALSE;

		m_lpniPreferredOwners.erase( m_lpniPreferredOwners.begin(), m_lpniPreferredOwners.end() );
		m_lpriResources.erase( m_lpriResources.begin(), m_lpriResources.end() );

		m_bHasIPAddress = FALSE;
		m_bHasNetName = FALSE;

		m_nPersistentState = 0;
		m_nFailoverThreshold = CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD;
		m_nFailoverPeriod = CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD;
		m_cgaftAutoFailbackType = CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE;
		m_nFailbackWindowStart = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START;
		m_nFailbackWindowEnd = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END;

	} //*** Reset()

protected:
	//
	// Properties of a group.
	//

	HGROUP				m_hGroup;

	BOOL				m_bHasIPAddress;
	BOOL				m_bHasNetName;

	DWORD				m_nPersistentState;
	DWORD				m_nFailoverThreshold;
	DWORD				m_nFailoverPeriod;
	CGAFT				m_cgaftAutoFailbackType;
	DWORD				m_nFailbackWindowStart;
	DWORD				m_nFailbackWindowEnd;

	CString				m_strNetworkName;
	CString				m_strIPAddress;
	CString				m_strNetwork;

	BOOL				m_bCollectedOwners;
	BOOL				m_bCollectedResources;
	CClusNodePtrList	m_lpniPreferredOwners;
	CClusResPtrList		m_lpriResources;

	// Set virtual server properties
	void SetVirtualServerProperties(
		IN LPCWSTR pszNetworkName,
		IN LPCWSTR pszIPAddress,
		IN LPCWSTR pszNetwork
		)
	{
		if ( pszNetworkName != NULL )
		{
			m_strNetworkName = pszNetworkName;
		} // if:  network name specified

		if ( pszIPAddress != NULL )
		{
			m_strIPAddress = pszIPAddress;
		} // if:  IP address specified

		if ( pszNetwork != NULL )
		{
			m_strNetwork = pszNetwork;
		} // if:  network specified

	} //*** SetVirtualServerProperties()

public:
	//
	// Accessor functions for group properties.
	//

	HGROUP Hgroup( void ) const					{ return m_hGroup; }

	BOOL BHasIPAddress( void ) const			{ return m_bHasIPAddress; }
	BOOL BHasNetName( void ) const				{ return m_bHasNetName; }

	DWORD NPersistentState( void ) const		{ return m_nPersistentState; }
	DWORD NFailoverThreshold( void ) const		{ return m_nFailoverThreshold; }
	DWORD NFailoverPeriod( void ) const			{ return m_nFailoverPeriod; }
	CGAFT CgaftAutoFailbackType( void ) const	{ return m_cgaftAutoFailbackType; }
	DWORD NFailbackWindowStart( void ) const	{ return m_nFailbackWindowStart; }
	DWORD NFailbackWindowEnd( void ) const		{ return m_nFailbackWindowEnd; }

	const CString & RstrNetworkName( void ) const	{ return m_strNetworkName; }
	const CString & RstrIPAddress( void ) const		{ return m_strIPAddress; }
	const CString & RstrNetwork( void ) const		{ return m_strNetwork; }

	BOOL BCollectedOwners( void ) const				{ return m_bCollectedOwners; }
	CClusNodePtrList * PlpniPreferredOwners( void )	{ return &m_lpniPreferredOwners; }
	CClusResPtrList * PlpriResources( void )		{ return &m_lpriResources; }

	// Returns whether the group is a virtual server or not
	BOOL BIsVirtualServer( void ) const
	{
		return m_bQueried && m_bHasIPAddress & m_bHasNetName;

	} //*** BIsVirtualServer()

	// Set failover properties for the group
	BOOL BSetFailoverProperties(
		IN DWORD nFailoverThreshold,
		IN DWORD nFailoverPeriod
		)
	{
		BOOL bChanged = FALSE;

		if ( m_nFailoverThreshold != nFailoverThreshold )
		{
			m_nFailoverThreshold = nFailoverThreshold;
			bChanged = TRUE;
		} // if:  threshold changed

		if ( m_nFailoverPeriod != nFailoverPeriod )
		{
			m_nFailoverPeriod = nFailoverPeriod;
			bChanged = TRUE;
		} // if:  period changed

		return bChanged;

	} //*** BSetFailoverProperties()

	// Set failback properties for the group
	BOOL BSetFailbackProperties(
		IN CGAFT cgaft,
		IN DWORD nFailbackWindowStart,
		IN DWORD nFailbackWindowEnd
		)
	{
		BOOL bChanged = FALSE;

		if ( m_cgaftAutoFailbackType != cgaft )
		{
			m_cgaftAutoFailbackType = cgaft;
			bChanged = TRUE;
		} // if:  autofailback type changed

		if ( m_nFailbackWindowStart != nFailbackWindowStart )
		{
			m_nFailbackWindowStart = nFailbackWindowStart;
			bChanged = TRUE;
		} // if:  failback start window changed

		if ( m_nFailbackWindowEnd != nFailbackWindowEnd )
		{
			m_nFailbackWindowEnd = nFailbackWindowEnd;
			bChanged = TRUE;
		} // if:  failback end window changed

		return bChanged;

	} //*** BSetFailbackProperties()

	// Return the list of extensions for groups
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrGroupsAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hGroup == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hGroup = OpenClusterGroup( m_pci->Hcluster(), m_strName );
		if ( m_hGroup == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Create the object
	DWORD ScCreate( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hGroup == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Create the object.
		//
		m_hGroup = CreateClusterGroup( m_pci->Hcluster(), m_strName );
		if ( m_hGroup == NULL )
		{
			sc = GetLastError();
		} // if:  error creating the object

		return sc;

	} //*** ScCreate()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusGroupInfo & rgi )
	{
		ATLASSERT( rgi.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rgi );

		m_bHasIPAddress = rgi.m_bHasIPAddress;
		m_bHasNetName = rgi.m_bHasNetName;
		m_nPersistentState = rgi.m_nPersistentState;
		m_nFailoverThreshold = rgi.m_nFailoverThreshold;
		m_nFailoverPeriod = rgi.m_nFailoverPeriod;
		m_cgaftAutoFailbackType = rgi.m_cgaftAutoFailbackType;
		m_nFailbackWindowStart = rgi.m_nFailbackWindowStart;
		m_nFailbackWindowEnd = rgi.m_nFailbackWindowEnd;

		//
		// Copy the preferred owners and resources lists.
		//
		m_lpniPreferredOwners = rgi.m_lpniPreferredOwners;
		m_lpriResources = rgi.m_lpriResources;

		//
		// Initialize the object.
		//
		if ( rgi.m_hGroup != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Delete the object
	DWORD ScDelete( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_hGroup != NULL );

		DWORD sc = ERROR_SUCCESS;

		sc = DeleteClusterGroup( m_hGroup );
		if ( sc == ERROR_SUCCESS )
		{
			Close();
			m_bCreated = FALSE;
		} // if:  objected deleted successfully

		return sc;

	} //*** ScDelete()

	// Close the object
	void Close( void )
	{
		if ( m_hGroup != NULL )
		{
			CloseClusterGroup( m_hGroup );
		} // if:  group is open
		m_hGroup = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusGroupInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypeInfo
//
//	Description:
//		Cluster resource type object.
//
//	Inheritance:
//		CClusResTypeInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusResTypeInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusResTypeInfo( void )
		: CClusterObject( CLUADMEX_OT_RESOURCETYPE )
		, m_pcrd( NULL )
	{
		Reset( NULL );

	} //*** CClusResTypeInfo()

	// Constructor taking cluster info pointer
	CClusResTypeInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_RESOURCETYPE, pci, pszName )
		, m_pcrd( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusResTypeInfo( pci )

	// Destructor
	~CClusResTypeInfo( void )
	{
		Close();

		delete [] m_pcrd;
		m_pcrd = NULL;

	} //*** ~CClusGroupInfo()

	// Operator = is not allowed
	CClusResTypeInfo & operator=( IN const CClusResTypeInfo & rrti )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_RESOURCETYPE );

		m_strDisplayName.Empty();
		m_strResDLLName.Empty();

		m_lstrAdminExtensions.erase( m_lstrAdminExtensions.begin(), m_lstrAdminExtensions.end() );
		m_lstrAllAdminExtensions.erase( m_lstrAllAdminExtensions.begin(), m_lstrAllAdminExtensions.end() );
		m_lstrResourceAdminExtensions.erase( m_lstrResourceAdminExtensions.begin(), m_lstrResourceAdminExtensions.end() );

		m_nLooksAlive = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
		m_nIsAlive = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
		m_rciResClassInfo.rc = CLUS_RESCLASS_UNKNOWN;
		m_rciResClassInfo.SubClass = 0;
		m_fCharacteristics = CLUS_CHAR_UNKNOWN;
		m_fFlags = 0;

		delete [] m_pcrd;
		m_pcrd = NULL;

	} //*** Reset()

protected:
	//
	// Properties of a resource type.
	//

	CString						m_strDisplayName;
	CString						m_strResDLLName;

	std::list< CString >		m_lstrAdminExtensions;
	std::list< CString >		m_lstrAllAdminExtensions;
	std::list< CString >		m_lstrResourceAdminExtensions;

	DWORD						m_nLooksAlive;
	DWORD						m_nIsAlive;
	CLUS_RESOURCE_CLASS_INFO	m_rciResClassInfo;
	DWORD						m_fCharacteristics;
	DWORD						m_fFlags;

	CLUSPROP_REQUIRED_DEPENDENCY *	m_pcrd;

public:
	//
	// Accessor functions for resource type properties
	//

	const CString & RstrDisplayName( void ) const	{ return m_strDisplayName; }
	const CString & RstrResDLLName( void ) const	{ return m_strResDLLName; }

	// Return list of extensions for this resource type
	const std::list< CString > * PlstrAdminExtensions( void )
	{
		//
		// If not done already, construct the complete list of extensions
		// from the extensions for this resource type and the extensions
		// for all resource types.
		//
		if ( m_lstrAllAdminExtensions.size() == 0 )
		{
			ATLASSERT( Pci() != NULL );
			m_lstrAllAdminExtensions = m_lstrAdminExtensions;
			m_lstrAllAdminExtensions.insert(
				m_lstrAllAdminExtensions.end(),
				Pci()->PlstrResTypesAdminExtensions()->begin(),
				Pci()->PlstrResTypesAdminExtensions()->end()
				);
		} // if:  full list not constructed yet

		return &m_lstrAllAdminExtensions;

	} //*** PlstrAdminExtensions()

	// Return list of extensions for resources of this type
	const std::list< CString > * PlstrResourceAdminExtensions( void )
	{
		//
		// If not done already, construct the complete list of extensions
		// from the extensions for this resource type and the extensions
		// for all resources.
		//
		if ( m_lstrResourceAdminExtensions.size() == 0 )
		{
			ATLASSERT( Pci() != NULL );
			m_lstrResourceAdminExtensions = m_lstrAdminExtensions;
			m_lstrResourceAdminExtensions.insert(
				m_lstrResourceAdminExtensions.end(),
				Pci()->PlstrResourcesAdminExtensions()->begin(),
				Pci()->PlstrResourcesAdminExtensions()->end()
				);
		} // if:  full list not constructed yet

		return &m_lstrResourceAdminExtensions;

	} //*** PlstrAdminExtensions()

	DWORD NLooksAlive( void ) const						{ return m_nLooksAlive; }
	DWORD NIsAlive( void ) const						{ return m_nIsAlive; }
	DWORD FCharacteristics( void ) const				{ return m_fCharacteristics; }
	DWORD FFlags( void ) const							{ return m_fFlags; }

	CLUS_RESOURCE_CLASS_INFO *	PrciResClassInfo( void )	{ return &m_rciResClassInfo; }
	CLUSTER_RESOURCE_CLASS		ResClass( void ) const		{ return m_rciResClassInfo.rc; }

	CLUSPROP_REQUIRED_DEPENDENCY * Pcrd( void )			{ return m_pcrd; }

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		return sc;

	} //*** ScOpen()

	// Create the object
	DWORD ScCreate( IN HGROUP hGroup, IN DWORD dwFlags )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_strName.GetLength() > 0 );
		ATLASSERT( m_strDisplayName.GetLength() > 0 );
		ATLASSERT( m_strResDLLName.GetLength() > 0 );
		ATLASSERT( m_nLooksAlive != 0 );
		ATLASSERT( m_nIsAlive != 0 );

		DWORD sc;

		//
		// Create the object.
		//
		sc = CreateClusterResourceType(
			Pci()->Hcluster(),
			m_strName,
			m_strDisplayName,
			m_strResDLLName,
			m_nLooksAlive,
			m_nIsAlive
			);

		return sc;

	} //*** ScCreate()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusResTypeInfo & rrti )
	{
		ATLASSERT( rrti.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rrti );

		m_strDisplayName = rrti.m_strDisplayName;
		m_strResDLLName = rrti.m_strResDLLName;

		m_lstrAdminExtensions = m_lstrAdminExtensions;
		m_lstrResourceAdminExtensions = rrti.m_lstrResourceAdminExtensions;

		m_nLooksAlive = rrti.m_nLooksAlive;
		m_nIsAlive = rrti.m_nIsAlive;
		m_rciResClassInfo.rc = rrti.m_rciResClassInfo.rc;
		m_rciResClassInfo.SubClass = rrti.m_rciResClassInfo.SubClass;
		m_fCharacteristics = rrti.m_fCharacteristics;
		m_fFlags = rrti.m_fFlags;

		//
		// Initialize the object.
		//
		// sc = ScOpen();

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		// Dummy function to support similar semantics as other objects.
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close();

}; //*** class CClusResTypeInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResInfo
//
//	Description:
//		Cluster resource object.
//
//	Inheritance:
//		CClusResInfo
//		CClusterObject
//
//	Notes:
//		1)	Must appear after definition of CClusResTypeInfo because
//			CClusResTypeInfo methods are referenced in this class's methods.
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusResInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusResInfo( void )
		: CClusterObject( CLUADMEX_OT_RESOURCE )
		, m_hResource( NULL )
	{
		Reset( NULL );

	} //*** CClusResInfo()

	// Constructor taking cluster info pointer
	CClusResInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_RESOURCE, pci, pszName )
		, m_hResource( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusResInfo( pci )

	~CClusResInfo( void )
	{
		Close();

	} //*** ~CClusResInfo()

	// Operator = is not allowed
	CClusResInfo & operator=( IN const CClusResInfo & rri )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_RESOURCE );

		m_prti = NULL;
		m_pgi = NULL;
		m_pniOwner = NULL;

		m_bCollectedOwners = FALSE;
		m_bCollectedDependencies = FALSE;

		m_lpniPossibleOwners.erase( m_lpniPossibleOwners.begin(), m_lpniPossibleOwners.end() );
		m_lpriDependencies.erase( m_lpriDependencies.begin(), m_lpriDependencies.end() );

		m_bSeparateMonitor = FALSE;
		m_nPersistentState = 0;
		m_nLooksAlive = CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE;
		m_nIsAlive = CLUSTER_RESOURCE_DEFAULT_IS_ALIVE;
		m_crraRestartAction = CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION;
		m_nRestartThreshold = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
		m_nRestartPeriod = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
		m_nPendingTimeout = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;

	} //*** Reset()

protected:
	//
	// Properties of a resource.
	//

	HRESOURCE			m_hResource;

	CClusResTypeInfo *	m_prti;
	CClusGroupInfo *	m_pgi;
	CClusNodeInfo *		m_pniOwner;

	BOOL				m_bSeparateMonitor;
	DWORD				m_nPersistentState;
	DWORD				m_nLooksAlive;
	DWORD				m_nIsAlive;
	CRRA				m_crraRestartAction;
	DWORD				m_nRestartThreshold;
	DWORD				m_nRestartPeriod;
	DWORD				m_nPendingTimeout;

	BOOL				m_bCollectedOwners;
	BOOL				m_bCollectedDependencies;
	CClusNodePtrList	m_lpniPossibleOwners;
	CClusResPtrList		m_lpriDependencies;

public:
	//
	// Accessor functions for resource properties
	//

	HRESOURCE Hresource( void ) const { return m_hResource; }

	CClusResTypeInfo * Prti( void ) const	{ ATLASSERT( m_prti != NULL ); return m_prti; }
	CClusGroupInfo * Pgi( void ) const		{ ATLASSERT( m_pgi != NULL ); return m_pgi; }
	CClusNodeInfo * PniOwner( void ) const	{ ATLASSERT( m_pniOwner != NULL ); return m_pniOwner; }

	BOOL BSeparateMonitor( void ) const		{ return m_bSeparateMonitor; }
	DWORD NPersistentState( void ) const	{ return m_nPersistentState; }
	DWORD NLooksAlive( void ) const			{ return m_nLooksAlive; }
	DWORD NIsAlive( void ) const			{ return m_nIsAlive; }
	CRRA CrraRestartAction( void ) const	{ return m_crraRestartAction; }
	DWORD NRestartThreshold( void ) const	{ return m_nRestartThreshold; }
	DWORD NRestartPeriod( void ) const		{ return m_nRestartPeriod; }
	DWORD NPendingTimeout( void ) const		{ return m_nPendingTimeout; }

	BOOL BCollectedOwners( void ) const			{ return m_bCollectedOwners; }
	BOOL BCollectedDependencies( void ) const	{ return m_bCollectedDependencies; }
	CClusNodePtrList *	PlpniPossibleOwners( void )	{ return &m_lpniPossibleOwners; }
	CClusResPtrList *	PlpriDependencies( void )	{ return &m_lpriDependencies; }

	CLUSTER_RESOURCE_CLASS ResClass( void ) const	{ return Prti()->ResClass(); }

	// Set the group
	void SetGroup( IN CClusGroupInfo * pgi )
	{
		ATLASSERT( pgi != NULL );

		m_pgi = pgi;

	} //*** SetGroup()

	// Set the resource type of the resource
	BOOL BSetResourceType( IN CClusResTypeInfo * prti )
	{
		ATLASSERT( prti != NULL );

		BOOL bChanged = FALSE;

		//
		// If the resource type changed, set it.
		//
		if ( m_prti != prti )
		{
			m_prti = prti;
			bChanged = TRUE;
		} // if:  resource type changed

		return bChanged;

	} //*** BSetResourceType()

	// Set the separate monitor property for the resource
	BOOL BSetSeparateMonitor( IN BOOL bSeparateMonitor )
	{
		BOOL bChanged = FALSE;

		if ( m_bSeparateMonitor != bSeparateMonitor )
		{
			m_bSeparateMonitor = bSeparateMonitor;
			bChanged = TRUE;
		} // if:  separate monitor changed

		return bChanged;

	} //*** BSetSeparateMonitor()

	// Set advanced properties for the resource
	BOOL BSetAdvancedProperties(
		IN CRRA crra,
		IN DWORD nRestartThreshold,
		IN DWORD nRestartPeriod,
		IN DWORD nLooksAlive,
		IN DWORD nIsAlive,
		IN DWORD nPendingTimeout
		)
	{
		BOOL bChanged = FALSE;

		if ( m_crraRestartAction != crra )
		{
			m_crraRestartAction = crra;
			bChanged = TRUE;
		} // if:  restart action changed

		if ( m_nRestartThreshold != nRestartThreshold )
		{
			m_nRestartThreshold = nRestartThreshold;
			bChanged = TRUE;
		} // if:  restart threshold changed

		if ( m_nRestartPeriod != nRestartPeriod )
		{
			m_nRestartPeriod = nRestartPeriod;
			bChanged = TRUE;
		} // if:  restart period changed

		if ( m_nLooksAlive != nLooksAlive )
		{
			m_nLooksAlive = nLooksAlive;
			bChanged = TRUE;
		} // if:  looks alive period changed

		if ( m_nIsAlive != nIsAlive )
		{
			m_nIsAlive = nIsAlive;
			bChanged = TRUE;
		} // if:  is alive period changed

		if ( m_nPendingTimeout != nPendingTimeout )
		{
			m_nPendingTimeout = nPendingTimeout;
			bChanged = TRUE;
		} // if:  pending timeout changed

		return bChanged;

	} //*** BSetAdvancedProperties()

	// Return the list of extensions for resources
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( m_prti != NULL );
		return m_prti->PlstrResourceAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hResource == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hResource = OpenClusterResource( m_pci->Hcluster(), m_strName );
		if ( m_hResource == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Create the object
	DWORD ScCreate( IN HGROUP hGroup, IN DWORD dwFlags )
	{
		ATLASSERT( hGroup != NULL );
		ATLASSERT( Prti() != NULL );
		ATLASSERT( Prti()->RstrName().GetLength() > 0 );
		ATLASSERT( m_hResource == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		m_bSeparateMonitor = ( dwFlags & CLUSTER_RESOURCE_SEPARATE_MONITOR ) == CLUSTER_RESOURCE_SEPARATE_MONITOR;

		//
		// Create the object.
		//
		m_hResource = CreateClusterResource( hGroup, m_strName, Prti()->RstrName(), dwFlags );
		if ( m_hResource == NULL )
		{
			sc = GetLastError();
		} // if:  error creating the object

		return sc;

	} //*** ScCreate()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusResInfo & rri )
	{
		ATLASSERT( rri.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rri );

		m_prti = rri.m_prti;
		m_pgi = rri.m_pgi;
		m_pniOwner = rri.m_pniOwner;

		m_bSeparateMonitor = rri.m_bSeparateMonitor;
		m_nPersistentState = rri.m_nPersistentState;
		m_nLooksAlive = rri.m_nLooksAlive;
		m_nIsAlive = rri.m_nIsAlive;
		m_crraRestartAction = rri.m_crraRestartAction;
		m_nRestartThreshold = rri.m_nRestartThreshold;
		m_nRestartPeriod = rri.m_nRestartPeriod;
		m_nPendingTimeout = rri.m_nPendingTimeout;

		//
		// Copy the possible owners and dependencies lists.
		//
		m_lpniPossibleOwners = rri.m_lpniPossibleOwners;
		m_lpriDependencies = rri.m_lpriDependencies;

		//
		// Initialize the object.
		//
		if ( rri.m_hResource != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Delete the object
	DWORD ScDelete( void )
	{
		ATLASSERT( m_hResource != NULL );

		DWORD sc = ERROR_SUCCESS;

		sc = DeleteClusterResource( m_hResource );
		if ( sc == ERROR_SUCCESS )
		{
			Close();
			m_bCreated = FALSE;
		} // if:  objected deleted successfully

		return sc;

	} //*** ScDelete()

	// Close the object
	void Close( void )
	{
		if ( m_hResource != NULL )
		{
			CloseClusterResource( m_hResource );
		} // if:  resource is open
		m_hResource = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

	// Get network name of first Network Name resource we are dependent on
	BOOL BGetNetworkName(
		OUT WCHAR *		lpszNetName,
		IN OUT DWORD *	pcchNetName
		)
	{
		ATLASSERT( m_hResource != NULL );
		ATLASSERT( lpszNetName != NULL );
		ATLASSERT( pcchNetName != NULL );

		return GetClusterResourceNetworkName(
					m_hResource,
					lpszNetName,
					pcchNetName
					);

	} //*** BGetNetworkName()

	// Determine whether required dependencies are specified or not
	BOOL BRequiredDependenciesPresent(
		IN CClusResPtrList const *	plpri,
		OUT CString &				rstrMissing,
		OUT BOOL &					rbMissingTypeName
		);

}; //*** class CClusResInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetworkInfo
//
//	Description:
//		Cluster network object.
//
//	Inheritance:
//		CClusNetworkInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusNetworkInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusNetworkInfo( void )
		: CClusterObject( CLUADMEX_OT_NETWORK )
		, m_hNetwork( NULL )
	{
		Reset( NULL );

	} //*** CClusNetworkInfo()

	// Constructor taking cluster info pointer
	CClusNetworkInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_NETWORK, pci, pszName )
		, m_hNetwork( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusNetworkInfo( pci )

	~CClusNetworkInfo( void )
	{
		Close();

	} //*** ~CClusterNetworkInfo()

	// Operator = is not allowed
	CClusNetworkInfo & operator=( IN const CClusNetworkInfo & rni )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_NETWORK );

		m_nRole = ClusterNetworkRoleNone;
		m_strAddress.Empty();
		m_strAddressMask.Empty();

		m_nAddress = 0;
		m_nAddressMask = 0;

	} //*** Reset()

protected:
	//
	// Properties of a network.
	//

	HNETWORK				m_hNetwork;

	CLUSTER_NETWORK_ROLE	m_nRole;
	CString					m_strAddress;
	CString					m_strAddressMask;

	DWORD					m_nAddress;
	DWORD					m_nAddressMask;

public:
	//
	// Accessor functions for network properties
	//

	HNETWORK Hnetwork( void ) const					{ return m_hNetwork; }

	CLUSTER_NETWORK_ROLE NRole( void ) const		{ return m_nRole; }
	const CString & RstrAddress( void ) const		{ return m_strAddress; }
	const CString & RstrAddressMask( void ) const	{ return m_strAddressMask; }

	DWORD NAddress( void ) const					{ return m_nAddress; }
	DWORD NAddressMask( void ) const				{ return m_nAddressMask; }

	// Returns whether the network is used for client access
	BOOL BIsClientNetwork( void ) const
	{
		return m_bQueried && (m_nRole & ClusterNetworkRoleClientAccess);

	} //*** BIsClientNetwork()

	// Returns whether the network is used for internal cluster use
	BOOL BIsInternalNetwork( void ) const
	{
		return m_bQueried && (m_nRole & ClusterNetworkRoleInternalUse);

	} //*** BIsInternalNetwork()

	// Return the list of extensions for networks
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrNetworksAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hNetwork == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hNetwork = OpenClusterNetwork( m_pci->Hcluster(), m_strName );
		if ( m_hNetwork == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusNetworkInfo & rni )
	{
		ATLASSERT( rni.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rni );

		m_nRole = rni.m_nRole;
		m_strAddress = rni.m_strAddress;
		m_strAddressMask = rni.m_strAddressMask;

		m_nAddress = rni.m_nAddress;
		m_nAddressMask = rni.m_nAddressMask;

		//
		// Initialize the object.
		//
		if ( rni.m_hNetwork != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		if ( m_hNetwork != NULL )
		{
			CloseClusterNetwork( m_hNetwork );
		} // if:  network is open
		m_hNetwork = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusNetworkInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetIFInfo
//
//	Description:
//		Cluster network interface object.
//
//	Inheritance:
//		CClusNetIFInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusNetIFInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusNetIFInfo( void )
		: CClusterObject( CLUADMEX_OT_NETINTERFACE )
		, m_hNetInterface( NULL )
	{
		Reset( NULL );

	} //*** CClusNetworkInfo()

	// Constructor taking cluster info pointer
	CClusNetIFInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_NETINTERFACE, pci, pszName )
		, m_hNetInterface( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusNetIFInfo( pci )

	~CClusNetIFInfo( void )
	{
		Close();

	} //*** ~CClusNetIFInfo()

	// Operator = is not allowed
	CClusNetIFInfo & operator=( IN const CClusNetIFInfo & rnii )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_NETINTERFACE );

	} //*** Reset()

protected:
	//
	// Properties of a network interface.
	//

	HNETINTERFACE m_hNetInterface;

public:
	//
	// Accessor functions for network properties
	//

	HNETINTERFACE Hnetinterface( void ) const { return m_hNetInterface; }

	// Return the list of extensions for network interfaces
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrNetInterfacesAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hNetInterface == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hNetInterface = OpenClusterNetInterface( m_pci->Hcluster(), m_strName );
		if ( m_hNetInterface == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusNetIFInfo & rnii )
	{
		ATLASSERT( rnii.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rnii );

		//
		// Initialize the object.
		//
		if ( rnii.m_hNetInterface != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		if ( m_hNetInterface != NULL )
		{
			CloseClusterNetInterface( m_hNetInterface );
		} // if:  network interface is open
		m_hNetInterface = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusNetIFInfo

/////////////////////////////////////////////////////////////////////////////
// Global Template Functions
/////////////////////////////////////////////////////////////////////////////

// Delete all list items from a pointer list
template < class ListT, class ObjT >
void DeleteListItems( ListT * ppl )
{
	ListT::iterator it;
	for ( it = ppl->begin() ; it != ppl->end() ; it++ )
	{
		ObjT * pco = *it;
		delete pco;
	} // for:  each item in the list

} //*** DeleteListItems< ListT, ObjT >()

// Retrieve an object from a list by its name
template < class ObjT >
ObjT PobjFromName( std::list< ObjT > * pList, IN LPCTSTR pszName )
{
	ATLASSERT( pList != NULL );
	ATLASSERT( pszName != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< ObjT >::iterator itCurrent = pList->begin();
	std::list< ObjT >::iterator itLast = pList->end();

	//
	// Loop through the list looking for the object with the specified name.
	//
	while ( itCurrent != itLast )
	{
		if ( (*itCurrent)->RstrName() == pszName )
		{
			return *itCurrent;
		} // if:  found a match
		itCurrent++;
	} // while:  more items in the list

	return NULL;

} //*** PobjFromName< ObjT >()

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUSOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\cluswrap.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//  Module Name:
//      ClusWrap.h
//
//  Description:
//      Wrapper functions for Cluster APIs.
//
//  Author:
//      Galen Barbee    (galenb)    15-Aug-1998
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#ifndef __CLUSWRAP_H
#define __CLUSWRAP_H

#include "clusapi.h"

#define CLUS_DEFAULT_TIMEOUT    10000

//////////////////////////////////////////////////////////////////////////
// Standard cluster API wrappers.
//////////////////////////////////////////////////////////////////////////

DWORD WINAPI WrapGetClusterInformation(
    IN HCLUSTER                         hCluster,
    OUT LPWSTR *                        ppwszClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO   pClusterInfo
    );

DWORD WINAPI WrapGetClusterQuorumResource(
    IN HCLUSTER     hCluster,
    OUT LPWSTR *    ppwszResourceName,
    OUT LPWSTR *    ppwszDeviceName,
    OUT LPDWORD     pdwMaxQuorumLogSize
    );

DWORD WINAPI WrapClusterEnum(
    IN HCLUSENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    plpwszName
    );

DWORD WINAPI WrapGetClusterNodeId(
    IN HNODE        hNode,
    OUT LPWSTR *    ppwszNodeId
    );

CLUSTER_GROUP_STATE WINAPI WrapGetClusterGroupState(
    IN HGROUP                   hGroup,
    OUT OPTIONAL    LPWSTR *    ppwszNodeName = NULL
    );

DWORD WINAPI WrapClusterGroupEnum(
    IN HGROUPENUM   hGroupEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszGroupName
    );

DWORD WINAPI WrapClusterNodeEnum(
    IN HNODEENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszNodeName
    );

DWORD WINAPI WrapClusterNetworkEnum(
    IN HNETWORKENUM hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszNetworkName
    );

CLUSTER_RESOURCE_STATE WINAPI WrapGetClusterResourceState(
    IN HRESOURCE            hResource,
    OUT OPTIONAL LPWSTR *   ppwszNodeName,
    OUT OPTIONAL LPWSTR *   ppwszGroupName
    );

DWORD WINAPI WrapClusterResourceEnum(
    IN HRESENUM     hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszResourceName
    );

DWORD WINAPI WrapClusterResourceTypeEnum(
    IN HRESTYPEENUM hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszResTyoeName
    );

HRESULT HrWrapOnlineClusterResource(
    HCLUSTER    hCluster,
    HRESOURCE   hResource,
    DWORD       nWait = 0,
    long *      pbPending = NULL
    );

DWORD ScWrapOnlineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapOfflineClusterResource(
    HCLUSTER    hCluster,
    HRESOURCE   hResource,
    DWORD       nWait = 0,
    long *      pbPending = NULL
    );

DWORD ScWrapOfflineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapMoveClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapMoveClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

////////////////////////////////////////////////////////////////////
// Custom helper functions/classes/etc.
////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNotifyPort
//
//  Description:
//      This class is a wrapper for the cluster notify port
//
//  Inheritance:
//      CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusterNotifyPort
{
public:
    CClusterNotifyPort();
    ~CClusterNotifyPort();

    DWORD Create(
            HCHANGE     hChange = (HCHANGE) INVALID_HANDLE_VALUE,
            HCLUSTER    hCluster = (HCLUSTER) INVALID_HANDLE_VALUE,
            DWORD       dwFilter = 0,
            DWORD_PTR   dwNotifyKey = 0
            );

    DWORD Close();

    DWORD Register( DWORD dwFilterType, HANDLE hObject, DWORD_PTR dwNotifyKey = 0 );

    DWORD GetNotify();

    DWORD_PTR   m_dwNotifyKey;
    DWORD       m_dwFilterType;
    WCHAR*      m_szName;
    DWORD       m_cchName;

protected:
    HCHANGE m_hChange;

}; //*** class CClusterNotifyPort

#endif __CLUSWRAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Abstract:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>
#include <resapi.h>
#include "DDxDDv.h"
#include "AdmCommonRes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel(LPTSTR psz);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT(pDX != NULL);
#ifdef _DEBUG
	if (bSigned)
	{
		ASSERT((LONG) dwMin < (LONG) dwMax);
	}
	else
	{
		ASSERT(dwMin < dwMax);
	}
#endif // _DEBUG

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl(nIDC);

	if (pDX->m_bSaveAndValidate)
	{
		BOOL	bTranslated;

		// Get the number from the control.
		dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);

		// If the retrival failed, it is a signed number, and the minimum
		// value is the smallest negative value possible, check the string itself.
		if (!bTranslated && bSigned && (dwMin == 0x80000000))
		{
			UINT	cch;
			TCHAR	szNumber[20];

			// See if it is the smallest negative number.
			cch = GetDlgItemText(pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof(szNumber) / sizeof(TCHAR));
			if ((cch != 0) && (lstrcmp(szNumber, _T("-2147483648")) == 0))
			{
				dwValue = 0x80000000;
				bTranslated = TRUE;
			}  // if:  text retrieved successfully and is highest negative number
		}  // if:  error translating number and getting signed number

		// If the retrieval failed or the specified number is
		// out of range, display an error.
		if (   !bTranslated
			|| (bSigned && (((LONG) dwValue < (LONG) dwMin) || ((LONG) dwValue > (LONG) dwMax)))
			|| (!bSigned && ((dwValue < dwMin) || (dwValue > dwMax)))
			)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			CString strPrompt;

			if (bSigned)
			{
				wsprintf(szMin, _T("%d%"), dwMin);
				wsprintf(szMax, _T("%d%"), dwMax);
			}  // if:  signed number
			else
			{
				wsprintf(szMin, _T("%u%"), dwMin);
				wsprintf(szMax, _T("%u%"), dwMax);
			}  // else:  unsigned number
			AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		}  // if:  invalid string
		else
			rdwValue = dwValue;
	}  // if:  saving data
	else
	{
		CString		strMinValue;
		CString		strMaxValue;
		UINT		cchMax;

		// Set the maximum number of characters that can be entered.
		if (bSigned)
		{
			strMinValue.Format(_T("%d"), dwMin);
			strMaxValue.Format(_T("%d"), dwMax);
		}  // if:  signed value
		else
		{
			strMinValue.Format(_T("%u"), dwMin);
			strMaxValue.Format(_T("%u"), dwMax);
		}  // else:  unsigned value
		cchMax = max(strMinValue.GetLength(), strMaxValue.GetLength());
		SendMessage(hwndCtrl, EM_LIMITTEXT, cchMax, 0);

		// Set the value into the control.
		if (bSigned)
		{
			LONG lValue = (LONG) rdwValue;
			DDX_Text(pDX, nIDC, lValue);
		}  // if:  signed value
		else
			DDX_Text(pDX, nIDC, rdwValue);
	}  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	if (pDX->m_bSaveAndValidate)
	{
		if (rstrValue.GetLength() == 0)
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			CleanupLabel(szLabel);

			// Format and display a message.
			strPrompt.FormatMessage(ADMC_IDS_REQUIRED_FIELD_EMPTY, szLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  field not specified
	}  // if:  saving data

}  //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_Path
//
//	Routine Description:
//		Validate that the path string contains valid characters.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Path to validate.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_Path(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	if (pDX->m_bSaveAndValidate)
	{
		if (!ResUtilIsPathValid(rstrValue))
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			CleanupLabel(szLabel);

			// Format and display a message.
			strPrompt.FormatMessage(ADMC_IDS_PATH_IS_INVALID, szLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  path is invalid
	}  // if:  saving data

}  //*** DDV_Path()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupLabel
//
//	Routine Description:
//		Prepare a label read from a dialog to be used as a string in a
//		message by removing ampersands (&) and colons (:).
//
//	Arguments:
//		pszLabel	[IN OUT] Label to be cleaned up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel(LPTSTR pszLabel)
{
	LPTSTR	pIn, pOut;
	LANGID	langid;
	WORD	primarylangid;
	BOOL	bFELanguage;

	// Get the language ID.
	langid = GetUserDefaultLangID();
	primarylangid = (WORD) PRIMARYLANGID(langid);
	bFELanguage = ((primarylangid == LANG_JAPANESE)
					|| (primarylangid == LANG_CHINESE)
					|| (primarylangid == LANG_KOREAN));

	//
	// copy the name sans '&' and ':' chars
	//

	pIn = pOut = pszLabel;
	do
	{
		//
		// strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
		//
		if (   bFELanguage
			&& (pIn[0] == _T('('))
			&& (pIn[1] == _T('&'))
			&& (pIn[2] != _T('\0'))
			&& (pIn[3] == _T(')')))
		{
			pIn += 3;
		}
		else if ((*pIn != _T('&')) && (*pIn != _T(':')))
			*pOut++ = *pIn;
	} while (*pIn++ != _T('\0')) ;

}  //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\cluswrap.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)1997-2001 Microsoft Corporation
//
//  Module Name:
//      ClusWrap.cpp
//
//  Description:
//      Wrapper functions for Cluster APIs.
//
//  Author:
//      Galen Barbee    (galenb)    15-Aug-1998
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <clusapi.h>
#include "cluswrap.h"

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterInformation
//
//  Description:
//      Wraps the GetClusterInformation function.
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapGetClusterInformation(
    IN HCLUSTER                         hCluster,
    OUT LPWSTR *                        ppszClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO   pClusterInfo
    )
{
    DWORD   dwStatus;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameter.
    if ( ppszClusterName != NULL )
    {
        *ppszClusterName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = GetClusterInformation( hCluster, pwszName, &cchTempName, pClusterInfo );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = GetClusterInformation( hCluster, pwszName, &cchTempName, pClusterInfo );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppszClusterName != NULL ) )
    {
        *ppszClusterName = pwszName;
    }

    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppszClusterName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapGetClusterInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterQuorumResource
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapGetClusterQuorumResource(
    IN  HCLUSTER    hCluster,
    OUT LPWSTR *    ppwszResourceName,
    OUT LPWSTR *    ppwszDeviceName,
    OUT LPDWORD     pdwMaxQuorumLogSize
    )
{
    DWORD   dwStatus;
    LPWSTR  pwszResourceName = NULL;
    DWORD   cchResourceName = 128;
    DWORD   cchTempResourceName = cchResourceName;
    LPWSTR  pwszDeviceName = NULL;
    DWORD   cchDeviceName = 128;
    DWORD   cchTempDeviceName = cchDeviceName;
    DWORD   dwMaxQuorumLogSize = 0;

    // Zero the out parameters
    if ( ppwszResourceName != NULL )
    {
        *ppwszResourceName = NULL;
    }

    if ( ppwszDeviceName != NULL )
    {
        *ppwszDeviceName = NULL;
    }

    if ( pdwMaxQuorumLogSize != NULL )
    {
        *pdwMaxQuorumLogSize = 0;
    }

    // Allocate the resource name buffer
    pwszResourceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchResourceName * sizeof( *pwszResourceName ) );
    if ( pwszResourceName != NULL )
    {
        // Allocate the device name buffer
        pwszDeviceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchDeviceName * sizeof( *pwszDeviceName ) );
        if ( pwszDeviceName != NULL )
        {
            dwStatus = GetClusterQuorumResource( hCluster,
                                                 pwszResourceName,
                                                 &cchTempResourceName,
                                                 pwszDeviceName,
                                                 &cchTempDeviceName,
                                                 &dwMaxQuorumLogSize );
            if ( dwStatus == ERROR_MORE_DATA )
            {
                LocalFree( pwszResourceName );
                pwszResourceName = NULL;

                cchResourceName = ++cchTempResourceName;
                // Allocate the resource name buffer
                pwszResourceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchResourceName * sizeof( *pwszResourceName ) );
                if ( pwszResourceName != NULL )
                {
                    LocalFree( pwszDeviceName );
                    pwszDeviceName = NULL;

                    cchDeviceName = ++cchTempDeviceName;
                    // Allocate the device name buffer
                    pwszDeviceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchDeviceName * sizeof( *pwszDeviceName ) );
                    if ( pwszDeviceName != NULL )
                    {
                        dwStatus = GetClusterQuorumResource( hCluster,
                                                             pwszResourceName,
                                                             &cchTempResourceName,
                                                             pwszDeviceName,
                                                             &cchTempDeviceName,
                                                             &dwMaxQuorumLogSize );
                    }
                    else
                    {
                        dwStatus = GetLastError();
                    }
                }
                else
                {
                    dwStatus = GetLastError();
                }
            }
        }
        else
        {
            dwStatus = GetLastError();
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszResourceName != NULL ) )
    {
        *ppwszResourceName = pwszResourceName;
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszDeviceName != NULL ) )
    {
        *ppwszDeviceName = pwszDeviceName;
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwMaxQuorumLogSize != NULL ) )
    {
        *pdwMaxQuorumLogSize = dwMaxQuorumLogSize;
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszResourceName == NULL ) )
    {
        LocalFree( pwszResourceName );
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszDeviceName == NULL ) )
    {
        LocalFree( pwszDeviceName );
    }

    return dwStatus;

} //*** WrapGetClusterQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Function:   WrapClusterEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterEnum(
    IN HCLUSENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;
            cchName = ++cchTempName;

            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if we succeeded and if the string argument is not NULL then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterNodeId
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapGetClusterNodeId(
    IN HNODE        hNode,
    OUT LPWSTR *    ppwszNodeId
    )
{
    DWORD   dwStatus;
    LPWSTR  pwszNodeId = NULL;
    DWORD   cchNodeId = 128;
    DWORD   cchTempNodeId = cchNodeId;

    // Zero the out parameters
    if ( ppwszNodeId != NULL )
    {
        *ppwszNodeId = NULL;
    }

    pwszNodeId = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeId * sizeof( *pwszNodeId ) );
    if ( pwszNodeId != NULL)
    {
        dwStatus = GetClusterNodeId( hNode, pwszNodeId, &cchTempNodeId );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszNodeId );
            pwszNodeId = NULL;

            cchNodeId = ++cchTempNodeId;
            pwszNodeId = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeId * sizeof( *pwszNodeId ) );
            if ( pwszNodeId != NULL)
            {
                dwStatus = GetClusterNodeId( hNode, pwszNodeId, &cchTempNodeId );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszNodeId != NULL ) )
    {
        *ppwszNodeId = pwszNodeId;
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszNodeId == NULL ) )
    {
        LocalFree( pwszNodeId );
    }

    return dwStatus;

} //*** WrapGetClusterNodeId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterGroupState
//
//  Description:
//      Wrapper function for GetClusterGroupState.
//
//  Arguments:
//      hGroup          [IN]    - The group handle.
//      ppwszNodeName   [OUT]   - Catches the name of the node that the group
//                              is online, if not NULL.
//
//  Return Value:
//      A cluster group state enum.
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_GROUP_STATE WINAPI WrapGetClusterGroupState(
    IN  HGROUP              hGroup,
    OUT OPTIONAL LPWSTR *   ppwszNodeName   // = NULL
    )
{
    CLUSTER_GROUP_STATE cState = ClusterGroupStateUnknown;

    if ( ppwszNodeName == NULL )
    {
        // The caller is not interested in the node name.
        // So, just call the actual function.
        cState = GetClusterGroupState( hGroup, NULL, 0 );
    } // if: the pointer to the node name pointer is not provided.
    else
    {
        LPWSTR              pwszNodeName = NULL;
        DWORD               cchNodeName = 128;
        DWORD               cchTempNodeName = cchNodeName;

        // Zero the out parameters
        *ppwszNodeName = NULL;

        pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
        if ( pwszNodeName != NULL )
        {
            cState = GetClusterGroupState( hGroup, pwszNodeName, &cchTempNodeName );
            if ( GetLastError() == ERROR_MORE_DATA )
            {
                cState = ClusterGroupStateUnknown;      // reset to error condition

                LocalFree( pwszNodeName );

                cchNodeName = ++cchTempNodeName;
                pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
                if ( pwszNodeName != NULL )
                {
                    cState = GetClusterGroupState( hGroup, pwszNodeName, &cchTempNodeName );
                }
            }
        }

        //
        // if there was not an error, then return the string.
        //
        if ( cState != ClusterGroupStateUnknown )
        {
            *ppwszNodeName = pwszNodeName;
        }
        else
        {
            LocalFree( pwszNodeName );
        }
    } // else: the pointer to the node name pointer is not NULL.

    return cState;

} //*** WrapGetClusterGroupState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterGroupEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterGroupEnum(
    IN HGROUPENUM   hGroupEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = NULL;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterGroupEnum( hGroupEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterGroupEnum( hGroupEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterGroupEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterNetworkEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterNetworkEnum(
    IN HNETWORKENUM hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterNetworkEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterNetworkEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterNetworkEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterNodeEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterNodeEnum(
    IN HNODEENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterNodeEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterNodeEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterNodeEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterResourceState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_RESOURCE_STATE WINAPI WrapGetClusterResourceState(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR * ppwszNodeName,
    OUT OPTIONAL LPWSTR * ppwszGroupName
    )
{
    CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;
    LPWSTR                  pwszNodeName = NULL;
    DWORD                   cchNodeName = 128;
    LPWSTR                  pwszGroupName = NULL;
    DWORD                   cchGroupName = 128;
    DWORD                   cchTempNodeName = cchNodeName;
    DWORD                   cchTempGroupName = cchGroupName;

    // Zero the out parameters
    if ( ppwszNodeName != NULL )
    {
        *ppwszNodeName = NULL;
    }

    if ( ppwszGroupName != NULL )
    {
        *ppwszGroupName = NULL;
    }

    pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
    if ( pwszNodeName != NULL )
    {
        pwszGroupName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchGroupName * sizeof( *pwszGroupName ) );
        if ( pwszGroupName != NULL )
        {
            cState = GetClusterResourceState( hResource, pwszNodeName, &cchTempNodeName, pwszGroupName, &cchTempGroupName );
            if ( GetLastError() == ERROR_MORE_DATA )
            {
                cState = ClusterResourceStateUnknown;   // reset to error condition

                LocalFree( pwszNodeName );
                pwszNodeName = NULL;
                cchNodeName = ++cchTempNodeName;

                LocalFree( pwszGroupName );
                pwszGroupName = NULL;
                cchGroupName = ++cchTempGroupName;

                pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
                if ( pwszNodeName != NULL )
                {
                    pwszGroupName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchGroupName * sizeof( *pwszGroupName ) );
                    if ( pwszGroupName != NULL )
                    {
                        cState = GetClusterResourceState( hResource,
                                                            pwszNodeName,
                                                            &cchNodeName,
                                                            pwszGroupName,
                                                            &cchGroupName );
                    }
                }
            }
        }
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszNodeName != NULL ) )
    {
        *ppwszNodeName = pwszNodeName;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszGroupName != NULL ) )
    {
        *ppwszGroupName = pwszGroupName;
    }

    //
    // if there was an error or the argument was NULL, then free the string.
    //
    if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszNodeName == NULL ) )
    {
        LocalFree( pwszNodeName );
    }

    //
    // if there was an error or the argument was NULL, then free the string.
    //
    if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszGroupName == NULL ) )
    {
        LocalFree( pwszGroupName );
    }

    return cState;

} //*** WrapGetClusterResourceState()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterNetInterfaceState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETINTERFACE_STATE WINAPI WrapGetClusterNetInterfaceState(
    IN HNETINTERFACE hNetInterface
    )
{

    return GetClusterNetInterfaceState( hNetInterface );

} //*** WrapGetClusterNetInterfaceState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterNetworkState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETWORK_STATE WINAPI WrapGetClusterNetworkState(
    IN HNETWORK hNetwork
    )
{

    return GetClusterNetworkState( hNetwork );

} //*** WrapGetClusterNetworkState()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterResourceEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterResourceEnum(
    IN HRESENUM  hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterResourceEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterResourceTypeEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterResourceTypeEnum(
    IN HRESTYPEENUM hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterResourceTypeEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterResourceTypeEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterResourceTypeEnum()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Misc helper functions, etc.
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyPort
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::CClusterNotifyPort
//
//  Description:    This class is a wrapper for the cluster notify port
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyPort::CClusterNotifyPort( void )
{
    m_dwNotifyKey = 0;
    m_dwFilterType = 0;
    m_szName = NULL;
    m_cchName = 0;
    m_hChange = NULL;

} //*** CClusterNotifyPort::CClusterNotifyPort()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::~CClusterNotifyPort
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyPort::~CClusterNotifyPort( void )
{
    if( NULL != m_szName )
    {
        delete [] m_szName;
    }
    Close();

} //*** CClusterNotifyPort::~CClusterNotifyPort()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::Create
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::Create(
    HCHANGE     hChange,
    HCLUSTER    hCluster,
    DWORD       dwFilter,
    DWORD_PTR   dwNotifyKey
    )
{
    DWORD sc = ERROR_SUCCESS;

    m_hChange = CreateClusterNotifyPort( hChange, hCluster, dwFilter, dwNotifyKey );
    if ( m_hChange == NULL )
    {
        sc = GetLastError();
    }

    return sc;

} //*** CClusterNotifyPort::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::Close
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::Close( void )
{
    DWORD sc = ERROR_SUCCESS;

    if ( m_hChange != NULL )
    {
        sc = CloseClusterNotifyPort( m_hChange );
    }

    return sc;

} //*** CClusterNotifyPort::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::Register
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::Register(
    DWORD       dwFilterType,
    HANDLE      hObject,
    DWORD_PTR   dwNotifyKey
    )
{
    return RegisterClusterNotify( m_hChange, dwFilterType, hObject, dwNotifyKey );

} //*** CClusterNotifyPort::Register()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::GetNotify
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::GetNotify( void )
{
    DWORD sc = ERROR_SUCCESS;
    DWORD cchName;

    cchName = m_cchName;

    //
    // Wait until state changes or 1 second elapses
    //
    sc = GetClusterNotify( m_hChange, &m_dwNotifyKey, &m_dwFilterType, m_szName, &cchName, 1000 );

    //
    // If we got an error_more_data or we passed in a NULL buffer pointer and got error_success
    // then we have to resize our buffer.  Member m_szName is initialized to NULL.
    //
    if ( sc == ERROR_MORE_DATA ||
       ( m_szName == NULL && sc == ERROR_SUCCESS )  )
    {
        //
        // resize the buffer
        //
        delete [] m_szName;

        cchName++;          // add one for NULL

        m_cchName = cchName;
        m_szName = new WCHAR[ m_cchName ];
        if ( m_szName == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
        } // if:
        else
        {
            cchName = m_cchName;
            sc = GetClusterNotify( m_hChange, &m_dwNotifyKey, &m_dwFilterType, m_szName, &cchName, 0 );
        } // else:
    } // if:

    return sc;

} //*** CClusterNotifyPort::GetNotify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForResourceStateChange
//
//  Description:
//      Wait for the resource state to change to a non pending state.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      pwszName        [IN]        - name of the resource to wait on
//      pPort           [IN]        - notification port to use
//      pnWait          [IN OUT]    - ~ number of seconds to wait
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForResourceStateChange(
    IN      HCLUSTER                hCluster,
    IN      LPWSTR                  pwszName,
    IN      CClusterNotifyPort *    pPort,
    IN OUT  DWORD *                 pnWait
    )
{
    CLUSTER_RESOURCE_STATE  crs = ClusterResourceStateUnknown;
    HRESOURCE               hResource = NULL;
    DWORD                   _sc = ERROR_SUCCESS;

    if ( pnWait != NULL )
    {
        hResource = OpenClusterResource( hCluster, pwszName );
        if ( hResource != NULL )
        {
            while ( *pnWait > 0 )
            {
                crs = WrapGetClusterResourceState( hResource, NULL, NULL );
                if ( crs != ClusterResourceStateUnknown )
                {
                    //
                    // if the state is greater than ClusterResourcePending then it's
                    // in a pending state and we want to wait for the next notification.
                    //
                    if ( crs > ClusterResourcePending )
                    {
                        pPort->GetNotify();  // this will only wait for up to 1 second.
                        --(*pnWait);
                    } // if: resource is in pending state
                    else
                    {
                        break;
                    } // else if: resource is no longer in a pending state
                } // if: WrapClusterResourceState
                else
                {
                    _sc = GetLastError();
                    break;
                } // else: WrapClusterResourceState failed
            } // while: *pnWait > 0

            CloseClusterResource( hResource );
        } // if: OpenClusterResource ok
        else
        {
            _sc = GetLastError();
        } // else: OpenClusterResource failed
    } // if: pnWait not NULL, this is for safety only

    return _sc;

} //*** WaitForResourceStateChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWaitForResourceStateChange
//
//  Description:
//      Wrapper for WaitForResourceStateChange.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      pwszName        [IN]        - name of the resource to wait on
//      pPort           [IN]        - notification port to use
//      pnWait          [IN OUT]    - ~ number of seconds to wait
//
//  Return Value:
//      S_OK or other Win32 HRESULT error
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT HrWaitForResourceStateChange(
    IN      HCLUSTER                hCluster,
    IN      LPWSTR                  pwszName,
    IN      CClusterNotifyPort *    pPort,
    IN OUT  DWORD *                 pnWait
    )
{
    DWORD   _sc = WaitForResourceStateChange( hCluster, pwszName, pPort, pnWait );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWaitForResourceStateChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForResourceGroupStateChange
//
//  Description:
//      Wait for the resource group state to change to a non pending state.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      hGroup          [IN]        - handle to the group to wait on
//      pnWait          [IN OUT]    - ~ number of seconds to wait
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForResourceGroupStateChange(
    IN      HCLUSTER    hCluster,
    IN      HGROUP      hGroup,
    IN OUT  DWORD *     pnWait
    )
{
    CLUSTER_GROUP_STATE _cgs = ClusterGroupStateUnknown;
    DWORD               _sc = ERROR_SUCCESS;

    if ( pnWait != NULL )
    {
        CClusterNotifyPort _port;       // Wait for a group state change event

        _sc = _port.Create( (HCHANGE) INVALID_HANDLE_VALUE, hCluster );
        if ( _sc == ERROR_SUCCESS )
        {
            _sc = _port.Register( CLUSTER_CHANGE_GROUP_STATE, hGroup );
            if ( _sc == ERROR_SUCCESS )
            {
                while ( *pnWait > 0 )
                {
                    _cgs = WrapGetClusterGroupState( hGroup, NULL );
                    if ( _cgs != ClusterGroupStateUnknown )
                    {
                        //
                        // if the state is ClusterGroupPending then it's
                        // in a pending state and we want to wait for the next notification.
                        //
                        if ( _cgs == ClusterGroupPending )
                        {
                            _port.GetNotify();   // this will only wait for up to 1 second.
                            --(*pnWait);
                        } // if: resource is in pending state
                        else
                        {
                            break;
                        } // else if: resource is no longer in a pending state
                    } // if: WrapClusterResourceState
                    else
                    {
                        _sc = GetLastError();
                        break;
                    } // else: WrapClusterResourceState failed
                } // while: *pnWait > 0
            } // if: port created
            else
            {
                _sc = GetLastError();
            } // else: port registration failed
        } // if: create notification port
    } // if: pnWait not NULL, this is for safety only

    return _sc;

} //*** WaitForResourceGroupStateChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWaitForResourceGroupStateChange
//
//  Description:
//      Wrapper for WaitForResourceGroupStateChange
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      hGroup          [IN]        - handle to the group to wait on
//      pnWait          [IN OUT]    - ~ number of seconds to wait
//
//  Return Value:
//      S_OK or other Win32 HRESULT error
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT HrWaitForResourceGroupStateChange(
    IN      HCLUSTER    hCluster,
    IN      HGROUP      hGroup,
    IN OUT  DWORD *     pnWait
    )
{
    DWORD   _sc = WaitForResourceGroupStateChange( hCluster, hGroup, pnWait );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWaitForResourceGroupStateChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForGroupToQuiesce
//
//  Description:
//      Wait for each of the resources in the group to leave a pending state.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      hGroup          [IN]        - handle to the group
//      pnWait          [IN OUT]    - ~ seconds to wait
//
//  Return Value:
//      ERROR_SUCCESS or error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForGroupToQuiesce(
    IN      HCLUSTER    hCluster,
    IN      HGROUP      hGroup,
    IN OUT  DWORD *     pnWait
    )
{
    HGROUPENUM  hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    if ( ( pnWait != NULL ) && ( *pnWait > 0 ) )
    {
        hEnum = ClusterGroupOpenEnum( hGroup, CLUSTER_GROUP_ENUM_CONTAINS );
        if ( hEnum != NULL)
        {
            CClusterNotifyPort port;        // Wait for a group state change event

            _sc = port.Create( (HCHANGE) INVALID_HANDLE_VALUE, hCluster );
            if ( _sc == ERROR_SUCCESS )
            {
                LPWSTR  pwszName = NULL;
                DWORD   dwIndex = 0;
                DWORD   dwType = 0;

                _sc = port.Register( CLUSTER_CHANGE_GROUP_STATE, hGroup );
                if ( _sc == ERROR_SUCCESS )
                {
                    for ( dwIndex = 0; _sc == ERROR_SUCCESS; dwIndex++ )
                    {
                        _sc = WrapClusterGroupEnum( hEnum, dwIndex, &dwType, &pwszName );
                        if ( _sc == ERROR_NO_MORE_ITEMS )
                        {
                            _sc = ERROR_SUCCESS;
                            break;
                        } // if: WrapClusterGroupEnum out of items -- leave!    we are done...
                        else if ( _sc == ERROR_SUCCESS )
                        {
                            _sc = WaitForResourceStateChange( hCluster, pwszName, &port, pnWait );
                            ::LocalFree( pwszName );
                            pwszName = NULL;
                        } // if: WrapClusterGroupEnum succeeded
                        else
                        {
                            _sc = GetLastError();
                        } // else: WrapClusterGroupEnum failed!
                    } // for: enum the resources in the group
                } // if: notification port registered
                else
                {
                    _sc = GetLastError();
                } // else: port registration failed
            } // if: create notification port

            ClusterGroupCloseEnum( hEnum );
        } // if: ClusterGroupOpenEnum succeeds
        else
        {
            _sc = GetLastError();
        } // else: ClusterGroupOpenEnum failed
    } // if: no wait time....

    return _sc;

} //*** WaitForGroupToQuiesce()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWaitForGroupToQuiesce
//
//  Description:
//      Wrapper for WaitForGroupToQuiesce
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      hGroup          [IN]        - handle to the group
//      pnWait          [IN OUT]    - ~ seconds to wait
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT HrWaitForGroupToQuiesce(
    IN      HCLUSTER    hCluster,
    IN      HGROUP      hGroup,
    IN OUT  DWORD *     pnWait
    )
{
    DWORD   _sc = WaitForGroupToQuiesce( hCluster, hGroup, pnWait );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWaitForGroupToQuiesce()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForResourceToQuiesce
//
//  Description:
//      Wrapper function that is called after OnlineClusterResouce  and
//      OfflineClusterResource that waits for the resource to finish its
//      state change.  Returns the pending state of the resource after the
//      wait period has expired and the state has not changed.
//
//  Arguments:
//      hCluster    [IN]        -   the cluster handle
//      hResource   [IN]        -   the resource handle to take on or offline
//      pnWait      [IN, OUT]   -   ~ how many seconds to wait
//      pbPending   [OUT]           - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForResourceToQuiesce(
    IN      HCLUSTER    hCluster,
    IN      HRESOURCE   hResource,
    IN OUT  DWORD *     pnWait,
    OUT  long *         pbPending
    )
{
     CLUSTER_RESOURCE_STATE crs = ClusterResourceStateUnknown;
     DWORD                  _sc = ERROR_SUCCESS;

    if ( ( pnWait != NULL ) && ( *pnWait > 0 ) )
    {
        CClusterNotifyPort port;        // if wait is specified open a notify port.

        _sc = port.Create( (HCHANGE) INVALID_HANDLE_VALUE, hCluster );
        if ( _sc == ERROR_SUCCESS )
        {
            _sc = port.Register( CLUSTER_CHANGE_RESOURCE_STATE, hResource );
            if ( _sc == ERROR_SUCCESS )
            {
                //
                // Check the state before we check the notification port.
                //
                crs = WrapGetClusterResourceState( hResource, NULL, NULL );
                if ( crs != ClusterResourceStateUnknown )
                {
                    while ( ( *pnWait > 0 ) && ( crs > ClusterResourcePending ) )
                    {
                        port.GetNotify();       // waits for ~ 1 second

                        crs = WrapGetClusterResourceState( hResource, NULL, NULL );

                        --(*pnWait);
                    } // while:
                } // if: get resource state
                else
                {
                    _sc = GetLastError();
                } // else: get resource state failed
            } // if: port was registered ok
        } // if: port was created ok
    } // if: *pnWait > 0
    else
    {
        crs = ClusterResourceOnlinePending;
    } // else: no time to wait and the resource is/was ERROR_IO_PENDING

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        if ( crs > ClusterResourcePending )
        {
            *pbPending = TRUE;
        } // if: is the resource still in a pending state
    } // if: does the argument exist?

    return _sc;

} //*** WaitForResourceToQuiesce()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWaitForResourceToQuiesce
//
//  Description:
//      Wrapper function for WaitForResourceToQuiesce
//
//  Arguments:
//      hCluster    [IN]        -   the cluster handle
//      hResource   [IN]        -   the resource handle to take on or offline
//      pnWait      [IN, OUT]   -   ~ how many seconds to wait
//      pbPending   [OUT]           - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT  HrWaitForResourceToQuiesce(
    IN      HCLUSTER    hCluster,
    IN      HRESOURCE   hResource,
    IN OUT  DWORD *     pnWait,
    OUT  long *         pbPending
    )
{
    DWORD   _sc = WaitForResourceToQuiesce( hCluster, hResource, pnWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWaitForResourceToQuiesce()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOnlineClusterResource
//
//  Description:
//      Wrapper function for OnlineClusterResouce that returns the pending
//      state of the resource after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      nWait       [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOnlineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ERROR_SUCCESS;

    _sc = OnlineClusterResource( hResource );
    if ( _sc == ERROR_IO_PENDING )
    {
        _sc = WaitForResourceToQuiesce( hCluster, hResource, &nWait, pbPending );
    } // if: ERROR_IO_PENDING
    else if ( _sc == ERROR_SUCCESS )
    {
        if ( pbPending != NULL )
        {
            *pbPending = FALSE;
        }
    } // else if: ERROR_SUCCESS, resource must  be online!

    return _sc;

} //*** ScWrapOnlineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOnlineClusterResource
//
//  Description:
//      Wrapper function for WrapOnlineClusterResouce
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      nWait       [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOnlineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ScWrapOnlineClusterResource( hCluster, hResource, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOnlineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOfflineClusterResource
//
//  Description:
//      Wrapper function for OfflineClusterResouce that returns the pending
//      state of the resource after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOfflineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ERROR_SUCCESS;

    _sc = OfflineClusterResource( hResource );
    if ( _sc == ERROR_IO_PENDING )
    {
        _sc = WaitForResourceToQuiesce( hCluster, hResource, &nWait, pbPending );
    } // if: ERROR_IO_PENDING
    else if ( _sc == ERROR_SUCCESS )
    {
        if ( pbPending != NULL )
        {
            *pbPending = FALSE;
        }
    } // else if: ERROR_SUCCESS, resource must  be online!

    return _sc;

} //*** ScWrapOfflineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOfflineClusterResource
//
//  Description:
//      Wrapper function for ScWrapOfflineClusterResource
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOfflineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ScWrapOfflineClusterResource( hCluster, hResource, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOfflineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOnlineClusterGroup
//
//  Description:
//      Wrapper function for OnlineClusterGroup that returns the pending state
//      of the group after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      hNode       [IN]    - the node the group should be brought online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT] - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode,          //=NULL
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    CLUSTER_GROUP_STATE cgs = ClusterGroupStateUnknown;
    DWORD               _sc = ERROR_SUCCESS;
    BOOL                bPending = FALSE;

    _sc = OnlineClusterGroup( hGroup, hNode );
    if ( _sc == ERROR_IO_PENDING )
    {
        //
        // is a wait time provided?
        //
        if ( nWait > 0 )
        {
            //
            // Check the group state before we check the state of the resources. When reporting the
            // group state the cluster API pulls the resource states online and offline pending up
            // to online or offline respectivly.    It also pulls the failed state up to offline.   This
            // means that a group state of online or offline is misleading because one or more
            // resources could be in a pending state.   The only absolute state is PartialOnline, at
            // least one resource is offline (or failed).
            //
            cgs = WrapGetClusterGroupState( hGroup, NULL );
            if ( cgs == ClusterGroupPending )
            {
                _sc = WaitForResourceGroupStateChange( hCluster, hGroup, &nWait );
            } // if: group state is pending
            else if ( ( cgs == ClusterGroupOnline ) || ( cgs == ClusterGroupPartialOnline ) )
            {
                _sc = WaitForGroupToQuiesce( hCluster, hGroup, &nWait );
                if ( _sc == ERROR_SUCCESS )
                {
                    bPending = ( nWait == 0 );      // if we ran out of time then something isn't online
                } // if: HrWaitForGroupToQuiesce ok
            } // else if: group is online -- we have to check all of the resources, on downlevel clusters...
            else if ( cgs == ClusterGroupStateUnknown )
            {
                _sc = GetLastError();
            } // else if: get group state failed
        } // if: pnWait > 0
        else
        {
            bPending = TRUE;
        } // if: no wait was specified
    } // if: OnlineClusterGroup returned ERROR_IO_PENDING

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        *pbPending = bPending;
    } // if: does the argument exist?

    return _sc;

} //*** ScWrapOnlineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOnlineClusterGroup
//
//  Description:
//      Wrapper function for ScWrapOnlineClusterGroup
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      hNode       [IN]    - the node the group should be brought online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT] - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode,          //=NULL
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ScWrapOnlineClusterGroup( hCluster, hGroup, hNode, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOnlineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOfflineClusterGroup
//
//  Description:
//      Wrapper function for OfflineClusterGroup that returns the pending
//      state of the group after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    CLUSTER_GROUP_STATE cgs = ClusterGroupStateUnknown;
    DWORD               _sc = ERROR_SUCCESS;
    BOOL                bPending = FALSE;

    _sc = OfflineClusterGroup( hGroup );
    if ( _sc == ERROR_IO_PENDING )
    {
        //
        // is a wait time provided?
        //
        if ( nWait > 0 )
        {
            //
            // Check the group state before we check the state of the resources. When reporting the
            // group state the cluster API pulls the resource states online and offline pending up
            // to online or offline respectivly.    It also pulls the failed state up to offline.   This
            // means that a group state of online or offline is misleading because one or more
            // resources could be in a pending state.
            //
            cgs = WrapGetClusterGroupState( hGroup, NULL );
            if ( cgs == ClusterGroupPending )
            {
                _sc = WaitForResourceGroupStateChange( hCluster, hGroup, &nWait );
            } // if: group state is pending
            else if ( cgs == ClusterGroupStateUnknown )
            {
                _sc = GetLastError();
            } // else if: get group state failed
            else if ( ( cgs == ClusterGroupOffline ) || ( cgs == ClusterGroupPartialOnline ) )
            {
                _sc = WaitForGroupToQuiesce( hCluster, hGroup, &nWait );
                if ( _sc == ERROR_SUCCESS )
                {
                    bPending = ( nWait == 0 );      // if we ran out of time then something isn't online
                } // if: HrWaitForGroupToQuiesce ok
            } // else if: group is offline -- we have to check all of the resources...
        } // if: pnWait > 0
        else
        {
            bPending = TRUE;
        } // if: no wait was specified
    } // if: OfflineClusterGroup returned ERROR_IO_PENDING

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        *pbPending = bPending;
    } // if: does the argument exist?

    return _sc;

} //*** ScWrapOfflineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOfflineClusterGroup
//
//  Description:
//      Wrapper function for OfflineClusterGroup that returns the pending
//      state of the group after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ScWrapOfflineClusterGroup( hCluster, hGroup, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOfflineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapMoveClusterGroup
//
//  Description:
//      Wrapper function for MoveClusterGroup that returns the pending state
//      of the group after the wait period has expired.
//
//  Arguments:
//      hCluster        [IN]    - the cluster handle
//      hGroup          [IN]    - the group handle to online
//      hNode           [IN]    - the node the group should be brought online
//      pnWait          [IN]    - ~ how many seconds to wait
//      pbPending       [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapMoveClusterGroup(
    IN  HCLUSTER                hCluster,
    IN  HGROUP                  hGroup,
    IN  HNODE                   hNode,              //=NULL
    IN  DWORD                   nWait,              //=0
    OUT long *                  pbPending           //=NULL
    )
{
    LPWSTR              pszOriginNodeName           = NULL;
    BOOL                bPending                    = FALSE;
    DWORD               _sc;

    do // dummy do-while look to avoid gotos.
    {
        CLUSTER_GROUP_STATE cgsInitialState             = ClusterGroupStateUnknown;
        CLUSTER_GROUP_STATE cgsCurrentState             = ClusterGroupStateUnknown;
        LPWSTR              pszCurrentNodeName          = NULL;

        // Get the initial group state.
        cgsInitialState = WrapGetClusterGroupState( hGroup, &pszOriginNodeName );
        if ( cgsInitialState == ClusterGroupStateUnknown )
        {
            // Error getting the group state
            _sc = GetLastError();
            break;
        }

        // Move the cluster group.
        _sc = MoveClusterGroup( hGroup, hNode );

        //
        // When MoveClusterGroup returns ERROR_SUCCESS, it just means that the group
        // has changed ownership successfully, but it does not mean that the group is
        // back to the state it was in before the move. Therefore, we still need to
        // wait, if a wait time is provided. If not, we are done.
        //
        if ( nWait <= 0 )
        {
            break;
        }

        //
        // MoveClusterGroup is not done yet
        //
        if ( _sc == ERROR_IO_PENDING )
        {
            _sc = ERROR_SUCCESS;

            do  // while (nWait > 0)
            {
                //
                // Get the name of the node which currently owns this group.
                //
                cgsCurrentState = WrapGetClusterGroupState( hGroup, &pszCurrentNodeName );
                if ( cgsCurrentState == ClusterGroupStateUnknown )
                {
                    // Error getting the group state
                    _sc = GetLastError();
                    break;
                }

                if ( lstrcmpiW( pszOriginNodeName, pszCurrentNodeName ) != 0 )
                {
                    //
                    // If the current owner node is not the original owner, then the call to
                    // move group has succeeded. So quit this loop (we still have to see
                    // if the group is stable though)
                    //
                    break;
                } // if: current owner node is not the same as the original owner node
                else
                {
                    //
                    // Current owner is the same as the original owner.
                    // Wait for one second and check again.
                    //
                    LocalFree( pszCurrentNodeName );
                    pszCurrentNodeName = NULL;      // Required to prevent freeing memory twice
                    --nWait;
                    Sleep( 1000 );
                } // if: current owner node is the same as the original owner node
            }
            while ( nWait > 0 );

            LocalFree( pszCurrentNodeName );

            //
            // If we ran out of time waiting for MoveClusterGroup to complete, then
            // set the pending flag and quit.
            //
            if ( nWait <= 0 )
            {
                bPending = TRUE;
                break;
            }
        } // if: MoveClusterGroup returned ERROR_IO_PENDING
        else
        {
            cgsCurrentState = WrapGetClusterGroupState( hGroup, NULL );
            if ( cgsCurrentState == ClusterGroupStateUnknown )
            {
                // Error getting the group state
                _sc = GetLastError();
            }
        } // else: MoveClusterGroup returned ERROR_SUCCESS

        //
        // if something went wrong with MoveClusterGroup, while waiting
        // for it to comeplete or with WrapGetClusterGroupState, then quit.
        //
        if ( _sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If the state of the group on the destination node is ClusterGroupFailed
        // then there is nothing much we can do.
        //
        if ( cgsCurrentState == ClusterGroupFailed )
        {
            break;
        }

        //
        // Check the group state before we check the state of the resources. When reporting the
        // group state the cluster API of a NT4 node pulls the resource states online and offline
        // pending up to online or offline respectivly. It also pulls the failed state up to offline.
        // This means that a group state of online or offline is misleading because one or more
        // resources could be in a pending state. The only absolute state is PartialOnline, at
        // least one resource is offline (or failed).
        //

        if ( cgsCurrentState == ClusterGroupPending )
        {
            // The current state is pending. So wait for a state change.
            _sc = WaitForResourceGroupStateChange( hCluster, hGroup, &nWait );
        } // if: the group state is pending.
        else
        {
            _sc = WaitForGroupToQuiesce( hCluster, hGroup, &nWait );
        } // else: group state is online, offline or partial online

        if ( _sc == ERROR_SUCCESS )
        {
            bPending = ( nWait == 0 );
        } // if: everything ok so far
    }
    while ( FALSE ); // dummy do-while look to avoid gotos

    LocalFree( pszOriginNodeName );

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        *pbPending = bPending;
    } // if: does the argument exist?

    return _sc;

} //*** ScWrapMoveClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapMoveClusterGroup
//
//  Description:
//      Wrapper function for ScWrapMoveClusterGroup that returns the pending state
//      of the group after the wait period has expired.
//
//  Arguments:
//      hCluster        [IN]    - the cluster handle
//      hGroup          [IN]    - the group handle to online
//      hNode           [IN]    - the node the group should be brought online
//      pnWait          [IN]    - ~ how many seconds to wait
//      pbPending       [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapMoveClusterGroup(
    IN  HCLUSTER                hCluster,
    IN  HGROUP                  hGroup,
    IN  HNODE                   hNode,              //=NULL
    IN  DWORD                   nWait,              //=0
    OUT long *                  pbPending           //=NULL
    )
{
    DWORD   _sc = ScWrapMoveClusterGroup ( hCluster, hGroup, hNode, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapMoveClusterGroup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.cpp
//
//	Abstract:
//		Implementation of the CDialogHelp class.
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagDlgHelp(_T("Help"), _T("DLG HELP"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDialogHelp, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CDialogHelp
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pmap		[IN] Map array mapping control IDs to help IDs.
//		dwMask		[IN] Mask to use for the low word of the help ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp(IN const DWORD * pdwHelpMap, IN DWORD dwMask)
{
	ASSERT(pdwHelpMap != NULL);

	CommonConstruct();
	SetMap(pdwHelpMap);
	m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CommonConstruct
//
//	Routine Description:
//		Do common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct(void)
{
	m_pmap = NULL;
	m_dwMask = 0;
	m_nHelpID = 0;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::NHelpFromCtrlID
//
//	Routine Description:
//		Return the help ID from a control ID.
//
//	Arguments:
//		nCtrlID		[IN] ID of control to search for.
//
//	Return Value:
//		nHelpID		Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID(IN DWORD nCtrlID) const
{
	DWORD						nHelpID = 0;
	const CMapCtrlToHelpID *	pmap = Pmap();

	ASSERT(pmap != NULL);
	ASSERT(nCtrlID != 0);

	for ( ; pmap->m_nCtrlID != 0 ; pmap++)
	{
		if (pmap->m_nCtrlID == nCtrlID)
		{
			nHelpID = pmap->m_nHelpCtrlID;
			break;
		}  // if:  found a match
	}  // for:  each control

	Trace(g_tagDlgHelp, _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID);

	return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu(CWnd * pWnd, CPoint point)
{
	CWnd *	pwndChild;
	CPoint	ptDialog;
	DWORD	nHelpID = 0;

	ASSERT(pWnd != NULL);

	m_nHelpID = 0;

	// Convert the point into dialog coordinates.
	ptDialog = point;
	pWnd->ScreenToClient(&ptDialog);

	// Find the control the cursor is over.
	{
		DWORD	nCtrlID;

		pwndChild = pWnd->ChildWindowFromPoint(ptDialog);
		if ((pwndChild != NULL) && (pwndChild->GetStyle() & WS_VISIBLE))
		{
			nCtrlID = pwndChild->GetDlgCtrlID();
			if (nCtrlID != 0)
				nHelpID = NHelpFromCtrlID(nCtrlID);
		}  // if:  over a child window
	}  // Find the control the cursor is over

	// Display a popup menu.
	if ((nHelpID != 0) && (nHelpID != -1))
	{
		CString	strMenu;
		CMenu	menu;

		try
		{
			strMenu.LoadString(IDS_MENU_WHATS_THIS);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return;
		}  // catch:  CMemoryException

		if (menu.CreatePopupMenu())
		{
			if (menu.AppendMenu(MF_STRING | MF_ENABLED, ID_HELP, strMenu))
			{
				DWORD	nCmd;
				m_nHelpID = nHelpID;
				nCmd = menu.TrackPopupMenu(
					TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
					point.x,
					point.y,
					AfxGetMainWnd()
					);
				if (nCmd != 0)
					AfxGetApp()->WinHelp(m_nHelpID, HELP_CONTEXTPOPUP);
			}  // if:  menu item added successfully
			menu.DestroyMenu();
		}  // if:  popup menu created successfully
	}  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo(HELPINFO * pHelpInfo)
{
	// If this is for a control, display control-specific help.
	if ((pHelpInfo->iContextType == HELPINFO_WINDOW)
			&& (pHelpInfo->iCtrlId != 0))
	{
		DWORD	nHelpID = NHelpFromCtrlID(pHelpInfo->iCtrlId);
		if (nHelpID != 0)
		{
			if (nHelpID != -1)
				AfxGetApp()->WinHelp(nHelpID, HELP_CONTEXTPOPUP);
			return TRUE;
		}  // if:  found the control in the list
	}  // if:  need help on a specific control

	// Display dialog help.
	return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		WPARAM		[IN] Passed on to base class method.
//		lParam		[IN] Help ID.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	return TRUE;

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\critsec.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CritSec.h
//
//	Abstract:
//		Definition of the CCritSec class.
//
//	Author:
//		David Potter (davidp)	November 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CRITSEC_H_
#define __CRITSEC_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCritSec;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CCritSec
/////////////////////////////////////////////////////////////////////////////

class CCritSec
{
protected:
	CRITICAL_SECTION	m_critsec;	// Critical section data.

public:
	CCritSec(void)
	{
		InitializeCriticalSection(&m_critsec);
	}

	~CCritSec(void)
	{
		// Make sure no one is holding the critical section
		// before we delete it.
		Lock();
		Unlock();
		DeleteCriticalSection(&m_critsec);
	}

	// Acquire the critical section
	void Lock(void)
	{
		EnterCriticalSection(&m_critsec);
	}

	// Release the critical section
	void Unlock(void)
	{
		LeaveCriticalSection(&m_critsec);
	}

};  //*** class CCritSec

/////////////////////////////////////////////////////////////////////////////

#endif // __CRITSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.h
//
//	Abstract:
//		Definition of the CDialogHelp class.
//
//	Implementation File:
//		DlgHelp.cpp
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#define _DLGHELP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
	DECLARE_DYNAMIC(CDialogHelp)

// Construction
public:
	CDialogHelp(void) { CommonConstruct(); }
	CDialogHelp(const DWORD * pdwHelpMap, DWORD dwMask);

	void CommonConstruct(void);

// Attributes
protected:
	const CMapCtrlToHelpID *	m_pmap;
	DWORD						m_dwMask;
	DWORD						m_nHelpID;

public:
	const CMapCtrlToHelpID *	Pmap(void) const	{ return m_pmap; }
	DWORD						DwMask(void) const	{ return m_dwMask; }
	DWORD						NHelpID(void) const	{ return m_nHelpID; }

	DWORD						NHelpFromCtrlID(IN DWORD nCtrlID) const;
	void						SetMap(IN const DWORD * pdwHelpMap)
	{
		ASSERT(pdwHelpMap != NULL);
		m_pmap = (const CMapCtrlToHelpID *) pdwHelpMap;
	}

// Operations
public:
	void		SetHelpMask(IN DWORD dwMask)	{ ASSERT(dwMask != 0); m_dwMask = dwMask; }

	void		OnContextMenu(CWnd * pWnd, CPoint point);
	BOOL		OnHelpInfo(HELPINFO * pHelpInfo);
	LRESULT		OnCommandHelp(WPARAM wParam, LPARAM lParam);

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // _DLGHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Abstract:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);

void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

void AFXAPI DDV_Path(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(pDX, nIDC, (DWORD &) rnValue, (DWORD) nMin, (DWORD) nMax, bSigned);
}

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\dlgitemutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		DlgItemUtils.h
//
//	Abstract:
//		Definition of the CDlgItemUtils class.
//
//	Author:
//		David Potter (davidp)	February 10, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DLGITEMUTILS_H_
#define __DLGITEMUTILS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDlgItemUtils;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	class CDlgItemUtils
//
//	Purpose:
//		Utilities for manipulating dialog items.
//
//	Inheritance:
//		CDlgItemUtils
//
/////////////////////////////////////////////////////////////////////////////

class CDlgItemUtils
{
public:
	//
	// Construction
	//

public:
	//
	// CDlgItemUtils public methods.
	//

	// Set a control to be read-only
	static BOOL SetDlgItemReadOnly( HWND hwndCtrl )
	{
		ATLASSERT( hwndCtrl != NULL );
		ATLASSERT( IsWindow( hwndCtrl ) );

		TCHAR szWindowClass[256];

		//
		// Get the class of the control
		//
		::GetClassName( hwndCtrl, szWindowClass, (sizeof(szWindowClass) / sizeof(TCHAR)) - 1 );

		//
		// If it is an edit control or an IP Address control we can handle it.
		//
		if ( lstrcmp( szWindowClass, _T("Edit") ) == 0 )
		{
			return ::SendMessage( hwndCtrl, EM_SETREADONLY, TRUE, 0 );
		} // if:  edit control

		if ( lstrcmp( szWindowClass, WC_IPADDRESS ) == 0 )
		{
			return ::EnumChildWindows( hwndCtrl, s_SetEditReadOnly, NULL );
		} // if:  IP Address control

		//
		// If we didn't handle it, it is an error.
		//
		return FALSE;

	} //*** SetDlgItemReadOnly()

// Implementation
protected:

	// Static method to set an edit control read only as a callback
	static BOOL CALLBACK s_SetEditReadOnly( HWND hwnd, LPARAM lParam )
	{
		return ::SendMessage( hwnd, EM_SETREADONLY, TRUE, 0 );

	} //*** s_SetEditReadOnly()

}; //*** class CDlgItemUtils

/////////////////////////////////////////////////////////////////////////////

#endif // __DLGITEMUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\excoper.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ExcOper.h
//
//	Implementation File:
//		ExcOper.cpp
//
//	Description:
//		Definition of the exception classes.
//
//	Author:
//		David Potter (davidp)	May 20, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXCOPER_H_
#define _EXCOPER_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExceptionWithOper;
class CNTException;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef DWORD SC;

#define EXCEPT_MAX_OPER_ARG_LENGTH	260

/////////////////////////////////////////////////////////////////////////////
// Wire in MFC if this is an MFC image.
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__

#define IDP_NO_ERROR_AVAILABLE AFX_IDP_NO_ERROR_AVAILABLE

inline int EXC_AppMessageBox( LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 )
{
	return AfxMessageBox( lpszText, nType, nIDHelp );
}

inline int EXC_AppMessageBox( UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1 )
{
	return AfxMessageBox( nIDPrompt, nType, nIDHelp );
}

inline int EXC_AppMessageBox( HWND hwndParent, LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 )
{
	return AfxMessageBox( lpszText, nType, nIDHelp );
}

inline int EXC_AppMessageBox( HWND hwndParent, UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1 )
{
	return AfxMessageBox( nIDPrompt, nType, nIDHelp );
}

inline HINSTANCE EXC_GetResourceInstance( void )
{
	return AfxGetApp()->m_hInstance;
}

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// class CException
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFX_H__

class CException
{
public:
	BOOL m_bAutoDelete;
#if DBG || defined( _DEBUG )
protected:
	BOOL m_bReadyForDelete;
public:
#endif // DBG || defined( _DEBUG )

	CException( void )
	{
		m_bAutoDelete = TRUE;
#if DBG || defined( _DEBUG )
		m_bReadyForDelete = FALSE;
#endif // DBG || defined( _DEBUG )
	}

	CException( BOOL bAutoDelete )
	{
		m_bAutoDelete = bAutoDelete;
#if DBG || defined( _DEBUG )
		m_bReadyForDelete = FALSE;
#endif // DBG || defined( _DEBUG )
	}

	virtual ~CException( void )
	{
	}

	void Delete( void )	// use to delete exception in 'catch' block
	{
		// delete exception if it is auto-deleting
		if ( m_bAutoDelete > 0 )
		{
#if DBG || defined( _DEBUG )
			m_bReadyForDelete = TRUE;
#endif // DBG || defined( _DEBUG )
			delete this;
		}
	}

	virtual BOOL GetErrorMessage(
		LPTSTR lpszError,
		UINT nMaxError,
		PUINT pnHelpContext = NULL
		)
	{
		if ( pnHelpContext != NULL )
			*pnHelpContext = 0;

		if ( nMaxError != 0 && lpszError != NULL )
			*lpszError = '\0';

		return FALSE;
	}

	virtual int ReportError( UINT nType = MB_OK, UINT nError = 0 );

#if DBG || defined( _DEBUG )
	void PASCAL operator delete( void * pbData )
	{
		// check for proper exception object deletion
		CException * pException = (CException *) pbData;

		// use: pException->Delete(), do not use: delete pException
		ASSERT( pException->m_bReadyForDelete );
		ASSERT( pException->m_bAutoDelete > 0 );

		// avoid crash when assert above is ignored
		if ( pException->m_bReadyForDelete && pException->m_bAutoDelete > 0 )
			::operator delete( pbData );
	}
#endif // DBG || defined( _DEBUG )

}; // class CException

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// class CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

typedef int (WINAPI *PFNMSGBOX)( DWORD dwParam, LPCTSTR lpszText, UINT nType, UINT nIDHelp );

class CExceptionWithOper : public CException
{
#ifdef __AFX_H__
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC( CExceptionWithOper )
#endif // __AFX_H__

public:
// Constructors
	CExceptionWithOper(
		IN UINT		idsOperation,
		IN LPCTSTR	pszOperArg1		= NULL,
		IN LPCTSTR	pszOperArg2		= NULL
		)
	{
		SetOperation(idsOperation, pszOperArg1, pszOperArg2);

	} // CExceptionWithOper()

	CExceptionWithOper(
		IN UINT		idsOperation,
		IN LPCTSTR	pszOperArg1,
		IN LPCTSTR	pszOperArg2,
		IN BOOL		bAutoDelete
		)
		: CException( bAutoDelete )
	{
		SetOperation( idsOperation, pszOperArg1, pszOperArg2 );

	} // CExceptionWithOper(bAutoDelete)

// Operations
public:
	virtual BOOL	GetErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL
						)
	{
		// Format the operation string.
		FormatWithOperation( lpszError, nMaxError, NULL );

		return TRUE;

	} // GetErrorMessage()
	virtual int		ReportError(
						UINT		nType	= MB_OK,
						UINT		nError	= 0
						);

	virtual int		ReportError(
						HWND		hwndParent,
						UINT		nType	= MB_OK,
						UINT		nError	= 0
						);

	virtual int		ReportError(
						PFNMSGBOX	pfnMsgBox,
						DWORD		dwParam,
						UINT		nType	= MB_OK,
						UINT		nError	= 0
						);

	void			SetOperation(
						IN UINT		idsOperation,
						IN LPCTSTR	pszOperArg1 = NULL,
						IN LPCTSTR	pszOperArg2 = NULL
						);

	void			SetOperationIfEmpty(
						IN UINT		idsOperation,
						IN LPCTSTR	pszOperArg1 = NULL,
						IN LPCTSTR	pszOperArg2 = NULL
						)
	{
		if ( m_idsOperation == 0 )
		{
			SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
		} // if:  exception is empty

	} //*** SetOperationIfEmpty()

	void			FormatWithOperation(
						OUT LPTSTR	lpszError,
						IN UINT		nMaxError,
						IN LPCTSTR	pszMsg
						);

// Implementation
protected:
	UINT			m_idsOperation;
	TCHAR			m_szOperArg1[EXCEPT_MAX_OPER_ARG_LENGTH];
	TCHAR			m_szOperArg2[EXCEPT_MAX_OPER_ARG_LENGTH];

public:
	UINT			IdsOperation( void ) const	{ return m_idsOperation; }
	LPTSTR			PszOperArg1( void )			{ return m_szOperArg1; }
	LPTSTR			PszOperArg2( void )			{ return m_szOperArg2; }

};  //*** class CExceptionWithOper

/////////////////////////////////////////////////////////////////////////////
// class CNTException
/////////////////////////////////////////////////////////////////////////////

class CNTException : public CExceptionWithOper
{
#ifdef __AFX_H__
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC( CNTException )
#endif // __AFX_H__

public:
// Constructors
	CNTException(
		IN SC		sc,
		IN UINT		idsOperation	= NULL,
		IN LPCTSTR	pszOperArg1		= NULL,
		IN LPCTSTR	pszOperArg2		= NULL
		)
		: CExceptionWithOper( idsOperation, pszOperArg1, pszOperArg2 )
		, m_sc( sc )
	{
	} // CNTException()

	CNTException(
		IN SC		sc,
		IN UINT		idsOperation,
		IN LPCTSTR	pszOperArg1,
		IN LPCTSTR	pszOperArg2,
		IN BOOL		bAutoDelete
		)
		: CExceptionWithOper( idsOperation, pszOperArg1, pszOperArg2, bAutoDelete )
		, m_sc( sc )
	{
	} // CNTException( bAutoDelete )

// Operations
public:
	virtual BOOL	GetErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL
						)
	{
		return FormatErrorMessage( lpszError, nMaxError, pnHelpContext, TRUE /*bIncludeID*/ );

	} //*** GetErrorMessage()

	BOOL			FormatErrorMessage(
						LPTSTR	lpszError,
						UINT	nMaxError,
						PUINT	pnHelpContext = NULL,
						BOOL	bIncludeID = FALSE
						);

	void			SetOperation(
						IN SC		sc,
						IN UINT		idsOperation,
						IN LPCTSTR	pszOperArg1 = NULL,
						IN LPCTSTR	pszOperArg2 = NULL
						)
	{
		m_sc = sc;
		CExceptionWithOper::SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
	} //*** SetOperation()

	void			SetOperationIfEmpty(
						IN SC		sc,
						IN UINT		idsOperation,
						IN LPCTSTR	pszOperArg1 = NULL,
						IN LPCTSTR	pszOperArg2 = NULL
						)
	{
		if ( (m_sc == ERROR_SUCCESS) && (m_idsOperation == 0) )
		{
			m_sc = sc;
			CExceptionWithOper::SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
		} // if:  exception is empty
	} //*** SetOperationIfEmpty()

// Implementation
protected:
	SC				m_sc;

public:
	SC				Sc( void )		{ return m_sc; }

};  //*** class CNTException

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void ThrowStaticException(
	IN UINT			idsOperation	= NULL,
	IN LPCTSTR		pszOperArg1		= NULL,
	IN LPCTSTR		pszOperArg2		= NULL
	);
void ThrowStaticException(
	IN SC			sc,
	IN UINT			idsOperation	= NULL,
	IN LPCTSTR		pszOperArg1		= NULL,
	IN LPCTSTR		pszOperArg2		= NULL
	);
BOOL FormatErrorMessage(
	DWORD	sc,
	LPTSTR	lpszError,
	UINT	nMaxError
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _EXCOPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\excoper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-2000 Microsoft Corporation
//
//	Module Name:
//		ExcOper.cpp
//
//	Abstract:
//		Implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	May 20, 1996
//
//	Revision History:
//
//	Notes:
//		TraceTag.h and resource.h are pulled from the project directory.
//
//		stdafx.h must disable some W4 warnings.
//
//		TraceTag.h must define TraceError.
//
//		resource.h must define IDS_ERROR_MSG_ID, and the string must be
//		defined something like "\n\nError ID: %d (%08.8x)." in the resource file.
//
//		IDP_NO_ERROR_AVAILABLE must defined as a string for displaying when
//		no error code is available.
//
//		EXC_AppMessageBox(LPCTSTR...) and EXC_AppMessageBox(UINT...) must be
//		defined and implemented.
//
//		EXC_GetResourceInstance must be defined and implemented to return the
//		resource instance handle of the application or DLL.
//
/////////////////////////////////////////////////////////////////////////////

#include <string.h>
#include "ExcOper.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CException
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CException::ReportError
//
//	Routine Description:
//		Report an error from the exception.  Overriding to get a bigger
//		error message buffer.
//
//	Arguments:
//		nType		[IN] Type of message box.
//		nError		[IN] ID of a mesage to display if exception has no message.
//
//	Return Value:
//		Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CException::ReportError( UINT nType /* = MB_OK */, UINT nError /* = 0 */ )
{
	TCHAR	szErrorMessage[128];
	int		nDisposition;
	UINT	nHelpContext;

	if ( GetErrorMessage(szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
	{
		nDisposition = EXC_AppMessageBox( szErrorMessage, nType, nHelpContext );
	} // if:  error message retrieved successfully
	else
	{
		if ( nError == 0 )
		{
			nError = IDP_NO_ERROR_AVAILABLE;
		} // if:  no error code
		nDisposition = EXC_AppMessageBox( nError, nType, nHelpContext );
	} // else:  error retrieving error message
	return nDisposition;

} //*** CException::ReportError()

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// class CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC(CExceptionWithOper, CException)
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::ReportError
//
//	Routine Description:
//		Report an error from the exception.  Overriding to get a bigger
//		error message buffer.
//
//	Arguments:
//		nType		[IN] Type of message box.
//		nError		[IN] ID of a mesage to display if exception has no message.
//
//	Return Value:
//		Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
	UINT nType /* = MB_OK */,
	UINT nError /* = 0 */
	)
{
	TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
	int     nDisposition;
	UINT    nHelpContext;

	if ( GetErrorMessage( szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
	{
		nDisposition = EXC_AppMessageBox( szErrorMessage, nType, nHelpContext );
	} // if:  error message retrieved successfully
	else
	{
		if ( nError == 0 )
		{
			nError = IDP_NO_ERROR_AVAILABLE;
		} // if:  no error code
		nDisposition = EXC_AppMessageBox( nError, nType, nHelpContext );
	} // else:  error retrieving error message
	return nDisposition;

} //*** CExceptionWithOper::ReportError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::ReportError
//
//	Routine Description:
//		Report an error from the exception.  This method should be used from
//		all threads except the main thread.
//
//	Arguments:
//		pfnMsgBox	[IN] Message box function pointer.
//		dwParam		[IN] Parameter to pass to the message box function.
//		nType		[IN] Type of message box.
//		nError		[IN] ID of a mesage to display if exception has no message.
//
//	Return Value:
//		Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
	PFNMSGBOX	pfnMsgBox,
	DWORD		dwParam,
	UINT		nType /* = MB_OK */,
	UINT		nError /* = 0 */
	)
{
	TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
	int     nDisposition;
	UINT    nHelpContext;

	ASSERT( pfnMsgBox != NULL );

	if ( GetErrorMessage( szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
	{
		nDisposition = (*pfnMsgBox)( dwParam, szErrorMessage, nType, nHelpContext );
	} // if:  error message retrieved successfully
	else
	{
		if ( nError == 0 )
		{
			nError = IDP_NO_ERROR_AVAILABLE;
		} // if:  no error code
		CString strMsg;
		strMsg.LoadString( nError );
		nDisposition = (*pfnMsgBox)( dwParam, strMsg, nType, nHelpContext );
	} // else:  error retrieving error message
	return nDisposition;

}  //*** CExceptionWithOper::ReportError( pfnMsgBox )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::ReportError
//
//	Routine Description:
//		Report an error from the exception.  This method should be used from
//		all threads except the main thread.
//
//	Arguments:
//		hwndParent	[IN] Parent window.
//		nType		[IN] Type of message box.
//		nError		[IN] ID of a mesage to display if exception has no message.
//
//	Return Value:
//		Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
	HWND	hwndParent,
	UINT	nType /* = MB_OK */,
	UINT	nError /* = 0 */
	)
{
	ASSERT(hwndParent != NULL);

	TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
	int     nDisposition;
	UINT    nHelpContext;

	if ( GetErrorMessage( szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
	{
		nDisposition = EXC_AppMessageBox( hwndParent, szErrorMessage, nType, nHelpContext );
	} // if:  error message retrieved successfully
	else
	{
		if ( nError == 0 )
		{
			nError = IDP_NO_ERROR_AVAILABLE;
		} // if:  no error code
		CString strMsg;
		strMsg.LoadString( nError );
		nDisposition = EXC_AppMessageBox( hwndParent, szErrorMessage, nType, nHelpContext );
	} // else:  error retrieving error message
	return nDisposition;

} //*** CExceptionWithOper::ReportError( pfnMsgBox )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::SetOperation
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::SetOperation(
	IN UINT			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	m_idsOperation = idsOperation;

	if ( pszOperArg1 == NULL )
	{
		m_szOperArg1[0] = _T('\0');
	} // if:  first argument not specified
	else
	{
		::_tcsncpy( m_szOperArg1, pszOperArg1, (sizeof( m_szOperArg1 ) / sizeof( TCHAR )) - 1 );
		m_szOperArg1[(sizeof( m_szOperArg1 ) / sizeof( TCHAR ))- 1] = _T('\0');
	}  // else:  first argument specified

	if ( pszOperArg2 == NULL )
	{
		m_szOperArg2[0] = _T('\0');
	} // if:  second argument not specified
	else
	{
		::_tcsncpy( m_szOperArg2, pszOperArg2, (sizeof( m_szOperArg2 ) / sizeof( TCHAR )) - 1 );
		m_szOperArg2[(sizeof( m_szOperArg2 ) / sizeof( TCHAR )) - 1] = _T('\0');
	}  // else:  second argument specified

} //*** CExceptionWithOper::SetOperation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExceptionWithOper::FormatWithOperation
//
//	Routine Description:
//		Get the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pszMsg			[IN] Message to format with the operation string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::FormatWithOperation(
	OUT LPTSTR	lpszError,
	IN UINT		nMaxError,
	IN LPCTSTR	pszMsg
	)
{
	DWORD		dwResult;
	TCHAR		szOperation[EXCEPT_MAX_OPER_ARG_LENGTH];
	TCHAR		szFmtOperation[EXCEPT_MAX_OPER_ARG_LENGTH * 3];

	ASSERT( lpszError != NULL );
	ASSERT( nMaxError > 0 );

	// Format the operation string.
	if ( m_idsOperation )
	{
		void *		rgpvArgs[2]	= { m_szOperArg1, m_szOperArg2 };

		// Load the operation string.
		dwResult = ::LoadString( EXC_GetResourceInstance(), m_idsOperation, szOperation, (sizeof( szOperation ) / sizeof( TCHAR )) );
		ASSERT( dwResult != 0 );

		// Format the operation string.
		::FormatMessage(
					FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
					szOperation,
					0,
					MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
					szFmtOperation,
					sizeof( szFmtOperation ) / sizeof( TCHAR ),
					(va_list *) rgpvArgs
					);
		szFmtOperation[(sizeof( szFmtOperation ) / sizeof( TCHAR )) - 1] = _T('\0');

		// Format the final error message.
		if ( pszMsg != NULL )
		{
			::_sntprintf( lpszError, nMaxError - 1, _T("%s\n\n%s"), szFmtOperation, pszMsg );
		} // if:  additional message specified
		else
		{
			::_tcsncpy(lpszError, szFmtOperation, nMaxError - 1);
		} // else:  no additional message specified
		lpszError[nMaxError - 1] = _T('\0');
	}  // if:  operation string specified
	else
	{
		if ( pszMsg != NULL )
		{
			::_tcsncpy( lpszError, pszMsg, nMaxError - 1 );
			lpszError[nMaxError - 1] = _T('\0');
		}  // if:  additional message specified
		else
		{
			lpszError[0] = _T('\0');
		} // if:  no additional message specified
	}  // else:  no operation string specified

} //*** CExceptionWithOper::FormatWithOperation()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// class CNTException
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CNTException, CExceptionWithOper )
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNTException::FormatErrorMessage
//
//	Routine Description:
//		Format the error message represented by the exception.
//
//	Arguments:
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//		pnHelpContext	[OUT] Help context for the error message.
//		bIncludeID		[IN] Include the ID in the message.
//
//	Return Value:
//		TRUE		Message available.
//		FALSE		No message available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNTException::FormatErrorMessage(
	LPTSTR	lpszError,
	UINT	nMaxError,
	PUINT	pnHelpContext,
	BOOL	bIncludeID
	)
{
	DWORD		dwResult;
	TCHAR		szNtMsg[1024];

	// Format the NT status code.
	::FormatErrorMessage( m_sc, szNtMsg, sizeof( szNtMsg ) / sizeof( TCHAR ) );

	// Format the message with the operation string.
	FormatWithOperation( lpszError, nMaxError, szNtMsg );

	// Add the error ID.
	if ( bIncludeID )
	{
		UINT	nMsgLength = _tcslen( lpszError );
		TCHAR	szErrorFmt[EXCEPT_MAX_OPER_ARG_LENGTH];

		if ( nMsgLength - 1 < nMaxError )
		{
			dwResult = ::LoadString( EXC_GetResourceInstance(), IDS_ERROR_MSG_ID, szErrorFmt, (sizeof( szErrorFmt ) / sizeof( TCHAR )) );
			ASSERT( dwResult != 0 );
			::_sntprintf( &lpszError[nMsgLength], nMaxError - nMsgLength - 1, szErrorFmt, m_sc, m_sc );
		}  // if:  there is room for the error ID
	}  // if:  error ID should be included

	return TRUE;

} //*** CNTException::FormatErrorMessage()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

static CNTException			gs_nte( ERROR_SUCCESS, NULL, NULL, NULL, FALSE );
static CExceptionWithOper	gs_ewo( NULL, NULL, NULL, FALSE );

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ThrowStaticException
//
//	Purpose:
//		Throw the static NT Exception.
//
//	Arguments:
//		sc				[IN] NT status code.
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
	IN SC			sc,
	IN UINT			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	gs_nte.SetOperation( sc, idsOperation, pszOperArg1, pszOperArg2 );
	TraceError( gs_nte );
	throw &gs_nte;

} //*** ThrowStaticException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ThrowStaticException
//
//	Purpose:
//		Throw the static Cluster Administrator Exception.
//
//	Arguments:
//		idsOperation	[IN] String ID for operation occurring during exception.
//		pszOperArg1		[IN] 1st argument to operation string.
//		pszOperArg2		[IN] 2nd argument to operation string.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
	IN UINT			idsOperation,
	IN LPCTSTR		pszOperArg1,
	IN LPCTSTR		pszOperArg2
	)
{
	gs_ewo.SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
	TraceError( gs_ewo );
	throw &gs_ewo;

} //*** ThrowStaticException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	FormatErrorMessage
//
//	Routine Description:
//		Format the error message represented by the exception.
//
//	Arguments:
//		sc				[IN] Status code.
//		lpszError		[OUT] String in which to return the error message.
//		nMaxError		[IN] Maximum length of the output string.
//
//	Return Value:
//		TRUE		Message available.
//		FALSE		No message available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL FormatErrorMessage(
	DWORD	sc,
	LPTSTR	lpszError,
	UINT	nMaxError
	)
{
	DWORD		_cch;

	// Format the NT status code from the system.
	_cch = FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					NULL,
					sc,
					MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
					lpszError,
					nMaxError,
					0
					);
	if ( _cch == 0 )
	{
		Trace( g_tagError, _T("Error %d getting message from system for error code %d"), GetLastError(), sc );

		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		_cch = FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						GetModuleHandle( _T("NTDLL.DLL") ),
						sc,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
						lpszError,
						nMaxError,
						0
						);
		if ( _cch == 0 )
		{

#ifdef _DEBUG

			DWORD	_sc = GetLastError();
                        _sc=_sc;
			Trace( g_tagError, _T("Error %d getting message from NTDLL.DLL for error code %d"), _sc, sc );

#endif

			lpszError[0] = _T('\0');

		}  // if:  error formatting status code from NTDLL
	}  // if:  error formatting status code from system

	return TRUE;

} //*** FormatErrorMessage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Abstract:
//		Definitions of routines for extension registration.
//
//	Implementation File:
//		RegExt.cpp
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGEXT_H_
#define _REGEXT_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _REGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		PropList.h
//
//	Implementation File:
//		PropList.cpp
//
//	Description:
//		Definition of the CClusPropList class.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//		12/18/1998	GalenB	Added MoveFirst, MoveNext, and other parsing
//							methods.
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PROPLIST_H_
#define _PROPLIST_H_

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CObjectProperty;
class CClusPropValueList;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if !defined( ASSERT )
#include <crtdbg.h>
#define ASSERT _ASSERTE
#endif // !defined( ASSERT )

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjectProperty
//
//	Description:
//		Describes a property in a cluster property list.
//
//	Inheritance:
//		CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////

#if defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		LONG *		pl;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;
	CValue					m_valueEx;		// expand_sz value (if any)

	DWORD					m_fFlags;

	enum ObjPropFlags
	{
		opfNew = 1
	};

	CObjectProperty::CObjectProperty( void )
	{
		m_value.pstr = NULL;
		m_value.pcb = NULL;
		m_valuePrev.pstr = NULL;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
	};

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	void	SetExpandSz(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	// Set() to get extra EXPANDED_SZ value
	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN CString & rstrValueEx,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valueEx.pstr = &rstrValueEx;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	// Set() to get extra EXPANDED_SZ value
	void	SetExpandSz(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN CString & rstrValueEx,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valueEx.pstr = &rstrValueEx;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	void	Set(
				IN LPCWSTR pwszName,
				IN LONG & rnValue,
				IN LONG & rnPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_LONG;
		m_value.pl = &rnValue;
		m_valuePrev.pl = &rnPrevValue;
		m_fFlags = fFlags;

	} //*** Set( LONG & )

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_valuePrev.pdw = &rdwPrevValue;
		m_fFlags = fFlags;

	} //*** Set( DWORD & )

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_valuePrev.pb = &rbPrevValue;
		m_fFlags = fFlags;

	} //*** Set( BOOL & )

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
		m_fFlags = fFlags;

	} //*** Set( PBYTE & )

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = reinterpret_cast< PBYTE * >( &rpwszValue );
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = reinterpret_cast< PBYTE * >( &rpwszPrevValue );
		m_valuePrev.pcb = &rcbPrevValue;
		m_fFlags = fFlags;

	} //*** Set( LPWSTR & )

}; //*** class CObjectProperty

#endif	// defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropValueList
//
//	Description:
//		Describes a cluster property list.
//
//	Inheritance:
//		CClusPropValueList
//		CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusPropValueList
#ifdef __AFX_H__
	: public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
	DECLARE_DYNAMIC( CClusPropValueList );
#endif // __AFX_H__

public:
	//
	// Construction.
	//

	// Default constructor
	CClusPropValueList( void )
		: m_cbDataSize( 0 )
		, m_cbDataLeft( 0 )
		, m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		m_cbhValueList.pb = NULL;
		m_cbhCurrentValue.pb = NULL;

	} //*** CClusPropValueList()

	// Copy constructor.
	CClusPropValueList( IN const CClusPropValueList & rcpvl )
		: m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		Init( rcpvl );

	} //*** CClusPropValueList()

	// Buffer helper constructor.
	CClusPropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
		: m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		Init( cbhValueList, cbDataSize );

	} //*** CClusPropValueList()

	// Destructor
	~CClusPropValueList( void )
	{
		DeleteValueList();

	} //*** ~CClusPropValueList()

	// Initialize the value list
	void Init( IN const CClusPropValueList & rcpvl )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= rcpvl.m_cbhValueList;
		m_cbhCurrentValue	= rcpvl.m_cbhCurrentValue;
		m_cbDataSize		= rcpvl.m_cbDataSize;
		m_cbDataLeft		= rcpvl.m_cbDataLeft;
		m_bAtEnd			= rcpvl.m_bAtEnd;

	} //*** Init()

	// Initialize the value list from a buffer helper
	void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= cbhValueList;
		m_cbhCurrentValue	= cbhValueList;
		m_cbDataSize		= cbDataSize;
		m_cbDataLeft		= cbDataSize;
		m_bAtEnd			= FALSE;

	} //*** Init()

	// Assignment operator
	void operator=( IN const CClusPropValueList & rcpvl )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= rcpvl.m_cbhValueList;
		m_cbhCurrentValue	= rcpvl.m_cbhCurrentValue;
		m_cbDataSize		= rcpvl.m_cbDataSize;
		m_cbDataLeft		= rcpvl.m_cbDataLeft;
		m_bAtEnd			= rcpvl.m_bAtEnd;

	} //*** operator=()

public:
	//
	// Accessor methods.
	//

	// Buffer helper cast operator to access the current value
	operator const CLUSPROP_BUFFER_HELPER( void ) const
	{
		return m_cbhCurrentValue;

	} //*** operator CLUSPROP_BUFFER_HELPER()

	// Access the value list
	CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
	{
		return m_cbhValueList;

	} //*** CbhValueList()

	// Access the current value
	CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
	{
		return m_cbhCurrentValue;

	} //*** CbhCurrentValue()

	// Access the format of the current value
	CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

	} //*** CpfCurrentValueFormat()

	// Access the type of the current value
	CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

	} //*** CptCurrentValueType()

	// Access the syntax of the current value
	CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

	} //*** CpsCurrentValueSyntax()

	// Access the length of the data of the current value
	DWORD CbCurrentValueLength( void ) const
	{
		DWORD cbLength;

		if ( m_cbhCurrentValue.pb == NULL )
		{
			cbLength = 0;
		} // if: no value list allocated yet
		else
		{
			cbLength = m_cbhCurrentValue.pValue->cbLength;
		} // else: value list allocated

		return cbLength;

	} //*** CbCurrentValueLength()

	// Access size of the data in the buffer.
	DWORD CbDataSize( void ) const
	{
		return m_cbDataSize;

	} //*** CbDataSize()

	// Access amount of data left in buffer after current value
	DWORD CbDataLeft( void ) const
	{
		return m_cbDataLeft;

	} //*** CbDataLeft()

public:
	//
	// Parsing methods.
	//

	// Move to the first value in the list
	DWORD ScMoveToFirstValue( void );

	// Move the value after the current one in the list
	DWORD ScMoveToNextValue( void );

	// Query whether we are at the last value in the list or not
	DWORD ScCheckIfAtLastValue( void );

public:
	//
	// Methods for building a value list.
	//

	// Allocate a value list
	DWORD ScAllocValueList( IN DWORD cbMinimum );

	// Delete the value list buffer and cleanup support variables
	void DeleteValueList( void )
	{
		//
		// If m_cbBufferSize is greater then 0 then we allocated the value list.
		// If it's zero then the value list is a part of the property list in
		// CClusPropList.
		//
		if ( m_cbBufferSize > 0 )
		{
			delete [] m_cbhValueList.pb;
			m_cbhValueList.pb = NULL;
			m_cbhCurrentValue.pb = NULL;
			m_cbBufferSize = 0;
			m_cbDataSize = 0;
			m_cbDataLeft = 0;
			m_bAtEnd = FALSE;
		} // if: we allocated anything

	} //*** DeletePropList()

	// Get a value list from a resource
	DWORD ScGetResourceValueList(
						IN HRESOURCE	hResource,
						IN DWORD		dwControlCode,
						IN HNODE		hHostNode		= NULL,
						IN LPVOID		lpInBuffer		= NULL,
						IN DWORD		cbInBufferSize	= 0
						);

	// Get a value list from a resource type
	DWORD ScGetResourceTypeValueList(
						IN HCLUSTER	hCluster,
						IN LPCWSTR	pwszResTypeName,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

private:
	CLUSPROP_BUFFER_HELPER	m_cbhValueList;		// Pointer to the value list for parsing.
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentValue;	// Pointer to the current value for parsing.
	DWORD					m_cbDataSize;		// Amount of data in the buffer.
	DWORD					m_cbDataLeft;		// Amount of data left in buffer after current value.
	DWORD					m_cbBufferSize;		// Size of the buffer if we allocated it.
	BOOL					m_bAtEnd;			// Indicates whether at last value in list.

}; //*** class CClusPropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropList
//
//	Description:
//		Describes a cluster property list.
//
//	Inheritance:
//		CClusPropList
//		CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusPropList
#ifdef __AFX_H__
	: public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
	DECLARE_DYNAMIC( CClusPropList );
#endif // __AFX_H__

public:
	//
	// Construction.
	//

	// Default constructor
	CClusPropList( IN BOOL bAlwaysAddProp = FALSE )
		: m_bAlwaysAddProp( bAlwaysAddProp )
		, m_cbBufferSize( 0 )
		, m_cbDataSize( 0 )
		, m_cbDataLeft( 0 )
		, m_nPropsRemaining( 0 )
	{
		m_cbhPropList.pList		= NULL;
		m_cbhCurrentProp.pb		= NULL;
		m_cbhCurrentPropName.pb	= NULL;

	} //*** CClusPropList()

	// Destructor
	~CClusPropList( void )
	{
		DeletePropList();

	} //*** ~CClusPropList()

	// Copy list into this list (like assignment operator)
	DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN DWORD cbListSize );

	// Delete the property list buffer and cleanup support variables
	void DeletePropList( void )
	{
		delete [] m_cbhPropList.pb;
		m_cbhPropList.pb = NULL;
		m_cbhCurrentProp.pb = NULL;
		m_cbhCurrentPropName.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
		m_cbDataLeft = 0;

	} //*** DeletePropList()

protected:
	//
	// Attributes.
	//

	BOOL					m_bAlwaysAddProp;		// Indicate if properties should be added even if not different.
	CLUSPROP_BUFFER_HELPER	m_cbhPropList;			// Pointer to the beginning of the list.
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentProp;		// Pointer to the current property.
	DWORD					m_cbBufferSize;			// Allocated size of the buffer.
	DWORD					m_cbDataSize;			// Amount of data in the buffer.
	DWORD					m_cbDataLeft;			// Amount of data left in buffer after current value.

private:
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentPropName;	// Pointer to the current name for parsing
	DWORD					m_nPropsRemaining;		// Used by BMoveToNextProperty() to track end of list.
	CClusPropValueList		m_pvlValues;			// Helper class for value list of current property.

public:
	//
	// Accessor methods.
	//

	// Access the values of the current property
	const CClusPropValueList & RPvlPropertyValue( void )
	{
		return m_pvlValues;

	} //*** RPvlPropertyValue()

	// Access the property list
	operator PCLUSPROP_LIST( void ) const
	{
		return m_cbhPropList.pList;

	} //*** operator PCLUSPROP_LIST()

	// Access allocated size of the buffer
	DWORD CbBufferSize( void ) const
	{
		return m_cbBufferSize;

	} //*** CbBufferSize()

	// Access the name of the current property
	LPCWSTR PszCurrentPropertyName( void ) const
	{
		return m_cbhCurrentPropName.pName->sz;

	} //*** PszCurrentPropertyName()

	// Access the current property name as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
	{
		return m_cbhCurrentPropName;

	} //*** CbhCurrentPropertyName()

	// Access value list of the current property as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
	{
		return m_pvlValues.CbhValueList();

	} //*** CbhCurrentValueList()

	// Access current value of the current property as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
	{
		return m_pvlValues.CbhCurrentValue();

	} //*** CbhCurrentValue()

	// Access the format of the current value of the current property
	CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
	{
		return m_pvlValues.CpfCurrentValueFormat();

	} //*** CpfCurrentValueFormat()

	// Access the type of the current value of the current property
	CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
	{
		return m_pvlValues.CptCurrentValueType();

	} //*** CptCurrentValueType()

	// Access the syntax of the current value of the current property
	CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
	{
		return m_pvlValues.CpsCurrentValueSyntax();

	} //*** CpsCurrentValueSyntax()

	// Access the length of the current value of the current property
	DWORD CbCurrentValueLength( void ) const
	{
		return m_pvlValues.CbCurrentValueLength();

	} //*** CbCurrentValueLength()

	PCLUSPROP_LIST Plist( void )
	{
		return m_cbhPropList.pList;

	} //*** Plist()

	const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
	{
		return m_cbhPropList;

	} //*** CbhPropList()

	PBYTE PbPropList( void ) const
	{
		return m_cbhPropList.pb;

	} //*** PbPropList()

	DWORD CbPropList( void ) const
	{
		return m_cbDataSize + sizeof( CLUSPROP_SYNTAX ); /*endmark*/

	} //*** CbPropList()

	// Access amount of data left in buffer after current value
	DWORD CbDataLeft( void ) const
	{
		return m_cbDataLeft;

	} //*** CbDataLeft()

	DWORD Cprops( void ) const
	{
		if ( m_cbhPropList.pb == NULL )
		{
			return 0;
		} // if:  no buffer yet

		return m_cbhPropList.pList->nPropertyCount;

	} //*** Cprops()

public:
	//
	// Parsing methods.
	//

	// Initialize the size after getting properties from an external source
	void InitSize( IN DWORD cbSize )
	{
		ASSERT( m_cbhPropList.pb != NULL );
		ASSERT( m_cbBufferSize > 0 );

		m_cbDataSize = cbSize;
		m_cbDataLeft = cbSize;

	} //*** InitSize()

	// Move to the first property in the list
	DWORD ScMoveToFirstProperty( void );

	// Move the property after the current one in the list
	DWORD ScMoveToNextProperty( void );

	// Move to a property by specifying its name
	DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

	// Move to the first value in the current property
	DWORD ScMoveToFirstPropertyValue( void )
	{
		return m_pvlValues.ScMoveToFirstValue();

	} //*** ScMoveToFirstPropertyValue()

	// Move the the value after the current on in the current property
	DWORD ScMoveToNextPropertyValue( void )
	{
		return m_pvlValues.ScMoveToNextValue();

	} //*** ScMoveToNextPropertyValue()

	// Query whether we are at the last property in the list or not
	DWORD ScCheckIfAtLastProperty( void ) const
	{
		DWORD _sc;

		if ( m_nPropsRemaining <= 1 )
		{
			_sc = ERROR_NO_MORE_ITEMS;
		} // if:  at the last property
		else
		{
			_sc = ERROR_SUCCESS;
		} // else:  not at the last property

		return _sc;

	} //*** ScCheckIfAtLastProperty()

	// Query whether the list is empty or not
	BOOL BIsListEmpty( void ) const
	{
		ASSERT( m_cbhPropList.pb != NULL );
		ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

		return m_cbhPropList.pList->nPropertyCount == 0;

	} //*** BIsListEmpty()

public:
	//
	// Methods for building a property list.
	//

	// Allocate a property list
	DWORD ScAllocPropList( IN DWORD cbMinimum );

	void ClearPropList( void )
	{
		m_cbDataSize = 0;
		m_cbDataLeft = 0;

		if ( m_cbBufferSize != 0 )
		{
			ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
			m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
			m_cbhCurrentPropName = m_cbhCurrentProp;
		} // if:  buffer already allocated

	} //*** ClearPropList()

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

#if CLUSAPI_VERSION >= 0x0500

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

#endif // CLUSAPI_VERSION >= 0x0500

	DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

	DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

	DWORD ScAddProp(
			IN LPCWSTR		pwszName,
			IN const PBYTE	pbValue,
			IN DWORD		cbValue,
			IN const PBYTE	pbPrevValue,
			IN DWORD		cbPrevValue
			);

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
	{
		return ScAddProp( pwszName, pwszValue, NULL );

	} //*** ScAddProp()

	DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
	{
		return ScAddExpandSzProp( pwszName, pwszValue, NULL );

	} //*** ScAddExpandSzProp()

public:
	//
	// Get Property methods.
	//

	DWORD ScGetNodeProperties(
						IN HNODE	hNode,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetGroupProperties(
						IN HGROUP	hGroup,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetResourceProperties(
						IN HRESOURCE	hResource,
						IN DWORD		dwControlCode,
						IN HNODE		hHostNode		= NULL,
						IN LPVOID		lpInBuffer		= NULL,
						IN DWORD		cbInBufferSize	= 0
						);

	DWORD ScGetResourceTypeProperties(
						IN HCLUSTER	hCluster,
						IN LPCWSTR	pwszResTypeName,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetNetworkProperties(
						IN HNETWORK	hNetwork,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetNetInterfaceProperties(
						IN HNETINTERFACE	hNetInterface,
						IN DWORD			dwControlCode,
						IN HNODE			hHostNode		= NULL,
						IN LPVOID			lpInBuffer		= NULL,
						IN DWORD			cbInBufferSize	= 0
						);

#if CLUSAPI_VERSION >= 0x0500

	DWORD ScGetClusterProperties(
						IN HCLUSTER	hCluster,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

#endif // CLUSAPI_VERSION >= 0x0500

// Implementation
protected:
	void CopyProp(
			IN PCLUSPROP_SZ				pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyExpandSzProp(
			IN PCLUSPROP_SZ				pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyMultiSzProp(
			IN PCLUSPROP_MULTI_SZ		pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyProp(
			IN PCLUSPROP_DWORD			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN DWORD					nValue
			);

#if CLUSAPI_VERSION >= 0x0500

	void CopyProp(
			IN PCLUSPROP_LONG			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LONG						nValue
			);

#endif // CLUSAPI_VERSION >= 0x0500

	void CopyProp(
			OUT	CLUSPROP_ULARGE_INTEGER UNALIGNED *	pprop,
			IN	CLUSTER_PROPERTY_TYPE		proptype,
			IN	ULONGLONG					nValue
			);

	void CopyProp(
			IN PCLUSPROP_BINARY			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN const PBYTE				pb,
			IN size_t					cb
			);

	void CopyEmptyProp(
			IN PCLUSPROP_VALUE			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN CLUSTER_PROPERTY_FORMAT	propfmt
			);

}; //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // _PROPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\restypeutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ResTypeUtils.cpp
//
//	Description:
//		Resource type utilities.
//
//	Author:
//		Galen Barbee	(galenb)	11-Jan-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <clusapi.h>
#include "ResTypeUtils.h"
#include "PropList.h"
#include "ClusWrap.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ScResTypeNameToDisplayName
//
//	Description:
//		Retrieve the display name for a specified resource type name.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster containing the resource type.
//		pszTypeName		[IN] Name of resource type.
//		ppszDisplayName	[IN] Pointer in which to return string containing
//							the resource type display name.  Caller must
//							deallocate this buffer by calling LocalFree().
//
//	Return Value:
//		Any status returns from CClusPropList::ScGetResourceTypeProperties(),
//		CClusPropList::ScMoveToPropertyByName(), or LocalAlloc().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ScResTypeNameToDisplayName(
	HCLUSTER	hCluster,
	LPCWSTR		pszTypeName,
	LPWSTR *	ppszDisplayName
	)
{
	DWORD			_sc	= ERROR_SUCCESS;
	DWORD			_cbSize;
	CClusPropList	_PropList;

	// Use the proplist helper class.

	*ppszDisplayName = NULL;

	_sc = _PropList.ScGetResourceTypeProperties(
				hCluster,
				pszTypeName,
				CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
				);

	if ( _sc != ERROR_SUCCESS )
	{
		return _sc;
	} // if: error getting common properties

	// Find the name property.
	_sc = _PropList.ScMoveToPropertyByName( _T("Name") );
	if ( _sc != ERROR_SUCCESS )
	{
		return _sc;
	} // if:  property not found

	_cbSize = lstrlenW( _PropList.CbhCurrentValue().pStringValue->sz ) + 1;
	_cbSize *= sizeof( *(_PropList.CbhCurrentValue().pStringValue->sz) );

	*ppszDisplayName = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_ZEROINIT, _cbSize ) );
	if ( *ppszDisplayName != NULL )
	{
		lstrcpyW( *ppszDisplayName, _PropList.CbhCurrentValue().pStringValue->sz );
	} // if:  buffer allocated successfully
	else
	{
		_sc = GetLastError();
	} // else: error allocating buffer

	return _sc;

} //*** ScResTypeNameToDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ScResDisplayNameToTypeName
//
//	Routine Description:
//		Retrieve the type name for a specified resource type display name.
//
//	Arguments:
//		pszTypeName		[IN] Name of resource type.
//		ppszTypeyName	[IN] Pointer in which to return string containing
//							the resource type name.  Caller must deallocate
//							this buffer by calling LocalFree().
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ScResDisplayNameToTypeName(
	HCLUSTER	hCluster,
	LPCWSTR		pszDisplayName,
	LPWSTR *	ppszTypeName
	)
{
	DWORD		_sc = ERROR_SUCCESS;
	HCLUSENUM	_hEnum;
	DWORD		_dwIndex;
	DWORD		_dwType;
	DWORD		_dwSize;
	LPWSTR		_pszName = NULL;
	LPWSTR		_pszTestDisplayName;
	BOOL		_bFound = FALSE;

	// Enumerate resources
	_hEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESTYPE );
	if ( _hEnum == NULL )
	{
		return GetLastError();
	} // if:  error opening the enumeration

	for ( _dwIndex = 0 ; ! _bFound && _sc == ERROR_SUCCESS ; _dwIndex++ )
	{
		_pszName = _pszTestDisplayName = NULL;

		_sc = WrapClusterEnum( _hEnum, _dwIndex, &_dwType, &_pszName );
		if ( _sc == ERROR_SUCCESS )
		{
			_sc = ScResTypeNameToDisplayName( hCluster, _pszName, &_pszTestDisplayName );
			if ( _sc == ERROR_SUCCESS )
			{
				ASSERT( _pszTestDisplayName != NULL );
				_bFound = lstrcmpiW( pszDisplayName, _pszTestDisplayName ) == 0;

				if ( _bFound )
				{
					_dwSize = lstrlenW( _pszName ) + 1;
					_dwSize *= sizeof( *_pszName );

					*ppszTypeName = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_ZEROINIT, _dwSize ) );
					if ( *ppszTypeName == NULL )
					{
						_sc = GetLastError();
					} // if:  error allocating memory
					else
					{
						lstrcpyW( *ppszTypeName, _pszName );
					} // else:  memory allocated successfully
				} // if:  found the display name
			} // if:  retrieved display name
			else
			{
				// If there was an error getting the display name of this resource type,
				// continue with the enumeration, so that if one resource type fails, we do
				// not abort getting the display name of resources further down in the 
				// enumeration list.
				_sc = ERROR_SUCCESS;
			} // else:	could not retrieve the display name.

		} // if: successfully retrieved next resource type from enumeration

		if ( _pszName != NULL )
		{
			LocalFree( _pszName );
		} // if:  name string was allocated

		if ( _pszTestDisplayName != NULL )
		{
			LocalFree( _pszTestDisplayName );
		} // if:  test display name string was allocated
	} // for:  each resource type

	if ( ( _sc == ERROR_NO_MORE_ITEMS ) || ( _bFound == FALSE ) )
	{
		_sc = ERROR_INVALID_PARAMETER;
	} // if:  resource type not found

	return _sc;

} //*** ScResDisplayNameToTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		PropList.cpp
//
//	Description:
//		Implementation of the CClusPropList class.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//		Galen Barbee (galenb)	December 18, 1998
//			Added parsing methods.
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "PropList.h"
#include "BarfClus.h"

#ifdef _DEBUG
#ifdef __AFX_H__
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // __AFX_H__
#endif

#ifndef __AFX_H__
class CMemoryException
{
public:
	void Delete( void ) { }

}; //*** class CMemoryException
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CchMultiSz
//
//	Description:
//		Length of all of the substrings of a multisz string minus the final NULL.
//
//		(i.e., includes the nulls of the substrings, excludes the final null)
//		multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//	Arguments:
//		psz		[IN] The string to get the length of.
//
//	Return Value:
//		Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static size_t CchMultiSz(
	IN LPCWSTR psz
	)
{
	ASSERT( psz != NULL );

	size_t	_cchTotal = 0;
	size_t	_cchChars;

	while ( *psz != _T( '\0' ) )
	{
		_cchChars = lstrlenW( psz ) + 1;

		_cchTotal += _cchChars;
		psz += _cchChars;
	} // while: pointer not stopped on EOS

	return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//	NCompareMultiSz
//
//	Description:
//		Compare two MULTI_SZ buffers.
//
//	Arguments:
//		pszSource	[IN] The source string.
//		pszTarget	[IN] The target string.
//
//	Return Value:
//		If the string pointed to by pszSource is less than the string pointed
//		to by pszTarget, the return value is negative. If the string pointed
//		to by pszSource is greater than the string pointed to by pszTarget,
//		the return value is positive. If the strings are equal, the return value
//		is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
	IN LPCWSTR pszSource,
	IN LPCWSTR pszTarget
	)
{
	ASSERT( pszSource != NULL );
	ASSERT( pszTarget != NULL );

	while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
	{
		//
		// Move to end of strings.
		//
		while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
		{
			++pszSource;
			++pszTarget;
		} // while: pointer not stopped on EOS

		//
		// If strings are the same, skip past terminating NUL.
		// Otherwise exit the loop.
		if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
		{
			++pszSource;
			++pszTarget;
		} // if: both stopped on EOS
		else
		{
			break;
		} // else: stopped because something is not equal -- wr are done.

	} // while: pointer not stopped on EOS

	return *pszSource - *pszTarget;

} //*** NCompareMultiSz()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropValueList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropValueList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScMoveToFirstValue
//
//	Description:
//		Move the cursor to the first value in the value list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS	Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToFirstValue( void )
{
	ASSERT( m_cbhValueList.pb != NULL );

	DWORD	_sc;

	m_cbhCurrentValue = m_cbhValueList;
	m_cbDataLeft = m_cbDataSize;
	m_bAtEnd = FALSE;

	if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
	{
		_sc = ERROR_NO_MORE_ITEMS;
	} // if: no items in the value list
	else
	{
		_sc = ERROR_SUCCESS;
	} // else: items exist in the value list

	return _sc;

} //*** CClusPropValueList::ScMoveToFirstValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScMoveToNextValue
//
//	Description:
//		Move the cursor to the next value in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the next value successfully.
//		ERROR_NO_MORE_ITEMS	Already at the end of the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToNextValue( void )
{
	ASSERT( m_cbhCurrentValue.pb != NULL );

	DWORD					_sc		= ERROR_NO_MORE_ITEMS;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;

	_cbhCurrentValue = m_cbhCurrentValue;

	do
	{
		//
		// Don't try to move if we're already at the end.
		//
		if ( m_bAtEnd )
		{
			break;
		} // if: already at the end of the list

		//
		// Make sure the buffer is big enough for the value header.
		//
		if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance buffer pointer.
		//
		_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
					+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

		//
		// Make sure the buffer is big enough for the value header,
		// the data itself, and the endmark.
		//
		if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Move past the current value to the next value's syntax.
		//
		_cbhCurrentValue.pb += _cbDataSize;

		//
		// This test will ensure that the value is always valid since we won't
		// advance if the next thing is the endmark.
		//
		if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
		{
			m_cbhCurrentValue = _cbhCurrentValue;
			m_cbDataLeft -= _cbDataSize;
			_sc = ERROR_SUCCESS;
		} // if: next value's syntax is not the endmark
		else
		{
			m_bAtEnd = TRUE;
		} // else: next value's syntax is the endmark
	} while ( 0 );

	return _sc;

} //*** CClusPropValueList::ScMoveToNextValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScCheckIfAtLastValue
//
//	Description:
//		Indicate whether we are on the last value in the list or not.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Not currently at the last value in the list.
//		ERROR_NO_MORE_ITEMS	Currently at the last value in the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScCheckIfAtLastValue( void )
{
	ASSERT( m_cbhCurrentValue.pb != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;
	DWORD					_cbDataSize;

	_cbhCurrentValue = m_cbhCurrentValue;

	do
	{
		//
		// Don't try to recalculate if we already know
		// we're at the end of the list.
		//
		if ( m_bAtEnd )
		{
			break;
		} // if: already at the end of the list

		//
		// Make sure the buffer is big enough for the value header.
		//
		if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance buffer pointer.
		//
		_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
					+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

		//
		// Make sure the buffer is big enough for the value header,
		// the data itself, and the endmark.
		//
		if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Move past the current value to the next value's syntax.
		//
		_cbhCurrentValue.pb += _cbDataSize;

		//
		// We are on the last value if the next thing after this value
		// is an endmark.
		//
		if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
		{
			_sc = ERROR_NO_MORE_ITEMS;
		} // if: next value's syntax is the endmark
	} while ( 0 );

	return _sc;

} //*** CClusPropValueList::ScCheckIfAtLastValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScAllocValueList
//
//	Description:
//		Allocate a value list buffer that's big enough to hold the next
//		value.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the value list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScAllocValueList( IN DWORD cbMinimum )
{
	ASSERT( cbMinimum > 0 );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbTotal = 0;

	//
	// Add the size of the item count and final endmark.
	//
	cbMinimum += sizeof( CLUSPROP_VALUE );
	_cbTotal = m_cbDataSize + cbMinimum;

	if ( m_cbBufferSize < _cbTotal )
	{
		PBYTE	_pbNewValuelist = NULL;

		cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
		_cbTotal = m_cbDataSize + cbMinimum;

		//
		// Allocate and zero a new buffer.
		//
		_pbNewValuelist = new BYTE[ _cbTotal ];
		if ( _pbNewValuelist != NULL )
		{
			ZeroMemory( _pbNewValuelist, _cbTotal );

			//
			// If there was a previous buffer, copy it and the delete it.
			//
			if ( m_cbhValueList.pb != NULL )
			{
				if ( m_cbDataSize != 0 )
				{
					CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
				} // if: data already exists in buffer

				delete [] m_cbhValueList.pb;
				m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
			} // if: there was a previous buffer
			else
			{
				m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
			} // else: no previous buffer

			//
			// Save the new buffer.
			//
			m_cbhValueList.pb = _pbNewValuelist;
			m_cbBufferSize = _cbTotal;
		} // if: allocation succeeded
		else
		{
			_sc = ERROR_NOT_ENOUGH_MEMORY;
		} // else: allocation failed
	} // if: buffer isn't big enough

	return _sc;

} //*** CClusPropValueList::ScAllocValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScGetResourceValueList
//
//	Description:
//		Get value list of a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceValueList(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hResource != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cb = 512;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get values.
	//
	_sc = ScAllocValueList( _cb );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhValueList.pb,
						m_cbBufferSize,
						&_cb
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocValueList( _cb );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceControl(
								hResource,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhValueList.pb,
								m_cbBufferSize,
								&_cb
								);
			} // if: ScAllocValueList succeeded
		} // if: buffer too small
	} // if: ScAllocValueList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeleteValueList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cb;
		m_cbDataLeft = _cb;
	} // else: no errors

	return _sc;

} //*** CClusPropValueList::ScGetResourceValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScGetResourceTypeValueList
//
//	Description:
//		Get value list of a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceTypeValueList(
	IN HCLUSTER	hCluster,
	IN LPCWSTR	pwszResTypeName,
	IN DWORD	dwControlCode,
	IN HNODE	hHostNode,
	IN LPVOID	lpInBuffer,
	IN DWORD	cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( pwszResTypeName != NULL );
	ASSERT( *pwszResTypeName != L'\0' );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cb = 512;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get values.
	//
	_sc = ScAllocValueList( _cb );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhValueList.pb,
						m_cbBufferSize,
						&_cb
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocValueList( _cb );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceTypeControl(
								hCluster,
								pwszResTypeName,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhValueList.pb,
								m_cbBufferSize,
								&_cb
								);
			} // if: ScAllocValueList succeeded
		} // if: buffer too small
	} // if: ScAllocValueList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeleteValueList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cb;
		m_cbDataLeft = _cb;
	} // else: no errors

	return _sc;

} //*** CClusPropValueList::ScGetResourceTypeValueList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScCopy
//
//	Description:
//		Copy a property list.  This function is equivalent to an assignment
//		operator.  Since this operation can fail, no assignment operator is
//		provided.
//
//	Arguments:
//		pcplPropList	[IN] The proplist to copy into this instance.
//		cbListSize		[IN] The total size of the prop list.
//
//	Return Value:
//		Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScCopy(
	IN const PCLUSPROP_LIST	pcplPropList,
	IN DWORD				cbListSize
	)
{
	ASSERT( pcplPropList != NULL );

	DWORD	_sc = ERROR_SUCCESS;

	//
	// Clean up any vestiges of a previous prop list.
	//
	if ( m_cbhPropList.pb != NULL )
	{
		DeletePropList();
	} // if: the current list is not empty

	//
	// Allocate the new property list buffer.  If successful,
	// copy the source list.
	//
	m_cbhPropList.pb = new BYTE[ cbListSize ];
	if ( m_cbhPropList.pb != NULL )
	{
		CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
		m_cbBufferSize = cbListSize;
		m_cbDataSize   = cbListSize;
		m_cbDataLeft   = cbListSize;
		_sc = ScMoveToFirstProperty();
	} // if: new succeeded
	else
	{
		_sc = ERROR_NOT_ENOUGH_MEMORY;
	} // else:

	return _sc;

} //*** CClusPropList::ScCopy()

////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToFirstProperty
//
//	Description:
//		Move the cursor to the first propery in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the first property successfully.
//		ERROR_NO_MORE_ITEMS	There are no properties in the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToFirstProperty( void )
{
	ASSERT( m_cbhPropList.pb != NULL );
	ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

	DWORD					_sc;
	DWORD					_cbDataLeft;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;

	do
	{
		//
		// Make sure the buffer is big enough for the list header.
		//
		if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data

		//
		// Set the property counter to the number of properties in the list.
		//
		m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

		//
		// Point the name pointer to the first name in the list.
		//
		m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
		m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

		//
		// Check to see if there are any properties in the list.
		//
		if ( m_nPropsRemaining == 0 )
		{
			_sc = ERROR_NO_MORE_ITEMS;
			break;
		} // if: no properties in the list

		//
		// Make sure the buffer is big enough for the first property name.
		//
		if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance the buffer pointer.
		//
		_cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
					+ ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

		//
		// Make sure the buffer is big enough for the name header
		// and the data itself.
		//
		if ( m_cbDataLeft < _cbDataSize )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Point the value buffer to the first value in the list.
		//
		_cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
		_cbDataLeft = m_cbDataLeft - _cbDataSize;
		m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

		//
		// Indicate we are successful.
		//
		_sc = ERROR_SUCCESS;

	} while ( 0 );

	return _sc;

} //*** CClusPropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToNextProperty
//
//	Description:
//		Move the cursor to the next property in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the next property successfully.
//		ERROR_NO_MORE_ITEMS	Already at the end of the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToNextProperty( void )
{
	ASSERT( m_cbhPropList.pb != NULL );
	ASSERT( m_pvlValues.CbhValueList().pb != NULL );

	DWORD					_sc;
	DWORD					_cbNameSize;
	DWORD					_cbDataLeft;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;
	CLUSPROP_BUFFER_HELPER	_cbhPropName;

	_cbhCurrentValue = m_pvlValues;
	_cbDataLeft = m_pvlValues.CbDataLeft();

	//
	// If we aren't already at the last property, attempt to move to the next one.
	//
	_sc = ScCheckIfAtLastProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			//
			// Make sure the buffer is big enough for the value header.
			//
			if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data left

			//
			// Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
			// pointer arithmetic will give undesirable results.
			//
			while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
			{
				//
				// Make sure the buffer is big enough for the value
				// and an endmark.
				//
				_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
							+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
				if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
				{
					_sc = ERROR_INVALID_DATA;
					break;
				} // if: not enough data left

				//
				// Advance past the value.
				//
				_cbhCurrentValue.pb += _cbDataSize;
				_cbDataLeft -= _cbDataSize;
			} // while: not at endmark

			if ( _sc != ERROR_SUCCESS )
			{
				break;
			} // if: error occurred in loop

			//
			// Advanced past the endmark.
			// Size check already performed in above loop.
			//
			_cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
			_cbhCurrentValue.pb += _cbDataSize;
			_cbDataLeft -= _cbDataSize;

			//
			// Point the name pointer to the next name in the list.
			//
			_cbhPropName = _cbhCurrentValue;
			ASSERT( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

			//
			// Calculate the size of the name with header.
			// Make sure the buffer is big enough for the name and an endmark.
			//
			if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data
			_cbNameSize = sizeof( *_cbhPropName.pName )
						+ ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
			if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data

			//
			// Point the value buffer to the first value in the list.
			//
			_cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
			m_cbhCurrentPropName = _cbhPropName;
			m_cbDataLeft = _cbDataLeft - _cbNameSize;
			m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

			//
			// We've successfully advanced to the next property,
			// so there is now one fewer property remaining.
			//
			--m_nPropsRemaining;
			ASSERT( m_nPropsRemaining >= 1 );

			_sc = ERROR_SUCCESS;

		} while ( 0 );
	} // if: not at last property

	return _sc;

} //*** CClusPropList::ScMoveToNextProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToPropertyByName
//
//	Description:
//		Find the passed in property name in the proplist.  Note that the
//		cursor is reset to the beginning at the beginning of the routine and
//		the current state of the cursor is lost.
//
//	Arguments:
//		pwszPropName	[IN] Name of the property
//
//	Return Value:
//		TRUE if the property was found, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
	ASSERT( m_cbhPropList.pb != NULL );

	DWORD	_sc;

	_sc = ScMoveToFirstProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			//
			// See if this is the specified property.  If so, we're done.
			//
			if ( lstrcmpiW( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
			{
				break;
			} // if: property found

			//
			// Advance to the next property.
			//
			_sc = ScMoveToNextProperty();

		} while ( _sc == ERROR_SUCCESS );	// do-while: not end of list
	} // if: successfully moved to the first property

	return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAllocPropList
//
//	Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAllocPropList( IN DWORD cbMinimum )
{
	ASSERT( cbMinimum > 0 );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbTotal = 0;

	//
	// Add the size of the item count and final endmark.
	//
	cbMinimum += sizeof( CLUSPROP_VALUE );
	_cbTotal = m_cbDataSize + cbMinimum;

	if ( m_cbBufferSize < _cbTotal )
	{
		PBYTE	_pbNewProplist = NULL;

		cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
		_cbTotal = m_cbDataSize + cbMinimum;

		//
		// Allocate and zero a new buffer.
		//
		_pbNewProplist = new BYTE[ _cbTotal ];
		if ( _pbNewProplist != NULL )
		{
			ZeroMemory( _pbNewProplist, _cbTotal );

			//
			// If there was a previous buffer, copy it and the delete it.
			//
			if ( m_cbhPropList.pb != NULL )
			{
				if ( m_cbDataSize != 0 )
				{
					CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
				} // if: data already exists in buffer

				delete [] m_cbhPropList.pb;
				m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
			} // if: there was a previous buffer
			else
			{
				m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
			} // else: no previous buffer

			//
			// Save the new buffer.
			//
			m_cbhPropList.pb = _pbNewProplist;
			m_cbBufferSize = _cbTotal;
		} // if: allocation succeeded
		else
		{
			_sc = ERROR_NOT_ENOUGH_MEMORY;
		} // else: allocation failed
	} // if: buffer isn't big enough

	return _sc;

} //*** CClusPropList::ScAllocPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR 	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_SZ			_pValue;

	if (( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ))
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pStringValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddMultiSzProp
//
//	Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddMultiSzProp(
	IN LPCWSTR 	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_MULTI_SZ		_pValue;

	if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (CchMultiSz( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pMultiSzValue;
			CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddExpandSzProp
//
//	Description:
//		Add an EXPAND_SZ string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddExpandSzProp(
	IN LPCWSTR	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_SZ			_pValue;

	if ( ( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ) )
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pStringValue;
			CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		nValue			[IN] Value of the property to set in the list.
//		nPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR	pwszName,
	IN DWORD	nValue,
	IN DWORD	nPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_DWORD			_pValue;

	if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_DWORD )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pDwordValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a LONG property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		nValue			[IN] Value of the property to set in the list.
//		nPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR	pwszName,
	IN LONG		nValue,
	IN LONG		nPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_LONG			_pValue;

	if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_LONG )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pLongValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_BINARY		_pValue;

	//
	// Determine if the buffer has changed.
	//
	if ( m_bAlwaysAddProp || (cbValue != cbPrevValue) )
	{
		bChanged = TRUE;
	} // if: always adding the property or the value size changed
	else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
	{
		bChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
	} // else if: value length changed

	if ( bChanged )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_BINARY )
					+ ALIGN_CLUSPROP( cbValue )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pBinaryValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Routine Description:
//		Add a ULONGLONG property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		ullValue		[IN] Value of the property to set in the list.
//		ullPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR		pwszName,
	IN ULONGLONG	ullValue,
	IN ULONGLONG	ullPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD						_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME		_pName;
	CLUSPROP_ULARGE_INTEGER UNALIGNED *	_pValue;

	if ( m_bAlwaysAddProp || ( ullValue != ullPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pULargeIntegerValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScSetPropToDefault
//
//	Description:
//		Add a property to the property list so that it will revert to its
//		default value.
//
//	Arguments:
//		pwszName	[IN] Name of the property.
//		cpfPropFmt	[IN] Format of property
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScSetPropToDefault(
	IN LPCWSTR					pwszName,
	IN CLUSTER_PROPERTY_FORMAT	cpfPropFmt
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	DWORD					_cbNameSize;
	DWORD					_cbValueSize;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_VALUE			_pValue;

	// Calculate sizes and make sure we have a property list.
	_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
				+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
	_cbValueSize = sizeof( CLUSPROP_BINARY )
				+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

	_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
	if ( _sc == ERROR_SUCCESS )
	{
		//
		// Set the property name.
		//
		_pName = m_cbhCurrentProp.pName;
		CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
		m_cbhCurrentProp.pb += _cbNameSize;

		//
		// Set the property value.
		//
		_pValue = m_cbhCurrentProp.pValue;
		CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
		m_cbhCurrentProp.pb += _cbValueSize;

		//
		// Increment the property count and buffer size.
		//
		m_cbhPropList.pList->nPropertyCount++;
		m_cbDataSize += _cbNameSize + _cbValueSize;
	} // if:

	return _sc;

} //*** CClusPropList::ScSetPropToDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.  If specified as 0,
//						the the length will be determined by a call to strlen.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz		// = 0
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
	} // if: zero size specified
	ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	lstrcpyW( pprop->sz, psz );

	//
	// Set an endmark.
	//
	_cbhProps.pStringValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyMultiSzProp
//
//	Description:
//		Copy a MULTI_SZ string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in psz string.  If specified as 0,
//						the the length will be determined by calls to strlen.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyMultiSzProp(
	OUT PCLUSPROP_MULTI_SZ		pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (CchMultiSz( psz ) + 1) * sizeof( WCHAR );
	} // if: zero size specified
	ASSERT( cbsz == (CchMultiSz( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	CopyMemory( pprop->sz, psz, cbsz );

	//
	// Set an endmark.
	//
	_cbhProps.pMultiSzValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyMultiSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyExpandSzProp
//
//	Description:
//		Copy an EXPAND_SZ string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in psz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyExpandSzProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
	} // if: cbsz == 0
	ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	lstrcpyW( pprop->sz, psz );

	//
	// Set an endmark.
	//
	_cbhProps.pStringValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyExpandSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of DWORD.
//		nValue		[IN] Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN DWORD					nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = sizeof( DWORD );
	pprop->dw = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pDwordValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a LONG property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of LONG.
//		nValue		[IN] Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_LONG			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LONG						nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = sizeof( DWORD );
	pprop->l = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pLongValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pLongValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a ULONGLONG property to a property structure.
//
//	Arguments:
//		pprop		[OUT]	Property structure to fill.
//		proptype	[IN]	Type of LONG.
//		nValue		[IN]	Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT	CLUSPROP_ULARGE_INTEGER UNALIGNED *	pprop,
	IN	CLUSTER_PROPERTY_TYPE		proptype,
	IN	ULONGLONG					nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
	pprop->Syntax.wType = static_cast< WORD >( proptype );
	pprop->cbLength = sizeof( ULONGLONG );
	pprop->li.QuadPart = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pULargeIntegerValue = (PCLUSPROP_ULARGE_INTEGER)pprop; // NTRAID#272389:  2000/01/13 - rlanser
	_cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN const PBYTE				pb,
	IN size_t					cb
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = cb;
	if ( cb > 0 )
	{
		CopyMemory( pprop->rgb, pb, cb );
	} // if: non-zero data length

	//
	// Set an endmark.
	//
	_cbhProps.pBinaryValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyEmptyProp
//
//	Description:
//		Copy an empty property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of property.
//		cpfPropFmt	[IN] Format of property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyEmptyProp(
	OUT PCLUSPROP_VALUE			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN CLUSTER_PROPERTY_FORMAT	cptPropFmt
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = 0;

	//
	// Set an endmark.
	//
	_cbhProps.pValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyEmptyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNodeProperties
//
//	Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hNode != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNodeControl(
								hNode,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
							);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetGroupProperties
//
//	Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hGroup != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterGroupControl(
								hGroup,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetResourceProperties
//
//	Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hResource != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceControl(
								hResource,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetResourceTypeProperties
//
//	Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( pwszResTypeName != NULL );
	ASSERT( *pwszResTypeName != L'\0' );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceTypeControl(
								hCluster,
								pwszResTypeName,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNetworkProperties
//
//	Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hNetwork != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNetworkControl(
								hNetwork,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNetInterfaceProperties
//
//	Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	ASSERT( hNetInterface != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc= ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNetInterfaceControl(
								hNetInterface,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNetInterfaceProperties()

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetClusterProperties
//
//	Description:
//		Get properties on a cluster.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetClusterProperties(
	IN HCLUSTER	hCluster,
	IN DWORD	dwControlCode,
	IN HNODE	hHostNode,
	IN LPVOID	lpInBuffer,
	IN DWORD	cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc= ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterControl(
						hCluster,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterControl(
								hCluster,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetClusterProperties()

#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.cpp
//
//	Abstract:
//		Implementation of routines for extension registration.
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminClusterExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetworksExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetInterfacesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"NetInterfaces", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminClusterExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetworksExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetInterfacesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"NetInterfaces", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Register the extension.
			hr = RegisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyRegistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been registered yet.
			if (pwszValue == NULL)
				bAlreadyRegistered = FALSE;
			else
			{
				LPCWSTR	pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpiW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyRegistered = (*pwszValueBuf != L'\0');
			}  // else:  extension value exists

			// Register the extension.
			if (!bAlreadyRegistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize + (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				if (cbSize == 0) // Add size of final NULL if first entry.
					cbNewSize += sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	cch;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							lstrcpyW(pwszNewValueBuf, pwszValueBuf);
							cch = lstrlenW(pwszValueBuf);
							pwszValueBuf += cch + 1;
							pwszNewValueBuf += cch + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Add the new CLSID to the list.
					lstrcpyW(pwszNewValueBuf, pwszClsid);
					pwszNewValueBuf += lstrlenW(pwszClsid) + 1;
					*pwszNewValueBuf = L'\0';

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not registered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Unregister the extension.
			hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyUnregistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been unregistered yet.
			if (pwszValue == NULL)
				bAlreadyUnregistered = TRUE;
			else
			{
				LPCWSTR pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpiW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyUnregistered = (*pwszValueBuf == L'\0');
			}  // else:  extension value exists

			// Unregister the extension.
			if (!bAlreadyUnregistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize - (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				if (cbNewSize == sizeof(WCHAR))
					cbNewSize = 0;
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if ((cbNewSize > 0) && (pwszValue != NULL))
					{
						while (*pwszValueBuf != L'\0')
						{
							if (lstrcmpiW(pwszClsid, pwszValueBuf) != 0)
							{
								lstrcpyW(pwszNewValueBuf, pwszValueBuf);
								pwszNewValueBuf += lstrlenW(pwszNewValueBuf) + 1;
							}  // if:  not CLSID being removed
							pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
						}  // while:  more strings in the extension list
						*pwszNewValueBuf = L'\0';
					}  // if:  previous value buffer existed

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not unregistered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadValue
//
//	Routine Description:
//		Reads a value from the cluster database.
//
//	Arguments:
//		hkey			[IN] Handle for the key to read from.
//		pwszValueName	[IN] Name of value to read.
//		ppwszValue		[OUT] Address of pointer in which to return data.
//							The string is allocated using LocalAlloc and must
//							be deallocated by the calling LocalFree.
//		pcbSize			[OUT] Size in bytes of the allocated value buffer.
//
//	Return Value:
//		Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	)
{
	DWORD		dwStatus;
	DWORD		cbSize;
	DWORD		dwType;
	LPWSTR		pwszValue;

	*ppwszValue = NULL;
	*pcbSize = 0;

	// Get the length of the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					NULL,
					&cbSize
					);
	if (   (dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_MORE_DATA))
	{
		if (dwStatus  == ERROR_FILE_NOT_FOUND)
			dwStatus = ERROR_SUCCESS;
		return dwStatus;
	}  // if:  error occurred

	if (cbSize > 0)
	{
		// Allocate a value string.
		pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbSize);
		if (pwszValue == NULL)
		{
			dwStatus = GetLastError();
			return dwStatus;
		}  // if:  error allocating memory

		// Read the the value.
		dwStatus = ClusterRegQueryValue(
						hkey,
						pwszValueName,
						&dwType,
						(LPBYTE) pwszValue,
						&cbSize
						);
		if (dwStatus != ERROR_SUCCESS)
		{
			LocalFree(pwszValue);
			pwszValue = NULL;
			cbSize = 0;
		}  // if:  error occurred

		*ppwszValue = pwszValue;
		*pcbSize = cbSize;
	}  // if:  value is not empty

	return dwStatus;

}  //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\restypeutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ResTypeUtils.h
//
//	Description:
//		Resource type utilities.
//
//	Author:
//		Galen Barbee	(galenb)	11-Jan-1999
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESUTILS_H
#define __RESUTILS_H

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI ScResTypeNameToDisplayName(
	HCLUSTER	hCluster,
	LPCWSTR		pszTypeName,
	LPWSTR *	ppszDisplayName
	);

DWORD WINAPI ScResDisplayNameToTypeName(
	HCLUSTER	hCluster,
	LPCWSTR		pszDisplayName,
	LPWSTR *	ppszTypeName
	);

/////////////////////////////////////////////////////////////////////////////

#endif // __RESUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\waitcrsr.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		WaitCrsr.h
//
//	Abstract:
//		Definition of the CWaitCursor class for changing the cursor to
//		an hourglass for the lifetime of the instantiation of the class.
//		Needed this because ATL doesn't provide it.
//
//	Author:
//		David Potter (davidp)	November 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WAITCRSR_H_
#define __WAITCRSR_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWaitCursor;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor
/////////////////////////////////////////////////////////////////////////////

class CWaitCursor
{
public:
	CWaitCursor(LPCTSTR lpCursorName = IDC_WAIT)
	{
		m_curOld = SetCursor(LoadCursor(NULL, lpCursorName));
	}

	~CWaitCursor(void)
	{
		SetCursor(m_curOld);
	}

protected:
	HCURSOR	m_curOld;

}; // class CWaitCursor

/////////////////////////////////////////////////////////////////////////////

#endif // __WAITCRSR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\stlutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		StlUtils.h
//
//	Abstract:
//		Definition of STL utility classes and functions.
//
//	Implementation File:
//		None.
//
//	Author:
//		David Potter (davidp)	May 21, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __STLUTUILS_H_
#define __STLUTUILS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

// Delete all items from a pointer list
template < class T >
void DeleteAllPtrListItems( std::list< T > * pList )
{
	ATLASSERT( pList != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< T >::iterator itCurrent = pList->begin();
	std::list< T >::iterator itLast = pList->end();

	//
	// Loop through the list and delete each objects.
	//
	while ( itCurrent != itLast )
	{
		T pT = *itCurrent;
		ATLASSERT( pT != NULL );
		delete pT;
		itCurrent = pList->erase( itCurrent );
	} // while:  more items in the list

} //*** DeleteAllPtrListItems()

// Delete items of a desired type from a pointer list
template < class TBase, class T >
void DeletePtrListItems( std::list< TBase > * pList )
{
	ATLASSERT( pList != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< TBase >::iterator itCurrent = pList->begin();
	std::list< TBase >::iterator itLast = pList->end();

	//
	// Loop through the list looking for objects of the
	// desired type and delete those objects.
	//
	while ( itCurrent != itLast )
	{
		T pT = dynamic_cast< T >( *itCurrent );
		if ( pT != NULL )
		{
			delete pT;
			itCurrent = pList->erase( itCurrent );
		} // if:  object has desired type
		else
		{
			itCurrent++;
		} // else:  object has different type
	} // while:  more items in the list

} //*** DeletePtrListItems()

// Move items of a desired type from one pointer list to another list
template < class TBase, class T >
void MovePtrListItems(
	std::list< TBase > * pSrcList,
	std::list< T > * pDstList
	)
{
	ATLASSERT( pSrcList != NULL );
	ATLASSERT( pDstList != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< TBase >::iterator itCurrent = pSrcList->begin();
	std::list< TBase >::iterator itLast = pSrcList->end();

	//
	// Loop through the source list looking for objects of the
	// desired type and move those objects to the
	// destination list.
	//
	while ( itCurrent != itLast )
	{
		T pT = dynamic_cast< T >( *itCurrent );
		if ( pT != NULL )
		{
			itCurrent = pSrcList->erase( itCurrent );
			pDstList->insert( pDstList->end(), pT );
		} // if:  object has desired type
		else
		{
			itCurrent++;
		} // else:  object has different type
	} // while:  more items in the list

} //*** MovePtrListItems()

/////////////////////////////////////////////////////////////////////////////

#endif // __STLUTUILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Cot();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Description:
//		Implementation of the CBasePropertyPage class.
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <clusapi.h>
#include "DebugEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CBasePropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
	CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		idd					[IN] Dialog template resource ID.
//		pdwHelpMap			[IN] Control-to-help ID map.
//		pdwWizardHelpMap	[IN] Control-to-help ID map if this is a wizard page.
//		nIDCaption			[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN const DWORD *	pdwWizardHelpMap,
	IN UINT				nIDCaption
	)
	: CPropertyPage(idd, nIDCaption)
	, m_dlghelp(pdwHelpMap, idd)
{
	CommonConstruct();
	m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CommonConstruct
//
//	Routine Description:
//		Common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
	//{{AFX_DATA_INIT(CBasePropertyPage)
	//}}AFX_DATA_INIT

	m_peo = NULL;
	m_hpage = NULL;
	m_bBackPressed = FALSE;

	m_iddPropertyPage = NULL;
	m_iddWizardPage = NULL;
	m_idsCaption = NULL;

	m_pdwWizardHelpMap = NULL;

	m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
	ASSERT(peo != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	m_peo = peo;

	// Change the help map if this is a wizard page.
	if (Peo()->BWizard())
		m_dlghelp.SetMap(m_pdwWizardHelpMap);

	// Don't display a help button.
	m_psp.dwFlags &= ~PSP_HASHELP;

	// Construct the property page.
	if (Peo()->BWizard())
	{
		ASSERT(IddWizardPage() != NULL);
		Construct(IddWizardPage(), IdsCaption());
		m_dlghelp.SetHelpMask(IddWizardPage());
	}  // if:  adding page to wizard
	else
	{
		ASSERT(IddPropertyPage() != NULL);
		Construct(IddPropertyPage(), IdsCaption());
		m_dlghelp.SetHelpMask(IddPropertyPage());
	}  // else:  adding page to property sheet

	// Read the properties common to this resource and parse them.
	{
		DWORD			dwStatus;
		CClusPropList	cpl;

		// Read the properties.
		ASSERT(Peo() != NULL);

		if (Peo()->PodObjData()->m_cot == CLUADMEX_OT_RESOURCE)
		{
			ASSERT(Peo()->PrdResData() != NULL);
			ASSERT(Peo()->PrdResData()->m_hresource != NULL);
			dwStatus = cpl.ScGetResourceProperties(
									Peo()->PrdResData()->m_hresource,
									CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES
									);
		}  // if:  resource object
		else
		{
			ASSERT(Peo()->PodObjData() != NULL);
			ASSERT(Peo()->PodObjData()->m_strName.GetLength() != 0);
			dwStatus = cpl.ScGetResourceTypeProperties(
									Hcluster(),
									Peo()->PodObjData()->m_strName,
									CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
									);
		}  // else:  resource type object

		// Parse the properties.
		if (dwStatus == ERROR_SUCCESS)
		{
			// Parse the properties.
			try
			{
				dwStatus = DwParseProperties(cpl);
			}  // try
			catch (CMemoryException * pme)
			{
				dwStatus = ERROR_NOT_ENOUGH_MEMORY;
				pme->Delete();
			}  // catch:  CMemoryException
		}  // if:  properties read successfully

		if (dwStatus != ERROR_SUCCESS)
		{
			return FALSE;
		}  // if:  error parsing getting or parsing properties
	}  // Read the properties private to this resource and parse them

	return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DwParseProperties
//
//	Routine Description:
//		Parse the properties of the resource.  This is in a separate function
//		from BInit so that the optimizer can do a better job.
//
//	Arguments:
//		rcpl			[IN] Cluster property list to parse.
//
//	Return Value:
//		ERROR_SUCCESS	Properties were parsed successfully.
//
//	Exceptions Thrown:
//		Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN const CClusPropList & rcpl)
{
	DWORD							cProps;
	DWORD							cprop;
	DWORD							cbProps;
	const CObjectProperty *			pprop;
	CLUSPROP_BUFFER_HELPER			props;
	CLUSPROP_PROPERTY_NAME const *	pName;

	ASSERT(rcpl.PbPropList() != NULL);

	props.pb = rcpl.PbPropList();
	cbProps = rcpl.CbPropList();

	// Loop through each property.
	for (cProps = *(props.pdw++) ; cProps > 0 ; cProps--)
	{
		pName = props.pName;
		ASSERT(pName->Syntax.dw == CLUSPROP_SYNTAX_NAME);
		props.pb += sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

		// Decrement the counter by the size of the name.
		ASSERT(cbProps > sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength));
		cbProps -= sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

		ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));

		// Parse known properties.
		for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
		{
			if (lstrcmpiW(pName->sz, pprop->m_pwszName) == 0)
			{
				ASSERT(props.pSyntax->wFormat == pprop->m_propFormat);
				switch (pprop->m_propFormat)
				{
					case CLUSPROP_FORMAT_SZ:
						ASSERT((props.pValue->cbLength == (lstrlenW(props.pStringValue->sz) + 1) * sizeof(WCHAR))
								|| ((props.pValue->cbLength == 0) && (props.pStringValue->sz[0] == L'\0')));
						*pprop->m_value.pstr = props.pStringValue->sz;
						*pprop->m_valuePrev.pstr = props.pStringValue->sz;
						break;
					case CLUSPROP_FORMAT_DWORD:
					case CLUSPROP_FORMAT_LONG:
						ASSERT(props.pValue->cbLength == sizeof(DWORD));
						*pprop->m_value.pdw = props.pDwordValue->dw;
						*pprop->m_valuePrev.pdw = props.pDwordValue->dw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						*pprop->m_value.ppb = props.pBinaryValue->rgb;
						*pprop->m_value.pcb = props.pBinaryValue->cbLength;
						*pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
						*pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				}  // switch:  property format

				// Exit the loop since we found the parameter.
				break;
			}  // if:  found a match
		}  // for:  each property

		// If the property wasn't known, ask the derived class to parse it.
		if (cprop == 0)
		{
			DWORD		dwStatus;

			dwStatus = DwParseUnknownProperty(pName->sz, props, cbProps);
			if (dwStatus != ERROR_SUCCESS)
				return dwStatus;
		}  // if:  property not parsed

		// Advance the buffer pointer past the value in the value list.
		while ((props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
				&& (cbProps > 0))
		{
			ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));
			cbProps -= sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
			props.pb += sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
		}  // while:  more values in the list

		// Advance the buffer pointer past the value list endmark.
		ASSERT(cbProps >= sizeof(*props.pSyntax));
		cbProps -= sizeof(*props.pSyntax);
		props.pb += sizeof(*props.pSyntax); // endmark
	}  // for:  each property

	return ERROR_SUCCESS;

}  //*** CBasePropertyPage::DwParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach(hWnd);
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Routine Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if (m_bDoDetach)
	{
		if (m_hWnd != NULL)
		{
			HWND hWnd = m_hWnd;

			Detach();
			m_hWnd = hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//{{AFX_DATA_MAP(CBasePropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

	if (!pDX->m_bSaveAndValidate)
	{
		// Set the title.
		DDX_Text(pDX, IDC_PP_TITLE, m_strTitle);
	}  // if:  not saving data

	CPropertyPage::DoDataExchange(pDX);

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PodObjData() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	// Call the base class method.
	CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if (Peo()->Hicon() != NULL)
		m_staticIcon.SetIcon(Peo()->Hicon());

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
	HRESULT		hr;

	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PodObjData() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Reread the data.
	hr = Peo()->HrGetObjectInfo();
	if (hr != NOERROR)
		return FALSE;

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	m_bBackPressed = FALSE;
	return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnApply
//
//	Routine Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
	ASSERT(!BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnChangeCtrl
//
//	Routine Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
	DWORD			dwStatus	= ERROR_SUCCESS;
	CClusPropList	cpl(BWizard() /*bAlwaysAddProp*/);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Save data.
	{
		// Build the property list.
		try
		{
			BuildPropList(cpl);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			dwStatus = ERROR_NOT_ENOUGH_MEMORY;
		}  // catch:  CMemoryException

		// Set the data.
		if (dwStatus == ERROR_SUCCESS)
			dwStatus = DwSetCommonProps(cpl);

		// Handle errors.
		if (dwStatus != ERROR_SUCCESS)
		{
			CString		strError;
			CString		strMsg;

			AFX_MANAGE_STATE(AfxGetStaticModuleState());

			FormatError(strError, dwStatus);
			if (dwStatus == ERROR_RESOURCE_PROPERTIES_STORED)
			{
				AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
				dwStatus = ERROR_SUCCESS;
			}  // if:  properties were stored
			else
			{
				strMsg.FormatMessage(IDS_APPLY_PARAM_CHANGES_ERROR, strError);
				AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
				return FALSE;
			}  // else:  error setting properties.
		}  // if:  error setting properties

		if (dwStatus == ERROR_SUCCESS)
		{
			// Save new values as previous values.
			try
			{
				DWORD					cprop;
				const CObjectProperty *	pprop;

				for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
				{
					switch (pprop->m_propFormat)
					{
						case CLUSPROP_FORMAT_SZ:
							ASSERT(pprop->m_value.pstr != NULL);
							ASSERT(pprop->m_valuePrev.pstr != NULL);
							*pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
							break;
						case CLUSPROP_FORMAT_DWORD:
							ASSERT(pprop->m_value.pdw != NULL);
							ASSERT(pprop->m_valuePrev.pdw != NULL);
							*pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
							break;
						case CLUSPROP_FORMAT_BINARY:
						case CLUSPROP_FORMAT_MULTI_SZ:
							ASSERT(pprop->m_value.ppb != NULL);
							ASSERT(*pprop->m_value.ppb != NULL);
							ASSERT(pprop->m_value.pcb != NULL);
							ASSERT(pprop->m_valuePrev.ppb != NULL);
							ASSERT(*pprop->m_valuePrev.ppb != NULL);
							ASSERT(pprop->m_valuePrev.pcb != NULL);
							delete [] *pprop->m_valuePrev.ppb;
							*pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
							CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
							*pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
							break;
						default:
							ASSERT(0);	// don't know how to deal with this type
					}  // switch:  property format
				}  // for:  each property
			}  // try
			catch (CMemoryException * pme)
			{
				pme->ReportError();
				pme->Delete();
			}  // catch:  CMemoryException
		}  // if:  properties set successfully
	}  // Save data

	return TRUE;

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BuildPropList
//
//	Routine Description:
//		Build the property list.
//
//	Arguments:
//		rcpl		[IN OUT] Cluster property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
	IN OUT CClusPropList & rcpl
	)
{
	DWORD					cprop;
	const CObjectProperty *	pprop;

	for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
	{
		switch (pprop->m_propFormat)
		{
			case CLUSPROP_FORMAT_SZ:
				rcpl.ScAddProp(
						pprop->m_pwszName,
						*pprop->m_value.pstr,
						*pprop->m_valuePrev.pstr
						);
				break;
			case CLUSPROP_FORMAT_DWORD:
				rcpl.ScAddProp(
						pprop->m_pwszName,
						*pprop->m_value.pdw,
						*pprop->m_valuePrev.pdw
						);
				break;
			case CLUSPROP_FORMAT_BINARY:
			case CLUSPROP_FORMAT_MULTI_SZ:
				rcpl.ScAddProp(
						pprop->m_pwszName,
						*pprop->m_value.ppb,
						*pprop->m_value.pcb,
						*pprop->m_valuePrev.ppb,
						*pprop->m_valuePrev.pcb
						);
				break;
			default:
				ASSERT(0);	// don't know how to deal with this type
				return;
		}  // switch:  property format
	}  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DwSetCommonProps
//
//	Routine Description:
//		Set the private properties for this object.
//
//	Arguments:
//		rcpl		[IN] Property list to set on the object.
//
//	Return Value:
//		ERROR_SUCCESS	The operation was completed successfully.
//		!0				Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwSetCommonProps(
	IN const CClusPropList &	rcpl
	)
{
	DWORD		dwStatus;
	DWORD		cbProps;

	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PrdResData());
	ASSERT(Peo()->PrdResData()->m_hresource);

	if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
	{
		// Set private properties.
		if (Cot() == CLUADMEX_OT_RESOURCE)
			dwStatus = ClusterResourceControl(
							Peo()->PrdResData()->m_hresource,
							NULL,	// hNode
							CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
							rcpl.PbPropList(),
							rcpl.CbPropList(),
							NULL,	// lpOutBuffer
							0,		// nOutBufferSize
							&cbProps
							);
		else
			dwStatus = ClusterResourceTypeControl(
							Hcluster(),
							Peo()->PodObjData()->m_strName,
							NULL,	// hNode
							CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES,
							rcpl.PbPropList(),
							rcpl.CbPropList(),
							NULL,	// lpOutBuffer
							0,		// nOutBufferSize
							&cbProps
							);
	}  // if:  there is data to set
	else
		dwStatus = ERROR_SUCCESS;

	return dwStatus;

}  //*** CBasePropertyPage::DwSetCommonProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	lProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	lProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!lProcessed)
		lProcessed = CPropertyPage::OnCommandHelp(wParam, lParam);

	return lProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\debugex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-2000 Microsoft Corporation
//
//	Module Name:
//		DebugEx.cpp
//
//	Abstract:
//		Implementation of the CDebugexApp class and DLL initialization
//		routines.
//
//	Author:
//		David Potter (davidp) September 19, 1996
//
//	Revision History:
//
//	Notes:
//		NOTE: You must use the MIDL compiler from NT 4.0,
//		version 3.00.44 or greater
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "DebugEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoDebugEx, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CDebugexApp
/////////////////////////////////////////////////////////////////////////////

class CDebugexApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
// The one and only CDebugexApp object

CDebugexApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugexApp::InitInstance
//
//	Routine Description:
//		Initialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugexApp::InitInstance(void)
{
	_Module.Init(ObjectMap, m_hInstance);

	// Construct the help path.
	{
		TCHAR szPath[_MAX_PATH];
		TCHAR szDrive[_MAX_PATH];
		TCHAR szDir[_MAX_DIR];
		int cchPath;
		VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
		cchPath = lstrlen(szPath);
		if (szPath[cchPath - 1] != _T('\\'))
		{
			szPath[cchPath++] = _T('\\');
			szPath[cchPath] = _T('\0');
		} // if: no backslash on the end of the path
		lstrcpy(&szPath[cchPath], _T("Help\\"));
		_tsplitpath(szPath, szDrive, szDir, NULL, NULL);
		_tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
		free((void *) m_pszHelpFilePath);
		BOOL bEnable;
		bEnable = AfxEnableMemoryTracking(FALSE);
		m_pszHelpFilePath = _tcsdup(szPath);
		AfxEnableMemoryTracking(bEnable);
	}  // Construct the help path

	return CWinApp::InitInstance();

}  //*** CDebugexApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugexApp::ExitInstance
//
//	Routine Description:
//		Deinitialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CDebugexApp::ExitInstance(void)
{
	_Module.Term();
	return CWinApp::ExitInstance();

}  //*** CDebugexApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	FormatError
//
//	Routine Description:
//		Format an error.
//
//	Arguments:
//		rstrError	[OUT] String in which to return the error message.
//		dwError		[IN] Error code to format.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
	DWORD	_cch;
	TCHAR	_szError[512];

	_cch = FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					dwError,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					_szError,
					sizeof(_szError) / sizeof(TCHAR),
					0
					);
	if (_cch == 0)
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		_cch = FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle(_T("NTDLL.DLL")),
						dwError,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
						_szError,
						sizeof(_szError) / sizeof(TCHAR),
						0
						);
	}  // if:  error formatting status code from system

	if (_cch > 0)
	{
		rstrError = _szError;
	}  // if:  no error
	else
	{

#ifdef _DEBUG

		DWORD	_sc = GetLastError();

		TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

		rstrError.Format(_T("Error 0x%08.8x"), dwError);

	}  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer(FALSE /*bRegTypeLib*/);
	return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	_Module.UnregisterServer();
	return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterCluAdminExtension
//
//	Routine Description:
//		Register the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr;

	hr = RegisterCluAdminAllResourcesExtension(hCluster, &CLSID_CoDebugEx);
	if (hr == S_OK)
		hr = RegisterCluAdminAllResourceTypesExtension(hCluster, &CLSID_CoDebugEx);

	return hr;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllUnregisterCluAdminExtension
//
//	Routine Description:
//		Unregister the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr;

	hr = UnregisterCluAdminAllResourcesExtension(hCluster, &CLSID_CoDebugEx);
	if (hr == S_OK)
		hr = UnregisterCluAdminAllResourceTypesExtension(hCluster, &CLSID_CoDebugEx);

	return hr;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\workthrd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		WorkThrd.cpp
//
//	Abstract:
//		Implementation of the CWorkerThread class.
//
//	Author:
//		David Potter (davidp)	November 17, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AdmCommonRes.h"
#include "WorkThrd.h"
#include <process.h>

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

TCHAR g_szOldWndProc[] = _T("CLADMWIZ_OldWndProc");
TCHAR g_szThreadObj[] = _T("CLADMWIZ_ThreadObj");

/////////////////////////////////////////////////////////////////////////////
// class CWorkerThread
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::CreateThread
//
//	Routine Description:
//		Create the thread.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any error values returned by CreateMutex(), CreateEvent(), or
//		CreateThread().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWorkerThread::CreateThread( void )
{
	ATLASSERT( m_hThread == NULL );
	ATLASSERT( m_hMutex == NULL );
	ATLASSERT( m_hInputEvent == NULL );
	ATLASSERT( m_hOutputEvent == NULL );
	ATLASSERT( m_idThread == 0 );

	DWORD	_sc = ERROR_SUCCESS;

	// Loop to avoid goto's.
	do
	{
		//
		// Create the mutex.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateMutex()\n") );
		m_hMutex = CreateMutex(
						NULL,	// lpMutexAttributes
						FALSE,	// bInitialOwner
						NULL	// lpName
						);
		if ( m_hMutex == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the mutex

		//
		// Create the input event.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateEvent() for input event\n") );
		m_hInputEvent = CreateEvent(
							NULL,	// lpEventAttributes
							TRUE,	// bManualReset
							FALSE,	// bInitialState
							NULL	// lpName
							);
		if ( m_hInputEvent == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the input event

		//
		// Create the output event.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateEvent() for output event\n") );
		m_hOutputEvent = CreateEvent(
							NULL,	// lpEventAttributes
							TRUE,	// bManualReset
							FALSE,	// bInitialState
							NULL	// lpName
							);
		if ( m_hOutputEvent == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the output event

		//
		// Create the thread.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateThread()\n") );
		m_hThread = reinterpret_cast< HANDLE >( _beginthreadex(
						NULL,			// security
						0,				// stack_size
						S_ThreadProc,	// start_address,
						(LPVOID) this,	// arglist
						0,				// initflag
						&m_idThread		// thrdaddr
						) );
		if ( m_hThread == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the thread

	} while ( 0 );

	//
	// Handle errors by cleaning up objects we created.
	//
	if ( _sc != ERROR_SUCCESS )
	{
		Cleanup();
	} // if:  error occurred

	return _sc;

} //*** CWorkerThread::CreateThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::PrepareWindowToWait
//
//	Routine Description:
//		Prepare to wait for a long operation.  This involves disabling the
//		window and displaying a wait cursor.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWorkerThread::PrepareWindowToWait( IN HWND hwnd )
{
	m_hCurrentCursor = GetCursor();

	if ( hwnd != NULL )
	{
		//
		// Subclass the window procedure so we can set the cursor properly.
		//
		m_pfnOldWndProc = reinterpret_cast< WNDPROC >( GetWindowLongPtr( hwnd, GWLP_WNDPROC ) );
		SetProp( hwnd, g_szOldWndProc, m_pfnOldWndProc );
		SetProp( hwnd, g_szThreadObj, this );
		SetWindowLongPtr( hwnd, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( S_ParentWndProc ) );

		//
		// Disable property sheet and wizard buttons.
		//
		EnableWindow( hwnd, FALSE );

	} // if:  parent window specified

} //*** CWorkerThread::PrepareWindowToWait()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::CleanupWindowAfterWait
//
//	Routine Description:
//		Prepare to wait for a long operation.  This involves disabling the
//		window and displaying a wait cursor.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWorkerThread::CleanupWindowAfterWait( IN HWND hwnd )
{
	if ( hwnd != NULL )
	{
		//
		// Unsubclass the window procedure.
		//
		SetWindowLongPtr( hwnd, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( m_pfnOldWndProc ) );
		m_pfnOldWndProc = NULL;
		RemoveProp( hwnd, g_szOldWndProc );
		RemoveProp( hwnd, g_szThreadObj );

		//
		// Re-enable property sheet and wizard buttons.
		//
		EnableWindow( hwnd, TRUE );
	} // if:  parent window specified

	m_hCurrentCursor = NULL;

} //*** CWorkerThread::CleanupWindowAfterWait()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::CallThreadFunction
//
//	Routine Description:
//		Call a function supported by the thread.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//		nFunction	[IN] Code representing the function to perform.
//		pvParam1	[IN OUT] Parameter 1 with function-specific data.
//		pvParam2	[IN OUT] Parameter 2 with function-specific data.
//
//	Return Value:
//		Any error values returned by AtlWaitWithMessageLoop() or PulseEvent().
//		Status return from the function.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWorkerThread::CallThreadFunction(
	IN HWND			hwnd,
	IN LONG			nFunction,
	IN OUT PVOID	pvParam1,	// = NULL,
	IN OUT PVOID	pvParam2	// = NULL
	)
{
	ATLASSERT( m_hThread != NULL );			// Thread must already be created.
	ATLASSERT( m_hMutex != NULL );			// Mutex must already be created.
	ATLASSERT( m_hInputEvent != NULL );		// Input event must already be created.
	ATLASSERT( m_hOutputEvent != NULL );	// Output event must already be created.
	ATLASSERT( m_pfnOldWndProc == NULL );	// Parent window not already subclassed.

	DWORD		_sc;
	CWaitCursor	_wc;

	//
	// Prepare the window to wait for the thread operation.
	//
	PrepareWindowToWait( hwnd );

	// Loop to avoid goto's.
	do
	{
		//
		// Wait for the thread to become available.
		//
		ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Waiting on mutex\n") );
		if ( ! AtlWaitWithMessageLoop( m_hMutex ) )
		{
			_sc = GetLastError();
			break;
		}  // if:  error waiting on the mutex

		// Loop to avoid using goto's.
		do
		{
			//
			// Pass this caller's data to the thread.
			//
			ATLASSERT( m_nFunction == 0 );
			ATLASSERT( m_pvParam1 == NULL );
			ATLASSERT( m_pvParam2 == NULL );
			ATLASSERT( m_dwOutputStatus == ERROR_SUCCESS );
			m_nFunction = nFunction;
			m_pvParam1 = pvParam1;
			m_pvParam2 = pvParam2;

			//
			// Signal the thread that there is work to do.
			//
			ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Setting input event\n") );
			if ( ! SetEvent( m_hInputEvent ) )
			{
				_sc = GetLastError();
				break;
			}  // if:  error pulsing the event

			//
			// Wait for the thread to complete the function.
			//
			ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Waiting on output event\n") );
			if ( ! AtlWaitWithMessageLoop( m_hOutputEvent ) )
			{
				_sc = GetLastError();
				break;
			}  // if:  error waiting for the event
			ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Resetting output event\n") );
			ResetEvent( m_hOutputEvent );

			//
			// Retrieve the results of the function to return
			// to the caller.
			//
			_sc = m_dwOutputStatus;

			//
			// Clear input parameters.
			//
			m_nFunction = WTF_NONE;
			m_pvParam1 = NULL;
			m_pvParam2 = NULL;
			m_dwOutputStatus = ERROR_SUCCESS;

		} while ( 0 );

		ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Releasing mutex\n") );
		ReleaseMutex( m_hMutex );

	} while ( 0 );

	//
	// Cleanup windows after the wait operation.
	//
	CleanupWindowAfterWait( hwnd );

	return _sc;

} //*** CWorkerThread::CallThreadFunction()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::WaitForThreadToExit
//
//	Routine Description:
//		Wait for the thread to exit.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//
//	Return Value:
//		ERROR_SUCCESS	Operation completed successfully.
//		Any error values returned by AtlWaitWithMessageLoop().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWorkerThread::WaitForThreadToExit( IN HWND hwnd )
{
	ATLASSERT( m_hThread != NULL );			// Thread must already be created.

	DWORD		_sc = ERROR_SUCCESS;
	CWaitCursor	_wc;

	//
	// Prepare the window to wait for the thread operation.
	//
	PrepareWindowToWait( hwnd );

	//
	// Wait for the thread to exit.
	//
	AtlWaitWithMessageLoop( m_hThread );
	if ( ! AtlWaitWithMessageLoop( m_hThread ) )
	{
		_sc = GetLastError();
	}  // if:  error waiting for the thread to exit

	//
	// Cleanup windows after the wait operation.
	//
	CleanupWindowAfterWait( hwnd );

	return _sc;

} //*** CWorkerThread::WaitForThreadToExit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	static
//	CWorkerThread::S_ParentWndProc
//
//	Routine Description:
//		Static parent window procedure.  This procedure handles the
//		WM_SETCURSOR message while the thread is processing a request.
//
//	Arguments:
//		hwnd		[IN] Identifies the window.
//		uMsg		[IN] Specifies the message.
//		wParam		[IN] Specifies additional information based on uMsg.
//		lParam		[IN] Specifies additional information based on uMsg.
//
//	Return Value:
//		The result of the message processing.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT WINAPI CWorkerThread::S_ParentWndProc(
	IN HWND		hwnd,
	IN UINT		uMsg,
	IN WPARAM	wParam,
	IN LPARAM	lParam
	)
{
	LRESULT			lResult = 0;
	CWorkerThread * pthread = reinterpret_cast< CWorkerThread * >( GetProp( hwnd, g_szThreadObj ) );

	ATLASSERT( pthread != NULL );

	if ( pthread != NULL )
	{
		if ( uMsg == WM_SETCURSOR )
		{
			if ( GetCursor() != pthread->m_hCurrentCursor )
			{
				SetCursor( pthread->m_hCurrentCursor );
			} // if:  cursor is different
			lResult = TRUE;
		} // if:  set cursor message
		else
		{
			lResult = (*pthread->m_pfnOldWndProc)( hwnd, uMsg, wParam, lParam );
		} // else:	other message
	} // if: thread is non-null

	return lResult;

} //*** CWorkerThread::S_ParentWndProc()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	static
//	CWorkerThread::S_ThreadProc
//
//	Routine Description:
//		Static thread procedure.
//
//	Arguments:
//		pvThis		[IN OUT] this pointer for the CWorkerThread instance.
//
//	Return Value:
//		None (ignored).
//
//--
/////////////////////////////////////////////////////////////////////////////
UINT __stdcall CWorkerThread::S_ThreadProc( IN OUT LPVOID pvThis )
{
	ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Beginning thread\n") );

	DWORD			_sc;
	LONG			_nFunction;
	CWorkerThread * _pThis = reinterpret_cast< CWorkerThread * >( pvThis );

	ATLASSERT( pvThis != NULL );
	ATLASSERT( _pThis->m_hMutex != NULL );
	ATLASSERT( _pThis->m_hInputEvent != NULL );
	ATLASSERT( _pThis->m_hOutputEvent != NULL );

	do
	{
		//
		// Wait for work.
		//
		ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Waiting on input event\n") );
		_sc = WaitForSingleObject( _pThis->m_hInputEvent, INFINITE );
		if ( _sc == WAIT_FAILED )
		{
			_sc = GetLastError();
			break;
		}  // if:  error waiting for the event
		ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Resetting input event\n") );
		ResetEvent( _pThis->m_hInputEvent );

		//
		// Handle the exit request.
		//
		if ( _pThis->m_nFunction == WTF_EXIT )
		{
			_pThis->m_bThreadExiting =  TRUE;
		} // if:  exiting
		else
		{
			//
			// Call the function handler.
			//
			ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Calling thread function handler\n") );
			ATLASSERT( _pThis->m_nFunction != 0 );
			_pThis->m_dwOutputStatus = _pThis->ThreadFunctionHandler(
												_pThis->m_nFunction,
												_pThis->m_pvParam1,
												_pThis->m_pvParam2
												);
		} // else:  not exiting

		//
		// Save locally data that we need to access once we have signalled
		// the caller's event.  If we don't do this, we won't be referencing
		// the proper function code after that point.
		//
		_nFunction = _pThis->m_nFunction;

		//
		// Signal the calling thread that the work has been completed.
		//
		ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Setting output event\n") );
		if ( ! SetEvent( _pThis->m_hOutputEvent ) )
		{
			_sc = GetLastError();
			break;
		}  // if:  error pulsing

		//
		// Set the status in case we are exiting.
		//
		_sc = ERROR_SUCCESS;

	} while ( _nFunction != WTF_EXIT );

	ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Exiting thread\n") );
//	Sleep( 10000 ); // Test thread synchronization
	return _sc;

} //*** CWorkerThread::S_ThreadProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\debugex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DebugEx.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		DebugEx.cpp
//
//	Author:
//		David Potter (davidp) September 19, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DEBUGEX_H_
#define _DEBUGEX_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_PARAMETERS			L"Parameters"
#define REGPARAM_DEBUG_PREFIX	    L"DebugPrefix"
#define REGPARAM_SEPARATE_MONITOR	L"SeparateMonitor"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

/////////////////////////////////////////////////////////////////////////////

#endif // _DEBUGEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Description:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Implementation File:
//		BasePage.cpp
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"		// for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN const DWORD *	pdwWizardHelpMap,
		IN UINT				nIDCaption = 0
		);
	virtual ~CBasePropertyPage(void) { }

	// Second phase construction.
	virtual BOOL			BInit(IN OUT CExtObject * peo);
	BOOL					BCreateParamsKey(void);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	CExtObject *			m_peo;
	HPROPSHEETPAGE			m_hpage;

	IDD						m_iddPropertyPage;
	IDD						m_iddWizardPage;
	IDS						m_idsCaption;

	CExtObject *			Peo(void) const					{ return m_peo; }
	HPROPSHEETPAGE			Hpage(void) const				{ return m_hpage; }

	IDD						IddPropertyPage(void) const		{ return m_iddPropertyPage; }
	IDD						IddWizardPage(void) const		{ return m_iddWizardPage; }
	IDS						IdsCaption(void) const			{ return m_idsCaption; }

public:
	void					SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }
	CLUADMEX_OBJECT_TYPE	Cot(void) const;

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual DWORD			DwParseUnknownProperty(
								IN LPCWSTR							pwszName,
								IN const CLUSPROP_BUFFER_HELPER &	rvalue,
								IN DWORD							cbBuf
								)		{ return ERROR_SUCCESS; }
	virtual BOOL			BApplyChanges(void);
	virtual void			BuildPropList(IN OUT CClusPropList & rcpl);

	virtual const CObjectProperty *	Pprops(void) const	{ return NULL; }
	virtual DWORD					Cprops(void) const	{ return 0; }

// Implementation
protected:
	BOOL					m_bBackPressed;
	const DWORD *			m_pdwWizardHelpMap;
	BOOL					m_bDoDetach;

	BOOL					BBackPressed(void) const		{ return m_bBackPressed; }
	BOOL					BWizard(void) const;
	HCLUSTER				Hcluster(void) const;

	DWORD					DwParseProperties(IN const CClusPropList & rcpl);
	DWORD					DwSetCommonProps(IN const CClusPropList & rcpl);

	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\common\workthrd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		WorkThrd.h
//
//	Abstract:
//		Definition of the CWorkerThread class.
//
//	Implementation File:
//		WorkThrd.cpp
//
//	Author:
//		David Potter (davidp)	November 17, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WORKTHRD_H_
#define __WORKTHRD_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWorkerThread;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXCOPER_H_
#include "ExcOper.h"	// for CNTException
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

// Worker thread function codes.
enum
{
	WTF_EXIT = -1,		// Ask the thread to exit.
	WTF_NONE = 0,		// No function.
	WTF_USER = 1000		// User functions start here.
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWorkerThread
//
//	Purpose:
//		This class provides a means of calling functions in a worker thread
//		and allowing a UI application to still respond to Windows messages.
//		The user of this class owns the input and output data pointed to
//		by this class.
//
//	Inheritance:
//		CWorkerThread
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWorkerThread
{
public:
	//
	// Construction and destruction.
	//

	// Default constructor
	CWorkerThread( void )
		: m_hThread( NULL )
		, m_hMutex( NULL )
		, m_hInputEvent( NULL )
		, m_hOutputEvent( NULL)
		, m_idThread( 0 )
		, m_bThreadExiting( FALSE )
		, m_nFunction( WTF_NONE )
		, m_pvParam1( NULL )
		, m_pvParam2( NULL )
		, m_dwOutputStatus( ERROR_SUCCESS )
		, m_nte( ERROR_SUCCESS )
		, m_pfnOldWndProc( NULL )
		, m_hCurrentCursor( NULL )
	{
	} //*** CWorkerThread()

	// Destructor
	~CWorkerThread( void )
	{
		ATLASSERT( m_nFunction == WTF_NONE );
		ATLASSERT( m_pvParam1 == NULL );
		ATLASSERT( m_pvParam2 == NULL );

		Cleanup();

		ATLASSERT( m_bThreadExiting );

	} //*** ~CWorkerThread()

	// Create the thread
	DWORD CreateThread( void );

	// Ask the thread to exit
	void QuitThread( IN HWND hwnd = NULL )
	{
		ATLASSERT( ! m_bThreadExiting );
		CWaitCursor wc;
		CallThreadFunction( hwnd, WTF_EXIT, NULL, NULL );

	} //*** QuitThread()

	// Call a function supported by the thread
	DWORD CallThreadFunction(
			IN HWND			hwnd,
			IN LONG			nFunction,
			IN OUT PVOID	pvParam1 = NULL,
			IN OUT PVOID	pvParam2 = NULL
			);

	// Wait for the thread to exit
	DWORD WaitForThreadToExit( IN HWND hwnd );

public:
	//
	// Accessor functions.
	//

	// Get the thread handle
	operator HANDLE( void ) const
	{
		return m_hThread;

	} //*** operator HANDLE()

	// Get the thread handle
	HANDLE HThreadHandle( void ) const
	{
		return m_hThread;

	} //*** HThreadHandle()

	// Get the thread ID
	operator DWORD( void ) const
	{
		return m_idThread;

	} //*** operator DWORD()

	// Get exception information resulting from a thread function call
	CNTException & Nte( void )
	{
		return m_nte;

	} //*** Nte()

	// Get exception information resulting from a thread function call
	operator CNTException *( void )
	{
		return &m_nte;

	} //*** operator CNTException *()

protected:
	//
	// Synchronization data.
	//
	HANDLE			m_hThread;			// Handle for the thread.
	HANDLE			m_hMutex;			// Handle for the mutex used to call a
										//	function in the thread.
	HANDLE			m_hInputEvent;		// Handle for the event used by the calling
										//	thread to signal the worker thread that
										//	there is work to do.
	HANDLE			m_hOutputEvent;		// Handle for the event used by the worker
										//	thread to signal the calling thread
										//	that the work has been completed.
	UINT			m_idThread;			// ID for the thread.
	BOOL			m_bThreadExiting;	// Determine if thread is exiting or not.

	//
	// Data used as input or produced by the thread.
	//
	LONG			m_nFunction;		// ID of the function to perform.
	PVOID			m_pvParam1;			// Parameter 1 with function-specific data.
	PVOID			m_pvParam2;			// Parameter 2 with function-specific data.
	DWORD			m_dwOutputStatus;	// Status returned from the function.
	CNTException	m_nte;				// Exception information from the function.

	//
	// Data and methods for handling WM_SETCURSOR messages.
	//
	WNDPROC			m_pfnOldWndProc;	// Old window procedure for the parent window.
	HCURSOR			m_hCurrentCursor;	// Cursor to display while waiting for thread call to complete.

	// Window procedure for subclassing the parent window
	static LRESULT WINAPI S_ParentWndProc(
							IN HWND		hwnd,
							IN UINT		uMsg,
							IN WPARAM	wParam,
							IN LPARAM	lParam
							);

	//
	// Thread worker functions.
	//

	// Static thread procedure
	static UINT __stdcall S_ThreadProc( IN OUT LPVOID pvThis );

	// Thread function handler
	virtual DWORD ThreadFunctionHandler(
						IN LONG			nFunction,
						IN OUT PVOID	pvParam1,
						IN OUT PVOID	pvParam2
						) = 0;

	//
	// Helper functions.
	//

	// Prepare a window to wait for a thread operation
	void PrepareWindowToWait( IN HWND hwnd );

	// Cleanup a window after waiting for a thread operation
	void CleanupWindowAfterWait( IN HWND hwnd );

	// Cleanup objects
	virtual void Cleanup( void )
	{
		if ( m_hThread != NULL )
		{
			if ( ! m_bThreadExiting && (m_nFunction != WTF_EXIT) )
			{
				QuitThread();
			} // if:  thread hasn't exited yet
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing thread handle\n") );
			CloseHandle( m_hThread );
			m_hThread = NULL;
		}  // if:  thread created
		if ( m_hMutex != NULL )
		{
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing mutex handle\n") );
			CloseHandle( m_hMutex );
			m_hMutex = NULL;
		}  // if:  mutex created
		if ( m_hInputEvent != NULL )
		{
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing input event handle\n") );
			CloseHandle( m_hInputEvent );
			m_hInputEvent = NULL;
		}  // if:  input event created
		if ( m_hOutputEvent != NULL )
		{
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing output event handle\n") );
			CloseHandle( m_hOutputEvent );
			m_hOutputEvent = NULL;
		}  // if:  output event created

	} //*** Cleanup()

}; // class CWorkerThread

/////////////////////////////////////////////////////////////////////////////

#endif // __WORKTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\regexts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExtS.cpp
//
//	Abstract:
//		Stub for implementation of extension registration classes.
//
//	Author:
//		David Potter (davidp)	May 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegExt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\helparr.h ===
#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_PP_RESOURCE_DEBUG_PAGE[]=
{
	IDC_PP_ICON,	((DWORD) -1),	// Debug: "" (Static)
	IDC_PP_DEBUG_DEBUGPREFIX_LABEL,	IDH_110_1071,	// Debug: "&Debug Command Prefix:" (Static)
	IDC_PP_TITLE,	((DWORD) -1),	// Debug: "" (Static)
	IDC_PP_DEBUG_DEBUGPREFIX,	IDH_110_1071,	// Debug: "" (Edit)
	IDC_PP_DEBUG_TEXT,	((DWORD) -1),	// Debug: "" (Static)
	0, 0
};




const DWORD g_a30721HelpIDs[]=
{
	0, 0
};



#else

extern const DWORD g_aHelpIDs_IDD_PP_RESOURCE_DEBUG_PAGE[];
extern const DWORD g_a30721HelpIDs[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Description:
//		Implementation of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DebugEx.h"
#include "ExtObj.h"
#include "ResProp.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static CRuntimeClass * g_rgprtcResPSPages[]	= {
	RUNTIME_CLASS(CDebugParamsPage),
	NULL
	};
static CRuntimeClass ** g_rgpprtcResPSPages[]	= {
	g_rgprtcResPSPages,
	};
static CRuntimeClass * g_rgprtcResTypePSPages[]	= {
	RUNTIME_CLASS(CDebugParamsPage),
	NULL
	};
static CRuntimeClass ** g_rgpprtcResTypePSPages[]	= {
	g_rgprtcResTypePSPages,
	};

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CExtObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
	m_piData = NULL;
	m_bWizard = FALSE;
	m_istrResTypeName = 0;

	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;
	m_hcluster = NULL;
	m_cobj = 0;
	m_podObjData = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::~CExtObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
	// Release the data interface.
	if (PiData() != NULL)
	{
		PiData()->Release();
		m_piData = NULL;
	}  // if:  we have a data interface pointer

	// Delete the pages.
	{
		POSITION	pos;

		pos = Lpg().GetHeadPosition();
		while (pos != NULL)
			delete Lpg().GetNext(pos);
	}  // Delete the pages

	delete m_podObjData;

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//	Routine Description:
//		Indicates whether an interface suportes the IErrorInfo interface.
//		This interface is provided by ATL.
//
//	Arguments:
//		riid		Interface ID.
//
//	Return Value:
//		S_OK		Interface supports IErrorInfo.
//		S_FALSE		Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] = 
	{
		&IID_IWEExtendPropertySheet,
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//	Routine Description:
//		Create property sheet pages and add them to the sheet.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the sheet is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
	IN IUnknown *					piData,
	IN IWCPropertySheetCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	CRuntimeClass **	pprtc	= NULL;
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try 
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		// Create property pages.
		ASSERT(PodObjData() != NULL);
		switch (PodObjData()->m_cot)
		{
			case CLUADMEX_OT_RESOURCE:
				pprtc = g_rgpprtcResPSPages[0];
				break;
			case CLUADMEX_OT_RESOURCETYPE:
				pprtc = g_rgpprtcResTypePSPages[0];
				break;
			default:
				hr = E_NOTIMPL;
				throw &exc;
				break;
		}  // switch:  object type

		// Create each page.
		for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
		{
			// Create the page.
			ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(pprtc[irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddPropertySheetPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page in the list

	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetUIInfo
//
//	Routine Description:
//		Get info about displaying UI.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	// Save info about all types of objects.
	{
		IGetClusterUIInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_lcid = pi->GetLocale();
		m_hfont = pi->GetFont();
		m_hicon = pi->GetIcon();

		pi->Release();
	}  // Save info about all types of objects

	return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrSaveData
//
//	Routine Description:
//		Save data from the object so that it can be used for the life
//		of the object.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	if (piData != m_piData)
	{
		if (m_piData != NULL)
			m_piData->Release();
		m_piData = piData;
	}  // if:  different data interface pointer

	// Save info about all types of objects.
	{
		IGetClusterDataInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_hcluster = pi->GetClusterHandle();
		m_cobj = pi->GetObjectCount();
		if (Cobj() != 1)	// Only have support for one selected object.
			hr = E_NOTIMPL;

		pi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Save info about all types of objects

	// Save info about this object.
	hr = HrGetObjectInfo();
	if (hr != NOERROR)
		return hr;

	return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectInfo
//
//	Routine Description:
//		Get information about the object.
//
//	Arguments:
//		None.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
	HRESULT						hr	= NOERROR;
	IGetClusterObjectInfo *		piGcoi;
	CLUADMEX_OBJECT_TYPE		cot;
	CException					exc(FALSE /*bAutoDelete*/);

	ASSERT(PiData() != NULL);

	// Get object info.
	{
		// Get an IGetClusterObjectInfo interface pointer.
		hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
		if (hr != NOERROR)
			return hr;

		// Read the object data.
		try
		{
			// Delete the previous object data.
			delete m_podObjData;
			m_podObjData = NULL;

			// Get the type of the object.
			cot = piGcoi->GetObjectType(0);
			switch (cot)
			{
				case CLUADMEX_OT_RESOURCE:
					{
						IGetClusterResourceInfo *	pi;

						m_podObjData = new CResData;

						// Get an IGetClusterResourceInfo interface pointer.
						hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &pi);
						if (hr != NOERROR)
							throw &exc;

						PrdResDataRW()->m_hresource = pi->GetResourceHandle(0);
						hr = HrGetResourceTypeName(pi);
						pi->Release();
						if (hr != NOERROR)
							throw &exc;
					}  // if:  object is a node
					break;
				case CLUADMEX_OT_RESOURCETYPE:
					m_podObjData = new CObjData;
					break;
				default:
					hr = E_NOTIMPL;
					throw &exc;
			}  // switch:  object type

			PodObjDataRW()->m_cot = cot;
			hr = HrGetObjectName(piGcoi);
		}  // try
		catch (CException * pe)
		{
			pe->Delete();
		}  // catch:  CException

		piGcoi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Get object info

	return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectName
//
//	Routine Description:
//		Get the name of the object.
//
//	Arguments:
//		piData			IGetClusterObjectInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
	IN OUT IGetClusterObjectInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetObjectName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetObjectName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting object name

		PodObjDataRW()->m_strName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetResourceTypeName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		piData			IGetClusterResourceInfo interface pointer for getting
//							the resource type name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IGetClusterResourceInfo::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
	IN OUT IGetClusterResourceInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetResourceTypeName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetResourceTypeName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting resource type name

		PrdResDataRW()->m_strResTypeName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DebugEx.rc
//
#define IDD_PP_RESOURCE_DEBUG_PAGE      110
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_DEBUG_DEBUGPREFIX_LABEL  1070
#define IDC_PP_DEBUG_DEBUGPREFIX        1071
#define IDC_PP_DEBUG_TEXT               1072
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_NOT_IN_SEPARATE_MONITOR     31102
#define IDS_RESOURCE_TEXT               31103
#define IDS_RESOURCE_TYPE_TEXT          31104
#define IDS_MENU_WHATS_THIS             31105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\helpids.h ===
#define IDH_110_1071	70189166	// Debug: "" (Edit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DebugEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoDebugEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoDebugEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.DebugEx"), _T("CLUADMEX.DebugEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) m_podObjData; }

	CLUADMEX_OBJECT_TYPE		Cot(void) const					{ ASSERT(PodObjData() != NULL); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL) {}

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
#ifdef _DEBUG
 inline void TraceError(IN OUT CException & rexcept)		{ }
 inline void TraceError(IN LPCTSTR pszModule, IN DWORD sc)	{ }
 inline void TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix) { }
 inline void InitAllTraceTags(void)							{ }
 inline void CleanupAllTraceTags(void)						{ }
#else
 #define TraceError(_rexcept)
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 #define InitAllTraceTags()
 #define CleanupAllTraceTags()
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ResProp.cpp
//
//	Description:
//		Implementation of the resource extension property page classes.
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DebugEx.h"
#include "ResProp.h"
#include "ExtObj.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDebugParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CDebugParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CDebugParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CDebugParamsPage)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
	ON_EN_CHANGE(IDC_PP_DEBUG_DEBUGPREFIX, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::CDebugParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDebugParamsPage::CDebugParamsPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RESOURCE_DEBUG_PAGE, NULL)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CDebugParamsPage)
	m_strText = _T("");
	m_strDebugPrefix = _T("");
	//}}AFX_DATA_INIT

	m_cprops = 0;

	m_iddPropertyPage = IDD_PP_RESOURCE_DEBUG_PAGE;

}  //*** CDebugParamsPage::CDebugParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugParamsPage::BInit(IN OUT CExtObject * peo)
{
	ASSERT(peo != NULL);

	m_peo = peo;

	// Setup the property array.
	m_rgProps[epropDebugPrefix].Set(REGPARAM_DEBUG_PREFIX, m_strDebugPrefix, m_strPrevDebugPrefix);
	if (Cot() == CLUADMEX_OT_RESOURCE)
	{
		m_rgProps[epropSeparateMonitor].Set(REGPARAM_SEPARATE_MONITOR, m_bSeparateMonitor, m_bPrevSeparateMonitor);
		m_cprops = sizeof(m_rgProps) / sizeof(CObjectProperty);
	}  // if:  resource object
	else if (Cot() == CLUADMEX_OT_RESOURCETYPE)
		m_cprops = (sizeof(m_rgProps) / sizeof(CObjectProperty)) - 1;
	else
	{
		ASSERT(0);
		return FALSE;
	}  // else:  unsupport object type

	// Call the base class method.
	return CBasePropertyPage::BInit(peo);

}  //*** CDebugParamsPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDebugParamsPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CDebugParamsPage)
	DDX_Control(pDX, IDC_PP_DEBUG_DEBUGPREFIX, m_editPrefix);
	DDX_Text(pDX, IDC_PP_DEBUG_TEXT, m_strText);
	DDX_Text(pDX, IDC_PP_DEBUG_DEBUGPREFIX, m_strDebugPrefix);
	//}}AFX_DATA_MAP

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CDebugParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Load the help text.
	{
		UINT	ids;

		if (Cot() == CLUADMEX_OT_RESOURCE)
			ids = IDS_RESOURCE_TEXT;
		else
			ids = IDS_RESOURCE_TYPE_TEXT;
		m_strText.LoadString(ids);
	}  // Load the help text.

	// Call the base class method.
	CBasePropertyPage::OnInitDialog();

	// Limit the size of the text that can be entered in edit controls.
	m_editPrefix.SetLimitText(_MAX_PATH);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CDebugParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugParamsPage::BApplyChanges(void)
{
	// If the debug prefix string is not empty but the resource is not being
	// run in a separate resource monitor, ask the user if we should change
	// that setting now.  Only do this for resources.
	if (   (Cot() == CLUADMEX_OT_RESOURCE)
		&& (m_strDebugPrefix.GetLength() > 0)
		&& !m_bSeparateMonitor)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		if (AfxMessageBox(IDS_NOT_IN_SEPARATE_MONITOR, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
			m_bSeparateMonitor = TRUE;
	}  // if:  debug prefix string specified for resource but not in separate monitor

	return CBasePropertyPage::BApplyChanges();

}  //*** CDebugParamsPage::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Abstract:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	October 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\debugex\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ResProp.h
//
//	Description:
//		Definition of the resource extension property page classes.
//
//	Implementation File:
//		ResProp.cpp
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDebugParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CDebugParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CDebugParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CDebugParamsPage)

// Construction
public:
	CDebugParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CDebugParamsPage)
	enum { IDD = IDD_PP_RESOURCE_DEBUG_PAGE };
	CEdit	m_editPrefix;
	CString	m_strText;
	CString	m_strDebugPrefix;
	//}}AFX_DATA
	CString	m_strPrevDebugPrefix;
	BOOL	m_bPrevSeparateMonitor;
	BOOL	m_bSeparateMonitor;

protected:
	enum
	{
		epropDebugPrefix,
		epropSeparateMonitor,
		epropMAX
	};
	CObjectProperty		m_rgProps[epropMAX];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDebugParamsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual BOOL		BInit(IN OUT CExtObject * peo);
	virtual BOOL		BApplyChanges(void);
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return m_cprops; }

// Implementation
protected:
	DWORD		m_cprops;

	// Generated message map functions
	//{{AFX_MSG(CDebugParamsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDebugParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\constdef.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ConstDef.h
//
//	Abstract:
//		Definitions of constants used in the IIS Cluster Administrator
//		extension.
//
//	Author:
//		David Potter (davidp)	March 7, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CONSTDEF_H_
#define _CONSTDEF_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_IIS_SERVICE_NAME				_T("ServiceName")
#define REGPARAM_IIS_DIRECTORY					_T("Directory")
#define REGPARAM_IIS_ALIAS						_T("Alias")
#define REGPARAM_IIS_ACCOUNTNAME				_T("AccountName")
#define REGPARAM_IIS_PASSWORD					_T("Password")
#define REGPARAM_IIS_ACCESSMASK 				_T("AccessMask")

#define RESTYPE_NAME_IIS_VIRTUAL_ROOT			_T("IIS Virtual Root")

/////////////////////////////////////////////////////////////////////////////

#endif // _CONSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Abstract:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(pDX, nIDC, (DWORD &) rnValue, (DWORD) nMin, (DWORD) nMax, bSigned);
}

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Abstract:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel(LPTSTR psz);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT(pDX != NULL);
#ifdef _DEBUG
	if (bSigned)
	{
		ASSERT((LONG) dwMin < (LONG) dwMax);
	}
	else
	{
		ASSERT(dwMin < dwMax);
	}
#endif // _DEBUG

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl(nIDC);

	if (pDX->m_bSaveAndValidate)
	{
		BOOL	bTranslated;

		// Get the number from the control.
		dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);

		// If the retrival failed, it is a signed number, and the minimum
		// value is the smallest negative value possible, check the string itself.
		if (!bTranslated && bSigned && (dwMin == 0x80000000))
		{
			UINT	cch;
			TCHAR	szNumber[20];

			// See if it is the smallest negative number.
			cch = GetDlgItemText(pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof(szNumber) / sizeof(TCHAR));
			if ((cch != 0) && (lstrcmp(szNumber, _T("-2147483648")) == 0))
			{
				dwValue = 0x80000000;
				bTranslated = TRUE;
			}  // if:  text retrieved successfully and is highest negative number
		}  // if:  error translating number and getting signed number

		// If the retrieval failed or the specified number is
		// out of range, display an error.
		if (   !bTranslated
			|| (bSigned && (((LONG) dwValue < (LONG) dwMin) || ((LONG) dwValue > (LONG) dwMax)))
			|| (!bSigned && ((dwValue < dwMin) || (dwValue > dwMax)))
			)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			CString strPrompt;

			if (bSigned)
			{
				wsprintf(szMin, _T("%d%"), dwMin);
				wsprintf(szMax, _T("%d%"), dwMax);
			}  // if:  signed number
			else
			{
				wsprintf(szMin, _T("%u%"), dwMin);
				wsprintf(szMax, _T("%u%"), dwMax);
			}  // else:  unsigned number
			AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		}  // if:  invalid string
		else
			rdwValue = dwValue;
	}  // if:  saving data
	else
	{
		CString		strMinValue;
		CString		strMaxValue;
		UINT		cchMax;

		// Set the maximum number of characters that can be entered.
		if (bSigned)
		{
			strMinValue.Format(_T("%d"), dwMin);
			strMaxValue.Format(_T("%d"), dwMax);
		}  // if:  signed value
		else
		{
			strMinValue.Format(_T("%u"), dwMin);
			strMaxValue.Format(_T("%u"), dwMax);
		}  // else:  unsigned value
		cchMax = max(strMinValue.GetLength(), strMaxValue.GetLength());
		SendMessage(hwndCtrl, EM_LIMITTEXT, cchMax, 0);

		// Set the value into the control.
		if (bSigned)
		{
			LONG lValue = (LONG) rdwValue;
			DDX_Text(pDX, nIDC, lValue);
		}  // if:  signed value
		else
			DDX_Text(pDX, nIDC, rdwValue);
	}  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pDX->m_bSaveAndValidate)
	{
		if (rstrValue.GetLength() == 0)
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			CleanupLabel(szLabel);

			// Format and display a message.
			strPrompt.FormatMessage(IDS_REQUIRED_FIELD_EMPTY, szLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  field not specified
	}  // if:  saving data

}  //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupLabel
//
//	Routine Description:
//		Prepare a label read from a dialog to be used as a string in a
//		message by removing ampersands (&) and colons (:).
//
//	Arguments:
//		pszLabel	[IN OUT] Label to be cleaned up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel(LPTSTR pszLabel)
{
	LPTSTR	pIn, pOut;
	LANGID	langid;
	WORD	primarylangid;
	BOOL	bFELanguage;

	// Get the language ID.
	langid = GetUserDefaultLangID();
	primarylangid = (WORD) PRIMARYLANGID(langid);
	bFELanguage = ((primarylangid == LANG_JAPANESE)
					|| (primarylangid == LANG_CHINESE)
					|| (primarylangid == LANG_KOREAN));

	//
	// copy the name sans '&' and ':' chars
	//

	pIn = pOut = pszLabel;
	do
	{
		//
		// strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
		//
		if (   bFELanguage
			&& (pIn[0] == _T('('))
			&& (pIn[1] == _T('&'))
			&& (pIn[2] != _T('\0'))
			&& (pIn[3] == _T(')')))
		{
			pIn += 3;
		}
		else if ((*pIn != _T('&')) && (*pIn != _T(':')))
			*pOut++ = *pIn;
	} while (*pIn++ != _T('\0')) ;

}  //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\chat.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    Chat.h

    This file contains constants & type definitions shared between the
    CHAT Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        KentCe      11-Dec-1995 Imported for new chat server

*/


#ifndef _CHAT_H_
#define _CHAT_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define CHAT_ANNOTATION_FILE_A           "~CHATSVC~.CKM"
#define CHAT_ANNOTATION_FILE_W          L"~CHATSVC~.CKM"


//
//  Configuration parameters registry key.
//
# define CHAT_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## CHAT_SERVICE_NAME_A

# define CHAT_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## CHAT_SERVICE_NAME_W

#define CHAT_PARAMETERS_KEY_A   CHAT_SERVICE_KEY_A ## "\\Parameters"
  
#define CHAT_PARAMETERS_KEY_W   CHAT_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define CHAT_PERFORMANCE_KEY_A  CHAT_SERVICE_KEY_A ## "\\Performance"

#define CHAT_PERFORMANCE_KEY_W  CHAT_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate CHATSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the CHAT Server.
//

#define CHAT_ACCESS_KEY_A                "AccessCheck"
#define CHAT_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define CHAT_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define CHAT_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define CHAT_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define CHAT_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define CHAT_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define CHAT_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define CHAT_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define CHAT_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define CHAT_GREETING_MESSAGE_A          "GreetingMessage"
#define CHAT_GREETING_MESSAGE_W         L"GreetingMessage"

#define CHAT_EXIT_MESSAGE_A              "ExitMessage"
#define CHAT_EXIT_MESSAGE_W             L"ExitMessage"

#define CHAT_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define CHAT_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define CHAT_DEBUG_FLAGS_A               "DebugFlags"
#define CHAT_DEBUG_FLAGS_W              L"DebugFlags"

#define CHAT_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define CHAT_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define CHAT_LOWERCASE_FILES_A           "LowercaseFiles"
#define CHAT_LOWERCASE_FILES_W          L"LowercaseFiles"

#define CHAT_LISTEN_BACKLOG_A            "ListenBacklog"
#define CHAT_LISTEN_BACKLOG_W           L"ListenBacklog"

#define CHAT_ENABLE_LICENSING_A          "EnableLicensing"
#define CHAT_ENABLE_LICENSING_W         L"EnableLicensing"

#define CHAT_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define CHAT_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define CHAT_ANONYMOUS_SECRET_A          "CHAT_ANONYMOUS_DATA"
#define CHAT_ANONYMOUS_SECRET_W         L"CHAT_ANONYMOUS_DATA"

#define CHAT_ROOT_SECRET_A               "CHAT_ROOT_DATA"
#define CHAT_ROOT_SECRET_W              L"CHAT_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define CHAT_ANNOTATION_FILE            CHAT_ANNOTATION_FILE_W
#define CHAT_PARAMETERS_KEY             CHAT_PARAMETERS_KEY_W
#define CHAT_PERFORMANCE_KEY            CHAT_PERFORMANCE_KEY_W
#define CHAT_ACCESS_KEY                 CHAT_ACCESS_KEY_W
#define CHAT_ALLOW_ANONYMOUS            CHAT_ALLOW_ANONYMOUS_W
#define CHAT_ALLOW_GUEST_ACCESS         CHAT_ALLOW_GUEST_ACCESS_W
#define CHAT_ANONYMOUS_ONLY             CHAT_ANONYMOUS_ONLY_W
#define CHAT_MSDOS_DIR_OUTPUT           CHAT_MSDOS_DIR_OUTPUT_W
#define CHAT_GREETING_MESSAGE           CHAT_GREETING_MESSAGE_W
#define CHAT_EXIT_MESSAGE               CHAT_EXIT_MESSAGE_W
#define CHAT_MAX_CLIENTS_MSG            CHAT_MAX_CLIENTS_MSG_W
#define CHAT_DEBUG_FLAGS                CHAT_DEBUG_FLAGS_W
#define CHAT_ANNOTATE_DIRS              CHAT_ANNOTATE_DIRS_W
#define CHAT_ANONYMOUS_SECRET           CHAT_ANONYMOUS_SECRET_W
#define CHAT_LOWERCASE_FILES            CHAT_LOWERCASE_FILES_W
#define CHAT_LISTEN_BACKLOG             CHAT_LISTEN_BACKLOG_W
#define CHAT_ENABLE_LICENSING           CHAT_ENABLE_LICENSING_W
#define CHAT_DEFAULT_LOGON_DOMAIN       CHAT_DEFAULT_LOGON_DOMAIN_W

#else   // !UNICODE

#define CHAT_ANNOTATION_FILE            CHAT_ANNOTATION_FILE_A
#define CHAT_PARAMETERS_KEY             CHAT_PARAMETERS_KEY_A
#define CHAT_PERFORMANCE_KEY            CHAT_PERFORMANCE_KEY_A
#define CHAT_ACCESS_KEY                 CHAT_ACCESS_KEY_A
#define CHAT_ANONYMOUS_ONLY             CHAT_ANONYMOUS_ONLY_A
#define CHAT_ALLOW_ANONYMOUS            CHAT_ALLOW_ANONYMOUS_A
#define CHAT_ALLOW_GUEST_ACCESS         CHAT_ALLOW_GUEST_ACCESS_A
#define CHAT_MSDOS_DIR_OUTPUT           CHAT_MSDOS_DIR_OUTPUT_A
#define CHAT_GREETING_MESSAGE           CHAT_GREETING_MESSAGE_A
#define CHAT_EXIT_MESSAGE               CHAT_EXIT_MESSAGE_A
#define CHAT_MAX_CLIENTS_MSG            CHAT_MAX_CLIENTS_MSG_A
#define CHAT_DEBUG_FLAGS                CHAT_DEBUG_FLAGS_A
#define CHAT_ANNOTATE_DIRS              CHAT_ANNOTATE_DIRS_A
#define CHAT_ANONYMOUS_SECRET           CHAT_ANONYMOUS_SECRET_A
#define CHAT_LOWERCASE_FILES            CHAT_LOWERCASE_FILES_A
#define CHAT_LISTEN_BACKLOG             CHAT_LISTEN_BACKLOG_A
#define CHAT_ENABLE_LICENSING           CHAT_ENABLE_LICENSING_A
#define CHAT_DEFAULT_LOGON_DOMAIN       CHAT_DEFAULT_LOGON_DOMAIN_A

  
#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _CHAT_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} CHAT_USER_INFO, * LPCHAT_USER_INFO;

typedef struct _CHAT_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         TimeOfLastClear;

} CHAT_STATISTICS_0, * LPCHAT_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_ChatEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPCHAT_USER_INFO * Buffer
    );

NET_API_STATUS
I_ChatDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_ChatQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_ChatSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_ChatQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_ChatClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _CHAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Abstract:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Implementation File:
//		BasePage.cpp
//		BasePage.inl
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(
		IN const DWORD *	pdwHelpMap,
		IN const DWORD *	pdwWizardHelpMap
		);
	CBasePropertyPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN const DWORD *	pdwWizardHelpMap,
		IN UINT				nIDCaption = 0
		);
	virtual ~CBasePropertyPage(void) { }

	// Second phase construction.
	virtual BOOL		BInit(IN OUT CExtObject * peo);

protected:
	void				CommonConstruct(void);

// Attributes
protected:
	CExtObject *		m_peo;
	HPROPSHEETPAGE		m_hpage;

	IDD					m_iddPropertyPage;
	IDD					m_iddWizardPage;
	IDS					m_idsCaption;

	CExtObject *		Peo(void) const					{ return m_peo; }
	HPROPSHEETPAGE		Hpage(void) const				{ return m_hpage; }

	IDD					IddPropertyPage(void) const		{ return m_iddPropertyPage; }
	IDD					IddWizardPage(void) const		{ return m_iddWizardPage; }
	IDS					IdsCaption(void) const			{ return m_idsCaption; }

public:
	void				SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual DWORD			DwParseUnknownProperty(
								IN LPCWSTR							pwszName,
								IN const CLUSPROP_BUFFER_HELPER &	rvalue,
								IN DWORD							cbBuf
								)		{ return ERROR_SUCCESS; }
	virtual BOOL			BApplyChanges(void);
	virtual void			BuildPropList(IN OUT CClusPropList & rcpl);

	virtual const CObjectProperty *	Pprops(void) const	{ return NULL; }
	virtual DWORD					Cprops(void) const	{ return 0; }

// Implementation
protected:
	BOOL					m_bBackPressed;
	const DWORD *			m_pdwWizardHelpMap;
	BOOL					m_bDoDetach;

	BOOL					BBackPressed(void) const		{ return m_bBackPressed; }
	IWCWizardCallback *		PiWizardCallback(void) const;
	BOOL					BWizard(void) const;
	HCLUSTER				Hcluster(void) const;
	void					EnableNext(IN BOOL bEnable = TRUE);

	DWORD					DwParseProperties(IN CClusPropList & rcpl);
	BOOL					BSetPrivateProps(IN BOOL bValidateOnly = FALSE);

	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Abstract:
//		Implementation of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IISClEx3.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CBasePropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
	CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		pdwHelpMap			[IN] Control-to-help ID map.
//		pdwWizardHelpMap	[IN] Control-to-help ID map if this is a wizard page.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN const DWORD *	pdwHelpMap,
	IN const DWORD *	pdwWizardHelpMap
	)
	: m_dlghelp(pdwHelpMap, 0)
{
	CommonConstruct();
	m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		idd					[IN] Dialog template resource ID.
//		pdwHelpMap			[IN] Control-to-help ID map.
//		pdwWizardHelpMap	[IN] Control-to-help ID map if this is a wizard page.
//		nIDCaption			[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN const DWORD *	pdwWizardHelpMap,
	IN UINT				nIDCaption
	)
	: CPropertyPage(idd, nIDCaption)
	, m_dlghelp(pdwHelpMap, idd)
{
	CommonConstruct();
	m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CommonConstruct
//
//	Routine Description:
//		Common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
	//{{AFX_DATA_INIT(CBasePropertyPage)
	//}}AFX_DATA_INIT

	m_peo = NULL;
	m_hpage = NULL;
	m_bBackPressed = FALSE;

	m_iddPropertyPage = NULL;
	m_iddWizardPage = NULL;
	m_idsCaption = NULL;

	m_pdwWizardHelpMap = NULL;

	m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
	ASSERT(peo != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	m_peo = peo;

	// Change the help map if this is a wizard page.
	if (Peo()->BWizard())
		m_dlghelp.SetMap(m_pdwWizardHelpMap);

	// Don't display a help button.
	m_psp.dwFlags &= ~PSP_HASHELP;

	// Construct the property page.
	if (Peo()->BWizard())
	{
		ASSERT(IddWizardPage() != NULL);
		Construct(IddWizardPage(), IdsCaption());
		m_dlghelp.SetHelpMask(IddWizardPage());
	}  // if:  adding page to wizard
	else
	{
		ASSERT(IddPropertyPage() != NULL);
		Construct(IddPropertyPage(), IdsCaption());
		m_dlghelp.SetHelpMask(IddPropertyPage());
	}  // else:  adding page to property sheet

	// Read the properties private to this resource and parse them.
	{
		DWORD			dwStatus;
		CClusPropList	cpl;

		ASSERT(Peo() != NULL);
		ASSERT(Peo()->PrdResData() != NULL);
		ASSERT(Peo()->PrdResData()->m_hresource != NULL);

		// Read the properties.
		dwStatus = cpl.ScGetResourceProperties(
								Peo()->PrdResData()->m_hresource,
								CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
								);

		// Parse the properties.
		if (dwStatus == ERROR_SUCCESS)
		{
			// Parse the properties.
			try
			{
				dwStatus = DwParseProperties(cpl);
			}  // try
			catch (CMemoryException * pme)
			{
				dwStatus = ERROR_NOT_ENOUGH_MEMORY;
				pme->Delete();
			}  // catch:  CMemoryException
		}  // if:  properties read successfully

		if (dwStatus != ERROR_SUCCESS)
		{
			return FALSE;
		}  // if:  error parsing getting or parsing properties
	}  // Read the properties private to this resource and parse them

	return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DwParseProperties
//
//	Routine Description:
//		Parse the properties of the resource.  This is in a separate function
//		from BInit so that the optimizer can do a better job.
//
//	Arguments:
//		rcpl			[IN] Cluster property list to parse.
//
//	Return Value:
//		ERROR_SUCCESS	Properties were parsed successfully.
//
//	Exceptions Thrown:
//		Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN CClusPropList & rcpl)
{
	DWORD					_sc;
	DWORD					_cprop;
	const CObjectProperty *	_pprop;

	ASSERT( rcpl.PbPropList() != NULL );

	_sc = rcpl.ScMoveToFirstProperty();
	while ( _sc == ERROR_SUCCESS )
	{
		//
		// Parse known properties.
		//
		for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
		{
			if ( lstrcmpiW( rcpl.PszCurrentPropertyName(), _pprop->m_pwszName ) == 0 )
			{
				ASSERT( rcpl.CpfCurrentValueFormat() == _pprop->m_propFormat );
				switch ( _pprop->m_propFormat )
				{
					case CLUSPROP_FORMAT_SZ:
					case CLUSPROP_FORMAT_EXPAND_SZ:
						ASSERT(		(rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
								||	(	(rcpl.CbCurrentValueLength() == 0)
									&&	(rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
						*_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
						*_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
						break;
					case CLUSPROP_FORMAT_DWORD:
					case CLUSPROP_FORMAT_LONG:
						ASSERT( rcpl.CbCurrentValueLength() == sizeof( DWORD ) );
						*_pprop->m_value.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
						*_pprop->m_valuePrev.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						*_pprop->m_value.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
						*_pprop->m_value.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
						*_pprop->m_valuePrev.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
						*_pprop->m_valuePrev.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				} // switch: property format

				// Exit the loop since we found the parameter.
				break;
			} // if: found a match
		} // for: each property that we know about

		//
		// If the property wasn't known, ask the derived class to parse it.
		//
		if ( _cprop == 0 )
		{
			_sc = DwParseUnknownProperty(
						rcpl.CbhCurrentPropertyName().pName->sz,
						rcpl.CbhCurrentValue(),
						rcpl.RPvlPropertyValue().CbDataLeft()
						);
			if ( _sc != ERROR_SUCCESS )
			{
				return _sc;
			} // if: error parsing the unknown property
		} // if: property not parsed

		//
		// Advance the buffer pointer past the value in the value list.
		//
		_sc = rcpl.ScMoveToNextProperty();
	} // while: more properties to parse

	//
	// If we reached the end of the properties, fix the return code.
	//
	if ( _sc == ERROR_NO_MORE_ITEMS )
	{
		_sc = ERROR_SUCCESS;
	} // if: ended loop after parsing all properties

	return _sc;

}  //*** CBasePropertyPage::DwParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
	{
		HWND _hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach(_hWnd);
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Routine Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if (m_bDoDetach)
	{
		if (m_hWnd != NULL)
		{
			HWND hWnd = m_hWnd;

			Detach();
			m_hWnd = hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//{{AFX_DATA_MAP(CBasePropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

	if (pDX->m_bSaveAndValidate)
	{
		if (!BBackPressed())
		{
			CWaitCursor	wc;

			// Validate the data.
			if (!BSetPrivateProps(TRUE /*bValidateOnly*/))
				pDX->Fail();
		}  // if:  Back button not pressed
	}  // if:  saving data from dialog
	else
	{
		// Set the title.
		DDX_Text(pDX, IDC_PP_TITLE, m_strTitle);
	}  // if:  not saving data

	CPropertyPage::DoDataExchange(pDX);

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
	ASSERT(Peo() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Set the title string.
	m_strTitle = Peo()->RrdResData().m_strName;

	// Call the base class method.
	CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if (Peo()->Hicon() != NULL)
		m_staticIcon.SetIcon(Peo()->Hicon());

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
	HRESULT		hr;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Reread the data.
	hr = Peo()->HrGetObjectInfo();
	if (hr != NOERROR)
		return FALSE;

	// Set the title string.
	m_strTitle = Peo()->RrdResData().m_strName;

	m_bBackPressed = FALSE;
	return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnApply
//
//	Routine Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
	ASSERT(!BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardBack
//
//	Routine Description:
//		Handler for the PSN_WIZBACK message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack(void)
{
	LRESULT		lResult;

	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	lResult = CPropertyPage::OnWizardBack();
	if (lResult != -1)
		m_bBackPressed = TRUE;

	return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardNext
//
//	Routine Description:
//		Handler for the PSN_WIZNEXT message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext(void)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return -1;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return -1;

	// Create the object.

	return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardFinish
//
//	Routine Description:
//		Handler for the PSN_WIZFINISH message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		FALSE	Don't change the page.
//		TRUE	Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish(void)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnChangeCtrl
//
//	Routine Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::EnableNext
//
//	Routine Description:
//		Enables or disables the NEXT or FINISH button.
//
//	Arguments:
//		bEnable		[IN] TRUE = enable the button, FALSE = disable the button.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext(IN BOOL bEnable /*TRUE*/)
{
	ASSERT(BWizard());
	ASSERT(PiWizardCallback());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	PiWizardCallback()->EnableNext((LONG *) Hpage(), bEnable);

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Save data.
	return BSetPrivateProps();

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BuildPropList
//
//	Routine Description:
//		Build the property list.
//
//	Arguments:
//		rcpl		[IN OUT] Cluster property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
	IN OUT CClusPropList & rcpl
	)
{
	DWORD					cprop;
	const CObjectProperty *	pprop;

	for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
	{
		switch (pprop->m_propFormat)
		{
			case CLUSPROP_FORMAT_SZ:
				rcpl.ScAddProp(
						pprop->m_pwszName,
						*pprop->m_value.pstr,
						*pprop->m_valuePrev.pstr
						);
				break;
			case CLUSPROP_FORMAT_DWORD:
				rcpl.ScAddProp(
						pprop->m_pwszName,
						*pprop->m_value.pdw,
						*pprop->m_valuePrev.pdw
						);
				break;
			case CLUSPROP_FORMAT_BINARY:
			case CLUSPROP_FORMAT_MULTI_SZ:
				rcpl.ScAddProp(
						pprop->m_pwszName,
						*pprop->m_value.ppb,
						*pprop->m_value.pcb,
						*pprop->m_valuePrev.ppb,
						*pprop->m_valuePrev.pcb
						);
				break;
			default:
				ASSERT(0);	// don't know how to deal with this type
				return;
		}  // switch:  property format
	}  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BSetPrivateProps
//
//	Routine Description:
//		Set the private properties for this object.
//
//	Arguments:
//		bValidateOnly	[IN] TRUE = only validate the data.
//
//	Return Value:
//		ERROR_SUCCESS	The operation was completed successfully.
//		!0				Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(IN BOOL bValidateOnly)
{
	BOOL			bSuccess	= TRUE;
	CClusPropList	cpl(BWizard() /*bAlwaysAddProp*/);

	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PrdResData());
	ASSERT(Peo()->PrdResData()->m_hresource);

	// Build the property list.
	try
	{
		BuildPropList(cpl);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		bSuccess = FALSE;
	}  // catch:  CException

	// Set the data.
	if (bSuccess)
	{
		if ((cpl.PbPropList() != NULL) && (cpl.CbPropList() > 0))
		{
			DWORD		dwStatus;
			DWORD		dwControlCode;
			DWORD		cbProps;

			// Determine which control code to use.
			if (bValidateOnly)
				dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
			else
				dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;

			// Set private properties.
			dwStatus = ClusterResourceControl(
							Peo()->PrdResData()->m_hresource,
							NULL,	// hNode
							dwControlCode,
							cpl.PbPropList(),
							cpl.CbPropList(),
							NULL,	// lpOutBuffer
							0,		// nOutBufferSize
							&cbProps
							);
			if (dwStatus != ERROR_SUCCESS)
			{
				CString strMsg;
				FormatError(strMsg, dwStatus);
				AfxMessageBox(strMsg);
				if (bValidateOnly
						|| (dwStatus != ERROR_RESOURCE_PROPERTIES_STORED))
					bSuccess = FALSE;
			}  // if:  error setting/validating data
		}  // if:  there is data to set
	}  // if:  no errors building the property list

	// Save data locally.
	if (!bValidateOnly && bSuccess)
	{
		// Save new values as previous values.
		try
		{
			DWORD					cprop;
			const CObjectProperty *	pprop;

			for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
			{
				switch (pprop->m_propFormat)
				{
					case CLUSPROP_FORMAT_SZ:
						ASSERT(pprop->m_value.pstr != NULL);
						ASSERT(pprop->m_valuePrev.pstr != NULL);
						*pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
						break;
					case CLUSPROP_FORMAT_DWORD:
						ASSERT(pprop->m_value.pdw != NULL);
						ASSERT(pprop->m_valuePrev.pdw != NULL);
						*pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						ASSERT(pprop->m_value.ppb != NULL);
						ASSERT(*pprop->m_value.ppb != NULL);
						ASSERT(pprop->m_value.pcb != NULL);
						ASSERT(pprop->m_valuePrev.ppb != NULL);
						ASSERT(*pprop->m_valuePrev.ppb != NULL);
						ASSERT(pprop->m_valuePrev.pcb != NULL);
						delete [] *pprop->m_valuePrev.ppb;
						*pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
						CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
						*pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				}  // switch:  property format
			}  // for:  each property
		}  // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  // if:  not just validating and successful so far

	return bSuccess;

}  //*** CBasePropertyPage::BSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	BOOL	bProcessed;

	bProcessed = (BOOL) m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!bProcessed)
		bProcessed = (BOOL) CPropertyPage::OnCommandHelp(wParam, lParam);

	return bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_DATA and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage and CPageList
#endif

//#define _DEMO_CTX_MENUS

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject : 
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
	public IWEExtendContextMenu,
	public IWEInvokeCommand,
#endif
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoIISClEx3>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
#ifdef _DEMO_CTX_MENUS
	COM_INTERFACE_ENTRY(IWEExtendContextMenu)
	COM_INTERFACE_ENTRY(IWEInvokeCommand)
#endif
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.IIS"), _T("CLUADMEX.IIS"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

#ifdef _DEMO_CTX_MENUS
// IWEExtendContextMenu
public:
	STDMETHOD(AddContextMenuItems)(
					IN IUnknown *				piData,
					IN IWCContextMenuCallback *	piCallback
					);

// IWEInvokeCommand
	STDMETHOD(InvokeCommand)(
					IN ULONG					nCommandID,
					IN IUnknown *				piData
					);
#endif

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterDataInfo data
	CString						m_strClusterName;
	HCLUSTER					m_hcluster;
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;
	LONG						m_cobj;

	CResData					m_rdResData;

	CObjData *					PodObjDataRW(void) const		{ return (CObjData *) &m_rdResData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) &m_rdResData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterDataInfo data
	const CString &				StrClusterName(void) const		{ return m_strClusterName; }
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CResData &			RrdResData(void) const			{ return m_rdResData; }
	const CObjData *			PodObjData(void) const			{ return &m_rdResData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) &m_rdResData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetClusterName(IN OUT IGetClusterDataInfo * pi);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);
	BOOL						BGetResourceNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\helparr.h ===
#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_PP_IIS_PARAMETERS[]=
{
	IDC_PP_IIS_WWW,	IDH_180_1082,	// Parameters: "&WWW" (Button)
	IDC_PP_IIS_ALIAS_LABEL,	IDH_180_1084,	// Parameters: "A&lias:" (Static)
	IDC_PP_IIS_ALIAS,	IDH_180_1084,	// Parameters: "" (Edit)
	IDC_PP_IIS_DIRECTORY_LABEL,	IDH_180_1086,	// Parameters: "&Directory:" (Static)
	IDC_PP_IIS_DIRECTORY,	IDH_180_1086,	// Parameters: "" (Edit)
	IDC_PP_IIS_BROWSE,	IDH_180_1087,	// Parameters: "&Browse..." (Button)
	IDC_PP_ICON,	((DWORD) -1),	// Parameters: "" (Static)
	IDC_PP_IIS_ACCESS_GROUP,	IDH_180_1093,	// Parameters: "Access" (Button)
	IDC_PP_TITLE,	((DWORD) -1),	// Parameters: "" (Static)
	IDC_PP_IIS_READ_ACCESS,	IDH_180_1093,	// Parameters: "&Read" (Button)
	IDC_PP_IIS_WRITE_ACCESS,	IDH_180_1093,	// Parameters: "E&xecute" (Button)
	IDC_PP_IIS_FTP,	IDH_180_1080,	// Parameters: "&FTP" (Button)
	IDC_PP_IIS_GOPHER,	IDH_180_1081,	// Parameters: "&Gopher" (Button)
	0, 0
};




const DWORD g_aHelpIDs_IDD_WIZ_IIS_PARAMETERS[]=
{
	IDC_PP_IIS_WWW,	IDH_180_1082,	// Parameters: "&WWW" (Button)
	IDC_PP_IIS_ALIAS_LABEL,	IDH_180_1084,	// Parameters: "A&lias:" (Static)
	IDC_PP_IIS_ALIAS,	IDH_180_1084,	// Parameters: "" (Edit)
	IDC_PP_IIS_DIRECTORY_LABEL,	IDH_180_1086,	// Parameters: "&Directory:" (Static)
	IDC_PP_IIS_DIRECTORY,	IDH_180_1086,	// Parameters: "" (Edit)
	IDC_PP_IIS_BROWSE,	IDH_181_1087,	// Parameters: "&Browse..." (Button)
	IDC_PP_ICON,	((DWORD) -1),	// Parameters: "" (Static)
	IDC_PP_IIS_ACCESS_GROUP,	IDH_180_1093,	// Parameters: "Access" (Button)
	IDC_PP_TITLE,	((DWORD) -1),	// Parameters: "" (Static)
	IDC_PP_IIS_READ_ACCESS,	IDH_180_1093,	// Parameters: "&Read" (Button)
	IDC_PP_IIS_WRITE_ACCESS,	IDH_180_1093,	// Parameters: "E&xecute" (Button)
	IDC_PP_IIS_FTP,	IDH_180_1080,	// Parameters: "&FTP" (Button)
	IDC_PP_IIS_GOPHER,	IDH_180_1081,	// Parameters: "&Gopher" (Button)
	0, 0
};




const DWORD g_a30721HelpIDs[]=
{
	100,	IDH_30721_100,	// New: "" (ListBox)
	57670,	IDH_30721_57670,	// New: "&Help" (Button)
	0, 0
};



#else

extern const DWORD g_aHelpIDs_IDD_PP_IIS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_IIS_PARAMETERS[];
extern const DWORD g_a30721HelpIDs[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Implementation of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Author:
//		David Potter (davidp)	August 29, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "IISClEx3.h"
#include "ExtObj.h"

#include "Iis.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
		RESTYPE_NAME_IIS_VIRTUAL_ROOT L"\0"
		;
const DWORD g_cchResourceTypeNames	= sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcPSIISPages[]	= {
	RUNTIME_CLASS(CIISVirtualRootParamsPage),
	NULL
	};

static CRuntimeClass ** g_rgpprtcPSPages[]	= {
	g_rgprtcPSIISPages
	};

// Wizard pages and property sheet pages are the same.
static CRuntimeClass ** g_rgpprtcWizPages[]	= {
	g_rgprtcPSIISPages
	};

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CExtObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
	m_piData = NULL;
	m_piWizardCallback = NULL;
	m_bWizard = FALSE;
	m_istrResTypeName = 0;

	m_hcluster = NULL;
	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::~CExtObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
	// Release the data interface.
	if (PiData() != NULL)
	{
		PiData()->Release();
		m_piData = NULL;
	}  // if:  we have a data interface pointer

	// Release the wizard callback interface.
	if (PiWizardCallback() != NULL)
	{
		PiWizardCallback()->Release();
		m_piWizardCallback = NULL;
	}  // if:  we have a wizard callback interface pointer

	// Delete the pages.
	{
		POSITION	pos;

		pos = Lpg().GetHeadPosition();
		while (pos != NULL)
			delete Lpg().GetNext(pos);
	}  // Delete the pages

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//	Routine Description:
//		Indicates whether an interface suportes the IErrorInfo interface.
//		This interface is provided by ATL.
//
//	Arguments:
//		riid		Interface ID.
//
//	Return Value:
//		S_OK		Interface supports IErrorInfo.
//		S_FALSE		Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] =
	{
		&IID_IWEExtendPropertySheet,
		&IID_IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
		&IID_IWEExtendContextMenu,
#endif
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//	Routine Description:
//		Create property sheet pages and add them to the sheet.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the sheet is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
	IN IUnknown *					piData,
	IN IWCPropertySheetCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		// Add each page for this type of resource.
		for (irtc = 0 ; g_rgpprtcPSPages[IstrResTypeName()][irtc] != NULL ; irtc++)
		{
			// Create the property pages.
			ppage = (CBasePropertyPage *) g_rgpprtcPSPages[IstrResTypeName()][irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(g_rgpprtcPSPages[IstrResTypeName()][irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddPropertySheetPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page for the type of resource
	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add property page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add property page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreateWizardPages (IWEExtendWizard)
//
//	Routine Description:
//		Create property sheet pages and add them to the wizard.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the wizard is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
	IN IUnknown *			piData,
	IN IWCWizardCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		m_piWizardCallback = piCallback;
		m_bWizard = TRUE;

		// Add each page for this type of resource.
		for (irtc = 0 ; g_rgpprtcWizPages[IstrResTypeName()][irtc] != NULL ; irtc++)
		{
			// Create the property pages.
			ppage = (CBasePropertyPage *) g_rgpprtcWizPages[IstrResTypeName()][irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(g_rgpprtcWizPages[IstrResTypeName()][irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddWizardPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page for the type of resource
	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add wizard page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add wizard page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piCallback->Release();
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	return hr;

}  //*** CExtObject::CreateWizardPages()

#ifdef _DEMO_CTX_MENUS
/////////////////////////////////////////////////////////////////////////////
// IWEExtendContextMenu Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::AddContextMenuItems (IWEExtendContextMenu)
//
//	Routine Description:
//		Add items to a context menu.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the context menu is being displayed.
//		piCallback		Pointer to an IWCContextMenuCallback interface
//							for adding menu items to the context menu.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_FAIL			Error adding context menu item.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes returned by HrSaveData() or IWCContextMenuCallback::
//		AddExtensionMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::AddContextMenuItems(
	IN IUnknown *				piData,
	IN IWCContextMenuCallback *	piCallback
	)
{
	HRESULT			hr		= NOERROR;
	CException		exc(FALSE /*bAutoDelete*/);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Add menu items specific to this resource type.
		{
			ULONG		iCommandID;
			LPWSTR		pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
			LPWSTR		pwszName;
			LPWSTR		pwszStatusBarText;

			for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
			{
				pwszName = pwsz;
				pwszStatusBarText = pwszName + (::wcslen(pwszName) + 1);
				hr = piCallback->AddExtensionMenuItem(
									pwszName,			// lpszName
									pwszStatusBarText,	// lpszStatusBarText
									iCommandID,			// lCommandID
									0,					// lSubCommandID
									0					// uFlags
									);
				if (hr != NOERROR)
					throw &exc;
				pwsz = pwszStatusBarText + (::wcslen(pwszStatusBarText) + 1);
			}  // while:  more menu items to add
		}  // Add menu items specific to this resource type
	}  // try
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add context menu item\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
// IWEInvokeCommand Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InvokeCommand (IWEInvokeCommand)
//
//	Routine Description:
//		Invoke a command offered by a context menu.
//
//	Arguments:
//		lCommandID		ID of the menu item to execute.  This is the same
//							ID passed to the IWCContextMenuCallback
//							::AddExtensionMenuItem() method.
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the command is to be invoked.
//
//	Return Value:
//		NOERROR			Command invoked successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::InvokeCommand(
	IN ULONG		nCommandID,
	IN IUnknown *	piData
	)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Find the item that was executed in our table.
	hr = HrSaveData(piData);
	if (hr == NOERROR)
	{
		ULONG		iCommandID;
		LPWSTR		pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
		LPWSTR		pwszName;
		LPWSTR		pwszStatusBarText;

		for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
		{
			pwszName = pwsz;
			pwszStatusBarText = pwszName + (::wcslen(pwszName) + 1);
			if (iCommandID == nCommandID)
				break;
			pwsz = pwszStatusBarText + (::wcslen(pwszStatusBarText) + 1);
		}  // while:  more menu items to add
		if (iCommandID == nCommandID)
		{
			CString		strMsg;
			CString		strName;

			try
			{
				strName = pwszName;
				strMsg.Format(_T("Item %s was executed"), strName);
				AfxMessageBox(strMsg);
			}  // try
			catch (CException * pe)
			{
				pe->Delete();
			}  // catch:  CException
		}  // if:  command ID found
	}  // if:  no errors saving the data

	piData->Release();
	m_piData = NULL;
	return NOERROR;

}  //*** CExtObject::InvokeCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetUIInfo
//
//	Routine Description:
//		Get info about displaying UI.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	// Save info about all types of objects.
	{
		IGetClusterUIInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_lcid = pi->GetLocale();
		m_hfont = pi->GetFont();
		m_hicon = pi->GetIcon();

		pi->Release();
	}  // Save info about all types of objects

	return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrSaveData
//
//	Routine Description:
//		Save data from the object so that it can be used for the life
//		of the object.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	if (piData != m_piData)
	{
		if (m_piData != NULL)
			m_piData->Release();
		m_piData = piData;
	}  // if:  different data interface pointer

	// Save info about all types of objects.
	{
		IGetClusterDataInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_hcluster = pi->GetClusterHandle();
		m_cobj = pi->GetObjectCount();
		if (Cobj() != 1)
			hr = E_NOTIMPL;
		else
			hr = HrGetClusterName(pi);

		pi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Save info about all types of objects

	// Save info about this object.
	hr = HrGetObjectInfo();
	if (hr != NOERROR)
		return hr;

	return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectInfo
//
//	Routine Description:
//		Get information about the object.
//
//	Arguments:
//		None.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
	HRESULT						hr	= NOERROR;
	IGetClusterObjectInfo *		piGcoi;
	IGetClusterResourceInfo *	piGcri;
	CException					exc(FALSE /*bAutoDelete*/);

	ASSERT(PiData() != NULL);

	// Get an IGetClusterObjectInfo interface pointer.
	hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
	if (hr != NOERROR)
		return hr;

	// Read the object data.
	try
	{
		// Get the type of the object.
		m_rdResData.m_cot = piGcoi->GetObjectType(0);
		if (m_rdResData.m_cot != CLUADMEX_OT_RESOURCE)
		{
			hr = E_NOTIMPL;
			throw &exc;
		}  // if:  not a resource

		hr = HrGetObjectName(piGcoi);
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

	piGcoi->Release();
	if (hr != NOERROR)
		return hr;

	// Get an IGetClusterResourceInfo interface pointer.
	hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
	if (hr != NOERROR)
		return hr;

	m_rdResData.m_hresource = piGcri->GetResourceHandle(0);
	hr = HrGetResourceTypeName(piGcri);

	// See if we know about this resource type.
	if (hr == NOERROR)
	{
		LPCWSTR	pwszResTypeName;

		// Find the resource type name in our list.
		// Save the index for use in other arrays.
		for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
				; *pwszResTypeName != L'\0'
				; m_istrResTypeName++, pwszResTypeName += ::wcslen(pwszResTypeName) + 1
				)
		{
			if (RrdResData().m_strResTypeName.CompareNoCase(pwszResTypeName) == 0)
				break;
		}  // for:  each resource type in the list
		if (*pwszResTypeName == L'\0')
			hr = E_NOTIMPL;
	}  // See if we know about this resource type

	piGcoi->Release();
	return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetClusterName
//
//	Routine Description:
//		Get the name of the cluster.
//
//	Arguments:
//		piData			IGetClusterDataInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterName(
	IN OUT IGetClusterDataInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetClusterName(NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetClusterName(pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting cluster name

		m_strClusterName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetClusterName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectName
//
//	Routine Description:
//		Get the name of the object.
//
//	Arguments:
//		piData			IGetClusterObjectInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
	IN OUT IGetClusterObjectInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetObjectName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetObjectName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting object name

		m_rdResData.m_strName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetResourceTypeName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		piData			IGetClusterResourceInfo interface pointer for getting
//							the resource type name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
	IN OUT IGetClusterResourceInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetResourceTypeName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetResourceTypeName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting resource type name

		m_rdResData.m_strResTypeName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetResourceTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::BGetResourceNetworkName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		lpszNetName		[OUT] String in which to return the network name resource name.
//		pcchNetName		[IN OUT] Points to a variable that specifies the
//							maximum size, in characters, of the buffer.  This
//							value shold be large enough to contain
//							MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//							return it contains the actual number of characters
//							copied.
//
//	Return Value:
//		TRUE		Resource is dependent on a network name resource.
//		FALSE		Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BGetResourceNetworkName(
	OUT WCHAR *		lpszNetName,
	IN OUT DWORD *	pcchNetName
	)
{
	BOOL						bSuccess;
	IGetClusterResourceInfo *	piGcri;

	ASSERT(PiData() != NULL);

	// Get an IGetClusterResourceInfo interface pointer.
	{
		HRESULT		hr;

		hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
		if (hr != NOERROR)
		{
			SetLastError(hr);
			return FALSE;
		}  // if:  error getting the interface
	}  // Get an IGetClusterResourceInfo interface pointer

	// Get the resource network name.
	bSuccess = piGcri->GetResourceNetworkName(0, lpszNetName, pcchNetName);

	piGcri->Release();

	return bSuccess;

}  //*** CExtObject::BGetResourceNetworkName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\helpids.h ===
#define IDH_180_1082	70910132	// Parameters: "&WWW" (Button)
#define IDH_180_1084	71041204	// Parameters: "" (Edit)
#define IDH_180_1086	71172276	// Parameters: "" (Edit)
#define IDH_181_1087	71237813	// Parameters: "&Browse..." (Button)
#define IDH_180_1087	71237812	// Parameters: "&Browse..." (Button)
#define IDH_30721_100	6584321	// New: "" (ListBox)
#define IDH_180_1093	71631028	// Parameters: "Access" (Button)
#define IDH_30721_57670	3779491841	// New: "&Help" (Button)
#define IDH_180_1080	70779060	// Parameters: "&FTP" (Button)
#define IDH_180_1081	70844596	// Parameters: "&Gopher" (Button)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\regexts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExtS.cpp
//
//	Abstract:
//		Stub for implementation of extension registration classes.
//
//	Author:
//		David Potter (davidp)	May 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegExt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\iis.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Iis.cpp
//
//	Abstract:
//		Implementation of the CIISVirtualRootParamsPage class.
//
//	Author:
//		Pete Benoit (v-pbenoi)	October 16, 1996
//		David Potter (davidp)	October 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <inetinfo.h>
#include "IISClEx3.h"
#include "Iis.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIISVirtualRootParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CIISVirtualRootParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CIISVirtualRootParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CIISVirtualRootParamsPage)
	ON_BN_CLICKED(IDC_PP_IIS_FTP, OnChangeServiceType)
	ON_BN_CLICKED(IDC_PP_IIS_GOPHER, OnChangeServiceType)
	ON_BN_CLICKED(IDC_PP_IIS_WWW, OnChangeServiceType)
#ifdef _ACCOUNT_AND_PASSWORD
	ON_EN_CHANGE(IDC_PP_IIS_DIRECTORY, OnChangeDirectory)
#endif // _ACCOUNT_AND_PASSWORD
	ON_EN_CHANGE(IDC_PP_IIS_ALIAS, OnChangeRequiredField)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
#ifdef _ACCOUNT_AND_PASSWORD
	ON_EN_CHANGE(IDC_PP_IIS_ACCOUNTNAME, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_IIS_PASSWORD, CBasePropertyPage::OnChangeCtrl)
#endif /// _ACCOUNT_AND_PASSWORD
	ON_BN_CLICKED(IDC_PP_IIS_READ_ACCESS, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_IIS_WRITE_ACCESS, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::CIISVirtualRootParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIISVirtualRootParamsPage::CIISVirtualRootParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_IIS_PARAMETERS, g_aHelpIDs_IDD_WIZ_IIS_PARAMETERS)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CIISVirtualRootParamsPage)
	m_strDirectory = _T("");
	m_strAlias = _T("");
	m_bRead = FALSE;
	m_bWrite = FALSE;
	m_nServerType = -1;
#ifdef _ACCOUNT_AND_PASSWORD
	m_strAccountName = _T("");
	m_strPassword = _T("");
#endif // _ACCOUNT_AND_PASSWORD
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[epropServiceName].Set(REGPARAM_IIS_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
		m_rgProps[epropDirectory].Set(REGPARAM_IIS_DIRECTORY, m_strDirectory, m_strPrevDirectory);
		m_rgProps[epropAlias].Set(REGPARAM_IIS_ALIAS, m_strAlias, m_strPrevAlias);
#ifdef _ACCOUNT_AND_PASSWORD
		m_rgProps[epropAccoutName].Set(REGPARAM_IIS_ACCOUNTNAME, m_strAccountName, m_strPrevAccountName);
		m_rgProps[epropPassword].Set(REGPARAM_IIS_PASSWORD, m_strPassword, m_strPrevPassword);
#endif // _ACCOUNT_AND_PASSWORD
		m_rgProps[epropAccessMask].Set(REGPARAM_IIS_ACCESSMASK, m_dwAccessMask, m_dwPrevAccessMask);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_IIS_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_IIS_PARAMETERS;

}  //*** CIISVirtualRootParamsPage::CIISVirtualRootParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (!pDX->m_bSaveAndValidate)
	{
		// Set the service type.
		if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_FTP) == 0)
			m_nServerType = 0;
		else if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_GOPHER) == 0)
			m_nServerType = 1;
		else if (m_strServiceName.CompareNoCase(IIS_SVC_NAME_WWW) == 0)
			m_nServerType = 2;
		else
			m_nServerType = -1;

		// Set the access variables.
		if (m_dwAccessMask & VROOT_MASK_READ)
			m_bRead = TRUE;
		else
			m_bRead = FALSE;
		if (m_dwAccessMask & (VROOT_MASK_WRITE | VROOT_MASK_EXECUTE))
			m_bWrite = TRUE;
		else
			m_bWrite = FALSE;
	}  // if:  setting data to dialog

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CIISVirtualRootParamsPage)
	DDX_Control(pDX, IDC_PP_IIS_WRITE_ACCESS, m_ckbWrite);
	DDX_Control(pDX, IDC_PP_IIS_READ_ACCESS, m_ckbRead);
	DDX_Control(pDX, IDC_PP_IIS_ACCESS_GROUP, m_groupAccess);
#ifdef _ACCOUNT_AND_PASSWORD
	DDX_Control(pDX, IDC_PP_IIS_PASSWORD, m_editPassword);
	DDX_Control(pDX, IDC_PP_IIS_PASSWORD_LABEL, m_staticPassword);
	DDX_Control(pDX, IDC_PP_IIS_ACCOUNTNAME, m_editAccountName);
	DDX_Control(pDX, IDC_PP_IIS_ACCOUNTNAME_LABEL, m_staticAccountName);
	DDX_Control(pDX, IDC_PP_IIS_ACCT_INFO_GROUP, m_groupAccountInfo);
#endif // _ACCOUNT_AND_PASSWORD
	DDX_Control(pDX, IDC_PP_IIS_ALIAS, m_editAlias);
	DDX_Control(pDX, IDC_PP_IIS_DIRECTORY, m_editDirectory);
	DDX_Control(pDX, IDC_PP_IIS_WWW, m_rbWWW);
	DDX_Control(pDX, IDC_PP_IIS_GOPHER, m_rbGOPHER);
	DDX_Control(pDX, IDC_PP_IIS_FTP, m_rbFTP);
	DDX_Radio(pDX, IDC_PP_IIS_FTP, m_nServerType);
	DDX_Text(pDX, IDC_PP_IIS_DIRECTORY, m_strDirectory);
	DDX_Text(pDX, IDC_PP_IIS_ALIAS, m_strAlias);
#ifdef _ACCOUNT_AND_PASSWORD
	DDX_Text(pDX, IDC_PP_IIS_ACCOUNTNAME, m_strAccountName);
	DDX_Text(pDX, IDC_PP_IIS_PASSWORD, m_strPassword);
#endif // _ACCOUNT_AND_PASSWORD
	DDX_Check(pDX, IDC_PP_IIS_READ_ACCESS, m_bRead);
	DDX_Check(pDX, IDC_PP_IIS_WRITE_ACCESS, m_bWrite);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (!BBackPressed())
		{
			DDV_MaxChars(pDX, m_strDirectory, MAX_PATH);
			DDV_MaxChars(pDX, m_strAlias, MAX_PATH);
			DDV_RequiredText(pDX, IDC_PP_IIS_DIRECTORY, IDC_PP_IIS_DIRECTORY_LABEL, m_strDirectory);
			DDV_RequiredText(pDX, IDC_PP_IIS_ALIAS, IDC_PP_IIS_ALIAS_LABEL, m_strAlias);
		}  // if:  Back button not pressed

		// Save the type.
		if (m_nServerType == 0)
			m_strServiceName = IIS_SVC_NAME_FTP;
		else if (m_nServerType == 1)
			m_strServiceName = IIS_SVC_NAME_GOPHER;
		else if (m_nServerType == 2)
			m_strServiceName = IIS_SVC_NAME_WWW;
		else
		{
			CString		strMsg;
			strMsg.LoadString(IDS_INVALID_IIS_SERVICE_TYPE);
			AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
			strMsg.Empty();
			pDX->PrepareCtrl(IDC_PP_IIS_FTP);	// do this just to set the control for Fail().
			pDX->Fail();
		}  // else:  no service type set

		// Save the access mask values.
		m_dwAccessMask = 0;
		if (m_bRead)
			m_dwAccessMask |= VROOT_MASK_READ;
		if (m_bWrite)
		{
			if (m_nServerType == 2) // WWW
				m_dwAccessMask |= VROOT_MASK_EXECUTE;
			else if (m_nServerType == 0) // FTP
				m_dwAccessMask |= VROOT_MASK_WRITE;
		}  // if:  Write/Execute button pressed

		// If the alias isn't prefixed with a slash, supply it.
		if (m_strAlias[0] != _T('/'))
		{
			CString		strTempAlias;
			try
			{
				strTempAlias = _T('/') + m_strAlias;
				m_strAlias = strTempAlias;
			}  // try
			catch (CException * pe)
			{
				pe->ReportError();
				pe->Delete();
				strTempAlias.Empty();
				pDX->PrepareCtrl(IDC_PP_IIS_ALIAS);	// do this just to set the control for Fail().
				pDX->Fail();
			}  // catch:  CException
		}  // if:  alias not prefixed with slash
	}  // if:  saving data from dialog

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CIISVirtualRootParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISVirtualRootParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (BWizard())
	{
		try
		{
			m_strServiceName = IIS_SVC_NAME_WWW;
			m_dwAccessMask = VROOT_MASK_READ;
		}  // try
		catch (CMemoryException * pme)
		{
			pme->ReportError();
			pme->Delete();
		}  // catch:  CMemoryException
	}  // if:  creating a new resource

	CBasePropertyPage::OnInitDialog();

	// Set limits on the edit controls.
	m_editDirectory.SetLimitText(MAX_PATH);
	m_editAlias.SetLimitText(MAX_PATH);

#ifdef _ACCOUNT_AND_PASSWORD
	m_staticPassword.EnableWindow(FALSE);
	m_editPassword.EnableWindow(FALSE);
#endif // _ACCOUNT_AND_PASSWORD

	OnChangeServiceType();
#ifdef _ACCOUNT_AND_PASSWORD
	OnChangeDirectory();
#endif // _ACCOUNT_AND_PASSWORD

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CIISVirtualRootParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISVirtualRootParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if ((m_editDirectory.GetWindowTextLength() == 0)
				|| (m_editAlias.GetWindowTextLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in the wizard

	return CBasePropertyPage::OnSetActive();

}  //*** CIISVirtualRootParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeServiceType
//
//	Routine Description:
//		Handler for the BN_CLICKED message on one of the service type radio
//		buttons.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::OnChangeServiceType(void)
{
	int		nCmdShowAccess;
	IDS		idsWriteLabel	= 0;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (m_rbFTP.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_SHOW;
		idsWriteLabel = IDS_WRITE;
	}  // if:  FTP service
	else if (m_rbGOPHER.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_HIDE;
	}  // else if:  GOPHER service
	else if (m_rbWWW.GetCheck() == BST_CHECKED)
	{
		nCmdShowAccess = SW_SHOW;
		idsWriteLabel = IDS_EXECUTE;
	}  // else if:  WWW service
	else
	{
		nCmdShowAccess = SW_HIDE;
	}  // else:  unknown service

	// Set the access checkbox labels.
	if (idsWriteLabel != 0)
	{
		CString		strWriteLabel;

		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		strWriteLabel.LoadString(idsWriteLabel);
		m_ckbWrite.SetWindowText(strWriteLabel);
	}  // if:  write label needs to be set

	// Hide the Access group if this is for a GOPHER Virtual Root.
	m_groupAccess.ShowWindow(nCmdShowAccess);
	m_ckbRead.ShowWindow(nCmdShowAccess);
	m_ckbWrite.ShowWindow(nCmdShowAccess);

}  //*** CIISVirtualRootParamsPage::OnChangeServiceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeDirectory
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Directory edit control.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _ACCOUNT_AND_PASSWORD
void CIISVirtualRootParamsPage::OnChangeDirectory(void)
{
	BOOL		bEnable		= FALSE;
	CString		strDirectory;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	// If the edit control begins with a \\name\, enable the account info
	// group.  Otherwise disable it.
	m_editDirectory.GetWindowText(strDirectory);
	if ((strDirectory.GetLength() >= 4)
			&& (strDirectory[0] == _T('\\'))
			&& (strDirectory[1] == _T('\\'))
			&& (strDirectory[2] != _T('\\')))
	{
		CString		strRight;

		strRight = strDirectory.Right(strDirectory.GetLength() - 3);
		if (strRight.Find(_T('\\')) >= 0)
			bEnable = TRUE;
	}  // if:  directory begins with a double backslash + non-backslash

	// Enable or disable the account info group.
	m_groupAccountInfo.EnableWindow(bEnable);
	m_staticAccountName.EnableWindow(bEnable);
	m_editAccountName.EnableWindow(bEnable);
//	m_staticPassword.EnableWindow(bEnable);
//	m_editPassword.EnableWindow(bEnable);

	if (BWizard())
	{
		if ((m_strDirectory.GetLength() == 0)
				|| (m_editAlias.GetWindowTextLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in a wizard

}  //*** CIISVirtualRootParamsPage::OnChangeDirectory()
#endif // _ACCOUNT_AND_PASSWORD

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISVirtualRootParamsPage::OnChangeRequiredField
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIISVirtualRootParamsPage::OnChangeRequiredField(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if ((m_editDirectory.GetWindowTextLength() == 0)
				|| (m_editAlias.GetWindowTextLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in a wizard

}  //*** CIISVirtualRootParamsPage::OnChangeRequiredField()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\iis.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Iis.h
//
//	Abstract:
//		Definition of the CIISVirtualRootParamsPage class, which implements the
//		Parameters page for IIS resources.
//
//	Implementation File:
//		Iis.cpp
//
//	Author:
//		Pete Benoit (v-pbenoi)	October 16, 1996
//		David Potter (davidp)	October 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IIS_H_
#define _IIS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CIISVirtualRootParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define IIS_SVC_NAME_FTP _T("MSFTPSVC")
#define IIS_SVC_NAME_GOPHER _T("GOPHERSVC")
#define IIS_SVC_NAME_WWW _T("W3SVC")

/////////////////////////////////////////////////////////////////////////////
//
//	CIISVirtualRootParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CIISVirtualRootParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CIISVirtualRootParamsPage)

// Construction
public:
	CIISVirtualRootParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CIISVirtualRootParamsPage)
	enum { IDD = IDD_PP_IIS_PARAMETERS };
	CButton	m_ckbWrite;
	CButton	m_ckbRead;
	CButton	m_groupAccess;
#ifdef _ACCOUNT_AND_PASSWORD
	CEdit	m_editPassword;
	CStatic	m_staticPassword;
	CEdit	m_editAccountName;
	CStatic	m_staticAccountName;
	CButton	m_groupAccountInfo;
#endif // _ACCOUNT_AND_PASSWORD
	CEdit	m_editAlias;
	CEdit	m_editDirectory;
	CButton	m_rbWWW;
	CButton	m_rbGOPHER;
	CButton	m_rbFTP;
	int		m_nServerType;
	CString	m_strDirectory;
	CString	m_strAlias;
#ifdef _ACCOUNT_AND_PASSWORD
    CString	m_strAccountName;
	CString	m_strPassword;
#endif // _ACCOUNT_AND_PASSWORD
	BOOL	m_bRead;
	BOOL	m_bWrite;
	//}}AFX_DATA
	CString m_strServiceName;
	CString m_strPrevServiceName;
	CString	m_strPrevDirectory;
	CString	m_strPrevAlias;
#ifdef _ACCOUNT_AND_PASSWORD
    CString	m_strPrevAccountName;
	CString	m_strPrevPassword;
#endif // _ACCOUNT_AND_PASSWORD
    DWORD   m_dwAccessMask;
    DWORD   m_dwPrevAccessMask;

protected:
	enum
	{
		epropServiceName,
		epropAlias,
		epropDirectory,
#ifdef _ACCOUNT_AND_PASSWORD
		epropAccoutName,
		epropPassword,
#endif // _ACCOUNT_AND_PASSWORD
		epropAccessMask,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIISVirtualRootParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIISVirtualRootParamsPage)
	virtual BOOL OnInitDialog();
#ifdef _ACCOUNT_AND_PASSWORD
	afx_msg void OnChangeDirectory();
#endif // _ACCOUNT_AND_PASSWORD
	afx_msg void OnChangeRequiredField();
	afx_msg void OnChangeServiceType();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CIISVirtualRootParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _IIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\inetcom.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetcom.h

Abstract:

    This file contains contains global definitions for internet products.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

--*/

#ifndef _INETCOM_H_
#define _INETCOM_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <lmcons.h>              // for definitions of NET_API*


//
//  Server bitfield mask definitions
//
//  The services using the tsunami cache must be the lowest bits in the
//  bitfield.
//

#define INET_FTP                0x0001
#define INET_GOPHER             0x0002
#define INET_HTTP               0x0004
#define INET_DNS                0x0008
#define INET_HTTP_PROXY         0x0010
#define INET_MSN                0x0020
#define INET_NNTP               0x0040
#define INET_SMTP               0x0080
#define INET_GATEWAY            0x0100
#define INET_POP3               0x0200
#define INET_CHAT               0x0400
#define INET_LDAP               0x0800
#define INET_IMAP               0x1000


//
//  structure Field Control defines
//

typedef DWORD FIELD_CONTROL;
typedef DWORD FIELD_FLAG;

//
//  Returns TRUE if the field specified by bitFlag is set
//

#define IsFieldSet(fc, bitFlag) \
    (((FIELD_CONTROL)(fc) & (FIELD_FLAG)(bitFlag)) != 0)

//
//  Indicates the field specified by bitFlag contains a valid value
//

#define SetField(fc, bitFlag) \
    ((FIELD_CONTROL)(fc) |= (FIELD_FLAG)(bitFlag))

//
//  Simple macro that sets the ith bit
//

#define BitFlag(i)                    ((0x1) << (i))


//
//  Values for Logging related parameters should match with values in
//       internet\svcs\inc\inetlog.h
//

//
// Log Type
//

#define INET_LOG_INVALID              ((DWORD ) -1)
#define INET_LOG_DISABLED             0
#define INET_LOG_TO_FILE              1
#define INET_LOG_TO_SQL               2


// Log File Periods -- options identifying logging periods for InetaLogToFile
#define INET_LOG_PERIOD_NONE          0
#define INET_LOG_PERIOD_DAILY         1
#define INET_LOG_PERIOD_WEEKLY        2
#define INET_LOG_PERIOD_MONTHLY       3
#define INET_LOG_PERIOD_YEARLY        4


// Log Format
#define INET_LOG_FORMAT_INTERNET_STD  0
#define INET_LOG_FORMAT_NCSA          3


# define MAX_TABLE_NAME_LEN            ( 30) // Most DBs support only 30 bytes
# define MAX_USER_NAME_LEN             ( UNLEN + 1)
# define MAX_PASSWORD_LEN              ( PWLEN + 1)


typedef struct _INET_LOG_CONFIGURATION
{

    DWORD   inetLogType;    // type of log.

    // File specific logging. (valid if inetLogType == INET_LOG_TO_FILE)
    DWORD   ilPeriod;              // one of Log File Periods

    // Empty string means do not modify existing default
    WCHAR   rgchLogFileDirectory[MAX_PATH]; // dest for log files

    // Zero value means do not modify the existing default.
    DWORD   cbSizeForTruncation;   // max size for each log file.


    // Sql specific logging (valid if inetLogType == INET_LOG_TO_SQL)
    // Empty string means do not modify existing default

    // rgchDataSource last 4 bytes will be the ilFormat for the log format

    WCHAR   rgchDataSource[MAX_PATH];    // ODBC data source name
    WCHAR   rgchTableName[MAX_TABLE_NAME_LEN];    // table name on data source
    WCHAR   rgchUserName[MAX_USER_NAME_LEN];
                                         // name of user for ODBC connections
    WCHAR   rgchPassword[MAX_PASSWORD_LEN];     // password for ODBC connection

} INET_LOG_CONFIGURATION, * LPINET_LOG_CONFIGURATION;


//
// Field Control common for Gateway services
//

#define FC_INET_COM_CONNECTION_TIMEOUT    ((FIELD_CONTROL)BitFlag(0))
#define FC_INET_COM_MAX_CONNECTIONS       ((FIELD_CONTROL)BitFlag(1))
#define FC_INET_COM_LOG_CONFIG            ((FIELD_CONTROL)BitFlag(2))
#define FC_INET_COM_ADMIN_NAME            ((FIELD_CONTROL)BitFlag(3))
#define FC_INET_COM_SERVER_COMMENT        ((FIELD_CONTROL)BitFlag(4))
#define FC_INET_COM_ADMIN_EMAIL           ((FIELD_CONTROL)BitFlag(5))

#define FC_INET_COM_ALL \
                                     (  FC_INET_COM_CONNECTION_TIMEOUT |\
                                        FC_INET_COM_MAX_CONNECTIONS    |\
                                        FC_INET_COM_LOG_CONFIG         |\
                                        FC_INET_COM_ADMIN_NAME         |\
                                        FC_INET_COM_SERVER_COMMENT     |\
                                        FC_INET_COM_ADMIN_EMAIL         \
                                       )

//
// common config info.
//

typedef struct _INET_COM_CONFIG_INFO
{
    DWORD       dwConnectionTimeout;     // how long to hold connections
    DWORD       dwMaxConnections;        // max connections allowed

    LPWSTR      lpszAdminName;
    LPWSTR      lpszAdminEmail;
    LPWSTR      lpszServerComment;

    LPINET_LOG_CONFIGURATION  lpLogConfig;

    LANGID      LangId;                  // These are read only
    LCID        LocalId;
    BYTE        ProductId[64];

} INET_COM_CONFIG_INFO, *LPINET_COM_CONFIG_INFO;

typedef struct _INET_COMMON_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;
    INET_COM_CONFIG_INFO CommonConfigInfo;

} *LPINET_COMMON_CONFIG_INFO;

//
// Global statistics
//

typedef struct _INET_COM_CACHE_STATISTICS {

    //
    //  These are memory cache counters
    //

    DWORD         CacheBytesTotal;       // Only returned for global statistics
    DWORD         CacheBytesInUse;
    DWORD         CurrentOpenFileHandles;
    DWORD         CurrentDirLists;
    DWORD         CurrentObjects;
    DWORD         FlushesFromDirChanges;
    DWORD         CacheHits;
    DWORD         CacheMisses;

} INET_COM_CACHE_STATISTICS;

typedef struct _INET_COM_ATQ_STATISTICS {

    // Numbers related to Atq Blocking, Rejections of requests
    DWORD         TotalBlockedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         TotalAllowedRequests;
    DWORD         CurrentBlockedRequests;
    DWORD         MeasuredBandwidth;

} INET_COM_ATQ_STATISTICS;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// preserve back ward compatibility                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////
typedef INET_COM_CACHE_STATISTICS  INETA_CACHE_STATISTICS,
                               * LPINETA_CACHE_STATISTICS;

typedef INET_COM_ATQ_STATISTICS  INETA_ATQ_STATISTICS,
                               * LPINETA_ATQ_STATISTICS;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Stuff from Wininet.h, which is no longer included in the server     //
// files                                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// service types for InternetConnect() and dirlist
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3


#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _INETCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\inetinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetinfo.h

Abstract:

    This file contains the internet info server admin APIs.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995  Made a new copy for product split from inetasrv.h
    MuraliK     12-Oct-1995  Fixes to support product split
    MuraliK     15-Nov-1995  Support Wide Char interface names

--*/

#ifndef _INETINFO_H_
#define _INETINFO_H_

# include "inetcom.h"

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

/************************************************************
 *  Symbolic Constants
 ************************************************************/

//
//  The total number of instances of common services using the commong
//  service counters
//

#define MAX_PERF_CTR_SVCS              3
#define LAST_PERF_CTR_SVC              INET_HTTP

#ifndef NO_AUX_PERF

#ifndef MAX_AUX_PERF_COUNTERS
#define MAX_AUX_PERF_COUNTERS          (20)
#endif // MAX_AUX_PERF_COUNTERS

#endif // NO_AUX_PERF

//
//  Service name.
//

#define INET_INFO_SERVICE_NAME             TEXT("INETINFO")
#define INET_INFO_SERVICE_NAME_A           "INETINFO"
#define INET_INFO_SERVICE_NAME_W           L"INETINFO"

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            TEXT("System\\CurrentControlSet\\Services\\InetInfo")

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY TEXT("\\Parameters")

//
//  If this registry key exists under the W3Svc\Parameters key,
//  it is used to validate server access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the Server.
//

#define INET_INFO_ACCESS_KEY               TEXT("AccessCheck")


//
//  Authentication requirements values
//

#define INET_INFO_AUTH_ANONYMOUS           0x00000001
#define INET_INFO_AUTH_CLEARTEXT           0x00000002   // Includes HTTP Basic
#define INET_INFO_AUTH_NT_AUTH             0x00000004


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define INET_INFO_ANONYMOUS_SECRET         TEXT("INET_INFO_ANONYMOUS_DATA")
#define INET_INFO_ANONYMOUS_SECRET_A       "INET_INFO_ANONYMOUS_DATA"
#define INET_INFO_ANONYMOUS_SECRET_W       L"INET_INFO_ANONYMOUS_DATA"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Internet Server Common Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

# define  INET_INFO_INTERFACE_NAME     INET_INFO_SERVICE_NAME
# define  INET_INFO_NAMED_PIPE         TEXT("\\PIPE\\") ## INET_INFO_INTERFACE_NAME
# define  INET_INFO_NAMED_PIPE_W  L"\\PIPE\\" ## INET_INFO_SERVICE_NAME_W


//
//  Field control values for the INET_INFO_CONFIG_INFO structure
//

#define FC_INET_INFO_AUTHENTICATION        ((FIELD_CONTROL)BitFlag(16))
#define FC_INET_INFO_ALLOW_ANONYMOUS       ((FIELD_CONTROL)BitFlag(17))
#define FC_INET_INFO_LOG_ANONYMOUS         ((FIELD_CONTROL)BitFlag(18))
#define FC_INET_INFO_LOG_NONANONYMOUS      ((FIELD_CONTROL)BitFlag(19))
#define FC_INET_INFO_ANON_USER_NAME        ((FIELD_CONTROL)BitFlag(20))
#define FC_INET_INFO_ANON_PASSWORD         ((FIELD_CONTROL)BitFlag(21))
#define FC_INET_INFO_PORT_NUMBER           ((FIELD_CONTROL)BitFlag(22))
#define FC_INET_INFO_SITE_SECURITY         ((FIELD_CONTROL)BitFlag(23))
#define FC_INET_INFO_VIRTUAL_ROOTS         ((FIELD_CONTROL)BitFlag(24))

// common parameters for publishing servers only
# define FC_INET_INFO_PUBLISHING_SVCS_ALL  (FC_INET_INFO_AUTHENTICATION     | \
                                        FC_INET_INFO_ALLOW_ANONYMOUS    | \
                                        FC_INET_INFO_LOG_ANONYMOUS      | \
                                        FC_INET_INFO_LOG_NONANONYMOUS   | \
                                        FC_INET_INFO_ANON_USER_NAME     | \
                                        FC_INET_INFO_ANON_PASSWORD      | \
                                        FC_INET_INFO_PORT_NUMBER        | \
                                        FC_INET_INFO_SITE_SECURITY      | \
                                        FC_INET_INFO_VIRTUAL_ROOTS        \
                                        )

#define FC_INET_INFO_ALL \
    (FC_INET_INFO_PUBLISHING_SVCS_ALL| \
    FC_INET_COM_ALL)

//
//  Virtual root access mask values
//

#define VROOT_MASK_READ                0x00000001
#define VROOT_MASK_WRITE               0x00000002
#define VROOT_MASK_EXECUTE             0x00000004
#define VROOT_MASK_SSL                 0x00000008
#define VROOT_MASK_DONT_CACHE          0x00000010

#define VROOT_MASK_MASK                0x0000001f


//
//  INet admin API structures
//

typedef struct _INET_INFO_IP_SEC_ENTRY
{
    DWORD       dwMask;                  // Mask and network number in
    DWORD       dwNetwork;               // network order

} INET_INFO_IP_SEC_ENTRY, *LPINET_INFO_IP_SEC_ENTRY;

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

typedef struct _INET_INFO_IP_SEC_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_IP_SEC_ENTRY  aIPSecEntry[];

} INET_INFO_IP_SEC_LIST, *LPINET_INFO_IP_SEC_LIST;

typedef struct _INET_INFO_VIRTUAL_ROOT_ENTRY
{
    LPWSTR  pszRoot;                  // Virtual root name
    LPWSTR  pszAddress;               // Optional IP address
    LPWSTR  pszDirectory;             // Physical direcotry
    DWORD   dwMask;                   // Mask for this virtual root
    LPWSTR  pszAccountName;           // Account to connect as
    WCHAR   AccountPassword[PWLEN+1]; // Password for pszAccountName
    DWORD   dwError;                  // Error code if entry wasn't added
                                      // only used for gets

} INET_INFO_VIRTUAL_ROOT_ENTRY, *LPINET_INFO_VIRTUAL_ROOT_ENTRY;


typedef struct _INET_INFO_VIRTUAL_ROOT_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_VIRTUAL_ROOT_ENTRY  aVirtRootEntry[];

} INET_INFO_VIRTUAL_ROOT_LIST, *LPINET_INFO_VIRTUAL_ROOT_LIST;

//
//  Admin configuration information
//

typedef struct _INET_INFO_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    //
    // don't add any service specific config parameter here.
    //

    INET_COM_CONFIG_INFO CommonConfigInfo;

    BOOL        fLogAnonymous;           // Log Anonymous users?
    BOOL        fLogNonAnonymous;        // Log Non anonymous users?

    LPWSTR      lpszAnonUserName;        // Anonymous user name?
    WCHAR       szAnonPassword[PWLEN+1]; // Password for the anonymous user

    DWORD       dwAuthentication;        // What authentication is enabled?

    short       sPort;                   // Port Number for service

    LPINET_INFO_IP_SEC_LIST DenyIPList;      // Site security deny list
    LPINET_INFO_IP_SEC_LIST GrantIPList;     // Site security grant list

    LPINET_INFO_VIRTUAL_ROOT_LIST VirtualRoots; // Symlinks to other data dirs

    //
    // add more service specific parameters here.
    //

} INET_INFO_CONFIG_INFO, * LPINET_INFO_CONFIG_INFO;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Global Internet Server Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define FC_GINET_INFO_BANDWIDTH_LEVEL      ((FIELD_CONTROL)BitFlag(0))
#define FC_GINET_INFO_MEMORY_CACHE_SIZE    ((FIELD_CONTROL)BitFlag(1))


#define FC_GINET_INFO_ALL \
                (   FC_GINET_INFO_BANDWIDTH_LEVEL      | \
                    FC_GINET_INFO_MEMORY_CACHE_SIZE    | \
                    0                                \
                    )

typedef struct _INET_INFO_GLOBAL_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         BandwidthLevel;          // Bandwidth Level used.
    DWORD         cbMemoryCacheSize;

} INET_INFO_GLOBAL_CONFIG_INFO, * LPINET_INFO_GLOBAL_CONFIG_INFO;

//
// Global statistics
//

typedef struct _INET_INFO_STATISTICS_0
{

    INET_COM_CACHE_STATISTICS  CacheCtrs;
    INET_COM_ATQ_STATISTICS    AtqCtrs;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} INET_INFO_STATISTICS_0, * LPINET_INFO_STATISTICS_0;

//
// Capabilities Flags
//

typedef struct _INET_INFO_CAP_FLAGS {

    DWORD   Flag;   // Which capabilities are enabled
    DWORD   Mask;   // Which capabilities are supported

} INET_INFO_CAP_FLAGS, * LPINET_INFO_CAP_FLAGS;

//
// Inet info server capabilities
//

typedef struct _INET_INFO_CAPABILITIES {

    DWORD   CapVersion;     // Version number of this structure
    DWORD   ProductType;    // Product type
    DWORD   MajorVersion;   // Major version number
    DWORD   MinorVersion;   // Minor Version number
    DWORD   BuildNumber;    // Build number
    DWORD   NumCapFlags;    // Number of capabilities structures

    LPINET_INFO_CAP_FLAGS    CapFlags;

} INET_INFO_CAPABILITIES, * LPINET_INFO_CAPABILITIES;

//
// Product type
//

#define INET_INFO_PRODUCT_NTSERVER          0x00000001
#define INET_INFO_PRODUCT_NTWKSTA           0x00000002
#define INET_INFO_PRODUCT_WINDOWS95         0x00000003
#define INET_INFO_PRODUCT_UNKNOWN           0xffffffff

//
// Settable server capabilities
//

#define IIS_CAP1_ODBC_LOGGING               0x00000001
#define IIS_CAP1_FILE_LOGGING               0x00000002
#define IIS_CAP1_VIRTUAL_SERVER             0x00000004
#define IIS_CAP1_BW_THROTTLING              0x00000008
#define IIS_CAP1_IP_ACCESS_CHECK            0x00000010
#define IIS_CAP1_MAX_CONNECTIONS            0x00000020

#define IIS_CAP1_ALL  ( IIS_CAP1_ODBC_LOGGING       |   \
                        IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_VIRTUAL_SERVER     |   \
                        IIS_CAP1_BW_THROTTLING      |   \
                        IIS_CAP1_IP_ACCESS_CHECK    |   \
                        IIS_CAP1_MAX_CONNECTIONS        \
                        )

//
//  INet admin API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetServerCapabilities(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES * ppCap
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_INFO_GLOBAL_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_INFO_GLOBAL_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_INFO_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  HTTP (w3) specific items                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

#define W3_SERVICE_NAME                TEXT("W3SVC")
#define W3_SERVICE_NAME_A              "W3SVC"
#define W3_SERVICE_NAME_W              L"W3SVC"

# define  W3_INTERFACE_NAME     W3_SERVICE_NAME
# define  W3_NAMED_PIPE         TEXT("\\PIPE\\") ## W3_INTERFACE_NAME
# define  W3_NAMED_PIPE_W       L"\\PIPE\\" ## W3_SERVICE_NAME_W


//
//  Manifests for APIs
//

#define FC_W3_DIR_BROWSE_CONTROL       ((FIELD_CONTROL)BitFlag(0))
#define FC_W3_DEFAULT_LOAD_FILE        ((FIELD_CONTROL)BitFlag(1))
#define FC_W3_CHECK_FOR_WAISDB         ((FIELD_CONTROL)BitFlag(2))
#define FC_W3_DIRECTORY_IMAGE          ((FIELD_CONTROL)BitFlag(3))
#define FC_W3_SERVER_AS_PROXY          ((FIELD_CONTROL)BitFlag(4))
#define FC_W3_CATAPULT_USER_AND_PWD    ((FIELD_CONTROL)BitFlag(5))
#define FC_W3_SSI_ENABLED              ((FIELD_CONTROL)BitFlag(6))
#define FC_W3_SSI_EXTENSION            ((FIELD_CONTROL)BitFlag(7))
#define FC_W3_GLOBAL_EXPIRE            ((FIELD_CONTROL)BitFlag(8))
#define FC_W3_SCRIPT_MAPPING           ((FIELD_CONTROL)BitFlag(9))



#define FC_W3_ALL                      (FC_W3_DIR_BROWSE_CONTROL | \
                                        FC_W3_DEFAULT_LOAD_FILE  | \
                                        FC_W3_CHECK_FOR_WAISDB   | \
                                        FC_W3_DIRECTORY_IMAGE    | \
                                        FC_W3_SERVER_AS_PROXY    | \
                                        FC_W3_CATAPULT_USER_AND_PWD |\
                                        FC_W3_SSI_ENABLED        | \
                                        FC_W3_SSI_EXTENSION      | \
                                        FC_W3_GLOBAL_EXPIRE      | \
                                        FC_W3_SCRIPT_MAPPING)

//
//  HTTP Directory browsing flags
//

#define DIRBROW_SHOW_ICON           0x00000001
#define DIRBROW_SHOW_DATE           0x00000002
#define DIRBROW_SHOW_TIME           0x00000004
#define DIRBROW_SHOW_SIZE           0x00000008
#define DIRBROW_SHOW_EXTENSION      0x00000010
#define DIRBROW_LONG_DATE           0x00000020

#define DIRBROW_ENABLED             0x80000000
#define DIRBROW_LOADDEFAULT         0x40000000

#define DIRBROW_MASK               (DIRBROW_SHOW_ICON      |    \
                                    DIRBROW_SHOW_DATE      |    \
                                    DIRBROW_SHOW_TIME      |    \
                                    DIRBROW_SHOW_SIZE      |    \
                                    DIRBROW_SHOW_EXTENSION |    \
                                    DIRBROW_LONG_DATE      |    \
                                    DIRBROW_LOADDEFAULT    |    \
                                    DIRBROW_ENABLED)

//
//  Setting the csecGlobalExpire field to this value will prevent the server
//  from generating an "Expires:" header.
//

#define NO_GLOBAL_EXPIRE           0xffffffff

//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | \
                                    ENC_CAPS_PCT)

#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

//
//  Structures for APIs
//

typedef struct _W3_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} W3_USER_INFO, * LPW3_USER_INFO;

typedef struct _W3_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;

    DWORD         TotalGets;
    DWORD         TotalPosts;
    DWORD         TotalHeads;
    DWORD         TotalOthers;      // Other HTTP verbs
    DWORD         TotalCGIRequests;
    DWORD         TotalBGIRequests;
    DWORD         TotalNotFoundErrors;

    DWORD         CurrentCGIRequests;
    DWORD         CurrentBGIRequests;
    DWORD         MaxCGIRequests;
    DWORD         MaxBGIRequests;

    DWORD         TimeOfLastClear;


# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF


} W3_STATISTICS_0, * LPW3_STATISTICS_0;

typedef struct _W3_SCRIPT_MAP_ENTRY
{
    LPWSTR lpszExtension;
    LPWSTR lpszImage;
} W3_SCRIPT_MAP_ENTRY, *LPW3_SCRIPT_MAP_ENTRY;

typedef struct _W3_SCRIPT_MAP_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    W3_SCRIPT_MAP_ENTRY  aScriptMap[];

} W3_SCRIPT_MAP_LIST, *LPW3_SCRIPT_MAP_LIST;

typedef struct _W3_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         dwDirBrowseControl;       // Directory listing and def. load
    LPWSTR        lpszDefaultLoadFile;      // File to load if feature is on
    BOOL          fCheckForWAISDB;          // Call waislookup if .dct found?
    LPWSTR        lpszDirectoryImage;       // Image for directory in file list
    BOOL          fServerAsProxy;           // Run server as a proxy if TRUE
    LPWSTR        lpszCatapultUser;         // The user/password to impersonate
    WCHAR         szCatapultUserPwd[PWLEN+1]; // if the proxy server is using
                                            // the catapult server

    BOOL          fSSIEnabled;              // Are server side includes enabled?
    LPWSTR        lpszSSIExtension;         // Extension for server side inc.

    DWORD         csecGlobalExpire;         // Value to set Expires: header to

    LPW3_SCRIPT_MAP_LIST ScriptMap;         // List of extension mappings

    DWORD         dwEncCaps;                // Encryption capabilities

} W3_CONFIG_INFO, *LPW3_CONFIG_INFO;

//
// API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
W3GetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPW3_CONFIG_INFO *    ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
W3SetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPW3_CONFIG_INFO    pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
W3EnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPW3_USER_INFO * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3DisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  FTP specific items                                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////
//
//  Service name.
//

//#define FTPD_SERVICE_NAME               TEXT("MSFTPSVC")
//#define FTPD_SERVICE_NAME_A              "MSFTPSVC"
//#define FTPD_SERVICE_NAME_W             L"MSFTPSVC"


//
//   Client Interface Name for RPC connections over named pipes
//

# define  FTP_INTERFACE_NAME     FTPD_SERVICE_NAME
# define  FTP_NAMED_PIPE         TEXT("\\PIPE\\") ## FTP_INTERFACE_NAME
# define  FTP_NAMED_PIPE_W       L"\\PIPE\\" ## FTPD_SERVICE_NAME_W


//
//  Manifests for APIs.
//

#define FC_FTP_ALLOW_ANONYMOUS          ((FIELD_CONTROL)BitFlag( 0))
#define FC_FTP_ALLOW_GUEST_ACCESS       ((FIELD_CONTROL)BitFlag( 1))
#define FC_FTP_ANNOTATE_DIRECTORIES     ((FIELD_CONTROL)BitFlag( 2))
#define FC_FTP_ANONYMOUS_ONLY           ((FIELD_CONTROL)BitFlag( 3))
#define FC_FTP_EXIT_MESSAGE             ((FIELD_CONTROL)BitFlag( 4))
#define FC_FTP_GREETING_MESSAGE         ((FIELD_CONTROL)BitFlag( 5))
#define FC_FTP_HOME_DIRECTORY           ((FIELD_CONTROL)BitFlag( 6))
#define FC_FTP_LISTEN_BACKLOG           ((FIELD_CONTROL)BitFlag( 7))
#define FC_FTP_LOWERCASE_FILES          ((FIELD_CONTROL)BitFlag( 8))
#define FC_FTP_MAX_CLIENTS_MESSAGE      ((FIELD_CONTROL)BitFlag( 9))
#define FC_FTP_MSDOS_DIR_OUTPUT         ((FIELD_CONTROL)BitFlag(10))

#define FC_FTP_READ_ACCESS_MASK         ((FIELD_CONTROL)BitFlag(11))
#define FC_FTP_WRITE_ACCESS_MASK        ((FIELD_CONTROL)BitFlag(12))

#define FC_FTP_ALL                      (                                 \
                                          FC_FTP_ALLOW_ANONYMOUS        | \
                                          FC_FTP_ALLOW_GUEST_ACCESS     | \
                                          FC_FTP_ANNOTATE_DIRECTORIES   | \
                                          FC_FTP_ANONYMOUS_ONLY         | \
                                          FC_FTP_EXIT_MESSAGE           | \
                                          FC_FTP_GREETING_MESSAGE       | \
                                          FC_FTP_HOME_DIRECTORY         | \
                                          FC_FTP_LISTEN_BACKLOG         | \
                                          FC_FTP_LOWERCASE_FILES        | \
                                          FC_FTP_MAX_CLIENTS_MESSAGE    | \
                                          FC_FTP_MSDOS_DIR_OUTPUT       | \
                                          FC_FTP_READ_ACCESS_MASK       | \
                                          FC_FTP_WRITE_ACCESS_MASK      | \
                                          0 )


//
//  Structures for APIs.
//

typedef struct _FTP_CONFIG_INFO
{
    FIELD_CONTROL   FieldControl;

    BOOL            fAllowAnonymous;
    BOOL            fAllowGuestAccess;
    BOOL            fAnnotateDirectories;
    BOOL            fAnonymousOnly;
    LPWSTR          lpszExitMessage;
    LPWSTR          lpszGreetingMessage;
    LPWSTR          lpszHomeDirectory;
    DWORD           dwListenBacklog;
    BOOL            fLowercaseFiles;
    LPWSTR          lpszMaxClientsMessage;
    BOOL            fMsdosDirOutput;

} FTP_CONFIG_INFO, * LPFTP_CONFIG_INFO;


//
//  API Prototypes.
//

NET_API_STATUS
NET_API_FUNCTION
FtpGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPFTP_CONFIG_INFO *   ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
FtpSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPFTP_CONFIG_INFO   pConfig
    );


# include <ftpd.h>

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Gopher specific items                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
//  Service name.
//

# define GOPHERD_SERVICE_NAME           TEXT("GopherSvc")
# define GOPHERD_SERVICE_NAME_A         "GopherSvc"
# define GOPHERD_SERVICE_NAME_W         L"GopherSvc"

//
//   Client Interface Name for RPC connections over named pipes
//
# define  GOPHERD_INTERFACE_NAME     GOPHERD_SERVICE_NAME
# define  GOPHERD_NAMED_PIPE         TEXT("\\PIPE\\") ## GOPHERD_INTERFACE_NAME
# define  GOPHERD_NAMED_PIPE_W       L"\\PIPE\\" ## GOPHERD_SERVICE_NAME_W


/************************************************************
 *   Symbolic Constants
 *   Prefix GDA_  stands for Gopher Daemon Admin
 ************************************************************/

# define   GDA_SITE                   ((FIELD_CONTROL ) BitFlag( 1)) // SZ
# define   GDA_ORGANIZATION           ((FIELD_CONTROL ) BitFlag( 2)) // SZ
# define   GDA_LOCATION               ((FIELD_CONTROL ) BitFlag( 3)) // SZ
# define   GDA_GEOGRAPHY              ((FIELD_CONTROL ) BitFlag( 4)) // SZ
# define   GDA_LANGUAGE               ((FIELD_CONTROL ) BitFlag( 5)) // SZ
# define   GDA_CHECK_FOR_WAISDB       ((FIELD_CONTROL ) BitFlag( 8)) // BOOL

# define   GDA_DEBUG_FLAGS            ((FIELD_CONTROL ) BitFlag( 30)) // DWORD

# define   GDA_ALL_CONFIG_INFO        ( GDA_SITE         | \
                                        GDA_ORGANIZATION | \
                                        GDA_LOCATION     | \
                                        GDA_GEOGRAPHY    | \
                                        GDA_LANGUAGE     | \
                                        GDA_CHECK_FOR_WAISDB | \
                                        GDA_DEBUG_FLAGS    \
                                       )

# define   GOPHERD_ANONYMOUS_SECRET_W       L"GOPHERD_ANONYMOUS_DATA"
# define   GOPHERD_ROOT_SECRET_W            L"GOPHERD_ROOT_DATA"


//
// Configuration information is the config data that is communicated
//  b/w the server and admin UI
//
typedef struct  _GOPHERD_CONFIG_INFO {

    FIELD_CONTROL  FieldControl;        // bit mask indicating fields set.

    LPWSTR      lpszSite;               // Name of Gopher site
    LPWSTR      lpszOrganization;       // Organization Name
    LPWSTR      lpszLocation;           // Location of server
    LPWSTR      lpszGeography;          // Geographical data
    LPWSTR      lpszLanguage;           // Language for server

    BOOL        fCheckForWaisDb;        // Check & allow Wais Db

    //  Debugging data
    DWORD       dwDebugFlags;           // Bitmap of debugging data

} GOPHERD_CONFIG_INFO, * LPGOPHERD_CONFIG_INFO;


typedef struct _GOPHERD_STATISTICS_INFO {

    LARGE_INTEGER   TotalBytesSent;
    LARGE_INTEGER   TotalBytesRecvd;

    DWORD           TotalFilesSent;
    DWORD           TotalDirectoryListings;
    DWORD           TotalSearches;

    DWORD           CurrentAnonymousUsers;
    DWORD           CurrentNonAnonymousUsers;
    DWORD           MaxAnonymousUsers;
    DWORD           MaxNonAnonymousUsers;
    DWORD           TotalAnonymousUsers;
    DWORD           TotalNonAnonymousUsers;

    DWORD           TotalConnections;
    DWORD           MaxConnections;
    DWORD           CurrentConnections;

    DWORD           ConnectionAttempts;     // raw connections made
    DWORD           LogonAttempts;          // total logons attempted
    DWORD           AbortedAttempts;        // Aborted connections
    DWORD           ErroredConnections;     // # in Error when processed

    DWORD           GopherPlusRequests;

    DWORD           TimeOfLastClear;
} GOPHERD_STATISTICS_INFO,  * LPGOPHERD_STATISTICS_INFO;


//
//   GOPHERD_USER_INFO  contains details about connected users.
//   This structure may undergo modification. Currently UserInformation
//    is not supported.
//

typedef struct _GOPHERD_USER_INFO  {

    DWORD   dwIdUser;               // Id for user
    LPWSTR  lpszUserName;           // User name
    BOOL    fAnonymous;             // TRUE if user logged on as anonymous
                                    //  FALSE otherwise
    DWORD   dwInetHost;             // host address for client

    //
    //  Other details if required
    //
} GOPHERD_USER_INFO, * LPGOPHERD_USER_INFO;



/************************************************************
 * Gopher Server RPC APIs
 ************************************************************/


//
//  Server Administrative Information
//

DWORD
NET_API_FUNCTION
GdGetAdminInformation(
    IN      LPWSTR                  pszServer  OPTIONAL,
    OUT     LPGOPHERD_CONFIG_INFO * ppConfigInfo
    );

DWORD
NET_API_FUNCTION
GdSetAdminInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPGOPHERD_CONFIG_INFO   pConfigInfo
    );



//
//  API for Users enumeration  ( Not Yet Supported).
//

DWORD
NET_API_FUNCTION
GdEnumerateUsers(
    IN      LPWSTR      pszServer OPTIONAL,
    OUT     LPDWORD     lpnEntriesRead,
    OUT     LPGOPHERD_USER_INFO * lpUserBuffer
    );

DWORD
NET_API_FUNCTION
GdDisconnectUser(
    IN      LPWSTR      pszServer  OPTIONAL,
    IN      DWORD       dwIdUser
    );


//
// Statistics API
//

DWORD
NET_API_FUNCTION
GdGetStatistics(
    IN      LPWSTR      pszServer  OPTIONAL,
    OUT     LPBYTE      lpStatBuffer        // pass LPGOPHERD_STATISTICS_INFO
    );


DWORD
NET_API_FUNCTION
GdClearStatistics(
    IN      LPWSTR      pszServer  OPTIONAL
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  NNTP specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define NNTP_SERVICE_NAME        TEXT("NNTPSVC")
# define NNTP_SERVICE_NAME_A      "NNTPSVC"
# define NNTP_SERVICE_NAME_W      L"NNTPSVC"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  NNTP_INTERFACE_NAME     NNTP_SERVICE_NAME
# define  NNTP_NAMED_PIPE         TEXT("\\PIPE\\") ## NNTP_INTERFACE_NAME
# define  NNTP_NAMED_PIPE_W       L"\\PIPE\\" ## NNTP_SERVICE_NAME_W


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  SMTP specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define SMTP_SERVICE_NAME        TEXT("SMTPSVC")
# define SMTP_SERVICE_NAME_A      "SMTPSVC"
# define SMTP_SERVICE_NAME_W      L"SMTPSVC"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  SMTP_INTERFACE_NAME     SMTP_SERVICE_NAME
# define  SMTP_NAMED_PIPE         TEXT("\\PIPE\\") ## SMTP_INTERFACE_NAME
# define  SMTP_NAMED_PIPE_W       L"\\PIPE\\" ## SMTP_SERVICE_NAME_W


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  POP3 specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define POP3_SERVICE_NAME        TEXT("POP3SVC")
# define POP3_SERVICE_NAME_A      "POP3SVC"
# define POP3_SERVICE_NAME_W      L"POP3SVC"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  POP3_INTERFACE_NAME     POP3_SERVICE_NAME
# define  POP3_NAMED_PIPE         TEXT("\\PIPE\\") ## POP3_INTERFACE_NAME
# define  POP3_NAMED_PIPE_W       L"\\PIPE\\" ## POP3_SERVICE_NAME_W


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Catapult specific items                            //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

# define INET_GATEWAY_INTERFACE_NAME    TEXT("gateway")


// preserve back ward compatibility
typedef INET_INFO_CONFIG_INFO    INETA_CONFIG_INFO,
                               * LPINETA_CONFIG_INFO;
typedef INET_INFO_IP_SEC_ENTRY   INETA_IP_SEC_ENTRY,
                               * LPINETA_IP_SEC_ENTRY;
typedef INET_INFO_IP_SEC_LIST    INETA_IP_SEC_LIST,
                               * LPINETA_IP_SEC_LIST;
typedef INET_INFO_VIRTUAL_ROOT_ENTRY  INETA_VIRTUAL_ROOT_ENTRY,
                               * LPINETA_VIRTUAL_ROOT_ENTRY;
typedef INET_INFO_VIRTUAL_ROOT_LIST  INETA_VIRTUAL_ROOT_LIST,
                               * LPINETA_VIRTUAL_ROOT_LIST;

typedef INET_INFO_GLOBAL_CONFIG_INFO   INETA_GLOBAL_CONFIG_INFO,
                               * LPINETA_GLOBAL_CONFIG_INFO;

typedef   INET_INFO_STATISTICS_0    INETA_STATISTICS_0,
                               * LPINETA_STATISTICS_0;

# define INETA_PARAMETERS_KEY    (INET_INFO_PARAMETERS_KEY)



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  CHAT specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define CHAT_SERVICE_NAME           TEXT("ChatSvc")
# define CHAT_SERVICE_NAME_A         "ChatSvc"
# define CHAT_SERVICE_NAME_W         L"ChatSvc"

//
//   Client Interface Name for RPC connections over named pipes
//
# define  CHAT_INTERFACE_NAME     CHAT_SERVICE_NAME
# define  CHAT_NAMED_PIPE         TEXT("\\PIPE\\") ## CHAT_INTERFACE_NAME
# define  CHAT_NAMED_PIPE_W       L"\\PIPE\\" ## CHAT_SERVICE_NAME_W



//
//  Manifests for APIs.
//

#define FC_CHAT_ALLOW_ANONYMOUS          ((FIELD_CONTROL)BitFlag( 0))
#define FC_CHAT_ALLOW_GUEST_ACCESS       ((FIELD_CONTROL)BitFlag( 1))
#define FC_CHAT_ANNOTATE_DIRECTORIES     ((FIELD_CONTROL)BitFlag( 2))
#define FC_CHAT_ANONYMOUS_ONLY           ((FIELD_CONTROL)BitFlag( 3))
#define FC_CHAT_EXIT_MESSAGE             ((FIELD_CONTROL)BitFlag( 4))
#define FC_CHAT_GREETING_MESSAGE         ((FIELD_CONTROL)BitFlag( 5))
#define FC_CHAT_HOME_DIRECTORY           ((FIELD_CONTROL)BitFlag( 6))
#define FC_CHAT_LISTEN_BACKLOG           ((FIELD_CONTROL)BitFlag( 7))
#define FC_CHAT_LOWERCASE_FILES          ((FIELD_CONTROL)BitFlag( 8))
#define FC_CHAT_MAX_CLIENTS_MESSAGE      ((FIELD_CONTROL)BitFlag( 9))
#define FC_CHAT_MSDOS_DIR_OUTPUT         ((FIELD_CONTROL)BitFlag(10))

#define FC_CHAT_READ_ACCESS_MASK         ((FIELD_CONTROL)BitFlag(11))
#define FC_CHAT_WRITE_ACCESS_MASK        ((FIELD_CONTROL)BitFlag(12))

#define FC_CHAT_ALL                      (                                 \
                                          FC_CHAT_ALLOW_ANONYMOUS        | \
                                          FC_CHAT_ALLOW_GUEST_ACCESS     | \
                                          FC_CHAT_ANNOTATE_DIRECTORIES   | \
                                          FC_CHAT_ANONYMOUS_ONLY         | \
                                          FC_CHAT_EXIT_MESSAGE           | \
                                          FC_CHAT_GREETING_MESSAGE       | \
                                          FC_CHAT_HOME_DIRECTORY         | \
                                          FC_CHAT_LISTEN_BACKLOG         | \
                                          FC_CHAT_LOWERCASE_FILES        | \
                                          FC_CHAT_MAX_CLIENTS_MESSAGE    | \
                                          FC_CHAT_MSDOS_DIR_OUTPUT       | \
                                          FC_CHAT_READ_ACCESS_MASK       | \
                                          FC_CHAT_WRITE_ACCESS_MASK      | \
                                          0 )


//
//  Structures for APIs.
//

typedef struct _CHAT_CONFIG_INFO
{
    FIELD_CONTROL   FieldControl;

    BOOL            fAllowAnonymous;
    BOOL            fAllowGuestAccess;
    BOOL            fAnnotateDirectories;
    BOOL            fAnonymousOnly;
    LPWSTR          lpszExitMessage;
    LPWSTR          lpszGreetingMessage;
    LPWSTR          lpszHomeDirectory;
    DWORD           dwListenBacklog;
    BOOL            fLowercaseFiles;
    LPWSTR          lpszMaxClientsMessage;
    BOOL            fMsdosDirOutput;

} CHAT_CONFIG_INFO, * LPCHAT_CONFIG_INFO;


//
//  API Prototypes.
//

NET_API_STATUS
NET_API_FUNCTION
ChatGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPCHAT_CONFIG_INFO *   ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
ChatSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPCHAT_CONFIG_INFO   pConfig
    );


# include <chat.h>


#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _INETINFO_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\iisclex3.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-2000 Microsoft Corporation
//
//	Module Name:
//		IISClEx3.cpp
//
//	Abstract:
//		Implementation of the CIISCluExApp class and DLL initialization
//		routines.
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "IISClEx3.h"
#include "ExtObj.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoIISClEx3, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
STDAPI DllCanUnloadNow(void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CIISCluExApp
/////////////////////////////////////////////////////////////////////////////

class CIISCluExApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CIISCluExApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISCluExApp::InitInstance
//
//	Routine Description:
//		Initialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Application initialized successfully.
//		FALSE		Error initializing application.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIISCluExApp::InitInstance(void)
{
	_Module.Init(ObjectMap, m_hInstance);

	// Construct the help path.
	// This is only necessary if the name of the help file is different
	// than the name of this DLL.  Remove this code if the name of the
	// help file becomes the same as the name of the DLL.
	{
		TCHAR szPath[_MAX_PATH];
		TCHAR szDrive[_MAX_PATH];
		TCHAR szDir[_MAX_DIR];
		int cchPath;
		VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
		cchPath = lstrlen(szPath);
		if (szPath[cchPath - 1] != _T('\\'))
		{
			szPath[cchPath++] = _T('\\');
			szPath[cchPath] = _T('\0');
		} // if: no backslash on the end of the path
		lstrcpy(&szPath[cchPath], _T("Help\\"));
		_tsplitpath(szPath, szDrive, szDir, NULL, NULL);
		_tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
		free((void *) m_pszHelpFilePath);
		BOOL bEnable;
		bEnable = AfxEnableMemoryTracking(FALSE);
		m_pszHelpFilePath = _tcsdup(szPath);
		AfxEnableMemoryTracking(bEnable);
	}  // Construct the help path

	return CWinApp::InitInstance();

}  //*** CIISCluExApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CIISCluExApp::ExitInstance
//
//	Routine Description:
//		Cleans up this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Application's exit code.  0 indicates no errors.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CIISCluExApp::ExitInstance(void)
{
	_Module.Term();
	return CWinApp::ExitInstance();

}  //*** CIISCluExApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(FALSE /*bRegTypeLib*/);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	FormatError
//
//	Routine Description:
//		Format an error.
//
//	Arguments:
//		rstrError	[OUT] String in which to return the error message.
//		dwError		[IN] Error code to format.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
	DWORD	_cch;
	TCHAR	_szError[512];

	_cch = FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					dwError,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					_szError,
					sizeof(_szError) / sizeof(TCHAR),
					0
					);
	if (_cch == 0)
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		_cch = FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle(_T("NTDLL.DLL")),
						dwError,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
						_szError,
						sizeof(_szError) / sizeof(TCHAR),
						0
						);
	}  // if:  error formatting status code from system

	if (_cch > 0)
	{
		rstrError = _szError;
	}  // if:  no error
	else
	{

#ifdef _DEBUG

		DWORD	_sc = GetLastError();

		TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

		rstrError.Format(_T("Error 0x%08.8x"), dwError);

	}  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterCluAdminExtension
//
//	Routine Description:
//		Register the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while (*pwszResTypes != L'\0')
	{
		wprintf(L"  %s\n", pwszResTypes);
		hr = RegisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoIISClEx3
					);
		if (hr != S_OK)
			break;
		pwszResTypes += lstrlenW(pwszResTypes) + 1;
	}  // while:  more resource types

	return hr;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllUnregisterCluAdminExtension
//
//	Routine Description:
//		Unregister the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while (*pwszResTypes != L'\0')
	{
		wprintf(L"  %s\n", pwszResTypes);
		hr = UnregisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoIISClEx3
					);
		if (hr != S_OK)
			break;
		pwszResTypes += lstrlenW(pwszResTypes) + 1;
	}  // while:  more resource types

	return hr;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\iisclex3.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		IISClEx3.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		IISClEx3.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IISCLEX3_H_
#define _IISCLEX3_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"

#ifndef _CONSTDEF_H_
#include "ConstDef.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // _IISCLEX3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IISClEx3.rc
//
#define IDD_PP_IIS_PARAMETERS           180
#define IDD_WIZ_IIS_PARAMETERS          181
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_IIS_FTP                  1080
#define IDC_PP_IIS_GOPHER               1081
#define IDC_PP_IIS_WWW                  1082
#define IDC_PP_IIS_ALIAS_LABEL          1083
#define IDC_PP_IIS_ALIAS                1084
#define IDC_PP_IIS_DIRECTORY_LABEL      1085
#define IDC_PP_IIS_DIRECTORY            1086
#define IDC_PP_IIS_BROWSE               1087
#define IDC_PP_IIS_ACCOUNTNAME_LABEL    1088
#define IDC_PP_IIS_ACCOUNTNAME          1089
#define IDC_PP_IIS_PASSWORD_LABEL       1090
#define IDC_PP_IIS_PASSWORD             1091
#define IDC_PP_IIS_ACCT_INFO_GROUP      1092
#define IDC_PP_IIS_ACCESS_GROUP         1093
#define IDC_PP_IIS_READ_ACCESS          1094
#define IDC_PP_IIS_WRITE_ACCESS         1095
#define IDS_CLUADMEX_COMOBJ_DESC        30500
#define IDS_WRITE                       30501
#define IDS_EXECUTE                     30502
#define IDS_MENU_WHATS_THIS             30503
#define IDS_ERROR_MSG_ID                31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_REQUIRED_FIELD_EMPTY        31102
#define IDS_INVALID_IIS_SERVICE_TYPE    31103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        152
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1178
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>	// for cluster definitions
#endif

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Description:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	Dec 20, 1998
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\iisclex3\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL) {}

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
 #define	TraceError				;/##/
 #define	InitAllTraceTags		;/##/

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusapp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ClusApp.cpp
//
//	Description:
//		Implementation of the application class
//
//	Author:
//		Galen Barbee	(GalenB)	10-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "ClusNeti.h"
#include "ClusNetw.h"
#include "ClusRes.h"
#include "ClusResg.h"
#include "ClusRest.h"
#include "ClusNode.h"
#include "ClusApp.h"
#include "cluster.h"

#define SERVER_INFO_LEVEL		101
#define MAX_BUF_SIZE			0x00100000

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *	iidCClusterNames[] =
{
	&IID_ISClusterNames
};

static const IID *	iidCDomainNames[] =
{
	&IID_ISDomainNames
};

static const IID *	iidCClusApplication[] =
{
	&IID_ISClusApplication
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterNames class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::CClusterNames
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNames::CClusterNames( void )
{
	m_piids	 = (const IID *) iidCClusterNames;
	m_piidsSize = ARRAYSIZE( iidCClusterNames );

} //*** CClusterNames::CClusterNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::~CClusterNames
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNames::~CClusterNames( void )
{
	Clear();

} //*** CClusterNames::~CClusterNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::Create
//
//	Description:
//		Finish creating the object.
//
//	Arguments:
//		bstrDomainName	[IN]	- Name of the domain this collection of
//		cluster names is for.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterNames::Create( IN BSTR bstrDomainName )
{
	//ASSERT( bstrDomainName != NULL );

	HRESULT _hr = E_POINTER;

	if ( bstrDomainName )
	{
		if ( *bstrDomainName != L'\0' )
		{
			m_bstrDomainName = bstrDomainName;
			_hr = S_OK;
		}
	}

	return _hr;

} //*** CClusterNames::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::get_DomainName
//
//	Description:
//		Return the domain that this collection of cluster names is for.
//
//	Arguments:
//		pbstrDomainName	[OUT]	- Catches the domain name.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_DomainName( OUT BSTR * pbstrDomainName )
{
	//ASSERT( pbstrDomainName != NULL );

	HRESULT _hr = E_POINTER;

	if ( pbstrDomainName != NULL )
	{
		*pbstrDomainName = m_bstrDomainName.Copy();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusterNames::get_DomainName()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::get_Count
//
//	Description:
//		Get the count of objects in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_Clusters.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusterNames::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::Clear
//
//	Description:
//		Empty the vector of cluster names.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNames::Clear( void )
{
	if ( ! m_Clusters.empty() )
	{
		ClusterNameList::iterator	_itCurrent = m_Clusters.begin();
		ClusterNameList::iterator	_itLast = m_Clusters.end();

		for ( ; _itCurrent != _itLast; _itCurrent++ )
		{
			delete (*_itCurrent);
		} // for:

		m_Clusters.erase( m_Clusters.begin(), _itLast );
	} // if:

} //*** CClusterNames::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::GetIndex
//
//	Description:
//		Convert the passed in 1 based index into a 0 based index.
//
//	Arguments:
//		varIndex	[IN]	- holds the 1 based index.
//		pnIndex		[OUT]	- catches the 0 based index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterNames::GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex )
{
	//ASSERT( pnIndex != NULL);

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant v;
		UINT		nIndex = 0;

		*pnIndex = 0;

		v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			nIndex = v.lVal;
			if ( --nIndex < m_Clusters.size() ) // Adjust index to be 0 relative instead of 1 relative
			{
				*pnIndex = nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusterNames::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::get_Item
//
//	Description:
//		Get the item (cluster name) at the passes in index.
//
//	Arguments:
//		varIndex			[IN]	- Contains the index of the requested item.
//		ppbstrClusterName	[OUT]	- Catches the cluster name.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_Item(
	IN	VARIANT varIndex,
	OUT	BSTR *	ppbstrClusterName
	)
{
	//ASSERT( ppbstrClusterName != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppbstrClusterName != NULL )
	{
		UINT nIndex = 0;

		// Zero the out param
		SysFreeString( *ppbstrClusterName );

		_hr = GetIndex( varIndex, &nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			*ppbstrClusterName = m_Clusters[ nIndex ]->Copy();
		}
	}

	return _hr;

} //*** CClusterNames::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::Refresh
//
//	Description:
//		Gets the list of cluster servers for the domain that this list is
//		for.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Win32 error passed in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::Refresh( void )
{
	SERVER_INFO_101 *	_pServerInfoList;
	DWORD				_cReturnCount = 0;
	DWORD				_cTotalServers = 0;
	DWORD				_sc;
	CComBSTR *			_pbstr = NULL;

	_sc = ::NetServerEnum(
					0,								// servername = where command executes 0 = local
					SERVER_INFO_LEVEL,				// level = type of structure to return.
					(LPBYTE *) &_pServerInfoList,	// bufptr = returned array of server info structures
					MAX_BUF_SIZE,					// prefmaxlen = preferred max of returned data
					&_cReturnCount,					// entriesread = number of enumerated elements returned
					&_cTotalServers,				// totalentries = total number of visible machines on the network
					SV_TYPE_CLUSTER_NT,				// servertype = filters the type of info returned
					m_bstrDomainName,				// domain = domain to limit search
					0								// resume handle
					);

	if ( _sc == ERROR_SUCCESS )
	{
		size_t	_index;

		Clear();

		for( _index = 0; _index < _cReturnCount; _index++ )
		{
			_pbstr = new CComBSTR( _pServerInfoList[ _index ].sv101_name );
			if ( _pbstr != NULL )
			{
				m_Clusters.insert( m_Clusters.end(), _pbstr );
			} // if:
			else
			{
				_sc = ERROR_NOT_ENOUGH_MEMORY;
				break;
			} // else:
		} // for:

		::NetApiBufferFree( _pServerInfoList );
	}

	return HRESULT_FROM_WIN32( _sc );

} //*** CClusterNames::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get__NewEnum(
	IUnknown ** ppunk
	)
{
	return ::HrNewCComBSTREnum< ClusterNameList >( ppunk, m_Clusters );

} //*** CClusterNames::get__NewEnum()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNames::get_Application
//
//	Description:
//		Return the parent application object.
//
//	Arguments:
//		ppParentApplication	[OUT]	- Catches the parent app object.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_Application(
	OUT ISClusApplication ** ppParentApplication
	)
{
	//ASSERT( ppParentApplication != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppParentApplication != NULL )
	{
		_hr = E_NOTIMPL;
	}

	return _hr;

} //*** CClusterNames::get_Application()
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CDomainNames class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::CDomainNames
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDomainNames::CDomainNames( void )
{
	m_piids		= (const IID *) iidCDomainNames;
	m_piidsSize	= ARRAYSIZE( iidCDomainNames );

} //*** CDomainNames::CDomainNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::~CDomainNames
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDomainNames::~CDomainNames( void )
{
	Clear();

} //*** CDomainNames::~CDomainNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::get_Count
//
//	Description:
//		Get the count of objects in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_DomainList.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CDomainNames::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::Clear
//
//	Description:
//		Empty the vector of domain names.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDomainNames::Clear( void )
{
	if ( ! m_DomainList.empty() )
	{
		DomainList::iterator	_itCurrent = m_DomainList.begin();
		DomainList::iterator	_itLast = m_DomainList.end();

		for ( ; _itCurrent != _itLast; _itCurrent++ )
		{
			delete (*_itCurrent);
		} // for:

		m_DomainList.erase( m_DomainList.begin(), _itLast );
	} // if:

} //*** CDomainNames::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::ScBuildTrustList
//
//	Description:
//		Attempts to find the domain that we are in.  If it can then it also
//		tries to enum the domains trusted domains.
//
//	Arguments:
//		pszTarget	[IN]	- A server name, or NULL to indicate this machine.
//
//	Return Value:
//		ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::ScBuildTrustList( IN LPWSTR pszTarget )
{
	LSA_HANDLE					PolicyHandle = INVALID_HANDLE_VALUE;
	DWORD						_sc;
	PPOLICY_ACCOUNT_DOMAIN_INFO	AccountDomain;
	BOOL						bDC;
	LPWSTR						pwszPrimaryDomainName = NULL;
	NTSTATUS					ntStatus = STATUS_SUCCESS;

	do
	{
		//
		// open the policy on the specified machine
		//
		_sc = ScOpenPolicy( pszTarget, POLICY_VIEW_LOCAL_INFORMATION, &PolicyHandle );
		if ( _sc != ERROR_SUCCESS )
		{
			break;
		}

		//
		// obtain the AccountDomain, which is common to all three cases
		//
		ntStatus = ::LsaQueryInformationPolicy( PolicyHandle, PolicyAccountDomainInformation, (void **) &AccountDomain );
		if ( ntStatus != STATUS_SUCCESS )
		{
			_sc = RtlNtStatusToDosError( ntStatus );
			break;
		}

		//
		// find out if the pszTarget machine is a domain controller
		//
		_sc = ScIsDomainController( pszTarget, &bDC );
		if ( _sc != ERROR_SUCCESS )
		{
			break;
		}

		if ( !bDC )
		{
			PPOLICY_PRIMARY_DOMAIN_INFO	PrimaryDomain;

			//
			// get the primary domain
			//
			ntStatus = ::LsaQueryInformationPolicy( PolicyHandle, PolicyPrimaryDomainInformation, (void **) &PrimaryDomain );
			if ( ntStatus != STATUS_SUCCESS )
			{
				_sc = RtlNtStatusToDosError( ntStatus );
				break;
			}

			//
			// if the primary domain Sid is NULL, we are a non-member, and
			// our work is done.
			//
			if ( PrimaryDomain->Sid == NULL )
			{
				::LsaFreeMemory( PrimaryDomain );
				break;
			}

			_sc = ScAddTrustToList( &PrimaryDomain->Name );
			if ( _sc != ERROR_SUCCESS )
			{
				break;
			} // if:

			//
			// build a copy of what we just added.	This is necessary in order
			// to lookup the domain controller for the specified domain.
			// the Domain name must be NULL terminated for NetGetDCName(),
			// and the LSA_UNICODE_STRING buffer is not necessarilly NULL
			// terminated.	Note that in a practical implementation, we
			// could just extract the element we added, since it ends up
			// NULL terminated.
			//

			pwszPrimaryDomainName = new WCHAR [ ( PrimaryDomain->Name.Length / sizeof( WCHAR ) ) + 1 ]; // existing length + NULL
			if ( pwszPrimaryDomainName != NULL )
			{
				//
				// copy the existing buffer to the new storage, appending a NULL
				//
				::lstrcpynW( pwszPrimaryDomainName, PrimaryDomain->Name.Buffer, ( PrimaryDomain->Name.Length / sizeof( WCHAR ) ) + 1 );
			}
			else
			{
				_sc = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}

			::LsaFreeMemory( PrimaryDomain );

			//
			// get the primary domain controller computer name
			//
			PDOMAIN_CONTROLLER_INFO pdci;

			_sc = ::DsGetDcName( NULL,
									pwszPrimaryDomainName,
									NULL,
									NULL,
									DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
									&pdci );
			if ( _sc != ERROR_SUCCESS )
			{
				break;
			}

			//
			// close the policy handle, because we don't need it anymore
			// for the workstation case, as we open a handle to a DC
			// policy below
			//
			::LsaClose( PolicyHandle );
			PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

			//
			// open the policy on the domain controller
			//
			_sc = ScOpenPolicy( ( pdci->DomainControllerName + 2 ), POLICY_VIEW_LOCAL_INFORMATION, &PolicyHandle );
			if ( _sc != ERROR_SUCCESS )
			{
				break;
			}
		}
		else
		{
			//
			// Note: AccountDomain->DomainSid will contain binary Sid
			//
			_sc = ScAddTrustToList( &AccountDomain->DomainName );
			if ( _sc != ERROR_SUCCESS )
			{
				break;
			} // if:
		}

		//
		// free memory allocated for account domain
		//
		::LsaFreeMemory( AccountDomain );

		//
		// build additional trusted domain(s) list and indicate if successful
		//
		_sc = ScEnumTrustedDomains( PolicyHandle );
		break;
	}
	while( TRUE );

	delete [] pwszPrimaryDomainName;

	//
	// close the policy handle
	//
	if ( PolicyHandle != INVALID_HANDLE_VALUE )
	{
		::LsaClose( PolicyHandle );
	}

	return HRESULT_FROM_WIN32( _sc );

} //*** CDomainNames::ScBuildTrustList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::ScOpenPolicy
//
//	Description:
//		Returns an open policy handle for the passed in machine name.
//
//	Arguments:
//		ServerName		[IN]	- The machine name.  Could be NULL.
//		DesiredAccess	[IN]	- The level of the information requested.
//		PolicyHandle	[OUT]	- Catches the policy handle.
//
//	Return Value:
//		ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScOpenPolicy(
	IN	LPWSTR		ServerName,
	IN	DWORD		DesiredAccess,
	OUT	PLSA_HANDLE	PolicyHandle
	)
{
	LSA_OBJECT_ATTRIBUTES	ObjectAttributes;
	LSA_UNICODE_STRING		ServerString;
	PLSA_UNICODE_STRING		Server;
	NTSTATUS				ntStatus = STATUS_SUCCESS;
	DWORD					_sc = ERROR_SUCCESS;

	//
	// Always initialize the object attributes to all zeroes
	//
	ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

	if ( ServerName != NULL )
	{
		//
		// Make a LSA_UNICODE_STRING out of the LPWSTR passed in
		//
		InitLsaString( &ServerString, ServerName );

		Server = &ServerString;
	}
	else
	{
		Server = NULL;
	}

	//
	// Attempt to open the policy
	//
	ntStatus = ::LsaOpenPolicy( Server, &ObjectAttributes, DesiredAccess, PolicyHandle );
	if ( ntStatus != STATUS_SUCCESS )
	{
		_sc = RtlNtStatusToDosError( ntStatus );
	} // if:

	return _sc;

} //*** CDomainNames::ScOpenPolicy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::InitLsaString
//
//	Description:
//		Initialize the passed in LSA string with either default or the value
//		of the passed in server name string.
//
//	Arguments:
//		LsaString	[OUT]	- Catches the LSA string.
//		psz			[IN]	- Server name -- could be NULL.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDomainNames::InitLsaString(
	OUT	PLSA_UNICODE_STRING	LsaString,
	IN	LPWSTR				psz
	)
{
	if ( psz == NULL )
	{
		LsaString->Buffer = NULL;
		LsaString->Length = 0;
		LsaString->MaximumLength = 0;
	} // if: psz is NULL
	else
	{
		size_t	cchpsz = lstrlenW( psz );

		LsaString->Buffer = psz;
		LsaString->Length = (USHORT) ( cchpsz * sizeof( WCHAR ) );
		LsaString->MaximumLength = (USHORT) ( ( cchpsz + 1 ) * sizeof( WCHAR ) );
	} // else: it's not NULL

} //*** CDomainNames::InitLsaString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::ScIsDomainController
//
//	Description:
//		Is the passed in server a DC?
//
//	Arguments:
//		pszServer	[IN]	- The server name.
//		pbIsDC		[OUT]	- Catches the "Is DC" bool.
//
//	Return Value:
//		ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScIsDomainController(
	IN	LPWSTR	pszServer,
	OUT	LPBOOL	pbIsDC
	)
{
	PSERVER_INFO_101	si101;
	NET_API_STATUS		nas;

	nas = ::NetServerGetInfo( pszServer, SERVER_INFO_LEVEL, (LPBYTE *) &si101 );
	if ( nas == NERR_Success )
	{
		if ( ( si101->sv101_type & SV_TYPE_DOMAIN_CTRL )	||
			 ( si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) )
		{
			*pbIsDC = TRUE;	// we are dealing with a DC
		}
		else
		{
			*pbIsDC = FALSE;
		}

		::NetApiBufferFree( si101 );
	}

	return nas;

} //*** CDomainNames::ScIsDomainController()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::ScEnumTrustedDomains
//
//	Description:
//		Enumerate the the trusted domains of the passed in policy handle.
//
//	Arguments:
//		PolicyHandle	[IN]	- Contains out domain.
//
//	Return Value:
//		ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScEnumTrustedDomains( LSA_HANDLE IN PolicyHandle )
{
	LSA_ENUMERATION_HANDLE	lsaEnumHandle = 0;		// start an enum
	PLSA_TRUST_INFORMATION	TrustInfo;
	ULONG					ulReturned;				// number of items returned
	ULONG					ulCounter;				// counter for items returned
	DWORD					_sc = ERROR_SUCCESS;
	NTSTATUS				ntStatus = STATUS_SUCCESS;

	do
	{
		ntStatus = ::LsaEnumerateTrustedDomains(
								PolicyHandle,			// open policy handle
								&lsaEnumHandle,			// enumeration tracker
								(void **) &TrustInfo,	// buffer to receive data
								32000,					// recommended buffer size
								&ulReturned				// number of items returned
								);
		//
		// get out if an error occurred
		//
		if ( ( ntStatus != STATUS_SUCCESS )			&&
			 ( ntStatus != STATUS_MORE_ENTRIES )	&&
			 ( ntStatus != STATUS_NO_MORE_ENTRIES ) )
		{
			break;
		}

		//
		// Display results
		// Note: Sids are in TrustInfo[ ulCounter ].Sid
		//
		for ( ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++ )
		{
			_sc = ScAddTrustToList( &TrustInfo[ ulCounter ].Name );
			if ( _sc != ERROR_SUCCESS )
			{
				break;
			} // if:
		} // for:

		//
		// free the buffer
		//
		::LsaFreeMemory( TrustInfo );

	} while ( ntStatus == STATUS_MORE_ENTRIES );

	if ( ntStatus == STATUS_NO_MORE_ENTRIES )
	{
		ntStatus = STATUS_SUCCESS;
	} // if:

	if ( ntStatus != STATUS_SUCCESS )
	{
		_sc = RtlNtStatusToDosError( ntStatus );
	} // if:

	return _sc;

} //*** CDomainNames::ScEnumTrustedDomains()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::ScAddTrustToList
//
//	Description:
//		Add the trusted domain to the collection of domains.
//
//	Arguments:
//		UnicodeString	[IN]	- Contains the domain name.
//
//	Return Value:
//		ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScAddTrustToList(
	IN PLSA_UNICODE_STRING UnicodeString
	)
{
	DWORD	_sc = ERROR_SUCCESS;

	CComBSTR *	pstr = new CComBSTR( ( UnicodeString->Length / sizeof( WCHAR ) ) + 1, UnicodeString->Buffer );
	if ( pstr != NULL )
	{
		m_DomainList.insert( m_DomainList.end(), pstr );
	}
	else
	{
		_sc = ERROR_NOT_ENOUGH_MEMORY;
	} // else:

	return _sc;

} //*** CDomainNames::ScAddTrustToList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::Refresh
//
//	Description:
//		Gets the list of domains that this collection contains.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Win32 error passed in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::Refresh( void )
{
	Clear();

	return ScBuildTrustList( NULL );

} //*** CDomainNames::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get__NewEnum( OUT IUnknown ** ppunk )
{
	return ::HrNewCComBSTREnum< DomainList >( ppunk, m_DomainList );

} //*** CDomainNames::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::GetIndex
//
//	Description:
//		Convert the passed in 1 based index into a 0 based index.
//
//	Arguments:
//		varIndex	[IN]	- holds the 1 based index.
//		pnIndex		[OUT]	- catches the 0 based index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CDomainNames::GetIndex(
	IN	VARIANT	varIndex,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL);

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant v;
		UINT		nIndex = 0;

		*pnIndex = 0;

		v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			nIndex = v.lVal;
			if ( --nIndex < m_DomainList.size() )	// Adjust index to be 0 relative instead of 1 relative
			{
				*pnIndex = nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CDomainNames::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::get_Item
//
//	Description:
//		Get the item (domain name) at the passes in index.
//
//	Arguments:
//		varIndex			[IN]	- Contains the index of the requested item.
//		p_pbstrClusterName	[OUT]	- Catches the cluster name.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get_Item(
	VARIANT varIndex,
	BSTR *	bstrDomainName
	)
{
	//ASSERT( bstrDomainName != NULL );

	HRESULT _hr = E_POINTER;

	if ( bstrDomainName != NULL )
	{
		UINT nIndex = 0;

		// Zero the out param
		SysFreeString( *bstrDomainName );

		_hr = GetIndex( varIndex, &nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			*bstrDomainName = m_DomainList [nIndex]->Copy();
		}
	}

	return _hr;

} //*** CDomainNames::get_Item()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDomainNames::get_Application
//
//	Description:
//		Returns the parent ClusApplication object.
//
//	Arguments:
//		ppParentApplication	[OUT]	- Catches the parent app object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get_Application(
	OUT ISClusApplication ** ppParentApplication
	)
{
	//ASSERT( ppParentApplication != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppParentApplication != NULL )
	{
		_hr = E_NOTIMPL;
	}

	return _hr;

} //*** CDomainNames::get_Application()
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusApplication class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusApplication::CClusApplication
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusApplication::CClusApplication( void )
{
	m_pDomainNames	= NULL;
	m_piids	 = (const IID *) iidCClusApplication;
	m_piidsSize = ARRAYSIZE( iidCClusApplication );

} //*** CClusApplication::CClusApplication()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusApplication::~CClusApplication
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusApplication::~CClusApplication( void )
{
	if ( m_pDomainNames != NULL )
	{
		m_pDomainNames->Release();
		m_pDomainNames = NULL;
	}

} //*** CClusApplication::~CClusApplication()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusApplication::get_DomainNames
//
//	Description:
//		Returns the collection of domain names for the domain that we are
//		joined to.
//
//	Arguments:
//		ppDomainNames	[OUT]	- Catches the collection of domain names.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::get_DomainNames(
	OUT ISDomainNames ** ppDomainNames
	)
{
	//ASSERT( ppDomainNames != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppDomainNames != NULL )
	{
		*ppDomainNames = NULL;
		_hr = S_OK;

		if ( m_pDomainNames == NULL )
		{
			CComObject< CDomainNames > *	pDomainNames = NULL;

			_hr = CComObject< CDomainNames >::CreateInstance( &pDomainNames );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< CComObject< CDomainNames > >	ptrDomainNames( pDomainNames );

				_hr = ptrDomainNames->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					m_pDomainNames = ptrDomainNames;
					ptrDomainNames->AddRef();
				}
			}
		}

		if ( SUCCEEDED( _hr ) )
		{
			_hr = m_pDomainNames->QueryInterface( IID_ISDomainNames, (void **) ppDomainNames );
		}
	} // if: args are not NULL

	return _hr;

} //*** CClusApplication::get_DomainNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusApplication::get_ClusterNames
//
//	Description:
//		Returns the clusters in the passed in domain.
//
//	Arguments:
//		bstrDomainName	[IN]	- The domain name to search for clusters.
//		ppClusterNames	[OUT]	- Catches the collection of cluster names.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::get_ClusterNames(
	IN	BSTR				bstrDomainName,
	OUT	ISClusterNames **	ppClusterNames
	)
{
	//ASSERT( bstrDomainName != NULL );
	//ASSERT( ppClusterNames != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppClusterNames != NULL )
	{
		*ppClusterNames = NULL;
		_hr = S_OK;

		CComObject< CClusterNames > *	pClusterNames = NULL;

		_hr = CComObject< CClusterNames >::CreateInstance( &pClusterNames );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< CClusterNames > >	ptrClusterNames( pClusterNames );

			_hr = ptrClusterNames->Create( bstrDomainName );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrClusterNames->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrClusterNames->QueryInterface( IID_ISClusterNames, (void **) ppClusterNames );
				} // if: collection was filled
			} // if: collection was created
		} // if: collection was allocated
	} // if: args are not NULL

	return _hr;

} //*** CClusApplication::get_ClusterNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusApplication::OpenCluster
//
//	Description:
//		Open the passed in cluster name.
//
//	Arguments:
//		bstrClusterName	[IN]	- The name of the cluster to open.
//		ppCluster		[OUT]	- Catches the newly created cluster obj.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::OpenCluster(
	IN	BSTR			bstrClusterName,
	OUT	ISCluster **	ppCluster
	)
{
	//ASSERT( bstrClusterName != NULL );
	//ASSERT( ppCluster != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( bstrClusterName != NULL ) && ( ppCluster != NULL ) )
	{
		CComObject< CCluster > *	pCluster = NULL;

		*ppCluster = NULL;

		_hr = CComObject< CCluster >::CreateInstance( &pCluster );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< CCluster > > ptrCluster( pCluster );

			_hr = ptrCluster->Create( this );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCluster->Open( bstrClusterName );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrCluster->QueryInterface( IID_ISCluster, (void **) ppCluster );
				} // if: cluster object was opened
			} // if: cluster object was created
		} // if: cluster object was allocated
	} // if: args are not NULL

	return _hr;

} //*** CClusApplication::OpenCluster()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusApplication::get_Application
//
//	Description:
//		Returns the parent ClusApplication object.  In this case "this".
//
//	Arguments:
//		ppParentApplication	[OUT]	- Catches the parent app object.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::get_Application(
	OUT ISClusApplication ** ppParentApplication
	)
{
	//ASSERT( ppParentApplication != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppParentApplication != NULL )
	{
		_hr = _InternalQueryInterface( IID_ISClusApplication, (void **) ppParentApplication );
	}

	return _hr;

} //*** CClusApplication::get_Application()
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		ClusApp.h
//
//	Description:
//		Definition of CClusApplication and it's supporting classes.
//
//	Implementation File:
//		ClusApp.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	10-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSAPPLICATION_H_
#define _CLUSAPPLICATION_H_

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusApplication;
class CClusterNames;
class CDomainNames;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusterNames
//
//	Description:
//		Cluster Names Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusterNames, &IID_ISClusterNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusterNames, &CLSID_ClusterNames >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusterNames	:
	public IDispatchImpl< ISClusterNames, &IID_ISClusterNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusterNames, &CLSID_ClusterNames >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusterNames( void );
	~CClusterNames( void );

BEGIN_COM_MAP(CClusterNames)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusterNames)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusterNames)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN BSTR bstrDomainName );

private:
	typedef std::vector< CComBSTR * >	ClusterNameList;

	ClusterNameList m_Clusters;
	CComBSTR		m_bstrDomainName;

	void Clear( void );

public:
	STDMETHODIMP get_DomainName( OUT BSTR * pbstrDomainName );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * bstrClusterName );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

//	STDMETHODIMP get_Application( OUT ISClusApplication ** ppParentApplication );

//	STDMETHODIMP get_Parent( OUT ISClusApplication ** ppParent )
//	{
//		return get_Application( ppParent );
//	}

protected:
	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

}; //*** CClusterNames

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDomainNames
//
//	Description:
//		Cluster Domain Names Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISDomainNames, &IID_ISDomainNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CDomainNames, &CLSID_DomainNames >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CDomainNames :
	public IDispatchImpl< ISDomainNames, &IID_ISDomainNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CDomainNames, &CLSID_DomainNames >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CDomainNames( void );
	~CDomainNames( void );

BEGIN_COM_MAP(CDomainNames)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISDomainNames)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDomainNames)
DECLARE_NO_REGISTRY()

private:
	typedef std::vector< CComBSTR * >	DomainList;

	DomainList		m_DomainList;

	STDMETHODIMP ScBuildTrustList( IN LPWSTR pszTarget );

	DWORD ScOpenPolicy( IN LPWSTR ServerName, IN DWORD DesiredAccess, OUT PLSA_HANDLE PolicyHandle );

	void InitLsaString( OUT PLSA_UNICODE_STRING LsaString, IN LPWSTR String );

	DWORD ScIsDomainController( IN LPWSTR pszServer, OUT LPBOOL pbIsDC );

	DWORD ScEnumTrustedDomains( IN LSA_HANDLE PolicyHandle );

	DWORD ScAddTrustToList( IN PLSA_UNICODE_STRING UnicodeString );

	void Clear( void );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * bstrDomainName );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

//	STDMETHODIMP get_Application( OUT ISClusApplication ** ppParentApplication );

//	STDMETHODIMP get_Parent( OUT ISClusApplication ** ppParent )
//	{
//		return get_Application( ppParent );
//	}

protected:
	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

}; //*** Class CDomainNames

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusApplication
//
//	Description:
//		Cluster Application Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusApplication, &IID_ISClusApplication, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusApplication, &CLSID_ClusApplication >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusApplication :
	public IDispatchImpl< ISClusApplication, &IID_ISClusApplication, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusApplication, &CLSID_ClusApplication >
{
	typedef CComObjectRootEx< CComSingleThreadModel >										BaseComClass;
	typedef CComCoClass< CClusApplication, &CLSID_ClusApplication >							BaseCoClass;
	typedef IDispatchImpl< ISClusApplication, &IID_ISClusApplication, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >	BaseDispatchClass;

public:
	CClusApplication( void );
	~CClusApplication( void );

BEGIN_COM_MAP(CClusApplication)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusApplication)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusApplication)
DECLARE_REGISTRY_RESOURCEID(IDR_MSCLUS)

public:
	STDMETHODIMP get_DomainNames( OUT ISDomainNames ** ppDomainNames );

	STDMETHODIMP OpenCluster( IN BSTR bstrClusterName, OUT ISCluster ** ppCluster );

	STDMETHODIMP get_ClusterNames( IN BSTR bstrDomainName, OUT ISClusterNames ** ppClusterNames );

//	STDMETHODIMP get_Application( OUT ISClusApplication ** ppParentApplication );

//	STDMETHODIMP get_Parent( OUT ISClusApplication ** ppParent )
//	{
//		return get_Application( ppParent );
//	}

private:
	CComObject< CDomainNames > *	m_pDomainNames;

}; //*** Class CClusApplication

#endif // _CLUSAPPLICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusdisk.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClusDisk.cpp
//
//	Description:
//		Implementation of the cluster disk class for the MSCLUS
//		automation classes.
//
//	Author:
//		Galen Barbee	(galenb)	11-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#if CLUSAPI_VERSION >= 0x0500
	#include <PropList.h>
#else
	#include "PropList.h"
#endif // CLUSAPI_VERSION >= 0x0500

#include "ClusDisk.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *	iidCClusDisk[] =
{
	&IID_ISClusDisk
};

static const IID *	iidCClusDisks[] =
{
	&IID_ISClusDisks
};

static const IID *	iidCClusScsiAddress[] =
{
	&IID_ISClusScsiAddress
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusDisk class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::CClusDisk
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisk::CClusDisk( void )
{
	m_pPartitions	= NULL;
	m_dwSignature	= 0;
	m_dwDiskNumber	= 0;
	m_piids			= (const IID *) iidCClusDisk;
	m_piidsSize		= ARRAYSIZE( iidCClusDisk );

}	//*** CClusDisk::CClusDisk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::~CClusDisk
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisk::~CClusDisk( void )
{
	if ( m_pPartitions != NULL )
	{
		m_pPartitions->Release();
	} // if:

}	//*** CClusDisk::~CClusDisk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::Create
//
//	Description:
//		Finish creating this object.  This method get the value list from
//		the passed in physical disk resource handle.
//
//	Arguments:
//		hResource	[IN]	- Handle to the physical disk resource.
//
//	Return Value:
//		S_OK if successful, or Win32 error wrapped in HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisk::Create( IN HRESOURCE hResource )
{
	HRESULT _hr = E_POINTER;

	DWORD				_sc	= ERROR_SUCCESS;
	CClusPropValueList	_cpvl;

	_sc = _cpvl.ScGetResourceValueList( hResource, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO );
	_hr = HRESULT_FROM_WIN32( _sc );
	if ( SUCCEEDED( _hr ) )
	{
		_sc = _cpvl.ScMoveToFirstValue();
		_hr = HRESULT_FROM_WIN32( _sc );
		if ( SUCCEEDED( _hr ) )
		{
			CLUSPROP_BUFFER_HELPER			_cbhValue = { NULL };
			CComObject< CClusPartitions > *	pPartitions = NULL;

			if ( m_pPartitions != NULL )
			{
				m_pPartitions->Release();
				m_pPartitions = NULL;
			} // if: clean up any old partitions collection

			_hr = CComObject< CClusPartitions >::CreateInstance( &pPartitions );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< CComObject< CClusPartitions > >	ptrPartitions( pPartitions );

				m_pPartitions = ptrPartitions;
				ptrPartitions->AddRef();

				do
				{
					_cbhValue = _cpvl;

					switch ( _cbhValue.pSyntax->dw )
					{
						case CLUSPROP_SYNTAX_PARTITION_INFO :
						{
							_hr = ptrPartitions->HrCreateItem( _cbhValue.pPartitionInfoValue );
							break;
						} // case: CLUSPROP_SYNTAX_PARTITION_INFO

						case CLUSPROP_SYNTAX_DISK_SIGNATURE :
						{
							m_dwSignature = _cbhValue.pDiskSignatureValue->dw;
							break;
						} // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

						case CLUSPROP_SYNTAX_SCSI_ADDRESS :
						{
							m_csaScsiAddress.dw = _cbhValue.pScsiAddressValue->dw;
							break;
						} // case: CLUSPROP_SYNTAX_SCSI_ADDRESS

						case CLUSPROP_SYNTAX_DISK_NUMBER :
						{
							m_dwDiskNumber = _cbhValue.pDiskNumberValue->dw;
							break;
						} // case: CLUSPROP_SYNTAX_DISK_NUMBER

					} // switch:

					//
					// Move to the next value.
					//
					_sc = _cpvl.ScMoveToNextValue();
					if ( _sc == ERROR_NO_MORE_ITEMS )
					{
						_hr = S_OK;
						break;
					} // if: error occurred moving to the next value

					_hr = HRESULT_FROM_WIN32( _sc );

				} while ( SUCCEEDED( _hr ) );	// do-while: there are no errors
			} // if: created the partition collection
		} // if: move to first value ok
	} // if: get the value list ok

	return _hr;

} //*** CClusDisk::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::HrCreate
//
//	Description:
//		Finish creating this object.  This method parses a passed in value
//		list to get the values for the physical disk object.
//
//	Arguments:
//		rcpvl		[IN OUT]	- Value list to parse.
//		pbEndFound	[OUT]		- Did find the end of the value list?
//
//	Return Value:
//		S_OK, or Win32 error code wrapped in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisk::HrCreate(
	IN OUT	CClusPropValueList &	rcpvl,
	OUT		BOOL *					pbEndFound
	)
{
	DWORD							_sc = ERROR_SUCCESS;
	CLUSPROP_BUFFER_HELPER			_cbhValue = { NULL };
	CComObject< CClusPartitions > *	pPartitions = NULL;
	HRESULT							_hr = S_FALSE;

	if ( m_pPartitions != NULL )
	{
		m_pPartitions->Release();
		m_pPartitions = NULL;
	} // if: clean up any old partitions collection

	_hr = CComObject< CClusPartitions >::CreateInstance( &pPartitions );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject< CClusPartitions > >	ptrPartitions( pPartitions );

		m_pPartitions = ptrPartitions;
		ptrPartitions->AddRef();

		_cbhValue = rcpvl;

		do
		{
			switch ( _cbhValue.pSyntax->dw )
			{
				case CLUSPROP_SYNTAX_DISK_SIGNATURE :
				{
					m_dwSignature = _cbhValue.pDiskSignatureValue->dw;
					break;
				} // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

				case CLUSPROP_SYNTAX_PARTITION_INFO :
				{
					_hr = ptrPartitions->HrCreateItem( _cbhValue.pPartitionInfoValue );
					break;
				} // case: CLUSPROP_SYNTAX_PARTITION_INFO

				case CLUSPROP_SYNTAX_SCSI_ADDRESS :
				{
					m_csaScsiAddress.dw = _cbhValue.pScsiAddressValue->dw;
					break;
				} // case: CLUSPROP_SYNTAX_SCSI_ADDRESS

				case CLUSPROP_SYNTAX_DISK_NUMBER :
				{
					m_dwDiskNumber = _cbhValue.pDiskNumberValue->dw;
					break;
				} // case: CLUSPROP_SYNTAX_DISK_NUMBER

			} // switch:

			//
			// Move to the next value.
			//
			_sc = rcpvl.ScMoveToNextValue();
			if ( _sc == ERROR_NO_MORE_ITEMS )
			{
				_hr = S_OK;
				*pbEndFound = TRUE;
				break;
			} // if: error occurred moving to the next value

			_cbhValue = rcpvl;

			if ( _cbhValue.pSyntax->dw == CLUSPROP_SYNTAX_DISK_SIGNATURE )
			{
				_hr = HRESULT_FROM_WIN32( _sc );
				break;
			} // if: exit if another signature is found before the end of the list is seen

			_hr = HRESULT_FROM_WIN32( _sc );

		} while ( SUCCEEDED( _hr ) );	// do-while: there are no errors

	} // if: the patitions collection can be created

	return _hr;

} //*** CClusDisk::HrCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::get_Signature
//
//	Description:
//		Get the disk signature.
//
//	Arguments:
//		plSignature	[OUT]	- catches the signature.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_Signature( OUT long * plSignature )
{
	//ASSERT( plSignature != NULL );

	HRESULT _hr = E_POINTER;

	if ( plSignature != NULL )
	{
		*plSignature = static_cast< long >( m_dwSignature );
		_hr = S_OK;
	}

	return _hr;

} //*** CClusDisk::get_Signature()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::get_ScsiAddress
//
//	Description:
//		Get the disk's SCSI address.
//
//	Arguments:
//		ppScsiAddress	[OUT]	- catches the SCSI address..
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_ScsiAddress(
	OUT ISClusScsiAddress ** ppScsiAddress
	)
{
	//ASSERT( ppScsiAddress != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppScsiAddress != NULL )
	{
		CComObject< CClusScsiAddress > *	_pScsiAddress = NULL;

		_hr = CComObject< CClusScsiAddress >::CreateInstance( &_pScsiAddress );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< CClusScsiAddress > >	_ptrScsiAddress( _pScsiAddress );

			_hr = _ptrScsiAddress->Create( m_csaScsiAddress );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = _ptrScsiAddress->QueryInterface( IID_ISClusScsiAddress, (void **) ppScsiAddress );
			} // if:
		} // if:
	} // if:

	return _hr;

} //*** CClusDisk::get_ScsiAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::get_DiskNumber
//
//	Description:
//		Get the disk number.
//
//	Arguments:
//		plDiskNumber	[OUT]	- catches the disk number.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_DiskNumber( OUT long * plDiskNumber )
{
	//ASSERT( plDiskNumber != NULL );

	HRESULT _hr = E_POINTER;

	if ( plDiskNumber != NULL )
	{
		*plDiskNumber = static_cast< long >( m_dwDiskNumber );
		_hr = S_OK;
	}

	return _hr;

} //*** CClusDisk::get_DiskNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisk::get_Partitions
//
//	Description:
//		Get the disk partitions.
//
//	Arguments:
//		ppPartitions	[OUT]	- catches the partitions collection.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_Partitions( OUT ISClusPartitions ** ppPartitions )
{
	//ASSERT( ppPartitions != NULL );
	ASSERT( m_pPartitions != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppPartitions != NULL )
	{
		if ( ppPartitions != NULL )
		{
			_hr = m_pPartitions->QueryInterface( IID_ISClusPartitions, (void **) ppPartitions );
		} // if:
	} // if:

	return _hr;

} //*** CClusDisk::get_Partitions()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusDisks class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::CClusDisks
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisks::CClusDisks( void )
{
	m_pClusRefObject		= NULL;
	m_piids				= (const IID *) iidCClusDisks;
	m_piidsSize			= ARRAYSIZE( iidCClusDisks );

} //*** CClusDisks::CClusDisks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::~CClusDisks
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisks::~CClusDisks( void )
{
	Clear();

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	} // if: do we have a pointer to the cluster handle wrapper?

} //*** CClusDisks::~CClusDisks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::Create
//
//	Description:
//		Complete the heavy weight construction,
//
//	Arguments:
//		rpvl	[IN]	- Property value list.
//
//	Return Value:
//		E_NOTIMPL
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::Create( IN const CClusPropValueList &rpvl )
{
	HRESULT _hr = E_NOTIMPL;

	return _hr;

} //*** CClusDisks::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::GetIndex
//
//	Description:
//		Convert the passed in 1 based index into a 0 based index.
//
//	Arguments:
//		varIndex	[IN]	- holds the 1 based index.
//		pnIndex		[OUT]	- catches the 0 based index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex )
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant	v;
		UINT		nIndex = 0;

		*pnIndex = 0;

		v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			nIndex = v.lVal;
			nIndex--;						// Adjust index to be 0 relative instead of 1 relative

			if ( nIndex < m_dvDisks.size() )
			{
				*pnIndex = nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusDisks::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::get_Count
//
//	Description:
//		Get the count of objects in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_dvDisks.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusDisks::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::Clear
//
//	Description:
//		Empty the vector of disks.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusDisks::Clear( void )
{
	::ReleaseAndEmptyCollection< DiskVector, CComObject< CClusDisk > >( m_dvDisks );

} //*** CClusDisks::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::get_Item
//
//	Description:
//		Get the item (disk) at the passed in index.
//
//	Arguments:
//		varIndex			[IN]	- Contains the index requested.
//		ppbstrRegistryKey	[OUT]	- Catches the key.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::get_Item(
	IN	VARIANT			varIndex,
	OUT	ISClusDisk **	ppDisk
	)
{
	//ASSERT( ppDisk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppDisk != NULL )
	{
		CComObject< CClusDisk > * pDisk = NULL;

		// Zero the out param
		*ppDisk = NULL;

		UINT nIndex = 0;

		_hr = GetIndex( varIndex, &nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			pDisk = m_dvDisks[ nIndex ];
			_hr = pDisk->QueryInterface( IID_ISClusDisk, (void **) ppDisk );
		}
	}

	return _hr;

} //*** CClusDisks::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::get__NewEnum( OUT IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< DiskVector, CComObject< CClusDisk > >( ppunk, m_dvDisks );

} //*** CClusDisks::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::Create
//
//	Description:
//		Finish creating the object by doing things that cannot be done in
//		a light weight constructor.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//		bstrResTypeName	[IN]	- The resource type this collection is for.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::Create(
	IN ISClusRefObject *	pClusRefObject,
	IN BSTR					bstrResTypeName
	)
{
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( pClusRefObject != NULL )
	{
		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();
		m_bstrResTypeName = bstrResTypeName;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusDisks::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::Refresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::Refresh( void )
{
	HRESULT			_hr = S_OK;
	DWORD			_sc = ERROR_SUCCESS;
	HCLUSTER		_hCluster = NULL;
	BOOL			_bEndFound = FALSE;

	_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
	if ( SUCCEEDED( _hr ) )
	{
		CClusPropValueList	_cpvl;
		DWORD				_sc = ERROR_SUCCESS;

		_sc = _cpvl.ScGetResourceTypeValueList(
										_hCluster,
										m_bstrResTypeName,
										CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS
										);
		_hr = HRESULT_FROM_WIN32( _sc );
		if ( SUCCEEDED( _hr ) )
		{
			Clear();

			_sc = _cpvl.ScMoveToFirstValue();
			_hr = HRESULT_FROM_WIN32( _sc );
			if ( SUCCEEDED( _hr ) )
			{
				CLUSPROP_BUFFER_HELPER	_cbhValue = { NULL };

				do
				{
					_cbhValue = _cpvl;

					if ( _cbhValue.pSyntax->dw  == CLUSPROP_SYNTAX_DISK_SIGNATURE )
					{
						_hr = HrCreateDisk( _cpvl, &_bEndFound );
					} // if: value list MUST start with signature!

				} while ( ! _bEndFound );	// do-while: there are values in the list

			} // if: we moved to the first value
		} // if: the value list of available disks was retrieved
	} // if: we have a cluster handle

	return _hr;

} //*** CClusDisks::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusDisks::HrCreateDisk
//
//	Description:
//		Create a CClusDisk object from the passed in value list and add it
//		to the collection.  This method assumes that the value list's curent
//		value is the disk signature.
//
//	Arguments:
//		rcpvl		[IN OUT]	- The value list to parse.
//		pbEndFound	[IN]		- Catches the end of list state.
//
//	Return Value:
//		S_OK, if successful, Win32 error code wrapped in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::HrCreateDisk(
	IN OUT	CClusPropValueList &	rcpvl,
	OUT		BOOL *					pbEndFound
	)
{
	CComObject< CClusDisk > *	_pDisk = NULL;
	HRESULT						_hr = S_FALSE;

	_hr = CComObject< CClusDisk >::CreateInstance( &_pDisk );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject< CClusDisk > >	_ptrDisk( _pDisk );

		_hr = _ptrDisk->HrCreate( rcpvl, pbEndFound );
		if ( SUCCEEDED( _hr ) )
		{
			m_dvDisks.insert( m_dvDisks.end(), _pDisk );
			_ptrDisk->AddRef();
		} // if:
	} // if:

	return _hr;

} //*** CClusDisks::HrCreateDisk()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusScsiAddress class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusScsiAddress::CClusScsiAddress
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusScsiAddress::CClusScsiAddress( void )
{
	m_piids			= (const IID *) iidCClusScsiAddress;
	m_piidsSize		= ARRAYSIZE( iidCClusScsiAddress );

}	//*** CClusScsiAddress::CClusScsiAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusScsiAddress::Create
//
//	Description:
//		Finish creating this object.
//
//	Arguments:
//		pcpi	[IN]	- points to the CLUS_PARTITION_INFO struct.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusScsiAddress::Create( IN const CLUS_SCSI_ADDRESS & rcsa )
{
	m_csa = rcsa;

	return S_OK;

} //*** CClusScsiAddress::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusScsiAddress::get_PortNumber
//
//	Description:
//		Get the disk's port number.
//
//	Arguments:
//		pvarPortNumber	[OUT]	- catches the port number.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_PortNumber( OUT VARIANT * pvarPortNumber )
{
	//ASSERT( pvarPortNumber != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPortNumber != NULL )
	{
		pvarPortNumber->bVal	= m_csa.PortNumber;
		pvarPortNumber->vt		= VT_UI1;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusScsiAddress::get_PortNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusScsiAddress::get_PathId
//
//	Description:
//		Get the disk's path id.
//
//	Arguments:
//		pvarPathId	[OUT]	- catches the path id.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_PathId( OUT VARIANT * pvarPathId )
{
	//ASSERT( pvarPathId != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPathId != NULL )
	{
		pvarPathId->bVal	= m_csa.PathId;
		pvarPathId->vt		= VT_UI1;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusScsiAddress::get_PathId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusScsiAddress::get_TargetId
//
//	Description:
//		Get the disk's target id.
//
//	Arguments:
//		pvarTargetId	[OUT]	- catches the target id.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_TargetId( OUT VARIANT * pvarTargetId )
{
	//ASSERT( pvarTargetId != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarTargetId != NULL )
	{
		pvarTargetId->bVal	= m_csa.TargetId;
		pvarTargetId->vt	= VT_UI1;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusScsiAddress::get_TargetId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusScsiAddress::get_Lun
//
//	Description:
//		Get the disk's Lun.
//
//	Arguments:
//		pvarLun	[OUT]	- catches the Lun.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_Lun( OUT VARIANT * pvarLun )
{
	//ASSERT( pvarLun != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarLun != NULL )
	{
		pvarLun->bVal	= m_csa.Lun;
		pvarLun->vt		= VT_UI1;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusScsiAddress::get_Lun()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusdisk.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClusDisk.h
//
//	Description:
//		Definition of the cluster disk class for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusDisk.cpp
//
//	Author:
//		Galen Barbee	(galenb)	11-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSDISK_H_
#define __CLUSDISK_H__

#ifndef __PARTITION_H__
	#include "Partition.h"
#endif // __PARTITION_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusDisk;
class CClusDisks;
class CClusScsiAddress;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusDisk
//
//	Description:
//		Cluster Disk Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusDisk, &IID_ISClusDisk, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusDisk, &CLSID_ClusDisk >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusDisk :
	public IDispatchImpl< ISClusDisk, &IID_ISClusDisk, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusDisk, &CLSID_ClusDisk >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusDisk( void );
	~CClusDisk( void );

BEGIN_COM_MAP(CClusDisk)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusDisk)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusDisk)
DECLARE_NO_REGISTRY()

private:
	CComObject< CClusPartitions > *	m_pPartitions;
	DWORD							m_dwSignature;
	DWORD							m_dwDiskNumber;
	CLUS_SCSI_ADDRESS				m_csaScsiAddress;

public:
	HRESULT Create( IN HRESOURCE hResource );

	HRESULT HrCreate( IN OUT CClusPropValueList & rcpvl, OUT BOOL * pbEndFound );

	STDMETHODIMP get_Signature( OUT long * plSignature );

	STDMETHODIMP get_ScsiAddress( OUT ISClusScsiAddress ** ppScsiAddress );

	STDMETHODIMP get_DiskNumber( OUT long * plDiskNumber );

	STDMETHODIMP get_Partitions( OUT ISClusPartitions ** ppPartitions );

}; //*** Class CClusDisk

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusDisks
//
//	Description:
//		Cluster Disk Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusDisks, &IID_ISClusDisks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusDisks, &CLSID_ClusDisks >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusDisks :
	public IDispatchImpl< ISClusDisks, &IID_ISClusDisks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusDisks, &CLSID_ClusDisks >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusDisks( void );
	~CClusDisks( void );

BEGIN_COM_MAP(CClusDisks)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusDisks)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusDisks)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN const CClusPropValueList & rcpvl );

	HRESULT Create( ISClusRefObject * pClusRefObject, BSTR bstrResTypeName );

private:
	typedef std::vector< CComObject< CClusDisk > * >	DiskVector;

	DiskVector			m_dvDisks;
	CComBSTR			m_bstrResTypeName;
	ISClusRefObject *	m_pClusRefObject;

	void	Clear( void );

	HRESULT GetIndex( VARIANT varIndex, UINT *pnIndex );

	HRESULT HrCreateDisk( IN OUT CClusPropValueList & rcpvl, OUT BOOL * pbEndFound );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusDisk ** ppDisk );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusDisks

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusScsiAddress
//
//	Description:
//		Cluster SCSI Address Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusScsiAddress, &IID_ISClusScsiAddress, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusScsiAddress, &CLSID_ClusScsiAddress >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusScsiAddress :
	public IDispatchImpl< ISClusScsiAddress, &IID_ISClusScsiAddress, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusScsiAddress, &CLSID_ClusScsiAddress >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusScsiAddress( void );

BEGIN_COM_MAP(CClusScsiAddress)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusScsiAddress)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusScsiAddress)
DECLARE_NO_REGISTRY()

private:
	CLUS_SCSI_ADDRESS	m_csa;

public:
	HRESULT Create( IN const CLUS_SCSI_ADDRESS & rcsa );

	STDMETHODIMP get_PortNumber( OUT VARIANT * pvarPortNumber );

	STDMETHODIMP get_PathId( OUT VARIANT * pvarPathId );

	STDMETHODIMP get_TargetId( OUT VARIANT * pvarTargetId );

	STDMETHODIMP get_Lun( OUT VARIANT * pvarLun );

}; //*** Class CClusScsiAddress

#endif // __CLUSDISK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\cluskeys.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClusKeys.cpp
//
//	Description:
//		Implementation of the cluster registry and crypto key collection
//		classes for the MSCLUS automation classes.
//
//	Author:
//		Galen Barbee	(galenb)	12-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#if CLUSAPI_VERSION >= 0x0500
	#include <PropList.h>
#else
	#include "PropList.h"
#endif // CLUSAPI_VERSION >= 0x0500

#include "ClusKeys.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *	iidCClusRegistryKeys[] =
{
	&IID_ISClusRegistryKeys
};

static const IID *	iidCClusCryptoKeys[] =
{
	&IID_ISClusCryptoKeys
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::CKeys
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CKeys::CKeys( void )
{
	m_pClusRefObject = NULL;

} //*** CKeys::CKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::~CKeys
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CKeys::~CKeys( void )
{
	Clear();

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	}

} //*** CKeys::~CKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrCreate
//
//	Description:
//		Finish creating the object by doing things that cannot be done in
//		a light weight constructor.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrCreate( IN ISClusRefObject * pClusRefObject )
{
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( pClusRefObject != NULL )
	{
		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();
		_hr = S_OK;
	}

	return _hr;

} //*** CKeys::HrCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::Clear
//
//	Description:
//		Empty the vector of keys.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CKeys::Clear( void )
{
	if ( ! m_klKeys.empty() )
	{
		KeyList::iterator	_itCurrent = m_klKeys.begin();
		KeyList::iterator	_itLast = m_klKeys.end();

		for ( ; _itCurrent != _itLast; _itCurrent++ )
		{
			delete (*_itCurrent);
		} // for:

		m_klKeys.erase( m_klKeys.begin(), _itLast );
	} // if:

} //*** CKeys::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::FindItem
//
//	Description:
//		Find the passed in key in the vector and return its index.
//
//	Arguments:
//		pwsKey	[IN]	- The node to find.
//		pnIndex	[OUT]	- Catches the node's index.
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::FindItem(
	IN	LPWSTR	pwsKey,
	OUT	ULONG *	pnIndex
	)
{
	//ASSERT( pwsKey != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pwsKey != NULL ) && ( pnIndex != NULL ) )
	{
		_hr = E_INVALIDARG;

		if ( ! m_klKeys.empty() )
		{
			CComBSTR *			_pKey = NULL;
			KeyList::iterator	_itCurrent = m_klKeys.begin();
			KeyList::iterator	_itLast = m_klKeys.end();
			ULONG				_iIndex;

			for ( _iIndex = 0; _itCurrent != _itLast; _itCurrent++, _iIndex++ )
			{
				_pKey = *_itCurrent;

				if ( _pKey && ( lstrcmpi( pwsKey, (*_pKey) ) == 0 ) )
				{
					*pnIndex = _iIndex;
					_hr = S_OK;
					break;
				} // if: match!
			} // for: each item in the vector
		} // if: the vector is not empty
	} // if: args not NULL

	return _hr;

} //*** CKeys::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrGetIndex
//
//	Description:
//		Convert the passed in 1 based index into a 0 based index.
//
//	Arguments:
//		varIndex	[IN]	- holds the 1 based index.
//		pnIndex		[OUT]	- catches the 0 based index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrGetIndex( IN VARIANT varIndex, OUT ULONG * pnIndex )
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		ULONG		_nIndex = 0;
		CComVariant	_var;

		*pnIndex = 0;

		_hr = _var.Attach( &varIndex );
		if ( SUCCEEDED( _hr ) )
		{
			// Check to see if the index is a number.
			_hr = _var.ChangeType( VT_I4 );
			if ( SUCCEEDED( _hr ) )
			{
				_nIndex = _var.lVal;
				_nIndex--; // Adjust index to be 0 relative instead of 1 relative
			} // if: the variant is a number
			else
			{
				// Check to see if the index is a string
				_hr = _var.ChangeType( VT_BSTR );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = FindItem( _var.bstrVal, &_nIndex );
				} // if: the variant is a string
			} // else:

			if ( SUCCEEDED( _hr ) )
			{
				if ( _nIndex < m_klKeys.size() )
				{
					*pnIndex = _nIndex;
				} // if: in range
				else
				{
					_hr = E_INVALIDARG;
				} // else: out of range
			} // if: we found an index value

			_var.Detach( &varIndex );
		} // if: we attched to the variant
	} // if: args not NULL

	return _hr;

} //*** CKeys::HrGetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrGetItem
//
//	Description:
//		Get the key at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- Contains the index of the requested key.
//		ppKey		[OUT]	- Catches the key.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrGetItem( IN VARIANT varIndex, OUT BSTR * ppKey )
{
	//ASSERT( ppKey != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppKey != NULL )
	{
		ULONG	_nIndex = 0;

		_hr = HrGetIndex( varIndex, &_nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			*ppKey = m_klKeys[ _nIndex ]->Copy();
			_hr = S_OK;
		}
	}

	return _hr;

} //*** CKeys::HrGetItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrRemoveAt
//
//	Description:
//		Remove the object from the vector at the passed in position.
//
//	Arguments:
//		pos	[IN]	- the position of the object to remove.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG if the position is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrRemoveAt( size_t pos )
{
	KeyList::iterator		_itCurrent = m_klKeys.begin();
	KeyList::const_iterator	_itLast = m_klKeys.end();
	HRESULT					_hr = E_INVALIDARG;
	size_t					_iIndex;

	for ( _iIndex = 0; ( _iIndex < pos ) && ( _itCurrent != _itLast ); _iIndex++, _itCurrent++ )
	{
	} // for:

	if ( _itCurrent != _itLast )
	{
		m_klKeys.erase( _itCurrent );
		_hr = S_OK;
	}

	return _hr;

} //*** CKeys::HrRemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrFindItem
//
//	Description:
//		Find the passed in key in the collection.
//
//	Arguments:
//		bstrKey	[IN]	- The key to find.
//		pnIndex	[OUT]	- Catches the index.
//
//	Return Value:
//		S_OK if found, or E_INVALIDARG if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrFindItem( IN BSTR bstrKey, OUT ULONG * pnIndex )
{
	HRESULT _hr = E_INVALIDARG;

	if ( ! m_klKeys.empty() )
	{
		KeyList::iterator	_itCurrent = m_klKeys.begin();
		KeyList::iterator	_itLast = m_klKeys.end();
		ULONG				_iIndex;

		for ( _iIndex = 0; _itCurrent != _itLast; _itCurrent++, _iIndex++ )
		{
			if ( lstrcmp( *(*_itCurrent), bstrKey ) == 0 )
			{
				*pnIndex = _iIndex;
				_hr = S_OK;
				break;
			}
		}
	} // if:

	return _hr;

} //*** CKeys::HrFindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrGetCount
//
//	Description:
//		Get the count of objects in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrGetCount( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_klKeys.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CKeys::HrGetCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrAddItem
//
//	Description:
//		Create a new key and add it to the collection.
//
//	Arguments:
//		bstrKey	[IN]	- Registry key to add to the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrAddItem( IN BSTR bstrKey )
{
	//ASSERT( bstrKey != NULL );

	HRESULT _hr = E_POINTER;

	if ( bstrKey != NULL )
	{
		ULONG _nIndex;

		_hr = HrFindItem( bstrKey, &_nIndex );
		if ( FAILED( _hr ) )
		{
			CComBSTR *	pbstr = NULL;

			pbstr = new CComBSTR( bstrKey );
			if ( pbstr != NULL )
			{
				m_klKeys.insert( m_klKeys.end(), pbstr );
				_hr = S_OK;
			} // if:
			else
			{
				_hr = E_OUTOFMEMORY;
			} // else:
		}
		else
		{
			_hr = E_INVALIDARG;
		} // else:
	}

	return _hr;

} //*** CKeys::HrAddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CKeys::HrRemoveItem
//
//	Description:
//		Remove the key at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- contains the index to remove.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrRemoveItem( IN VARIANT varIndex )
{
	HRESULT	_hr = S_OK;
	ULONG	_nIndex = 0;

	_hr = HrGetIndex( varIndex, &_nIndex );
	if ( SUCCEEDED( _hr ) )
	{
		delete m_klKeys[ _nIndex ];
		HrRemoveAt( _nIndex );
	}

	return _hr;

} //*** CKeys::HrRemoveItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceKeys::HrRefresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		dwControlCode	[IN]	- Control code
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResourceKeys::HrRefresh( IN DWORD dwControlCode )
{
	HRESULT	_hr = S_FALSE;
	PWSTR	_psz = NULL;
	DWORD	_cbPsz = 512;
	DWORD	_cbRequired = 0;
	DWORD	_sc = ERROR_SUCCESS;

	_psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
	if ( _psz != NULL )
	{
		_sc = ::ClusterResourceControl(
						m_hResource,
						NULL,
						dwControlCode,
						NULL,
						0,
						_psz,
						_cbPsz,
						&_cbRequired
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			::LocalFree( _psz );
			_psz = NULL;
			_cbPsz = _cbRequired;

			_psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
			if ( _psz != NULL )
			{
				_sc = ::ClusterResourceControl(
								m_hResource,
								NULL,
								dwControlCode,
								NULL,
								0,
								_psz,
								_cbPsz,
								&_cbRequired
								);
				_hr = HRESULT_FROM_WIN32( _sc );
			} // if: alloc OK
			else
			{
				_sc = GetLastError();
				_hr = HRESULT_FROM_WIN32( _sc );
			} // else: alloc failed
		} // if: error was no more item, re-alloc and try again.
		else
		{
			_hr = HRESULT_FROM_WIN32( _sc );
		} // else: error was not no more items -- could be no error

		if ( SUCCEEDED( _hr ) )
		{
			CComBSTR *	_pbstr = NULL;

			Clear();

			while( *_psz != L'\0' )
			{
				_pbstr = new CComBSTR( _psz );
				if ( _pbstr != NULL )
				{
					m_klKeys.insert( m_klKeys.end(), _pbstr );
					_psz += lstrlenW( _psz ) + 1;
					_pbstr = NULL;
				} // if:
				else
				{
					_hr = E_OUTOFMEMORY;
					break;
				} // else:
			} // while: not EOS
		} // if: keys were retrieved ok

		::LocalFree( _psz );
	} // if: alloc ok
	else
	{
		_sc = GetLastError();
		_hr = HRESULT_FROM_WIN32( _sc );
	} // else: alloc failed

	return _hr;

} //*** CResourceKeys::HrRefresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceKeys::HrAddItem
//
//	Description:
//		Create a new key and add it to the collection.
//
//	Arguments:
//		bstrKey			[IN]	- Registry key to add to the collection.
//		dwControlCode	[IN]	- Control code
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResourceKeys::HrAddItem(
	IN BSTR		bstrKey,
	IN DWORD	dwControlCode
	)
{
	//ASSERT( bstrKey != NULL );

	HRESULT _hr = E_POINTER;

	if ( bstrKey != NULL )
	{
		DWORD	_sc = ERROR_SUCCESS;

		_sc = ::ClusterResourceControl(
						m_hResource,
						NULL,
						dwControlCode,
						bstrKey,
						( lstrlenW( bstrKey) + 1) * sizeof( WCHAR ),
						NULL,
						0,
						NULL
						);
		_hr = HRESULT_FROM_WIN32( _sc );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = CKeys::HrAddItem( bstrKey );
		} // if:
	} // if:

	return _hr;

} //*** CResourceKeys::HrAddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceKeys::HrRemoveItem
//
//	Description:
//		Remove the key at the passed in index.
//
//	Arguments:
//		varIndex		[IN]	- contains the index to remove.
//		dwControlCode	[IN]	- Control code
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResourceKeys::HrRemoveItem(
	IN VARIANT	varIndex,
	IN DWORD	dwControlCode
	)
{
	HRESULT	_hr = S_OK;
	ULONG	_nIndex = 0;

	_hr = HrGetIndex( varIndex, &_nIndex );
	if ( SUCCEEDED( _hr ) )
	{
		DWORD		_sc = ERROR_SUCCESS;
		CComBSTR *	_pbstr = NULL;

		_pbstr = m_klKeys[ _nIndex ];

		_sc = ::ClusterResourceControl(
						m_hResource,
						NULL,
						dwControlCode,
						(BSTR) (*_pbstr),
						( _pbstr->Length() + 1 ) * sizeof( WCHAR ),
						NULL,
						0,
						NULL
						);
		_hr = HRESULT_FROM_WIN32( _sc );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = CKeys::HrRemoveItem( varIndex );
		}
	}

	return _hr;

} //*** CResourceKeys::HrRemoveItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResourceRegistryKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::CClusResourceRegistryKeys
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResourceRegistryKeys::CClusResourceRegistryKeys( void )
{
	m_hResource	= NULL;
	m_piids		= (const IID *) iidCClusRegistryKeys;
	m_piidsSize	= ARRAYSIZE( iidCClusRegistryKeys );

} //*** CClusResourceRegistryKeys::CClusResourceRegistryKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::Create
//
//	Description:
//		Finish creating the object by doing things that cannot be done in
//		a light weight constructor.
//
//	Arguments:
//		hResource	[IN]	- Resource this collection belongs to.
//
//	Return Value:
//		S_OK if successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResourceRegistryKeys::Create( IN HRESOURCE hResource )
{
	m_hResource = hResource;

	return S_OK;

} //*** CClusResourceRegistryKeys::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::get_Count
//
//	Description:
//		Get the count of objects in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::get_Count( OUT long * plCount )
{
	return CKeys::HrGetCount( plCount );

} //*** CClusResourceRegistryKeys::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::get_Item
//
//	Description:
//		Get the item (key) at the passed in index.
//
//	Arguments:
//		varIndex			[IN]	- Contains the index requested.
//		ppbstrRegistryKey	[OUT]	- Catches the key.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::get_Item(
	IN	VARIANT	varIndex,
	OUT	BSTR *	ppbstrRegistryKey
	)
{
	return HrGetItem( varIndex, ppbstrRegistryKey );

} //*** CClusResourceRegistryKeys::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewCComBSTREnum< KeyList >( ppunk, m_klKeys );

} //*** CClusResourceRegistryKeys::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::AddItem
//
//	Description:
//		Create a new item (key) and add it to the collection.
//
//	Arguments:
//		bstrRegistryKey	[IN]	- Registry key to add to the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::AddItem(
	IN BSTR bstrRegistryKey
	)
{
	return HrAddItem( bstrRegistryKey, CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT );

} //*** CClusResourceRegistryKeys::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::RemoveItem
//
//	Description:
//		Remove the item (key) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- contains the index to remove.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::RemoveItem( IN VARIANT varIndex )
{
	return HrRemoveItem( varIndex, CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT );

} //*** CClusResourceRegistryKeys::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceRegistryKeys::Refresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::Refresh( void )
{
	return HrRefresh( CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS );

} //*** CClusResourceRegistryKeys::Refresh()


//*************************************************************************//


#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
// CClusResourceCryptoKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::CClusResourceCryptoKeys
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResourceCryptoKeys::CClusResourceCryptoKeys( void )
{
	m_hResource	= NULL;
	m_piids		= (const IID *) iidCClusCryptoKeys;
	m_piidsSize	= ARRAYSIZE( iidCClusCryptoKeys );

} //*** CClusResourceCryptoKeys::CClusResourceCryptoKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::Create
//
//	Description:
//		Finish creating the object by doing things that cannot be done in
//		a light weight constructor.
//
//	Arguments:
//		hResource	[IN]	- Resource this collection belongs to.
//
//	Return Value:
//		S_OK if successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResourceCryptoKeys::Create( IN HRESOURCE hResource )
{
	m_hResource = hResource;

	return S_OK;

} //*** CClusResourceCryptoKeys::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::get_Count
//
//	Description:
//		Get the count of objects in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::get_Count( OUT long * plCount )
{
	return CKeys::HrGetCount( plCount );

} //*** CClusResourceCryptoKeys::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::get_Item
//
//	Description:
//		Get the item (key) at the passed in index.
//
//	Arguments:
//		varIndex			[IN]	- Contains the index requested.
//		ppbstrRegistryKey	[OUT]	- Catches the key.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::get_Item(
	IN	VARIANT	varIndex,
	OUT	BSTR *	ppbstrRegistryKey
	)
{
	return HrGetItem( varIndex, ppbstrRegistryKey );

} //*** CClusResourceCryptoKeys::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewCComBSTREnum< KeyList >( ppunk, m_klKeys );

} //*** CClusResourceCryptoKeys::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::AddItem
//
//	Description:
//		Create a new item (key) and add it to the collection.
//
//	Arguments:
//		bstrRegistryKey	[IN]	- Registry key to add to the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::AddItem(
	IN BSTR bstrRegistryKey
	)
{
	return HrAddItem( bstrRegistryKey, CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT );

} //*** CClusResourceCryptoKeys::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::RemoveItem
//
//	Description:
//		Remove the item (key) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- contains the index to remove.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::RemoveItem( IN VARIANT varIndex )
{
	return HrRemoveItem( varIndex, CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT );

} //*** CClusResourceCryptoKeys::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResourceCryptoKeys::Refresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::Refresh( void )
{
	return HrRefresh( CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS );

} //*** CClusResourceCryptoKeys::Refresh()

#endif // CLUSAPI_VERSION >= 0x0500


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResTypeKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResTypeKeys::HrRefresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		dwControlCode	[IN]	- Control code
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResTypeKeys::HrRefresh( IN DWORD dwControlCode )
{
	HRESULT		_hr = S_FALSE;
	PWSTR		_psz = NULL;
	DWORD		_cbPsz = 512;
	DWORD		_cbRequired = 0;
	DWORD		_sc = ERROR_SUCCESS;
	HCLUSTER	hCluster = NULL;

	_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
	if ( SUCCEEDED( _hr ) )
	{
		_psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
		if ( _psz != NULL )
		{
			_sc = ::ClusterResourceTypeControl(
							hCluster,
							m_bstrResourceTypeName,
							NULL,
							dwControlCode,
							NULL,
							0,
							_psz,
							_cbPsz,
							&_cbRequired
							);
			if ( _sc == ERROR_MORE_DATA )
			{
				::LocalFree( _psz );
				_psz = NULL;
				_cbPsz = _cbRequired;

				_psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
				if ( _psz != NULL )
				{
					_sc = ::ClusterResourceTypeControl(
									hCluster,
									m_bstrResourceTypeName,
									NULL,
									dwControlCode,
									NULL,
									0,
									_psz,
									_cbPsz,
									&_cbRequired
									);
					_hr = HRESULT_FROM_WIN32( _sc );
				} // if: alloc OK
				else
				{
					_sc = GetLastError();
					_hr = HRESULT_FROM_WIN32( _sc );
				} // else: alloc failed
			} // if: error was no more item, re-alloc and try again.
			else
			{
				_hr = HRESULT_FROM_WIN32( _sc );
			} // else: error was not no more items -- could be no error

			if ( SUCCEEDED( _hr ) )
			{
				CComBSTR *	_pbstr = NULL;

				Clear();

				while( *_psz != L'\0' )
				{
					_pbstr = new CComBSTR( _psz );
					if ( _pbstr != NULL )
					{
						m_klKeys.insert( m_klKeys.end(), _pbstr );
						_psz += lstrlenW( _psz ) + 1;
						_pbstr = NULL;
					} // if:
					else
					{
						_hr = E_OUTOFMEMORY;
						break;
					} // else:
				} // while: not EOS
			} // if: keys were retrieved ok
		} // if: alloc ok
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		} // else: alloc failed
	} // if: we got a cluster handle

	return _hr;

} //*** CResTypeKeys::HrRefresh()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\cluskeys.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClusKeys.h
//
//	Description:
//		Definition of the registry and crypto key collection classes for
//		the MSCLUS automation classes.
//
//	Implementation File:
//		ClusKeys.cpp
//
//	Author:
//		Galen Barbee	(galenb)	12-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSKEYS_H_
#define _CLUSKEYS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CKeys;
class CResourceKeys;
class CResTypeKeys;
class CClusResourceRegistryKeys;
class CClusResourceCryptoKeys;
class CClusResTypeRegistryKeys;
class CClusResTypeCryptoKeys;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CKeys
//
//	Description:
//		Cluster Keys Collection Implementation Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CKeys
{
public:
	CKeys( void );
	~CKeys( void );

protected:
	typedef std::vector< CComBSTR * >	KeyList;

	ISClusRefObject *	m_pClusRefObject;
	KeyList				m_klKeys;

	HRESULT HrCreate( ISClusRefObject * pClusRefObject );

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNodeName, OUT ULONG * pnIndex );

	HRESULT HrGetIndex( IN VARIANT varIndex, OUT ULONG * pnIndex );

	HRESULT HrGetItem( IN VARIANT varIndex, OUT BSTR * ppKey );

	HRESULT HrRemoveAt( IN size_t pos );

	HRESULT HrFindItem( IN BSTR bstrKey, OUT ULONG * pnIndex );

	HRESULT HrGetCount( OUT long * plCount );

	virtual HRESULT HrRemoveItem( IN VARIANT varIndex );

	virtual HRESULT HrAddItem( IN BSTR bstrKey );

}; //*** Class CKeys

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CResourceKeys
//
//	Description:
//		Cluster Resource Keys Collection Implementation Class.
//
//	Inheritance:
//		CKeys
//
//--
/////////////////////////////////////////////////////////////////////////////
class CResourceKeys: public CKeys
{
protected:
	HRESOURCE	m_hResource;

	HRESULT	HrRefresh( DWORD dwControlCode );

	virtual HRESULT HrRemoveItem( IN VARIANT varIndex, IN DWORD dwControlCode );

	virtual HRESULT HrAddItem( IN BSTR bstrKey, IN DWORD dwControlCode );

}; //*** Class CResourceKeys

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CResTypeKeys
//
//	Description:
//		Cluster Resource Keys Collection Implementation Class.
//
//	Inheritance:
//		CKeys
//
//--
/////////////////////////////////////////////////////////////////////////////
class CResTypeKeys: public CKeys
{
protected:
	CComBSTR	m_bstrResourceTypeName;

	HRESULT	HrRefresh( DWORD dwControlCode );

}; //*** Class CResTypeKeys

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResourceRegistryKeys
//
//	Description:
//		Cluster Registry Keys Collection Automation Class.
//
//	Inheritance:
//		CResourceKeys
//		IDispatchImpl< ISClusRegistryKeys, &IID_ISClusRegistryKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< ClusRegistryKeys, &CLSID_ClusRegistryKeys >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResourceRegistryKeys :
	public CResourceKeys,
	public IDispatchImpl< ISClusRegistryKeys, &IID_ISClusRegistryKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< ClusRegistryKeys, &CLSID_ClusRegistryKeys >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResourceRegistryKeys( void );

BEGIN_COM_MAP(CClusResourceRegistryKeys)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusRegistryKeys)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResourceRegistryKeys)
DECLARE_NO_REGISTRY()

	HRESULT Create( HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * ppbstrRegistryKey );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP AddItem( IN BSTR bstrRegistryKey );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResourceRegistryKeys

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResourceCryptoKeys
//
//	Description:
//		Cluster Crypto Keys Collection Automation Class.
//
//	Inheritance:
//		CResourceKeys
//		IDispatchImpl< ISClusCryptoKeys, &IID_ISClusCryptoKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< ClusCryptoKeys, &CLSID_ClusCryptoKeys >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResourceCryptoKeys :
	public CResourceKeys,
	public IDispatchImpl< ISClusCryptoKeys, &IID_ISClusCryptoKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< ClusCryptoKeys, &CLSID_ClusCryptoKeys >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResourceCryptoKeys( void );

BEGIN_COM_MAP(CClusResourceCryptoKeys)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusCryptoKeys)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResourceCryptoKeys)
DECLARE_NO_REGISTRY()

	HRESULT Create( HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * ppbstrCryptoKey );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP AddItem( IN BSTR bstrCryptoKey );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResourceCryptoKeys

#endif // CLUSAPI_VERSION >= 0x0500

#endif // _CLUSKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusneti.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusNetI.h
//
//	Description:
//		Definition of the network interface classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusNetI.cpp
//
//	Author:
//		Ramakrishna Rosanuru via David Potter	(davidp)	5-Sep-1997
//		Galen Barbee							(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNETI_H_
#define _CLUSNETI_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNetInterface;
class CNetInterfaces;
class CClusNetInterfaces;
class CClusNetworkNetInterfaces;
class CClusNodeNetInterfaces;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetInterface
//
//	Description:
//		Cluster Net Interface Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetInterface, &IID_ISClusNetInterface, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNetInterface, &CLSID_ClusNetInterface >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetInterface :
	public IDispatchImpl< ISClusNetInterface, &IID_ISClusNetInterface, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNetInterface, &CLSID_ClusNetInterface >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetInterface( void );
	~CClusNetInterface( void );

BEGIN_COM_MAP(CClusNetInterface)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetInterface)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetInterface)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *				m_pClusRefObject;
	HNETINTERFACE					m_hNetInterface;
	CComObject< CClusProperties > *	m_pCommonProperties;
	CComObject< CClusProperties > *	m_pPrivateProperties;
	CComObject< CClusProperties > *	m_pCommonROProperties;
	CComObject< CClusProperties > *	m_pPrivateROProperties;
	CComBSTR						m_bstrNetInterfaceName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Open( IN ISClusRefObject* pClusRefObject, IN BSTR bstrNetInterfaceName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP get_Name( OUT BSTR * pbstrNetInterfaceName );

	STDMETHODIMP get_State( OUT CLUSTER_NETINTERFACE_STATE * dwState );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrNetInterfaceName ; };

}; //*** Class CClusNetInterface

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CNetInterfaces
//
//	Description:
//		Cluster Net Interfaces Collection Implementation Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CNetInterfaces
{
public:
	CNetInterfaces( void );
	~CNetInterfaces( void );

	HRESULT Create( IN ISClusRefObject * pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusNetInterface > * > NetInterfacesList;

	ISClusRefObject *	m_pClusRefObject;
	NetInterfacesList	m_NetInterfaceList;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNetInterfaceName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusNetInterface * pClusterNetInterface, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetItem( IN LPWSTR lpszNetInterfaceName, OUT ISClusNetInterface ** ppClusterNetInterface );

	HRESULT GetItem( IN UINT nIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	HRESULT GetNetInterfaceItem( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

}; //*** Class CNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetInterfaces
//
//	Description:
//		Cluster Net Interfaces Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetInterfaces, &IID_ISClusNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNetInterfaces
//		CComCoClass< CClusNetInterfaces, &CLSID_ClusNetInterfaces >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetInterfaces :
	public IDispatchImpl< ISClusNetInterfaces, &IID_ISClusNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNetInterfaces,
	public CComCoClass< CClusNetInterfaces, &CLSID_ClusNetInterfaces >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetInterfaces( void );
	~CClusNetInterfaces( void );

BEGIN_COM_MAP(CClusNetInterfaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetInterfaces)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetInterfaces)
DECLARE_NO_REGISTRY()

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetworkNetInterfaces
//
//	Description:
//		Cluster Network Net Interfaces collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetworkNetInterfaces, &IID_ISClusNetworkNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >,
//		CNetInterfaces
//		CComCoClass< CClusNetworkNetInterfaces, &CLSID_ClusNetworkNetInterfaces >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetworkNetInterfaces :
	public IDispatchImpl< ISClusNetworkNetInterfaces, &IID_ISClusNetworkNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNetInterfaces,
	public CComCoClass< CClusNetworkNetInterfaces, &CLSID_ClusNetworkNetInterfaces >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetworkNetInterfaces( void );
	~CClusNetworkNetInterfaces( void );

BEGIN_COM_MAP(CClusNetworkNetInterfaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetworkNetInterfaces)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetworkNetInterfaces)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HNETWORK hNetwork );

private:
	HNETWORK	m_hNetwork;

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNetworkNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNodeNetInterfaces
//
//	Description:
//		Cluster Node Net Interfaces collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNodeNetInterfaces, &IID_ISClusNodeNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >,
//		CNetInterfaces
//		CComCoClass< CClusNodeNetInterfaces, &CLSID_ClusNodeNetInterfaces >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNodeNetInterfaces	:
	public IDispatchImpl< ISClusNodeNetInterfaces, &IID_ISClusNodeNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNetInterfaces,
	public CComCoClass< CClusNodeNetInterfaces, &CLSID_ClusNodeNetInterfaces >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNodeNetInterfaces( void );
	~CClusNodeNetInterfaces( void );

BEGIN_COM_MAP(CClusNodeNetInterfaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNodeNetInterfaces)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNodeNetInterfaces)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HNODE hNode );

private:
	HNODE	m_hNode;

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNodeNetInterfaces

#endif // _CLUSNETI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusneti.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		 ClusNetI.cpp
//
//	Description:
//		 Implementation of the network interface classes for the MSCLUS
//		 automation classes.
//
//	Author:
//		 Ramakrishna Rosanuru via David Potter	(davidp)	5-Sep-1997
//		Galen Barbee							(galenb)	July 1998
//
//	Revision History:
//		 July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusneti.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID * iidCClusNetInterface[] =
{
	&IID_ISClusNetInterface
};

static const IID * iidCClusNetInterfaces[] =
{
	&IID_ISClusNetInterface
};

static const IID * iidCClusNetworkNetInterfaces[] =
{
	&IID_ISClusNetworkNetInterfaces
};

static const IID * iidCClusNodeNetInterfaces[] =
{
	&IID_ISClusNodeNetInterfaces
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetInterface class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::CClusNetInterface
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterface::CClusNetInterface( void )
{
	m_hNetInterface			= NULL;
	m_pCommonProperties		= NULL;
	m_pPrivateProperties	= NULL;
	m_pCommonROProperties	= NULL;
	m_pPrivateROProperties	= NULL;
	m_pClusRefObject		= NULL;
	m_piids					= (const IID *) iidCClusNetInterface;
	m_piidsSize				= ARRAYSIZE( iidCClusNetInterface );

} //*** CClusNetInterface::CClusNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::~CClusNetInterface
//
//	Description:
//		destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterface::~CClusNetInterface( void )
{
	if ( m_hNetInterface != NULL )
	{
		::CloseClusterNetInterface( m_hNetInterface );
	} // if:

	if ( m_pCommonProperties != NULL )
	{
		m_pCommonProperties->Release();
		m_pCommonProperties = NULL;
	} // if: release the property collection

	if ( m_pPrivateProperties != NULL )
	{
		m_pPrivateProperties->Release();
		m_pPrivateProperties = NULL;
	} // if: release the property collection

	if ( m_pCommonROProperties != NULL )
	{
		m_pCommonROProperties->Release();
		m_pCommonROProperties = NULL;
	} // if: release the property collection

	if ( m_pPrivateROProperties != NULL )
	{
		m_pPrivateROProperties->Release();
		m_pPrivateROProperties = NULL;
	} // if: release the property collection

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	} // if: do we have a pointer to the cluster handle wrapper?

} //*** CClusNetInterface::~CClusNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::Open
//
//	Description:
//		Open the passed in network interface.
//
//	Arguments:
//		pClusRefObject			[IN]	- Wraps the cluster handle.
//		bstrNetInterfaceName	[IN]	- The name of the interface to open.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetInterface::Open(
	IN ISClusRefObject *	pClusRefObject,
	IN BSTR					bstrNetInterfaceName
	)
{
	ASSERT( pClusRefObject != NULL );
	//ASSERT( bstrNetInterfaceName != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pClusRefObject != NULL ) && ( bstrNetInterfaceName != NULL ) )
	{
		HCLUSTER	 _hCluster;

		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();

		_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
		if ( SUCCEEDED( _hr ) )
		{
			m_hNetInterface = OpenClusterNetInterface( _hCluster, bstrNetInterfaceName );
			if ( m_hNetInterface == 0 )
			{
				DWORD	_sc = GetLastError();

				_hr = HRESULT_FROM_WIN32( _sc );
			} // if: it failed
			else
			{
				m_bstrNetInterfaceName = bstrNetInterfaceName;
				_hr = S_OK;
			} // else: it worked
		} // if: we have a cluster handle
	} // if: the args are not NULL

	return _hr;

} //*** CClusNetInterface::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::GetProperties
//
//	Description:
//		Creates a property collection for this object type
//		(Network Interface).
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the newly created collection.
//		bPrivate		[IN]	- Are these private properties? Or Common?
//		bReadOnly		[IN]	- Are these read only properties?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetInterface::GetProperties(
	ISClusProperties **	ppProperties,
	BOOL				bPrivate,
	BOOL				bReadOnly
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		*ppProperties = NULL;

		CComObject< CClusProperties > * pProperties = NULL;

		_hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< CClusProperties > >	ptrProperties( pProperties );

			_hr = ptrProperties->Create( this, bPrivate, bReadOnly );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrProperties->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
					if ( SUCCEEDED( _hr ) )
					{
						ptrProperties->AddRef();

						if ( bPrivate )
						{
							if ( bReadOnly )
							{
								m_pPrivateROProperties = pProperties;
							}
							else
							{
								m_pPrivateProperties = pProperties;
							}
						}
						else
						{
							if ( bReadOnly )
							{
								m_pCommonROProperties = pProperties;
							}
							else
							{
								m_pCommonProperties = pProperties;
							}
						}
					}
				}
			}
		}
	}

	return _hr;

} //*** CClusNetInterface::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_Handle
//
//	Description:
//		Return the raw handle to this objec (Netinterface).
//
//	Arguments:
//		phandle	[OUT]	- Catches the handle.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_Handle( OUT ULONG_PTR * phandle )
{
	//ASSERT( phandle != NULL );

	HRESULT _hr = E_POINTER;

	if ( phandle != NULL )
	{
		*phandle = (ULONG_PTR) m_hNetInterface;
		_hr = S_OK;
	} // if: args are not NULL

	return _hr;

} //*** CClusNetInterface::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_Name
//
//	Description:
//		Return the name of this object (Network Interface).
//
//	Arguments:
//		pbstrNetInterfaceName	[OUT]	- Catches the name of this object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_Name( OUT BSTR * pbstrNetInterfaceName )
{
	//ASSERT( pbstrNetInterfaceName != NULL );

	HRESULT _hr = E_POINTER;

	if ( pbstrNetInterfaceName != NULL )
	{
		*pbstrNetInterfaceName = m_bstrNetInterfaceName.Copy();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusNetInterface::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_State
//
//	Description:
//		Return the current state of the object (Netinterface).
//
//	Arguments:
//		cnisState	[OUT]	- Catches the state.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_State(
	OUT CLUSTER_NETINTERFACE_STATE * cnisState
	)
{
	//ASSERT( cnisState != NULL );

	HRESULT _hr = E_POINTER;

	if ( cnisState != NULL )
	{
		CLUSTER_NETINTERFACE_STATE _cnis = GetClusterNetInterfaceState( m_hNetInterface );

		if ( _cnis == ClusterNetInterfaceStateUnknown )
		{
			DWORD	_sc = GetLastError();

			_hr = HRESULT_FROM_WIN32( _sc );
		}
		else
		{
			*cnisState = _cnis;
			_hr = S_OK;
		}
	}

	return _hr;

} //*** CClusNetInterface::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_CommonProperties
//
//	Description:
//		Get this object's (Network Interface) common properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_CommonProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pCommonProperties )
		{
			_hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, FALSE, FALSE );
		}
	}

	return _hr;

} //*** CClusNetInterface::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_PrivateProperties
//
//	Description:
//		Get this object's (Network Interface) private properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_PrivateProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pPrivateProperties )
		{
			_hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, TRUE, FALSE );
		}
	}

	return _hr;

} //*** CClusNetInterface::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_CommonROProperties
//
//	Description:
//		Get this object's (Network Interface) common read only properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_CommonROProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pCommonROProperties )
		{
			_hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, FALSE, TRUE );
		}
	}

	return _hr;

} //*** CClusNetInterface::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_PrivateROProperties
//
//	Description:
//		Get this object's (Network Interface) private read only properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_PrivateROProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pPrivateROProperties )
		{
			_hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, TRUE, TRUE );
		}
	}

	return _hr;

} //*** CClusNetInterface::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::get_Cluster
//
//	Description:
//		Return the cluster this object (Netinterface) belongs to.
//
//	Arguments:
//		ppCluster	[OUT]	- Catches the cluster.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_Cluster( OUT ISCluster ** ppCluster )
{
	return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusNetInterface::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::HrLoadProperties
//
//	Description:
//		This virtual function does the actual load of the property list from
//		the cluster.
//
//	Arguments:
//		rcplPropList	[IN OUT]	- The property list to load.
//		bReadOnly		[IN]		- Load the read only properties?
//		bPrivate		[IN]		- Load the common or the private properties?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetInterface::HrLoadProperties(
	IN OUT	CClusPropList &	rcplPropList,
	IN		BOOL			bReadOnly,
	IN		BOOL			bPrivate
	)
{
	HRESULT	_hr = S_FALSE;
	DWORD	_dwControlCode = 0;
	DWORD	_sc = ERROR_SUCCESS;


	if ( bReadOnly )
	{
		_dwControlCode = bPrivate
						? CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES
						: CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;
	}
	else
	{
		_dwControlCode = bPrivate
						? CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
						: CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;
	} // else:

	_sc = rcplPropList.ScGetNetInterfaceProperties( m_hNetInterface, _dwControlCode );

	_hr = HRESULT_FROM_WIN32( _sc );

	return _hr;

} //*** CClusNetInterface::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterface::ScWriteProperties
//
//	Description:
//		This virtual function does the actual saving of the property list to
//		the cluster.
//
//	Arguments:
//		rcplPropList	[IN]	- The property list to save.
//		bPrivate		[IN]	- Save the common or the private properties?
//
//	Return Value:
//		ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusNetInterface::ScWriteProperties(
	const CClusPropList &	rcplPropList,
	BOOL					bPrivate
	)
{
	DWORD	_dwControlCode	= bPrivate ? CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES : CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;
	DWORD	_nBytesReturned	= 0;
	DWORD	_sc				= ERROR_SUCCESS;

	_sc = ClusterNetInterfaceControl(
						m_hNetInterface,
						NULL,
						_dwControlCode,
						rcplPropList,
						rcplPropList.CbBufferSize(),
						0,
						0,
						&_nBytesReturned
						);

	return _sc;

} //*** CClusNetInterface::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::CNetInterfaces
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaces::CNetInterfaces( void )
{
	m_pClusRefObject = NULL;

} //*** CNetInterfaces::CNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::~CNetInterfaces
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaces::~CNetInterfaces( void )
{
	Clear();

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	} // if: do we have a pointer to the cluster handle wrapper?

} //*** CNetInterfaces::~CNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::Create( IN ISClusRefObject * pClusRefObject )
{
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( pClusRefObject != NULL )
	{
		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();
		_hr = S_OK;
	}

	return _hr;

} //*** CNetInterfaces::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::Clear
//
//	Description:
//		Empty the collection of net interfaces.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterfaces::Clear( void )
{
	::ReleaseAndEmptyCollection< NetInterfacesList, CComObject< CClusNetInterface > >( m_NetInterfaceList );

} //*** CNetInterfaces::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::FindItem
//
//	Description:
//		Find a net interface in the collection by name and return its index.
//
//	Arguments:
//		pszNetInterfaceName	[IN]	- The name to look for.
//		pnIndex				[OUT]	- Catches the index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::FindItem(
	IN	LPWSTR pszNetInterfaceName,
	OUT	UINT * pnIndex
	)
{
	//ASSERT( pszNetInterfaceName != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pszNetInterfaceName != NULL ) && ( pnIndex != NULL ) )
	{
		CComObject< CClusNetInterface > *	_pNetInterface = NULL;
		NetInterfacesList::iterator			_first = m_NetInterfaceList.begin();
		NetInterfacesList::iterator			_last = m_NetInterfaceList.end();
		int									_idx = 0;

		_hr = E_INVALIDARG;

		for ( ; _first != _last; _first++, _idx++ )
		{
			_pNetInterface = *_first;

			if ( _pNetInterface && ( lstrcmpi( pszNetInterfaceName, _pNetInterface->Name() ) == 0 ) )
			{
				*pnIndex = _idx;
				_hr = S_OK;
				break;
			}
		}
	}

	return _hr;

} //*** CNetInterfaces::FindItem( pszNetInterfaceName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::FindItem
//
//	Description:
//		Find a net interface in the collection and return its index.
//
//	Arguments:
//		pClusterNetInterface	[IN]	- The net interface to look for.
//		pnIndex					[OUT]	- Catches the index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::FindItem(
	IN	ISClusNetInterface *	pClusterNetInterface,
	OUT	UINT *					pnIndex
	)
{
	//ASSERT( pClusterNetInterface != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pClusterNetInterface != NULL ) && ( pnIndex != NULL ) )
	{
		CComBSTR _bstrName;

		_hr = pClusterNetInterface->get_Name( &_bstrName );

		if ( SUCCEEDED( _hr ) )
		{
			_hr = FindItem( _bstrName, pnIndex );
		}
	}

	return _hr;

} //*** CNetInterfaces::FindItem( pClusterNetInterface )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::GetIndex
//
//	Description:
//		Convert the passed in variant index into the real index in the
//		collection.
//
//	Arguments:
//		varIndex	[IN]	- The index to convert.
//		pnIndex		[OUT]	- Catches the index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetIndex(
	IN	VARIANT	varIndex,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		UINT		_nIndex = 0;
		CComVariant _v;

		*pnIndex = 0;

		_v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = _v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			_nIndex = _v.lVal;
			_nIndex--; // Adjust index to be 0 relative instead of 1 relative
		} // if: the index is a number
		else
		{
			// Check to see if the index is a string.
			_hr = _v.ChangeType( VT_BSTR );
			if ( SUCCEEDED( _hr ) )
			{
				// Search for the string.
				_hr = FindItem( _v.bstrVal, &_nIndex );
			} // if: the index is a string -- the net interface name
		} // else: not a number

		// We found an index, now check the range.
		if ( SUCCEEDED( _hr ) )
		{
			if ( _nIndex < m_NetInterfaceList.size() )
			{
				*pnIndex = _nIndex;
			} // if: index is in range
			else
			{
				_hr = E_INVALIDARG;
			} // else: index out of range
		} // if: did we find an index?
	} // if: args are not NULL

	return _hr;

} //*** CNetInterfaces::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::GetItem
//
//	Description:
//		Return the item (Netinterface) by name.
//
//	Arguments:
//		pszNetInterfaceName		[IN]	- The name of the item requested.
//		ppClusterNetInterface	[OUT]	- Catches the item.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetItem(
	IN	LPWSTR					pszNetInterfaceName,
	OUT	ISClusNetInterface **	ppClusterNetInterface
	)
{
	//ASSERT( pszNetInterfaceName != NULL );
	//ASSERT( ppClusterNetInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pszNetInterfaceName != NULL ) && ( ppClusterNetInterface != NULL ) )
	{
		CComObject< CClusNetInterface > *	_pNetInterface = NULL;
		NetInterfacesList::iterator			_first	= m_NetInterfaceList.begin();
		NetInterfacesList::iterator			_last	= m_NetInterfaceList.end();

		_hr = E_INVALIDARG;

		for ( ; _first != _last; _first++ )
		{
			_pNetInterface = *_first;

			if ( _pNetInterface && ( lstrcmpi( pszNetInterfaceName, _pNetInterface->Name() ) == 0 ) )
			{
				_hr = _pNetInterface->QueryInterface( IID_ISClusNetInterface, (void **) ppClusterNetInterface );
				break;
			} // if: match?
		} // for:
	} // if: args are not NULL

	return _hr;

} //*** CNetInterfaces::GetItem( pszNetInterfaceName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::GetItem
//
//	Description:
//		Return the item (Netinterface) at the passed in index.
//
//	Arguments:
//		nIndex					[IN]	- The index of the item requested.
//		ppClusterNetInterface	[OUT]	- Catches the item.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetItem(
	IN	UINT					nIndex,
	OUT	ISClusNetInterface **	ppClusterNetInterface
	)
{
	//ASSERT( ppClusterNetInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppClusterNetInterface != NULL )
	{
		//
		// Automation collections are 1-relative for languages like VB.
		// We are 0-relative internally.
		//
		nIndex--;

		if ( nIndex < m_NetInterfaceList.size() )
		{
			CComObject< CClusNetInterface > * _pNetInterface = m_NetInterfaceList[ nIndex ];

			_hr = _pNetInterface->QueryInterface( IID_ISClusNetInterface, (void **) ppClusterNetInterface );
		} // if: index is in range
		else
		{
			_hr = E_INVALIDARG;
		} // else: index is out of range
	}

	return _hr;

} //*** CNetInterfaces::GetItem( nIndex )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaces::GetNetInterfaceItem
//
//	Description:
//		Return the object (Netinterface) at the passed in index.
//
//	Arguments:
//		varIndex				[IN]	- Contains the index.
//		ppClusterNetInterface	[OUT]	- Catches the item.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetNetInterfaceItem(
	IN	VARIANT					varIndex,
	OUT	ISClusNetInterface **	ppClusterNetInterface
	)
{
	//ASSERT( ppClusterNetInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppClusterNetInterface != NULL )
	{
		CComObject< CClusNetInterface > *	_pNetInterface = NULL;
		UINT								_nIndex = 0;

		*ppClusterNetInterface = NULL;

		_hr = GetIndex( varIndex, &_nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			_pNetInterface = m_NetInterfaceList[ _nIndex ];

			_hr = _pNetInterface->QueryInterface( IID_ISClusNetInterface, (void **) ppClusterNetInterface );
		} // if: we have a proper index
	} // if: args are not NULL

	return _hr;

} //*** CNetInterfaces::GetNetInterfaceItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterfaces::CClusNetInterfaces
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterfaces::CClusNetInterfaces( void )
{
	m_piids		= (const IID *) iidCClusNetInterfaces;
	m_piidsSize = ARRAYSIZE( iidCClusNetInterfaces );

} //*** CClusNetInterfaces::CClusNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterfaces::~CClusNetInterfaces
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterfaces::~CClusNetInterfaces( void )
{
	Clear();

} //*** CClusNetInterfaces::~CClusNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterfaces::get_Count
//
//	Description:
//		Return the count of objects (Netinterfaces) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_NetInterfaceList.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusNetInterfaces::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterfaces::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< NetInterfacesList, CComObject< CClusNetInterface > >( ppunk, m_NetInterfaceList );

} //*** CClusNetInterfaces::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterfaces::Refresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::Refresh( void )
{
	ASSERT( m_pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( m_pClusRefObject != NULL )
	{
		HCLUSENUM	_hEnum = NULL;
		HCLUSTER	_hCluster;
		DWORD		_sc = ERROR_SUCCESS;

		_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
		if ( SUCCEEDED( _hr ) )
		{
			_hEnum = ::ClusterOpenEnum( _hCluster, CLUSTER_ENUM_NETINTERFACE );
			if ( _hEnum != NULL )
			{
				int									_nIndex = 0;
				DWORD								_dwType;
				LPWSTR								_pszName = NULL;
				CComObject< CClusNetInterface > *	_pNetInterface = NULL;

				Clear();

				for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
				{
					_sc = ::WrapClusterEnum( _hEnum, _nIndex, &_dwType, &_pszName );
					if ( _sc == ERROR_NO_MORE_ITEMS )
					{
						_hr = S_OK;
						break;
					}
					else if ( _sc == ERROR_SUCCESS )
					{
						_hr = CComObject< CClusNetInterface >::CreateInstance( &_pNetInterface );
						if ( SUCCEEDED( _hr ) )
						{
							CSmartPtr< ISClusRefObject >					_ptrRefObject( m_pClusRefObject );
							CSmartPtr< CComObject< CClusNetInterface > >	_ptrNetInterface( _pNetInterface );

							_hr = _ptrNetInterface->Open( _ptrRefObject, _pszName );
							if ( SUCCEEDED( _hr ) )
							{
								_ptrNetInterface->AddRef();
								m_NetInterfaceList.insert( m_NetInterfaceList.end(), _ptrNetInterface );
							}
						}

						::LocalFree( _pszName );
						_pszName = NULL;
					}
					else
					{
						_hr = HRESULT_FROM_WIN32( _sc );
					}
				}

				::ClusterCloseEnum( _hEnum );
			}
			else
			{
				_sc = GetLastError();
				_hr = HRESULT_FROM_WIN32( _sc );
			}
		}
	}

	return _hr;

} //*** CClusNetInterfaces::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetInterfaces::get_Item
//
//	Description:
//		Return the object (Netinterface) at the passed in index.
//
//	Arguments:
//		varIndex				[IN]	- Contains the index requested.
//		ppClusterNetInterface	[OUT]	- Catches the item.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::get_Item(
	IN	VARIANT					varIndex,
	OUT	ISClusNetInterface **	ppClusterNetInterface
	)
{
	//ASSERT( ppClusterNetInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppClusterNetInterface != NULL )
	{
		_hr = GetNetInterfaceItem( varIndex, ppClusterNetInterface );
	}

	return _hr;

} //*** CClusNetInterfaces::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetworkNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::CClusNetworkNetInterfaces
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkNetInterfaces::CClusNetworkNetInterfaces( void )
{
	m_piids		= (const IID *) iidCClusNetworkNetInterfaces;
	m_piidsSize	= ARRAYSIZE( iidCClusNetworkNetInterfaces );

} //*** CClusNetworkNetInterfaces::CClusNetworkNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::~CClusNetworkNetInterfaces
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkNetInterfaces::~CClusNetworkNetInterfaces( void )
{
	Clear();

} //*** CClusNetworkNetInterfaces::~CClusNetworkNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::Create
//
//	Description:
//		Complete the heavy weight construction.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//		hNetwork		[IN]	- The handle of the network whose netinterfaces
//								this collection holds.  The parent.
//
//	Return Value:
//		S_OK if successful, or E_POINTER is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworkNetInterfaces::Create(
	IN ISClusRefObject *	pClusRefObject,
	IN HNETWORK				hNetwork
	)
{
	HRESULT _hr = E_POINTER;

	_hr = CNetInterfaces::Create( pClusRefObject );
	if ( SUCCEEDED( _hr ) )
	{
		m_hNetwork = hNetwork;
	} // if: args are not NULL

	return _hr;

} //*** CClusNetworkNetInterfaces::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::get_Count
//
//	Description:
//		Return the count of objects (NetworkNetinterfaces) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_NetInterfaceList.size();
		_hr = S_OK;
	} // if: args are not NULL

	return _hr;

} //*** CClusNetworkNetInterfaces::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< NetInterfacesList, CComObject< CClusNetInterface > >( ppunk, m_NetInterfaceList );

} //*** CClusNetworkNetInterfaces::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::Refresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::Refresh( void )
{
	HRESULT _hr = E_POINTER;
	DWORD	_sc = ERROR_SUCCESS;

	if ( m_hNetwork != NULL )
	{
		HNETWORKENUM _hEnum = NULL;

		_hEnum = ::ClusterNetworkOpenEnum( m_hNetwork, CLUSTER_NETWORK_ENUM_NETINTERFACES );
		if ( _hEnum != NULL )
		{
			int									_nIndex = 0;
			DWORD								_dwType;
			LPWSTR								_pszName = NULL;
			CComObject< CClusNetInterface > *	_pNetInterface = NULL;

			Clear();

			for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
			{
				_sc = ::WrapClusterNetworkEnum( _hEnum, _nIndex, &_dwType, &_pszName );
				if ( _sc == ERROR_NO_MORE_ITEMS )
				{
					_hr = S_OK;
					break;
				}
				else if ( _sc == ERROR_SUCCESS )
				{
					_hr = CComObject< CClusNetInterface >::CreateInstance( &_pNetInterface );
					if ( SUCCEEDED( _hr ) )
					{
						CSmartPtr< ISClusRefObject >					_ptrRefObject( m_pClusRefObject );
						CSmartPtr< CComObject< CClusNetInterface > >	_ptrNetInterface( _pNetInterface );

						_hr = _ptrNetInterface->Open( _ptrRefObject, _pszName );
						if ( SUCCEEDED( _hr ) )
						{
							_ptrNetInterface->AddRef();
							m_NetInterfaceList.insert( m_NetInterfaceList.end(), _ptrNetInterface );
						}
					}

					::LocalFree( _pszName );
					_pszName = NULL;
				}
				else
				{
					_hr = HRESULT_FROM_WIN32( _sc );
				}
			}

			::ClusterNetworkCloseEnum( _hEnum );
		}
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusNetworkNetInterfaces::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNetworkNetInterfaces::get_Item
//
//	Description:
//		Return the object (NetworkNetinterface) at the passed in index.
//
//	Arguments:
//		varIndex				[IN]	- Contains the index requested.
//		ppClusterNetInterface	[OUT]	- Catches the item.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::get_Item(
	VARIANT					varIndex,
	ISClusNetInterface **	ppClusterNetInterface
	)
{
	//ASSERT( ppClusterNetInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppClusterNetInterface != NULL )
	{
		_hr = GetNetInterfaceItem( varIndex, ppClusterNetInterface );
	}

	return _hr;

} //*** CClusNetworkNetInterfaces::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNodeNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::CClusNodeNetInterfaces
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodeNetInterfaces::CClusNodeNetInterfaces( void )
{
	m_piids		= (const IID *) iidCClusNetInterfaces;
	m_piidsSize	= ARRAYSIZE( iidCClusNetInterfaces );

} //*** CClusNodeNetInterfaces::CClusNodeNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::~CClusNodeNetInterfaces
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodeNetInterfaces::~CClusNodeNetInterfaces( void )
{
	Clear();

} //*** CClusNodeNetInterfaces::~CClusNodeNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::Create
//
//	Description:
//		Complete the heavy weight construction.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//		hNode			[IN]	- The handle of the node whose netinterfaces
//								this collection holds.  The parent.
//
//	Return Value:
//		S_OK if successful, or E_POINTER is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNodeNetInterfaces::Create(
	IN ISClusRefObject *	pClusRefObject,
	IN HNODE				hNode
	)
{
	HRESULT _hr = E_POINTER;

	_hr = CNetInterfaces::Create( pClusRefObject );
	if ( SUCCEEDED( _hr ) )
	{
		m_hNode = hNode;
	} // if: args are not NULL

	return _hr;

} //*** CClusNodeNetInterfaces::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::get_Count
//
//	Description:
//		Return the count of objects (NodeNetinterfaces) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_NetInterfaceList.size();
		_hr = S_OK;
	} // if: args are not NULL

	return _hr;

} //*** CClusNodeNetInterfaces::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< NetInterfacesList, CComObject< CClusNetInterface > >( ppunk, m_NetInterfaceList );

} //*** CClusNodeNetInterfaces::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::Refresh
//
//	Description:
//		Load the collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::Refresh( void )
{
	HRESULT	_hr = E_POINTER;
	DWORD	_sc = ERROR_SUCCESS;

	if ( m_hNode != NULL )
	{
		HNODEENUM	_hEnum = NULL;

		_hEnum = ::ClusterNodeOpenEnum( m_hNode, CLUSTER_NODE_ENUM_NETINTERFACES );
		if ( _hEnum != NULL )
		{
			int									_nIndex = 0;
			DWORD								_dwType;
			LPWSTR								_pszName = NULL;
			CComObject< CClusNetInterface > *	_pNetInterface = NULL;

			Clear();

			for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
			{
				_sc = ::WrapClusterNodeEnum( _hEnum, _nIndex, &_dwType, &_pszName );
				if ( _sc == ERROR_NO_MORE_ITEMS )
				{
					_hr = S_OK;
					break;
				}
				else if ( _sc == ERROR_SUCCESS )
				{
					_hr = CComObject< CClusNetInterface >::CreateInstance( &_pNetInterface );
					if ( SUCCEEDED( _hr ) )
					{
						CSmartPtr< ISClusRefObject >					_ptrRefObject( m_pClusRefObject );
						CSmartPtr< CComObject< CClusNetInterface > >	_ptrNetInterface( _pNetInterface );

						_hr = _ptrNetInterface->Open( _ptrRefObject, _pszName );
						if ( SUCCEEDED( _hr ) )
						{
							_ptrNetInterface->AddRef();
							m_NetInterfaceList.insert( m_NetInterfaceList.end(), _ptrNetInterface );
						}
					}

					::LocalFree( _pszName );
					_pszName = NULL;
				}
				else
				{
					_hr = HRESULT_FROM_WIN32( _sc );
				}
			}

			::ClusterNodeCloseEnum( _hEnum );
		}
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;


} //*** CClusNodeNetInterfaces::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusNodeNetInterfaces::get_Item
//
//	Description:
//		Return the object (NodeNetinterface) at the passed in index.
//
//	Arguments:
//		varIndex				[IN]	- Contains the index requested.
//		ppClusterNetInterface	[OUT]	- Catches the item.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::get_Item(
	VARIANT					varIndex,
	ISClusNetInterface **	ppClusterNetInterface
	)
{
	//ASSERT( ppClusterNetInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppClusterNetInterface != NULL )
	{
		_hr = GetNetInterfaceItem( varIndex, ppClusterNetInterface );
	}

	return _hr;

} //*** CClusNodeNetInterfaces::get_Item()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusnetw.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      ClusNetW.cpp
//
//  Description:
//      Implementation of the network classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Ramakrishna Rosanuru via David Potter   (davidp)    5-Sep-1997
//      Galen Barbee                            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusneti.h"
#include "clusnetw.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusNetwork[] =
{
    &IID_ISClusNetwork
};

static const IID *  iidCClusNetworks[] =
{
    &IID_ISClusNetworks
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetwork class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::CClusterNetworkCClusterNetwork
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetwork::CClusNetwork( void )
{
    m_hNetwork              = NULL;
    m_pClusRefObject        = NULL;
    m_pNetInterfaces        = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;

    m_piids              = (const IID *) iidCClusNetwork;
    m_piidsSize          = ARRAYSIZE( iidCClusNetwork );

} //*** CClusNetwork::CClusNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::~CClusNetwork
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetwork::~CClusNetwork( void )
{
    if ( m_hNetwork != NULL )
    {
        CloseClusterNetwork( m_hNetwork );
    } // if:

    if ( m_pNetInterfaces != NULL )
    {
        m_pNetInterfaces->Release();
        m_pNetInterfaces = NULL;
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CClusNetwork::~CClusNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::Open
//
//  Description:
//      Open the passed in network.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrNetworkName [IN]    - The name of the interface to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetwork::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrNetworkName
    )
{
    ASSERT( pClusRefObject != NULL );
    //ASSERT( bstrNetworkName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject ) && ( bstrNetworkName != NULL ) )
    {
        HCLUSTER hCluster;

        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        _hr = m_pClusRefObject->get_Handle((ULONG_PTR *) &hCluster);
        if ( SUCCEEDED( _hr ) )
        {
            m_hNetwork = OpenClusterNetwork( hCluster, bstrNetworkName );
            if ( m_hNetwork == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            }
            else
            {
                m_bstrNetworkName = bstrNetworkName;
                _hr = S_OK;
            } // else:
        } // if:
    } // if:

    return _hr;

} //*** CClusNetwork::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Network).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetwork::GetProperties(
    OUT ISClusProperties ** ppProperties,
    IN  BOOL                bPrivate,
    IN  BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject< CClusProperties > * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusNetwork::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_Handle
//
//  Description:
//      Return the raw handle to this objec (Network).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        *phandle = (ULONG_PTR) m_hNetwork;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetwork::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::put_Name
//
//  Description:
//      Change the name of this object (Network).
//
//  Arguments:
//      bstrNetworkName [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::put_Name( IN BSTR bstrNetworkName )
{
    //ASSERT( bstrNetworkName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrNetworkName != NULL )
    {
        DWORD _sc = ERROR_SUCCESS;

        _sc = SetClusterNetworkName( m_hNetwork, bstrNetworkName );
        if ( _sc == ERROR_SUCCESS )
        {
            m_bstrNetworkName = bstrNetworkName;
        }

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;


} //*** CClusNetwork::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_Name
//
//  Description:
//      Return the name of this object (Network).
//
//  Arguments:
//      pbstrNetworkName    [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_Name( OUT BSTR * pbstrNetworkName )
{
    //ASSERT( pbstrNetworkName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNetworkName != NULL )
    {
        *pbstrNetworkName = m_bstrNetworkName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetwork::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_NetworkID
//
//  Description:
//      Get the network ID of this network.
//
//  Arguments:
//      pbstrNetworkID  [OUT]   - Catches the network ID.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_NetworkID( OUT BSTR * pbstrNetworkID )
{
    //ASSERT( pbstrNetworkID != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNetworkID != NULL )
    {
        WCHAR * pszNetworkID;
        DWORD   dwBytes = 0;
        DWORD   dwRet = ERROR_SUCCESS;

        dwRet = ::GetClusterNetworkId( m_hNetwork, NULL, &dwBytes );
        if ( SUCCEEDED( dwRet ) )
        {
            pszNetworkID = new WCHAR [ dwBytes + 1 ];
            if ( pszNetworkID != NULL )
            {
                dwRet = ::GetClusterNetworkId( m_hNetwork, pszNetworkID, &dwBytes );
                if ( SUCCEEDED( dwRet ) )
                {
                    *pbstrNetworkID = ::SysAllocString( pszNetworkID );
                    if ( *pbstrNetworkID == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        _hr = S_OK;
                    }
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( dwRet );
                }

                delete [] pszNetworkID;
            }
            else
            {
                _hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            _hr = HRESULT_FROM_WIN32( dwRet );
        }
    }

    return _hr;

} //*** CClusNetwork::get_NetworkID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_State
//
//  Description:
//      Returns the current state of this object (Network).
//
//  Arguments:
//      cnsState    [OUT]   - Catches the state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_State( OUT CLUSTER_NETWORK_STATE * cnsState )
{
    //ASSERT( cnsState != NULL );

    HRESULT _hr = E_POINTER;

    if ( cnsState != NULL )
    {
        CLUSTER_NETWORK_STATE   _cns = ::GetClusterNetworkState( m_hNetwork );

        if ( _cns == ClusterNetworkStateUnknown )
        {
            DWORD   _sc = ::GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        } // if: error
        else
        {
            *cnsState = _cns;
            _hr = S_OK;
        } // else: success
    } // if: args are not NULL

    return _hr;

} //*** CClusNetwork::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_CommonProperties
//
//  Description:
//      Get this object's (Network) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr =   m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_PrivateProperties
//
//  Description:
//      Get this object's (Network) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_CommonROProperties
//
//  Description:
//      Get this object's (Network) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_PrivateROProperties
//
//  Description:
//      Get this object's (Network) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_PrivateROProperties(
    ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_NetInterfaces
//
//  Description:
//      Creates a collection of netinterfaces for this network.
//
//  Arguments:
//      ppNetInterfaces [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_NetInterfaces(
    OUT ISClusNetworkNetInterfaces ** ppNetInterfaces
    )
{
    return ::HrCreateResourceCollection< CClusNetworkNetInterfaces, ISClusNetworkNetInterfaces, HNETWORK >(
                        &m_pNetInterfaces,
                        m_hNetwork,
                        ppNetInterfaces,
                        IID_ISClusNetworkNetInterfaces,
                        m_pClusRefObject
                        );

} //*** CClusNetwork::get_NetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_Cluster
//
//  Description:
//      Return the cluster this object (Network) belongs to.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_Cluster(
    ISCluster ** ppCluster
    )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusNetwork::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetwork::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;


    if ( bReadOnly )
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES
                        : CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_NETWORK_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetNetworkProperties( m_hNetwork, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusNetwork::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusNetwork::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES : CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterNetworkControl(
                        m_hNetwork,
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusNetwork::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetworks class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::CClusNetworks
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworks::CClusNetworks( void )
{
    m_pClusRefObject    = NULL;
    m_piids             = (const IID *) iidCClusNetworks;
    m_piidsSize         = ARRAYSIZE( iidCClusNetworks );

} //*** CClusNetworks::CClusNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::~CClusNetworks
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworks::~CClusNetworks( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CClusNetworks::~CClusNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful, E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetworks::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::get_Count
//
//  Description:
//      Return the count of objects (Networks) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_NetworkList.size();
        _hr = S_OK;
    } // if: args are not NULL

    return _hr;

} //*** CClusNetworks::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::get__NewEnum( IUnknown ** punk )
{
    return ::HrNewIDispatchEnum< NetworkList, CComObject< CClusNetwork > >( punk, m_NetworkList );

} //*** CClusNetworks::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::Refresh( void )
{
    HRESULT _hr = E_POINTER;
    DWORD   _sc = ERROR_SUCCESS;

    if ( m_pClusRefObject != NULL )
    {
        HCLUSENUM   hEnum = NULL;
        HCLUSTER    hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_NETWORK );
            if ( hEnum != NULL )
            {
                int                             _nIndex = 0;
                DWORD                           dwType = 0;
                LPWSTR                          pszName = NULL;
                CComObject< CClusNetwork > *    pNetwork = NULL;

                Clear();

                for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
                {
                    _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pszName );
                    if ( _sc == ERROR_NO_MORE_ITEMS )
                    {
                        _hr = S_OK;
                        break;
                    }
                    else if ( _sc == ERROR_SUCCESS )
                    {
                        _hr = CComObject< CClusNetwork >::CreateInstance( &pNetwork );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusNetwork > > ptrNetwork( pNetwork );

                            _hr = ptrNetwork->Open( ptrRefObject, pszName );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrNetwork->AddRef();
                                m_NetworkList.insert( m_NetworkList.end(), ptrNetwork );
                            }
                        }

                        ::LocalFree( pszName );
                        pszName = NULL;
                    }
                    else
                    {
                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }

                ::ClusterCloseEnum( hEnum );
            }
            else
            {
                _sc = GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }
    }

    return _hr;


} //*** CClusNetworks::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::Clear
//
//  Description:
//      Empty the collection of networks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusNetworks::Clear( void )
{
    ::ReleaseAndEmptyCollection< NetworkList, CComObject< CClusNetwork > >( m_NetworkList );

} //*** CClusNetworks::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::FindItem
//
//  Description:
//      Find a network in the collection by name and return its index.
//
//  Arguments:
//      lpszNetworkName [IN]    - The name to look for.
//      pnIndex         [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::FindItem(
    IN  LPWSTR  lpszNetworkName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( lpszNetworkName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( lpszNetworkName != NULL ) && ( pnIndex != NULL ) )
    {
        CComObject< CClusNetwork > *    pNetwork = NULL;
        NetworkList::iterator           first = m_NetworkList.begin();
        NetworkList::iterator           last    = m_NetworkList.end();
        UINT                            iIndex = 0;

        _hr = E_INVALIDARG;

        for ( ; first != last; first++, iIndex++ )
        {
            pNetwork = *first;

            if ( pNetwork && ( lstrcmpi( lpszNetworkName, pNetwork->Name() ) == 0 ) )
            {
                *pnIndex = iIndex;
                _hr = S_OK;
                break;
            }
        }
    } // if: args are not NULL

    return _hr;

} //*** CClusNetworks::FindItem( lpszNetworkName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::FindItem
//
//  Description:
//      Find a network in the collection and return its index.
//
//  Arguments:
//      pClusterNetwork [IN]    - The network to look for.
//      pnIndex         [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::FindItem(
    IN  ISClusNetwork * pClusterNetwork,
    OUT UINT *          pnIndex
    )
{
    //ASSERT( pClusterNetwork != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusterNetwork != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR    bstrName;

        _hr = pClusterNetwork->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CClusNetworks::FindItem( pClusterNetwork )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;
    UINT    nIndex = 0;

    if ( pnIndex != NULL )
    {
        CComVariant v;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_NetworkList.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusNetworks::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::GetItem
//
//  Description:
//      Return the item (Network) by name.
//
//  Arguments:
//      lpszNetworkName         [IN]    - The name of the item requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::GetItem(
    IN  LPWSTR              lpszNetworkName,
    OUT ISClusNetwork **    ppClusterNetwork
    )
{
    //ASSERT( lpszNetworkName != NULL );
    //ASSERT( ppClusterNetwork != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( lpszNetworkName != NULL ) && ( ppClusterNetwork != NULL ) )
    {
        CComObject<CClusNetwork> *  pNetwork = NULL;
        NetworkList::iterator           first = m_NetworkList.begin();
        NetworkList::iterator           last    = m_NetworkList.end();

        while ( first != last )
        {
            pNetwork = *first;

            if ( lstrcmpi( lpszNetworkName, pNetwork->Name() ) == 0 )
            {
                _hr = pNetwork->QueryInterface( IID_ISClusNetwork, (void **) ppClusterNetwork );
                break;
            }

            first++;
        }
    }

    return _hr;

} //*** CClusNetworks::GetItem( lpszNetworkName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::GetItem
//
//  Description:
//      Return the item (Network) by index.
//
//  Arguments:
//      nIndex                  [IN]    - The index of the item requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::GetItem(
    IN  UINT                nIndex,
    OUT ISClusNetwork **    ppClusterNetwork
    )
{
    //ASSERT( ppClusterNetwork != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetwork != NULL )
    {
        // Automation collections are 1-relative for languages like VB.
        // We are 0-relative internally.
        nIndex--;

        if ( nIndex < m_NetworkList.size() )
        {
            CComObject< CClusNetwork > * pNetwork = m_NetworkList[ nIndex ];

            _hr = pNetwork->QueryInterface( IID_ISClusNetwork, (void **) ppClusterNetwork );
        } // if: index is in range
        else
        {
            _hr = E_INVALIDARG;
        } // else: index is out of range
    }

    return _hr;

} //*** CClusNetworks::GetItem( nIndex )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::get_Item
//
//  Description:
//      Return the object (Network) at the passed in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index requested.
//      ppClusterNetwork    [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusNetwork **    ppClusterNetwork
    )
{
    //ASSERT( ppClusterNetwork != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetwork != NULL )
    {
        CComObject<CClusNetwork> *  pNetwork = NULL;
        UINT                            nIndex = 0;

        // Zero the out param
        *ppClusterNetwork = 0;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pNetwork = m_NetworkList[ nIndex ];
            _hr = pNetwork->QueryInterface( IID_ISClusNetwork, (void **) ppClusterNetwork );
        }
    }

    return _hr;

} //*** CClusNetworks::get_Item()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusnetw.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusNetW.h
//
//	Description:
//		Definition of the network classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusNetW.cpp
//
//	Author:
//		Ramakrishna Rosanuru via David Potter	(davidp)	5-Sep-1997
//		Galen Barbee							(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNETW_H_
#define _CLUSNETW_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNetwork;
class CClusNetworks;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetwork
//
//	Description:
//		Cluster Network Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetwork, &IID_ISClusNetwork, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo,
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNetwork, &CLSID_ClusNetwork >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetwork :
	public IDispatchImpl< ISClusNetwork, &IID_ISClusNetwork, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNetwork, &CLSID_ClusNetwork >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetwork( void );
	~CClusNetwork( void );

BEGIN_COM_MAP(CClusNetwork)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetwork)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetwork)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *	m_pClusRefObject;
	HNETWORK			m_hNetwork;
	CComBSTR			m_bstrNetworkName;

	CComObject< CClusNetworkNetInterfaces > *	m_pNetInterfaces;
	CComObject< CClusProperties > *				m_pCommonProperties;
	CComObject< CClusProperties > *				m_pPrivateProperties;
	CComObject< CClusProperties > *				m_pCommonROProperties;
	CComObject< CClusProperties > *				m_pPrivateROProperties;


	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrNetworkName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP get_Name( OUT BSTR * pbstrNetworkName );

	STDMETHODIMP put_Name( IN BSTR pbstrNetworkName );

	STDMETHODIMP get_NetworkID( OUT BSTR * pbstrNetworkID );

	STDMETHODIMP get_State( OUT CLUSTER_NETWORK_STATE * dwState );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties	);

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_NetInterfaces( OUT ISClusNetworkNetInterfaces ** ppNetInterfaces	);

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrNetworkName ; };

}; //*** Class CClusNetwork

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetworks
//
//	Description:
//		Cluster Networks Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetworks, &IID_ISClusNetworks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo,
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNetworks, &CLSID_ClusNetworks >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetworks :
	public IDispatchImpl< ISClusNetworks, &IID_ISClusNetworks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNetworks, &CLSID_ClusNetworks >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetworks( void );
	~CClusNetworks( void );

BEGIN_COM_MAP(CClusNetworks)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetworks)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetworks)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject* pClusRefObject );

protected:
	typedef std::vector< CComObject<CClusNetwork> * >	NetworkList;

	NetworkList			m_NetworkList;
	ISClusRefObject *	m_pClusRefObject;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNetworkName, OUT UINT * pnIndex	);

	HRESULT FindItem( IN ISClusNetwork * pClusterNetwork, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetItem( IN LPWSTR lpszNetworkName, OUT ISClusNetwork ** ppClusterNetwork );

	HRESULT GetItem( IN UINT nIndex, OUT ISClusNetwork ** ppClusterNetwork );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetwork ** ppClusterNetwork );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNetworks

#endif // _CLUSNETW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusnode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusNode.h
//
//	Description:
//		Definition of the node classes for the MSCLUS automation classes.
//
//	Implementation File:
//		ClusNode.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNODE_H_
#define _CLUSNODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNode;
class CNodes;
class CClusNodes;
class CClusResGroupPreferredOwnerNodes;
class CClusResPossibleOwnerNodes;

const IID IID_CClusNode = {0xf2e60800,0x2631,0x11d1,{0x89,0xf1,0x00,0xa0,0xc9,0x0d,0x06,0x1e}};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNode
//
//	Description:
//		Cluster Node Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNode, &IID_ISClusNode, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNode, &CLSID_ClusNode >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNode :
	public IDispatchImpl< ISClusNode, &IID_ISClusNode, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNode, &CLSID_ClusNode >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNode( void );
	~CClusNode( void );

BEGIN_COM_MAP(CClusNode)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNode)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IID(IID_CClusNode, CClusNode)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNode)
DECLARE_NO_REGISTRY()

private:
	HNODE				m_hNode;
	ISClusRefObject *	m_pClusRefObject;
	CComBSTR			m_bstrNodeName;

	CComObject< CClusResGroups > *			m_pResourceGroups;
	CComObject< CClusProperties > *			m_pCommonProperties;
	CComObject< CClusProperties > *			m_pPrivateProperties;
	CComObject< CClusProperties > *			m_pCommonROProperties;
	CComObject< CClusProperties > *			m_pPrivateROProperties;
	CComObject< CClusNodeNetInterfaces > *	m_pNetInterfaces;


	HRESULT Close( void );

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrNodeName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP get_Name( OUT BSTR * pbstrNodeName );

	STDMETHODIMP get_NodeID( OUT BSTR * pbstrNodeID );

	STDMETHODIMP get_State( OUT CLUSTER_NODE_STATE * dwState );

	STDMETHODIMP Pause( void );

	STDMETHODIMP Resume( void );

	STDMETHODIMP Evict( void );

	STDMETHODIMP get_ResourceGroups( OUT ISClusResGroups ** ppResourceGroups );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_NetInterfaces( OUT ISClusNodeNetInterfaces ** ppNetInterfaces );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrNodeName; };

	const HNODE & RhNode( void ) const { return m_hNode; };

}; //*** Class CClusNode

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CNodes
//
//	Description:
//		Cluster Nodes Collection Implementation Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CNodes
{
public:
	CNodes( void );
	~CNodes( void );

	HRESULT Create( ISClusRefObject * pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusNode > * >	NodeList;

	ISClusRefObject *	m_pClusRefObject;
	NodeList			m_Nodes;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNodeName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusNode * pClusterNode, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetItem( IN LPWSTR lpszNodeName, OUT ISClusNode ** ppClusterNode );

	HRESULT GetItem( IN UINT nIndex, OUT ISClusNode ** ppClusterNode );

	HRESULT GetNodeItem( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	HRESULT InsertAt( IN CComObject< CClusNode > * pNode, IN size_t pos );

	HRESULT RemoveAt( IN size_t pos );

}; //*** Class CNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNodes
//
//	Description:
//		Cluster Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNodes, &IID_ISClusNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes,
//		CComCoClass< CClusNodes, &CLSID_ClusNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNodes :
	public IDispatchImpl< ISClusNodes, &IID_ISClusNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusNodes, &CLSID_ClusNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNodes( void );
	~CClusNodes( void );

BEGIN_COM_MAP(CClusNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISC