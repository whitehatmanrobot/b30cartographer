             // All we do for registry notifications is set the timer, issue
                // the RegNotify again, mark the RNB as pending, and rewait.
                //
                DueTime.QuadPart = -10 * 1000 * 1000 * LAZY_CHECKPOINT;
                Success = SetWaitableTimer(Rnb->hTimer,
                                           &DueTime,
                                           0,
                                           NULL,
                                           NULL,
                                           FALSE);
                CL_ASSERT(Success);
                Status = RegNotifyChangeKeyValue(Rnb->hKey,
                                                 TRUE,
                                                 REG_LEGAL_CHANGE_FILTER,
                                                 Rnb->hEvent,
                                                 TRUE);
                if (Status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[CP] CppRegNotifyThread - error %1!d! attempting to reregister notification for %2!ws!\n",
                               Status,
                               Rnb->KeyName);
                }

                //
                // Mark it pending so if someone tries to remove it we know that
                // we should checkpoint first.
                //
                Rnb->Pending = TRUE;

            } else {
                //
                // This must be a timer firing
                //
                CL_ASSERT(Rnb->Pending);

                ClRtlLogPrint(LOG_NOISE,
                           "[CP] CppRegNotifyThread checkpointing key %1!ws! to id %2!d! due to timer\n",
                           Rnb->KeyName,
                           Rnb->dwId);

                           
                Status = CppNotifyCheckpoint(Rnb);
                if (Status == ERROR_SUCCESS)
                {
                    Rnb->Pending = FALSE;
                }
                else
                {
                    LARGE_INTEGER DueTime;

                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[CP] CppRegNotifyThread CppNotifyCheckpoint due to timer failed, reset the timer.\n");
                    //
                    // This checkpoint on timer can fail because the quorum resource is
                    // not available.  This is because we do not sychronoze the quorum
                    // state change with this timer and it is too inefficient to do so !
                    
                    DueTime.QuadPart = -10 * 1000 * 1000 * LAZY_CHECKPOINT;
                    Success = SetWaitableTimer(Rnb->hTimer,
                                               &DueTime,
                                               0,
                                               NULL,
                                               NULL,
                                               FALSE);
                    CL_ASSERT(Success);
                    
                    //Pending remains set to TRUE.
                        
                }
            }

        }


    } while ( Group->BlockCount > 0 );

    return(ERROR_SUCCESS);
}


DWORD
CppNotifyCheckpoint(
    IN PRNB Rnb
    )
/*++

Routine Description:

    Checkpoints the registry subtree for the specified RNB

Arguments:

    Rnb - Supplies the registry notification block to be checkpointed

Return Value:

    None

--*/

{
    DWORD Status;

    Status = CppCheckpoint(Rnb->Resource,
                           Rnb->hKey,
                           Rnb->dwId,
                           Rnb->KeyName);
                           

    return(Status);
}


DWORD
CppRundownCheckpoints(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Runs down, frees, and removes any registry notification blocks
    for the specified resource.

Arguments:

    Resource - Supplies the resource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PRNB Rnb;
    PRNB NextRnb;
    PNOTIFY_GROUP Group;

    EnterCriticalSection(&CppNotifyLock);
    NextRnb = (PRNB)Resource->CheckpointState;
    while (NextRnb) {
        Rnb = NextRnb;
        NextRnb = NextRnb->Next;

        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CppRundownCheckpoints removing RNB for %1!ws!\n",
                   Rnb->KeyName);

        Group = Rnb->NotifyGroup;

        //
        // Send a command to the group notify thread to remove the RNB.
        //
        if (Group->BlockCount == 1) 
        {
            //
            // Remove this group, it is going to be empty. The worker thread
            // will exit after this command
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[CP] CppRundownCheckpoints removing empty group\n");
            RemoveEntryList(&Group->ListEntry);

            //dont wait, the notification thread for this group will automatically
            //exit when the block count drops to 0.  It cleans up the hCommandEvent
            //and the hCompleteEvent on exit, so do not do a waitforsingleobject() 
            //in this case.
            Group->Command = NotifyRemoveRNB;
            Group->CommandContext = (ULONG_PTR)Rnb;
            SetEvent(Group->hCommandEvent);
            //wait for the thread to exit
            WaitForSingleObject(Group->hThread, INFINITE);
            // Clean up the group structure 
            CloseHandle(Group->hCommandEvent);
            CloseHandle(Group->hCommandComplete);
            CloseHandle(Group->hThread);
            CsFree(Group);
        }
        else
        {
            //the block count is greater than 1, remove the rnb, signal
            //the thread and wait
            Group->Command = NotifyRemoveRNB;
            Group->CommandContext = (ULONG_PTR)Rnb;
            SetEvent(Group->hCommandEvent);
            WaitForSingleObject(Group->hCommandComplete, INFINITE);
        }

        //
        // Clean up all the allocations and handles in the RNB.
        //
        CsFree(Rnb->KeyName);
        RegCloseKey(Rnb->hKey);
        CloseHandle(Rnb->hEvent);
        CloseHandle(Rnb->hTimer);
        CsFree(Rnb);
    }
    Resource->CheckpointState = 0;

    LeaveCriticalSection(&CppNotifyLock);

    return(ERROR_SUCCESS);
}


DWORD
CppRundownCheckpointById(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId
    )
/*++

Routine Description:

    Runs down, frees, and removes the registry notification block
    for the specified resource and checkpoint ID.

Arguments:

    Resource - Supplies the resource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PRNB Rnb;
    PRNB NextRnb;
    PRNB *ppLastRnb;
    PNOTIFY_GROUP Group;

    EnterCriticalSection(&CppNotifyLock);
    NextRnb = (PRNB)Resource->CheckpointState;
    ppLastRnb = &((PRNB)Resource->CheckpointState);
    while (NextRnb) {
        Rnb = NextRnb;
        NextRnb = NextRnb->Next;
        if (Rnb->dwId == dwId) {
            ClRtlLogPrint(LOG_NOISE,
                       "[CP] CppRundownCheckpointById removing RNB for %1!ws!\n",
                       Rnb->KeyName);
            //remove from the list of checkpoint id's for the resource                       
            *ppLastRnb = NextRnb;
                
            Group = Rnb->NotifyGroup;

            //
            // Send a command to the group notify thread to remove the RNB.
            //
            if (Group->BlockCount == 1) 
            {
                //
                // Remove this group, it is going to be empty. The worker thread
                // will exit after this command
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[CP] CppRundownCheckpointById removing empty group\n");

                RemoveEntryList(&Group->ListEntry);

                //dont wait, the notification thread for this group will automatically
                //exit when the block count drops to 0.  It cleans up the hCommandEvent
                //and the hCompleteEvent on exit, so do not do a waitforsingleobject() 
                //in this case.
                Group->Command = NotifyRemoveRNB;
                Group->CommandContext = (ULONG_PTR)Rnb;
                SetEvent(Group->hCommandEvent);
                //wait for the thread to exit
                WaitForSingleObject(Group->hThread, INFINITE);
                // Clean up the group structure 
                CloseHandle(Group->hCommandEvent);
                CloseHandle(Group->hCommandComplete);
                CloseHandle(Group->hThread);
                CsFree(Group);
            }
            else
            {
                //the block count is greater than 1, remove the rnb, signal
                //the thread and wait
                Group->Command = NotifyRemoveRNB;
                Group->CommandContext = (ULONG_PTR)Rnb;
                SetEvent(Group->hCommandEvent);
                WaitForSingleObject(Group->hCommandComplete, INFINITE);
            }

            
            //
            // Clean up all the allocations and handles in the RNB.
            //
            CsFree(Rnb->KeyName);
            RegCloseKey(Rnb->hKey);
            CloseHandle(Rnb->hEvent);
            CloseHandle(Rnb->hTimer);
            CsFree(Rnb);
            LeaveCriticalSection(&CppNotifyLock);
            return(ERROR_SUCCESS);
        }
        ppLastRnb = &Rnb->Next;
    }
    ClRtlLogPrint(LOG_UNUSUAL,
               "[CP] CppRundownCheckpointById - could not find checkpoint %1!d! in resource %2!ws!\n",
               dwId,
               OmObjectName(Resource));

    LeaveCriticalSection(&CppNotifyLock);
    return(ERROR_FILE_NOT_FOUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\crypto.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    Interfaces for registering and deregistering crypto checkpoint
    handlers.

Author:

    Jeff Spelman (jeffspel) 11/10/1998

Revision History:

    Charlie Wickham (charlwi) 7/7/00

        added "how this works" section
--*/

#include "cpp.h"
#include "wincrypt.h"

#if 0

How crypto checkpointing works

Crypto checkpointing allows a crypto key container to be associated with a
resource. When that resource is moved to another node in the cluster, the key
container is constructed/updated from the checkpoint information on the previous
hosting node. The key container is not replicated; it only appears on a node if
the resource is moved to that node. Keys in the container must be exportable.

The user identifies the crypto key container by passing in a string of the form
"Type\Name\Key" where Type is CSP Provider type, Name is the provider name, and
Key is the key container name.

Checkpoints are added in CpckAddCryptoCheckpoint. Checkpoint information is
stored in two places: in the CryptoSync key under the resource key and in a
datafile on the quorum drive. A new key, called CryptoSync, is created under
the resource key. In this key are values that are of the form 00000001,
00000002, etc. The data associated with the value is the string identifying
the crypto key container. The datafile contains all the information to restore
the crypto key container on another node in the cluster, i.e., a header
(CRYPTO_KEY_FILE_DATA), the signature and exchange keys if they exist, and the
security descriptor associated with key container.

Upon receiving the control code, the cluster service cracks the string into its
component parts and stores the data in a CRYPTO_KEY_INFO structure. The
CryptoSync key is opened/created and a check is made to see if the checkpoint
already exists. If not, a new ID is found and the checkpoint is saved to a file
on the quorum disk.

When the resource is moved to another node, the FM calls CpckReplicateCryptoKeys
to restore the keys on that node. This routine reads the file and creates the
key container, imports the keys and sets the security descr. on the container.

Delete cleans up registry entry and file.

#endif

//
// Local type and structure definitions
//
typedef struct _CPCK_ADD_CONTEXT {
    BOOL fFound;
    BYTE *pbInfo;
    DWORD cbInfo;
} CPCK_ADD_CONTEXT, *PCPCK_ADD_CONTEXT;

typedef struct _CPCK_DEL_CONTEXT {
    DWORD dwId;
    BYTE *pbInfo;
    DWORD cbInfo;
} CPCK_DEL_CONTEXT, *PCPCK_DEL_CONTEXT;

typedef struct _CPCK_GET_CONTEXT {
    DWORD cCheckpoints;
    BOOL fNeedMoreData;
    DWORD cbAvailable;
    DWORD cbRequired;
    BYTE *pbOutput;
} CPCK_GET_CONTEXT, *PCPCK_GET_CONTEXT;


// struct for Crypto Key information
typedef struct _CRYPTO_KEY_INFO {
    DWORD dwVersion;
    DWORD dwProvType;
    LPWSTR pwszProvName;
    LPWSTR pwszContainer;
} CRYPTO_KEY_INFO, *PCRYPTO_KEY_INFO;

// current version for the CRYPTO_KEY_INFO struct
#define CRYPTO_KEY_INFO_VERSION     1

// struct for key data when writing and reading from files

#define SALT_SIZE   16
#define IV_SIZE      8

typedef struct _CRYPTO_KEY_FILE_DATA {
    DWORD dwVersion;
    DWORD cbSig;
    DWORD cbExch;
    DWORD cbSecDescr;
    struct _CRYPTO_KEY_FILE_INITIALIZATION_DATA {
        BYTE rgbSigIV[IV_SIZE];
        BYTE rgbExchIV[IV_SIZE];
        BYTE rgbSalt[SALT_SIZE];
    };
} CRYPTO_KEY_FILE_DATA, *PCRYPTO_KEY_FILE_DATA;

// current version for the CRYPTO_KEY_INFO struct
#define CRYPTO_KEY_FILE_DATA_VERSION     1

//
// Local function prototypes
//
BOOL
CpckReplicateCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    );

BOOL
CpckAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_ADD_CONTEXT Context
    );

BOOL
CpckDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_DEL_CONTEXT Context
    );

BOOL
CpckGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_GET_CONTEXT Context
    );

DWORD
CpckInstallKeyContainer(
    IN HCRYPTPROV hProv,
    IN LPWSTR   FileName
    );

DWORD
CpckCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HCRYPTPROV hProv,
    IN DWORD dwId,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo
    );

CL_NODE_ID
CppGetQuorumNodeId(
    VOID
    );


DWORD
CpckReplicateCryptoKeys(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Restores any crypto key checkpoints for this resource.

Arguments:

    Resource - Supplies the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmOpenKey(ResourceKey,
                              L"CryptoSync",
                              KEY_READ);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey != NULL) {

        DmEnumValues(CryptoSyncKey,
                     CpckReplicateCallback,
                     Resource);
        DmCloseKey(CryptoSyncKey);
    }

    return(ERROR_SUCCESS);
} //  CpckReplicateCryptoKeys


void
FreeCryptoKeyInfo(
    IN OUT CRYPTO_KEY_INFO *pCryptoKeyInfo
    )
/*++

Routine Description:

    Frees the string pointers in the structure.

Arguments:

    CryptoKeyInfo - Pointer to the CRYPTO_KEY_INFO structure which

--*/
{
    if (NULL != pCryptoKeyInfo)
    {
        if (NULL != pCryptoKeyInfo->pwszProvName)
        {
            LocalFree(pCryptoKeyInfo->pwszProvName);
            pCryptoKeyInfo->pwszProvName = NULL;
        }
        if (NULL != pCryptoKeyInfo->pwszContainer)
        {
            LocalFree(pCryptoKeyInfo->pwszContainer);
            pCryptoKeyInfo->pwszContainer = NULL;
        }
    }
} // FreeCryptoKeyInfo


DWORD
CpckValueToCryptoKeyInfo(
    OUT CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN LPVOID ValueData,
    IN DWORD ValueSize
    )
/*++

Routine Description:

    Converts from a binary blob into a CryptoKeyInfo structure.  Basically
    this just does some value and pointer assignments.

Arguments:

    CryptoKeyInfo - Pointer to the CRYPTO_KEY_INFO structure which is filled in

    ValueData - Supplies the value data (this is the binary blob)

    ValueSize - Supplies the size of ValueData

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD   *pdw;
    WCHAR   *pwsz = (WCHAR*)ValueData;
    DWORD   cb = sizeof(DWORD) * 2;
    DWORD   cwch;
    DWORD   i;
    DWORD   Status = ERROR_SUCCESS;

    // make sure the length is OK
    if (ValueSize < sizeof(WCHAR) * 3)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // first is the Provider type
    for (i = 0; i < (ValueSize - 3) / sizeof(WCHAR); i++)
    {
        if (L'\\' == pwsz[i])
        {
            pwsz[i] = L'\0';
            break;
        }
    }
    if ((ValueSize - 3) / sizeof(WCHAR) == i)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
    pCryptoKeyInfo->dwProvType = _wtoi(pwsz);
    pwsz[i] = L'\\';
    cwch = i;

    // grab the provider name pointer
    for (i = i + 1; i < (ValueSize - 2) / sizeof(WCHAR); i++)
    {
        if (L'\\' == pwsz[i])
        {
            pwsz[i] = L'\0';
            break;
        }
    }
    if ((ValueSize - 2) / sizeof(WCHAR) == i)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
    cb = (wcslen(&pwsz[cwch + 1]) + 1) * sizeof(WCHAR);
    if (NULL == (pCryptoKeyInfo->pwszProvName = 
        (WCHAR*)LocalAlloc(LMEM_ZEROINIT, cb)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    wcscpy(pCryptoKeyInfo->pwszProvName, &pwsz[cwch + 1]);
    pwsz[i] = L'\\';
    cwch = i;

    // grab the container name pointer
    cb = (wcslen(&pwsz[cwch + 1]) + 1) * sizeof(WCHAR);
    if (NULL == (pCryptoKeyInfo->pwszContainer = 
        (WCHAR*)LocalAlloc(LMEM_ZEROINIT, cb)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    wcscpy(pCryptoKeyInfo->pwszContainer, &pwsz[cwch + 1]);
Ret:
    return (Status);
} // CpckValueToCryptoKeyInfo


DWORD
CpckOpenCryptoKeyContainer(
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN BOOL fCreate,
    OUT HCRYPTPROV *phProv
    )
/*++

Routine Description:

    Opens a crypto key container (always uses CRYPT_MACHINE_KEYSET). Checks
    for either a signature and/or an exchange key and that they are
    exportable.

Arguments:

    pCryptKeyInfo - Supplies the information for opening the container

    fCreate - Flag indicating if container is to be created

    phProv - The resulting Crypto Provider handle

Return Value:

    ERROR_SUCCESS if succeeds

    Crypto Error code if it fails

--*/

{
    BOOLEAN WasEnabled;
    HCRYPTKEY hSigKey = 0;
    HCRYPTKEY hExchKey = 0;
    DWORD dwPermissions;
    DWORD cbPermissions;
    DWORD Status = 0;

    //
    // Attempt to open the specified crypto key container.
    //
    if (!CryptAcquireContextW(phProv,
                              pCryptoKeyInfo->pwszContainer,
                              pCryptoKeyInfo->pwszProvName,
                              pCryptoKeyInfo->dwProvType,
                              CRYPT_MACHINE_KEYSET))
    {
        if (fCreate)
        {
            //
            // if unable to open then create the container
            //
            if (!CryptAcquireContextW(phProv,
                                      pCryptoKeyInfo->pwszContainer,
                                      pCryptoKeyInfo->pwszProvName,
                                      pCryptoKeyInfo->dwProvType,
                                      CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
            {
                Status = GetLastError();
            }
        }
        else
        {
            Status = GetLastError();
        }
    }

    // if failed then try with BACKUP/RESTORE privilege
    if (0 != Status)
    {
        //
        //
        Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                                  &WasEnabled);

        if ( Status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckOpenCryptoKeyContainer failed to enable thread privilege %1!d!...\n",
                      Status);
            goto Ret;
        }

        if (!CryptAcquireContextW(phProv,
                                  pCryptoKeyInfo->pwszContainer,
                                  pCryptoKeyInfo->pwszProvName,
                                  pCryptoKeyInfo->dwProvType,
                                  CRYPT_MACHINE_KEYSET))
        {
            if (fCreate)
            {
                //
                // if unable to open then create the container
                //
                if (!CryptAcquireContextW(phProv,
                                          pCryptoKeyInfo->pwszContainer,
                                          pCryptoKeyInfo->pwszProvName,
                                          pCryptoKeyInfo->dwProvType,
                                          CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
                {
                    Status = GetLastError();
                }
            }
            else
            {
                Status = GetLastError();
            }
        }
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    }

    if ((0 == Status) && (!fCreate))
    {
        // check if there is a sig key
        if (CryptGetUserKey(*phProv, AT_SIGNATURE, &hSigKey))
        {
            // check if key is exportable
            cbPermissions = sizeof(DWORD);
            if (!CryptGetKeyParam(hSigKey,
                                  KP_PERMISSIONS,
                                  (BYTE*)&dwPermissions,
                                  &cbPermissions,
                                  0))
            {
                Status = GetLastError();
                goto Ret;
            }
            if (!(dwPermissions & CRYPT_EXPORT))
            {
                Status = (DWORD)NTE_BAD_KEY;
                goto Ret;
            }
        }

        // check if there is an exchange key
        if (CryptGetUserKey(*phProv, AT_KEYEXCHANGE, &hExchKey))
        {
            // check if key is exportable
            cbPermissions = sizeof(DWORD);
            if (!CryptGetKeyParam(hExchKey,
                                  KP_PERMISSIONS,
                                  (BYTE*)&dwPermissions,
                                  &cbPermissions,
                                  0))
            {
                Status = GetLastError();
                goto Ret;
            }
            if (!(dwPermissions & CRYPT_EXPORT))
            {
                Status = (DWORD)NTE_BAD_KEY;
                goto Ret;
            }
        }
    }
Ret:
    if (hSigKey)
        CryptDestroyKey(hSigKey);
    if (hExchKey)
        CryptDestroyKey(hExchKey);

    return Status;
} // CpckOpenCryptoKeyContainer


BOOL
CpckReplicateCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Value enumeration callback for watching a resource's crypto key
    checkpoints.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry crypto key info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Resource - Supplies the resource this value is a crypto key checkpoint for

Return Value:

    TRUE to continue enumeration

--*/

{
    DWORD Id;
    DWORD Status;
    WCHAR TempFile[MAX_PATH];
    CRYPTO_KEY_INFO CryptoKeyInfo;
    HCRYPTPROV hProv = 0;
    BOOL fRet = TRUE;

    memset(&CryptoKeyInfo, 0, sizeof(CryptoKeyInfo));

    Id = wcstol(ValueName, NULL, 16);  // skip past the 'Crypto' prefix
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Resource));
        goto Ret;
    }

    //
    // convert from binary blob into a Crypto Key Info structure
    //

    Status = CpckValueToCryptoKeyInfo(&CryptoKeyInfo,
                                      ValueData,
                                      ValueSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback invalid crypto info %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Resource));
        goto Ret;
    }

    Status = CpckOpenCryptoKeyContainer(&CryptoKeyInfo,
                                        TRUE,
                                        &hProv);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback CryptAcquireContext failed for %1!ws! %2!ws! with %3!d! for resource %4!ws!\n",
                   CryptoKeyInfo.pwszContainer,
                   CryptoKeyInfo.pwszProvName,
                   Status,
                   OmObjectName(Resource));
        goto Ret;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CPCK] CpckReplicateCallback retrieving crypto id %1!lx! for resource %2!ws\n",
               Id,
               OmObjectName(Resource));
    //
    // See if there is any checkpoint data for this ID.
    //
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
    }
    Status = CpGetDataFile(Resource,
                           Id,
                           TempFile,
                           TRUE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback - CpGetDataFile for id %1!lx! resource %2!ws! failed %3!d!\n",
                   Id,
                   OmObjectName(Resource),
                   Status);
    } else {

        //
        // Finally install the checkpointed file into the registry.
        //
        Status = CpckInstallKeyContainer(hProv, TempFile);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CPCK] CpckReplicateCallback: could not restore temp file %1!ws! to container %2!ws! error %3!d!\n",
                       TempFile,
                       CryptoKeyInfo.pwszContainer,
                       Status);
            // Log the event for crypto key failure
            CsLogEventData2(LOG_CRITICAL,
                            CP_CRYPTO_CKPT_RESTORE_FAILED,
                            sizeof(Status),
                            &Status,
                            OmObjectName(Resource),
                            CryptoKeyInfo.pwszContainer);
        }

    }
    DeleteFile(TempFile);

    //
    // watcher for crypto keys is not currently available or needed
    //
Ret:
    FreeCryptoKeyInfo(&CryptoKeyInfo);

    if (hProv)
        CryptReleaseContext(hProv, 0);

    return fRet;
} // CpckReplicateCallback


DWORD
CpckAddCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )
/*++

Routine Description:

    Adds a new crypto key checkpoint to a resource's list.

Arguments:

    Resource - supplies the resource the crypto key checkpoint should be added to.

    InBuffer - Supplies the crypto key information (always CRYPT_MACHINE_KEYSET)

    InBufferSize - Supplies the length of InBuffer

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY  SyncKey;
    CPCK_ADD_CONTEXT Context;
    HDMKEY  ResourceKey = NULL;
    HDMKEY  CryptoSyncKey = NULL;
    DWORD   Disposition;
    DWORD   Id;
    WCHAR   IdName[9];
    DWORD   Status;
    CLUSTER_RESOURCE_STATE State;
    BOOLEAN WasEnabled;
    DWORD   Count=60;
    CRYPTO_KEY_INFO CryptoKeyInfo;
    HCRYPTPROV hProv = 0;

    memset(&CryptoKeyInfo, 0, sizeof(CryptoKeyInfo));

    //
    // convert from binary blob into a Crypto Key Info structure
    //

    Status = CpckValueToCryptoKeyInfo(&CryptoKeyInfo,
                                      InBuffer,
                                      InBufferSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckAddCryptoCheckpoint: invalid crypto info for resource %1!ws!\n",
                      OmObjectName(Resource));
        goto Ret;
    }

    Status = CpckOpenCryptoKeyContainer(&CryptoKeyInfo,
                                        FALSE,
                                        &hProv);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckAddCryptoCheckpoint: open key container failed for "
                      "container %1!ws! (provider: %2!ws!) with %3!d! for resource %4!ws!\n",
                      CryptoKeyInfo.pwszContainer,
                      CryptoKeyInfo.pwszProvName,
                      Status,
                      OmObjectName(Resource));
        goto Ret;
    }

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);

    if( ResourceKey == NULL ) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: couldn't open Resource key for %1!ws! error %2!d!\n",
                      OmObjectName(Resource),
                      Status);
        goto Ret;                   
    }

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmCreateKey(ResourceKey,
                                L"CryptoSync",
                                0,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &Disposition);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: couldn't create CryptoSync key for "
                      "resource %1!ws! error %2!d!\n",
                      OmObjectName(Resource),
                      Status);
        goto Ret;                   
    }
    if (Disposition == REG_OPENED_EXISTING_KEY) {
        //
        // Enumerate all the other values to make sure this key is
        // not already registered.
        //
        Context.fFound = FALSE;
        Context.pbInfo = InBuffer;
        Context.cbInfo = InBufferSize;
        DmEnumValues(CryptoSyncKey,
                     CpckAddCheckpointCallback,
                     &Context);
        if (Context.fFound) {
            //
            // This checkpoint already exists.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[CPCK] CpckAddCryptoCheckpoint: failing attempt to add duplicate "
                          "checkpoint for resource %1!ws!, container %2!ws! (provider: %3!ws!)\n",
                          OmObjectName(Resource),
                          CryptoKeyInfo.pwszContainer,
                          CryptoKeyInfo.pwszProvName);
            Status = ERROR_ALREADY_EXISTS;
            goto Ret;
        }

        //
        // Now we need to find a unique checkpoint ID for this registry subtree.
        // Start at 1 and keep trying value names until we get to one that does
        // not already exist.
        //
        for (Id=1; ; Id++) {
            DWORD dwType;
            DWORD cbData;

            wsprintfW(IdName,L"%08lx",Id);
            cbData = 0;
            Status = DmQueryValue(CryptoSyncKey,
                                  IdName,
                                  &dwType,
                                  NULL,
                                  &cbData);
            if (Status == ERROR_FILE_NOT_FOUND) {
                //
                // Found a free ID.
                //
                break;
            }
        }
    } else {
        //
        // The crypto sync reg key was just created, so this must be the only checkpoint
        // that exists.
        //
        Id = 1;
        wsprintfW(IdName, L"%08lx",Id);
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[CPCK] CpckAddCryptoCheckpoint: creating new checkpoint id %1!d! "
                  "for resource %2!ws!, container %3!ws! (provider: %4!ws!)\n",
                  Id,
                  OmObjectName(Resource),
                  CryptoKeyInfo.pwszContainer,
                  CryptoKeyInfo.pwszProvName);

    Status = DmSetValue(CryptoSyncKey,
                        IdName,
                        REG_BINARY,
                        (CONST BYTE *)InBuffer,
                        InBufferSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: failed to create new checkpoint id %1!d! "
                      "for resource %2!ws!, container %3!ws! (provider: %4!ws!)\n",
                      Id,
                      OmObjectName(Resource),
                      CryptoKeyInfo.pwszContainer,
                      CryptoKeyInfo.pwszProvName);
        goto Ret;
    }

RetryCheckpoint:
    //
    // Take the initial checkpoint
    //
    Status = CpckCheckpoint(Resource,
                            hProv,
                            Id,
                            &CryptoKeyInfo);

    // this may fail due to quorum resource being offline. We could do one of
    // two things here, wait for quorum resource to come online or retry. We
    // retry as this may be called from the online routines of a resource and
    // we dont want to add any circular waits.
    if ((Status == ERROR_ACCESS_DENIED) ||
        (Status == ERROR_INVALID_FUNCTION) ||
        (Status == ERROR_NOT_READY) ||
        (Status == RPC_X_INVALID_PIPE_OPERATION) ||
        (Status == ERROR_BUSY) ||
        (Status == ERROR_SWAPERROR))
    {
        if (Count--)
        {
            Sleep(1000);
            goto RetryCheckpoint;
        } 
#if DBG
        else
        {
            if (IsDebuggerPresent())
                DebugBreak();
        }        
#endif                                
        
    }
    
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: failed to take initial checkpoint for "
                      "resource %1!ws!, container %2!ws! (provider: %3!ws!), error %4!d!\n",
                      OmObjectName(Resource),
                      CryptoKeyInfo.pwszContainer,
                      CryptoKeyInfo.pwszProvName,
                      Status);
        goto Ret;
    }
Ret:
    FreeCryptoKeyInfo(&CryptoKeyInfo);

    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (CryptoSyncKey)
        DmCloseKey(CryptoSyncKey);

    return(Status);
} // CpckAddCryptoCheckpoint


BOOL
CpckAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_ADD_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for adding a new registry
    checkpoint subtrees. This is only used to see if the specified
    registry subtree is already being watched.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto key information)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (memcmp(ValueData, Context->pbInfo, Context->cbInfo) == 0) {
        //
        // Found a match
        //
        Context->fFound = TRUE;
        return(FALSE);
    }
    return(TRUE);
} // CpckAddCheckpointCallback


DWORD
CpckDeleteCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )
/*++

Routine Description:

    Removes a crypto key checkpoint from a resource's list.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    InBuffer - Supplies the crypto key information (always CRYPT_MACHINE_KEYSET)

    InBufferSize - Supplies the length of InBuffer

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPCK_DEL_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;
    DWORD Status;
    WCHAR ValueId[9];
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;
    CLUSTER_RESOURCE_STATE State;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmOpenKey(ResourceKey,
                           L"CryptoSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't open CryptoSync key error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Enumerate all the values to find this one
    //
    Context.dwId = 0;
    Context.pbInfo = InBuffer;
    Context.cbInfo = InBufferSize;
    DmEnumValues(CryptoSyncKey,
                 CpckDeleteCheckpointCallback,
                 &Context);
    if (Context.dwId == 0) {
        //
        // The specified tree was not found.
        //
        DmCloseKey(CryptoSyncKey);
        return(ERROR_FILE_NOT_FOUND);
    }

    wsprintfW(ValueId,L"%08lx",Context.dwId);
    Status = DmDeleteValue(CryptoSyncKey, ValueId);
    DmCloseKey(CryptoSyncKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't delete value %1!ws! error %2!d!\n",
                   ValueId,
                   Status);
        return(Status);
    }

    //delete the file corresponding to this checkpoint
    Status = CpckDeleteCryptoFile(Resource, Context.dwId, NULL);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't delete checkpoint file , error %1!d!\n",
                   Status);
        return(Status);
    }

    return(Status);
} // CpckDeleteCryptoCheckpoint

DWORD
CpckRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    This is called when a resource is deleted to remove all the checkpoints
    and the related stuff in the registry.

Arguments:

    Resource - supplies the resource 

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status;

    //delete all the checkpoints corresponding to this resource
    Status = CpckDeleteCryptoFile(Resource, 0, NULL);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckRemoveResourceCheckpoints, CpckDeleteCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    

FnExit:
    return(Status);
} // CpckRemoveResourceCheckpoints


BOOL
CpckDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_DEL_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for deleting an old registry
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (memcmp(ValueData, Context->pbInfo, Context->cbInfo) == 0) {
        //
        // Found a match
        //
        Context->dwId = wcstol(ValueName, NULL, 16);  // skip past the 'Crypto' prefix
        return(FALSE);
    }
    return(TRUE);
} // CpckDeleteCheckpointCallback


DWORD
CpckGetCryptoCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Retrieves a list of the resource's crypto checkpoints

Arguments:

    Resource - Supplies the resource whose crypto checkpoints should be retrieved.

    OutBuffer - Supplies a pointer to the output buffer.

    OutBufferSize - Supplies the size (in bytes) of the output buffer.

    BytesReturned - Returns the number of bytes written to the output buffer.

    Required - Returns the number of bytes required. (if the output buffer was insufficient)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPCK_GET_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;
    DWORD Status;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmOpenKey(ResourceKey,
                           L"CryptoSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey == NULL) {
        //
        // No reg sync key, therefore there are no subtrees
        //
        return(ERROR_SUCCESS);
    }

    Context.cCheckpoints = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    Context.cbRequired = sizeof(WCHAR);
    if (OutBufferSize < sizeof(WCHAR) * 2)
    {
        Context.fNeedMoreData = TRUE;
        Context.cbAvailable = 0;
        *BytesReturned = 0;
    }
    else
    {
        Context.fNeedMoreData = FALSE;
        Context.cbAvailable = OutBufferSize - sizeof(WCHAR);
        Context.pbOutput = (BYTE*)(OutBuffer);
        *BytesReturned = sizeof(WCHAR) * 2;
    }

    DmEnumValues(CryptoSyncKey,
                 CpckGetCheckpointsCallback,
                 &Context);

    DmCloseKey(CryptoSyncKey);

    if ((0 != Context.cCheckpoints) && Context.fNeedMoreData) {
        Status = ERROR_MORE_DATA;
    } else {
        Status = ERROR_SUCCESS;
    }

    if ( 0 == Context.cCheckpoints ) {
        *BytesReturned = 0;
        *Required = 0;
    } else {
        if ( Context.fNeedMoreData ) {
            *Required = Context.cbRequired;
        } else {
            *BytesReturned = (DWORD)(Context.pbOutput - OutBuffer);
        }
    }


    return(Status);
} // CpckGetCryptoCheckpoints

BOOL
CpckGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_GET_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for retrieving all of a resource's
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

--*/

{
    Context->cbRequired += ValueSize;
    Context->cCheckpoints++;
    if (Context->cbAvailable >= ValueSize) {
        CopyMemory(Context->pbOutput, ValueData, ValueSize);
        Context->pbOutput += ValueSize;
        Context->cbAvailable -= ValueSize;
    } else {
        Context->fNeedMoreData = TRUE;
    }
    return(TRUE);
} // CpckGetCheckpointsCallback

DWORD
CpckGenSymKey(
    IN HCRYPTPROV hProv,
    IN BYTE *pbSalt,
    IN BYTE *pbIV,
    OUT HCRYPTKEY *phSymKey
    )

/*++

Routine Description:

    Generate a session key based on the specified Salt and IV.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pbSalt - Salt value

    pbIV - IV value

    phSymKey - Resulting symmetric key (CALG_RC2)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    HCRYPTHASH hHash = 0;
    DWORD cbPassword = 0;
    DWORD Status;

    if (!CryptCreateHash(hProv,
                         CALG_SHA1,
                         0,
                         0,
                         &hHash))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (!CryptHashData(hHash,
                       pbSalt,
                       SALT_SIZE,
                       0))
    {
        Status = GetLastError();
        goto Ret;
    }

    // derive the key from the hash
    if (!CryptDeriveKey(hProv,
                        CALG_RC2,
                        hHash,
                        0,
                        phSymKey))
    {
        Status = GetLastError();
        goto Ret;
    }

    // set the IV on the key
    if (!CryptSetKeyParam(*phSymKey,
                          KP_IV,
                          pbIV,
                          0))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (hHash)
        CryptDestroyHash(hHash);

    return (Status);
} // CpckGenSymKey

DWORD
CpckExportPrivateKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN BYTE *pbIV,
    IN BYTE *pbSalt,
    OUT BYTE *pbExportedKey,
    OUT DWORD *pcbExportedKey
    )

/*++

Routine Description:

    Exports the private key data.

Arguments:

    hProv - Handle to the crypto provider (key container)

    hKey - Handle to the key to export

    pbIV - IV for the symmetric key

    pbSalt - Salt to generate symmetric key

    pbExportedKey - Supplies the buffer the key is to be exported into

    pcbExportedKey - Supplies the length of the buffer, if pbExportedKey is
                     NULL then this will be the length of the key to export

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    HCRYPTKEY hSymKey = 0;
    DWORD Status;

    // create the symmetric key to encrypt the private key with
    Status = CpckGenSymKey(hProv,
                           pbSalt,
                           pbIV,
                           &hSymKey);
    if (0 != Status)
    {
        goto Ret;
    }


    // Export the key
    if (!CryptExportKey(hKey,
                        hSymKey,
                        PRIVATEKEYBLOB,
                        0,
                        pbExportedKey,
                        pcbExportedKey))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (hSymKey)
        CryptDestroyKey(hSymKey);

    return (Status);
} // CpckExportPrivateKey


DWORD
CpckGetKeyContainerSecDescr(
    IN HCRYPTPROV hProv,
    OUT PSECURITY_DESCRIPTOR *ppSecDescr,
    OUT DWORD *pcbSecDescr
    )
/*++

Routine Description:

    Gets the key container security descriptor so that when replicated
    the same descriptor may be set on the replicated key.

Arguments:

    hProv - Handle to the crypto provider (key container)

    ppSecDescr - Pointer to buffer holding security descriptor

    pcbSecDescr - Pointer to the length of the returned security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PTOKEN_PRIVILEGES pPrevPriv = NULL;
    DWORD cbPrevPriv = 0;
    BYTE rgbNewPriv[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];
    PTOKEN_PRIVILEGES pNewPriv = (PTOKEN_PRIVILEGES)rgbNewPriv;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    HANDLE hToken = 0;
    PSECURITY_DESCRIPTOR pNewSD = NULL;
    DWORD dw;
    DWORD dwFlags;
    DWORD Status = ERROR_SUCCESS;

    // check if there is a thread token
    if (FALSE == OpenThreadToken(GetCurrentThread(),
                                 MAXIMUM_ALLOWED,
                                 TRUE,
                                 &hToken))
    {
        // get the process token
        if (FALSE == OpenProcessToken(GetCurrentProcess(),
                                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                      &hToken))
        {
            Status = GetLastError();
            goto Ret;
        }
    }

    // set up the new priviledge state
    memset(rgbNewPriv, 0, sizeof(rgbNewPriv));
    pNewPriv->PrivilegeCount = 1;
    if(!LookupPrivilegeValueW(NULL, SE_SECURITY_NAME,
                              &(pNewPriv->Privileges[0].Luid)))
    {
        goto Ret;
    }
    pNewPriv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // get the length of the previous state
    AdjustTokenPrivileges(hToken,
                          FALSE,
                          (PTOKEN_PRIVILEGES)pNewPriv,
                          sizeof(dw),
                          (PTOKEN_PRIVILEGES)&dw,
                          &cbPrevPriv);

    // alloc for the previous state
    if (NULL == (pPrevPriv = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,
                                                           cbPrevPriv)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // adjust the priviledge and get the previous state
    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               pNewPriv,
                               cbPrevPriv,
                               (PTOKEN_PRIVILEGES)pPrevPriv,
                               &cbPrevPriv))
    {
        Status = GetLastError();
        goto Ret;
    }

    dwFlags = OWNER_SECURITY_INFORMATION | 
              GROUP_SECURITY_INFORMATION | 
              DACL_SECURITY_INFORMATION  |
              SACL_SECURITY_INFORMATION ;

    // get the security descriptor
    if (CryptGetProvParam(hProv,
                           PP_KEYSET_SEC_DESCR,
                           NULL,
                           pcbSecDescr,
                           dwFlags))
    {
        if (NULL != (*ppSecDescr =
            (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT,
                                             *pcbSecDescr)))
        {
            if (!CryptGetProvParam(hProv,
                                   PP_KEYSET_SEC_DESCR,
                                   (BYTE*)(*ppSecDescr),
                                   pcbSecDescr,
                                   dwFlags))
            {
                Status = GetLastError();
            }
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        Status = GetLastError();
    }

    // adjust the priviledge to the previous state
    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               pPrevPriv,
                               0,
                               NULL,
                               NULL))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }

    // ge the control on the security descriptor to check if self relative
    if (!GetSecurityDescriptorControl(*ppSecDescr, 
                                      &Control,
                                      &dwRevision))
    {
        Status = GetLastError();
        goto Ret;
    }

    // if not self relative then make a self relative copy
    if (!(SE_SELF_RELATIVE & Control))
    {
        if (NULL == (pNewSD =
            (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT,
                                             *pcbSecDescr)))
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        if (!MakeSelfRelativeSD(*ppSecDescr,
                                pNewSD,
                                pcbSecDescr))
        {
            Status = GetLastError();
            goto Ret;
        }
        LocalFree(*ppSecDescr);
        *ppSecDescr = (BYTE*)pNewSD;
        pNewSD = NULL;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (pPrevPriv)
        LocalFree(pPrevPriv);
    if (pNewSD)
        LocalFree(pNewSD);
    if (hToken)
        CloseHandle(hToken);

    return Status;
} // CpckGetKeyContainerSecDescr

DWORD
CpckStoreKeyContainer(
    IN HCRYPTPROV hProv,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN LPWSTR TempFile
    )
/*++

Routine Description:

    Writes the key container associated with the provider handle to a
    the specified file.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pCryptoKeyInfo - Crypto key information (password if given)

    TempFile - Supplies the file which the key data is to be written to

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    CRYPTO_KEY_FILE_DATA KeyFileData;
    HCRYPTKEY hSigKey = 0;
    HCRYPTKEY hExchKey = 0;
    BYTE *pb = NULL;
    DWORD cb = 0;
    DWORD dwBytesWritten;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwPermissions = 0;
    DWORD cbPermissions ;
    PSECURITY_DESCRIPTOR pSecDescr = NULL;
    DWORD cbSecDescr;
    DWORD Status;

    memset(&KeyFileData, 0, sizeof(KeyFileData));

    // generate the necessary random data for salt and IVs.
    // calls with the sig IV buffer but this will fill the
    // exch IV and Salt as well since the buffer len is 32
    if (!CryptGenRandom(hProv,
                        sizeof(struct _CRYPTO_KEY_FILE_INITIALIZATION_DATA),
                        KeyFileData.rgbSigIV))
    {
        Status = GetLastError();
        goto Ret;
    }
    KeyFileData.dwVersion = CRYPTO_KEY_FILE_DATA_VERSION;

    // calculate the length of key data
    cb = sizeof(KeyFileData);

    // get the self relative security descriptor
    Status = CpckGetKeyContainerSecDescr(hProv,
                                         &pSecDescr,
                                         &cbSecDescr);
    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }
    cb += cbSecDescr;

    // get sig key length if necessary
    if (CryptGetUserKey(hProv, AT_SIGNATURE, &hSigKey))
    {
        // check if key is exportable
        cbPermissions = sizeof(DWORD);
        if (!CryptGetKeyParam(hSigKey,
                              KP_PERMISSIONS,
                              (BYTE*)&dwPermissions,
                              &cbPermissions,
                              0))
        {
            Status = GetLastError();
            goto Ret;
        }
        if (!(dwPermissions & CRYPT_EXPORT))
        {
            Status = (DWORD)NTE_BAD_KEY;
            goto Ret;
        }

        // get the sig key length
        Status = CpckExportPrivateKey(hProv,
                                      hSigKey,
                                      KeyFileData.rgbSigIV,
                                      KeyFileData.rgbSalt,
                                      NULL,
                                      &(KeyFileData.cbSig));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbSig;
    }

    // get key exchange key length if necessary
    if (CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hExchKey))
    {
        // check if key is exportable
        dwPermissions = 0;
        cbPermissions = sizeof(DWORD);
        if (!CryptGetKeyParam(hExchKey,
                              KP_PERMISSIONS,
                              (BYTE*)&dwPermissions,
                              &cbPermissions,
                              0))
        {
            Status = GetLastError();
            goto Ret;
        }
        if (!(dwPermissions & CRYPT_EXPORT))
        {
            Status = (DWORD)NTE_BAD_KEY;
            goto Ret;
        }

        // get the exchange key length
        Status = CpckExportPrivateKey(hProv,
                                      hExchKey,
                                      KeyFileData.rgbExchIV,
                                      KeyFileData.rgbSalt,
                                      NULL,
                                      &(KeyFileData.cbExch));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbExch;
    }

    // allocate space for the keys
    if (NULL == (pb = LocalAlloc(LMEM_ZEROINIT, cb)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // copy the key file data into the pb
    cb = sizeof(KeyFileData);

    // copy the signature key
    if (0 != hSigKey)
    {
        Status = CpckExportPrivateKey(hProv,
                                      hSigKey,
                                      KeyFileData.rgbSigIV,
                                      KeyFileData.rgbSalt,
                                      pb + cb,
                                      &(KeyFileData.cbSig));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbSig;
    }
    // copy the key exchange key
    if (0 != hExchKey)
    {
        Status = CpckExportPrivateKey(hProv,
                                      hExchKey,
                                      KeyFileData.rgbExchIV,
                                      KeyFileData.rgbSalt,
                                      pb + cb,
                                      &(KeyFileData.cbExch));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbExch;
    }

    // copy the security descriptor
    CopyMemory(pb + cb, (BYTE*)pSecDescr, cbSecDescr);
    cb += cbSecDescr;

    // copy the lengths
    CopyMemory(pb, &KeyFileData, sizeof(KeyFileData));

    // write the buffer to the file
    hFile = CreateFileW(TempFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        Status = GetLastError();
        goto Ret;
    }

    if (!WriteFile(hFile, pb, cb, &dwBytesWritten, NULL))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (pSecDescr)
        LocalFree(pSecDescr);
    if(INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (pb)
        LocalFree(pb);
    if (hSigKey)
        CryptDestroyKey(hSigKey);
    if (hExchKey)
        CryptDestroyKey(hExchKey);

    return (Status);
} // CpckStoreKeyContainer


DWORD
CpckSaveCheckpointToFile(
    IN HCRYPTPROV hProv,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN LPWSTR   TempFile)
/*++

Routine Description:

    have DM create a temp file and call the routine that exports the keys and
    writes the checkpoint file.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pCryptoKeyInfo - Crypto key information (password if given)

    TempFile - Supplies the file which the key data is to be written to

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD   Status;
    
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        TempFile[0] = L'\0';
        return(Status);
    }

    // put the key information into the file
    Status = CpckStoreKeyContainer(hProv, pCryptoKeyInfo, TempFile);
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckSaveCheckpointToFile failed to get store container %1!ws! %2!ws! to file %3!ws! error %4!d!\n",
                   pCryptoKeyInfo->pwszContainer,
                   pCryptoKeyInfo->pwszProvName,
                   TempFile,
                   Status);
        CL_LOGFAILURE(Status);
        DeleteFile(TempFile);
        TempFile[0] = L'\0';
    }        

    return(Status);
} // CpckSaveCheckpointToFile


DWORD
CpckCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HCRYPTPROV hProv,
    IN DWORD dwId,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo
    )
/*++

Routine Description:

    Takes a checkpoint of the specified crypto key.

Arguments:

    Resource - Supplies the resource this is a checkpoint for.

    hKey - Supplies the crypto info to checkpoint

    dwId - Supplies the checkpoint ID.

    KeyName - Supplies the name of the registry key.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    WCHAR TempFile[MAX_PATH];

    Status = CpckSaveCheckpointToFile(hProv, pCryptoKeyInfo, TempFile);
    if (Status == ERROR_SUCCESS)
    {
        //
        // Got a file with the right bits in it. Checkpoint the
        // file.
        //
        Status = CpSaveDataFile(Resource,
                                dwId,
                                TempFile,
                                TRUE);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CPCK] CpckCheckpoint - CpSaveData failed %1!d!\n",
                       Status);
        }
    }
    //if the file was created, delete it
    if (TempFile[0] != L'\0')
        DeleteFile(TempFile);

    return(Status);
} // CpckCheckpoint

DWORD
CpckSetKeyContainerSecDescr(
    IN HCRYPTPROV hProv,
    IN BYTE *pbSecDescr,
    IN DWORD cbSecDescr
    )
/*++

Routine Description:

    Sets the key container security descriptor.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pbSecDescr - Buffer holding security descriptor

    cbSecDescr - Length of the security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PTOKEN_PRIVILEGES pPrevPriv = NULL;
    DWORD cbPrevPriv = 0;
    BYTE rgbNewPriv[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];
    PTOKEN_PRIVILEGES pNewPriv = (PTOKEN_PRIVILEGES)rgbNewPriv;
    HANDLE hToken = 0;
    DWORD dw;
    DWORD dwFlags;
    DWORD Status = ERROR_SUCCESS;

    // check if there is a thread token
    if (FALSE == OpenThreadToken(GetCurrentThread(),
                                 MAXIMUM_ALLOWED,
                                 TRUE,
                                 &hToken))
    {
        // get the process token
        if (FALSE == OpenProcessToken(GetCurrentProcess(),
                                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                      &hToken))
        {
            Status = GetLastError();
            goto Ret;
        }
    }

    // set up the new priviledge state
    memset(rgbNewPriv, 0, sizeof(rgbNewPriv));
    pNewPriv->PrivilegeCount = 1;
    if(!LookupPrivilegeValueW(NULL, SE_SECURITY_NAME,
                              &(pNewPriv->Privileges[0].Luid)))
    {
        goto Ret;
    }
    pNewPriv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // get the length of the previous state
    AdjustTokenPrivileges(hToken,
                          FALSE,
                          (PTOKEN_PRIVILEGES)pNewPriv,
                          sizeof(dw),
                          (PTOKEN_PRIVILEGES)&dw,
                          &cbPrevPriv);

    // alloc for the previous state
    if (NULL == (pPrevPriv = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,
                                                           cbPrevPriv)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // adjust the priviledge and get the previous state
    AdjustTokenPrivileges(hToken,
                          FALSE,
                          pNewPriv,
                          cbPrevPriv,
                          (PTOKEN_PRIVILEGES)pPrevPriv,
                          &cbPrevPriv);

    dwFlags = OWNER_SECURITY_INFORMATION | 
              GROUP_SECURITY_INFORMATION | 
              DACL_SECURITY_INFORMATION  |
              SACL_SECURITY_INFORMATION ;

    // get the security descriptor
    if (!CryptSetProvParam(hProv,
                           PP_KEYSET_SEC_DESCR,
                           pbSecDescr,
                           dwFlags))
    {
        Status = GetLastError();
    }

    // adjust the priviledge to the previous state
    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               pPrevPriv,
                               0,
                               NULL,
                               NULL))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (pPrevPriv)
        LocalFree(pPrevPriv);
    if (hToken)
        CloseHandle(hToken);

    return Status;
} // CpckSetKeyContainerSecDescr


DWORD
CpckImportPrivateKey(
                     IN HCRYPTPROV hProv,
                     IN BYTE *pbIV,
                     IN BYTE *pbSalt,
                     IN BYTE *pbKey,
                     IN DWORD cbKey
                     )
/*++

Routine Description:

    Exports the private key data.

Arguments:

    hProv - Handle to the crypto provider (key container)

    hKey - Handle to the key to export

    pbIV - IV for the symmetric key

    pbSalt - Salt to generate symmetric key

    pbKey - Supplies the buffer the key is in

    cbKey - Supplies the length of the key buffer

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    BOOLEAN WasEnabled;
    HCRYPTKEY hSymKey = 0;
    HCRYPTKEY hKey = 0;
    DWORD Status = ERROR_SUCCESS;

    // create the symmetric key to encrypt the private key with
    Status = CpckGenSymKey(hProv,
                           pbSalt,
                           pbIV,
                           &hSymKey);
    if (0 != Status)
    {
        goto Ret;
    }

    // Import the key
    if (!CryptImportKey(hProv,
                        pbKey,
                        cbKey,
                        hSymKey,
                        CRYPT_EXPORTABLE,
                        &hKey))
    {
        // if failed then try with BACKUP/RESTORE
        ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           &WasEnabled);
        if (!CryptImportKey(hProv,
                            pbKey,
                            cbKey,
                            hSymKey,
                            CRYPT_EXPORTABLE,
                            &hKey))
        {
            Status = GetLastError();
        }
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    }

Ret:
    if (hSymKey)
        CryptDestroyKey(hSymKey);
    if (hKey)
        CryptDestroyKey(hKey);

    return (Status);
} // CpckImportPrivateKey



DWORD
CpckInstallKeyContainer(
    IN HCRYPTPROV hProv,
    IN LPWSTR   FileName
    )
/*++

Routine Description:

    Installs new crypto key information from a specified file.

Arguments:

    hProv - Supplies the provider handle where FileName will be installed to.

    FileName - The name of the file from which to read the crypto key info
               to install.

Return Value:

    ERROR_SUCCESS if the installation completed successfully

    Win32 error code otherwise.

--*/

{
    HANDLE hMap = NULL;
    BYTE *pbFile = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbFile = 0;
    DWORD *pdwVersion;
    CRYPTO_KEY_FILE_DATA *pKeyFileData;
    DWORD Status;

    // read the key data from the file
    hFile = CreateFileW(FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        Status = GetLastError();
        goto Ret;
    }

    if (0xFFFFFFFF == (cbFile = GetFileSize(hFile, NULL)))
    {
        Status = GetLastError();
        goto Ret;
    }
    if (sizeof(CRYPTO_KEY_FILE_DATA) > cbFile)
    {
        Status = ERROR_FILE_INVALID;
        goto Ret;
    }
 
    if (NULL == (hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,
                                          0, 0, NULL)))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (NULL == (pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ,
                                               0, 0, 0 )))
    {
        Status = GetLastError();
        goto Ret;
    }

    // get the length information out of the file
    pKeyFileData = (CRYPTO_KEY_FILE_DATA*)pbFile;
    if (CRYPTO_KEY_FILE_DATA_VERSION != pKeyFileData->dwVersion)
    {
        Status = ERROR_FILE_INVALID;
        goto Ret;
    }
    if ((sizeof(CRYPTO_KEY_FILE_DATA) + pKeyFileData->cbSig +
         pKeyFileData->cbExch) > cbFile)
    {
        Status = ERROR_FILE_INVALID;
        goto Ret;
    }

    if (pKeyFileData->cbSig)
    {
        // import the sig key if there is one
        Status = CpckImportPrivateKey(hProv,
                                      pKeyFileData->rgbSigIV,
                                      pKeyFileData->rgbSalt,
                                      pbFile + sizeof(CRYPTO_KEY_FILE_DATA),
                                      pKeyFileData->cbSig);
        if (0 != Status)
        {
            goto Ret;
        }
    }

    if (pKeyFileData->cbExch)
    {
        // import the exch key if there is one
        Status = CpckImportPrivateKey(hProv,
                                      pKeyFileData->rgbExchIV,
                                      pKeyFileData->rgbSalt,
                                      pbFile + sizeof(CRYPTO_KEY_FILE_DATA) +
                                          pKeyFileData->cbSig,
                                      pKeyFileData->cbExch);
        if (0 != Status)
        {
            goto Ret;
        }
    }

    Status = CpckSetKeyContainerSecDescr(hProv,
                                pbFile + sizeof(CRYPTO_KEY_FILE_DATA) +
                                    pKeyFileData->cbSig + pKeyFileData->cbExch,
                                pKeyFileData->cbSecDescr);
    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if(pbFile)
        UnmapViewOfFile(pbFile);

    if(hMap)
        CloseHandle(hMap);

    if(INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    return(Status);
} // CpckInstallKeyContainer

DWORD
CpckDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    Gets the file corresponding to the checkpoint id relative
    to the supplied path and deletes it.

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if the completed successfully

    Win32 error code otherwise.

--*/
    
{    
    DWORD   Status;
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;

    Status = CppGetCheckpointFile(Resource, dwCheckpointId,
        &pszDirectoryName, &pszFileName, lpszQuorumPath, TRUE);


    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteFile- couldnt get checkpoint file name, error %1!d!\n",
                   Status);
        goto FnExit;
    }


    if (!DeleteFileW(pszFileName))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteFile - couldn't delete the file, error %1!d!\n",
                   Status);
        goto FnExit;                   
    }

    //
    // Now try and delete the directory.
    //
    if (!RemoveDirectoryW(pszDirectoryName)) 
    {
        //if there is a failure, we still return success
        //because it may not be possible to delete a directory
        //when it is not empty
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckDeleteFile- unable to remove directory %1!ws!, error %2!d!\n",
                      pszDirectoryName,
                      GetLastError());
    }

FnExit:
    if (pszFileName)
        LocalFree(pszFileName);
    if (pszDirectoryName)
        LocalFree(pszDirectoryName);

    return(Status);
} // CpckDeleteFile

BOOL
CpckRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Registry value enumeration callback used when the quorum resource
    is changing. Deletes the specified checkpoint file from the old
    quorum directory.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (old path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{

    DWORD Status;
    DWORD Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckRemoveCheckpointFileCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    Status = CpckDeleteFile(Context->Resource, Id, Context->lpszPathName);
    
    return(TRUE);
} // CpckRemoveCheckpointFileCallback


DWORD
CpckDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR  lpszQuorumPath
    )
/*++

Routine Description:

    Deletes the checkpoint file corresponding the resource.
    This node must be the owner of the quorum resource

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if completed successfully

    Win32 error code otherwise.

--*/

{

    DWORD               Status;
    HDMKEY              ResourceKey;
    HDMKEY              CryptoSyncKey;
    CP_CALLBACK_CONTEXT Context;


    if (dwCheckpointId)
    {
        Status = CpckDeleteFile(Resource, dwCheckpointId, lpszQuorumPath);
    }
    else
    {
        HDMKEY              ResourceKey;
        HDMKEY              CryptoSyncKey;
        CP_CALLBACK_CONTEXT Context;

    
        //delete all checkpoints corresponding to this resource
        
        //
        // Open up the resource's key
        //
        ResourceKey = DmOpenKey(DmResourcesKey,
                                OmObjectId(Resource),
                                KEY_READ);
        CL_ASSERT(ResourceKey != NULL);

        //
        // Open up the CryptoSync key
        //
        CryptoSyncKey = DmOpenKey(ResourceKey,
                               L"CryptoSync",
                               KEY_READ | KEY_WRITE);
        DmCloseKey(ResourceKey);
        if (CryptoSyncKey == NULL)
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                       "[CPCK] CpckDeleteCheckpointFile- couldn't open CryptoSync key error %1!d!\n",
                       Status);
            goto FnExit;
        }

        Context.lpszPathName = lpszQuorumPath;
        Context.Resource = Resource;

        //
        // Enumerate all the values and delete them one by one.
        //
        DmEnumValues(CryptoSyncKey,
                     CpckRemoveCheckpointFileCallback,
                     &Context);
    }

FnExit:
    return(Status);

} // CpckDeleteCheckpointFile


DWORD
CpckDeleteCryptoFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    This function removes the checkpoint file correspoinding to the
    checkpoint id for a given resource from the given directory.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszQuorumPath - Supplies the path of the cluster files on a quorum device.                    

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID  OwnerNode;
    DWORD       Status;

    do {
        OwnerNode = CppGetQuorumNodeId();
        ClRtlLogPrint(LOG_NOISE,
                   "[CPCK] CpckDeleteCryptoFile: removing checkpoint file for id %1!d! at quorum node %2!d!\n",
                    dwCheckpointId,
                    OwnerNode);
        if (OwnerNode == NmLocalNodeId) 
        {
            Status = CpckDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
        } 
        else
        {
            Status = CpDeleteCryptoCheckpoint(Session[OwnerNode],
                            OmObjectId(Resource),
                            dwCheckpointId,
                            lpszQuorumPath);

            //talking to an old server, cant perform this function
            //ignore the error
            if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
                Status = ERROR_SUCCESS;        
        }

        if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
            //
            // This node no longer owns the quorum resource, retry.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CPCK] CpckDeleteCryptoFile: quorum owner %1!d! no longer owner\n",
                        OwnerNode);
        }
    } while ( Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER );
    return(Status);
} // CpckDeleteCryptoFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\cpinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cpinit.c

Abstract:

    Initialization and shutdown code for the Checkpoint Manager (CP)

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"


BOOL
CppCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );

BOOL
CpckCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );

BOOL
CppEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );

BOOL
CpckEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );


VOID
CppResourceNotify(
    IN PVOID Context,
    IN PFM_RESOURCE Resource,
    IN DWORD NotifyCode
    )
/*++

Routine Description:

    Resource notification callback for hooking resource state
    changes. This allows to to register/deregister our registry
    notifications for that resource.

Arguments:

    Context - Supplies the context. Not used

    Resource - Supplies the resource that is going online or
        has been taken offline.

    NotifyCode - Supplies the type of notification, either
        NOTIFY_RESOURCE_PREONLINE or NOTIFY_RESOURCE_POSTOFFLINE
        /NOTIFY_RESOURCE_FAILED.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppResourceNotify for resource %1!ws!\n",
               OmObjectName(Resource));

    if ( Resource->QuorumResource ) {
        return;
    }

    if (NotifyCode == NOTIFY_RESOURCE_PREONLINE) {
        //
        // Restore any checkpointed registry state for this resource
        // This will also start the registry notification thread.
        //
        Resource->CheckpointState = 0;
        Status = CppWatchRegistry(Resource);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWatchRegistry for resource %1!ws! failed %2!d!\n",
                       OmObjectName(Resource),
                       Status);
        }

        Status = CpckReplicateCryptoKeys(Resource);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpckReplicateCryptoKeys for resource %1!ws! failed %2!d!\n",
                       OmObjectName(Resource),
                       Status);
        }
    } else {
        CL_ASSERT(NotifyCode == NOTIFY_RESOURCE_POSTOFFLINE ||
            NotifyCode == NOTIFY_RESOURCE_FAILED);
        //
        // Remove any posted registry notification for this resource
        //
        Status = CppRundownCheckpoints(Resource);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppUnWatchRegistry for resource %1!ws! failed %2!d!\n",
                       OmObjectName(Resource),
                       Status);
        }
    }
}


DWORD
CpInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the checkpoint manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    InitializeCriticalSection(&CppNotifyLock);
    InitializeListHead(&CpNotifyListHead);
    //
    // Register for resource online/offline notifications
    //
    Status = OmRegisterTypeNotify(ObjectTypeResource,
                                  NULL,
                                  NOTIFY_RESOURCE_PREONLINE |
                                  NOTIFY_RESOURCE_POSTOFFLINE|
                                  NOTIFY_RESOURCE_FAILED,
                                  CppResourceNotify);

    return(ERROR_SUCCESS);
}


DWORD
CpShutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down the Checkpoint Manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DeleteCriticalSection(&CppNotifyLock);
    return(ERROR_SUCCESS);
}


DWORD
CpCompleteQuorumChange(
    IN LPCWSTR lpszOldQuorumPath
    )
/*++

Routine Description:

    Completes a change of the quorum disk. This involves deleting
    all the checkpoint files on the old quorum disk.

    Simple algorithm used here is to enumerate all the resources.
    For each resource, enumerate all its checkpoints and delete the
    checkpoint files.

Arguments:

    lpszNewQuorumPath - Supplies the new quorum path.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_CALLBACK_CONTEXT CbContext;

    CbContext.lpszPathName = lpszOldQuorumPath;
    
    OmEnumObjects(ObjectTypeResource,
                  CppEnumResourceCallback,
                  (PVOID)&CbContext,
                  CppRemoveCheckpointFileCallback);

    OmEnumObjects(ObjectTypeResource,
                  CpckEnumResourceCallback,
                  (PVOID)&CbContext,
                  CpckRemoveCheckpointFileCallback);

    return(ERROR_SUCCESS);
}


DWORD
CpCopyCheckpointFiles(
    IN LPCWSTR lpszPathName,
    IN BOOL    IsChangeFileAttribute
    )
/*++

Routine Description:

    Copies all the checkpoint files from the quorum disk to the supplied
    directory path. This function is invoked whenever the quorum disk
    changes or when the user wants to make a backup of the cluster DB
    on the quorum disk.

    Simple algorithm used here is to enumerate all the resources.
    For each resource, enumerate all its checkpoints and copy the
    checkpoint files from the quorum disk to the supplied path.

Arguments:

    lpszPathName - Supplies the destination path name.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_CALLBACK_CONTEXT CbContext;

    CbContext.lpszPathName = lpszPathName;
    CbContext.IsChangeFileAttribute = IsChangeFileAttribute;
   
    OmEnumObjects(ObjectTypeResource,
                  CppEnumResourceCallback,
                  (PVOID)&CbContext,
                  CppCopyCheckpointCallback);

    OmEnumObjects(ObjectTypeResource,
                  CpckEnumResourceCallback,
                  (PVOID)&CbContext,
                  CpckCopyCheckpointCallback);

    return(ERROR_SUCCESS);
}


BOOL
CppEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PENUM_VALUE_CALLBACK lpValueEnumRoutine,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource enumeration callback for copying or deleting checkpoints
    when the quorum resource changes or when the user is making
    a backup of the cluster DB on the quorum disk.

Arguments:

    lpszPathName - Supplies the new quorum path to be passed to lpValueEnumRoutine.

    lpValueEnumRoutine - Supplies the value enumeration callback to
        be called if checkpoints exist.

    Resource - Supplies the resource object.

    Name - Supplies the resource name

Return Value:

    TRUE to continue enumeration

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;
    CP_CALLBACK_CONTEXT Context;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    if (ResourceKey != NULL) {

        //
        // Open up the RegSync key
        //
        RegSyncKey = DmOpenKey(ResourceKey,
                               L"RegSync",
                               KEY_READ);
        DmCloseKey(ResourceKey);
        if (RegSyncKey != NULL) {

            Context.lpszPathName = pCbContext->lpszPathName;
            Context.Resource = Resource;
            Context.IsChangeFileAttribute = pCbContext->IsChangeFileAttribute;
            DmEnumValues(RegSyncKey,
                         lpValueEnumRoutine,
                         &Context);
            DmCloseKey(RegSyncKey);
        }
    }

    return(TRUE);
}


BOOL
CppCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Registry value enumeration callback used when the quorum resource
    is changing or when the user is making a backup of the cluster DB
    on the quorum disk. Copies the specified checkpoint file from the 
    current quorum directory to the supplied path (in the Context parameter).

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (new path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{
    WCHAR  OldCheckpointFile[MAX_PATH+1];
    LPWSTR NewCheckpointDir;
    LPWSTR NewCheckpointFile;
    DWORD  Status;
    DWORD  Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppCopyCheckpointCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get a temporary file name for saving the old checkpoint file
    //
    Status = DmCreateTempFileName(OldCheckpointFile);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback - DmCreateTempFileName for old file failed with status %1!d! for resource %2!ws!...\n",
                   Status,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    //  Get the old checkpoint file from the node hosting the quorum resource
    //
    Status = CpGetDataFile(Context->Resource,
                           Id,
                           OldCheckpointFile,
                           FALSE);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback - CpGetDataFile for checkpoint ID %2!d! failed with status %1!d! for resource %3!ws!...\n",
                   Status,
                   Id,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get the new checkpoint file and directory
    //
    Status = CppGetCheckpointFile(Context->Resource,
                                  Id,
                                  &NewCheckpointDir,
                                  &NewCheckpointFile,
                                  Context->lpszPathName,
                                  FALSE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback - CppGetCheckpointFile for new file failed %1!d!\n",
                   Status);
        return(TRUE);
    }

    //
    //  If necessary, try to change the file attributes to NORMAL
    //
    if (Context->IsChangeFileAttribute == TRUE) {
        SetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_NORMAL);
        SetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_NORMAL);
    }


    //
    // Create the new directory.
    //
    if (!CreateDirectory(NewCheckpointDir, NULL)) {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppCopyCheckpointCallback unable to create directory %1!ws!, error %2!d!\n",
                       NewCheckpointDir,
                       Status);
            LocalFree(NewCheckpointFile);
            LocalFree(NewCheckpointDir);
            return(TRUE);
        }
        Status = ERROR_SUCCESS;
    }

    //
    // Copy the old file to the new file
    //
    if (!CopyFile(OldCheckpointFile, NewCheckpointFile, FALSE)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   OldCheckpointFile,
                   NewCheckpointFile,
                   Status);
    }

    //
    //  If necessary, change the file attributes to READONLY
    //
    if ((Status == ERROR_SUCCESS) && (Context->IsChangeFileAttribute == TRUE)) {
        if (!SetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_READONLY)
            ||
            !SetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_READONLY)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CP] CppCopyCheckpointCallback unable to change file attributes in %1!ws!, error %2!d!\n",
                    NewCheckpointDir,
                    Status);
        }
    }

    LocalFree(NewCheckpointFile);
    LocalFree(NewCheckpointDir);
    return(TRUE);
}


BOOL
CppRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Registry value enumeration callback used when the quorum resource
    is changing. Deletes the specified checkpoint file from the old
    quorum directory.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (old path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{

    DWORD Status;
    DWORD Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppRemoveCheckpointFileCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    Status = CppDeleteFile(Context->Resource, Id, Context->lpszPathName);
    
    return(TRUE);
}

BOOL
CpckEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PENUM_VALUE_CALLBACK lpValueEnumRoutine,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource enumeration callback for copying or deleting crypto checkpoints
    when the quorum resource changes or when the user is making
    a backup of the cluster DB on the quorum disk.

Arguments:

    lpszPathName - Supplies the new quorum path to be passed to lpValueEnumRoutine.

    lpValueEnumRoutine - Supplies the value enumeration callback to
        be called if checkpoints exist.

    Resource - Supplies the resource object.

    Name - Supplies the resource name

Return Value:

    TRUE to continue enumeration

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;
    CP_CALLBACK_CONTEXT Context;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    if (ResourceKey != NULL) {

        //
        // Open up the CryptoSyncKey key
        //
        CryptoSyncKey = DmOpenKey(ResourceKey,
                               L"CryptoSync",
                               KEY_READ);
        DmCloseKey(ResourceKey);
        if (CryptoSyncKey != NULL) {

            Context.lpszPathName = pCbContext->lpszPathName;
            Context.Resource = Resource;
            Context.IsChangeFileAttribute = pCbContext->IsChangeFileAttribute;
            DmEnumValues(CryptoSyncKey,
                         lpValueEnumRoutine,
                         &Context);
            DmCloseKey(CryptoSyncKey);
        }
    }

    return(TRUE);
}


BOOL
CpckCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Crypto key enumeration callback used when the quorum resource
    is changing or when the user is making a backup of the cluster DB
    on the quorum disk. Copies the specified checkpoint file from the 
    current quorum directory to the supplied path (in the Context parameter).

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (new path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{
    WCHAR  OldCheckpointFile[MAX_PATH+1];
    LPWSTR NewCheckpointDir;
    LPWSTR NewCheckpointFile;
    DWORD  Status;
    DWORD  Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckCopyCheckpointCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get a temporary file name for saving the old checkpoint file
    //
    Status = DmCreateTempFileName(OldCheckpointFile);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpckCopyCheckpointCallback - DmCreateTempFileName for old file failed with status %1!d! for resource %2!ws!...\n",
                   Status,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    //  Get the old checkpoint file from the node hosting the quorum resource
    //
    Status = CpGetDataFile(Context->Resource,
                           Id,
                           OldCheckpointFile,
                           TRUE);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpckCopyCheckpointCallback - CpGetDataFile for checkpoint ID %2!d! failed with status %1!d! for resource %3!ws!...\n",
                   Status,
                   Id,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get the new checkpoint file and directory
    //
    Status = CppGetCheckpointFile(Context->Resource,
                                  Id,
                                  &NewCheckpointDir,
                                  &NewCheckpointFile,
                                  Context->lpszPathName,
                                  TRUE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckCopyCheckpointCallback - CppGetCheckpointFile for new file failed %1!d!\n",
                   Status);
        return(TRUE);
    }

    //
    //  If necessary, try to change the file attributes to NORMAL
    //
    if (Context->IsChangeFileAttribute == TRUE) {
        SetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_NORMAL);
        SetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_NORMAL);
    }


    //
    // Create the new directory.
    //
    if (!CreateDirectory(NewCheckpointDir, NULL)) {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CPCK] CpckCopyCheckpointCallback unable to create directory %1!ws!, error %2!d!\n",
                       NewCheckpointDir,
                       Status);
            LocalFree(NewCheckpointFile);
            LocalFree(NewCheckpointDir);
            return(TRUE);
        }
        Status = ERROR_SUCCESS;
    }

    //
    // Copy the old file to the new file
    //
    if (!CopyFile(OldCheckpointFile, NewCheckpointFile, FALSE)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckCopyCheckpointCallback unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   OldCheckpointFile,
                   NewCheckpointFile,
                   Status);
    }

    //
    //  If necessary, change the file attributes to READONLY
    //
    if ((Status == ERROR_SUCCESS) && (Context->IsChangeFileAttribute == TRUE)) {
        if (!SetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_READONLY)
            ||
            !SetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_READONLY)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CPCK] CpckCopyCheckpointCallback unable to change file attributes in %1!ws!, error %2!d!\n",
                    NewCheckpointDir,
                    Status);
        }
    }

    LocalFree(NewCheckpointFile);
    LocalFree(NewCheckpointDir);
    return(TRUE);
}

/****
@func       DWORD | CpRestoreCheckpointFiles | Create a directory if necessary
            and copy all the resource checkpoint files from the backup
            directory to the quorum disk

@parm       IN LPWSTR | lpszSourcePathName | The name of the source path
            where the files are backed up.

@parm       IN LPWSTR | lpszSubDirName | The name of the sub-directory under
            the source path which can be a possible candidate for 
            containing the resource checkpoint files.

@parm       IN LPCWSTR | lpszQuoLogPathName | The name of the quorum disk 
            path where the files will be restored.
                      
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@xref       <f DmpRestoreClusterDatabase> 
****/
DWORD CpRestoreCheckpointFiles(
    IN LPWSTR  lpszSourcePathName,
    IN LPWSTR  lpszSubDirName,
    IN LPCWSTR lpszQuoLogPathName )
{
    LPWSTR          szSourcePathName = NULL;
    LPWSTR          szSourceFileName = NULL;
    WCHAR           szDestPathName[MAX_PATH];
    WCHAR           szDestFileName[MAX_PATH];
    DWORD           dwLen;
    HANDLE          hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR           szTempCpFileNameExtn[10];
    DWORD           status;

    //
    //  Chittur Subbaraman (chitturs) - 10/20/98
    //

    dwLen = lstrlenW( lpszSourcePathName );
    dwLen += lstrlenW( lpszSubDirName );
    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 15 ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[CP] CpRestoreCheckpointFiles: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              lpszSourcePathName); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }
    
    lstrcpyW( szSourcePathName, lpszSourcePathName );
    lstrcatW( szSourcePathName, lpszSubDirName ); 
    
    if ( szSourcePathName[dwLen-1] != L'\\' )
    {
        szSourcePathName[dwLen++] = L'\\';
        szSourcePathName[dwLen] = L'\0';
    }

    mbstowcs ( szTempCpFileNameExtn, "*.CP*", 6 );
    lstrcatW ( szSourcePathName, szTempCpFileNameExtn );

    //
    //  Try to find the first file in the directory
    //
    hFindFile = FindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[CP] CpRestoreCheckpointFiles: No file can be found in the supplied path %1!ws! Error = %2!%d! !!!\n",
                    szSourcePathName,
                    status);  
            CL_LOGFAILURE( status );
        } else
        {
            status = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    dwLen = lstrlenW( szSourcePathName );
    
    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 1 + LOG_MAX_FILENAME_LENGTH ) *
                                 sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[CP] CpRestoreCheckpointFiles: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              szSourcePathName); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }
      
    lstrcpyW( szDestPathName, lpszQuoLogPathName );
    lstrcatW( szDestPathName, lpszSubDirName );
    dwLen = lstrlenW( szDestPathName );
    
    if ( szDestPathName[dwLen-1] != L'\\' )
    {
        szDestPathName[dwLen++] = L'\\';
        szDestPathName[dwLen] = L'\0';
    }
    //
    // Create the new directory, if necessary
    //
    if ( !CreateDirectory ( szDestPathName, NULL ) ) 
    {
        status = GetLastError();
        if ( status != ERROR_ALREADY_EXISTS ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[CP] CpRestoreCheckpointFiles: Unable to create directory %1!ws!, error %2!d!\n",
                    szDestPathName,
                    status);
            CL_LOGFAILURE( status );
            goto FnExit;
        }
    }

    status = ERROR_SUCCESS;

    while ( status == ERROR_SUCCESS )
    {
        //
        //  Copy the checkpoint file to the destination
        //
        lstrcpyW( szSourceFileName, szSourcePathName );
        lstrcatW( szSourceFileName, FindData.cFileName );
        lstrcpyW( szDestFileName, szDestPathName );
        lstrcatW( szDestFileName, FindData.cFileName );

        status = CopyFileW( szSourceFileName, szDestFileName, FALSE );
        if ( !status ) 
        {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[CP] CpRestoreCheckpointFiles: Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                    szSourceFileName,
                    szDestFileName,
                    status);
            CL_LOGFAILURE( status );
            goto FnExit;
        } 

        //
        //  Set the file attribute to normal. Continue even if you 
        //  fail in this step but log an error. 
        //
        if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[CP] CpRestoreCheckpointFiles::Error in changing %1!ws! attribute to NORMAL\n",
                    szDestFileName);
        }

        if ( FindNextFile( hFindFile, &FindData ) )
        {
            status = ERROR_SUCCESS;
        } else
        {
            status = GetLastError();
        }
    }

    if ( status == ERROR_NO_MORE_FILES )
    {
        status = ERROR_SUCCESS;
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[CP] CpRestoreCheckpointFiles: FindNextFile failed !!!\n");
    }

FnExit:
    LocalFree( szSourcePathName );
    LocalFree( szSourceFileName );
    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        FindClose( hFindFile );
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    APIs for the server-side RPC support for the Checkpoint Manager

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"


error_status_t
CppDepositCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData,
    BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Server side RPC to allow other nodes to checkpoint data to the
    quorum disk.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose data is being checkpointed

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data can be retrieved.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status = ERROR_SUCCESS;
    LPWSTR FileName = NULL;
    LPWSTR DirectoryName = NULL;
    BOOL Success;
    PFM_RESOURCE Resource;
    HANDLE hDirectory = INVALID_HANDLE_VALUE;

    ACQUIRE_SHARED_LOCK(gQuoLock);

    Resource = OmReferenceObjectById(ObjectTypeResource, ResourceId);
    if (Resource == NULL) 
    {
        Status = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  &DirectoryName,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    OmDereferenceObject(Resource);
    
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDepositCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppDepositCheckpoint checkpointing data to file %1!ws!\n",
               FileName);
    //
    // Create the directory.
    //
    if (!CreateDirectory(DirectoryName, NULL)) 
    {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppDepositCheckpoint unable to create directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
        else
        {
            //the directory exists, set Status to ERROR_SUCCESS
            Status = ERROR_SUCCESS;
        }
    }
    else
    {
        //
        // The directory was newly created. Put the appropriate ACL on it
        // so that only ADMINs can read it.
        //
        hDirectory = CreateFile(DirectoryName,
                                GENERIC_READ | WRITE_DAC | READ_CONTROL,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_FLAG_BACKUP_SEMANTICS,
                                NULL);
        if (hDirectory == INVALID_HANDLE_VALUE) 
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppDepositCheckpoint unable to open directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
        Status = ClRtlSetObjSecurityInfo(hDirectory,
                                         SE_FILE_OBJECT,
                                         GENERIC_ALL,
                                         GENERIC_ALL,
                                         0);

        if (Status != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppDepositCheckpoint- unable to set ACL on directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
                                         
    }
    
    //
    // Pull the checkpoint data file across RPC
    //
    Status = DmPullFile(FileName, CheckpointData);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDepositCheckpoint - DmPullFile %1!ws! failed %2!d!\n",
                   FileName,
                   Status);
    }

FnExit:
    RELEASE_LOCK(gQuoLock);

    //clean up
    if (DirectoryName) LocalFree(DirectoryName);
    if (FileName) LocalFree(FileName);
    if (hDirectory != INVALID_HANDLE_VALUE)
        CloseHandle(hDirectory);

    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;

    //At this point, CppDepositCheckpoint should either 

    //a) throw the error code as an exception, or 
    //b) drain the [in] pipe and then return the error code normally

    //but if it returns without draining the pipe, and the RPC runtime throws 
    //the pipe-discipline exception.
    if (Status != ERROR_SUCCESS)
        RpcRaiseException(Status);

    return(Status);
}


error_status_t
s_CpDepositCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC to allow other nodes to checkpoint data to the
    quorum disk.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose data is being checkpointed

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data can be retrieved.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    return CppDepositCheckpoint(IDL_handle,
                                ResourceId,
                                dwCheckpointId,
                                CheckpointData,
                                FALSE
                                );
}


error_status_t
s_CpDepositCryptoCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC to allow other nodes to checkpoint data to the
    quorum disk.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose data is being checkpointed

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data can be retrieved.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    return CppDepositCheckpoint(IDL_handle,
                                ResourceId,
                                dwCheckpointId,
                                CheckpointData,
                                TRUE
                                );
}


error_status_t
CppRetrieveCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BOOLEAN fCryptoCheckpoint,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC through which data checkpointed to the quorum disk
    can be retrieved by other nodes.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint data is to be retrieved

    dwCheckpointId - Unique identifier of the checkpoint

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint

    CheckpointData - pipe through which checkpoint data should be sent

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPWSTR FileName=NULL;
    HANDLE hFile;
    BOOL Success;
    PFM_RESOURCE Resource;

    ACQUIRE_SHARED_LOCK(gQuoLock);
    Resource = OmReferenceObjectById(ObjectTypeResource, ResourceId);
    if (Resource == NULL) {
        Status = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  NULL,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    OmDereferenceObject(Resource);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppRetrieveCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppRetrieveCheckpoint retrieving data from file %1!ws!\n",
               FileName);

    //
    // Push the checkpoint data file across RPC
    //
    Status = DmPushFile(FileName, CheckpointData);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppRetrieveCheckpoint - DmPushFile %1!ws! failed %2!d!\n",
                   FileName,
                   Status);
    }

FnExit:
    RELEASE_LOCK(gQuoLock);
    //cleanup
    if (FileName) LocalFree(FileName);

    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;

    return(Status);
}


error_status_t
s_CpRetrieveCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC through which data checkpointed to the quorum disk
    can be retrieved by other nodes.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint data is to be retrieved

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data should be sent

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    return CppRetrieveCheckpoint(IDL_handle,
                                 ResourceId,
                                 dwCheckpointId,
                                 FALSE,
                                 CheckpointData
                                 );

}


error_status_t
s_CpRetrieveCryptoCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC through which data checkpointed to the quorum disk
    can be retrieved by other nodes.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint data is to be retrieved

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data should be sent

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    return CppRetrieveCheckpoint(IDL_handle,
                                 ResourceId,
                                 dwCheckpointId,
                                 TRUE,
                                 CheckpointData
                                 );

}

error_status_t
CppDeleteCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath,
    BOOL        fCryptoCheckpoint
    )
/*++

Routine Description:

    Server side RPC through which the checkpoint file  corresponding to a 
    given checkpointid for a resource is deleted.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint file is to be deleted.

    dwCheckpointId - Unique identifier of the checkpoint. If 0, all checkpoints
    must be deleted.

    lpszQuorumPath - The path to the cluster files from where these files must
    be deleted.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD           Status;
    PFM_RESOURCE    Resource = NULL;

    Resource = OmReferenceObjectById(ObjectTypeResource, ResourceId);
    if (Resource == NULL) {
        Status = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    if (fCryptoCheckpoint) {
        Status = CpckDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
    } else {
        Status = CppDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
    }

    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

FnExit:
    if (Resource) OmDereferenceObject(Resource);
    return(Status);
}

error_status_t
s_CpDeleteCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath
    )
/*++

Routine Description:

    Server side RPC through which the checkpoint file  corresponding to a 
    given checkpointid for a resource is deleted.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint file is to be deleted.

    dwCheckpointId - Unique identifier of the checkpoint. If 0, all checkpoints
    must be deleted.

    lpszQuorumPath - The path to the cluster files from where these files must
    be deleted.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    return CppDeleteCheckpoint(IDL_handle,
                               ResourceId,
                               dwCheckpointId,
                               lpszQuorumPath,
                               FALSE);
}

error_status_t
s_CpDeleteCryptoCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath
    )
/*++

Routine Description:

    Server side RPC through which the crypto checkpoint file  corresponding to a 
    given checkpointid for a resource is deleted.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint file is to be deleted.

    dwCheckpointId - Unique identifier of the checkpoint. If 0, all checkpoints
    must be deleted.

    lpszQuorumPath - The path to the cluster files from where these files must
    be deleted.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    return CppDeleteCheckpoint(IDL_handle,
                               ResourceId,
                               dwCheckpointId,
                               lpszQuorumPath,
                               TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Interfaces for registering and deregistering registry checkpoint
    handlers.

Author:

    John Vert (jvert) 1/16/1997

Revision History:

--*/
#include "cpp.h"

//
// Local type and structure definitions
//
typedef struct _CPP_ADD_CONTEXT {
    BOOL Found;
    LPCWSTR KeyName;
} CPP_ADD_CONTEXT, *PCPP_ADD_CONTEXT;

typedef struct _CPP_DEL_CONTEXT {
    DWORD dwId;
    LPCWSTR KeyName;
} CPP_DEL_CONTEXT, *PCPP_DEL_CONTEXT;

typedef struct _CPP_GET_CONTEXT {
    DWORD Available;
    DWORD Required;
    LPWSTR lpOutput;
} CPP_GET_CONTEXT, *PCPP_GET_CONTEXT;

//
// Local function prototypes
//
BOOL
CppWatchCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    );

BOOL
CppAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_ADD_CONTEXT Context
    );

BOOL
CppDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_DEL_CONTEXT Context
    );

BOOL
CppGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_GET_CONTEXT Context
    );


DWORD
CppWatchRegistry(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Restores any registry checkpoints for this resource and begins
    watching the registry for any further modifications.

Arguments:

    Resource - Supplies the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmOpenKey(ResourceKey,
                           L"RegSync",
                           KEY_READ);
    DmCloseKey(ResourceKey);
    if (RegSyncKey != NULL) {

        DmEnumValues(RegSyncKey,
                     CppWatchCallback,
                     Resource);
        DmCloseKey(RegSyncKey);
    }

    return(ERROR_SUCCESS);
}


BOOL
CppWatchCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Value enumeration callback for watching a resource's registry
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Resource - Supplies the resource this value is a registry checkpoint for

Return Value:

    TRUE to continue enumeration

--*/

{
    HKEY hKey;
    DWORD Id;
    DWORD Status;
    DWORD Disposition;
    WCHAR TempFile[MAX_PATH];
    BOOLEAN WasEnabled;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppWatchCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Resource));
        return(TRUE);
    }

    //
    // Attempt to create the specified registry key.
    //
    Status = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                             ValueData,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hKey,
                             &Disposition);
    if (Status != ERROR_SUCCESS) {
        //
        // For some reason we could not open the key. Try again with restore
        // privilege. Note that this will not work if the key does not exist.
        // Not much we can do in that case.
        //
        ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           &WasEnabled);
        Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               ValueData,
                               REG_OPTION_BACKUP_RESTORE,
                               KEY_WRITE,
                               &hKey);
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    }

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWatchCallback: could not create key %1!ws! error %2!d!\n",
                   ValueData,
                   Status);
        return(TRUE);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppWatchCallback retrieving checkpoint id %1!lx! for resource %2!ws\n",
               Id,
               OmObjectName(Resource));
    //
    // See if there is any checkpoint data for this ID.
    //
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
    }
    Status = CpGetDataFile(Resource,
                           Id,
                           TempFile,
                           FALSE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppWatchCallback - CpGetDataFile for id %1!lx! resource %2!ws! failed %3!d!\n",
                   Id,
                   OmObjectName(Resource),
                   Status);
    } else {

        //
        // Finally install the checkpointed file into the registry.
        //
        Status = CppInstallDatabase(hKey,
                                    TempFile);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWatchCallback: could not restore temp file %1!ws! to key %2!ws! error %3!d!\n",
                       TempFile,
                       ValueData,
                       Status);
            CsLogEventData2(LOG_CRITICAL,
                            CP_REG_CKPT_RESTORE_FAILED,
                            sizeof(Status),
                            &Status,
                            OmObjectName(Resource),
                            ValueData);
        }

    }
    DeleteFile(TempFile);
    RegCloseKey(hKey);

    //
    // Install the registry watcher for this checkpoint
    //
    Status = CppRegisterNotify(Resource,
                               ValueData,
                               Id);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWatchRegistry - CppRegisterNotify failed for key %1!ws! %1!d!\n",
                   ValueData,
                   Status);
    }

    return(TRUE);
}


DWORD
CpAddRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Adds a new registry checkpoint to a resource's list.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    KeyName - Supplies the name of the registry key (relative to HKEY_LOCAL_MACHINE);

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPP_ADD_CONTEXT Context;
    HDMKEY  ResourceKey = NULL;
    HDMKEY  RegSyncKey = NULL;
    DWORD   Disposition;
    DWORD   Id;
    WCHAR   IdName[9];
    DWORD   Status;
    HKEY    hKey = NULL;
    CLUSTER_RESOURCE_STATE State;
    BOOLEAN WasEnabled;
    DWORD   Count=60;
    HKEY    hKeyOpen = NULL;
    //
    // Make sure the specified key is valid.
    //  - First we try and open the key while using backup privilege.
    //    If the key exists, this will get us a handle even if our account
    //    does not have permission.
    //  - If you are using REG_OPTION_BACKUP_RESTORE and the key does not
    //    exist, a new key will not be created. So if the first create fails,
    //    we try again without REG_OPTION_BACKUP_RESTORE. This will create
    //    the key if it does not exist (and we have permission to create such
    //    a key) If the key does not exist and we cannot create they key,
    //    the checkpoint add fails.
    //
    Status = ClRtlEnableThreadPrivilege(SE_BACKUP_PRIVILEGE,
                       &WasEnabled);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[CP] CpAddRegistryCheckpoint - ClRtlEnableThreadPrivilege failed with Status %1!u!\n",
               Status);
        goto FnExit;               

    }
    Status = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                             KeyName,
                             0,
                             NULL,
                             REG_OPTION_BACKUP_RESTORE,
                             KEY_READ,
                             NULL,
                             &hKey,
                             &Disposition);
    ClRtlRestoreThreadPrivilege(SE_BACKUP_PRIVILEGE,
                       WasEnabled);
    if (Status != ERROR_SUCCESS) {
        //
        // Try again without REG_OPTION_BACKUP_RESTORE.
        //
        Status = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                 KeyName,
                                 0,
                                 NULL,
                                 0,
                                 KEY_READ,
                                 NULL,
                                 &hKey,
                                 &Disposition);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpAddRegistryCheckpoint Could not create key %1!ws! error %2!d!\n",
                       KeyName,
                       Status);
            goto FnExit;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpAddRegistryCheckpoint created new key %1!ws! for checkpointing.\n",
                       KeyName);
        }
    }

    //
    //  Chittur Subbaraman (chitturs) - 2/26/99
    //
    //  Make sure the key can be opened. Else, bail out.
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         KeyName,
                         &hKeyOpen);

    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                    "[CP] CpAddRegistryCheckpoint Could not open key %1!ws! error %2!d!\n",
                    KeyName,
                    Status);  
        goto FnExit;
    }

    if ( hKeyOpen != NULL ) {
        RegCloseKey( hKeyOpen );
    }

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
                            
    if( ResourceKey == NULL ) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint couldn't open Resource key for %1!ws! error %2!d!\n",
                   OmObjectName(Resource),
                   Status);
        goto FnExit;                   
    }

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmCreateKey(ResourceKey,
                             L"RegSync",
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &Disposition);
    DmCloseKey(ResourceKey);
    if (RegSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint couldn't create RegSync key for %1!ws! error %2!d!\n",
                   OmObjectName(Resource),
                   Status);
        goto FnExit;                   
    }
    if (Disposition == REG_OPENED_EXISTING_KEY) {
        //
        // Enumerate all the other values to make sure this key is
        // not already registered.
        //
        Context.Found = FALSE;
        Context.KeyName = KeyName;
        DmEnumValues(RegSyncKey,
                     CppAddCheckpointCallback,
                     &Context);
        if (Context.Found) {
            //
            // This checkpoint already exists.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpAddRegistryCheckpoint failing attempt to add duplicate checkpoint for %1!ws!\n",
                       KeyName);
            Status = ERROR_ALREADY_EXISTS;
            goto FnExit;
        }

        //
        // Now we need to find a unique checkpoint ID for this registry subtree.
        // Start at 1 and keep trying value names until we get to one that does
        // not already exist.
        //
        for (Id=1; ; Id++) {
            DWORD dwType;
            DWORD cbData;

            wsprintfW(IdName,L"%08lx",Id);
            cbData = 0;
            Status = DmQueryValue(RegSyncKey,
                                  IdName,
                                  &dwType,
                                  NULL,
                                  &cbData);
            if (Status == ERROR_FILE_NOT_FOUND) {
                //
                // Found a free ID.
                //
                break;
            }
        }
    } else {
        //
        // The key was just created, so this must be the only checkpoint
        // that exists.
        //
        Id = 1;
        wsprintfW(IdName, L"%08lx",Id);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CpAddRegistryCheckpoint creating new checkpoint id %1!d! for subtree %2!ws!\n",
               Id,
               KeyName);

    Status = DmSetValue(RegSyncKey,
                        IdName,
                        REG_SZ,
                        (CONST BYTE *)KeyName,
                        (lstrlenW(KeyName)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint failed to create new checkpoint id %1!d! error %2!d!\n",
                   Id,
                   KeyName);
        goto FnExit;
    }

RetryCheckpoint:
    //
    // Take the initial checkpoint
    //
    Status = CppCheckpoint(Resource,
                           hKey,
                           Id,
                           KeyName);

    //this may fail due to quorum resource being offline
    // we could do one of two things here, wait for quorum resource to
    // come online or retry
    // we retry as this may be called from the online routines of a
    //resource and we dont want to add any circular waits
    if ((Status == ERROR_ACCESS_DENIED) ||
        (Status == ERROR_INVALID_FUNCTION) ||
        (Status == ERROR_NOT_READY) ||
        (Status == RPC_X_INVALID_PIPE_OPERATION) ||
        (Status == ERROR_BUSY) ||
        (Status == ERROR_SWAPERROR))
    {
        if (Count--)
        {
            Sleep(1000);
            goto RetryCheckpoint;
        } 
#if DBG
        else
        {
            if (IsDebuggerPresent())
                DebugBreak();
        }        
#endif                                
        
    }

    
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint failed to take initial checkpoint for %1!ws! error %2!d!\n",
                   KeyName,
                   Status);
        goto FnExit;
    }

    //
    // If the resource is currently online, add this to the list of subtree notifications
    //

    State = FmGetResourceState(Resource, NULL, NULL);
    if ((State == ClusterResourceOnline) ||
        (State == ClusterResourceOnlinePending)) {
        Status = CppRegisterNotify(Resource,
                                   KeyName,
                                   Id);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpAddRegistryCheckpoint - CppRegisterNotify failed for key %1!ws! %1!d!\n",
                       KeyName,
                       Status);
        }
    }

FnExit:
    if (RegSyncKey) DmCloseKey(RegSyncKey);
    if (hKey) RegCloseKey(hKey);
    return(Status);
}


BOOL
CppAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_ADD_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for adding a new registry
    checkpoint subtrees. This is only used to see if the specified
    registry subtree is already being watched.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (lstrcmpiW(ValueData, Context->KeyName) == 0) {
        //
        // Found a match
        //
        Context->Found = TRUE;
        return(FALSE);
    }
    return(TRUE);
}


DWORD
CpDeleteRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Removes a registry checkpoint from a resource's list.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    KeyName - Supplies the name of the registry key (relative to HKEY_LOCAL_MACHINE);

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPP_DEL_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;
    DWORD Status;
    WCHAR ValueId[9];
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;
    CLUSTER_RESOURCE_STATE State;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmOpenKey(ResourceKey,
                           L"RegSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (RegSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CpDeleteRegistryCheckpoint - couldn't open RegSync key error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Enumerate all the values to find this one
    //
    Context.dwId = 0;
    Context.KeyName = KeyName;
    DmEnumValues(RegSyncKey,
                 CppDeleteCheckpointCallback,
                 &Context);
    if (Context.dwId == 0) {
        //
        // The specified tree was not found.
        //
        DmCloseKey(RegSyncKey);
        return(ERROR_FILE_NOT_FOUND);
    }

    wsprintfW(ValueId,L"%08lx",Context.dwId);
    Status = DmDeleteValue(RegSyncKey, ValueId);
    DmCloseKey(RegSyncKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpDeleteRegistryCheckpoint - couldn't delete value %1!ws! error %2!d!\n",
                   ValueId,
                   Status);
        return(Status);
    }

    //delete the file corresponding to this checkpoint
    Status = CpDeleteCheckpointFile(Resource, Context.dwId, NULL);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpDeleteRegistryCheckpoint - couldn't delete checkpoint file , error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Now remove the checkpoint from our watcher list
    //
    State = FmGetResourceState(Resource, NULL, NULL);
    if ((State == ClusterResourceOnline) ||
        (State == ClusterResourceOnlinePending)) {
        Status = CppRundownCheckpointById(Resource, Context.dwId);
    }

    return(Status);
}


DWORD
CpRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    This is called when a resource is deleted to remove all the checkpoints
    and the related stuff in the registry.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    KeyName - Supplies the name of the registry key (relative to HKEY_LOCAL_MACHINE);

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status;

    //delete all the checkpoints corresponding to this resource
    Status = CpDeleteCheckpointFile(Resource, 0, NULL);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpRemoveResourceCheckpoints, CppDeleteCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    

FnExit:
    return(Status);
}



BOOL
CppDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_DEL_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for deleting an old registry
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (lstrcmpiW(ValueData, Context->KeyName) == 0) {
        //
        // Found a match
        //
        Context->dwId = wcstol(ValueName, NULL, 16);
        return(FALSE);
    }
    return(TRUE);
}


DWORD
CpGetRegistryCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Retrieves a list of the resource's registry checkpoints

Arguments:

    Resource - Supplies the resource whose registry checkpoints should be retrieved.

    OutBuffer - Supplies a pointer to the output buffer.

    OutBufferSize - Supplies the size (in bytes) of the output buffer.

    BytesReturned - Returns the number of bytes written to the output buffer.

    Required - Returns the number of bytes required. (if the output buffer was insufficient)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPP_GET_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;
    DWORD Status;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmOpenKey(ResourceKey,
                           L"RegSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (RegSyncKey == NULL) {
        //
        // No reg sync key, therefore there are no subtrees
        //
        return(ERROR_SUCCESS);
    }

    Context.Available = OutBufferSize;
    Context.Required = 0;
    Context.lpOutput = (LPWSTR)OutBuffer;

    DmEnumValues(RegSyncKey,
                 CppGetCheckpointsCallback,
                 &Context);

    DmCloseKey(RegSyncKey);

    if (Context.Available < sizeof(WCHAR)) {
        Status = ERROR_MORE_DATA;
    } else {
        if ( (PCHAR)(Context.lpOutput) - OutBuffer ) {
            *Context.lpOutput++ = L'\0';
        }
        Status = ERROR_SUCCESS;
    }

    if ( Context.Required ) {
        *Required = Context.Required + sizeof(WCHAR);
    }

    //
    // If the buffer was large enough for all the data, indicate the
    // number of bytes we are returning in the output buffer.
    //
    if ( OutBufferSize >= *Required ) {
        *BytesReturned = (DWORD)((PCHAR)(Context.lpOutput) - OutBuffer);
    }

    return(Status);
}

BOOL
CppGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_GET_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for retrieving all of a resource's
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

--*/

{
    Context->Required += ValueSize;
    if (Context->Available >= ValueSize) {
        CopyMemory(Context->lpOutput, ValueData, ValueSize);
        Context->lpOutput += ValueSize/sizeof(WCHAR);
        Context->Available -= ValueSize;
    } else {
        Context->Available = 0;
    }
    return(TRUE);
}

DWORD CppSaveCheckpointToFile(
    IN HKEY     hKey,
    IN LPCWSTR  KeyName,
    IN LPWSTR   TempFile)
{
    DWORD   Status;
    
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        TempFile[0] = L'\0';
        return(Status);
    }

    Status = DmGetDatabase(hKey, TempFile);
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppCheckpoint failed to get registry database %1!ws! to file %2!ws! error %3!d!\n",
                   KeyName,
                   TempFile,
                   Status);
        CL_LOGFAILURE(Status);
        DeleteFile(TempFile);
        TempFile[0] = L'\0';
    }        

    return(Status);
}


DWORD
CppCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HKEY hKey,
    IN DWORD dwId,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Takes a checkpoint of the specified registry key.

Arguments:

    Resource - Supplies the resource this is a checkpoint for.

    hKey - Supplies the registry subtree to checkpoint

    dwId - Supplies the checkpoint ID.

    KeyName - Supplies the name of the registry key.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    WCHAR TempFile[MAX_PATH];

    Status = CppSaveCheckpointToFile(hKey, KeyName, TempFile);
    if (Status == ERROR_SUCCESS)
    {
        //
        // Got a file with the right bits in it. Checkpoint the
        // file.
        //
        Status = CpSaveDataFile(Resource,
                                dwId,
                                TempFile,
                                FALSE);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppCheckpoint - CpSaveData failed %1!d!\n",
                       Status);
        }
    }
    //if the file was created, delete it
    if (TempFile[0] != L'\0')
        DeleteFile(TempFile);

    return(Status);
}



DWORD
CppInstallDatabase(
    IN HKEY hKey,
    IN LPWSTR   FileName
    )
/*++

Routine Description:

    Installs a new registry database from a specified file.

Arguments:

    hKey - Supplies the registry key where FileName will be installed to.

    FileName - The name of the file from which to read the registry database
               to install.

Return Value:

    ERROR_SUCCESS if the installation completed successfully

    Win32 error code otherwise.

--*/

{
    DWORD    Status;
    BOOLEAN  WasEnabled;

    //
    // Install the new registry from the file
    //
    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);
    if (Status != ERROR_SUCCESS) {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] Restore privilege not held by cluster service\n");
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
        return(Status);
    }
    Status = RegRestoreKeyW(hKey,
                            FileName,
                            REG_FORCE_RESTORE);
    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                       WasEnabled);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] Error installing registry database from %1!ws!, error %2!u!.\n",
                   FileName,
                   Status);
    }

    return(Status);
}


DWORD
CppDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR  lpszQuorumPath
    )
/*++

Routine Description:

    Deletes the checkpoint file corresponding the resource.
    This node must be the owner of the quorum resource

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if completed successfully

    Win32 error code otherwise.

--*/

{

    DWORD               Status;
    HDMKEY              ResourceKey;
    HDMKEY              RegSyncKey;
    CP_CALLBACK_CONTEXT Context;


    if (dwCheckpointId)
    {
        Status = CppDeleteFile(Resource, dwCheckpointId, lpszQuorumPath);
    }
    else
    {
        HDMKEY              ResourceKey;
        HDMKEY              RegSyncKey;
        CP_CALLBACK_CONTEXT Context;

    
        //delete all checkpoints corresponding to this resource
        
        //
        // Open up the resource's key
        //
        ResourceKey = DmOpenKey(DmResourcesKey,
                                OmObjectId(Resource),
                                KEY_READ);
        CL_ASSERT(ResourceKey != NULL);

        //
        // Open up the RegSync key
        //
        RegSyncKey = DmOpenKey(ResourceKey,
                               L"RegSync",
                               KEY_READ | KEY_WRITE);
        DmCloseKey(ResourceKey);
        if (RegSyncKey == NULL)
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                       "[CP] CppDeleteCheckpointFile- couldn't open RegSync key error %1!d!\n",
                       Status);
            goto FnExit;
        }

        Context.lpszPathName = lpszQuorumPath;
        Context.Resource = Resource;

        //
        // Enumerate all the values and delete them one by one.
        //
        DmEnumValues(RegSyncKey,
                     CppRemoveCheckpointFileCallback,
                     &Context);
    }

FnExit:
    return(Status);

}    

DWORD CppDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    Gets the file corresponding to the checkpoint id relative
    to the supplied path and deletes it.

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if the completed successfully

    Win32 error code otherwise.

--*/
    
{    
    DWORD   Status;
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;

    Status = CppGetCheckpointFile(Resource, dwCheckpointId,
        &pszDirectoryName, &pszFileName, lpszQuorumPath, FALSE);


    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDeleteFile- couldnt get checkpoint file name, error %1!d!\n",
                   Status);
        goto FnExit;
    }


    if (!DeleteFileW(pszFileName))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDeleteFile - couldn't delete the file %2!ws!, error %1!d!\n",
                   Status,
                   pszFileName);
        goto FnExit;                   
    }

    //
    // Now try and delete the directory.
    //
    if (!RemoveDirectoryW(pszDirectoryName)) 
    {
        //if there is a failure, we still return success
        //because it may not be possible to delete a directory
        //when it is not empty
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppDeleteFile- unable to remove directory %1!ws!, error %2!d!\n",
                   pszDirectoryName,
                   GetLastError());
    }

FnExit:
    if (pszFileName) LocalFree(pszFileName);
    if (pszDirectoryName) LocalFree(pszDirectoryName);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\send.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    send.c

Abstract:

    APIs for the client side of the checkpoint manager

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"


CL_NODE_ID
CppGetQuorumNodeId(
    VOID
    )
/*++

Routine Description:

    Returns the node ID of the node owning the quorum resource.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE QuorumResource;
    DWORD Status;
    DWORD NodeId;

    Status = FmFindQuorumResource(&QuorumResource);
    if (Status != ERROR_SUCCESS) {
        return((DWORD)-1);
    }

    NodeId = FmFindQuorumOwnerNodeId(QuorumResource);
    OmDereferenceObject(QuorumResource);

    return(NodeId);
}



DWORD
CpSaveDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    This function checkpoints arbitrary data for the specified resource. The data is stored on the quorum
    disk to ensure that it survives partitions in time. Any node in the cluster may save or retrieve
    checkpointed data.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the name of the file with the checkpoint data.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID OwnerNode;
    DWORD Status;

    do {
        OwnerNode = CppGetQuorumNodeId();
        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CpSaveData: checkpointing data id %1!d! to quorum node %2!d!\n",
                    dwCheckpointId,
                    OwnerNode);
        if (OwnerNode == NmLocalNodeId) {
            Status = CppWriteCheckpoint(Resource,
                                        dwCheckpointId,
                                        lpszFileName,
                                        fCryptoCheckpoint);
        } else {
            HANDLE hFile;
            FILE_PIPE FilePipe;
            hFile = CreateFileW(lpszFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                0,
                                NULL);
            if (hFile == INVALID_HANDLE_VALUE) {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                           "[CP] CpSaveData: failed to open data file %1!ws! error %2!d!\n",
                           lpszFileName,
                           Status);
            } else {
                DmInitFilePipe(&FilePipe, hFile);
                try {
                    if (fCryptoCheckpoint) {
                        Status = CpDepositCryptoCheckpoint(Session[OwnerNode],
                                                           OmObjectId(Resource),
                                                           dwCheckpointId,
                                                           FilePipe.Pipe);
                    } else {
                        Status = CpDepositCheckpoint(Session[OwnerNode],
                                                     OmObjectId(Resource),
                                                     dwCheckpointId,
                                                     FilePipe.Pipe);
                    }
                } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[CP] CpSaveData - s_CpDepositCheckpoint from node %1!d! raised status %2!d!\n",
                               OwnerNode,
                               GetExceptionCode());
                    Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
                }
                DmFreeFilePipe(&FilePipe);
                CloseHandle(hFile);
            }
        }

        if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
            //
            // This node no longer owns the quorum resource, retry.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpSaveData: quorum owner %1!d! no longer owner\n",
                        OwnerNode);
        }
    } while ( Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER );
    return(Status);
}

DWORD
CpDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    This function removes the checkpoint file correspoinding to the
    checkpoint id for a given resource from the given directory.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszQuorumPath - Supplies the path of the cluster files on a quorum device.                    

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID  OwnerNode;
    DWORD       Status;

    do {
        OwnerNode = CppGetQuorumNodeId();
        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CpDeleteDataFile: removing checkpoint file for id %1!d! at quorum node %2!d!\n",
                    dwCheckpointId,
                    OwnerNode);
        if (OwnerNode == NmLocalNodeId) 
        {
            Status = CppDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
        } 
        else
        {
            Status = CpDeleteCheckpoint(Session[OwnerNode],
                            OmObjectId(Resource),
                            dwCheckpointId,
                            lpszQuorumPath);

            //talking to an old server, cant perform this function
            //ignore the error
            if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
                Status = ERROR_SUCCESS;                                        
        }

        if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
            //
            // This node no longer owns the quorum resource, retry.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpSaveData: quorum owner %1!d! no longer owner\n",
                        OwnerNode);
        }
    } while ( Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER );
    return(Status);
}



DWORD
CpGetDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    This function retrieves checkpoint data for the specified resource. The data must
    have been saved by CpSaveData. Any node in the cluster may save or retrieve
    checkpointed data.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is
        responsible for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the filename where the data should be retrieved.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID OwnerNode;
    DWORD Status;
    DWORD Count = 60;
    
RetryRetrieveChkpoint:
    OwnerNode = CppGetQuorumNodeId();
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CpGetDataFile: restoring data id %1!d! from quorum node %2!d!\n",
                dwCheckpointId,
                OwnerNode);
    if (OwnerNode == NmLocalNodeId) {
        Status = CppReadCheckpoint(Resource,
                                   dwCheckpointId,
                                   lpszFileName,
                                   fCryptoCheckpoint);
    } else {
        HANDLE hFile;
        FILE_PIPE FilePipe;

        hFile = CreateFileW(lpszFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            0,
                            NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpGetDataFile: failed to create new file %1!ws! error %2!d!\n",
                       lpszFileName,
                       Status);
        } else {
            DmInitFilePipe(&FilePipe, hFile);
            try {
                if (fCryptoCheckpoint) {
                    Status = CpRetrieveCryptoCheckpoint(Session[OwnerNode],
                                                        OmObjectId(Resource),
                                                        dwCheckpointId,
                                                        FilePipe.Pipe);
                } else {
                    Status = CpRetrieveCheckpoint(Session[OwnerNode],
                                                  OmObjectId(Resource),
                                                  dwCheckpointId,
                                                  FilePipe.Pipe);
                }
            } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[CP] CpGetData - s_CpRetrieveCheckpoint from node %1!d! raised status %2!d!\n",
                           OwnerNode,
                           GetExceptionCode());
                CL_UNEXPECTED_ERROR( GetExceptionCode() );
                Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
            }
            DmFreeFilePipe(&FilePipe);
            CloseHandle(hFile);
        }
    }
    if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
        //
        // This node no longer owns the quorum resource, retry.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CpGetData: quorum owner %1!d! no longer owner\n",
                    OwnerNode);
        goto RetryRetrieveChkpoint;                    
    }
    else if ((Status == ERROR_ACCESS_DENIED) || 
        (Status == ERROR_INVALID_FUNCTION) ||
        (Status == ERROR_NOT_READY) ||
        (Status == RPC_X_INVALID_PIPE_OPERATION) ||
        (Status == ERROR_BUSY) ||
        (Status == ERROR_SWAPERROR))
    {
        //if the quorum resource offline suddenly
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CpGetData: quorum resource went offline in the middle, Count=%1!u!\n",
                   Count);
        //we dont prevent the quorum resource from going offline if some resource 
        //is blocked for a long time in its online/offline thread- this is because 
        //some resources(like dtc)try to enumerate resources in the  quorum group
        //we increase the timeout to give cp a chance to retrieve the checkpoint 
        //while the quorum group is being moved or failed over
        if (Count--)
        {
            Sleep(1000);
            goto RetryRetrieveChkpoint;
        }            
    }

    if (Status != ERROR_SUCCESS) {
        WCHAR  string[16];

        wsprintfW(&(string[0]), L"%u", Status);

        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpGetDataFile - failed to retrieve checkpoint %1!d! error %2!d!\n",
                   dwCheckpointId,
                   Status);
        CL_LOGCLUSERROR2(CP_RESTORE_REGISTRY_FAILURE, OmObjectName(Resource), string);
#if DBG
        if (IsDebuggerPresent())
            DebugBreak();
#endif            
                     
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dminit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dminit.c

Abstract:

    Contains the initialization code for the Cluster Database Manager

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"

//
// Global Data
//

HKEY DmpRoot;
LIST_ENTRY KeyList;
CRITICAL_SECTION KeyLock;
HDMKEY DmClusterParametersKey;
HDMKEY DmResourcesKey;
HDMKEY DmResourceTypesKey;
HDMKEY DmGroupsKey;
HDMKEY DmNodesKey;
HDMKEY DmNetworksKey;
HDMKEY DmNetInterfacesKey;
HDMKEY DmQuorumKey;
HANDLE ghQuoLogOpenEvent=NULL;

#if NO_SHARED_LOCKS
CRITICAL_SECTION gLockDmpRoot;
#else
RTL_RESOURCE    gLockDmpRoot;
#endif
BOOL gbIsQuoLoggingOn=FALSE;
HANDLE ghDiskManTimer=NULL;//disk management timer
PFM_RESOURCE gpQuoResource=NULL;  //set when DMFormNewCluster is completed
HANDLE ghCheckpointTimer = NULL; //timer for periodic checkpointing
BOOL   gbDmInited = FALSE; //set to TRUE when all phases of dm initialization are over
extern HLOG ghQuoLog;
BOOL   gbDmpShutdownUpdates = FALSE;


//define public cluster key value names
const WCHAR cszPath[]= CLUSREG_NAME_QUORUM_PATH;
const WCHAR cszMaxQuorumLogSize[]=CLUSREG_NAME_QUORUM_MAX_LOG_SIZE;
const WCHAR cszParameters[] = CLUSREG_KEYNAME_PARAMETERS;

//other const strings
const WCHAR cszQuoFileName[]=L"quolog.log";
const WCHAR cszQuoTombStoneFile[]=L"quotomb.stn";
const WCHAR cszTmpQuoTombStoneFile[]=L"quotomb.tmp";

GUM_DISPATCH_ENTRY DmGumDispatchTable[] = {
    {3, (PGUM_DISPATCH_ROUTINE1)DmpUpdateCreateKey},
    {4, (PGUM_DISPATCH_ROUTINE1)DmpUpdateSetSecurity}
    };

//
// Global data for interfacing with registry watcher thread
//
HANDLE hDmpRegistryFlusher=NULL;
HANDLE hDmpRegistryEvent=NULL;
HANDLE hDmpRegistryRestart=NULL;
DWORD
DmpRegistryFlusher(
    IN LPVOID lpThreadParameter
    );

//
// Local function prototypes
//
VOID
DmpInvalidateKeys(
    VOID
    );

VOID
DmpReopenKeys(
    VOID
    );

DWORD
DmpLoadHive(
    IN LPCWSTR Path
    );

typedef struct _DMP_KEY_DEF {
    HDMKEY *pKey;
    LPWSTR Name;
} DMP_KEY_DEF;

DMP_KEY_DEF DmpKeyTable[] = {
    {&DmResourcesKey, CLUSREG_KEYNAME_RESOURCES},
    {&DmResourceTypesKey, CLUSREG_KEYNAME_RESOURCE_TYPES},
    {&DmQuorumKey, CLUSREG_KEYNAME_QUORUM},
    {&DmGroupsKey, CLUSREG_KEYNAME_GROUPS},
    {&DmNodesKey, CLUSREG_KEYNAME_NODES},
    {&DmNetworksKey, CLUSREG_KEYNAME_NETWORKS},
    {&DmNetInterfacesKey, CLUSREG_KEYNAME_NETINTERFACES}};


DWORD
DmInitialize(
    VOID
    )

/*++

Routine Description:

    Inits the config database manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    BOOL Success;
    DWORD Status = ERROR_SUCCESS;
    DWORD dwOut;

    ClRtlLogPrint(LOG_NOISE,"[DM] Initialization\n");

    InitializeListHead(&KeyList);
    InitializeCriticalSection(&KeyLock);

    //create a critical section for locking the database while checkpointing
    INITIALIZE_LOCK(gLockDmpRoot);

    //create a named event that is used for waiting for quorum resource
    //to go online
    ghQuoLogOpenEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!ghQuoLogOpenEvent)
    {
        CL_UNEXPECTED_ERROR((Status = GetLastError()));
        goto FnExit;

    }

    Success = DmpInitNotify();
    CL_ASSERT(Success);
    if (!Success)
    {
        Status = GetLastError();
        goto FnExit;
    }

    //find out if the databasecopy was in progresss on last death
    DmpGetDwordFromClusterServer(L"ClusterDatabaseCopyInProgress", &dwOut, 0);

LoadClusterDatabase:
    //
    // Open key to root of cluster.
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRoot);
    //
    // If the key was not found, go load the database.
    //
    if (Status == ERROR_FILE_NOT_FOUND) {
        WCHAR Path[MAX_PATH];
        WCHAR BkpPath[MAX_PATH];
        WCHAR *p;

        Status = GetModuleFileName(NULL, Path, MAX_PATH);
        if (Status == 0) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Couldn't find cluster database, status=%1!u!\n", 
                         Status);
            goto FnExit;
        }

        //get the name of the cluster database
        p=wcsrchr(Path, L'\\');
        if (p == NULL) 
        {
            Status = ERROR_FILE_NOT_FOUND;
            CL_UNEXPECTED_ERROR(Status);
            goto FnExit;
        }
        //see if we should load the hive from the old one or the bkp file
        *p = L'\0';
        wcscpy(BkpPath, Path);
#ifdef   OLD_WAY
        wcscat(Path, L"\\CLUSDB");
        wcscat(BkpPath, L"\\CLUSTER_DATABASE_TMPBKP_NAME");
#else    // OLD_WAY
        wcscat(Path, L"\\"CLUSTER_DATABASE_NAME );
        wcscat(BkpPath, L"\\"CLUSTER_DATABASE_TMPBKP_NAME);
#endif   // OLD_WAY

        if (dwOut)
        {
            //the backip file must exist
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmInitialize:: DatabaseCopy was in progress on last death, get hive from %1!ws!!\n",
                BkpPath);
            //set file attributes of the BkpPath
            if (!SetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmInitialize:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
                    BkpPath, Status);
                goto FnExit;                
            }

            //copyfilex preserves the attributes on the original file
            if (!CopyFileEx(BkpPath, Path, NULL, NULL, NULL, 0))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmInitialize:: Databasecopy was in progress,Failed to copy %1!ws! to %2!ws!, Status=%3!u!\n",
                    BkpPath, Path, Status);
                //set the file attribute on the backup, so that
                //nobody mucks with it without knowing what they are 
                //doing
                SetFileAttributes(BkpPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
                goto FnExit;                
            }
            //now we can reset the DatabaseCopyInProgress value in the registry
            //set databaseCopyInProgress key to FALSE
            //This will flush the key as well
            Status = DmpSetDwordInClusterServer( L"ClusterDatabaseCopyInProgress", 0);
            if (Status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmInitialize:: Failed to reset ClusterDatabaseCopyInProgress, Status=%1!u!\n",
                    Status);
                goto FnExit;            
            }
            //Now we can delete the backup path, since the key has been flushed
            if (!DeleteFileW(BkpPath))
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmInitialize:: Failed to delete the backup when it wasnt needed,Status=%1!u!\n",
                    GetLastError());
                //this is not fatal so we ignore the error                    
            }
        }
        else
        {
            //the backup file might exist
            //this is true when safe copy makes a backup but hasnt 
            //set the value DatabaseCopyInProgress in the registry
            //if it does delete it
            //set file attributes of the BkpPath
            if (!SetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
            {
                //errors are not fatal, we just ignore them                    
                //this may fail because the path doesnt exist                                    
            }
            //Now we can delete the backup path, since the key has been flushed
            //this is not fatal so we ignore the error                    
            if (DeleteFileW(BkpPath))
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmInitialize:: Deleted the unneeded backup of the cluster database\n");
            }

        }
        
        Status = DmpLoadHive(Path);
        if (Status != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Couldn't load cluster database\n");
            CsLogEventData(LOG_CRITICAL,
                           DM_DATABASE_CORRUPT_OR_MISSING,
                           sizeof(Status),
                           &Status);
            goto FnExit;                           
        }
        
        Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                             DmpClusterParametersKeyName,
                             &DmpRoot);
        //
        // HACKHACK John Vert (jvert) 6/3/1997
        //      There is a bug in the registry with refresh
        //      where the Parent field in the root cell doesn't
        //      get flushed to disk, so it gets blasted if we
        //      do a refresh. Then we crash in unload. So flush
        //      out the registry to disk here to make sure the
        //      right Parent field gets written to disk.
        //
        if (Status == ERROR_SUCCESS) {
            DWORD Dummy=0;
            //
            // Make something dirty in the root
            //
            RegSetValueEx(DmpRoot,
                          L"Valid",
                          0,
                          REG_DWORD,
                          (PBYTE)&Dummy,
                          sizeof(Dummy));
            RegDeleteValue(DmpRoot, L"Valid");
            Status = RegFlushKey(DmpRoot);
        }
    } else {

        //if the hive is already loaded we unload and reload it again
        //to make sure that it is loaded with the right flags and
        //also to make sure that the backup copy is used in case
        //of failures
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmInitialize: The hive was loaded- rollback, unload and reload again\n");
        //BUGBUG:: currently the unload flushes the hive, ideally we 
        //would like to unload it without flushing it
        //This way a part transaction wont be a part of the hive
        //However, if somebody messes with the cluster hive using
        //regedt32 and if reg_no_lazy flush is not specified, some
        //changes might get flushed to the hive.
        
        //We can try and do the rollback in any case,
        //the rollback will fail if the registry wasnt loaded with the
        //reg_no_lazy_flush flag.
        //unload it and then proceed to reload it 
        //this will take care of situations where a half baked clusdb
        //gets loaded because of failures
        Status = DmRollbackRegistry();
        if (Status != ERROR_SUCCESS)
        {
            //we ignore the error
            Status = ERROR_SUCCESS;
        }            
        RegCloseKey(DmpRoot);
        Status = DmpUnloadHive();
        
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmInitialize: DmpUnloadHive failed, Status=%1!u!\n",
                Status);
            goto FnExit;                 
        }        
        goto LoadClusterDatabase;            
    }
    
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // Create the registry watcher thread
    //
    Status = DmpStartFlusher();
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }
    //
    // Open the cluster keys
    //
    Status = DmpOpenKeys(MAXIMUM_ALLOWED);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        goto FnExit;
    }

FnExit:
    return(Status);

}//DmInitialize


DWORD
DmpRegistryFlusher(
    IN LPVOID lpThreadParameter
    )
/*++

Routine Description:

    Registry watcher thread for explicitly flushing changes.

Arguments:

    lpThreadParameter - not used

Return Value:

    None.

--*/

{
    DWORD Status;
    HANDLE hEvent;
    HANDLE hTimer;
    HANDLE WaitArray[4];
    LARGE_INTEGER DueTime;
    BOOL Dirty = FALSE;

    //
    // Create a notification event and a delayed timer for lazy flushing.
    //
    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmpRegistryFlusher couldn't create notification event %1!d!\n",
                   Status);
        goto error_exit1;
    }

    hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
    if (hTimer == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmpRegistryFlusher couldn't create notification event %1!d!\n",
                   Status);
        goto error_exit2;
    }

    WaitArray[0] = hDmpRegistryEvent;
    WaitArray[1] = hEvent;
    WaitArray[2] = hTimer;
    WaitArray[3] = hDmpRegistryRestart;

    while (TRUE) {
        //
        // Set up a registry notification on DmpRoot. We acquire the lock here to
        // make sure that rollback or install is not messing with the database
        // while we are trying to get a notification.
        //
        ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
        Status = RegNotifyChangeKeyValue(DmpRoot,
                                         TRUE,
                                         REG_LEGAL_CHANGE_FILTER,
                                         hEvent,
                                         TRUE);
        RELEASE_LOCK(gLockDmpRoot);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] DmpRegistryFlusher couldn't register for notifications %1!d!\n",
                       Status);
            break;
        }

        //
        // Wait for something to happen.
        //
        Status = WaitForMultipleObjects(4,
                                        WaitArray,
                                        FALSE,
                                        (DWORD)-1);
        switch (Status) {
            case 0:
                ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: got 0\r\n");
                //
                // We have been asked to stop, clean up and exit
                //
                Status = ERROR_SUCCESS;
                if (Dirty) {
                    //
                    // Make sure any changes that we haven't gotten around to flushing
                    // get flushed now.
                    //
                    DmCommitRegistry();
                }
                ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: exiting\r\n");
                goto error_exit3;
                break;

            case 1:
                //
                // A registry change has occurred. Set our timer to
                // go off in 5 seconds. At that point we will do the
                // actual flush.
                //
                //ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: got 1\r\n");

                DueTime.QuadPart = -5 * 10 * 1000 * 1000;
                if (!SetWaitableTimer(hTimer,
                                      &DueTime,
                                      0,
                                      NULL,
                                      NULL,
                                      FALSE)) {
                    //
                    // Some error occurred, go ahead and flush now.
                    //
                    Status = GetLastError();
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[DM] DmpRegistryFlusher failed to set lazy flush timer %1!d!\n",
                               Status);
#if DBG
                    CL_ASSERT(FALSE);
#endif
                    DmCommitRegistry();
                    Dirty = FALSE;
                } else {
                    Dirty = TRUE;
                }
                break;

            case 2:
                //
                // The lazy flush timer has gone off, commit the registry now.
                //
                //ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: got 2\r\n");
                DmCommitRegistry();
                Dirty = FALSE;
                break;

            case 3:
                //
                // DmpRoot has been changed, simply restart the loop with the new handle.
                //
                ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: restarting\n");
                break;

            default:
                //
                // Something very odd has happened
                //
                ClRtlLogPrint(LOG_CRITICAL,
                           "[DM] DmpRegistryFlusher got error %1!d! from WaitForMultipleObjects\n",
                           Status);
                goto error_exit3;
        }
    }

error_exit3:
    CloseHandle(hTimer);

error_exit2:
    CloseHandle(hEvent);

error_exit1:
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmpRegistryFlusher exiting abnormally, status %1!d!\n",
                   Status);
    }
    return(Status);
}


DWORD
DmJoin(
    IN RPC_BINDING_HANDLE RpcBinding,
    OUT DWORD *StartSeq
    )
/*++

Routine Description:

    Performs the join and synchronization process for the
    database manager.

Arguments:

    RpcBinding - Supplies an RPC binding handle to the Join Master

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;
    DWORD GumSequence;
    DWORD CurrentSequence;


    //
    // Register our update handler.
    //
    GumReceiveUpdates(TRUE,
                      GumUpdateRegistry,
                      DmpUpdateHandler,
                      DmWriteToQuorumLog,
                      sizeof(DmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      DmGumDispatchTable,
                      NULL);

retry:
    CurrentSequence = DmpGetRegistrySequence();

    Status = GumBeginJoinUpdate(GumUpdateRegistry, &GumSequence);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] GumBeginJoinUpdate failed %1!d!\n",
                   Status);
        return(Status);
    }
    /*
    if (CurrentSequence == GumSequence) {
        //
        // Our registry sequence already matches. No need to slurp
        // down a new copy.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[DM] DmJoin: registry database is up-to-date\n");
    } else
    */
    //SS: always get the database irrespective of the sequence numbers
    //this is because transactions may be lost in the log file due
    //to the fact that it is not write through and because of certain
    //race conditions in down notifications vs gum failure conditions.
    {

        ClRtlLogPrint(LOG_NOISE,
                   "[DM] DmJoin: getting new registry database\n");
        Status = DmpSyncDatabase(RpcBinding, NULL);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[DM] DmJoin: DmpSyncDatabase failed %1!d!\n",
                       Status);
            return(Status);
        }
    }

    //
    // Issue GUM join update
    //
    Status = GumEndJoinUpdate(GumSequence,
                              GumUpdateRegistry,
                              DmUpdateJoin,
                              0,
                              NULL);
    if (Status == ERROR_CLUSTER_DATABASE_SEQMISMATCH) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] GumEndJoinUpdate with sequence %1!d! failed with a sequence mismatch\n",
                   GumSequence);
        goto retry;
    } else if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] GumEndJoinUpdate with sequence %1!d! failed with status %2!d!\n",
                   GumSequence,
                   Status);
        return(Status);
    }

    *StartSeq = GumSequence;

    return(ERROR_SUCCESS);

} // DmJoin


/*
DWORD
DmFormNewCluster(
    VOID
    )
{
    DWORD Status;


    //
    // Set the current GUM sequence to be one more than the one in the registry.
    //
    // SS: this will be the one to be used for the next gum transaction,
    // it should be one than the current as the logger discards the first of
    // every record the same transaction number to resolve changes made when the
    // locker/logger node dies in the middle of a transaction
    GumSetCurrentSequence(GumUpdateRegistry, (DmpGetRegistrySequence()+1));

    return(ERROR_SUCCESS);

} // DmFormNewCluster

*/

DWORD
DmFormNewCluster(
    VOID
    )

/*++

Routine Description:

    This routine sets the gum sequence number from the registry before
    logs are unrolled and prepares the quorum object for quorum logging.
    It also hooks events  for node up/down notifications.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   dwError=ERROR_SUCCESS;

    //
    // Set the current GUM sequence to be one more than the one in the registry.
    //
    // SS: this will be the one to be used for the next gum transaction,
    // it should be one than the current as the logger discards the first of
    // every record the same transaction number to resolve changes made when the
    // locker/logger node dies in the middle of a transaction
    GumSetCurrentSequence(GumUpdateRegistry, (DmpGetRegistrySequence()+1));

    //
    // Register our update handler.
    //
    GumReceiveUpdates(FALSE,
                      GumUpdateRegistry,
                      DmpUpdateHandler,
                      DmWriteToQuorumLog,
                      sizeof(DmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      DmGumDispatchTable,
                      NULL);

    //hook the callback for node related notification with the event processor
    if (dwError = DmpHookEventHandler())
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster: DmpHookEventHandler failed 0x!08lx!\r\n",
                dwError);
        goto FnExit;
    };

    //get the quorum resource and hook the callback for notification on quorum resource
    if (dwError = DmpHookQuorumNotify())
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster: DmpHookQuorumNotify failed 0x%1!08lx!\r\n",
                dwError);
        goto FnExit;
    };


    //SS: if this procedure is successfully completed gpQuoResource is NON NULL.
FnExit:

    return(dwError);

} // DmUpdateFormNewCluster

DWORD
DmUpdateFormNewCluster(
    VOID
    )

/*++

Routine Description:

    This routine updates the cluster registry after the quorum resource has
    been arbitrated as part of forming a new cluster. The database manager
    is expected to read logs or do whatever it needs to update the current
    state of the registry - presumably using logs that are written to the
    quorum resource. This implies that the quorum resource represents some
    form of stable storage.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       dwError=ERROR_SUCCESS;
    BOOL        bAreAllNodesUp = TRUE;    //assume all nodes are up


    //since we havent been logging as yet, take a checkpoint
    if (ghQuoLog)
    {
        //get a checkpoint database
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmUpdateFormNewCluster - taking a checkpoint\r\n");
        //
        //  Chittur Subbaraman (chitturs) - 6/3/99
        //  
        //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
        //  so as to maintain the ordering between this lock and the log lock.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);

        dwError = LogCheckPoint(ghQuoLog, TRUE, NULL, 0);

        RELEASE_LOCK(gLockDmpRoot);
        
        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmUpdateFormNewCluster - Failed to take a checkpoint in the log file\r\n");
            CL_UNEXPECTED_ERROR(dwError);
        }

    }

    //if all nodes are not up, turn quorum logging on
    if ((dwError = OmEnumObjects(ObjectTypeNode, DmpNodeObjEnumCb, &bAreAllNodesUp, NULL))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster : OmEnumObjects returned 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    if (!bAreAllNodesUp)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmUpdateFormNewCluster - some node down\r\n");
        gbIsQuoLoggingOn = TRUE;
    }

    //add a timer to monitor disk space, should be done after we have formed.
    ghDiskManTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!ghDiskManTimer)
    {
        CL_LOGFAILURE(dwError = GetLastError());
        goto FnExit;
    }

    AddTimerActivity(ghDiskManTimer, DISKSPACE_MANAGE_INTERVAL, 1, DmpDiskManage, NULL);

    gbDmInited = TRUE;
    
FnExit:
    return (dwError);
} // DmFormNewCluster


/****
@func   DWORD | DmPauseDiskManTimer| The disk manager timer activity to monitor
        space on the quorum disk is set to a puased state.

@rdesc  Returns ERROR_SUCCESS on success.  Else returns the error code.

@comm   This is called while the quorum resource is being changed.

@xref   <f DmRestartDiskManTimer>
****/
DWORD DmPauseDiskManTimer()
{
    DWORD dwError=ERROR_SUCCESS;

    if (ghDiskManTimer)
        dwError = PauseTimerActivity(ghDiskManTimer);
    return(dwError);
}

/****
@func   DWORD | DmRestartDiskManTimer| This disk manager activity to monitor
        space on the quorum disk is set back to activated state.

@rdesc  Returns ERROR_SUCCESS on success.  Else returns the error code.

@comm   This is called after the quorum resource has been changed.

@xref   <f DmPauseDiskManTimer>
****/
DWORD DmRestartDiskManTimer()
{
    DWORD dwError=ERROR_SUCCESS;
    if (ghDiskManTimer)
        dwError = UnpauseTimerActivity(ghDiskManTimer);
    return(dwError);
}
/****
@func           DWORD | DmRollChanges| This waits for the quorum resource to come online at
                        initialization when a cluster is being formed.  The changes in the quorum
                        log file are applied to the local cluster database.

@rdesc          Returns ERROR_SUCCESS on success.  Else returns the error code.

@comm           This allows for partitions in time.

@xref
****/
DWORD DmRollChanges()
{

    DWORD dwError=ERROR_SUCCESS;


    //before applying the changes validate that this quorum resource is the real one
    if ((dwError = DmpChkQuoTombStone()) != ERROR_SUCCESS)
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmRollChanges: DmpChkQuoTombStone() failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;

    }
    if ((dwError = DmpApplyChanges()) != ERROR_SUCCESS)
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmRollChanges: DmpApplyChanges() failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    //ss: this is here since lm doesnt know about the ownership of quorum
    //disks today
    //call DmpCheckSpace
    if ((dwError = DmpCheckDiskSpace()) != ERROR_SUCCESS)
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmRollChanges: DmpCheckDiskSpace() failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

FnExit:
    return(dwError);
}



DWORD DmShutdown()
{
    DWORD   dwError;

    ClRtlLogPrint(LOG_NOISE,
        "[Dm] DmShutdown\r\n");

    //this will close the timer handle
    if (ghDiskManTimer) RemoveTimerActivity(ghDiskManTimer);

    if (gpQuoResource)
    {
        // DmFormNewCluster() completed
        //
        // Deregister from any further GUM updates
        //
        //GumIgnoreUpdates(GumUpdateRegistry, DmpUpdateHandler);
    }
    //unhook the callback for notification on quorum resource
    if (dwError = DmpUnhookQuorumNotify())
    {
        //just log the error as we are shutting down
        ClRtlLogPrint(LOG_UNUSUAL,
        "[DM] DmShutdown: DmpUnhookQuorumNotify failed 0x%1!08lx!\r\n",
                dwError);

    }


    //if the quorum log is open close it
    if (ghQuoLog)
    {
        LogClose(ghQuoLog);
        ghQuoLog = NULL;
        //dont try and log after this
        gbIsQuoLoggingOn = FALSE;
    }

    //close the event created for notification of the quorum resource to
    //go online
    if (ghQuoLogOpenEvent)
    {
        //wait any thread blocked on this
        SetEvent(ghQuoLogOpenEvent);
        CloseHandle(ghQuoLogOpenEvent);
        ghQuoLogOpenEvent = NULL;
    }

    //
    // Shut down the registry flusher thread.
    //
    DmpShutdownFlusher();

    return(dwError);
}


DWORD
DmpStartFlusher(
    VOID
    )
/*++

Routine Description:

    Starts up a new registry flusher thread.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD ThreadId;

    ClRtlLogPrint(LOG_NOISE,"[DM] DmpStartFlusher: Entry\r\n");
    if (!hDmpRegistryFlusher)
    {
        hDmpRegistryEvent = CreateEventW(NULL,FALSE,FALSE,NULL);
        if (hDmpRegistryEvent == NULL) {
            return(GetLastError());
        }
        hDmpRegistryRestart = CreateEventW(NULL,FALSE,FALSE,NULL);
        if (hDmpRegistryRestart == NULL) {
            CloseHandle(hDmpRegistryEvent);
            return(GetLastError());
        }
        hDmpRegistryFlusher = CreateThread(NULL,
                                           0,
                                           DmpRegistryFlusher,
                                           NULL,
                                           0,
                                           &ThreadId);
        if (hDmpRegistryFlusher == NULL) {
            CloseHandle(hDmpRegistryRestart);
            CloseHandle(hDmpRegistryEvent);
            return(GetLastError());
        }
        ClRtlLogPrint(LOG_NOISE,"[DM] DmpStartFlusher: thread created\r\n");

    }
    return(ERROR_SUCCESS);
}


VOID
DmpShutdownFlusher(
    VOID
    )
/*++

Routine Description:

    Cleanly shutsdown the registry flusher thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_NOISE,"[DM] DmpShutdownFlusher: Entry\r\n");

    if (hDmpRegistryFlusher) {
        ClRtlLogPrint(LOG_NOISE,"[DM] DmpShutdownFlusher: Setting event\r\n");
        SetEvent(hDmpRegistryEvent);
        WaitForSingleObject(hDmpRegistryFlusher, INFINITE);
        CloseHandle(hDmpRegistryFlusher);
        hDmpRegistryFlusher = NULL;
        CloseHandle(hDmpRegistryEvent);
        CloseHandle(hDmpRegistryRestart);
        hDmpRegistryEvent = NULL;
        hDmpRegistryRestart = NULL;
    }
}


VOID
DmpRestartFlusher(
    VOID
    )
/*++

Routine Description:

    Restarts the registry flusher thread if DmpRoot is being changed.

    N.B. In order for this to work correctly, gLockDmpRoot MUST be held!

Arguments:

    None.

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_NOISE,"[DM] DmpRestartFlusher: Entry\r\n");
#if NO_SHARED_LOCKS    
    CL_ASSERT(HandleToUlong(gLockDmpRoot.OwningThread) == GetCurrentThreadId());
#else
    CL_ASSERT(HandleToUlong(gLockDmpRoot.ExclusiveOwnerThread) == GetCurrentThreadId());
#endif
    SetEvent(hDmpRegistryRestart);
}

DWORD
DmUpdateJoinCluster(
    VOID
    )

/*++

Routine Description:

    This routine is called after a node has successfully joined a cluster.
    It allows the DM to hook callbacks for node up/down notifications and for
    quorum resource change notification.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD dwError=ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmUpdateJoinCluster: Begin.\r\n");

    //hook the notification for node up/down so we can keep track  of whether logging
    //should be on or off.
    if (dwError = DmpHookEventHandler())
    {
        //BUGBUG SS: do we log this or return this error code
        ClRtlLogPrint(LOG_UNUSUAL,
        "[DM] DmUpdateJoinCluster: DmpHookEventHandler failed 0x%1!08lx!\r\n",
            dwError);

    }

    //hook the callback for notification on quorum resource
    if (dwError = DmpHookQuorumNotify())
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
        "[DM] DmUpdateJoinCluster: DmpHookQuorumNotify failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    if ((dwError = DmpCheckDiskSpace()) != ERROR_SUCCESS)
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateJoinCluster: DmpCheckDiskSpace() failed 0x%1!08lx!\r\n",
                    dwError);
        goto FnExit;
    }

    //add a timer to monitor disk space, should be done after we have joined.
    ghDiskManTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!ghDiskManTimer)
    {
        CL_LOGFAILURE(dwError = GetLastError());
        goto FnExit;
    }

    //register a periodic timer
    AddTimerActivity(ghDiskManTimer, DISKSPACE_MANAGE_INTERVAL, 1,  DmpDiskManage, NULL);

    gbDmInited = TRUE;
    
FnExit:
    return(dwError);
} // DmUpdateJoinCluster


DWORD
DmpOpenKeys(
    IN REGSAM samDesired
    )
/*++

Routine Description:

    Opens all the standard cluster registry keys. If any of the
    keys are already opened, they will be closed and reopened.

Arguments:

    samDesired - Supplies the access that the keys will be opened with.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD i;
    DWORD Status;

    DmClusterParametersKey = DmGetRootKey( MAXIMUM_ALLOWED );
    if ( DmClusterParametersKey == NULL ) {
        Status = GetLastError();
        CL_UNEXPECTED_ERROR(Status);
        return(Status);
    }

    for (i=0;
         i<sizeof(DmpKeyTable)/sizeof(DMP_KEY_DEF);
         i++) {

        *DmpKeyTable[i].pKey = DmOpenKey(DmClusterParametersKey,
                                         DmpKeyTable[i].Name,
                                         samDesired);
        if (*DmpKeyTable[i].pKey == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Failed to open key %1!ws!, status %2!u!\n",
                       DmpKeyTable[i].Name,
                       Status);
            CL_UNEXPECTED_ERROR( Status );
            return(Status);
        }
    }
    return(ERROR_SUCCESS);
}


VOID
DmpInvalidateKeys(
    VOID
    )
/*++

Routine Description:

    Invalidates all open cluster registry keys.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDMKEY Key;

    ListEntry = KeyList.Flink;
    while (ListEntry != &KeyList) {
        Key = CONTAINING_RECORD(ListEntry,
                                DMKEY,
                                ListEntry);
        if (!Key->hKey)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpInvalidateKeys %1!ws! Key was deleted since last reopen but not closed\n",
                Key->Name);

            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] THIS MAY BE A KEY LEAK !!\r\n");
        }            
        else
        {
            RegCloseKey(Key->hKey);
            Key->hKey = NULL;
        }            
        ListEntry = ListEntry->Flink;
    }
}


VOID
DmpReopenKeys(
    VOID
    )
/*++

Routine Description:

    Reopens all the keys that were invalidated by DmpInvalidateKeys

Arguments:

    None

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDMKEY Key;
    DWORD Status;

    ListEntry = KeyList.Flink;
    while (ListEntry != &KeyList) {
        Key = CONTAINING_RECORD(ListEntry,
                                DMKEY,
                                ListEntry);
        CL_ASSERT(Key->hKey == NULL);
        Status = RegOpenKeyEx(DmpRoot,
                              Key->Name,
                              0,
                              Key->GrantedAccess,
                              &Key->hKey);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,"[DM] Could not reopen key %1!ws! error %2!d!\n",Key->Name,Status);
            // if the error is file not found, then the key was deleted while the handle
            // was open.  Set the key to NULL
            // If the key is used after delete, it should be validated
            if (Status == ERROR_FILE_NOT_FOUND)
                Key->hKey = NULL;
            else
                CL_UNEXPECTED_ERROR(Status);

        }
        ListEntry = ListEntry->Flink;
    }
}


DWORD
DmpGetRegistrySequence(
    VOID
    )
/*++

Routine Description:

    Returns the current registry sequence stored in the registry.

Arguments:

    None.

Return Value:

    The current registry sequence.

--*/

{
    DWORD Length;
    DWORD Type;
    DWORD Sequence;
    DWORD Status;

    Length = sizeof(Sequence);
    Status = RegQueryValueExW(DmpRoot,
                              CLUSREG_NAME_CLUS_REG_SEQUENCE,
                              0,
                              &Type,
                              (LPBYTE)&Sequence,
                              &Length);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmpGetRegistrySequence failed %1!u!\n",Status);
        Sequence = 0;
    }

    return(Sequence);
}


DWORD DmWaitQuorumResOnline()
/*++

Routine Description:

    Waits for quorum resource to come online.  Used for quorum logging.

Arguments:

    None

Return Value:

    returns ERROR_SUCCESS - if the online event is signaled and the quorum
    notification callback is called.  Else returns the wait status.

--*/
{

        //wait for the quorum resource to go online
    //give it a minute
    DWORD dwError;

    if (ghQuoLogOpenEvent)
            //dwError  = WaitForSingleObject(ghQuoOnlineEvent, 60000*10);
            dwError  = WaitForSingleObject(ghQuoLogOpenEvent, INFINITE);


    switch(dwError)
    {
        case WAIT_OBJECT_0:
                //everything is fine
                dwError = ERROR_SUCCESS;
                break;

        case WAIT_TIMEOUT:
                //couldnt roll the changes
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmRollChanges: Timed out waiting on dmInitEvent\r\n");
                break;

        case WAIT_FAILED:
                CL_ASSERT(dwError != WAIT_FAILED);
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmRollChanges: wait on dmInitEventfailed failed 0x%1!08lx!\r\n",
                        GetLastError());
                break;
    }
    return(dwError);
}

VOID DmShutdownUpdates(
    VOID
    )
/*++

Routine Description:

    Shutdown DM GUM updates.

Arguments:

    None

Return Value:

    None.
--*/
{
    gbDmpShutdownUpdates = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmnotify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmnotify.c

Abstract:

    Contains notification support for the Configuration Database Manager

    Each call to DmNotifyChangeKey adds a leaf to the notification tree. This
    tree is expected to be sparse, so each node is implemented as a linked list of
    subnodes and a linked list of leaves.

    When a registry modification occurs, the tree is traversed from the root
    to the leaf representing the key. Any leaves along the path are candidates
    for reporting a notification event.

Author:

    John Vert (jvert) 9/18/1996

Revision History:

--*/
#include "dmp.h"

typedef struct _DM_NOTIFY_BRANCH {
    LIST_ENTRY SiblingList;             // Links onto parent's ChildList.
    LIST_ENTRY ChildList;               // Links onto child's SiblingList.
    LIST_ENTRY LeafList;                // Links
    struct _DM_NOTIFY_BRANCH *Parent;   // Parent
    USHORT NameLength;
    WCHAR KeyName[0];                   // Name component (a single keyname, not a path)
} DM_NOTIFY_BRANCH, *PDM_NOTIFY_BRANCH;

typedef struct _DM_NOTIFY_LEAF {
    LIST_ENTRY SiblingList;             // Links onto parent branch's ChildList
    LIST_ENTRY KeyList;                 // Links onto DMKEY.NotifyList
    LIST_ENTRY RundownList;             // Passed into DmNotifyChangeKey, used for rundown
    HDMKEY     hKey;
    DWORD      CompletionFilter;
    DM_NOTIFY_CALLBACK NotifyCallback;
    DWORD_PTR  Context1;
    DWORD_PTR  Context2;
    PDM_NOTIFY_BRANCH Parent;
    BOOL       WatchTree;
} DM_NOTIFY_LEAF, *PDM_NOTIFY_LEAF;

CRITICAL_SECTION NotifyLock;
PDM_NOTIFY_BRANCH NotifyRoot=NULL;

//
// Local function prototypes
//
VOID
DmpPruneBranch(
    IN PDM_NOTIFY_BRANCH Branch
    );

PDM_NOTIFY_BRANCH
DmpFindKeyInBranch(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN OUT LPCWSTR *RelativeName,
    OUT WORD *pNameLength
    );

DWORD
DmpAddNotifyLeaf(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN PDM_NOTIFY_LEAF NewLeaf,
    IN LPCWSTR RelativeName
    );

VOID
DmpReportNotifyWorker(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN LPCWSTR RelativeName,
    IN LPCWSTR FullName,
    IN DWORD Filter
    );


BOOL
DmpInitNotify(
    VOID
    )
/*++

Routine Description:

    Initializes the notification package for the DM.

Arguments:

    None.

Return Value:

    TRUE if successful

    FALSE otherwise

--*/

{
    InitializeCriticalSection(&NotifyLock);

    return(TRUE);
}


DWORD
DmNotifyChangeKey(
    IN HDMKEY hKey,
    IN DWORD CompletionFilter,
    IN BOOL WatchTree,
    IN OPTIONAL PLIST_ENTRY ListHead,
    IN DM_NOTIFY_CALLBACK NotifyCallback,
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2
    )
/*++

Routine Description:

    Registers a notification for a specific registry key. When the
    notification event occurs, ApiReportRegistryNotify will be called.

Arguments:

    hKey - Supplies the registry key handle on which the notification
           should be posted.

    CompletionFilter - Supplies the registry events which should trigger
           the notification.

    WatchTree - Supplies whether or not changes to the children of the specified
           key should trigger the notification.

    ListHead - If present, supplies the listhead that the new notification should be
            queued to. This listhead should be passed to DmRundownList.

    NotifyCallback - Supplies the notification routine that should be called
            when the notification occurs.

    Context1 - Supplies the first DWORD of context to be passed to ApiReportRegistryNotify

    Context2 - Supplies the second DWORD of context to be passed to ApiReportRegistryNotify

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    PDMKEY Key;
    PDM_NOTIFY_LEAF Leaf;
    DWORD Status;

    Key = (PDMKEY)hKey;

    Leaf = LocalAlloc(LMEM_FIXED, sizeof(DM_NOTIFY_LEAF));
    if (Leaf == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Leaf->hKey = hKey;
    Leaf->CompletionFilter = CompletionFilter;
    Leaf->WatchTree = WatchTree;
    Leaf->NotifyCallback = NotifyCallback;
    Leaf->Context1 = Context1;
    Leaf->Context2 = Context2;

    EnterCriticalSection(&NotifyLock);

    if (NotifyRoot == NULL) {
        //
        // Create notify root here.
        //
        NotifyRoot = LocalAlloc(LMEM_FIXED, sizeof(DM_NOTIFY_BRANCH));
        if (NotifyRoot == NULL) {
            LeaveCriticalSection(&NotifyLock);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        InitializeListHead(&NotifyRoot->SiblingList);
        InitializeListHead(&NotifyRoot->ChildList);
        InitializeListHead(&NotifyRoot->LeafList);
        NotifyRoot->Parent = NULL;
    }

    Status = DmpAddNotifyLeaf(NotifyRoot, Leaf, Key->Name);
    if (Status == ERROR_SUCCESS) {
        InsertHeadList(&Key->NotifyList, &Leaf->KeyList);
        if (ARGUMENT_PRESENT(ListHead)) {
            InsertHeadList(ListHead, &Leaf->RundownList);
        } else {
            Leaf->RundownList.Flink = NULL;
            Leaf->RundownList.Blink = NULL;
        }
    } else {
        LocalFree(Leaf);
    }

    LeaveCriticalSection(&NotifyLock);

    return(Status);
}


VOID
DmRundownList(
    IN PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Runs down a list of leaves. Used by the API when the notify port
    is closed.

Arguments:

    ListHead - Supplies the head of the rundown list. This is the
        same listhead passed to DmNotifyChangeKey

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_LEAF Leaf;

    //
    // Remove all outstanding DM_NOTIFY_LEAF structures from this list.
    //
    EnterCriticalSection(&NotifyLock);
    while (!IsListEmpty(ListHead)) {
        ListEntry = RemoveHeadList(ListHead);
        Leaf = CONTAINING_RECORD(ListEntry,
                                 DM_NOTIFY_LEAF,
                                 RundownList);
        RemoveEntryList(&Leaf->SiblingList);
        RemoveEntryList(&Leaf->KeyList);

        //
        // Attempt to prune this branch.
        //
        DmpPruneBranch(Leaf->Parent);

        LocalFree(Leaf);
    }

    LeaveCriticalSection(&NotifyLock);
}


VOID
DmpRundownNotify(
    IN PDMKEY Key
    )
/*++

Routine Description:

    Cleans up any outstanding notifications for a key when the
    key is being closed.

Arguments:

    Key - Supplies the key

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_LEAF Leaf;

    //
    // Remove all outstanding DM_NOTIFY_LEAF structures from this key.
    //
    EnterCriticalSection(&NotifyLock);
    while (!IsListEmpty(&Key->NotifyList)) {
        ListEntry = RemoveHeadList(&Key->NotifyList);
        Leaf = CONTAINING_RECORD(ListEntry,
                                 DM_NOTIFY_LEAF,
                                 KeyList);
        RemoveEntryList(&Leaf->SiblingList);
        if (Leaf->RundownList.Flink != NULL) {
            RemoveEntryList(&Leaf->RundownList);
        }

        //
        // Attempt to prune this branch.
        //
        DmpPruneBranch(Leaf->Parent);

        LocalFree(Leaf);
    }

    LeaveCriticalSection(&NotifyLock);

}


VOID
DmpPruneBranch(
    IN PDM_NOTIFY_BRANCH Branch
    )
/*++

Routine Description:

    Checks to see if a branch is empty and should be pruned (freed).
    If the branch is empty, this routine will recursively call itself
    on the parent until a non-empty branch is found.

Arguments:

    Branch - Supplies the branch to be pruned.

Return Value:

    None.

--*/

{
    if ((IsListEmpty(&Branch->ChildList)) &&
        (IsListEmpty(&Branch->LeafList))) {

        //
        // No need to keep this branch around any more. Remove
        // it from its parent, then check to see if the parent
        // should be pruned.
        //
        if (Branch->Parent == NULL) {
            //
            // This is the root, go ahead and free it up too.
            //
            CL_ASSERT(NotifyRoot == Branch);
            NotifyRoot = NULL;

        } else {
            RemoveEntryList(&Branch->SiblingList);
            DmpPruneBranch(Branch->Parent);
        }
        LocalFree(Branch);
    }
}


DWORD
DmpAddNotifyLeaf(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN PDM_NOTIFY_LEAF NewLeaf,
    IN LPCWSTR RelativeName
    )
/*++

Routine Description:

    Adds a leaf to the notification key.

    If the RelativeName is empty, a leaf is created in RootBranch.

    If the RelativeName is not empty, look up its first component
    in RootBranch. If it's not there, create it. Then call ourselves
    recursively after stripping off the first component of RelativeName

Arguments:

    RootBranch - Supplies the root where the leaf is to be added

    NewLeaf - Supplies the new leaf structure

    RelativeName - Supplies the relative name.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_BRANCH Branch;
    USHORT NameLength;
    LPCWSTR NextName;

    if (RelativeName[0] == '\0') {
        InsertHeadList(&RootBranch->LeafList, &NewLeaf->SiblingList);
        NewLeaf->Parent = RootBranch;
        return(ERROR_SUCCESS);
    }

    NextName = RelativeName;
    Branch = DmpFindKeyInBranch(RootBranch, &NextName, &NameLength);
    if (Branch == NULL) {
        //
        // No branch existed with this name. Create a new branch.
        //
        Branch = LocalAlloc(LMEM_FIXED, sizeof(DM_NOTIFY_BRANCH) + NameLength*sizeof(WCHAR));
        if (Branch == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        InitializeListHead(&Branch->ChildList);
        InitializeListHead(&Branch->LeafList);
        Branch->Parent = RootBranch;
        Branch->NameLength = NameLength;
        CopyMemory(Branch->KeyName, RelativeName, NameLength*sizeof(WCHAR));
        InsertHeadList(&RootBranch->ChildList, &Branch->SiblingList);
    }

    //
    // Call ourselves recursively on the new branch.
    //
    return(DmpAddNotifyLeaf(Branch, NewLeaf, NextName));
}


VOID
DmpReportNotify(
    IN LPCWSTR KeyName,
    IN DWORD Filter
    )
/*++

Routine Description:

    Interface to the rest of DM to report a notification event on
    a particular key.

Arguments:

    Key - Supplies the key that was modified.

    Filter - Supplies the modification type.

Return Value:

    None.

--*/

{
    if (NotifyRoot == NULL) {
        return;
    }

    EnterCriticalSection(&NotifyLock);

    if (NotifyRoot != NULL) {
        DmpReportNotifyWorker(NotifyRoot,
                              KeyName,
                              KeyName,
                              Filter);
    }

    LeaveCriticalSection(&NotifyLock);

}


VOID
DmpReportNotifyWorker(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN LPCWSTR RelativeName,
    IN LPCWSTR FullName,
    IN DWORD Filter
    )
/*++

Routine Description:

    Recursive worker routine that drills down through the notification
    tree until it reaches the supplied name. Notifications are issued
    for any leaves along the path that match the event.

Arguments:

    RootBranch - Supplies the branch of the tree to start with.

    RelativeName - Supplies the name of the changed key, relative to Branch.

    FullName - Supplies the full name of the changed key.

    Filter - Supplies the type of event.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_LEAF Leaf;
    PDM_NOTIFY_BRANCH Branch;
    LPCWSTR NextName;
    WORD Dummy;

    //
    // First, issue notifies for any leaves at this node
    //
    ListEntry = RootBranch->LeafList.Flink;
    while (ListEntry != &RootBranch->LeafList) {
        Leaf = CONTAINING_RECORD(ListEntry,
                                 DM_NOTIFY_LEAF,
                                 SiblingList);
        if (Leaf->CompletionFilter & Filter) {
            if ( Leaf->WatchTree ||
                (RelativeName[0] == '\0')) {

                (Leaf->NotifyCallback)(Leaf->Context1,
                                       Leaf->Context2,
                                       Filter,
                                       RelativeName);

            }
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Now search the child list for a subkey that matches the next component
    // of the key name. If there isn't one, we are done. If there is one,
    // call ourselves recursively on it.
    //
    if (RelativeName[0] == '\0') {
        return;
    }
    NextName = RelativeName;
    Branch = DmpFindKeyInBranch(RootBranch, &NextName, &Dummy);
    if (Branch != NULL) {
        DmpReportNotifyWorker(Branch, NextName, FullName, Filter);
    }

}


PDM_NOTIFY_BRANCH
DmpFindKeyInBranch(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN OUT LPCWSTR *RelativeName,
    OUT WORD *pNameLength
    )
/*++

Routine Description:

    Finds the next component of a key name in a branch.

Arguments:

    RootBranch - Supplies the branch to search.

    RelativeName - Supplies the relative name of the key.
                   Returns the remaining name

    NameLength - Returns the length of the next component.

Return Value:

    Pointer to the found branch if successful.

    NULL otherwise.

--*/

{
    PDM_NOTIFY_BRANCH Branch;
    USHORT NameLength;
    LPCWSTR NextName;
    PLIST_ENTRY ListEntry;

    //
    // Find the first component of the relative name.
    //
    NextName = wcschr(*RelativeName, '\\');
    if (NextName==NULL) {
        NameLength = (USHORT)lstrlenW(*RelativeName);
        NextName = *RelativeName + NameLength;
    } else {
        NameLength = (USHORT)(NextName - *RelativeName);
        ++NextName;
    }
    *pNameLength = NameLength;

    //
    // Search through the root's children to try and find a match on the
    // first component.
    //
    ListEntry = RootBranch->ChildList.Flink;
    while (ListEntry != &RootBranch->ChildList) {
        Branch = CONTAINING_RECORD(ListEntry,
                                   DM_NOTIFY_BRANCH,
                                   SiblingList);
        if ((NameLength == Branch->NameLength) &&
            (wcsncmp(*RelativeName, Branch->KeyName, NameLength)==0)) {

            //
            // We have matched an existing branch. Return success.
            //
            *RelativeName = NextName;
            return(Branch);
        }
        ListEntry = ListEntry->Flink;
    }
    *RelativeName = NextName;

    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmp.h ===
#ifndef _DMP_H
#define _DMP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmp.h

Abstract:

    Private header file for the Config Database Manager (DM) component
    of the NT Cluster Service

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_DM

#define DM_SEPARATE_HIVE 1

// For now is hKey is NULL, we assume that it was deleted while this handle was open
#define ISKEYDELETED(pDmKey)            \
        (!((pDmKey != NULL) && (pDmKey->hKey)))

#define AMIOWNEROFQUORES(pQuoResource)  \
        (NmGetNodeId(NmLocalNode) == NmGetNodeId(pQuoResource->Group->OwnerNode))


//
// DMKEY Structure.
//

typedef struct _DMKEY {
    LIST_ENTRY ListEntry;
    LIST_ENTRY NotifyList;
    HKEY    hKey;
    DWORD   GrantedAccess;
    WCHAR   Name[0];
} DMKEY, *PDMKEY;

//
// Update handler definition
//
DWORD
DmpUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

//
// Definitions for GUM update types
//
// The first entries in this list are auto-marshalled through Gum...Ex.
// Any updates that are not auto-marshalled must come after DmUpdateMaxAuto
//
typedef enum {
    DmUpdateCreateKey = 0,
    DmUpdateSetSecurity,
    DmUpdateMaxAuto = 0x1000,
    DmUpdateDeleteKey,
    DmUpdateSetValue,
    DmUpdateDeleteValue,
    DmUpdateJoin
} DM_UPDATE_TYPE;

//
// Key creation update structure.
//
typedef struct _DM_CREATE_KEY_UPDATE {
    LPDWORD lpDisposition;              // only valid on issuing node
    HKEY    *phKey;                     // only valid on issuing node
    DWORD   samDesired;
    DWORD   dwOptions;
    BOOL    SecurityPresent;
} DM_CREATE_KEY_UPDATE, *PDM_CREATE_KEY_UPDATE;


//
// Key deletion update structure.
//
typedef struct _DM_DELETE_KEY_UPDATE {
    LPDWORD lpStatus;                   // only valid on issuing node
    WCHAR   Name[0];
} DM_DELETE_KEY_UPDATE, *PDM_DELETE_KEY_UPDATE;

//
// Value set update structure.
//
typedef struct _DM_SET_VALUE_UPDATE {
    LPDWORD lpStatus;                   // only valid on issuing node
    DWORD   NameOffset;
    DWORD   DataOffset;
    DWORD   DataLength;
    DWORD   Type;
    WCHAR   KeyName[0];
} DM_SET_VALUE_UPDATE, *PDM_SET_VALUE_UPDATE;

//
// Value delete update structure.
//
typedef struct _DM_DELETE_VALUE_UPDATE {
    LPDWORD lpStatus;                   // only valid on issuing node
    DWORD   NameOffset;
    WCHAR   KeyName[0];
} DM_DELETE_VALUE_UPDATE, *PDM_DELETE_VALUE_UPDATE;

// the record structure for quorum logging


typedef struct _DM_LOGSCAN_CONTEXT{
        DWORD       dwSequence;
        LSN         StartLsn;
        DWORD       dwLastSequence;
}DM_LOGSCAN_CONTEXT, *PDM_LOGSCAN_CONTEXT;
//
// Data local to the DM module.
//
extern HKEY DmpRoot;
extern LIST_ENTRY KeyList;
extern CRITICAL_SECTION KeyLock;
extern BOOL gbDmpShutdownUpdates;

//disk space requirements
//1M, is lower than this, gracefully shutdown
#define DISKSPACE_LOW_WATERMARK     (1 * 1024 * 1000)
//2M, if lower then send alert
#define DISKSPACE_HIGH_WATERMARK    (5 * 1024 * 1000)
//minimum required to start the cluster service
#define DISKSPACE_INIT_MINREQUIRED  DISKSPACE_HIGH_WATERMARK

#define DISKSPACE_MANAGE_INTERVAL     (5 * 60 * 1000) //5 minute..log management functions are performed

#define DEFAULT_CHECKPOINT_INTERVAL     (4 ) // in hours

typedef struct _LOCALXSACTION{
    DWORD       dwSig;
    DWORD       dwSequence;
    HXSACTION   hLogXsaction;   //the log transaction
    LIST_ENTRY  PendingNotifyListHead;  //the pending notifications to be issued on commit
}LOCALXSACTION, *PLOCALXSACTION;


typedef struct _DM_PENDING_NOTIFY{
    LIST_ENTRY  ListEntry;
    LPWSTR      pszKeyName;
    DWORD       dwFilter;
}DM_PENDING_NOTIFY, *PDM_PENDING_NOTIFY;


#define LOCALXSAC_SIG   'CAXL'

#define GETLOCALXSACTION(pLocalXsaction, hLocalXsaction)    \
        (pLocalXsaction) = (PLOCALXSACTION)(hLocalXsaction); \
        CL_ASSERT((pLocalXsaction)->dwSig == LOCALXSAC_SIG)

//quorum log tombstone
#define     MAXSIZE_RESOURCEID         128
typedef struct _QUO_TOMBSTONE{
       WCHAR    szOldQuoResId[MAXSIZE_RESOURCEID];
       WCHAR    szOldQuoLogPath[MAX_PATH];
}QUO_TOMBSTONE, *PQUO_TOMBSTONE;


//
// Function prototypes local to the DM
//
DWORD
DmpOpenKeys(
    IN REGSAM samDesired
    );

DWORD
DmpGetRegistrySequence(
    VOID
    );

DWORD
DmpSyncDatabase(
    IN RPC_BINDING_HANDLE  RpcBinding,
    IN OPTIONAL LPCWSTR Directory
    );

VOID
DmpUpdateSequence(
    VOID
    );

VOID
DmpInvalidateKeys(
    VOID
    );

VOID
DmpReopenKeys(
    VOID
    );

//
// Notification interface
//
BOOL
DmpInitNotify(
    VOID
    );

VOID
DmpRundownNotify(
    IN PDMKEY Key
    );

VOID
DmpReportNotify(
    IN LPCWSTR KeyName,
    IN DWORD Filter
    );

//for delivering notifications when a transaction is committed
VOID
DmpReportPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN BOOL             bCommit
    );

DWORD
DmpAddToPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN LPCWSTR          pszName,
    IN DWORD            dwFilter
    );

//
// Update handlers
//

DWORD
DmpUpdateCreateKey(
    IN BOOL SourceNode,
    IN PDM_CREATE_KEY_UPDATE CreateUpdate,
    IN LPCWSTR KeyName,
    IN OPTIONAL LPVOID lpSecurityDescriptor
    );

DWORD
DmpUpdateDeleteKey(
    IN BOOL SourceNode,
    IN PDM_DELETE_KEY_UPDATE Update
    );

DWORD
DmpUpdateSetValue(
    IN BOOL SourceNode,
    IN PDM_SET_VALUE_UPDATE Update
    );

DWORD
DmpUpdateDeleteValue(
    IN BOOL SourceNode,
    IN PDM_DELETE_VALUE_UPDATE Update
    );

DWORD
DmpUpdateSetSecurity(
    IN BOOL SourceNode,
    IN PSECURITY_INFORMATION pSecurityInformation,
    IN LPCWSTR KeyName,
    IN PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    IN LPDWORD pGrantedAccess
    );


//
// For Quorum Logging
//
DWORD DmpChkQuoTombStone(void);

DWORD DmpApplyChanges(void);

DWORD DmpCheckDiskSpace(void);

//diskmanage functions
void
WINAPI DmpDiskManage(
    IN HANDLE   hTimer,
    IN PVOID    pContext
    );

void WINAPI DmpCheckpointTimerCb(
    IN HANDLE hTimer,
    IN PVOID pContext
    );

DWORD DmWriteToQuorumLog(
    IN DWORD        dwGumDispatch,
    IN DWORD        dwSequence,
    IN DWORD        dwType,
    IN PVOID        pData,
    IN DWORD        dwSize
    );

BOOL DmpLogApplyChangesCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         Transaction,
    IN TRTYPE       TransactionType,
    IN const        PVOID pLogData,
    IN DWORD        DataLength
    );

BOOL WINAPI DmpApplyTransactionCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         TransactionId,
    IN const PVOID  pLogData,
    IN DWORD        dwDataLength
    );

DWORD  DmpLogFindStartLsn(
    IN HLOG         hQuoLog,
    OUT LSN         *pStartScanLsn,
    IN OUT LPDWORD  pdwSequence);

BOOL WINAPI DmpLogFindStartLsnCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         Transaction,
    IN TRTYPE       TransactionType,
    IN const        PVOID pLogData,
    IN DWORD        DataLength);

DWORD WINAPI DmpGetSnapShotCb(
    IN LPCWSTR      lpszPathName,
    IN PVOID        pContext,
    OUT LPWSTR      szChkPtFile,
    OUT LPDWORD     pdwChkPtSequence);

DWORD
    DmpHookQuorumNotify(void);

DWORD
    DmpUnhookQuorumNotify(void);


void DmpQuoObjNotifyCb(
    IN PVOID pContext,
    IN PVOID pObject,
    IN DWORD dwNotification);

DWORD
    DmpHookEventHandler();


BOOL DmpNodeObjEnumCb(
    IN BOOL *pbAreAllNodesUp,
    IN PVOID pContext2,
    IN PVOID pNode,
    IN LPCWSTR szName);

DWORD WINAPI
DmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID pContext
    );

DWORD
DmpLoadHive(
    IN LPCWSTR Path
    );

DWORD
DmpUnloadHive(
    );

DWORD DmpRestoreClusterDatabase(
    IN LPCWSTR  lpszQuoLogPathName 
    );

DWORD DmpLogCheckpointAndBackup(
    IN HLOG     hLogFile,    
    IN LPWSTR   lpszPathName);


DWORD DmpGetCheckpointInterval(
    OUT LPDWORD pdwCheckpointInterval);

DWORD DmpHandleNodeDownEvent(
    IN LPVOID  NotUsed );

//
// registry flusher thread interface.
//
DWORD
DmpStartFlusher(
    VOID
    );

VOID
DmpShutdownFlusher(
    VOID
    );


VOID
DmpRestartFlusher(
    VOID
    );

DWORD
DmpSetDwordInClusterServer(
    LPCWSTR lpszValueName,
    DWORD   dwValue
    );


DWORD DmpGetDwordFromClusterServer(
    IN LPCWSTR lpszValueName,
    OUT LPDWORD pdwValue,
    IN DWORD   dwDefaultValue
    );
    
DWORD
DmpSafeDatabaseCopy(
    IN LPCWSTR  FileName,
    IN LPCWSTR  Path,
    IN LPCWSTR  BkpPath,
    IN BOOL     bDeleteSrcFile
    );

#endif //ifndef _DMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmlog.c

Abstract:

    Contains the quorum logging related functions for
    the cluster registry.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"
#include "tchar.h"
#include "clusudef.h"
/****
@doc    EXTERNAL INTERFACES CLUSSVC DM
****/

//global static data
HLOG                ghQuoLog=NULL;  //pointer to the quorum log
DWORD               gbIsQuoResOnline = FALSE;
DWORD               gbNeedToCheckPoint = FALSE;
DWORD               gbIsQuoResEnoughSpace = TRUE;
HLOG                ghNewQuoLog = NULL; //pointer to the new quorum resource
//global data
extern HANDLE           ghQuoLogOpenEvent;
extern BOOL             gbIsQuoLoggingOn;
extern HANDLE           ghDiskManTimer;
extern HANDLE           ghCheckpointTimer;
extern PFM_RESOURCE     gpQuoResource;  //set when DmFormNewCluster is complete
extern BOOL             gbDmInited;
#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

//forward definitions
void DmpLogCheckPointCb();

/****
@func       DWORD | DmPrepareQuorumResChange| When the quorum resource is changed,
            the FM invokes this api on the owner node of the new quorum resource
            to create a new quorum log file.

@parm       IN PVOID | pResource | The new quorum resource.
@parm       IN LPCWSTR | lpszPath | The path for temporary cluster files.
@parm       IN DWORD | dwMaxQuoLogSize | The maximum size limit for the quorum log file.

@comm       When a quorum resource is changed, the fm calls this funtion before it
            updates the quorum resource.  If a new log file needs to be created,
            a checkpoint is taken.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD DmPrepareQuorumResChange(
    IN PVOID    pResource,
    IN LPCWSTR  lpszPath,
    IN DWORD    dwMaxQuoLogSize)
{
    DWORD           dwError=ERROR_SUCCESS;
    PFM_RESOURCE    pNewQuoRes;
    WCHAR           szFileName1[MAX_PATH];  //for new quorum log,for tombstonefile
    LSN             FirstLsn;
    WCHAR           szFileName2[MAX_PATH];  //for old quorum log, for temp tombstone
    DWORD           dwCurLogSize;
    DWORD           dwMaxLogSize;
    DWORD           dwChkPtSequence;
    WIN32_FIND_DATA FindData;
    HANDLE          hSrchTmpFiles;
    HANDLE          hDirectory;

    pNewQuoRes = (PFM_RESOURCE)pResource;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmPrepareQuorumResChange - Entry\r\n");


    //the resource is already online at this point
    //if the directory doesnt exist create it
    dwError = ClRtlCreateDirectory(lpszPath);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Failed to create directory, Status=%1!u!\r\n",
            dwError);
        goto FnExit;
    }

    lstrcpyW(szFileName1, lpszPath);
    lstrcatW(szFileName1, cszQuoFileName);

    //if the log file is open here
    //this implies that the new quorum resource is the on the same node
    //as the old one
    if (ghQuoLog)
    {
        LogGetInfo(ghQuoLog, szFileName2, &dwCurLogSize, &dwMaxLogSize);

        //if the file is the same as the new log file, simply set the size
        if (!lstrcmpiW(szFileName2, szFileName1))
        {
            LogSetInfo(ghQuoLog, dwMaxQuoLogSize);
            ghNewQuoLog = ghQuoLog;
            goto CopyCpFiles;
        }
    }


    //delele all the quorum logging related files
    //delete the log if it exits
    DeleteFile(szFileName1);
    //delete all checkpoint files
    lstrcpyW(szFileName2, lpszPath);
    lstrcatW(szFileName2, L"*.tmp");
    hSrchTmpFiles = FindFirstFileW(szFileName2, & FindData);
    if (hSrchTmpFiles != INVALID_HANDLE_VALUE)
    {
        lstrcpyW(szFileName2, lpszPath);
        lstrcatW(szFileName2, FindData.cFileName);
        DeleteFile(szFileName2);

        while (FindNextFile( hSrchTmpFiles, & FindData))
        {
            lstrcpyW(szFileName2, lpszPath);
            lstrcatW(szFileName2, FindData.cFileName);
            DeleteFile(szFileName2);
        }
        FindClose(hSrchTmpFiles);
    }

    //set the security attributes for the file
    hDirectory =  CreateFile(lpszPath,
        GENERIC_READ|WRITE_DAC|READ_CONTROL,
        0,
        NULL,
        OPEN_ALWAYS,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (hDirectory == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Failed to create file, Status=%1!u!\r\n",
            dwError);
        goto FnExit;
    }

    dwError = ClRtlSetObjSecurityInfo(hDirectory, SE_FILE_OBJECT,
        GENERIC_ALL, GENERIC_ALL, GENERIC_READ);
    CloseHandle(hDirectory);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - ClRtlSetObjSecurityInfo Failed, Status=%1!u!\r\n",
            dwError);
        goto FnExit;
    }
    //open the new log file

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmPrepareQuorumResChange: the name of the quorum file is %1!ls!\r\n",
        szFileName1);

    //open the log file
    ghNewQuoLog = LogCreate(szFileName1, dwMaxQuoLogSize,
        (PLOG_GETCHECKPOINT_CALLBACK)DmpGetSnapShotCb, NULL,
        TRUE, &FirstLsn);

    if (!ghNewQuoLog)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmPrepareQuorumResChange: Quorum log could not be opened, error = %1!u!\r\n",
            dwError);
        CsLogEventData1( LOG_CRITICAL,
                         CS_DISKWRITE_FAILURE,
                         sizeof(dwError),
                         &dwError,
                         szFileName1 );
        CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
    }

    //create a checkpoint in the new place
    dwError = DmpGetSnapShotCb(lpszPath, NULL, szFileName1, &dwChkPtSequence);
    if (dwError != ERROR_SUCCESS)
    {
        CL_LOGFAILURE(dwError);
        CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
        goto FnExit;
    }

    dwError = LogCheckPoint(ghNewQuoLog, TRUE, szFileName1, dwChkPtSequence);

    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - failed to take chkpoint, error = %1!u!\r\n",
            dwError);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmPrepareQuorumResChange - checkpoint taken\r\n");


CopyCpFiles:
    //
    // Call the checkpoint manager to copy over any checkpoint files
    //
    dwError = CpCopyCheckpointFiles(lpszPath, FALSE);
    if (dwError != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //create the tombstone and tmp file names
    lstrcpyW(szFileName1, lpszPath);
    lstrcatW(szFileName1, cszQuoTombStoneFile);

    lstrcpyW(szFileName2, lpszPath);
    lstrcatW(szFileName2, cszTmpQuoTombStoneFile);

    //rename the quorum tomstone file,it if it exists
    if (!MoveFileExW(szFileName1, szFileName2,
        MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH))
    {
        //this may fail if the tombstone doesnt exist, ignore error
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmPrepareQuorumResChange:tombstone doesnt exist,movefilexW failed, error=0x%1!08lx!\r\n",
            GetLastError());
    }

FnExit:
    if (dwError != ERROR_SUCCESS)
    {
        //if not sucess, clean up the new file
        if (ghNewQuoLog)
        {
            LogClose(ghNewQuoLog);
            ghNewQuoLog = NULL;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Exit, error=0x%1!08lx!\r\n",
            dwError);
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Exit, status=0x%1!08lx!\r\n",
            dwError);
    }

    return(dwError);

} // DmPrepareQuorumResChange

/****
@func       void | DmDwitchToNewQuorumLog| This is called to switch to a new
            quorum log when the quorum resource is changed.

@comm       When a quorum resource is successfully changed, this function is
            to switch quorum logs.  The synchronous notifications for the old resource
            are unhooked and those for the new resource file are hooked.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
void DmSwitchToNewQuorumLog(
    IN LPCWSTR lpszQuoLogPath)
{
    WCHAR   szTmpQuoTombStone[MAX_PATH];
    DWORD   dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmSwitchQuorumLogs - Entry\r\n");

    //unhook notifications with the old quorum resource
    DmpUnhookQuorumNotify();
    //ask the dm to register with the new quorum resource
    DmpHookQuorumNotify();

    //if the new log file exists... this is the owner of the new quorum resource.
    //the new log file may be the same as the old one
    if (ghNewQuoLog)
    {
        if (ghQuoLog && (ghQuoLog != ghNewQuoLog))
        {
            LogClose(ghQuoLog);
           //take another checkpoint to the new quorum file,
           //so that the last few updates make into it
            if ((dwError = LogCheckPoint(ghNewQuoLog, TRUE, NULL, 0))
                != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmSwitchQuorumLogs - Failed to take a checkpoint\r\n");
                CL_UNEXPECTED_ERROR(dwError);
            }
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmSwitchQuorumLogs - taken checkpoint\r\n");

            ghQuoLog = NULL;
        }
        ghQuoLog = ghNewQuoLog;
        ghNewQuoLog = NULL;

        // if the old tombstome was replace by a tmp file at the beginning
        //of change quorum resource delete it now
        //get the tmp file for the new quorum resource
        lstrcpyW(szTmpQuoTombStone, lpszQuoLogPath);
        lstrcatW(szTmpQuoTombStone, cszTmpQuoTombStoneFile);
        DeleteFile(szTmpQuoTombStone);
        
    }
    else
    {
        //if the old log file is open, owner of the old quorum resource
        if (ghQuoLog)
        {
            LogClose(ghQuoLog);
            ghQuoLog = NULL;
        }
    }

    if (FmDoesQuorumAllowLogging() != ERROR_SUCCESS)
    {
        //this is not enough to ensure the dm logging will cease
        //the ghQuoLog parameter must be NULL
        CsNoQuorumLogging = TRUE;
        if (ghQuoLog)
        {
            LogClose(ghQuoLog);
            ghQuoLog = NULL;
        }                
    } else if ( !CsUserTurnedOffQuorumLogging )
    {
        //
        //  If the user did not turn off quorum logging explicitly, then turn it back on since
        //  the new quorum resource is not local quorum.
        //
        CsNoQuorumLogging = FALSE;    
    }

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmSwitchQuorumLogs - Exit!\r\n");
    return;
}

/****
@func       DWORD | DmReinstallTombStone| If the change to a new quorum
            resource fails, the new log is closed and the tombstone is
            reinstalled.

@parm       IN LPCWSTR | lpszQuoLogPath | The path for maintenance cluster files.

@comm       The old quorum log file is deleted and a tomstone file is created in its
            place.  If this tombstone file is detected in the quorum path, the node
            is not allowed to do a form.  It must do a join to find about the new
            quorum resource from the node that knows about the most recent quorum
            resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD DmReinstallTombStone(
    IN LPCWSTR  lpszQuoLogPath
)
{

    DWORD           dwError=ERROR_SUCCESS;
    WCHAR           szQuoTombStone[MAX_PATH];
    WCHAR           szTmpQuoTombStone[MAX_PATH];



    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmReinstallTombStone - Entry\r\n");

    if (ghNewQuoLog)
    {
        //get the tmp file for the new quorum resource
        lstrcpyW(szTmpQuoTombStone, lpszQuoLogPath);
        lstrcatW(szTmpQuoTombStone, cszTmpQuoTombStoneFile);

        //create the tombstone file or replace the previous one with a new one
        lstrcpyW(szQuoTombStone, lpszQuoLogPath);
        lstrcatW(szQuoTombStone, cszQuoTombStoneFile);

        //restore the tombstone
        if (!MoveFileExW(szTmpQuoTombStone, szQuoTombStone,
            MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH))
        {
            //this may fail if the tombstone doesnt exist, ignore error
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmReinstallTombStone :Warning-MoveFileExW failed, error=0x%1!08lx!\r\n",
                GetLastError());
        }
        // if this is not the same as the old log file, close it
        if (ghNewQuoLog != ghQuoLog)
        {
            LogClose(ghNewQuoLog);
        }
        ghNewQuoLog = NULL;
    }

    return(dwError);
}


/****
@func       DWORD | DmCompleteQuorumResChange| This is called on the quorum resource
            if the old quorum log file is not the same as the new one.

@parm       IN PVOID | pOldQuoRes | The new quorum resource.
@parm       IN LPCWSTR | lpszPath | The path for temporary cluster files.
@parm       IN DWORD | dwMaxQuoLogSize | The maximum size limit for the quorum log file.

@comm       The old quorum log file is deleted and a tomstone file is created in its
            place.  If this tombstone file is detected in the quorum path, the node
            is not allowed to do a form.  It must do a join to find about the new
            quorum resource from the node that knows about the most recent quorum
            resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD DmCompleteQuorumResChange(
    IN LPCWSTR  lpszOldQuoResId,
    IN LPCWSTR  lpszOldQuoLogPath
)
{
    DWORD           dwError=ERROR_SUCCESS;
    WCHAR           szOldQuoFileName[MAX_PATH];
    HANDLE          hTombStoneFile;
    WCHAR           szQuorumTombStone[MAX_PATH];
    PQUO_TOMBSTONE  pTombStone = NULL;
    DWORD           dwBytesWritten;
    WIN32_FIND_DATA FindData;
    HANDLE          hSrchTmpFiles;



    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCompleteQuorumResChange - Entry\r\n");

    //the old log file name
    lstrcpyW(szOldQuoFileName, lpszOldQuoLogPath);
    lstrcatW(szOldQuoFileName, cszQuoFileName);

    //create the tombstone file or replace the previous one with a new one
    lstrcpyW(szQuorumTombStone, lpszOldQuoLogPath);
    lstrcatW(szQuorumTombStone, cszQuoTombStoneFile);

    pTombStone = LocalAlloc(LMEM_FIXED, sizeof(QUO_TOMBSTONE));
    if (!pTombStone)
    {
        CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
        CsLogEvent(LOG_UNUSUAL, DM_TOMBSTONECREATE_FAILED);
        goto DelOldFiles;
    }
    hTombStoneFile = CreateFileW(szQuorumTombStone,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL);

    if (hTombStoneFile == INVALID_HANDLE_VALUE)
    {
        //dont return failure
        CL_LOGFAILURE(GetLastError());
        CsLogEvent(LOG_UNUSUAL, DM_TOMBSTONECREATE_FAILED);
        goto DelOldFiles;

    }
    //write the old quorum path to it.
    lstrcpyn(pTombStone->szOldQuoResId, lpszOldQuoResId, MAXSIZE_RESOURCEID);
    lstrcpy(pTombStone->szOldQuoLogPath, lpszOldQuoLogPath);

    //write the tombstones
    if (! WriteFile(hTombStoneFile, pTombStone, sizeof(QUO_TOMBSTONE),
        &dwBytesWritten, NULL))
    {
        CL_LOGFAILURE(GetLastError());
        CsLogEvent(LOG_UNUSUAL, DM_TOMBSTONECREATE_FAILED);
        goto DelOldFiles;
    }

    CL_ASSERT(dwBytesWritten == sizeof(QUO_TOMBSTONE));

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCompleteQuorumResChange: tombstones written\r\n");

DelOldFiles:
    //
    //delete the old quorum files
    //
    if (!DeleteFile(szOldQuoFileName))
        CL_LOGFAILURE(GetLastError());

    //delele other tmp files in there
    lstrcpyW(szOldQuoFileName, lpszOldQuoLogPath);
    lstrcatW(szOldQuoFileName, L"*.tmp");
    hSrchTmpFiles = FindFirstFileW(szOldQuoFileName, & FindData);
    if (hSrchTmpFiles != INVALID_HANDLE_VALUE)
    {
        lstrcpyW(szQuorumTombStone, lpszOldQuoLogPath);
        lstrcatW(szQuorumTombStone, FindData.cFileName);
        DeleteFile(szQuorumTombStone);

        while (FindNextFile( hSrchTmpFiles, & FindData))
        {
            lstrcpyW(szQuorumTombStone, lpszOldQuoLogPath);
            lstrcatW(szQuorumTombStone, FindData.cFileName);
            DeleteFile(szQuorumTombStone);
        }
        FindClose(hSrchTmpFiles);
    }

    //
    // Clean up the old registry checkpoint files
    //
    CpCompleteQuorumChange(lpszOldQuoLogPath);

    if (hTombStoneFile != INVALID_HANDLE_VALUE)
        CloseHandle(hTombStoneFile);
    if (pTombStone) LocalFree(pTombStone);
    return(dwError);
}

/****
@func       DWORD | DmWriteToQuorumLog| When a transaction to the cluster database
            is completed successfully, this function is invoked.

@parm       DWORD | dwSequence | The sequnece number of the transaction.

@parm       PVOID | pData | A pointer to a record data.

@parm       DWORD | dwSize | The size of the record data in bytes.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/
DWORD WINAPI DmWriteToQuorumLog(
    IN DWORD dwGumDispatch,
    IN DWORD dwSequence,
    IN DWORD dwType,
    IN PVOID pData,
    IN DWORD dwSize)
{
    DWORD dwError=ERROR_SUCCESS;

    //dmupdate is coming before the DmUpdateJoinCluster is called.
    //at this point we are not the owner of quorum in any case
    
    if (!gpQuoResource)
        goto FnExit;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmWriteToQuorumLog Entry Seq#=%1!u! Type=%2!u! Size=%3!u!\r\n",
         dwSequence, dwType, dwSize);
    //
    //  Chittur Subbaraman (chitturs) - 6/3/99
    //  
    //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
    //  so as to maintain the ordering between this lock and the log lock.
    //
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);
    
    //if I am the owner of the quorum logs, just write the record
    if (gbIsQuoLoggingOn && ghQuoLog && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource))
    {
        if (dwGumDispatch == PRE_GUM_DISPATCH)
        {
            //make sure the logger has enough space to commit this else
            //refuse this GUM transaction
            dwError = LogCommitSize(ghQuoLog, RMRegistryMgr, dwSize);
            if (dwError != ERROR_SUCCESS)
            {
                if (dwError == ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE)
                {
                    //map error
                    CL_LOGCLUSERROR(LM_DISKSPACE_LOW_WATERMARK);
                    gbIsQuoResEnoughSpace = FALSE;
                }
            }
            else
            {
                if (!gbIsQuoResEnoughSpace) gbIsQuoResEnoughSpace = TRUE;
            }
        }
        else if (dwGumDispatch == POST_GUM_DISPATCH)
        {
            if (LogWrite(ghQuoLog, dwSequence, TTCompleteXsaction, RMRegistryMgr,
                dwType, pData, dwSize) == NULL_LSN)
            {
                dwError = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmWriteToQuorumLog failed, error=0x%1!08lx!\r\n",
                    dwError);
            }
        }
    }
    
    RELEASE_LOCK(gLockDmpRoot);
    
FnExit:
    return (dwError);

}

/****
@func   DWORD | DmpChkQuoTombStone| This checks the quorum logs to ensure
        that it is the most recent one before rolling in the changes.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@comm   This looks for the tombstone file and if one exists.  It checks if this
        quorum file is marked as dead in there.

@xref   <f FmSetQuorumResource>
****/
DWORD DmpChkQuoTombStone()
{
    DWORD           dwError=ERROR_SUCCESS;
    WCHAR           szQuorumLogPath[MAX_PATH];
    WCHAR           szQuorumTombStone[MAX_PATH];
    HANDLE          hTombStoneFile = INVALID_HANDLE_VALUE;
    PQUO_TOMBSTONE  pTombStone = NULL;
    DWORD           dwBytesRead;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpChkQuoTombStone - Entry\r\n");

    dwError = DmGetQuorumLogPath(szQuorumLogPath, sizeof(szQuorumLogPath));
    if (dwError)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone - DmGetQuorumLogPath failed,error=0x%1!08lx!\n",
            dwError);
        goto FnExit;
    }

    lstrcpyW(szQuorumTombStone, szQuorumLogPath);
    lstrcatW(szQuorumTombStone,  L"\\quotomb.stn");

    pTombStone = LocalAlloc(LMEM_FIXED, sizeof(QUO_TOMBSTONE));
    if (!pTombStone)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    hTombStoneFile = CreateFileW(szQuorumTombStone,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL);

    if (hTombStoneFile == INVALID_HANDLE_VALUE)
    {
        //there is no tombstone file, not a problem-we can proceed with the form
        goto FnExit;
    }

    //found a tombstone file
    //read the file
    if (! ReadFile(hTombStoneFile, pTombStone, sizeof(QUO_TOMBSTONE),
        &dwBytesRead, NULL))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone - Couldn't read the tombstone,error=0x%1!08lx!\n",
            dwError);
        //dont return an error, we can proceed with form??
        goto FnExit;
    }

    if (dwBytesRead != sizeof(QUO_TOMBSTONE))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone - Couldn't read the entire tombstone\r\n");
        //dont return an error, we can proceed with form??
        goto FnExit;
    }


    if ((!lstrcmpW(OmObjectId(gpQuoResource), pTombStone->szOldQuoResId))
        && (!lstrcmpiW(szQuorumLogPath, pTombStone->szOldQuoLogPath)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone:A tombstone for this resource, and quorum log file was found here.\r\n");
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone:This is node is only allowed to do a join, make sure another node forms\r\n");
        //log something into the eventlog
        CL_LOGCLUSERROR(SERVICE_MUST_JOIN);
        //we exit with succes because this is by design and we dont want
        //clusprxy to retry starting unnecessarily
        ExitProcess(dwError);
        goto FnExit;
    }
    else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone: Bogus TombStone ??\r\n");
#if DBG
        if (IsDebuggerPresent())
            DebugBreak();
#endif
        goto FnExit;

    }
FnExit:
    if (hTombStoneFile != INVALID_HANDLE_VALUE)
        CloseHandle(hTombStoneFile);
    if (pTombStone) LocalFree(pTombStone);
    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpChkQuoTombStone: Exit, returning 0x%1!08lx!\r\n",
        dwError);
    return(dwError);
}


/****
@func       DWORD | DmpApplyChanges| When dm is notified that the cluster form is
            occuring, it calls DmpApplyChanges to apply the quorum logs to the
            cluster database.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This opens the quorum file.  Note that it doesnt close the quorum file.

@xref
****/
DWORD DmpApplyChanges()
{
    LSN                 FirstLsn;
    DWORD               dwErr = ERROR_SUCCESS;
    DWORD               dwSequence;
    DM_LOGSCAN_CONTEXT  DmAppliedChangeContext;


    if (ghQuoLog == NULL)
    {
        return(ERROR_QUORUMLOG_OPEN_FAILED);
    }
    //find the current sequence number from the registry
    dwSequence = DmpGetRegistrySequence();
    ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpApplyChanges: The current registry sequence number %1!d!\r\n",
            dwSequence);

    // upload a database if the current sequence number is lower or equal to
    // the one in the database OR if the user is forcing a restore database
    // operation.
    // find the lsn of the record from which we need to start applying changes
    // if null there are no changes to apply
    dwErr = DmpLogFindStartLsn(ghQuoLog, &FirstLsn, &dwSequence);

    if (dwErr != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpApplyChanges: DmpLogFindStartLsn failed, error=0x%1!08lx!\r\n",
            dwErr);
        goto FnExit;
    }

    //dwSequence now contains the current sequence number in the registry
    DmAppliedChangeContext.dwSequence = dwSequence;

    if (FirstLsn != NULL_LSN)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpApplyChanges: The LSN of the record to apply changes from 0x%1!08lx!\r\n",
            FirstLsn);

        if (dwErr = LogScan(ghQuoLog, FirstLsn, TRUE,(PLOG_SCAN_CALLBACK)DmpLogApplyChangesCb,
            &DmAppliedChangeContext) != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpApplyChanges: LogScan failed, error=0x%1!08lx!\r\n",
                dwErr);
        }
        //if the more changes have been applied
        if (DmAppliedChangeContext.dwSequence != dwSequence)
        {
            //set the gum sequence number to the trid that has been applied
            GumSetCurrentSequence(GumUpdateRegistry, DmAppliedChangeContext.dwSequence);
            //update the registry with this sequence number
            DmpUpdateSequence();
            //set the gum sequence number to one higher for the next transaction
            GumSetCurrentSequence(GumUpdateRegistry,
                (DmAppliedChangeContext.dwSequence + 1));

            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpApplyChanges: Gum sequnce number set to = %1!d!\r\n",
                (DmAppliedChangeContext.dwSequence + 1));

        }
    }
FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpApplyChanges: Exit, returning 0x%1!08lx!\r\n",
        dwErr);
    return(dwErr);
}


/****
@func   DWORD | DmpFindStartLsn| Uploads the last checkpoint from the
        quorum and returns the LSN of the record from which the changes
        should be applied.

@parm   IN HLOG | hQuoLog | the log file handle.

@parm   OUT LSN *| pStartScanLsn | Returns the LSN of the record in the
        quorum log from which changes must be applied is returned here.
        NULL_LSN is returned if no changes need to be applied.

@parm   IN OUT  LPDWORD | *pdwSequence | Should be set to the current sequence
        number is the cluster registry.  If a new chkpoint is uploaded, the
        sequence number corresponding to that is returned.

@rdesc  Returns ERROR_SUCCESS if a valid LSN is returned. This may be NULL_LSN.
        Returns the error code if the database cannot be uploaded from the last chkpoint
        or if something horrible happens.

@comm   This finds the last valid check point in the log file.  The data
        base is synced with this checkpoint and the gum sequence number is
        set to one plus the sequence number of that checkpoint.  If no
        checkpoint record is found, a checkpoint is taken and NULL_LSN is
        returned.

@xref
****/
DWORD DmpLogFindStartLsn(
    IN HLOG hQuoLog,
    OUT LSN *pStartScanLsn,
    IN OUT LPDWORD pdwSequence)
{
    LSN                 ChkPtLsn;
    LSN                 StartScanLsn;
    DWORD               dwChkPtSequence=0;
    DWORD               dwError = ERROR_SUCCESS;
    WCHAR               szChkPtFileName[LOG_MAX_FILENAME_LENGTH];
    DM_LOGSCAN_CONTEXT  DmAppliedChangeContext;

    *pStartScanLsn = NULL_LSN;
    ChkPtLsn = NULL_LSN;
    //read the last check point record if any and the transaction id till that
    //checkpoint
    dwError = LogGetLastChkPoint(hQuoLog, szChkPtFileName, &dwChkPtSequence,
        &ChkPtLsn);
    if (dwError != ERROR_SUCCESS)
    {
        //no chk point record found
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogFindStartLsn: LogGetLastChkPoint failed, error=0x%1!08lx!\r\n",
            dwError );

        // this can happen either due to the fact that the log file was just created,
        // and hence there is no checkpoint or because log file was messed up
        // and the mount process corrected it but removed the checkpoint.
        // If it is the second case, then logpmountlog should put something in the
        // event log
        if (dwError == ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND)
        {
            //
            //  Chittur Subbaraman (chitturs) - 6/3/99
            //  
            //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
            //  so as to maintain the ordering between this lock and the log lock.
            //
            ACQUIRE_SHARED_LOCK(gLockDmpRoot);

            //take a checkpoint, so that this doesnt happen the next time
            dwError = LogCheckPoint(hQuoLog, TRUE, NULL, 0);

            RELEASE_LOCK(gLockDmpRoot);
            
            if (dwError != ERROR_SUCCESS)
            {
                //check point could not be taken
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmpLogFindStartLsn: Checkpoint on first form failed, error=0x%1!08lx!\r\n",
                    dwError );
                goto FnExit;
            }
        }
        else
        {
            //there were other errors
            goto FnExit;
        }
    }
    else
    {
        //found check point record
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogFindStartLsn: LogGetLastChkPt rets, Seq#=%1!d! ChkPtLsn=0x%2!08lx!\r\n",
            dwChkPtSequence, ChkPtLsn);

        //
        //  Chittur Subbaraman (chitturs) - 10/18/98
        //
        //  If the user is forcing a database restore from backup, then
        //  do not check whether the current sequence number in the registry
        //  is younger than the checkpoint sequence number in the quorum log.
        //  Just, go ahead and load the checkpoint from restored database.
        //
        if ( CsDatabaseRestore == TRUE )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpLogFindStartLsn: User forcing a chkpt upload from quorum log...\r\n");
        }
        else 
        {
        
            //if the sequence number is greater than the check point sequence number
            //plus one, that implies..that only changes from that sequence number
            //need to be applied.(this node may not have been the first one to die)
            //We dont always apply the database because if logging is mostly off
            //and the two nodes die simultaneosly we want to prevent losing all the
            //changes
            //else if the checkpoint sequence is one below the current
            //current sequence number, then the locker node could have died after updating
            //get the current checkpoint irrespective of what the current sequence number is
            //this is because a checkpoint with the same sequence number may have
            //a change that is different from whats there in the current registry.
            //if node 'a'(locker and logger dies in the middle of logging trid=x+1,
            //the other node,'b' will take over logging and checkpoint the database
            //at trid=x.  If 'a' comes back up, it needs to throw aways its x+1 change
            //and apply changes from the log from chk pt x.

            if (*pdwSequence > (dwChkPtSequence + 1))
            {
                //the current sequence number is less than or equal to chkpt Seq + 1
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpLogFindStartLsn: ChkPt not applied, search for next seq\r\n");


                DmAppliedChangeContext.dwSequence = *pdwSequence;
                DmAppliedChangeContext.StartLsn = NULL_LSN;
                //find the LSN from which to apply changes
                if (dwError = LogScan(ghQuoLog, ChkPtLsn, TRUE,(PLOG_SCAN_CALLBACK)DmpLogFindStartLsnCb,
                    &DmAppliedChangeContext) != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpLogFindStartLsn: LogScan failed, no changes will be applied, error=0x%1!08lx!\r\n",
                        dwError);
                    goto FnExit;
                }
                *pStartScanLsn = DmAppliedChangeContext.StartLsn;
                goto FnExit;
            }
        } 

        //
        //  The current registry sequence number is less than or equal 
        //  to chkpt Seq + 1 OR the user is forcing a database restore
        //  from the backup area.
        //
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogFindStartLsn: Uploading chkpt from quorum log\r\n");


        //make sure that no keys are added to the key list because of opens/creates
        ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
        //hold the key lock as well
        EnterCriticalSection(&KeyLock);

        //invalidate all open keys
        DmpInvalidateKeys();
        
        if ((dwError = DmInstallDatabase(szChkPtFileName, NULL, FALSE)) != ERROR_SUCCESS)
        {
            //couldnt install the database
            //bad !
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogFindStartLsn: DmpInstallDatabase failed, error=0x%1!08lx!\r\n",
                dwError);
            CsLogEventData( LOG_CRITICAL,
                            DM_CHKPOINT_UPLOADFAILED,
                            sizeof(dwError),
                            &dwError );
            DmpReopenKeys();
            //release the locks            
            LeaveCriticalSection(&KeyLock);
            RELEASE_LOCK(gLockDmpRoot);
            goto FnExit;
        }
        else
        {
            //the current sequence number is less than or equal to chkpt Seq + 1
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpLogFindStartLsn: chkpt uploaded from quorum log\r\n");

            //since we downloaded the database, we should start
            //aplying changes from ChkPtLsn
            *pStartScanLsn = ChkPtLsn;
            *pdwSequence = dwChkPtSequence;
            //set the gum sequence number to be the next one
            //ss: the next logged transaction shouldnt have the same
            //transaction id
            GumSetCurrentSequence(GumUpdateRegistry, (dwChkPtSequence+1));
            //reopen the keys
            DmpReopenKeys();
            //release the locks            
            LeaveCriticalSection(&KeyLock);
            RELEASE_LOCK(gLockDmpRoot);
            goto FnExit;
        }
    }

FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpLogFindStartLsn: LSN=0x%1!08lx!, returning 0x%2!08lx!\r\n",
        *pStartScanLsn, dwError);

    return(dwError);
}

/****
@func       DWORD | DmpLogFindStartLsnCb| The callback tries to find the first record
            with a transaction id that is larger than the sequence number of the
            local database.

@parm       PVOID | pContext| A pointer to a DM_STARTLSN_CONTEXT structure.
@parm       LSN | Lsn| The LSN of the record.
@parm       RMID | Resource | The resource manager for this transaction.
@parm       RMID | ResourceType | The resource manager for this transaction.
@parm       TRID | Transaction | The transaction number of this record.
@parm       PVOID | pLogData | The log data for this record.
@parm       DWORD | DataLength | The length of the record.

@rdesc      Returns TRUE to continue scan.  FALSE to stop.

@comm       This function returns true if the sequence number of the record
            being scanned is higher than the seqence number passed in the context.

@xref       <f DmpLogFindStartLsn> <f LogScan>
****/
BOOL WINAPI DmpLogFindStartLsnCb(
    IN PVOID    pContext,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceFlags,
    IN TRID     Transaction,
    IN TRTYPE   TrType,
    IN const    PVOID pLogData,
    IN DWORD    DataLength)
{
    PDM_LOGSCAN_CONTEXT pDmStartLsnContext= (PDM_LOGSCAN_CONTEXT) pContext;


    CL_ASSERT(pDmStartLsnContext);
    if (Transaction > (int)pDmStartLsnContext->dwSequence)
    {
        pDmStartLsnContext->StartLsn = Lsn;
        return (FALSE);
    }

    return(TRUE);
}

/****
@func       DWORD | DmpHookQuorumNotify| This hooks a callback to be invoked whenever
            the state of the quorum resource changes.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This is used to monitor the state of
@xref
****/
DWORD DmpHookQuorumNotify()
{

    DWORD   dwError = ERROR_SUCCESS;

    if (dwError = FmFindQuorumResource(&gpQuoResource))
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster: FmFindQuorumResource failed, error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    dwError = OmRegisterNotify(gpQuoResource, NULL,
        NOTIFY_RESOURCE_POSTONLINE| NOTIFY_RESOURCE_PREOFFLINE |
        NOTIFY_RESOURCE_OFFLINEPENDING | NOTIFY_RESOURCE_POSTOFFLINE |
        NOTIFY_RESOURCE_FAILED,
        DmpQuoObjNotifyCb);

FnExit:
    return(dwError);
}


/****
@func       DWORD | DmpUnhookQuorumNotify| This unhooks the callback function
            that is registered with the object.

@parm       PVOID | pContext| A pointer to a DMLOGRECORD structure.
@parm       PVOID | pObject| A pointer to quorum resource object.
@parm       DWORD | dwNotification| A pointer to a DMLOGRECORD structure.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/

DWORD DmpUnhookQuorumNotify()
{
    DWORD dwError = ERROR_SUCCESS;

    if (gpQuoResource)
    {
        dwError = OmDeregisterNotify(gpQuoResource, DmpQuoObjNotifyCb);
        OmDereferenceObject(gpQuoResource);
    }
    return(ERROR_SUCCESS);
}


/****
@func       DWORD | DmpQuoObjNotifyCb| This is a callback that is called on
            change of state on quorum resource.

@parm       PVOID | pContext| A pointer to a DMLOGRECORD structure.
@parm       PVOID | pObject| A pointer to quorum resource object.
@parm       DWORD | dwNotification| A pointer to a DMLOGRECORD structure.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/

void DmpQuoObjNotifyCb(
    IN PVOID pContext,
    IN PVOID pObject,
    IN DWORD dwNotification)
{

    switch(dwNotification)
    {
    case NOTIFY_RESOURCE_POSTONLINE:
        gbIsQuoResOnline = TRUE;
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpQuoObjNotifyCb: Quorum resource is online\r\n");

        //if this is the owner of the quorum resource
        //and the log is not open, open the log
        if (AMIOWNEROFQUORES(gpQuoResource) && !CsNoQuorumLogging)
        {

            //ToDo: the quorum file name should be obtained from the setup
            //for now obtain the value from the cluster registry.
            PTEB    CurrentTeb;
            WCHAR   szQuorumFileName[MAX_PATH];
            LSN     FirstLsn;
            DWORD   dwError;
            DWORD   dwType;
            DWORD   dwLength;
            DWORD   dwMaxQuoLogSize;
            DWORD   bForceReset = FALSE;
            DWORD   OldHardErrorValue;

            //bug# :106647
            //SS: HACKHACK disabling hard error pop ups so that disk corruption
            //is caught somewhere else..
            //atleast the pop-ups must be disabled for the whole process !
            //me thinks this is covering up the problem of disk corruption
            //disk corruption should not occur!
            CurrentTeb = NtCurrentTeb();
            OldHardErrorValue = CurrentTeb->HardErrorsAreDisabled;
            CurrentTeb->HardErrorsAreDisabled = 1;

            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpQuoObjNotifyCb: Own quorum resource, try open the quorum log\r\n");

            if (DmGetQuorumLogPath(szQuorumFileName, sizeof(szQuorumFileName)) != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpQuoObjNotifyCb: Quorum log file is not configured\r\n");
            }
            else
            {
                BOOL                fSetSecurity = FALSE;
                HANDLE              hFindFile = INVALID_HANDLE_VALUE;
                WIN32_FIND_DATA     FindData;
                
                hFindFile = FindFirstFile( szQuorumFileName, &FindData ); 

                if ( hFindFile == INVALID_HANDLE_VALUE )
                {
                    dwError = GetLastError();
                    ClRtlLogPrint(LOG_NOISE,
                                 "[DM] DmpQuoObjNotifyCb: FindFirstFile on path %1!ws! failed, Error=%2!d! !!!\n",
                                 szQuorumFileName,
                                 dwError);                   
                    if ( dwError == ERROR_PATH_NOT_FOUND )
                    {
                        fSetSecurity = TRUE;
                    }
                } else
                {
                    FindClose( hFindFile );
                }

                //if the directory doesnt exist create it
                dwError = ClRtlCreateDirectory(szQuorumFileName);
                if (dwError != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[DM] DmpQuoObjNotifyCb: Failed to open quorum file: %1!ws!, error=0x%2!08lx!\r\n",
                        szQuorumFileName,
                        dwError);

                    CL_UNEXPECTED_ERROR(dwError);
                    CsInconsistencyHalt(dwError);
                }

                if ( fSetSecurity == TRUE )
                {
                    HANDLE              hFile;

                    ClRtlLogPrint(LOG_NOISE,
                                  "[DM] DmpQuoObjNotifyCb: Attempting to set security on directory %1!ws!...\r\n",
                                  szQuorumFileName);
        
                    //
                    //  Open the newly created directory object with rights to modify DACL 
                    //  in the object's SD.
                    //
                    hFile =  CreateFile( szQuorumFileName,
                                         GENERIC_READ | WRITE_DAC | READ_CONTROL, // for setting DACL
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_FLAG_BACKUP_SEMANTICS,              // for directory open
                                         NULL );

                    if ( hFile == INVALID_HANDLE_VALUE )
                    {
                        dwError = GetLastError();
                        ClRtlLogPrint(LOG_CRITICAL,
                                      "[DM] DmpQuoObjNotifyCb: Failed to open directory %1!ws!, Status=%2!u!...\r\n",
                                      szQuorumFileName,
                                      dwError);
                        CL_LOGFAILURE( dwError );
                        CsInconsistencyHalt( dwError );
                    }

                    //
                    //  Set DACL on the file handle object granting full rights only to admin 
                    //  and owner.
                    //
                    dwError = ClRtlSetObjSecurityInfo( hFile, 
                                                       SE_FILE_OBJECT,
                                                       GENERIC_ALL,      // for Admins
                                                       GENERIC_ALL,      // for Owner
                                                       0 );              // for Everyone

                    CloseHandle( hFile );

                    if ( dwError != ERROR_SUCCESS )
                    {
                        ClRtlLogPrint(LOG_CRITICAL,
                                      "[DM] DmpQuoObjNotifyCb: ClRtlSetObjSecurityInfo failed for file %1!ws!, Status=%2!u!\r\n",
                                      szQuorumFileName,
                                      dwError);
                        CL_LOGFAILURE( dwError );
                        CsInconsistencyHalt( dwError );
                    }
                }

                DmGetQuorumLogMaxSize(&dwMaxQuoLogSize);

                // If the resource monitor dies and comes back up, this can happen
                if (ghQuoLog != NULL)
                {
                    LogClose(ghQuoLog);
                    if (gbIsQuoLoggingOn) gbNeedToCheckPoint = TRUE;
                }
                //
                //  Chittur Subbaraman (chitturs) - 10/16/98
                //
                //  Check whether you need to restore the database from a
                //  user-supplied backup directory to the quorum disk. This
                //  restore operation is done only once when the Dm has
                //  not been fully initialized. Note that this function
                //  is called whenever the state of the quorum resource
                //  changes but the restore operation is only done once.
                //
                if ( ( gbDmInited == FALSE ) &&
                     ( CsDatabaseRestore == TRUE ) )
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: Beginning DB restoration from %1!ws!...\r\n",
                          CsDatabaseRestorePath);
                    if ( ( dwError = DmpRestoreClusterDatabase ( szQuorumFileName ) )
                            != ERROR_SUCCESS )
                    {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[DM] DmpQuoObjNotifyCb: DB restore operation from %1!ws! failed! Error=0x%2!08lx!\r\n",
                              CsDatabaseRestorePath,
                              dwError);
                        CL_LOGFAILURE( dwError );
                        CsDatabaseRestore = FALSE;
                        CsInconsistencyHalt( dwError );
                    }
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: DB restoration from %1!ws! successful...\r\n",
                          CsDatabaseRestorePath);
                    CL_LOGCLUSINFO( SERVICE_CLUSTER_DATABASE_RESTORE_SUCCESSFUL );
                }

                lstrcat(szQuorumFileName, cszQuoFileName);
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpQuoObjNotifyCb: the name of the quorum file is %1!ls!\r\n",
                      szQuorumFileName);

                // 
                // Chittur Subbaraman (chitturs) - 12/4/99
                //
                // If the quorum log file is found to be missing or corrupt,
                // reset it only under the following conditions, else
                // fail the log creation and halt the node.
                //
                // (1) A freshly formed cluster,
                // (2) The user has chosen to reset the log since the user
                //     does not have a backup.
                // (3) After the quorum resource has successfully come
                //     online on this node and the DM has been initialized
                //     successfully. This is because the sanity of the
                //     quorum log file has already been verified at
                //     initialization and the chances of the quorum log
                //     missing or getting corrputed after that are not
                //     so high (due to it being held open by the cluster
                //     service) and so it is not worth halting the node 
                //     during run-time.
                //
                if ((CsFirstRun && !CsUpgrade) || 
                    (CsResetQuorumLog) || 
                    (gbDmInited == TRUE))
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: Will try to reset Quorum log if file not found or if corrupt\r\n");
                    bForceReset = TRUE;
                }                    
                //  open the log file
                ghQuoLog = LogCreate(szQuorumFileName, dwMaxQuoLogSize,
                        (PLOG_GETCHECKPOINT_CALLBACK)DmpGetSnapShotCb, NULL,
                        bForceReset, &FirstLsn);

                if (!ghQuoLog)
                {
                    dwError = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpQuoObjNotifyCb: Quorum log could not be opened, error = 0x%1!08lx!\r\n",
                        dwError);
                    CL_LOGFAILURE(dwError);
                    CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
                }
                else
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: Quorum log opened\r\n");
                }
                if (gbNeedToCheckPoint && ghQuoLog)
                {
                    //take a checkpoint and set the flag to FALSE.
                    gbNeedToCheckPoint = FALSE;
                    //get a checkpoint database
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb - taking a checkpoint\r\n");
                    //
                    //  Chittur Subbaraman (chitturs) - 6/3/99
                    //  
                    //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
                    //  so as to maintain the ordering between this lock and the log lock.
                    //
                    ACQUIRE_SHARED_LOCK(gLockDmpRoot);
    
                    dwError = LogCheckPoint(ghQuoLog, TRUE, NULL, 0); 

                    RELEASE_LOCK(gLockDmpRoot);
                    
                    if (dwError != ERROR_SUCCESS)
                    {
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[DM] DmpEventHandler - Failed to take a checkpoint in the log file, error = 0x%1!08lx!\r\n",
                            dwError);
                        CL_UNEXPECTED_ERROR(dwError);
                        CsInconsistencyHalt(dwError);
                    }

                }
                //if the checkpoint timer doesnt already exist
                //check if the timer has already been created - we might
                // get two post online notifications
                //and dont cause a timer leak
                if (!ghCheckpointTimer)
                {
                    ghCheckpointTimer = CreateWaitableTimer(NULL, FALSE, NULL);

                    if (!ghCheckpointTimer)
                    {
                        CL_UNEXPECTED_ERROR(dwError = GetLastError());
                    }
                    else
                    {

                        DWORD dwCheckpointInterval;
                        
                        dwError = DmpGetCheckpointInterval(&dwCheckpointInterval);
                        CL_ASSERT(dwError == ERROR_SUCCESS);

                        //add a timer to take periodic checkpoints 
                        AddTimerActivity(ghCheckpointTimer, dwCheckpointInterval, 
                            1, DmpCheckpointTimerCb, &ghQuoLog);
                    }
                }                    
            }
            //SS:completion of hack, revert to enabling pop-ups
            CurrentTeb->HardErrorsAreDisabled = OldHardErrorValue;

        }
        if (ghQuoLogOpenEvent)
        {
            //this is the first notification after the form
            //allow the initialization to continue after rolling
            //back the changes
            SetEvent(ghQuoLogOpenEvent);
        }
        break;


    case NOTIFY_RESOURCE_FAILED:
    case NOTIFY_RESOURCE_PREOFFLINE:
    case NOTIFY_RESOURCE_OFFLINEPENDING:
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpQuoObjNotifyCb: Quorum resource offline/offlinepending/preoffline\r\n");
        gbIsQuoResOnline = FALSE;
        if (ghQuoLog)
        {
            //stop the checkpoint timer
            if (ghCheckpointTimer)
            {
                RemoveTimerActivity(ghCheckpointTimer);
                ghCheckpointTimer = NULL;
            }                
            LogClose(ghQuoLog);
            ghQuoLog = NULL;
            //dont try and log after this
            gbIsQuoLoggingOn = FALSE;
        }
        if (ghQuoLogOpenEvent)
        {
            //this is the first notification after the form
            //allow the initialization to continue after rolling
            //back the changes
            SetEvent(ghQuoLogOpenEvent);
        }

        break;

    }
}

/****
@func       DWORD | DmpHookEventHandler| This hooks a callback to be invoked whenever
            the state of the quorum resource changes.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This is used to monitor the state of nodes and turn quorum logging on or off.
@xref
****/
DWORD DmpHookEventHandler()
{
    DWORD   dwError;

    dwError = EpRegisterEventHandler(CLUSTER_EVENT_ALL,DmpEventHandler);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmHookEventHandler: EpRegisterEventHandler failed, error=0x%1!08lx!\r\n",
            dwError);
        CL_UNEXPECTED_ERROR( dwError );
    }

    return(dwError);
}



/****
@func       DWORD | DmpEventHandler| This routine handles events for the Cluster
            Database Manager.

@parm       CLUSTER_EVENT | Event | The event to be processed. Only one event at a time.
            If the event is not handled, return ERROR_SUCCESS.

@parm       PVOID| pContext | A pointer to context associated with the particular event.

@rdesc      Returns ERROR_SUCCESS else a Win32 error code on other errors.

@comm       This is used to monitor the state of nodes and turn quorum logging on or off.
@xref
****/
DWORD WINAPI DmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID pContext
    )
{
    DWORD   dwError=ERROR_SUCCESS;
    BOOL    bAreAllNodesUp;

    switch ( Event ) {
    case CLUSTER_EVENT_NODE_UP:
        bAreAllNodesUp = TRUE;
        if ((dwError = OmEnumObjects(ObjectTypeNode, DmpNodeObjEnumCb, &bAreAllNodesUp, NULL))
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM]DmpEventHandler : OmEnumObjects returned, error=0x%1!08lx!\r\n",
                dwError);

        }
        else
        {
            if (bAreAllNodesUp)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpEventHandler - node is up, turning quorum logging off\r\n");

                gbIsQuoLoggingOn = FALSE;
            }
        }
        break;

    case CLUSTER_EVENT_NODE_DOWN:
        if (!gbIsQuoLoggingOn)
        {
            HANDLE  hThread = NULL;
            DWORD   dwThreadId;

            //
            //  Chittur Subbaraman (chitturs) - 7/23/99
            //
            //  Create a new thread to handle the checkpointing on a 
            //  node down. This is necessary since we don't want the
            //  DM node down handler to be blocked in any fashion. If
            //  it is blocked since FmCheckQuorumState couldn't get the 
            //  quorum group lock and some other thread got the group 
            //  lock and is waiting for the GUM lock, then we have 
            //  an immediate deadlock. Only after this node down 
            //  handler finishes, any subsequent future node down
            //  processing can be started.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpEventHandler - Node is down, turn quorum logging on...\r\n");

            gbIsQuoLoggingOn = TRUE;
            
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpEventHandler - Create thread to handle node down event...\r\n");
  
            hThread = CreateThread( NULL, 
                                    0, 
                                    DmpHandleNodeDownEvent,
                                    NULL, 
                                    0, 
                                    &dwThreadId );

            if ( hThread == NULL )
            {
                dwError = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmpEventHandler - Unable to create thread to handle node down event. Error=0x%1!08lx!\r\n",
                dwError);
                CsInconsistencyHalt( dwError );
            }
        
            CloseHandle( hThread );
        }

        break;

    case CLUSTER_EVENT_NODE_CHANGE:
        break;

    case CLUSTER_EVENT_NODE_ADDED:
        break;

    case CLUSTER_EVENT_NODE_DELETED:
        break;

    case CLUSTER_EVENT_NODE_JOIN:
        break;


    }
    return(dwError);

} // DmpEventHandler


/****
@func       DWORD | DmpNodeObjEnumCb| This is a callback that is called when node
            objects are enumberate by the dm.

@parm       PVOID | pContext| A pointer to a DMLOGRECORD structure.
@parm       PVOID | pObject| A pointer to quorum resource object.
@parm       DWORD | dwNotification| A pointer to a DMLOGRECORD structure.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/
BOOL DmpNodeObjEnumCb(IN BOOL *pbAreAllNodesUp, IN PVOID pContext2,
    IN PVOID pNode, IN LPCWSTR szName)
{

    if ((NmGetNodeState(pNode) != ClusterNodeUp) &&
        (NmGetNodeState(pNode) != ClusterNodePaused))
        *pbAreAllNodesUp = FALSE;
    //if any of the nodes is down fall out
    return(*pbAreAllNodesUp);
}

/****
@func       BOOL | DmpGetSnapShotCb| This callback is invoked when the logger
                        is asked to take a checkpoint record for the cluster registry.

@parm       PVOID| pContext | The checkpoint context passed into LogCreate.

@parm       LPWSTR | szChkPtFile | The name of the file in which to take a checkpoint.

@parm       LPDWORD | pdwChkPtSequence | The sequence number related with this
            checkpoint is returned in this.

@rdesc      Returns a result code. ERROR_SUCCESS on success.  If the file corresponding
            to this checkpoint already exists, it will return ERROR_ALREADY_EXISTS and
            szChkPtFile will be set to the name of the file.

@comm       LogCheckPoint() calls this function when the log manager is asked to checkpoint the
            dm database.

@xref
****/

DWORD WINAPI DmpGetSnapShotCb(IN LPCWSTR szPathName, IN PVOID pContext,
    OUT LPWSTR szChkPtFile, OUT LPDWORD pdwChkPtSequence)
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szFilePrefix[MAX_PATH] = L"chkpt";
    WCHAR   szTempFile[MAX_PATH] = L"";

    ACQUIRE_SHARED_LOCK( gLockDmpRoot );

    szChkPtFile[0] = L'\0';

    //
    //  Chittur Subbaraman (chitturs) - 5/1/2000
    //
    //  Checkpoint file name is based on registry sequence number. It is possible that two
    //  or more consecutive calls to this function to take checkpoints may read the same
    //  registry sequence number. Thus, if DmGetDatabase fails for some reason, it is possible
    //  that an existing checkpoint file will get corrupted. Thus, even though the quorum log
    //  marks a 'start checkpoint record' and an 'end checkpoint record', it could turn out
    //  to be useless if this function manages to corrupt an existing checkpoint file. To solve
    //  this problem, we first generate a temp file, take a cluster hive snapshot as this temp
    //  file, then atomically move the temp file to the final checkpoint file using the MoveFileEx
    //  function.
    //

    //
    //  Create a new unique temp file name
    //
    if ( !GetTempFileNameW( szPathName, szFilePrefix, 0, szTempFile ) )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] DmpGetSnapShotCb: Failed to generate a temp file name, PathName=%1!ls!, FilePrefix=%2!ls!, Error=0x%3!08lx!\r\n",
            szPathName, szFilePrefix, dwError);
        goto FnExit;
    }

    dwError = DmCommitRegistry();         // Ensure up-to-date snapshot

    if ( dwError != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[LM] DmpGetSnapShotCb: DmCommitRegistry() failed, Error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    dwError = DmGetDatabase( DmpRoot, szTempFile );

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpGetSnapShotCb: DmpGetDatabase returned 0x%1!08lx!\r\n",
        dwError);

    if ( dwError == ERROR_SUCCESS )
    {
        *pdwChkPtSequence = DmpGetRegistrySequence();

        //
        // Create a checkpoint file name based on the registry sequence number
        //
        if ( !GetTempFileNameW( szPathName, szFilePrefix, *pdwChkPtSequence, szChkPtFile ) )
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] DmpGetSnapShotCb: Failed to generate a chkpt file name, PathName=%1!ls!, FilePrefix=%2!ls!, Error=0x%3!08lx!\r\n",
                szPathName, szFilePrefix, dwError);
            //
            // Reset the file name to null, as this information will be used to determine
            // if the checkpoint was taken
            //
            szChkPtFile[0] = L'\0';
            goto FnExit;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[LM] DmpGetSnapshotCb: Checkpoint file name=%1!ls! Seq#=%2!d!\r\n",
            szChkPtFile, *pdwChkPtSequence);

        if ( !MoveFileEx( szTempFile, szChkPtFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH ) )
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] DmpGetSnapShotCb: Failed to move the temp file to checkpoint file, TempFileName=%1!ls!, ChkPtFileName=%2!ls!, Error=0x%3!08lx!\r\n",
                szTempFile, szChkPtFile, dwError);
            //
            // Reset the file name to null, as this information will be used to determine
            // if the checkpoint was taken
            //
            szChkPtFile[0] = L'\0';
            goto FnExit;
        }
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);

    if ( dwError != ERROR_SUCCESS )
    {
        DeleteFileW( szTempFile );
    }
    return ( dwError );
}

/****
@func       BOOL WINAPI | DmpLogApplyChangesCb| This callback walks through the records in
            the quorum logs and applies changes to the local database.

@parm       PVOID | pContext | The event to be processed. Only one event at a time.
            If the event is not handled, return ERROR_SUCCESS.

@parm       LSN | Lsn | Lsn of the record.

@parm       RMID | Resource | The resource id of the entity that logged this record.

@parm       RMTYPE | ResourceType | The record type that is specific to the resource id.

@parm       TRID | Transaction | The sequence number of the transaction.

@parm       const PVOID | pLogData | A pointer to the record data.

@parm       DWORD | DataLength | The length of the data in bytes.

@rdesc      Returns TRUE to continue scan else returns FALSE.

@comm       This function is called at initialization when a cluster is being formed to apply
            transactions from the quorum log to the local cluster database.
@xref
****/

BOOL WINAPI DmpLogApplyChangesCb(
    IN PVOID    pContext,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceType,
    IN TRID     Transaction,
    IN TRTYPE   TransactionType,
    IN const    PVOID pLogData,
    IN DWORD    DataLength)
{

    DWORD               Status;
    PDM_LOGSCAN_CONTEXT pDmAppliedChangeContext = (PDM_LOGSCAN_CONTEXT) pContext;
    TRSTATE             trXsactionState;
    BOOL                bRet = TRUE;

    CL_ASSERT(pDmAppliedChangeContext);
    //if the resource id is not the same as dm..ignore..go to the next one

    switch(TransactionType)
    {
        case TTStartXsaction:
            Status = LogFindXsactionState(ghQuoLog, Lsn, Transaction, &trXsactionState);
            if (Status != ERROR_SUCCESS)
            {
                //there was an error
                ClRtlLogPrint(LOG_NOISE, "[DM] DmpLogApplyChangesCb ::LogFindXsaction failed, error=0x%1!08lx!\r\n",
                Status);
                //assume unknown state
                CL_LOGFAILURE(Status);
                trXsactionState = XsactionUnknown;
            }
            //if the transaction is successful apply it, else continue
            if (trXsactionState == XsactionCommitted)
            {
                Status = LogScanXsaction(ghQuoLog, Lsn, Transaction, DmpApplyTransactionCb,
                    NULL);
                if (Status != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpLogApplyChangesCb :LogScanTransaction for committed record failed, error=0x%1!08lx!\r\n",
                        Status);
                    bRet = FALSE;
                    CL_LOGFAILURE(Status);
                    break;
                }
                pDmAppliedChangeContext->dwSequence = Transaction;
            }
            else
            {
                ClRtlLogPrint(LOG_NOISE, "[DM] TransactionState = %1!u!\r\n",
                    trXsactionState);
            }
            break;


        case TTCompleteXsaction:
            bRet = DmpApplyTransactionCb(NULL, Lsn, Resource, ResourceType,
                Transaction, pLogData, DataLength);
            pDmAppliedChangeContext->dwSequence = Transaction;
            break;

        default:
            CL_ASSERT(FALSE);

    }

    return(bRet);

}


BOOL WINAPI DmpApplyTransactionCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         TransactionId,
    IN const PVOID  pLogData,
    IN DWORD        dwDataLength)
{
    DWORD   Status;

    switch(ResourceType)
    {

        case DmUpdateCreateKey:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmpLogScanCb::DmUpdateCreateKey\n");
            //SS: we dont care at this point as to where the update originated
            Status = DmpUpdateCreateKey(FALSE,
                                        GET_ARG(pLogData,0),
                                        GET_ARG(pLogData,1),
                                        GET_ARG(pLogData,2));
            break;

        case DmUpdateDeleteKey:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteKey \n");
            Status = DmpUpdateDeleteKey(FALSE,
                        (PDM_DELETE_KEY_UPDATE)((PBYTE)pLogData));
            break;

        case DmUpdateSetValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateSetValue \n");
            Status = DmpUpdateSetValue(FALSE,
                        (PDM_SET_VALUE_UPDATE)((PBYTE)pLogData));
            break;

        case DmUpdateDeleteValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteValue\n");
            Status = DmpUpdateDeleteValue(FALSE,
                        (PDM_DELETE_VALUE_UPDATE)((PBYTE)pLogData));
            break;

        case DmUpdateJoin:
            ClRtlLogPrint(LOG_UNUSUAL,"[DM] DmUpdateJoin\n");
            Status = ERROR_SUCCESS;
            break;

        default:
            ClRtlLogPrint(LOG_UNUSUAL,"[DM] DmpLogScanCb:uType = %1!u!\r\n",
                ResourceType);
            Status = ERROR_INVALID_DATA;
            CL_UNEXPECTED_ERROR(ERROR_INVALID_DATA);
            break;

    }
    return(TRUE);
}

/****
@func       WORD| DmpLogCheckPtCb| A callback fn for DM
            to take a checkpoint to the log if the quorum
            resource is online on this node.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       This callback is called when the quorum resource
            is online on this node.  Since the quorum resource
            synchronous callbacks are called before the resource 
            state changes are propagated, if the quorum is online
            the log must be open.
            
@xref
****/
void DmpLogCheckPointCb()
{
    DWORD dwError;

    //
    //  Chittur Subbaraman (chitturs) - 9/22/99
    //
    //  If the quorum logging switch is off, don't do anything.
    //
    if (CsNoQuorumLogging) return;
    
    //once it is online the log file should be open
    //SS:BUGS: should we log something in the eventlog
    if (ghQuoLog)
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/3/99
        //  
        //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
        //  so as to maintain the ordering between this lock and the log lock.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);

        //get a checkpoint database
        dwError = LogCheckPoint(ghQuoLog, TRUE, NULL, 0);

        RELEASE_LOCK(gLockDmpRoot);
        
        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpLogCheckPointCb - Failed to take a checkpoint in the log file, error=0x%1!08lx!\r\n",
                dwError);
            CL_UNEXPECTED_ERROR(dwError);
        }
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogCheckPointCb - taken checkpoint\r\n");
    }
    else 
    {
        CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
    }

    
}

/****
@func       WORD| DmGetQuorumLogPath| Reads the quorum log file path configured in
            the registry during setup.

@parm       LPWSTR | szQuorumLogPath | A pointer to a wide string of size MAX_PATH.
@parm       DWORD | dwSize | The size of szQuorumLogPath in bytes.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD DmGetQuorumLogPath(LPWSTR szQuorumLogPath, DWORD dwSize)
{
    DWORD Status;
    
    Status = DmQuerySz( DmQuorumKey,
                        cszPath,
                        &szQuorumLogPath,
                        &dwSize,
                        &dwSize);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmGetQuorumLogPath failed, error=%1!u!\n", Status);
        goto FnExit;
    }

FnExit:    
    return(Status);
}

/****
@func       WORD| DmpGetCheckpointInterval| Reads the checkpoint interval
            from the registry, else returns the default.

@parm       LPDWORD | pdwCheckpointInterval | A pointer to DWORD where 
            the checkpoint interval, in secs, is returned.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       The default checkpoint interval is 4 hours.  The registry must be configured
            in units of hours.
@xref
****/
DWORD DmpGetCheckpointInterval(
    OUT LPDWORD pdwCheckpointInterval)
{
    DWORD dwDefCheckpointInterval = DEFAULT_CHECKPOINT_INTERVAL;
    DWORD dwStatus = ERROR_SUCCESS;
    
    dwStatus = DmQueryDword( DmQuorumKey,
                        CLUSREG_NAME_CHECKPOINT_INTERVAL,
                        pdwCheckpointInterval,
                        &dwDefCheckpointInterval);

    if (dwStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmGetCheckpointInterval Failed, error=%1!u!\n",
            dwStatus);
        goto FnExit;            
    }
    //the checkpoint interval cant be less than 1 hour or more than 1 day
    if ((*pdwCheckpointInterval  < 1) || (*pdwCheckpointInterval>24)) 
        *pdwCheckpointInterval = DEFAULT_CHECKPOINT_INTERVAL;

    //convert to msecs
    *pdwCheckpointInterval = *pdwCheckpointInterval * 60 * 60 * 1000;

FnExit:
    return(dwStatus);
}


/****
@func       WORD| DmGetQuorumLogMaxSize| Reads the quorum log file max size.

@parm       LPDWORD | pdwMaxLogSize| A pointer to a dword containing the size.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD DmGetQuorumLogMaxSize(LPDWORD pdwMaxLogSize)
{
    DWORD Status;
    DWORD dwDefaultLogMaxSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;

    Status = DmQueryDword( DmQuorumKey,
                        cszMaxQuorumLogSize,
                        pdwMaxLogSize,
                        &dwDefaultLogMaxSize);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmGetQuorumLogMaxSize failed, error=%1!u!\n",Status);
    }

    return(Status);
}


/****
@func           DWORD | DmpCheckDiskSpace| Called to check for the disk space
            on the quorum resource after it is brought online and logs are rolled up.

@rdesc          ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm           This function checks if there is enough disk space and sets up
            a periodic timer to monitor the disk space.

@xref           <f DmpDiskManage>
****/
DWORD DmpCheckDiskSpace()
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szQuoLogPathName[MAX_PATH];
    ULARGE_INTEGER   liNumTotalBytes;
    ULARGE_INTEGER   liNumFreeBytes;

    //if you own the quorum resource, try to check the size
    if (gpQuoResource && AMIOWNEROFQUORES(gpQuoResource) && gbIsQuoResOnline)
    {
        //get the path
        if ((dwError = DmGetQuorumLogPath(szQuoLogPathName, sizeof(szQuoLogPathName)))
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpCheckDiskSpace: Quorum log file is not configured, error=%1!u!\r\n",
                dwError);
            //log something in the event log
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }
        
        //check the minimum space on the quorum disk
        if (!GetDiskFreeSpaceEx(szQuoLogPathName, &liNumFreeBytes, &liNumTotalBytes,
            NULL))
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpCheckDiskSpace: GetDiskFreeSpace returned error=0x%1!08lx!\r\n",
                dwError);
            goto FnExit;
        }

        //if not available, log something in the event log and bail out
        if ((liNumFreeBytes.HighPart == 0) &&
            (liNumFreeBytes.LowPart < DISKSPACE_INIT_MINREQUIRED))
        {
            CL_LOGCLUSWARNING(LM_DISKSPACE_HIGH_WATERMARK);
            dwError = ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
            goto FnExit;
        }

    }


FnExit:
    return(dwError);
}


/****
@func       DWORD | DmpDiskManage | This is the callback registered to perform
            periodic disk check functions on the quorum resource.

@comm       If the disk space has dipped below the lowwatermark, this gracefully
            shuts the cluster service. If the disk space dips below the high
            watermark, it sends an alert to registered recipients.

@xref       <f DmpCheckDiskSpace>
****/
void WINAPI DmpDiskManage(
    IN HANDLE hTimer,
    IN PVOID pContext)
{
    DWORD           dwError;
    WCHAR           szQuoLogPathName[MAX_PATH];
    ULARGE_INTEGER  liNumTotalBytes;
    ULARGE_INTEGER  liNumFreeBytes;
    static DWORD    dwNumWarnings=0;

    
    if (!gpQuoResource || (!AMIOWNEROFQUORES(gpQuoResource)) ||
        (!gbIsQuoResOnline || (CsNoQuorumLogging)))
    {
        //the owner of the quorum resource checks the disk space
        //the quorum disk shouldnt go offline
        //skip checking if no quorum logging is required
        return;
    }
    //get the path
    if ((dwError = DmGetQuorumLogPath(szQuoLogPathName, sizeof(szQuoLogPathName)))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpDiskManage: Quorum log file is not configured, error=%1!u!\r\n",
            dwError);
        //log something in the event log
        CL_UNEXPECTED_ERROR(dwError);
        goto FnExit;
    }

    //check the minimum space on the quorum disk
    if (!GetDiskFreeSpaceEx(szQuoLogPathName, &liNumFreeBytes, &liNumTotalBytes,
        NULL))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpDiskManage: GetDiskFreeSpace returned error=0x%1!08lx!\r\n",
            dwError);
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    if ((liNumFreeBytes.HighPart == 0) &&
        (liNumFreeBytes.LowPart < DISKSPACE_LOW_WATERMARK))
    {
        //reached the low water mark
        dwNumWarnings++;
        //ss: we can control the rate at which we put things in the
        //event log but once every five minutes is not bad.
        //ss: post an event ???
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpDiskManage: GetDiskFreeSpace - Not enough disk space, Avail=0x%1!08lx!\r\n",
            liNumFreeBytes.LowPart);
        CL_LOGCLUSWARNING(LM_DISKSPACE_LOW_WATERMARK);
    }
    else
    {
        gbIsQuoResEnoughSpace = TRUE;
        dwNumWarnings = 0;
    }
FnExit:
    return;
}


/****
@func       DWORD | DmpCheckpointTimerCb | This is the callback registered to perform
            periodic checkpointing on the quorum log.

@parm       IN HANDLE| hTimer| The timer associated with checkpointing interval.

@parm       IN PVOID | pContext | A pointer to the handle for the quorum log file.

@comm       This helps in backups.  If you want to take a cluster backup by making
            a copy of the quorum.log and checkpoint files, then if both nodes have
            been up for a long time both the files can be old.  By taking a periodic
            checkpoint we guarantee that they are not more than n hours old.

****/
void WINAPI DmpCheckpointTimerCb(
    IN HANDLE hTimer,
    IN PVOID pContext)
{

    HLOG    hQuoLog;
    DWORD   dwError;
    
    hQuoLog = *((HLOG *)pContext);

    if (hQuoLog && gbDmInited)
    {

        //get a checkpoint database
        ClRtlLogPrint(LOG_NOISE,
            "[DM]DmpCheckpointTimerCb- taking a checkpoint\r\n");
        //
        //  Chittur Subbaraman (chitturs) - 6/3/99
        //  
        //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
        //  so as to maintain the ordering between this lock and the log lock.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);
        
        dwError = LogReset(hQuoLog);

        RELEASE_LOCK(gLockDmpRoot);
        
        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM]DmpCheckpointTimerCb - Failed to reset log, error=%1!u!\r\n",
                dwError);
            CL_UNEXPECTED_ERROR(dwError);
        }
    }
}

/****
@func       DWORD | DmBackupClusterDatabase | Take a fresh checkpoint and 
            copy the quorum log and the checkpoint file to the supplied 
            path name. This function is called with gQuoLock held.

@parm       IN LPCWSTR | lpszPathName | The directory path name where the 
            files have to be backed up. This path must be visible to the 
            node on which the quorum resource is online (i.e., this node
            in this case).

@comm       This function first takes a fresh checkpoint, updates the quorum
            log file and then copies the two files to a backup area.

@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@xref       <f DmpLogCheckpointAndBackup> <f DmpRestoreClusterDatabase>
****/
DWORD DmBackupClusterDatabase(
    IN LPCWSTR  lpszPathName)
{
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    DWORD               status = ERROR_SUCCESS;
    LPWSTR              szDestPathName = NULL;
    DWORD               dwLen;

    //
    //  Chittur Subbaraman (chitturs) - 10/12/98
    //
    dwLen = lstrlenW( lpszPathName ); 

    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szDestPathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 5 ) *
                                 sizeof ( WCHAR ) );

    if ( szDestPathName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBackupClusterDatabase: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              lpszPathName); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }

    lstrcpyW( szDestPathName, lpszPathName );
    //
    //  If the client-supplied path is not already terminated with '\', 
    //  then add it.
    //
    if ( szDestPathName [dwLen-1] != L'\\' )
    {
        szDestPathName [dwLen++] = L'\\';
    }
    //
    //  Add a wild character at the end to search for any file in the
    //  supplied directory
    //
    szDestPathName[dwLen++] = L'*';
    szDestPathName[dwLen] = L'\0';

    //
    //  Find out whether you can access the supplied path by
    //  trying to find some file in the directory.
    //
    hFindFile = FindFirstFile( szDestPathName, &FindData ); 
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBackupClusterDatabase: Supplied path %1!ws! does not exist, Error=%2!d! !!!\n",
                szDestPathName,
                status);  
        goto FnExit;
    }
    //
    //  Check whether the log is open. It must be since we already 
    //  verified that the quorum resource is online on this node and
    //  quorum logging is turned on.
    //
    if ( ghQuoLog )
    {
        //
        //  Remove the '*' so the same variable can be used.
        //
        szDestPathName [dwLen-1] = L'\0';
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBackupClusterDatabase: Attempting to take a checkpoint and then backup to %1!ws!..\n",
            szDestPathName); 

        //
        //  The gLockDmpRoot needs to be acquired here since otherwise
        //  you will get the log lock in the LogCheckPoint( )
        //  function and someone else could get the gLockDmpRoot. 
        //  After you get the log lock, you also try to acquire 
        //  the gLockDmpRoot in the function DmCommitRegistry. 
        //  This is a potential deadlock situation and is avoided here.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);
        status = DmpLogCheckpointAndBackup ( ghQuoLog, szDestPathName );
        RELEASE_LOCK(gLockDmpRoot);

        if ( status == ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmBackupClusterDatabase: Successfully finished backing up to %1!ws!...\n",
                szDestPathName);
        }
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmBackupClusterDatabase: Quorum log could not be opened...\r\n");
        status = ERROR_QUORUMLOG_OPEN_FAILED;
    }

FnExit:
    if ( hFindFile != INVALID_HANDLE_VALUE ) 
    {
        FindClose ( hFindFile );
    }
    LocalFree ( szDestPathName );
    return ( status );
}

/****
@func   DWORD | DmpLogCheckpointAndBackup | Takes a checkpoint, updates the
        quorum log and then copies the files to the supplied path. This
        function is called with the gQuoLock and the gLockDmpRoot held.

@parm   IN HLOG | hLogFile | An identifier for the quorum log file.

@parm   IN LPWSTR | lpszPathName | The path for storing the quorum log
        file, the recent checkpoint file, and the resource registry
        checkpoint files. This path must be visible from this node.

@comm   Called by DmpBackupQuorumLog() to take a checkpoint and then
        take a backup of the cluster database including resource
        registry checkpoint files.
        
@rdesc  Returns a Win32 error code on failure. ERROR_SUCCESS on success.
        
@xref   <f DmBackupClusterDatabase> 
****/
DWORD DmpLogCheckpointAndBackup(
    IN HLOG     hLogFile,    
    IN LPWSTR   lpszPathName)
{
    DWORD   dwError;
    DWORD   dwLen;
    WCHAR   szChkPointFilePrefix[MAX_PATH];
    WCHAR   szQuoLogPathName[MAX_PATH];
    LPWSTR  szDestFileName = NULL;
    WCHAR   szSourceFileName[MAX_PATH];
    LPWSTR  szDestPathName = NULL;
    LPWSTR  lpChkPointFileNameStart;
    LSN     Lsn;
    TRID    Transaction;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    //
    //  Chittur Subbaraman (chitturs) - 10/12/1998
    //

    //
    //  Initiate a checkpoint process. Allow a log file reset, if necessary.
    //
    if ( ( dwError = LogCheckPoint( hLogFile, TRUE, NULL, 0 ) )
        != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Callback failed to return a checkpoint. Error=%1!u!\r\n",
            dwError);
        CL_LOGFAILURE( dwError );
        LogClose( hLogFile );
        goto FnExit;
    }

    //
    //  Get the name of the most recent checkpoint file
    //
    szChkPointFilePrefix[0] = TEXT('\0');
    if ( ( dwError = LogGetLastChkPoint( hLogFile, szChkPointFilePrefix, &Transaction, &Lsn ) )
        != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::No check point found in the log file. Error=%1!u!\r\n",
            dwError);
        CL_LOGFAILURE( dwError );
        LogClose( hLogFile );
        goto FnExit;
    }

    dwError = DmGetQuorumLogPath( szQuoLogPathName, sizeof( szQuoLogPathName ) );
    if ( dwError  != ERROR_SUCCESS )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::DmGetQuorumLogPath failed, Error = %1!d!\r\n",
              dwError);
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szDestPathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( lstrlenW ( lpszPathName ) + 1 ) *
                                   sizeof ( WCHAR ) );

    if ( szDestPathName == NULL )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogCheckpointAndBackup: Error %1!d! in allocating memory for %2!ws! !!!\n",
              dwError,
              lpszPathName); 
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Get the user-supplied destination path name
    //
    lstrcpyW( szDestPathName, lpszPathName );

    szDestFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( lstrlenW ( szDestPathName ) + 1 + LOG_MAX_FILENAME_LENGTH ) *
                                   sizeof ( WCHAR ) );

    if ( szDestFileName == NULL )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogCheckpointAndBackup: Error %1!d! in allocating memory for chkpt file name !!!\n",
              dwError); 
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Make an attempt to delete the CLUSBACKUP.DAT file
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, L"CLUSBACKUP.DAT" );
    //
    //  Set the file attribute to normal. Continue even if you 
    //  fail in this step, but log an error. (Note that you are
    //  countering the case in which a destination file with
    //  the same name exists in the backup directory already and
    //  you are trying to delete it.)
    //
    if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, Error = %2!d!\n",
                    szDestFileName,
                    dwError);
        }
    }
    
    if ( !DeleteFile( szDestFileName ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmpLogCheckpointAndBackup::CLUSBACKUP.DAT exists, but can't delete it, Error = %1!d!\n",
                   dwError);
            CL_LOGFAILURE( dwError );
            goto FnExit;   
        }  
    }
    //
    //  Just get the checkpoint file name without any path added.
    //  Note that szQuoLogPathName includes the '\'
    //
    dwLen = lstrlenW ( szQuoLogPathName );
    lpChkPointFileNameStart = &szChkPointFilePrefix[dwLen];  

    //
    //  Now, create the path-included destination file name
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, lpChkPointFileNameStart );

    //
    //  And, the path-included source file name
    //
    lstrcpyW( szSourceFileName,  szChkPointFilePrefix );

    //
    //  Set the file attribute to normal. Continue even if you 
    //  fail in this step, but log an error. (Note that you are
    //  countering the case in which a destination file with
    //  the same name exists in the backup directory already and
    //  you are trying to overwrite it.)
    //
    if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, Error = %2!d!\n",
                    szDestFileName,
                    dwError);
        }
    }

    //
    //  Copy the checkpoint file to the destination
    //
    dwError = CopyFileW( szSourceFileName, szDestFileName, FALSE );
    if ( !dwError ) 
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmpLogCheckpointAndBackup::Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                   szSourceFileName,
                   szDestFileName,
                   dwError);
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Set the file attribute to read-only. Continue even if you 
    //  fail in this step, but log an error. 
    //
    if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_READONLY ) )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to READONLY, Error = %2!d!\n",
                szDestFileName,
                dwError);    
    }
  
    //
    //  Now, create the path-included destination file name
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, cszQuoFileName );

    //
    //  And, the path-included source file name
    //
    lstrcpyW( szSourceFileName, szQuoLogPathName );
    lstrcatW( szSourceFileName, cszQuoFileName );

    //
    //  Set the destination file attribute to normal. Continue even if you 
    //  fail in this step, but log an error. (Note that you are
    //  countering the case in which a destination file with
    //  the same name exists in the backup directory already and
    //  you are trying to overwrite it.)
    //
    if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, Error = %2!d!\n",
                    szDestFileName,
                    dwError);
        }
    }

    //
    //  Copy the quorum log file to the destination
    //
    dwError = CopyFileW( szSourceFileName, szDestFileName, FALSE );
    if ( !dwError ) 
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmpLogCheckpointAndBackup::Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                   szSourceFileName,
                   szDestFileName,
                   dwError);
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Set the destination file attribute to read-only. Continue even 
    //  if you fail in this step, but log an error
    //
    if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_READONLY ) )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to READONLY, Error = %2!d!\n",
                szDestFileName,
                dwError);    
    }

    //
    //  Now copy the resource chkpt files to the destination. Note that
    //  we call this function with both gQuoLock and gLockDmpRoot held.
    //  The former lock prevents any checkpoint being read or written
    //  via CppReadCheckpoint() and CppWriteCheckpoint() while the
    //  following function is executing. 
    //
    //  Note: However, the CpDeleteRegistryCheckPoint() function is 
    //  unprotected and poses a potential danger here.
    //
    //  Note: Also, currently the following function returns ERROR_SUCCESS
    //  in all cases. 
    //
    dwError = CpCopyCheckpointFiles( szDestPathName, TRUE );
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Unable to copy resource checkpoint files, Error = %1!d!\n",
               dwError);
        goto FnExit;
    }

    //
    //  Now create an empty READONLY, HIDDEN, file in the destination 
    //  directory which marks the successful ending of the backup.
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, L"CLUSBACKUP.DAT");
    hFile = CreateFileW( szDestFileName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_NEW,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                              NULL );
                                  
    if ( hFile == INVALID_HANDLE_VALUE ) 
    {
        dwError = GetLastError();
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }
    
    dwError = ERROR_SUCCESS;

FnExit:
    LocalFree ( szDestFileName );
    LocalFree ( szDestPathName );
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle ( hFile );
    }
    return ( dwError );
}

/****
@func       DWORD | DmpRestoreClusterDatabase | Copy the quorum log and all the 
            checkpoint files from CsDatabaseRestorePath to the 
            quorum log path in the quorum disk.

@parm       IN LPCWSTR | lpszQuoLogPathName | The quorum directory path 
            where the backed up files have to be copied to. 
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@xref       <f CppRestoreCpFiles> <f DmBackupClusterDatabase>
****/
DWORD DmpRestoreClusterDatabase(
    IN LPCWSTR  lpszQuoLogPathName )
{
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    DWORD               status;
    WCHAR               szDestFileName[MAX_PATH];
    LPWSTR              szSourceFileName = NULL;
    LPWSTR              szSourcePathName = NULL;
    DWORD               dwLen;
    WCHAR               szChkptFileNameStart[4];
    WCHAR               szTempFileName[MAX_PATH];

    //
    //  Chittur Subbaraman (chitturs) - 10/20/98
    //
    dwLen = lstrlenW ( CsDatabaseRestorePath );
    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 25 ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpRestoreClusterDatabase: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              CsDatabaseRestorePath); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }
    
    lstrcpyW ( szSourcePathName,  CsDatabaseRestorePath );
  
    //
    //  If the client-supplied path is not already terminated with '\', 
    //  then add it.
    //
    if ( szSourcePathName [dwLen-1] != L'\\' )
    {
        szSourcePathName [dwLen++] = L'\\';
        szSourcePathName[dwLen] = L'\0';
    }

    lstrcatW ( szSourcePathName, L"CLUSBACKUP.DAT" );

    //
    //  Try to find the CLUSBACKUP.DAT file in the directory
    //
    hFindFile = FindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND )
        {
	  ClRtlLogPrint(LOG_NOISE,
	               "[DM] DmpRestoreClusterDatabase: Path %1!ws! unavailable, Error = %2!d! !!!\n",
			szSourcePathName,
			status); 
        } else
        {
            status = ERROR_DATABASE_BACKUP_CORRUPT;
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpRestoreClusterDatabase: Backup procedure not fully successful, can't restore DB, Error = %1!d! !!!\n",
                    status); 
        }
        CL_LOGFAILURE( status );
        goto FnExit;
    }
    FindClose ( hFindFile );
    
    szSourcePathName[dwLen++] = L'*';
    szSourcePathName[dwLen] = L'\0';

    //
    //  Try to find any file in the directory
    //
    hFindFile = FindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen-1] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpRestoreClusterDatabase: Error %2!d! in trying to find file in path %1!ws!\r\n",
                    szSourcePathName,
                    status); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }

    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( lstrlenW ( szSourcePathName ) + 1 + LOG_MAX_FILENAME_LENGTH ) *
                                 sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpRestoreClusterDatabase: Error %1!d! in allocating memory for source file name !!!\n",
              status); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }   
   
    status = ERROR_SUCCESS;

    //
    //  Now, find and copy all relevant files from the backup area
    //  to the quorum disk. Note that only one of the copied chk*.tmp
    //  files will be used as the valid checkpoint. However, we copy
    //  all chk*.tmp files to make this implementation simple and 
    //  straightforward to comprehend.
    //
    while ( status == ERROR_SUCCESS )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
        { 
            if ( FindData.cFileName[0] == L'.' )
            {
                if ( FindData.cFileName[1] == L'\0' ||
                         FindData.cFileName[1] == L'.' && FindData.cFileName[2] == L'\0' ) 
                {
                    goto skip;
                }
            }

            //  
            //  Since the found file is infact a directory, check 
            //  whether it is one of the resource checkpoint directories.
            //  If so copy the relevant checkpoint files to the quorum
            //  disk.
            //
            if ( ( status = CpRestoreCheckpointFiles( szSourcePathName, 
                                               FindData.cFileName,
                                               lpszQuoLogPathName ) )
                    != ERROR_SUCCESS )
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpRestoreClusterDatabase: Error %1!d! in copying resource cp files !!!\n",
                    status); 
                CL_LOGFAILURE( status );
                goto FnExit;
            }
        } else
        {
            lstrcpyW ( szTempFileName, FindData.cFileName );
            szTempFileName[3] = L'\0';
            mbstowcs( szChkptFileNameStart, "chk", 4 );
            if ( ( lstrcmpW ( szTempFileName, szChkptFileNameStart ) == 0 ) 
                   || 
                 ( lstrcmpW ( FindData.cFileName, cszQuoFileName ) == 0 ) )
            {
                lstrcpyW( szSourceFileName, szSourcePathName );
                lstrcatW( szSourceFileName, FindData.cFileName );
                lstrcpyW( szDestFileName, lpszQuoLogPathName );
                lstrcatW( szDestFileName, FindData.cFileName );

                status = CopyFileW( szSourceFileName, szDestFileName, FALSE );
                if ( !status ) 
                {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpRestoreClusterDatabase: Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                        szSourceFileName,
                        szDestFileName,
                        status);
                     CL_LOGFAILURE( status );
                     goto FnExit;
                } 
                //
                //  Set the file attribute to normal. There is no reason
                //  to fail in this step since the quorum disk is ours
                //  and we succeeded in copying the file.
                //
                if ( !SetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
                {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, error = %2!u!\n",
                         szDestFileName,
                         status);
                    CL_LOGFAILURE( status );
                    goto FnExit;
                }
            }
        }
skip:                 
        if ( FindNextFile( hFindFile, &FindData ) )
        {
            status = ERROR_SUCCESS;
        } else
        {
            status = GetLastError();
        }
    }
    
    if ( status == ERROR_NO_MORE_FILES )
    {
        status = ERROR_SUCCESS;
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpRestoreClusterDatabase: FindNextFile failed! Error = %1!u!\n",
            status);
    }

FnExit:
    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        FindClose ( hFindFile );
    }
    
    LocalFree ( szSourceFileName );
    LocalFree ( szSourcePathName );
    
    return ( status );
}

/****
@func       DWORD | DmpHandleNodeDownEvent | Handle the node down event
            for DM.

@parm       IN LPVOID | NotUsed | Unused parameter. 
            
@rdesc      Returns ERROR_SUCCESS.

@xref       <f DmpEventHandler> 
****/
DWORD DmpHandleNodeDownEvent(
    IN LPVOID  NotUsed )
{
    //
    // Chittur Subbaraman (chitturs) - 7/23/99
    //
    // This function handles the DM node down processing as a separate
    // thread. The reasons for creating this thread are outlined in
    // DmpEventHandler.
    //
    ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpHandleNodeDownEvent - Entry...\r\n");
    
    //
    // SS: I am not the owner of the quorum resource as yet, but I might
    // be after rearbitration, in that case, just set a flag saying we
    // need to checkpoint.  It will be looked at when the quorum resource
    // comes online. The following function in FM checks if the 
    // quorum is online on this node and if it is, it calls 
    // the checkpoint callback function.  If it is not, it sets the 
    // global boolean variable passed to TRUE.
    //
    FmCheckQuorumState( DmpLogCheckPointCb, &gbNeedToCheckPoint );

    ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpHandleNodeDownEvent - Exit...\r\n");

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\store.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    store.c

Abstract:

    Interface for storing and retrieving checkpoint data on the quorum
    disk.

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"
#include <ntddvol.h>


DWORD
CppGetCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId,
    OUT OPTIONAL LPWSTR *pDirectoryName,
    OUT LPWSTR *pFileName,
    IN OPTIONAL LPCWSTR lpszQuorumDir,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Constructs the correct directory and file names for the checkpoint
    file on the quorum disk.

Arguments:

    Resource - Supplies the quorum resource.

    dwId - Supplies the checkpoint ID

    DirectoryName - if present, returns the full name of the directory the
        checkpoint file should be created in. This buffer must be
        freed by the caller with LocalFree

    FileName - Returns the full pathname of the checkpoint file. This buffer must
        be freed by the caller with LocalFree

    lpszQuorumDir - If present, supplies the quorum directory to use.
                If not present, the current quorum directory is used.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPCWSTR ResourceId;
    LPWSTR QuorumDir=NULL;
    DWORD QuorumDirLength=0;
    LPWSTR Dir;
    DWORD DirLen;
    LPWSTR File;
    DWORD FileLen;
    WCHAR Buff[13];     // 8.3 + NULL

    if (lpszQuorumDir == NULL) {
        Status = DmQuerySz( DmQuorumKey,
                            cszPath,
                            &QuorumDir,
                            &QuorumDirLength,
                            &QuorumDirLength);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppGetCheckpointFile failed to get quorum path %1!d!\n",
                       Status);
            return(Status);
        }
    } else {
        QuorumDir = (LPWSTR)lpszQuorumDir;
        QuorumDirLength = (lstrlenW(QuorumDir)+1)*sizeof(WCHAR);
    }

    ResourceId = OmObjectId(Resource);
    DirLen = QuorumDirLength + sizeof(WCHAR) + (lstrlenW(ResourceId)*sizeof(WCHAR));
    Dir = LocalAlloc(LMEM_FIXED, DirLen);
    if (Dir == NULL) {
        if (lpszQuorumDir == NULL) {
            LocalFree(QuorumDir);
        }
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyW(Dir, QuorumDir);
    lstrcatW(Dir, L"\\");
    lstrcatW(Dir, ResourceId);
    if (lpszQuorumDir == NULL) {
        LocalFree(QuorumDir);
    }

    //
    // Now construct the file name
    //
    FileLen = DirLen + sizeof(WCHAR) + sizeof(Buff);
    File = LocalAlloc(LMEM_FIXED, FileLen);
    if (File == NULL) {
        LocalFree(Dir);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    if (fCryptoCheckpoint) {
        wsprintfW(Buff, L"%08lx.CPR", dwId);
    } else {
        wsprintfW(Buff, L"%08lx.CPT", dwId);
    }
    lstrcpyW(File, Dir);
    lstrcatW(File, L"\\");
    lstrcatW(File, Buff);

    if (ARGUMENT_PRESENT(pDirectoryName)) {
        *pDirectoryName = Dir;
    } else {
        LocalFree(Dir);
    }
    *pFileName = File;
    return(ERROR_SUCCESS);
}


DWORD
CppReadCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Reads a checkpoint off the quorum disk.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is
        responsible for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the filename where the data should be retrieved.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status = ERROR_SUCCESS;
    LPWSTR FileName = NULL;
    BOOL Success;

    //
    //  Chittur Subbaraman (chitturs) - 8/2/99
    //
    //  Remove gQuoLock acquisition from this function also following
    //  the reasoning outlined in CppWriteCheckpoint function. Note that
    //  the caller of this function will retry on specific errors.
    //  [We have to play these hacks to survive !]
    // 
    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  NULL,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppReadCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppReadCheckpoint restoring checkpoint from file %1!ws! to %2!ws!\n",
               FileName,
               lpszFileName);

    Success = CopyFile(FileName, lpszFileName, FALSE);
    if (!Success) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppReadCheckpoint unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   FileName,
                   lpszFileName,
                   Status);
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppReadCheckpoint - Was that due to quorum resource not being up ???\n");
    } else {
        Status = ERROR_SUCCESS;
    }


FnExit:
    if (FileName) LocalFree(FileName);
    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;

    return(Status);
}


DWORD
CppWriteCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Writes a checkpoint to the quorum disk.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the name of the file with the checkpoint data.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status = ERROR_SUCCESS;
    LPWSTR DirectoryName = NULL;
    LPWSTR FileName = NULL;
    BOOL Success;
    HANDLE hDirectory = INVALID_HANDLE_VALUE;

    //
    //  Chittur Subbaraman (chitturs) - 8/2/99
    //
    //  Remove gQuoLock acquisition from this function. This is necessary
    //  since this function could get invoked indirectly from 
    //  FmpRmDoInterlockedDecrement (as a part of the synchronous 
    //  notification - Consider a case where the resource is failing
    //  or going offline and you have to rundown the checkpoints as
    //  a part of the synchronous notification. The rundown function
    //  CppRundownCheckpoints needs to wait until the CppRegNotifyThread
    //  completes and the latter could be stuck trying to write a
    //  checkpoint by calling this function) before the "blockingres" count is
    //  decremented. Now the quorum resource offline operation could
    //  be waiting inside FmpRmOfflineResource waiting for this count
    //  to go down to zero and this holds the gQuoLock (so as not to
    //  let any more resources to bump up this count). So if we want
    //  to get the gQuoLock here, we have an easy deadlock. Note that
    //  the caller of this function will retry on specific errors.
    //  [We have to play these hacks to survive !]
    //
    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  &DirectoryName,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWriteCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppWriteCheckpoint checkpointing file %1!ws! to file %2!ws!\n",
               lpszFileName,
               FileName);

    //
    // Create the directory.
    //
    if (!CreateDirectory(DirectoryName, NULL)) 
    {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWriteCheckpoint unable to create directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;                       
        }
        else
        {
            //the directory exists, it is alright, set Status to ERROR_SUCCESS
            Status = ERROR_SUCCESS;
        }
        
    } 
    else
    {
        //
        // The directory was newly created. Put the appropriate ACL on it
        // so that only ADMINs can read it.
        //
        hDirectory = CreateFile(DirectoryName,
                                GENERIC_READ | WRITE_DAC | READ_CONTROL,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_FLAG_BACKUP_SEMANTICS,
                                NULL);
        if (hDirectory == INVALID_HANDLE_VALUE) 
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWriteCheckpoint unable to open directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
        Status = ClRtlSetObjSecurityInfo(hDirectory,
                                         SE_FILE_OBJECT,
                                         GENERIC_ALL,
                                         GENERIC_ALL,
                                         0);

        if (Status != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWriteCheckpoint unable to set ACL on directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
                                         
    }
    

    //
    // Copy the file
    //
    Success = CopyFile(lpszFileName, FileName, FALSE);
    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWriteCheckpoint unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   lpszFileName,
                   FileName,
                   Status);
    } 

FnExit:

    //clean up
    if (DirectoryName) LocalFree(DirectoryName);
    if (FileName) LocalFree(FileName);
    if (hDirectory != INVALID_HANDLE_VALUE) CloseHandle(hDirectory);

    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;
    
    return(Status);
}

BOOL
CppIsQuorumVolumeOffline(
    VOID
    )
/*++

Routine Description:

    Check the state of the quorum volume.

Arguments:

    None
    
Return Value:

    TRUE - Quorum volume is offline.

    FALSE - Quorum volume is online OR it is not possible to determine the quorum volume state

Notes:

    This function is called in private CP functions to check if the quorum volume is offline or not.
    This is necessary since the error codes returned in those functions when they try to
    access the quorum disk when it is offline does not deterministically point out the state
    of the disk. Note that this function will only perform its job when the quorum volume is 
    a physical disk since the storage stack drivers alone implement the IOCTL_IS_VOLUME_OFFLINE
    at the time of this implementation.

--*/

{
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               dwStatus;
    DWORD               cbBytesReturned = 0;
    WCHAR               szFileName[10];
    WCHAR               szQuorumLogPath[MAX_PATH];
    WCHAR               szQuorumDriveLetter[4];
    BOOL                fOffline = FALSE;

    //
    //  Get the quorum log path so that we can get the quorum drive letter off it.
    //
    dwStatus = DmGetQuorumLogPath( szQuorumLogPath, sizeof( szQuorumLogPath ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                     "[CP] CppIsQuorumVolumeOffline: DmGetQuorumLogPath failed, Status = %1!u!...\n",
                     dwStatus);
        goto FnExit;
    }

    //
    //  Create a file name of the form \\.\Q:
    //
    lstrcpyn( szQuorumDriveLetter, szQuorumLogPath, 3 );

    //
    //  See if the drive letter looks syntactically valid. We don't want to proceed further
    //  if the quorum is a network share.
    //
    if ( !ClRtlIsPathValid( szQuorumDriveLetter ) )
    {
        ClRtlLogPrint(LOG_NOISE,
                     "[CP] CppIsQuorumVolumeOffline: Quorum path %1!ws! does not have a drive letter, returning...\n",
                     szQuorumLogPath);
        goto FnExit;
    }

    lstrcpy( szFileName, L"\\\\.\\" );
    lstrcat( szFileName, szQuorumDriveLetter );
   
    //
    //  Open a handle to the quorum volume
    //
    hFile = CreateFileW( szFileName,
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                     "[CP] CppIsQuorumVolumeOffline: CreateFile for file %1!ws! failed, Status = %2!u!...\n",
                     szFileName,
                     dwStatus);
        goto FnExit;
    }

    //
    //  Check if the volume is offline or not
    //
    if ( !DeviceIoControl( hFile,                   // Device handle
                           IOCTL_VOLUME_IS_OFFLINE, // IOCTL code
                           NULL,                    // In buffer
                           0,                       // In buffer size
                           NULL,                    // Out buffer
                           0,                       // Out buffer size
                           &cbBytesReturned,        // Bytes returned
                           NULL ) )                 // Overlapped
    {
        dwStatus = GetLastError();
        if ( dwStatus != ERROR_GEN_FAILURE )
            ClRtlLogPrint(LOG_UNUSUAL,
                         "[CP] CppIsQuorumVolumeOffline: IOCTL_VOLUME_IS_OFFLINE failed, Status = %1!u!...\n",
                         dwStatus);
        goto FnExit;
    } 

    //
    //  Volume is offline, adjust return status
    //
    fOffline = TRUE;

    ClRtlLogPrint(LOG_NOISE, "[CP] CppIsQuorumVolumeOffline: Quorum volume IS offline...\n");
    
FnExit:
    if ( hFile != INVALID_HANDLE_VALUE ) CloseHandle( hFile );

    return ( fOffline );
}// CppIsQuorumVolumeOffline
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmlocal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmlocal.c

Abstract:

    Contains the routines for local transactions that can be called within
    gum handlers.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"
#include "clusudef.h"

extern BOOL             gbIsQuoLoggingOn;
extern PFM_RESOURCE     gpQuoResource;
extern DWORD            gbIsQuoResOnline;
extern HLOG             ghQuoLog;
#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif
/****
@doc    EXTERNAL INTERFACES CLUSSVC DM
****/

/****
@func       HXSACTION | DmBeginLocalUpdate| Called by gum handlers to make consistent
            changes to the local registry.  The log is reset and a start transaction
            record is written to the log, if the log is active.

@comm       When GumHandlers need to update the registry consitently they must use the 
            LocalApis provided by DM.  

@rdesc      Returns a transaction handle. NULL on failure.  Call GetLastError()
            for error code.

@xref       <f DmAbortLocalUpdate> <f DmCommitLocalUpdate>
****/
HLOCALXSACTION DmBeginLocalUpdate()
{
    DWORD   dwError=ERROR_SUCCESS;
    LSN     StartXsactionLsn;
    DWORD   dwSequence;
    HXSACTION hXsaction = NULL;
    PLOCALXSACTION  pLocalXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmBeginLocalUpdate Entry\r\n");

    //lock the data base, so that a check point is not taken in this duration
    //this lock is released in DmCommitLocalUpdate() or DmAbortLocalUpdate()
    //this lock also prevents the the registry from being flushed.
    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    
    //Commit the registry so that it can be restored on  abort
    if ((dwError = DmCommitRegistry()) != ERROR_SUCCESS)
    {
        goto FnExit;
    }
    //allocate memory for local transaction
    pLocalXsaction = LocalAlloc(LMEM_FIXED, sizeof(LOCALXSACTION));
    if (!pLocalXsaction)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    pLocalXsaction->dwSig = LOCALXSAC_SIG;
    dwSequence = GumGetCurrentSequence(GumUpdateRegistry);
    pLocalXsaction->dwSequence = dwSequence;
    pLocalXsaction->hLogXsaction = NULL;
    InitializeListHead(&pLocalXsaction->PendingNotifyListHead);
    
    //log the start checkpoint record
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) && ghQuoLog)
    {

        hXsaction = LogStartXsaction(ghQuoLog, dwSequence ,RMRegistryMgr, 0);
        if (!hXsaction)
        {
            dwError = GetLastError();
        }
        pLocalXsaction->hLogXsaction = hXsaction;
    }
FnExit:
    if (dwError != ERROR_SUCCESS)
    {
        if (pLocalXsaction) LocalFree(pLocalXsaction);
        pLocalXsaction = NULL;
        RELEASE_LOCK(gLockDmpRoot);

        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBeginLocalUpdate Exit, pLocalXsaction=0x%1!08lx! Error=0x%2!08lx!\r\n",
                pLocalXsaction, dwError);
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBeginLocalUpdate Exit, pLocalXsaction=0x%1!08lx!\r\n",
                pLocalXsaction);
    }

    return((HLOCALXSACTION)pLocalXsaction);
}



/****
@func       DWORD | DmCommitLocalUpdate| This api must be called to commit
            the changes to the local registry.

@parm       IN HXSACTION | hXsaction | The handle to the transaction to be committed.

@comm       A commit record is written the quorum log if logging is active.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmBeginLocalUpdate> <f DmAbortLocalUpdate>
****/
DWORD DmCommitLocalUpdate(IN HLOCALXSACTION hLocalXsaction)
{
    DWORD dwError=ERROR_SUCCESS;
    PLOCALXSACTION  pLocalXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCommitLocalUpdate Entry\r\n");

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);
    

    //update the gum sequence
    DmpUpdateSequence();

    DmpReportPendingNotifications(pLocalXsaction, TRUE );

    //write a commit record to the quorum log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {
        CL_ASSERT(pLocalXsaction->hLogXsaction);
        dwError = LogCommitXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 0);
        // 
        //  Chittur Subbaraman (chitturs) - 1/19/99
        //
        pLocalXsaction->hLogXsaction = NULL;
    }

    // 
    //  Chittur Subbaraman (chitturs) - 1/19/99
    //
    //  Make sure that the hLogXsaction memory is freed (even in the case
    //  in which you started a local xsaction and didn't get a chance to
    //  commit it or abort it to the log because quorum logging got turned
    //  off in the middle, for example. This turning off of the logging
    //  in the middle of a transaction could be considered as a bug ?)
    //
    LocalFree( pLocalXsaction->hLogXsaction );
    
    //invalidate the signature and free the transaction structure
    pLocalXsaction->dwSig = 0;
    LocalFree(pLocalXsaction);
    //release the database
    RELEASE_LOCK(gLockDmpRoot);

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCommitLocalUpdate Exit, returning 0x%1!08lx!\r\n",
        dwError);

    return(dwError);
}


/****
@func       DWORD | DmAbortLocalUpdate| DmAbortLocalUpdate aborts all the changes
            to the local registry associated with this transaction.

@parm       IN HXSACTION | hXsaction | The handle to the transaction to be committed.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmBeginLocalUpdate> <f DmCommitLocalUpdate>
****/
DWORD DmAbortLocalUpdate(IN HLOCALXSACTION hLocalXsaction)
{
    DWORD           dwError=ERROR_SUCCESS;
    PLOCALXSACTION  pLocalXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmAbortLocalUpdate Entry\r\n");

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    //write the abort chkpoint record
    //if the locker  node is logging this is valid,
    //if the nonlocker node is logging, and it aborts
    // some other node will inherit the quorum log and
    //checkpoint and hence commit this update.
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {
        CL_ASSERT(pLocalXsaction->hLogXsaction);
        LogAbortXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 0);
        // 
        //  Chittur Subbaraman (chitturs) - 1/19/99
        //
        pLocalXsaction->hLogXsaction = NULL;
    }

    //SS: if the rollback fails, then we kill ourselves??
    //restore the old registry
    if ((dwError = DmRollbackRegistry()) != ERROR_SUCCESS)
    {
        CL_UNEXPECTED_ERROR(dwError);
    }

    //free any pending notifications that were built up for
    //this transaction
    DmpReportPendingNotifications(pLocalXsaction, FALSE );

    // 
    //  Chittur Subbaraman (chitturs) - 1/19/99
    //
    //  Make sure that the hLogXsaction memory is freed (even in the case
    //  in which you started a local xsaction and didn't get a chance to
    //  commit it or abort it to the log because quorum logging got turned
    //  off in the middle, for example. This turning off of the logging
    //  in the middle of a transaction could be considered as a bug ?)
    //
    LocalFree( pLocalXsaction->hLogXsaction );
    
    //free the transaction structure, it cannot be used any more
    pLocalXsaction->dwSig = 0;
    LocalFree(pLocalXsaction);

    //release the database
    RELEASE_LOCK(gLockDmpRoot);

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmAbortLocalUpdate Exit, returning 0x%1!08lx!\r\n",
        dwError);

    return(dwError);

}




DWORD
DmLocalSetValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key on the local machine

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DWORD       Status = ERROR_SUCCESS;
    PDMKEY      Key;
    PUCHAR      Dest;
    DWORD       NameLength;
    DWORD       ValueNameLength;
    DWORD       UpdateLength;
    PDM_SET_VALUE_UPDATE Update = NULL;
    PLOCALXSACTION  pLocalXsaction;
    
    Key = (PDMKEY)hKey;

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    Status = RegSetValueExW(Key->hKey,
                            lpValueName,
                            0,
                            dwType,
                            lpData,
                            cbData);

    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    DmpAddToPendingNotifications(pLocalXsaction, Key->Name, CLUSTER_CHANGE_REGISTRY_VALUE);

    //write it to the quorum log 
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource)  
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {
        Key = (PDMKEY)hKey;
        NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
        ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
        UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +
                       NameLength +
                       ValueNameLength +
                       cbData;


        Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
        if (Update == NULL) 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }


        Update->lpStatus = NULL;
        Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;
        Update->DataOffset = Update->NameOffset + ValueNameLength;
        Update->DataLength = cbData;
        Update->Type = dwType;
        CopyMemory(Update->KeyName, Key->Name, NameLength);

        Dest = (PUCHAR)Update + Update->NameOffset;
        CopyMemory(Dest, lpValueName, ValueNameLength);

        Dest = (PUCHAR)Update + Update->DataOffset;
        CopyMemory(Dest, lpData, cbData);

        
        if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
            DmUpdateSetValue, Update, UpdateLength) == NULL_LSN)
        {
            Status = GetLastError();
        }
    }        
                            
FnExit:
    if (Update) LocalFree(Update);
    return(Status);

}


HDMKEY
DmLocalCreateKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:

    Creates a key in the local registry. If the key exists, it
    is opened. If it does not exist, it is created.

Arguments:

    hKey - Supplies the key that the create is relative to.

    lpSubKey - Supplies the key name relative to hKey

    dwOptions - Supplies any registry option flags. 

    samDesired - Supplies desired security access mask

    lpSecurityDescriptor - Supplies security for the newly created key.

    Disposition - Returns whether the key was opened (REG_OPENED_EXISTING_KEY)
        or created (REG_CREATED_NEW_KEY)

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY                  Parent;
    PDMKEY                  Key = NULL;
    DWORD                   NameLength;
    DWORD                   Status;
    PDM_CREATE_KEY_UPDATE   CreateUpdate = NULL;
    PVOID                   pBuffer = NULL;
    DWORD                   dwBufLength;
    DWORD                   dwSecurityLength;
    PLOCALXSACTION          pLocalXsaction;
    

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    if (dwOptions == REG_OPTION_VOLATILE)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    Parent = (PDMKEY)hKey;

    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Create the key on the local machine.
    //
    Status = RegCreateKeyExW(Parent->hKey,
                             lpSubKey,
                             0,
                             NULL,
                             0,
                             samDesired,
                             lpSecurityDescriptor,
                             &Key->hKey,
                             lpDisposition);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    // Create the key name
    //
    lstrcpyW(Key->Name, Parent->Name);
    if (Key->Name[0] != UNICODE_NULL) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

    //add the pending notification to be delivered on commit
    DmpAddToPendingNotifications(pLocalXsaction, Key->Name, CLUSTER_CHANGE_REGISTRY_NAME);

    //successfully created key, write to the log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {

        //get the length of the security structure
        if (ARGUMENT_PRESENT(lpSecurityDescriptor)) 
        {
            dwSecurityLength = GetSecurityDescriptorLength(lpSecurityDescriptor);
        } 
        else 
        {
            dwSecurityLength = 0;
        }

        CreateUpdate = (PDM_CREATE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, sizeof(DM_CREATE_KEY_UPDATE));
        if (CreateUpdate == NULL) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }

        //
        // Issue the update.
        //
        CreateUpdate->lpDisposition = lpDisposition;
        CreateUpdate->phKey = &Key->hKey;
        CreateUpdate->samDesired = samDesired;
        CreateUpdate->dwOptions = dwOptions;

        if (ARGUMENT_PRESENT(lpSecurityDescriptor)) {
            CreateUpdate->SecurityPresent = TRUE;
        } else {
            CreateUpdate->SecurityPresent = FALSE;
        }

        //marshall the data, 
        pBuffer = GumMarshallArgs(&dwBufLength,
                            3, 
                            sizeof(DM_CREATE_KEY_UPDATE),
                            CreateUpdate,
                            (lstrlenW(Key->Name)+1)*sizeof(WCHAR),
                            Key->Name,
                            dwSecurityLength,
                            lpSecurityDescriptor);
        if (pBuffer)
        {
            CL_ASSERT(pLocalXsaction->hLogXsaction);
            //write it to the logger
            if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
                DmUpdateCreateKey, pBuffer, dwBufLength) == NULL_LSN)
            {   
                Status = GetLastError();
                goto FnExit;
            }                
        }
    }


    

FnExit:    
    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        Key = NULL;
        SetLastError(Status);
    }
    if (CreateUpdate) LocalFree(CreateUpdate);
    if (pBuffer) LocalFree(pBuffer);
    return((HDMKEY)Key);

}


DWORD
DmLocalRemoveFromMultiSz(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Removes a string from a REG_MULTI_SZ value.

Arguments:

    hKey - Supplies the key where the value exists. This key must
           have been opened with READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be removed from the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPWSTR Buffer=NULL;
    DWORD BufferSize;
    DWORD DataSize;
    LPWSTR Current;
    DWORD CurrentLength;
    DWORD i;
    LPWSTR Next;
    PCHAR Src, Dest;
    DWORD NextLength;
    DWORD MultiLength;
    


    BufferSize = 0;
    Status = DmQueryString(hKey,
                           lpValueName,
                           REG_MULTI_SZ,
                           &Buffer,
                           &BufferSize,
                           &DataSize);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MultiLength = DataSize/sizeof(WCHAR);
    Status = ClRtlMultiSzRemove(Buffer,
                                &MultiLength,
                                lpString);
    if (Status == ERROR_SUCCESS) {
        //
        // Set the new value back.
        //
        Status = DmLocalSetValue(hLocalXsaction,
                                 hKey,
                                 lpValueName,
                                 REG_MULTI_SZ,
                                 (CONST BYTE *)Buffer,
                                 MultiLength * sizeof(WCHAR));

    } else if (Status == ERROR_FILE_NOT_FOUND) {
        Status = ERROR_SUCCESS;
    }
    if (Buffer) LocalFree(Buffer);
    return(Status);
}

DWORD
DmLocalAppendToMultiSz(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )

/*++

Routine Description:

    Adds another string to a REG_MULTI_SZ value. If the value does
    not exist, it will be created.

Arguments:

    hLocalXsaction - A handle to a local transaction.
    
    hKey - Supplies the key where the value exists. This key must
           have been opened with KEY_READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be appended to the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD ValueLength = 512;
    DWORD ReturnedLength;
    LPWSTR ValueData;
    DWORD StringLength;
    DWORD Status;
    DWORD cbValueData;
    PWSTR s;
    DWORD Type;

    StringLength = (lstrlenW(lpString)+1)*sizeof(WCHAR);
retry:
    ValueData = LocalAlloc(LMEM_FIXED, ValueLength + StringLength);
    if (ValueData == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    cbValueData = ValueLength;
    Status = DmQueryValue(hKey,
                          lpValueName,
                          &Type,
                          (LPBYTE)ValueData,
                          &cbValueData);
    if (Status == ERROR_MORE_DATA) {
        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = cbValueData;
        LocalFree(ValueData);
        goto retry;
    }
    if (Status == ERROR_FILE_NOT_FOUND) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData;

    } else if (Status == ERROR_SUCCESS) {
        //
        // A value already exists. Append our string to the
        // MULTI_SZ.
        //
        s = (PWSTR)((PCHAR)ValueData + cbValueData) - 1;
    } else {
        LocalFree(ValueData);
        return(Status);
    }

    CopyMemory(s, lpString, StringLength);
    s += (StringLength / sizeof(WCHAR));
    *s++ = L'\0';

    Status = DmLocalSetValue(
                        hLocalXsaction,
                        hKey,
                        lpValueName,
                        REG_MULTI_SZ,
                        (CONST BYTE *)ValueData,
                        (DWORD)((s-ValueData)*sizeof(WCHAR)));
    LocalFree(ValueData);

    return(Status);
}

DWORD
DmLocalDeleteKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key from the local registry. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY                      Key;
    DWORD                       NameLength;
    DWORD                       UpdateLength;
    PDM_DELETE_KEY_UPDATE       Update=NULL;
    DWORD                       Status;
    PLOCALXSACTION              pLocalXsaction;

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    Key = (PDMKEY)hKey;
    NameLength = (lstrlenW(Key->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    UpdateLength = NameLength + sizeof(DM_DELETE_KEY_UPDATE);

    Update = (PDM_DELETE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);

    if (Update == NULL) 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }


    //dont need an update on status thru marshalled data
    Update->lpStatus = NULL;
    CopyMemory(Update->Name, Key->Name, (lstrlenW(Key->Name) + 1) * sizeof(WCHAR));
    if (Update->Name[0] != L'\0') 
    {
        lstrcatW(Update->Name, L"\\");
    }
    lstrcatW(Update->Name, lpSubKey);
    
    Status = RegDeleteKeyW(DmpRoot, Update->Name);

    if (Status != ERROR_SUCCESS)
        goto FnExit;

    //add the pending notification to be delivered on commit
    DmpAddToPendingNotifications(pLocalXsaction, Update->Name, CLUSTER_CHANGE_REGISTRY_NAME);

    //successfully deleted key, write to the log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource)  
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {

        if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
            DmUpdateDeleteKey, Update, UpdateLength) == NULL_LSN)
        {   
            Status = GetLastError();
            goto FnExit;
        }                

    }


FnExit:
    if (Update) LocalFree(Update);
    return(Status);
}

DWORD
DmLocalDeleteTree(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )
/*++

Routine Description:

    Deletes the specified registry subtree in the local registry. 
    All subkeys are    deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL.
        Any subkeys of the specified key will also be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY Subkey;
    DWORD i;
    DWORD Status;
    LPWSTR KeyBuffer=NULL;
    DWORD MaxKeyLen;
    DWORD NeededSize;

    Subkey = DmOpenKey(hKey,
                       lpSubKey,
                       MAXIMUM_ALLOWED);
    if (Subkey == NULL) {
        Status = GetLastError();
        return(Status);
    }

    //
    // Get the size of name buffer we will need.
    //
    Status = DmQueryInfoKey(Subkey,
                            NULL,
                            &MaxKeyLen,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        DmCloseKey(Subkey);
        return(Status);
    }
    KeyBuffer = LocalAlloc(LMEM_FIXED, (MaxKeyLen+1)*sizeof(WCHAR));
    if (KeyBuffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
        DmCloseKey(Subkey);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate the subkeys and apply ourselves recursively to each one.
    //
    i=0;
    do {
        NeededSize = MaxKeyLen+1;
        Status = DmEnumKey(Subkey,
                           i,
                           KeyBuffer,
                           &NeededSize,
                           NULL);
        if (Status == ERROR_SUCCESS) {
            //
            // Call ourselves recursively on this keyname.
            //
            DmLocalDeleteTree(hLocalXsaction, Subkey, KeyBuffer);

        } else {
            //
            // Some odd error, keep going with the next key.
            //
            ++i;
        }

    } while ( Status != ERROR_NO_MORE_ITEMS );

    DmCloseKey(Subkey);

    Status = DmLocalDeleteKey(hLocalXsaction, hKey, lpSubKey);

    if (KeyBuffer != NULL) {
        LocalFree(KeyBuffer);
    }
    return(Status);
}


DWORD
DmLocalDeleteValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    )
{
    PDMKEY                      Key;
    DWORD                       NameLength;
    DWORD                       ValueNameLength;
    DWORD                       UpdateLength;
    PDM_DELETE_VALUE_UPDATE     Update=NULL;
    PUCHAR                      Dest;
    DWORD                       Status;
    HKEY                        hRegKey;
    PLOCALXSACTION              pLocalXsaction;

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    Key = (PDMKEY)hKey;

    Status = RegOpenKeyExW(DmpRoot,
                           Key->Name,
                           0,
                           KEY_SET_VALUE,
                           &hRegKey);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }


    Status = RegDeleteValueW(hRegKey, lpValueName);
    RegCloseKey(hRegKey);

    if (Status!=ERROR_SUCCESS)
        goto FnExit;

    //add the pending notification to be delivered on commit
    DmpAddToPendingNotifications(pLocalXsaction, Key->Name, CLUSTER_CHANGE_REGISTRY_VALUE);

    //successfully created key, write to the log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {

        //if successful and this is the logging node, then log
        // the transaction
        NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
        ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
        UpdateLength = sizeof(DM_DELETE_VALUE_UPDATE) +
                       NameLength +
                       ValueNameLength;

        Update = (PDM_DELETE_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
        if (Update == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }


        Update->lpStatus = NULL;
        Update->NameOffset = FIELD_OFFSET(DM_DELETE_VALUE_UPDATE, KeyName)+NameLength;

        CopyMemory(Update->KeyName, Key->Name, NameLength);

        Dest = (PUCHAR)Update + Update->NameOffset;
        CopyMemory(Dest, lpValueName, ValueNameLength);

        if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
            DmUpdateDeleteValue, Update, UpdateLength) == NULL_LSN)
        {   
            Status = GetLastError();
            goto FnExit;
        }                
    }

FnExit:
    if (Update) LocalFree(Update);
    return(Status);
}


/****
@func       VOID | DmpReportPendingNotifications| This is called
            on commit or abort of a local transactions.  On a commit,
            notifications related to changes within a transaction
            are delivered.

@parm       IN PLOCALXSACTION | pLocalXsaction| A pointer to the local
            transation context.

@parm       IN BOOL | bCommit| Set to TRUE when the transaction is 
            commited.

@comm       The pending notification structure associated with the
            transaction is cleaned up.

@xref       <f DmAbortLocalUpdate> <f DmCommitLocalUpdate>
****/
VOID
DmpReportPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN BOOL             bCommit
    )
{
    PLIST_ENTRY         pListEntry;
    PDM_PENDING_NOTIFY  pDmPendingNotify;
    
    pListEntry = pLocalXsaction->PendingNotifyListHead.Flink;

    //remove the entries and proces them one by one
    //free them when done
    while (pListEntry != &pLocalXsaction->PendingNotifyListHead)
    {
        pDmPendingNotify = CONTAINING_RECORD(pListEntry, DM_PENDING_NOTIFY, ListEntry);
        // if transaction is commited
        if (bCommit)
            DmpReportNotify(pDmPendingNotify->pszKeyName, pDmPendingNotify->dwFilter);               
        pListEntry = pListEntry->Flink;
        RemoveEntryList( &pDmPendingNotify->ListEntry );
        LocalFree(pDmPendingNotify->pszKeyName);
        LocalFree(pDmPendingNotify);
    }
    return;
}


/****
@func       DWORD | DmpAddToPendingNotifications| This is called
            by the DmLocal Api's to queue registry notifications
            on success.  The notifications are delivered or 
            thrown away depending on whether the transaction commits
            or aborts.

@parm       IN PLOCALXSACTION | pLocalXsaction| A pointer to the local
            transation context.

@parm       IN LPCWSTR | pszName| A pointer to the registry key name.

@parm       IN DWORD | dwFilter | The filters associated with the notification.

@comm       A new pending notification structure is created and associated 
            with the transaction.

@xref       <f DmAbortLocalUpdate> <f DmCommitLocalUpdate>
****/
DWORD    
DmpAddToPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN LPCWSTR          pszName,
    IN DWORD            dwFilter
)    
{
    DWORD               dwError = ERROR_SUCCESS;
    PDM_PENDING_NOTIFY  pDmPendingNotify;

    pDmPendingNotify = LocalAlloc(LPTR, sizeof(DM_PENDING_NOTIFY));
    if (!pDmPendingNotify)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    pDmPendingNotify->pszKeyName = LocalAlloc(LMEM_FIXED, 
                        ((lstrlenW(pszName) + 1 ) * sizeof(WCHAR)));
    if (!pDmPendingNotify->pszKeyName)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //initialize the structure
    lstrcpyW(pDmPendingNotify->pszKeyName, pszName);
    pDmPendingNotify->dwFilter = dwFilter;
    InitializeListHead(&pDmPendingNotify->ListEntry);

    //add to the list
    InsertTailList(&pLocalXsaction->PendingNotifyListHead, 
        &pDmPendingNotify->ListEntry);    


FnExit:
    return(dwError);
}

/****
@func       DWORD | DmAmITheOwnerOfTheQuorumResource| This harmless
            function is used by regroup module to determine whether
            a node thinks that it is the owner of the quorum resource or not.
****/
DWORD DmAmITheOwnerOfTheQuorumResource() {
  return gpQuoResource 
      && gpQuoResource->Group 
      && gbIsQuoResOnline 
      && AMIOWNEROFQUORES(gpQuoResource);
}



DWORD
DmRtlLocalCreateKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY * phkResult,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:

    Wrapper function for DmLocalCreateKey to be used with CLRtl* functions.

--*/    
{   
    DWORD   status;

    *phkResult= DmLocalCreateKey(
                    hLocalXsaction,
                    hKey,
                    lpSubKey,
                    dwOptions,
                    samDesired,
                    lpSecurityDescriptor,
                    lpDisposition
                    );
    if(* phkResult == NULL)
        status=GetLastError();
    else
        status=ERROR_SUCCESS;
    return status;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\ep\epp.h ===
#ifndef _EPP_H
#define _EPP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    epp.h

Abstract:

    Private header file for the cluster event processor.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_EP


//
// Local Constants
//
#define NUMBER_OF_COMPONENTS       5
#define EP_MAX_CACHED_EVENTS       20
#define EP_MAX_ALLOCATED_EVENTS    CLRTL_MAX_POOL_BUFFERS

#define EpQuadAlign(size)    ( (((size) / sizeof(DWORDLONG)) + 1) * \
                               sizeof(DWORDLONG) )


//
// Local Types
//
typedef struct {
    CLUSTER_EVENT   Id;
    DWORD           Flags;
    PVOID           Context;
} EP_EVENT, *PEP_EVENT;

#endif //ifndef _EPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmreg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmreg.c

Abstract:

    Contains the registry access routines for the Config Database Manager

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"

#include <align.h>

#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE     gLockDmpRoot;
#endif

HDMKEY
DmGetRootKey(
    IN DWORD samDesired
    )

/*++

Routine Description:

    Opens the registry key at the root of the cluster registry database

Arguments:

    samDesired - Supplies requested security access

Return Value:

    A handle to the opened registry key.

    NULL on error. LastError will be set to the specific error code.

--*/

{
    DWORD Error;
    PDMKEY Key;

    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+sizeof(WCHAR));
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    //  Acquire DM root lock to synchronize with DmRollbackRegistry.
    //
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          DmpClusterParametersKeyName,
                          0,
                          samDesired,
                          &Key->hKey);
    if (Error != ERROR_SUCCESS) {
        LocalFree(Key);
        SetLastError(Error);
        Key = NULL;
        goto FnExit;
    }
    Key->Name[0] = '\0';
    Key->GrantedAccess = samDesired;
    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);

    return((HDMKEY)Key);

}


DWORD
DmCloseKey(
    IN HDMKEY hKey
    )

/*++

Routine Description:

    Closes a handle to an open HDMKEY key.

Arguments:

    hKey - Supplies the handle to be closed.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Error = ERROR_SUCCESS;
    PDMKEY Key;

    //
    // Nobody better EVER close one of the global keys.
    //
    CL_ASSERT(hKey != DmClusterParametersKey);
    CL_ASSERT(hKey != DmResourcesKey);
    CL_ASSERT(hKey != DmResourceTypesKey);
    CL_ASSERT(hKey != DmQuorumKey);
    CL_ASSERT(hKey != DmGroupsKey);
    CL_ASSERT(hKey != DmNodesKey);
    CL_ASSERT(hKey != DmNetworksKey);
    CL_ASSERT(hKey != DmNetInterfacesKey);

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //if the key was deleted and invalidated and couldnt be reopened
    // it will be set to NULL, in this case we dont call regclosekey

    if( Key == NULL ) goto FnExit;
        
    if (ISKEYDELETED(Key))
        goto CleanupKey;

    Error = RegCloseKey(Key->hKey);
    if (Error != ERROR_SUCCESS) 
    {
        CL_LOGFAILURE(Error);
        goto FnExit;
    }

CleanupKey:
    EnterCriticalSection(&KeyLock);
    RemoveEntryList(&Key->ListEntry);
    DmpRundownNotify(Key);
    LeaveCriticalSection(&KeyLock);
    LocalFree(Key);
    
FnExit:    
    RELEASE_LOCK(gLockDmpRoot);
    return(Error);
}


HDMKEY
DmCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:

    Creates a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, it is created on all nodes in
    the cluster.

Arguments:

    hKey - Supplies the key that the create is relative to.

    lpSubKey - Supplies the key name relative to hKey

    dwOptions - Supplies any registry option flags. 

    samDesired - Supplies desired security access mask

    lpSecurityDescriptor - Supplies security for the newly created key.

    Disposition - Returns whether the key was opened (REG_OPENED_EXISTING_KEY)
        or created (REG_CREATED_NEW_KEY)

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY Parent;
    PDMKEY Key=NULL;
    DWORD NameLength;
    DWORD Status = ERROR_SUCCESS;
    HDMKEY NewKey;
    PDM_CREATE_KEY_UPDATE CreateUpdate = NULL;
    DWORD SecurityLength;

    // if this is a request to create a volatile key, refuse it
    // we dont support volatile keys in the cluster hive since
    // we cant roll back the cluster hive then.
    if (dwOptions == REG_OPTION_VOLATILE)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    //
    // Issue a global update to create the key.
    //

    Parent = (PDMKEY)hKey;

    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Create the key name
    //
    lstrcpyW(Key->Name, Parent->Name);
    if (Key->Name[0] != UNICODE_NULL) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    //get the length of the security structure
    if (ARGUMENT_PRESENT(lpSecurityDescriptor)) {
        SecurityLength = GetSecurityDescriptorLength(lpSecurityDescriptor);
    } else {
        SecurityLength = 0;
    }


    CreateUpdate = (PDM_CREATE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, sizeof(DM_CREATE_KEY_UPDATE));
    if (CreateUpdate == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Issue the update.
    //
    CreateUpdate->lpDisposition = lpDisposition;
    CreateUpdate->phKey = &Key->hKey;
    CreateUpdate->samDesired = samDesired;
    CreateUpdate->dwOptions = dwOptions;

    if (ARGUMENT_PRESENT(lpSecurityDescriptor)) {
        CreateUpdate->SecurityPresent = TRUE;
    } else {
        CreateUpdate->SecurityPresent = FALSE;
    }

    Status = GumSendUpdateEx(GumUpdateRegistry,
                             DmUpdateCreateKey,
                             3,
                             sizeof(DM_CREATE_KEY_UPDATE),
                             CreateUpdate,
                             (lstrlenW(Key->Name)+1)*sizeof(WCHAR),
                             Key->Name,
                             SecurityLength,
                             lpSecurityDescriptor);

    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    if (CreateUpdate) LocalFree(CreateUpdate);

    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }
    else
    {
        return ((HDMKEY)Key);
    }
}


HDMKEY
DmOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired
    )

/*++

Routine Description:

    Opens a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, the call fails.

Arguments:

    hKey - Supplies the key that the open is relative to.

    lpSubKey - Supplies the key name relative to hKey

    samDesired - Supplies desired security access mask

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY  Parent;
    PDMKEY  Key=NULL;
    DWORD   NameLength;
    DWORD   Status = ERROR_SUCCESS;

    Parent = (PDMKEY)hKey;

    //hold the shared lock
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //check if the key was deleted and invalidated
    if (ISKEYDELETED(Parent))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // Open the key on the local machine.
    //
    Status = RegOpenKeyEx(Parent->hKey,
                          lpSubKey,
                          0,
                          samDesired,
                          &Key->hKey);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    // Create the key name. only append a trailing backslash
    // if a parent name and subkey are non-null
    //
    lstrcpyW(Key->Name, Parent->Name);
    if ((Key->Name[0] != UNICODE_NULL) && (lpSubKey[0] != UNICODE_NULL)) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);

    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }
    else
        return((HDMKEY)Key);


}



DWORD
DmEnumKey(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    OUT OPTIONAL PFILETIME lpLastWriteTime
    )

/*++

Routine Description:

    Enumerates the subkeys of a cluster registry key.

Arguments:

    hKey - Supplies the registry key for which the subkeys should
           be enumerated.

    dwIndex - Supplies the index to be enumerated.

    KeyName - Returns the name of the dwIndex subkey. The memory
           allocated for this buffer must be freed by the client.

    lpLastWriteTime - Returns the last write time.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY Key;
    DWORD  Status;
    FILETIME LastTime;

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //check if the key was deleted and invalidated
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    Status = RegEnumKeyExW(Key->hKey,
                         dwIndex,
                         lpName,
                         lpcbName,
                         NULL,
                         NULL,
                         NULL,
                         &LastTime);

    if (lpLastWriteTime != NULL) {
        *lpLastWriteTime = LastTime;
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmSetValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key.

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DWORD Status= ERROR_SUCCESS;        //initialize to success
    PDMKEY Key;
    DWORD NameLength;
    DWORD ValueNameLength;
    DWORD UpdateLength;
    PDM_SET_VALUE_UPDATE Update;
    PUCHAR Dest;


    Key = (PDMKEY)hKey;

    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    //
    // round lengths such that pointers to the data trailing the structure are
    // aligned on the architecture's natural boundary
    //
    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));

    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
    ValueNameLength = ROUND_UP_COUNT( ValueNameLength, sizeof( DWORD_PTR ));

    UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +
                   NameLength +
                   ValueNameLength +
                   cbData;


    Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;
    Update->DataOffset = Update->NameOffset + ValueNameLength;
    Update->DataLength = cbData;
    Update->Type = dwType;
    CopyMemory(Update->KeyName, Key->Name, NameLength);

    Dest = (PUCHAR)Update + Update->NameOffset;
    CopyMemory(Dest, lpValueName, ValueNameLength);

    Dest = (PUCHAR)Update + Update->DataOffset;
    CopyMemory(Dest, lpData, cbData);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateSetValue,
                  UpdateLength,
                  Update);


    LocalFree(Update);

    return(Status);

}


DWORD
DmDeleteValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    )

/*++

Routine Description:

    Removes the specified value from a given registry subkey

Arguments:

    hKey - Supplies the key whose value is to be deleted.

    lpValueName - Supplies the name of the value to be removed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY Key;
    DWORD NameLength;
    DWORD ValueNameLength;
    DWORD UpdateLength;
    PDM_DELETE_VALUE_UPDATE Update;
    PUCHAR Dest;
    DWORD Status;

    Key = (PDMKEY)hKey;
    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);


    //
    // round up length to align pointer to ValueName on natural architecture
    // boundary
    //
    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));

    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);

    UpdateLength = sizeof(DM_DELETE_VALUE_UPDATE) +
                   NameLength +
                   ValueNameLength;

        Update = (PDM_DELETE_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    Update->NameOffset = FIELD_OFFSET(DM_DELETE_VALUE_UPDATE, KeyName)+NameLength;

    CopyMemory(Update->KeyName, Key->Name, NameLength);

    Dest = (PUCHAR)Update + Update->NameOffset;
    CopyMemory(Dest, lpValueName, ValueNameLength);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateDeleteValue,
                  UpdateLength,
                  Update);
    LocalFree(Update);

    return(Status);
}


DWORD
DmQueryValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Queries a named value for the specified cluster registry subkey

Arguments:

    hKey - Supplies the subkey whose value should be queried

    lpValueName - Supplies the named value to be queried

    lpType - Returns the type of the value's data

    lpData - Returns the value's data

    lpcbData - Supplies the size (in bytes) of the lpData buffer
               Returns the number of bytes copied into the lpData buffer
               If lpData==NULL, cbData is set to the required buffer
               size and the function returns ERROR_SUCCESS

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY  Key;
    DWORD   Status;

    Key = (PDMKEY)hKey;
    //check if the key was deleted and invalidated

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }

    Status = RegQueryValueEx(Key->hKey,
                           lpValueName,
                           NULL,
                           lpType,
                           lpData,
                           lpcbData);
FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmQueryDword(
    IN  HDMKEY  hKey,
    IN  LPCWSTR lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    )

/*++

Routine Description:

    Reads a REG_DWORD registry value. If the value is not present, then
    default to the value supplied in lpDefaultValue (if present).

Arguments:

    hKey        - Open key for the value to be read.

    lpValueName - Unicode name of the value to be read.

    lpValue     - Pointer to the DWORD into which to read the value.

    lpDefaultValue - Optional pointer to a DWORD to use as a default value.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY  Key;
    DWORD   Status;
    DWORD   ValueType;
    DWORD   ValueSize = sizeof(DWORD);

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    Status = RegQueryValueEx(Key->hKey,
                             lpValueName,
                             NULL,
                             &ValueType,
                             (LPBYTE)lpValue,
                             &ValueSize);

    if ( Status == ERROR_SUCCESS ) {
        if ( ValueType != REG_DWORD ) {
            Status = ERROR_INVALID_PARAMETER;
        }
    } else {
        if ( ARGUMENT_PRESENT( lpDefaultValue ) ) {
            *lpValue = *lpDefaultValue;
            Status = ERROR_SUCCESS;
        }
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);

} // DmQueryDword


DWORD
DmQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = DmQueryValue( Key,
                           ValueName,
                           &valueType,
                           (LPBYTE) *StringBuffer,
                           StringSize
                         );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        if (*StringSize) status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = LocalAlloc(LMEM_FIXED, *StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            LocalFree(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = DmQueryValue( Key,
                               ValueName,
                               &valueType,
                               (LPBYTE) *StringBuffer,
                               StringSize
                             );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // DmQueryString


VOID
DmEnumKeys(
    IN HDMKEY RootKey,
    IN PENUM_KEY_CALLBACK Callback,
    IN PVOID Context
    )

/*++

 Routine Description:

     Enumerates the subkeys of the given registry key. For each
     subkey, a string is allocated to hold the subkey name and
     the subkey is opened. The specified callback function is
     called and passed the subkey handle and subkey name.

     The callback function is responsible for closing the subkey
     handle and freeing the subkey name.

 Arguments:

    RootKey - Supplies a handle to the key whose subkeys are to
              be enumerated.

    Callback - Supplies the callback routine.

    Context - Supplies an arbitrary context to be passed to the
              callback routine.

 Return Value:

    None.

--*/
{
    PWSTR KeyName;
    HDMKEY SubKey;
    DWORD Index;
    DWORD Status;
    FILETIME FileTime;
    PWSTR NameBuf;
    DWORD NameBufSize;
    DWORD OrigNameBufSize;

    //
    // Find the length of the longest subkey name.
    //
    Status = DmQueryInfoKey(RootKey,
                            NULL,
                            &NameBufSize,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR(Status);
        return;
    }

    NameBufSize = (NameBufSize + 1)*sizeof(WCHAR);
    NameBuf = LocalAlloc(LMEM_FIXED, NameBufSize);
    if (NameBuf == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
    }
    OrigNameBufSize = NameBufSize;

    //
    // Enumerate the subkeys
    //
    Index = 0;
    do {
        NameBufSize = OrigNameBufSize;
        Status = DmEnumKey( RootKey,
                            Index,
                            NameBuf,
                            &NameBufSize,
                            NULL);

        if (Status == ERROR_SUCCESS) {
            KeyName = LocalAlloc(LMEM_FIXED, (wcslen(NameBuf)+1)*sizeof(WCHAR));
            if (KeyName != NULL) {

                wcscpy(KeyName, NameBuf);

                //
                // Open the key
                //
                SubKey = DmOpenKey( RootKey,
                                    KeyName,
                                    MAXIMUM_ALLOWED);
                if (SubKey == NULL) {
                    Status = GetLastError();
                    CL_UNEXPECTED_ERROR(Status);
                    LocalFree(KeyName);
                } else {
                    (Callback)(SubKey,
                               KeyName,
                               Context);
                }

            } else {
                CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        Index++;
    } while ( Status == ERROR_SUCCESS );

    LocalFree(NameBuf);

} // DmEnumKeys


VOID
DmEnumValues(
    IN HDMKEY RootKey,
    IN PENUM_VALUE_CALLBACK Callback,
    IN PVOID Context
    )

/*++

 Routine Description:

     Enumerates the values of the given registry key. For each
     value, a string is allocated to hold the value name and a
     buffer is allocated to hold its data. The specified callback
     function is called and passed the value name and data.

     The callback function must not free either the value name
     or its buffer. If it needs this data after the callback
     returns, it must copy it.

 Arguments:

    RootKey - Supplies a handle to the key whose values are to
              be enumerated.

    Callback - Supplies the callback routine.

    Context - Supplies an arbitrary context to be passed to the
              callback routine.

 Return Value:

    None.

--*/
{
    DWORD Index;
    DWORD Status;
    PWSTR NameBuf;
    DWORD NameBufSize;
    DWORD ValueCount;
    DWORD MaxValueLen;
    DWORD MaxNameLen;
    PVOID ValueBuf;
    DWORD cbName;
    DWORD cbData;
    DWORD dwType;
    BOOL Continue;

    //
    // Find the length of the longest value name and data.
    //
    Status = DmQueryInfoKey(RootKey,
                            NULL,
                            NULL,
                            &ValueCount,
                            &MaxNameLen,
                            &MaxValueLen,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR(Status);
        return;
    }

    NameBuf = CsAlloc((MaxNameLen+1)*sizeof(WCHAR));
    ValueBuf = CsAlloc(MaxValueLen);

    //
    // Enumerate the values
    //
    for (Index=0; Index<ValueCount; Index++) {
        cbName = MaxNameLen+1;
        cbData = MaxValueLen;
        Status = DmEnumValue(RootKey,
                             Index,
                             NameBuf,
                             &cbName,
                             &dwType,
                             ValueBuf,
                             &cbData);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] DmEnumValue for index %1!d! of key %2!ws! failed %3!d!\n",
                       Index,
                       ((PDMKEY)(RootKey))->Name,
                       Status);
        } else {
            Continue = (Callback)(NameBuf,
                                  ValueBuf,
                                  dwType,
                                  cbData,
                                  Context);
            if (!Continue) {
                break;
            }
        }
    }

    CsFree(NameBuf);
    CsFree(ValueBuf);

} // DmEnumValues


DWORD
DmQueryInfoKey(
    IN  HDMKEY  hKey,
    OUT LPDWORD SubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD Values,
    OUT LPDWORD MaxValueNameLen,
    OUT LPDWORD MaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME FileTime
    )

/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY  Key;
    DWORD   Ignored;
    DWORD   Status;

    Key = (PDMKEY)hKey;  

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }

    Status = RegQueryInfoKeyW( Key->hKey,
                             NULL,
                             &Ignored,
                             NULL,
                             SubKeys,
                             MaxSubKeyLen,
                             &Ignored,
                             Values,
                             MaxValueNameLen,
                             MaxValueLen,
                             lpcbSecurityDescriptor,
                             FileTime);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);

} // DmQueryInfoKey


DWORD
DmDeleteKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY                      Key;
    DWORD                       NameLength;
    DWORD                       UpdateLength;
    PDM_DELETE_KEY_UPDATE Update;
    DWORD                       Status;

    Key = (PDMKEY)hKey;

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    NameLength = (lstrlenW(Key->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
        UpdateLength = NameLength + sizeof(DM_DELETE_KEY_UPDATE);

    Update = (PDM_DELETE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);

    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    CopyMemory(Update->Name, Key->Name, (lstrlenW(Key->Name) + 1) * sizeof(WCHAR));
    if (Update->Name[0] != '\0') {
        lstrcatW(Update->Name, L"\\");
    }
    lstrcatW(Update->Name, lpSubKey);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateDeleteKey,
                  sizeof(DM_DELETE_KEY_UPDATE)+NameLength,
                  Update);

    LocalFree(Update);
    return(Status);
}


DWORD
DmDeleteTree(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )
/*++

Routine Description:

    Deletes the specified registry subtree. All subkeys are
    deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL.
        Any subkeys of the specified key will also be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY Subkey;
    DWORD i;
    DWORD Status;
    LPWSTR KeyBuffer=NULL;
    DWORD MaxKeyLen;
    DWORD NeededSize;

    Subkey = DmOpenKey(hKey,
                       lpSubKey,
                       MAXIMUM_ALLOWED);
    if (Subkey == NULL) {
        Status = GetLastError();
        return(Status);
    }

    //
    // Get the size of name buffer we will need.
    //
    Status = DmQueryInfoKey(Subkey,
                            NULL,
                            &MaxKeyLen,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        DmCloseKey(Subkey);
        return(Status);
    }
    KeyBuffer = LocalAlloc(LMEM_FIXED, (MaxKeyLen+1)*sizeof(WCHAR));
    if (KeyBuffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
        DmCloseKey(Subkey);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate the subkeys and apply ourselves recursively to each one.
    //
    i=0;
    do {
        NeededSize = MaxKeyLen+1;
        Status = DmEnumKey(Subkey,
                           i,
                           KeyBuffer,
                           &NeededSize,
                           NULL);
        if (Status == ERROR_SUCCESS) {
            //
            // Call ourselves recursively on this keyname.
            //
            DmDeleteTree(Subkey, KeyBuffer);

        } else {
            //
            // Some odd error, keep going with the next key.
            //
            ++i;
        }

    } while ( Status != ERROR_NO_MORE_ITEMS );

    DmCloseKey(Subkey);

    Status = DmDeleteKey(hKey, lpSubKey);

    if (KeyBuffer != NULL) {
        LocalFree(KeyBuffer);
    }
    return(Status);
}


DWORD
DmEnumValue(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Enumerates the specified value of a registry subkey

Arguments:

    hKey - Supplies the registry key handle

    dwIndex - Supplies the index of the value to be enumerated

    lpValueName - Points to a buffer that receives the name of the value,
        including the terminating null character

    lpcbValueName - Points to a variable that specifies the size, in characters,
        of the buffer pointed to by the lpValueName parameter. This size should
        include the terminating null character. When the function returns, the
        variable pointed to by lpcbValueName contains the number of characters
        stored in the buffer. The count returned does not include the terminating
        null character.

    lpType - Returns the value data type

    lpData - Points to a buffer that receives the data for the value entry. This
        parameter can be NULL if the data is not required.

    lpcbData - Points to a variable that specifies the size, in bytes, of the
        buffer pointed to by the lpData parameter. When the function returns, the
        variable pointed to by the lpcbData parameter contains the number of bytes
        stored in the buffer. This parameter can be NULL, only if lpData is NULL.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY  Key;
    DWORD   Status;
    DWORD   cbValueName = *lpcbValueName;

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }


    Status = RegEnumValueW(Key->hKey,
                         dwIndex,
                         lpValueName,
                         lpcbValueName,
                         NULL,
                         lpType,
                         lpData,
                         lpcbData);

    //
    //  The following code is to mask the registry behavior by which RegEnumValue does not necessarily 
    //  fill in lpValueName (even though we specify a large enough buffer) when lpData buffer is a 
    //  valid buffer but a little too small.
    //
    if ( Status == ERROR_MORE_DATA )
    {
        DWORD       dwError;
        
        dwError = RegEnumValueW( Key->hKey,
                                 dwIndex,
                                 lpValueName,
                                 &cbValueName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

        if ( ( dwError != ERROR_SUCCESS ) && 
             ( dwError != ERROR_MORE_DATA ) )  
        {
            Status = dwError;
        } else
        {
            *lpcbValueName = cbValueName;
        }
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);


}


DWORD
DmAppendToMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )

/*++

Routine Description:

    Adds another string to a REG_MULTI_SZ value. If the value does
    not exist, it will be created.

Arguments:

    hKey - Supplies the key where the value exists. This key must
           have been opened with KEY_READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be appended to the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD ValueLength = 512;
    DWORD ReturnedLength;
    LPWSTR ValueData;
    DWORD StringLength;
    DWORD Status;
    DWORD cbValueData;
    PWSTR s;
    DWORD Type;

    StringLength = (lstrlenW(lpString)+1)*sizeof(WCHAR);
retry:
    ValueData = LocalAlloc(LMEM_FIXED, ValueLength + StringLength);
    if (ValueData == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    cbValueData = ValueLength;
    Status = DmQueryValue(hKey,
                          lpValueName,
                          &Type,
                          (LPBYTE)ValueData,
                          &cbValueData);
    if (Status == ERROR_MORE_DATA) {
        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = cbValueData;
        LocalFree(ValueData);
        goto retry;
    }
    if (Status == ERROR_FILE_NOT_FOUND) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData;

    } else if (Status == ERROR_SUCCESS) {
        //
        // A value already exists. Append our string to the
        // MULTI_SZ.
        //
        s = (PWSTR)((PCHAR)ValueData + cbValueData) - 1;
    } else {
        LocalFree(ValueData);
        return(Status);
    }

    CopyMemory(s, lpString, StringLength);
    s += (StringLength / sizeof(WCHAR));
    *s++ = L'\0';

    Status = DmSetValue(hKey,
                        lpValueName,
                        REG_MULTI_SZ,
                        (CONST BYTE *)ValueData,
                        (DWORD)((s-ValueData)*sizeof(WCHAR)));
    LocalFree(ValueData);

    return(Status);
}


DWORD
DmRemoveFromMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Removes a string from a REG_MULTI_SZ value.

Arguments:

    hKey - Supplies the key where the value exists. This key must
           have been opened with READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be removed from the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPWSTR Buffer=NULL;
    DWORD BufferSize;
    DWORD DataSize;
    LPWSTR Current;
    DWORD CurrentLength;
    DWORD i;
    LPWSTR Next;
    PCHAR Src, Dest;
    DWORD NextLength;
    DWORD MultiLength;


    BufferSize = 0;
    Status = DmQueryString(hKey,
                           lpValueName,
                           REG_MULTI_SZ,
                           &Buffer,
                           &BufferSize,
                           &DataSize);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    MultiLength = DataSize/sizeof(WCHAR);
    Status = ClRtlMultiSzRemove(Buffer,
                                &MultiLength,
                                lpString);
    if (Status == ERROR_SUCCESS) {
        //
        // Set the new value back.
        //
        Status = DmSetValue(hKey,
                            lpValueName,
                            REG_MULTI_SZ,
                            (CONST BYTE *)Buffer,
                            MultiLength * sizeof(WCHAR));

    } else if (Status == ERROR_FILE_NOT_FOUND) {
        Status = ERROR_SUCCESS;
    }

FnExit:
    if (Buffer) LocalFree(Buffer);
    return(Status);
}


DWORD
DmGetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN LPDWORD lpcbSecurityDescriptor
    )
/*++

Routine Description:

    Retrieves a copy of the security descriptor protecting
    the specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key

    RequestedInformation - Specifies a SECURITY_INFORMATION structure that
        indicates the requested security information.

    pSecurityDescriptor - Points to a buffer that receives a copy of the
        requested security descriptor.

    lpcbSecurityDescriptor - Points to a variable that specifies the size,
        in bytes, of the buffer pointed to by the pSecurityDescriptor parameter.
        When the function returns, the variable contains the number of bytes
        written to the buffer.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PDMKEY Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }

    Status = RegGetKeySecurity(Key->hKey,
                               RequestedInformation,
                               pSecurityDescriptor,
                               lpcbSecurityDescriptor);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmSetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    Sets the security on the specified registry key.

Arguments:

    hKey - Supplies a handle to a currently open key.

    SecurityInformation - Supplies the type of security information to
        be set.

    pRpcSecurityDescriptor - Supplies the security information

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PDMKEY Key = (PDMKEY)hKey;

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it

    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    Status = GumSendUpdateEx(GumUpdateRegistry,
                             DmUpdateSetSecurity,
                             4,
                             sizeof(SecurityInformation),
                             &SecurityInformation,
                             (lstrlenW(Key->Name)+1)*sizeof(WCHAR),
                             Key->Name,
                             GetSecurityDescriptorLength(pSecurityDescriptor),
                             pSecurityDescriptor,
                             sizeof(Key->GrantedAccess),
                             &Key->GrantedAccess);

    return(Status);
}



DWORD
DmCommitRegistry(
    VOID
    )
/*++

Routine Description:

    Flushes the registry to disk, producing a new persistent cluster registry state.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    Status = RegFlushKey(DmpRoot);

    RELEASE_LOCK(gLockDmpRoot);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmCommitRegistry failed to flush dirty data %1!d!\n",
                   Status);
    }
    return(Status);
}


DWORD
DmRollbackRegistry(
    VOID
    )
/*++

Routine Description:

    Rolls the registry back to the last previously committed state.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD       Status;
    BOOLEAN     WasEnabled;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
    //hold the key lock as well
    EnterCriticalSection(&KeyLock);


    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmRollbackRegistry failed to restore privilege %1!d!\n",
               Status);
        goto FnExit;
    }

    //
    // Restart the registry watcher thread so it is not trying to use
    // DmpRoot while we are messing with things.
    //
    DmpRestartFlusher();

    //
    // Close any open handles
    //
    DmpInvalidateKeys();


    Status = NtRestoreKey(DmpRoot,
                              NULL,
                              REG_REFRESH_HIVE);

    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                       WasEnabled);

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmRollbackRegistry: NtRestoreKey failed %1!d!\n",
               Status);
        goto FnExit;
    }

    //
    // Reopen handles
    //
    RegCloseKey(DmpRoot);
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRoot);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmRollbackRegistry failed to reopen DmpRoot %1!d!\n",
                   Status);
        goto FnExit;
    }
    DmpReopenKeys();

FnExit:
    //release the locks
    LeaveCriticalSection(&KeyLock);
    RELEASE_LOCK(gLockDmpRoot);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmRollbackRegistry failed to flush dirty data %1!d!\n",
                   Status);
    }

    return(Status);
}


DWORD
DmRtlCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY *  phkResult,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:
    Wrapper function for DmCreateKey. Its definition corresponds to
    ClusterRegCreateKey.  This should be used instead of DmCreateKey
    when passing to ClRtl* funtions.
--*/
{
    DWORD status;
    
    *phkResult = DmCreateKey(
                        hKey,
                        lpSubKey,
                        dwOptions,
                        samDesired,
                        lpSecurityDescriptor,
                        lpDisposition
                   );
    if (*phkResult == NULL)
        status=GetLastError();
    else 
        status = ERROR_SUCCESS;    
    return status;
 }
                    


DWORD
DmRtlOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired,
    OUT HDMKEY * phkResult
    )

/*++

Routine Description:
    Wrapper function for DmOpenKey. Its definition corresponds to
    ClusterRegOpenKey.  This should be used instead of DmOpenKey when 
    passing to ClRtl* funtions. See DmOpenKey for argument description
--*/
{    
    DWORD   status;

    *phkResult = DmOpenKey(
                    hKey,
                    lpSubKey,
                    samDesired
                    );
    if (*phkResult == NULL)
        status=GetLastError();
    else
        status=ERROR_SUCCESS;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmsync.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmsync.c

Abstract:

    Contains the registry synchronization code for the Cluster Database
    Manager.

Author:

    John Vert (jvert) 5/23/1996

Revision History:

--*/
#include "dmp.h"


#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

const WCHAR DmpClusterParametersKeyName[] = L"Cluster";

//
// Private Constants
//
#define CHUNK_SIZE 4096

//
// Private macro
//
#define ClosePipe( _pipe )  \
(_pipe.push)(_pipe.state,   \
             NULL,          \
             0 )            \



//
// Client-Side Utility Routines
//
void
FilePipePush(
    FILE_PIPE_STATE *state,
    unsigned char *pBuffer,
    unsigned long BufferSize
    )
{
    DWORD   dwBytesWritten;
    DWORD   dwStatus;
    
    if (BufferSize != 0) {
        if (!WriteFile (state->hFile,
                   pBuffer,
                   BufferSize,
                   &dwBytesWritten,
                   NULL))
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "FilePipePush :: Write file failed with error %1!u!\n",
                dwStatus);
            RpcRaiseException(dwStatus);                
        }
    }
}

void
FilePipePull(
    FILE_PIPE_STATE *state,
    unsigned char *pBuffer,
    unsigned long BufferSize,
    unsigned long __RPC_FAR *Written
    )
{
    DWORD dwBytesRead;
    BOOL Success;
    DWORD dwStatus;
    
    if (BufferSize != 0) {
        Success = ReadFile (state->hFile,
                            pBuffer,
                            BufferSize,
                            &dwBytesRead,
                            NULL);
        *Written = dwBytesRead;
        if (!Success)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "FilePipePush :: Write file failed with error %1!u!\n",
                dwStatus);
            RpcRaiseException(dwStatus);                
        }
    }
}


void
PipeAlloc (
    FILE_PIPE_STATE *state,
    unsigned long   RequestedSize,
    unsigned char **buf,
    unsigned long  *ActualSize
    )
{
    *buf = state->pBuffer;

    *ActualSize = (RequestedSize < state->BufferSize ?
                   RequestedSize :
                   state->BufferSize);
}


VOID
DmInitFilePipe(
    IN PFILE_PIPE FilePipe,
    IN HANDLE hFile
    )
/*++

Routine Description:

    Initializes a file pipe.

Arguments:

    FilePipe - Supplies a pointer to the file pipe to be initialized

    hFile - Supplies a handle to the file to be transmitted.

Return Value:

    None.

--*/

{
    FilePipe->State.hFile = hFile;
    FilePipe->State.BufferSize = CHUNK_SIZE;
    FilePipe->State.pBuffer = LocalAlloc(LMEM_FIXED, CHUNK_SIZE);
    if (FilePipe->State.pBuffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    FilePipe->Pipe.state = (char __RPC_FAR *)&FilePipe->State;
    FilePipe->Pipe.alloc = (void __RPC_FAR *)PipeAlloc;
    FilePipe->Pipe.push = (void __RPC_FAR *)FilePipePush;
    FilePipe->Pipe.pull = (void __RPC_FAR *)FilePipePull;

}


VOID
DmFreeFilePipe(
    IN PFILE_PIPE FilePipe
    )
/*++

Routine Description:

    Frees a file pipe initialized by DmInitFilePipe

Arguments:

    FilePipe - Supplies the file pipe to be freed.

Return Value:

    None

--*/

{
    LocalFree(FilePipe->State.pBuffer);
}


DWORD
DmPullFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe
    )
/*++

Routine Description:

    Creates a new file and pulls the data down the RPC pipe

Arguments:

    FileName - Supplies the name of the file.

    Pipe - Supplies the RPC pipe to pull the data from.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HANDLE File;
    DWORD Status = ERROR_SUCCESS;
    PUCHAR Buffer;
    DWORD BytesRead;
    //
    // Create a new file to hold the bits from the client.
    //
    File = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      0,
                      NULL);

    if (File == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPullFile failed to create file %1!ws! error %2!d!\n",
                   FileName,
                   Status);
        return(Status);
    } 
    
    Buffer = LocalAlloc(LMEM_FIXED, CHUNK_SIZE);

    if (Buffer == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CloseHandle(File);
        CL_UNEXPECTED_ERROR( Status );
        return (Status);
    } 

    try {
        do {
            (Pipe.pull)(Pipe.state,
                        Buffer,
                        CHUNK_SIZE,
                        &BytesRead);
            if (BytesRead == 0) {
                break;
            }
            if (!WriteFile(File,
                      Buffer,
                      BytesRead,
                      &BytesRead,
                      NULL))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPullFile :: WriteFile to file failed with error %1!ws! error %2!d!\n",
                   FileName, Status);
                break;                       
            }
        } while ( TRUE );
    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = GetExceptionCode();
        ClRtlLogPrint(LOG_ERROR,
                    "[DM] DmPullFile :: Exception code 0x%1!08lx! raised for file %2!ws!\n",
                    Status, FileName);       
    }
    
    LocalFree(Buffer);

    CloseHandle(File);

    return(Status);

}


 DWORD
DmPushFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe
    )
/*++

Routine Description:

    Opens a file and pushes it down the RPC pipe

Arguments:

    FileName - Supplies the name of the file.

    Pipe - Supplies the RPC pipe to push it down.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HANDLE File;
    DWORD Status = ERROR_SUCCESS;
    PUCHAR Buffer;
    DWORD BytesRead;

    //
    // Got a file with the right bits in it. Push it down
    // to the client.
    //
    File = CreateFile(FileName,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL);

    if (File == INVALID_HANDLE_VALUE) {
        ClosePipe( Pipe );
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPushFile failed to open file %1!ws! error %2!d!\n",
                   FileName,
                   Status);
        return(Status);
    } 
    
    Buffer = LocalAlloc(LMEM_FIXED, CHUNK_SIZE);

    if (Buffer == NULL) {
        ClosePipe( Pipe );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CloseHandle(File);
        CL_UNEXPECTED_ERROR( Status );
        return(Status);
    } 

    try {
        do {
            if (!ReadFile(File,
                     Buffer,
                     CHUNK_SIZE,
                     &BytesRead,
                     NULL))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmPushFile failed to read file %1!ws! error %2!d!\n",
                    FileName, Status);
                break;
            }

            (Pipe.push)(Pipe.state,
                        Buffer,
                        BytesRead);

        } while ( BytesRead != 0 );
    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = GetExceptionCode();
        ClRtlLogPrint(LOG_ERROR,
                    "[DM] DmPushFile :: Exception code 0x%1!08lx! raised for file %2!ws!\n",
                    Status, FileName);       
    }
    
    LocalFree(Buffer);

    CloseHandle(File);

    return(Status);
}


DWORD
DmpSyncDatabase(
    IN RPC_BINDING_HANDLE  RpcBinding,
    IN OPTIONAL LPCWSTR Directory
    )
/*++

Routine Description:

    Connects to a remote node and attempts to sync with its
    cluster database.

Arguments:

    RpcBinding - The RPC binding handle to use to sync the database.

    Directory - if present, supplies the directory where CLUSDB should
                be created.

Return Value:

    ERROR_SUCCESS if the database was successfully updated.

    Win32 error otherwise

--*/
{
    DWORD Status;
    WCHAR FileName[MAX_PATH+1];
    FILE_PIPE FilePipe;
    HANDLE hFile;

    //
    // Issue conditional synchronization
    //
    Status = DmCreateTempFileName(FileName);

    if (Status == ERROR_SUCCESS) {
        hFile = CreateFileW(FileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            0,
                            NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            Status = GetLastError();
            CL_UNEXPECTED_ERROR( Status );
        } else {
            DmInitFilePipe(&FilePipe, hFile);
            Status = DmSyncDatabase(RpcBinding,
                                    FilePipe.Pipe);

            DmFreeFilePipe(&FilePipe);
            CloseHandle(hFile);

            if (Status == ERROR_SUCCESS) {

                //
                // A new registry file was successfully downloaded.
                // Install it into the current registry.
                //
                ClRtlLogPrint(LOG_UNUSUAL,"[DM] Obtained new database.\n");

                //acquire the exclusive locks so that no new keys are opened while
                // the registry is being reinstated
                ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
                // hold the key lock as well
                EnterCriticalSection(&KeyLock);

                // Invalidate any open keys
                DmpInvalidateKeys();

                Status = DmInstallDatabase(FileName, Directory, TRUE);

                if (Status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[DM] DmpSyncDatabase failed, error %1!u!.\n",
                               Status);
                }
                // Reopen the keys for read/write access
                DmpReopenKeys();
                // release the locks
                LeaveCriticalSection(&KeyLock);
                RELEASE_LOCK(gLockDmpRoot);

            } else {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[DM] Failed to get a new database, status %1!u!\n",
                    Status
                    );
                CL_UNEXPECTED_ERROR(Status);
            }

            DeleteFile(FileName);
        }
    }

    return(Status);
}


DWORD
DmInstallDatabase(
    IN LPWSTR   FileName,
    IN OPTIONAL LPCWSTR Directory,
    IN BOOL     bDeleteSrcFile
    )
/*++

Routine Description:

    Installs a new cluster registry database from the specified file

Arguments:

    FileName - The name of the file from which to read the registry database
               to install.

    Directory - if present, supplies the directory where the CLUSDB file should
                be created.
                if not present, the current directory is used.

    bDeleteSrcFile - Delete the Source file represented by FileName.                

Return Value:

    ERROR_SUCCESS if the installation completed successfully

    Win32 error code otherwise.

--*/

{
    DWORD    Status;
    BOOLEAN  WasEnabled;
    WCHAR Path[MAX_PATH];
    WCHAR *p;
    WCHAR BkpPath[MAX_PATH];
    
    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);
    if (Status != ERROR_SUCCESS) {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Restore privilege not held by cluster service\n");
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
        return(Status);
    }

    //
    // Restart the registry watcher thread so it is not trying to use
    // DmpRoot while we are messing with things.
    //
    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
    DmpRestartFlusher();

    //
    // Close DmpRoot (it should be the only thing open) so that we can
    // unload the current cluster database.
    //
    RegCloseKey(DmpRoot);
    Status = RegUnLoadKey(HKEY_LOCAL_MACHINE, L"Cluster");
    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
        WasEnabled);
    if (Status == ERROR_SUCCESS) {
        //
        // Get the CLUSDB full pathname.
        //
        if (Directory == NULL) {
            Status = GetModuleFileName(NULL, Path, MAX_PATH);
            if (Status == 0) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[DM] Couldn't find cluster database\n");
                Status = GetLastError();
            } else {
                Status = ERROR_SUCCESS;
                p=wcsrchr(Path, L'\\');
                if (p != NULL) {
                    *p = L'\0';
                    wcscpy(BkpPath, Path);
#ifdef   OLD_WAY
                    wcscat(Path, L"\\CLUSDB");
#else    // OLD_WAY
                    wcscat(Path, L"\\"CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY
                    wcscat(BkpPath, L"\\"CLUSTER_DATABASE_TMPBKP_NAME);
                } else {
                    CL_UNEXPECTED_ERROR(ERROR_FILE_NOT_FOUND);
                }
            }
        } else {
            lstrcpyW(Path, Directory);
            lstrcpyW(BkpPath, Path);
#ifdef   OLD_WAY
            wcscat(Path, L"\\CLUSDB");
#else    // OLD_WAY
            wcscat(Path, L"\\"CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY
            wcscat(BkpPath, L"\\"CLUSTER_DATABASE_TMPBKP_NAME);
        }
        if (Status == ERROR_SUCCESS) {
            //
            // Now copy the supplied file to CLUSDB
            //
            Status = DmpSafeDatabaseCopy(FileName, Path, BkpPath, bDeleteSrcFile);
            if (Status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[DM] DmInstallDatabase :: DmpSafeDatabaseCopy() failed %1!d!\n",
                           Status);

                // SS:  BUG BUG - we should not reload the old hive
                //on a join, that would be catastrophic to continue
                //on a form, while uploading from a checkpoint file
                // it would be the same
                //
                // Try and reload the old hive
                //
                // Status = DmpLoadHive(Path);
                CL_UNEXPECTED_ERROR(Status);
            } else {
                //
                // Finally, reload the hive.
                //
                Status = DmpLoadHive(Path);
            }
        }
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] RegUnloadKey of existing database failed %1!d!\n",
                   Status);
        goto FnExit;                   
    }

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmInstallDatabase :: failed to load hive %1!d!\n",
               Status);
        goto FnExit;               
    }
    //
    // Reopen DmpRoot
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRoot);
    if ( Status != ERROR_SUCCESS ) {
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // HACKHACK John Vert (jvert) 6/3/1997
    //      There is a bug in the registry with refresh
    //      where the Parent field in the root cell doesn't
    //      get flushed to disk, so it gets blasted if we
    //      do a refresh. Then we crash in unload. So flush
    //      out the registry to disk here to make sure the
    //      right Parent field gets written to disk.
    //
    if (Status == ERROR_SUCCESS) {
        DWORD Dummy=0;
        //
        // Make something dirty in the root
        //
        RegSetValueEx(DmpRoot,
                      L"Valid",
                      0,
                      REG_DWORD,
                      (PBYTE)&Dummy,
                      sizeof(Dummy));
        RegDeleteValue(DmpRoot, L"Valid");
        Status = RegFlushKey(DmpRoot);
        if (Status != ERROR_SUCCESS)
        {
            CL_UNEXPECTED_ERROR(Status);
            ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmInstallDatabase : RegFlushKey failed with error %1!d!\n",
               Status);
        }

    }

FnExit:    
    RELEASE_LOCK(gLockDmpRoot);

    return(Status);
}


DWORD
DmGetDatabase(
    IN HKEY hKey,
    IN LPWSTR  FileName
    )
/*++

Routine Description:

    Writes the registry database to a specified file.

Arguments:

    hKey - Supplies the root of the registry tree to get.

    FileName - The name of the file into which to write the current
               registry database.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    Win32 error code otherwise.

--*/

{
    BOOLEAN  WasEnabled;
    DWORD    Status;
    NTSTATUS Error;

    //
    // Make sure this file does not exist already.
    //
    DeleteFileW(FileName);

    Status = ClRtlEnableThreadPrivilege(SE_BACKUP_PRIVILEGE,
                               &WasEnabled);
    if ( Status != STATUS_SUCCESS ) {
        CL_LOGFAILURE( Status );
        goto FnExit;
    }
    Status = RegSaveKeyW(hKey,
                         FileName,
                         NULL);
    // this is used for checkpointing and shouldnt fail, but if it does we
    // will log an event and delete the file
    if ( Status != ERROR_SUCCESS ) {
        CL_LOGFAILURE( Status );
        CsLogEventData1( LOG_CRITICAL,
                         CS_DISKWRITE_FAILURE,
                         sizeof(Status),
                         &Status,
                         FileName );
        DeleteFileW(FileName);
    }

    Error = ClRtlRestoreThreadPrivilege(SE_BACKUP_PRIVILEGE,
                       WasEnabled);

    if (Error != ERROR_SUCCESS)
    {
        CL_UNEXPECTED_ERROR(Error);
    }
FnExit:
    return(Status);
}

//
//
// Server-side join routines.
//
//
error_status_t
s_DmSyncDatabase(
    IN     handle_t IDL_handle,
    OUT    BYTE_PIPE Regdata
    )
/*++

Routine Description:

    Pushes a new configuration database to a joining node.

Arguments:

    IDL_handle - RPC binding handle, not used.

    Regdata  - The RPC data pipe to use to transfer the data.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    Win32 error code otherwise.

--*/
{
    HANDLE File;
    DWORD Status;
    WCHAR FileName[MAX_PATH+1];

    ClRtlLogPrint(LOG_UNUSUAL, "[DM] Supplying database to joining node.\n");

    Status = DmCreateTempFileName(FileName);

    if (Status == ERROR_SUCCESS) {
        DmCommitRegistry();         // Ensure up-to-date snapshot

        //
        //  Chittur Subbaraman (chitturs) - 01/19/2001
        //
        //  Hold the root lock before trying to save the hive. This is necessary so that
        //  an NtRestoreKey/RegCloseKey on the root key is not in progress at the time
        //  the save is attempted.
        //
        ACQUIRE_EXCLUSIVE_LOCK( gLockDmpRoot );

        Status = DmGetDatabase(DmpRoot,FileName);

        RELEASE_LOCK ( gLockDmpRoot );
        
        if (Status != ERROR_SUCCESS) {
            ClosePipe(Regdata);
            CL_UNEXPECTED_ERROR( Status );
        } else {
            Status = DmPushFile(FileName, Regdata);
            DeleteFile(FileName);
        }
    } else {
        RpcRaiseException( Status );
        ClosePipe(Regdata);
        CL_UNEXPECTED_ERROR( Status );
    }


    ClRtlLogPrint(LOG_UNUSUAL, 
        "[DM] Finished supplying database to joining node.\n"
        );

    return(Status);
}


DWORD
DmCreateTempFileName(
    OUT LPWSTR FileName
    )
/*++

Routine Description:

    Creates a temporary filename for use by the cluster service.

Arguments:

    FileName - Returns the name of the temporary file. The buffer
               pointed to must be big enough for at least MAX_PATH
               characters.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise

--*/

{
    WCHAR   TempPath[MAX_PATH];
    DWORD   Status;
    HANDLE  hFile;

    GetTempPath(sizeof(TempPath)/sizeof(WCHAR),TempPath);

    Status = GetTempFileName(TempPath,L"CLS",0,FileName);
    if (Status == 0) {
        //
        // Somebody has probably set the TMP variable incorrectly.
        // Just use the current directory.
        //
        Status = GetTempFileName(L".", L"CLS",0,FileName);
        if (Status == 0) {
            Status = GetLastError();
            CL_UNEXPECTED_ERROR( Status );
            return(Status);
        }
    }

    //
    //  Open the newly created temp file with rights to modify DACL in the object's SD.
    //
    hFile =  CreateFile( FileName,
                         GENERIC_READ | WRITE_DAC | READ_CONTROL, 
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmCreateTempFile: Failed to open file temp file %1!ws!, Status=%2!u!...\r\n",
                      FileName,
                      Status);
        return ( Status );
    }

    //
    //  Set DACL on the file handle object granting full rights only to admin and owner.
    //
    Status = ClRtlSetObjSecurityInfo( hFile, 
                                      SE_FILE_OBJECT,
                                      GENERIC_ALL,      // for Admins
                                      GENERIC_ALL,      // for Owner
                                      0 );              // for Everyone

    CloseHandle( hFile );

    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmCreateTempFile: ClRtlSetObjSecurityInfo failed for file %1!ws!, Status=%2!u!\r\n",
                      FileName,
                      Status);
        return ( Status );
    }

    return( ERROR_SUCCESS );
}


DWORD
DmpLoadHive(
    IN LPCWSTR Path
    )
/*++

Routine Description:

    Loads the cluster database into HKLM\Cluster

Arguments:

    Path - Supplies the fully qualified filename of the cluster database.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    BOOLEAN  WasEnabled;
    RTL_RELATIVE_NAME   RelativeName;
    OBJECT_ATTRIBUTES TargetKey;
    OBJECT_ATTRIBUTES SourceFile;
    UNICODE_STRING SubKey;
    UNICODE_STRING FileName;
    NTSTATUS Status;
    BOOLEAN ErrorFlag;
    LPWSTR FreeBuffer;

    //
    // If the cluster database is not loaded, load it now.
    //
    ClRtlLogPrint(LOG_NOISE,
               "[DM] Loading cluster database from %1!ws!\n", Path);

    RtlInitUnicodeString(&SubKey, L"\\Registry\\Machine\\Cluster");
    InitializeObjectAttributes(&TargetKey,
                               &SubKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    ErrorFlag = RtlDosPathNameToNtPathName_U(Path,
                                             &FileName,
                                             NULL,
                                             &RelativeName);
    if (!ErrorFlag) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] RtlDosPathNameToNtPathName_U failed\n");
        return ERROR_INVALID_PARAMETER;
    }
    FreeBuffer = FileName.Buffer;
    if (RelativeName.RelativeName.Length) {
        FileName = *((PUNICODE_STRING)&RelativeName.RelativeName);
    } else {
        RelativeName.ContainingDirectory = NULL;
    }
    InitializeObjectAttributes(&SourceFile,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);
    if (Status != ERROR_SUCCESS) {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Restore privilege not held by cluster service\n");
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
    } else {
        //
        //   Note : Sunitas
        //   There used to be a registry bug where if we set REG_NO_LAZY_FLUSH and the hive
        //   is corrupt, the system crashes. So we used to first try loading it without the
        //   REG_NO_LAZY_FLUSH. If that works, unload it and do it again with
        //   REG_NO_LAZY_FLUSH.  The registry folks claim that is fixed..so I am
        //   removing that hack
        //
        Status = NtLoadKey2(&TargetKey,
                            &SourceFile,
                            REG_NO_LAZY_FLUSH);
        if (Status != STATUS_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpLoadHive: NtLoadKey2 failed with error, %1!u!\n",
                    Status);
            CL_UNEXPECTED_ERROR(Status);
        }        
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    return(Status);

}

DWORD DmpUnloadHive()
/*++

Routine Description:

    Unloads the cluster database from HKLM\Cluster.  This is called at initialization
    to make sure that the database is loaded with the correct flags.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    BOOLEAN  WasEnabled;
    OBJECT_ATTRIBUTES TargetKey;
    UNICODE_STRING SubKey;
    NTSTATUS Status;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpUnloadHive: unloading the hive\r\n");

    RtlInitUnicodeString(&SubKey, L"\\Registry\\Machine\\Cluster");
    InitializeObjectAttributes(&TargetKey,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                &WasEnabled);
    if (Status != ERROR_SUCCESS) 
    {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpUnloadHive:: Restore privilege not held by cluster service\n");
        } 
        else 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpUnloadHive: Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
        goto FnExit;
    }

    Status = NtUnloadKey(&TargetKey);
    if (Status != STATUS_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpUnloadHive: NtUnloadKey failed with error, %1!u!\n",
            Status);
        CL_UNEXPECTED_ERROR(Status);
    }

    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
        WasEnabled);

FnExit:
    return(Status);

}

DWORD
DmpSafeDatabaseCopy(
    IN LPCWSTR  FileName,
    IN LPCWSTR  Path,
    IN LPCWSTR  BkpPath,
    IN BOOL     bDeleteSrcFile    
    )
/*++

Routine Description:

    Loads the cluster database into HKLM\Cluster

Arguments:
    FileName - Supplies the fully qualified filename of the new cluster database
    Path - Supplies the fully qualified filename of the cluster database.
    BkpPath - Supplies the fully qualified filename of the cluster database temporary
        backup
    bDeleteSrcFile - Specifies whether the source file may be deleted        

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;

    //set the file attributes of the bkp file to be normal so that we can
    //overwrite it if it exists
    if (!SetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
               "[DM] DmpSafeDatabaseCopy:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
                BkpPath, GetLastError());
        //this may fail because the file doesnt exist but that is not fatal so we ignore the error                
    }

    //Save the database to a temp database that can be used for recovery
    //copyfileex preserves attributes of the old file
    if (!CopyFileEx(Path, BkpPath, NULL, NULL, NULL, 0))
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpSafeDatabaseCopy:: Failed to create a backup copy of database, Status=%1!u!\n",
            dwStatus);
        goto FnExit;
    }

    //hide the file since users are not supposed to know about it
    if (!SetFileAttributes(BkpPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY))
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmpSafeDatabaseCopy:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
                BkpPath, dwStatus);
        goto FnExit;

    }

    //set DatabaseCopyInProgress key to  be TRUE
    dwStatus = DmpSetDwordInClusterServer( L"ClusterDatabaseCopyInProgress",1);
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpSafeDatabaseCopy:: Failed to set ClusterDatabaseCopyInProgress, Status=%1!u!\n",
            dwStatus);
        goto FnExit;            
    }
    

    //delete clusdb
    if (!DeleteFile(Path))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
               "[DM] DmpSafeDatabaseCopy:: Couldnt delete the database file, Error=%1!u!\n",
               GetLastError());
        //this is not fatal, we will still try the move file
    }
    //copy the new database to clusdb
    if (bDeleteSrcFile)
    {
        //the source file may be deleted, this is true at join sync time
        //the source file is a temporary file
        if (!MoveFileEx(FileName, Path, MOVEFILE_REPLACE_EXISTING |
                    MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH))
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpSafeDatabaseCopy:: Failed to move %1!ws! to %2!ws!, Status=%3!u!\n",
                FileName, Path, dwStatus);
            goto FnExit;                
        }
    }        
    else
    {
        //the source file must not be deleted use copy..this is true
        //when the logs are being rolled at form and we are uploading
        //the database from a checkpoint file
        if (!CopyFileEx(FileName, Path, NULL, NULL, NULL, 0))
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpSafeDatabaseCopy:: Failed to copy %1!ws! to %2!ws!, Status=%3!u!\n",
                FileName, Path, dwStatus);
            goto FnExit;
        }
    }

    //set databaseCopyInProgress key to FALSE
    dwStatus = DmpSetDwordInClusterServer( L"ClusterDatabaseCopyInProgress", 0);
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpSafeDatabaseCopy:: Failed to set ClusterDatabaseCopyInProgress, Status=%1!u!\n",
            dwStatus);
        goto FnExit;            
    }

    //now that clusdb is safely copied, we can delete the backup
    //for that we need to set the file attribute to normal
    if (!SetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpSafeDatabaseCopy:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
            BkpPath, GetLastError());
                               
    }

    //delete the backup
    if (!DeleteFile(BkpPath))
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpSafeDatabaseCopy:: Failed to delete bkp database file %1!ws!, Status=%2!u!\n",
            BkpPath, GetLastError());
        //this is not fatal so ignore the error                        
    }

FnExit:
    return(dwStatus);

}

DWORD
DmpSetDwordInClusterServer(
    LPCWSTR lpszValueName,
    DWORD   dwValue
    )

/*++

Routine Description:

    Sets the value specified under  
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
    to the value specified by dwValue.  It flushes the change.

Arguments:

    lpszValueName : Sets the value for the name specified by lpszValueName
    dwValue : The value to set to.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/
{

    HKEY     hKey;
    DWORD    dwStatus = ERROR_SUCCESS;     // returned by registry API functions

    // Attempt to open an existing key in the registry.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_WRITE,
                                &hKey );

    // Was the registry key opened successfully ?

    if ( dwStatus == ERROR_SUCCESS )
    {

        DWORD dwValueType = REG_DWORD;
        DWORD dwDataBufferSize = sizeof( DWORD );

        dwStatus = RegSetValueExW( hKey,
                                    lpszValueName,
                                    0, // reserved
                                    dwValueType,
                                    (LPBYTE) &dwValue,
                                    dwDataBufferSize );

        //Flush the key
        RegFlushKey(hKey);
        
        // Close the registry key.

        RegCloseKey( hKey );

        // Was the value set successfully?
    }

    return(dwStatus);

} // DmpSetDwordInClusterServer


DWORD DmpGetDwordFromClusterServer(
    IN LPCWSTR lpszValueName,
    OUT LPDWORD pdwValue,
    IN  DWORD   dwDefaultValue
    )
/*++

Routine Description:

    Gets the DWORD value specified in lpszValueName.
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server".
    If the value doesnt exist, the default is returned.

Arguments:

    lpszValueName :  The Value to read.
    pdwValue : Returns the value of the key specified by lpszValueName
    dwDefaultValue: The value to be returned if the specified key doesnt exist
        or in case of error.

Return Value:

    ERROR_SUCCESS if everything worked ok or if the key wasnt present.

--*/
    
{
    HKEY  hKey = NULL;
    DWORD dwStatus;     // returned by registry API functions
    DWORD dwClusterInstallState;
    DWORD dwValueType;
    DWORD dwDataBufferSize = sizeof( DWORD );

    *pdwValue = dwDefaultValue;
    // Read the registry key that indicates whether cluster files are installed.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_READ,
                                &hKey );

    // Was the registry key opened successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwValue = dwDefaultValue;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

    // Read the entry.
    dwStatus = RegQueryValueExW( hKey,
                                  lpszValueName,
                                  0, // reserved
                                  &dwValueType,
                                  (LPBYTE) pdwValue,
                                  &dwDataBufferSize );

    // Was the value read successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwValue = dwDefaultValue;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

FnExit:    
    // Close the registry key.
    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    return ( dwStatus );

} //*** DmpGetDwordFromClusterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\evtlog\evtlogp.h ===
#ifndef _EVTLOGP_H
#define _EVTLOGP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtlog.h

Abstract:

    Private header file for the eventlogging component for
    the NT Cluster Service

Author:

    Sunita Shrivastava (sunitas) 5-Dec-1996.

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"
#include "api_rpc.h"

#define LOG_CURRENT_MODULE LOG_MODULE_EVTLOG


DWORD EvpPropPendingEvents(
	IN DWORD 			dwEventInfoSize,
	IN PPACKEDEVENTINFO	pPackedEventInfo);

DWORD
EvpClusterEventHandler(
    IN CLUSTER_EVENT  Event,
    IN PVOID          Context
    );
	

#endif //_EVTLOGP_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\dm\dmupdate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmupdate.c

Abstract:

    Contains the global update handlers for the Configuration Database Manager

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"

#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

VOID
DmpUpdateSequence(
    VOID
    );


DWORD
DmpUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Update handler for registry updates

Arguments:

    Context - Supplies the update context. This is the message type

    SourceNode - Supplies whether or not the update originated on this node.

    BufferLength - Supplies the length of the update.

    Buffer - Supplies a pointer to the buffer.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    if ( gbDmpShutdownUpdates ) return( ERROR_SUCCESS );

    switch (Context) {

        case DmUpdateDeleteKey:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteKey \n");
            Status = DmpUpdateDeleteKey(SourceNode,
                                        (PDM_DELETE_KEY_UPDATE)Buffer);
            break;

        case DmUpdateSetValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateSetValue \n");
            Status = DmpUpdateSetValue(SourceNode,
                                       (PDM_SET_VALUE_UPDATE)Buffer);
            break;

        case DmUpdateDeleteValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteValue\n");
            Status = DmpUpdateDeleteValue(SourceNode,
                                          (PDM_DELETE_VALUE_UPDATE)Buffer);
            break;

        case DmUpdateJoin:
            ClRtlLogPrint(LOG_UNUSUAL,"[DM] DmUpdateJoin\n");
            Status = ERROR_SUCCESS;
            break;

        default:
            Status = ERROR_INVALID_DATA;
            CL_UNEXPECTED_ERROR(ERROR_INVALID_DATA);
            break;
    }
    return(Status);
}


DWORD
DmpUpdateDeleteKey(
    IN BOOL SourceNode,
    IN PDM_DELETE_KEY_UPDATE Update
    )

/*++

Routine Description:

    Deletes the specified registry key on this node.

Arguments:

    SourceNode - Supplies whether or not this node is the one that originated
        the update.

    Buffer - Supplies the DM_DELETE_KEY_UPDATE structure with the information necessary
        to delete the key.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD Disposition;
    DWORD Status;
    HKEY Key;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegDeleteKeyW(DmpRoot, Update->Name);
    if (SourceNode) {
        *Update->lpStatus = Status;
    }
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(Update->Name, CLUSTER_CHANGE_REGISTRY_NAME);
    }

    RELEASE_LOCK(gLockDmpRoot);

    return(Status);
}


DWORD
DmpUpdateSetValue(
    IN BOOL SourceNode,
    IN PDM_SET_VALUE_UPDATE Update
    )

/*++

Routine Description:

    Updates the specified registry value on this node.

Arguments:

    SourceNode - Supplies whether or not this node is the one that originated
        the update.

    Buffer - Supplies the DM_SET_VALUE_UPDATE structure with the information necessary
        to set the value.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD Status;
    HKEY Key;
    LPWSTR ValueName;
    CONST BYTE *lpData;

    ValueName = (LPWSTR)((PUCHAR)Update + Update->NameOffset);

    switch( Update->Type )
    {
        case REG_DWORD:
            ClRtlLogPrint(LOG_NOISE,
               "[DM] Setting value of %1!ws! for key %2!ws! to 0x%3!08lx!\n",
               ValueName,
               Update->KeyName,
               *(PDWORD)((CONST BYTE *)Update + Update->DataOffset));
            break;

        case REG_SZ:
            ClRtlLogPrint(LOG_NOISE,
               "[DM] Setting value of %1!ws! for key %2!ws! to %3!ws!\n",
               ValueName,
               Update->KeyName,
               (CONST BYTE *)Update + Update->DataOffset);
            break;

        default:
            ClRtlLogPrint(LOG_NOISE,
               "[DM] Setting value of %1!ws! for key %2!ws!\n",
               ValueName,
               Update->KeyName);
            break;
    }

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegOpenKeyExW(DmpRoot,
                           Update->KeyName,
                           0,
                           KEY_SET_VALUE,
                           &Key);

    if (Status != ERROR_SUCCESS) {
        if (SourceNode) {
            *Update->lpStatus = Status;
        }
        ClRtlLogPrint(LOG_NOISE,
                   "[DM] SetValue failed to open target key %1!ws!\n",
                   Update->KeyName);
        goto FnExit;
    }

    lpData = (CONST BYTE *)Update + Update->DataOffset;

    Status = RegSetValueExW(Key,
                            ValueName,
                            0,
                            Update->Type,
                            lpData,
                            Update->DataLength);
    RegCloseKey(Key);
    if (SourceNode) {
        *Update->lpStatus = Status;
    }
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(Update->KeyName, CLUSTER_CHANGE_REGISTRY_VALUE);
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmpUpdateDeleteValue(
    IN BOOL SourceNode,
    IN PDM_DELETE_VALUE_UPDATE Update
    )

/*++

Routine Description:

    Deletes the specified registry value on this node.

Arguments:

    SourceNode - Supplies whether or not this node is the one that originated
        the update.

    Buffer - Supplies the DM_DELETE_VALUE_UPDATE structure with the information necessary
        to delete the value.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD Status;
    HKEY Key;
    LPWSTR ValueName;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
    Status = RegOpenKeyExW(DmpRoot,
                           Update->KeyName,
                           0,
                           KEY_SET_VALUE,
                           &Key);
    if (Status != ERROR_SUCCESS) {
        if (SourceNode) {
            *Update->lpStatus = Status;
        }
        goto FnExit;
    }

    ValueName = (LPWSTR)((PUCHAR)Update + Update->NameOffset);

    Status = RegDeleteValueW(Key, ValueName);
    RegCloseKey(Key);
    if (SourceNode) {
        *Update->lpStatus = Status;
    }
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(Update->KeyName, CLUSTER_CHANGE_REGISTRY_VALUE);
    }


FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


VOID
DmpUpdateSequence(
    VOID
    )
/*++

Routine Description:

    Updates the sequence number stored in the registry.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD Sequence;
    DWORD Status;

    Sequence = GumGetCurrentSequence(GumUpdateRegistry);

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegSetValueExW(DmpRoot,
                            CLUSREG_NAME_CLUS_REG_SEQUENCE,
                            0,
                            REG_DWORD,
                            (BYTE CONST *)&Sequence,
                            sizeof(Sequence));

    RELEASE_LOCK(gLockDmpRoot);

    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
    }

}


DWORD
DmpUpdateCreateKey(
    IN BOOL SourceNode,
    IN PDM_CREATE_KEY_UPDATE CreateUpdate,
    IN LPCWSTR KeyName,
    IN OPTIONAL LPVOID lpSecurityDescriptor
    )
/*++

Routine Description:

    GUM dispatch routine for creating a registry key.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    CreateUpdate - Supplies key creation options.

    KeyName - Supplies the key name

    lpSecurityDescriptor - if present, supplies the security descriptor to be
        applied when the key is created.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Disposition;
    DWORD Status;
    HKEY Key;
    SECURITY_ATTRIBUTES SecurityAttributes;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;


    if (CreateUpdate->SecurityPresent) {
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = FALSE;
        SecurityAttributes.lpSecurityDescriptor = lpSecurityDescriptor;
        lpSecurityAttributes = &SecurityAttributes;
    } else {
        lpSecurityAttributes = NULL;
    }


    ClRtlLogPrint(LOG_NOISE,
               "[DM] DmpUpdateCreateKey: Creating key <%1!ws!>...\n",
               KeyName);

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegCreateKeyEx(DmpRoot,
                            KeyName,
                            0,
                            NULL,
                            CreateUpdate->dwOptions,
                            CreateUpdate->samDesired,
                            lpSecurityAttributes,
                            &Key,
                            &Disposition);
    if (SourceNode) {
        *CreateUpdate->lpDisposition = Disposition;
        *CreateUpdate->phKey = Key;
    } else {
        RegCloseKey(Key);
    }
    if ((Status == ERROR_SUCCESS) &&
        (Disposition == REG_CREATED_NEW_KEY)) {
        DmpUpdateSequence();
        DmpReportNotify(KeyName, CLUSTER_CHANGE_REGISTRY_NAME);
    }

    RELEASE_LOCK(gLockDmpRoot);

    return(Status);
}


DWORD
DmpUpdateSetSecurity(
    IN BOOL SourceNode,
    IN PSECURITY_INFORMATION pSecurityInformation,
    IN LPCWSTR KeyName,
    IN PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    IN LPDWORD pGrantedAccess
    )
/*++

Routine Description:

    GUM dispatch routine for creating a registry key.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    pSecurityInformation - Supplies a pointer to the security information

    KeyName - Supplies the key name

    lpSecurityDescriptor - Supplies the security descriptor to be
        applied.

    pGrantedAccess - Supplies the access that the key was opened with.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    HKEY Key;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegOpenKeyExW(DmpRoot,
                           KeyName,
                           0,
                           *pGrantedAccess,
                           &Key);
    if (Status != ERROR_SUCCESS) {
        if ((Status == ERROR_ACCESS_DENIED) ||
            (Status == ERROR_PRIVILEGE_NOT_HELD)) {
            BOOLEAN Enabled;

            Status = ClRtlEnableThreadPrivilege(SE_SECURITY_PRIVILEGE,
                                        &Enabled);
            if (Status == ERROR_SUCCESS) {
                Status = RegOpenKeyExW(DmpRoot,
                                       KeyName,
                                       0,
                                       *pGrantedAccess,
                                       &Key);
                ClRtlRestoreThreadPrivilege(SE_SECURITY_PRIVILEGE,
                                   Enabled);
            }

        }
        if (Status != ERROR_SUCCESS) {
            goto FnExit;
        }
    }

    Status = RegSetKeySecurity(Key,
                               *pSecurityInformation,
                               lpSecurityDescriptor);
    RegCloseKey(Key);
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(KeyName, CLUSTER_CHANGE_REGISTRY_ATTRIBUTES);
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\ep\event.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    event.c

Abstract:

    Event Engine for the Event Processor component of the Cluster Service.

Author:

    Rod Gamache (rodga) 28-Feb-1996


Revision History:

--*/

#include "epp.h"

//
// Event Processor State.
//

ULONG EventProcessorState = EventProcessorStateIniting;


//
// Global data
//



//
// Local data
//

EVENT_DISPATCH_TABLE EventDispatchTable[NUMBER_OF_COMPONENTS] = {0};
EVENT_DISPATCH_TABLE SyncEventDispatchTable[NUMBER_OF_COMPONENTS] = {0};
PCLRTL_BUFFER_POOL   EventPool = NULL;
DWORD EventHandlerCount = 0;
DWORD SyncEventHandlerCount = 0;
DWORD EventBufferOffset = EpQuadAlign(sizeof(CLRTL_WORK_ITEM));


//
// Functions
//



DWORD
WINAPI
EpInitialize(
    VOID
    )

/*++

Routine Description:

     Event Processor Initialize routine.

Arguments:

    None.

Return Value:

     A Win32 status code.

--*/

{

    DWORD      status = ERROR_SUCCESS;
    DWORD      index;
    DWORD      i;
    PVOID      eventArray[EP_MAX_CACHED_EVENTS];


    ClRtlLogPrint(LOG_NOISE,"[EP] Initialization...\n");

    //
    // Create the event pool. The event structure must be quadword aligned.
    //
    EventPool = ClRtlCreateBufferPool(
                    EventBufferOffset + sizeof(EP_EVENT),
                    EP_MAX_CACHED_EVENTS,
                    EP_MAX_ALLOCATED_EVENTS,
                    NULL,
                    NULL
                    );

    if (EventPool == NULL) {
        ClRtlLogPrint(LOG_NOISE,"[EP] Unable to allocate event buffer pool\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Prime the event pool cache to minimize the chance of an allocation
    // failure.
    //
    ZeroMemory(&(eventArray[0]), sizeof(PVOID) * EP_MAX_CACHED_EVENTS);

    for (i=0; i<EP_MAX_CACHED_EVENTS; i++) {
        eventArray[i] = ClRtlAllocateBuffer(EventPool);

        if (eventArray[i] == NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[EP] Unable to prime event buffer cache, buf num %1!u!!!!\n",
                i
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            CsInconsistencyHalt( status );
        }
    }

    for (i=0; i<EP_MAX_CACHED_EVENTS; i++) {
        if (eventArray[i] != NULL) {
            ClRtlFreeBuffer(eventArray[i]);
        }
    }

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    return(ERROR_SUCCESS);

}  // EpInitialize


void
EppLogEvent(
    IN CLUSTER_EVENT Event
    )
{

    switch( Event ) {

    case CLUSTER_EVENT_ONLINE:
        ClRtlLogPrint(LOG_NOISE,"[EP] Cluster Service online event received\n");
        break;

    case CLUSTER_EVENT_SHUTDOWN:
        ClRtlLogPrint(LOG_NOISE,"[EP] Cluster Service shutdown event received\n");
        break;

    case CLUSTER_EVENT_NODE_UP:
        ClRtlLogPrint(LOG_NOISE,"[EP] Node up event received\n");
        break;

    case CLUSTER_EVENT_NODE_DOWN:
        ClRtlLogPrint(LOG_NOISE,"[EP] Node down event received\n");
        break;

    case CLUSTER_EVENT_NODE_DOWN_EX:
        ClRtlLogPrint(LOG_NOISE,"[EP] Nodes down event received\n");
        break;

    default:
        break;

    }  // switch( Event )
}



VOID
EpEventHandler(
    IN PCLRTL_WORK_ITEM  WorkItem,
    IN DWORD             Ignored1,
    IN DWORD             Ignored2,
    IN ULONG_PTR         Ignored3
    )

/*++

--*/

{
    DWORD      index;
    PEP_EVENT  Event = (PEP_EVENT) (((char *) WorkItem) + EventBufferOffset);


    if (Event->Id == CLUSTER_EVENT_SHUTDOWN) {
        //
        // To shutdown, we just need to stop the service.
        //
        CsStopService();
    }
        
    //
    // Now deliver the event to all of the other components.
    // Eventually, we might filter events based on the mask
    // returned on the init call.
    //

    for ( index = 0; index < NUMBER_OF_COMPONENTS; index++ ) {
        if ( EventDispatchTable[index].EventRoutine == NULL ) {
            continue;
        }

        (EventDispatchTable[index].EventRoutine)(
                                                Event->Id,
                                                Event->Context
                                                );
    }

    //
    // Handle any post processing that might be required.
    //
    if (Event->Flags & EP_CONTEXT_VALID) {
        if (Event->Flags & EP_DEREF_CONTEXT) {
            OmDereferenceObject(Event->Context);
        }

        if (Event->Flags & EP_FREE_CONTEXT) {
            LocalFree(Event->Context);
        }
    }

    ClRtlFreeBuffer(WorkItem);

    return;
}

DWORD
WINAPI
EpPostSyncEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    )
/*++

Routine Description:

    Synchronously posts an event to the rest of the cluster

Arguments:

    Event - Supplies the type of event

    Flags - Supplies any post processing that should be done to the
            context after all dispatch handlers have been called

    Context - Supplies the context.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes:

    If flags is NULL, then we assume Context points to a standard (OM known)
    object, and we'll reference and dereference that object appropriately.

    If flags is non-NULL, then don't reference/dereference the Context object.

--*/

{
    DWORD      index;

    // log event
    EppLogEvent(Event);

    //
    // Reference to keep the context object around.
    //
    if (Context) {
        if ( Flags == 0) {
	    OmReferenceObject( Context );
	    Flags = EP_DEREF_CONTEXT;
	}

	Flags |= EP_CONTEXT_VALID;
    }
    
    //
    // Now deliver the event to all of the other components.
    // Eventually, we might filter events based on the mask
    // returned on the init call.
    //

    for ( index = 0; index < NUMBER_OF_COMPONENTS; index++ ) {
        if ( SyncEventDispatchTable[index].EventRoutine == NULL ) {
            continue;
        }

        (SyncEventDispatchTable[index].EventRoutine)(
                                                Event,
                                                Context
                                                );
    }

    //
    // Handle any post processing that might be required.
    //
    if (Flags & EP_CONTEXT_VALID) {
        if (Flags & EP_DEREF_CONTEXT) {
            OmDereferenceObject(Context);
        }

        if (Flags & EP_FREE_CONTEXT) {
            LocalFree(Context);
        }
    }

    return (ERROR_SUCCESS);
}


DWORD
WINAPI
EpPostEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    )
/*++

Routine Description:

    Asynchronously posts an event to the rest of the cluster

Arguments:

    Event - Supplies the type of event

    Flags - Supplies any post processing that should be done to the
            context after all dispatch handlers have been called

    Context - Supplies the context.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes:

    If flags is NULL, then we assume Context points to a standard (OM known)
    object, and we'll reference and dereference that object appropriately.

    If flags is non-NULL, then don't reference/dereference the Context object.

--*/

{
    PCLRTL_WORK_ITEM  workItem;
    PEP_EVENT         event;
    DWORD             status;

    // log event
    EppLogEvent(Event);

    // handle async handlers.
    workItem = ClRtlAllocateBuffer(EventPool);

    if (workItem != NULL) {

        ClRtlInitializeWorkItem(workItem, EpEventHandler, NULL);

        //
        // Reference to keep the context object around.
        //
        if (Context) {
            if ( Flags == 0) {
                OmReferenceObject( Context );
                Flags = EP_DEREF_CONTEXT;
            }

            Flags |= EP_CONTEXT_VALID;
        }

        event = (PEP_EVENT) ( ((char *) workItem) + EventBufferOffset );


        event->Id = Event;
        event->Flags = Flags;
        event->Context = Context;


        status = ClRtlPostItemWorkQueue(CsCriticalWorkQueue, workItem, 0, 0);

        if (status == ERROR_SUCCESS) {
            return(ERROR_SUCCESS);
        }

        ClRtlLogPrint(LOG_NOISE,
            "[EP] Failed to post item to critical work queue, status %1!u!\n",
            status
            );

        ClRtlFreeBuffer(workItem);

        return(status);
    }

    ClRtlLogPrint(LOG_NOISE,"[EP] Failed to allocate an event buffer!!!\n");

    return(ERROR_NOT_ENOUGH_MEMORY);
}



VOID
EpShutdown(
   VOID
   )

/*++

Routine Description:

    This routine shuts down the components of the Cluster Service.

Arguments:

    None.

Returns:

    None.

--*/

{
    if ( EventPool ) {
        ClRtlDestroyBufferPool(EventPool);
    }

    // Now shutdown the event processor by just cleaning up.

}


DWORD
EpRegisterEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    )
/*++

Routine Description:

    Registers an event handler for the specified type of event.

Arguments:

    EventMask - Supplies the mask of events that should be delivered.

    EventRoutine - Supplies the event routine that should be called.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    CL_ASSERT(EventHandlerCount < NUMBER_OF_COMPONENTS);

    EventDispatchTable[EventHandlerCount].EventMask = EventMask;
    EventDispatchTable[EventHandlerCount].EventRoutine = EventRoutine;

    ++EventHandlerCount;
    return(ERROR_SUCCESS);
}


DWORD
EpRegisterSyncEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    )
/*++

Routine Description:

    Registers an event handler for the specified type of event. The handler
    is called in the context of the dispatcher. Sync event handlers are to
    be used by components that require a barrier semanitcs in handling
    events e.g. gum, dlm , ...etc.

Arguments:

    EventMask - Supplies the mask of events that should be delivered.

    EventRoutine - Supplies the event routine that should be called.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{

    CL_ASSERT(SyncEventHandlerCount < NUMBER_OF_COMPONENTS);

    // XXX: Do we need locking here in case this is not called from init() ?

    SyncEventDispatchTable[EventHandlerCount].EventMask = EventMask;
    SyncEventDispatchTable[EventHandlerCount].EventRoutine = EventRoutine;

    ++SyncEventHandlerCount;
    return(ERROR_SUCCESS);
}


DWORD EpInitPhase1()
{
    DWORD dwError=ERROR_SUCCESS;

//    ClRtlLogPrint(LOG_NOISE,"[EP] EpInitPhase1\n");

    return(dwError);
}


DWORD
WINAPI
EpGumUpdateHandler(
    IN DWORD    Context,
    IN BOOL     SourceNode,
    IN DWORD    BufferLength,
    IN PVOID    Buffer
    )
{
    DWORD Status;

    switch (Context)
    {

        default:
            Status = ERROR_INVALID_DATA;
            CsInconsistencyHalt(ERROR_INVALID_DATA);
            break;
    }
    return(Status);

}



/****
@func   WORD| EpClusterWidePostEvent| This generates an event notification on
        all the cluster nodes.

@parm   IN EVENT | Event | The event to be posted.

@parm   IN DWORD | dwFlags | The flags associated with this event.
        If zero, pContext points to one of the om objects.

@parm   IN PVOID | pContext | A pointer to an object or a buffer.

@parm   IN DWORD | cbContext | The size of pContext if it is a buffer.

@rdesc  Returns ERROR_SUCCESS for success, else returns the error code.

@comm   <f EpClusWidePostEvent>
@xref
****/
DWORD
WINAPI
EpClusterWidePostEvent(
    IN CLUSTER_EVENT    Event,
    IN DWORD            dwFlags,
    IN PVOID            pContext,
    IN DWORD            cbContext
    )
{
    DWORD Status;
    DWORD cbObjectId = 0;
    PVOID pContext1 = pContext;
    DWORD cbContext1 = cbContext;
    PVOID pContext2 = NULL;
    DWORD cbContext2 = 0;


    //
    // We have do the work of EpPostEvent here because GUM
    // does not correctly pass a NULL pointer.
    //
    if (pContext) {
        if (dwFlags == 0) {
            //
            // The context is a pointer to a cluster object.
            // The caller is assumed to have a reference on the object
            // so it won't go away while we are using it.
            //
            DWORD dwObjectType = OmObjectType(pContext);
            LPCWSTR lpszObjectId = OmObjectId(pContext);

            cbContext1 = (lstrlen(lpszObjectId) + 1 ) * sizeof(WCHAR);
            pContext1 = (PVOID) lpszObjectId;

            pContext2 = &dwObjectType;
            cbContext2 = sizeof(dwObjectType);

            dwFlags = EP_DEREF_CONTEXT;
        }

        dwFlags |= EP_CONTEXT_VALID;
    }

    Status = GumSendUpdateEx(GumUpdateFailoverManager,
                             EmUpdateClusWidePostEvent,
                             4,
                             sizeof(CLUSTER_EVENT),
                             &Event,
                             sizeof(DWORD),
                             &dwFlags,
                             cbContext1,
                             pContext1,
                             cbContext2,
                             pContext2
                             );

    return(Status);
}



/****
@func   WORD| EpUpdateClusWidePostEvent| The update handler for
        EmUpdateClusWidePostEvent.

@parm   IN BOOL | SourceNode | If this is the source of origin of the gum update.

@parm   IN EVENT | pEvent | A pointer to the event to be posted.

@parm   IN LPDWORD | pdwFlags | A pointer to the flags associated with this event.

@parm   IN PVOID | pContext1 | A pointer to an object or a buffer.

@parm   IN PVOID | pContext2 | A pointer to an object type if pContext1 is a
                               pointer to an object. Else unused.

@rdesc  Returns ERROR_SUCCESS for success, else returns the error code.

@comm   <f EpClusWidePostEvent>
@xref
****/
DWORD
EpUpdateClusWidePostEvent(
    IN BOOL             SourceNode,
    IN PCLUSTER_EVENT   pEvent,
    IN LPDWORD          pdwFlags,
    IN PVOID            pContext1,
    IN PVOID            pContext2
)
{
    DWORD   Status = ERROR_INVALID_PARAMETER;


    if (*pdwFlags & EP_CONTEXT_VALID)
    {
        if (*pdwFlags & EP_DEREF_CONTEXT) {
            //
            // pContext1 is a pointer to an object ID.
            // pContext2 is a pointer to an object type.
            //
            LPCWSTR  lpszObjectId = (LPCWSTR) pContext1;
            DWORD    dwObjectType = *((LPDWORD) pContext2);
            PVOID    pObject = OmReferenceObjectById(
                                   dwObjectType,
                                   lpszObjectId
                                   );

            if (!pObject)
            {
                //
                // Return success if object is not found! The object was
                // probably deleted.
                //
                return(ERROR_SUCCESS);
            }

            Status  = EpPostEvent(*pEvent, *pdwFlags, pObject);
        }
        else {
            //
            // pContext1 is a buffer. If the FREE_BUFFER flag is on, turn
            // it off since the memory is owned by GUM.
            // pContext2 is ignored.
            //
            *pdwFlags = *pdwFlags & ~EP_FREE_CONTEXT;

            Status  = EpPostEvent(*pEvent, *pdwFlags, pContext1);
        }
    }

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\evtlog\simpleq.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    simpleq.c

Abstract:

    Simple non-blocking queue, that allows
    multiple concurrent data providers
    and singe data consumer

Author:

    GorN 9-Feb-1999

Revision History:

--*/

#include "evtlogp.h"
#include "simpleq.h"

DWORD SimpleQueueInitialize(
    IN OUT PSIMPLEQUEUE q, 
    IN DWORD cbSize, 
    IN PWCHAR Name,

    IN DATA_AVAILABLE_CALLBACK DataAvailableCallback,
    IN DROPPED_DATA_NOTIFY Callback,
    IN DWORD NotifyInterval
    ) 
/*++

Routine Description:

    Initializes a queue
    
Arguments:

    q      - a queue to be initialized
    cbSize - size of the queue in bytes 
    Name   - Name of the queue. It will be supplied to DroppedDataNotifyCallback

    DataAvailableCallback     - This function will be called if there are data available
                                in the queue. This function will not be called again until
                                Read/CompleteRead operations empty the queue.
                                
    DroppedDataNotifyCallback - This function will be called if there are dropped data and
                                the last time we reported dropped data was NotifyInterval 
                                or more seconds before.
    
    NotifyInterval            - We will not report dropped data unless it has been longer
                                than NotifyInterval seconds since the last report
             
Return Value:

    ERROR_SUCCESS - success
    error code    - called failed
    
 */
{
    cbSize = SQB_INFLATE_SIZE(cbSize);
    ZeroMemory(q, sizeof(SIMPLEQUEUE) );

    q->Begin = LocalAlloc(LPTR, cbSize);
    if (q->Begin == 0) {
        return GetLastError();
    }
    q->End = q->Begin + cbSize;
    q->Head = q->Begin;
    q->Tail = q->Begin;
    q->Wrap = 0;

    q->Empty = TRUE;

    q->Name = Name;
    q->ReadInProgress = 0;
    q->DataAvailableCallback = DataAvailableCallback;

#ifdef COUNT_DROPPED_PACKETS
    GetSystemTimeAsFileTime( (LPFILETIME)&q->NextDroppedDataNotify );
    q->DroppedDataNotifyInterval.QuadPart = Int32x32To64(NotifyInterval, 10000000);
    q->NextDroppedDataNotify.QuadPart += q->DroppedDataNotifyInterval.QuadPart;
    q->DroppedDataNotifyCallback = Callback;

    q->DroppedDataCount = 0;
    q->DroppedDataSize  = 0;
#endif

    InitializeCriticalSection(&q->Lock);
    q->Enabled = TRUE;
    return ERROR_SUCCESS;
}

VOID SimpleQueueDelete(
    IN PSIMPLEQUEUE q
    ) 
/*++

Routine Description:

    Destroys a queue
    
Arguments:

    q      - a queue to be destroyed
             
Return Value:

    None
    
Comments:

    This routine will destroy queue's CriticalSection
    and deallocate queue's memory. It is the responsibility of
    the caller to guarantee that nobody will be using the queue
    after this function is called
    
 */
{
    if (q->Begin) {
        LocalFree(q->Begin);
        DeleteCriticalSection(&q->Lock);
    }
}

BOOL SimpleQueueTryAdd(
    IN PSIMPLEQUEUE q, 
    IN DWORD      PayloadSize, 
    IN PVOID      Payload) 
/*++

Routine Description:

    Tries to add data in a queue
    
Arguments:

    q           - a queue
    PayloadSise - size of the chunk to be added to a queue
    Payload     - pointer to a buffer that countains data to be added
             
Return Value:

    TRUE - if the data were put into the queue successfully
    FALSE - otherwise
    
Comments:

    DataAvailableCallback will be called 
    if there are data available. DataAvailableCallback will not be called 
    during subsequent add requests until Read/CompleteRead 
    operations empty the queue.
    
 */
{
    BOOL DataAvailableCallRequired = FALSE;
    DWORD BlockSize = SQB_PAYLOADSIZE_TO_BLOCKSIZE(PayloadSize);

    if (!q->Enabled) {
        return FALSE;
    }

    EnterCriticalSection(&q->Lock);

    if (q->Wrap) {
        if (q->Head + BlockSize > q->Tail) {
            goto NoRoom;
        }
    } else {
        if (q->End - q->Head < (INT)BlockSize) {
            // not enough room for this data at the
            // end of the queue.
            // Let's see whether we have enough room at the front
            if (q->Tail - q->Begin < (INT)BlockSize) {
                goto NoRoom;
            }
            q->Wrap = q->Head;
            q->Head = q->Begin;
        }
    }

    SQB_HEADER(q->Head)->PayloadSize = PayloadSize;
    CopyMemory( SQB_PAYLOAD(q->Head), Payload, PayloadSize);

    q->Head += BlockSize;

    q->Empty = FALSE;

    if ( !q->ReadInProgress ) {
        DataAvailableCallRequired = TRUE;
        q->ReadInProgress = TRUE;
    }
    
    LeaveCriticalSection(&q->Lock);

    if (DataAvailableCallRequired) {
        q->DataAvailableCallback(q); // Post a worker item in the queue //
    }
    return TRUE;

NoRoom:

#ifdef COUNT_DROPPED_PACKETS
    (q->DroppedDataCount) += 1;
    (q->DroppedDataSize)  += PayloadSize;
#endif
    LeaveCriticalSection(&q->Lock);
    return FALSE;
}

BOOL
SimpleQueueReadAll(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
   )
/*++

Routine Description:

    Allows to read all available blocks
    
Arguments:

    q     - a queue
    begin - receives a pointer to the first queue block
    end   - receives a pointer past the end of the last queue block
             
Return Value:

    TRUE - if we get at least one block
    FALSE - if the queue is empty
    
Comments:

    This function not always give you ALL available blocks in the 
    queue. It gives you all blocks up until the hard end of the queue buffer or
    the writing head of the queue, whatever is smaller.
    If the function returns success, it guarantees that begin < end.
    
    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
    
    You can walk over these block using SQB_NEXTBLOCK macro.

 */
{
    EnterCriticalSection(&q->Lock);
    if (q->Empty) {
        q->ReadInProgress = 0;
        LeaveCriticalSection(&q->Lock);
        return FALSE;
    }
    if (q->Wrap) {
        if (q->Tail == q->Wrap) {
            q->Tail = q->Begin;
            *begin = q->Begin;
            *end   = q->Head;
            q->Wrap = 0;
        } else {
            *begin = q->Tail;
            *end   = q->Wrap;
        }
    } else {
        *begin = q->Tail;
        *end   = q->Head;
    }
    LeaveCriticalSection(&q->Lock);
    return TRUE;
}

BOOL
SimpleQueueReadOne(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
    )
/*++

Routine Description:

    Allows to read a single block of data
    
Arguments:

    q     - a queue
    begin - receives a pointer to the beginning of the first available queue block
    end   - receives a pointer past the end of this block
             
Return Value:

    TRUE  - success
    FALSE - if the queue is empty
    
Comments:

    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
 */
{
    EnterCriticalSection(&q->Lock);
    if (q->Empty) {
        q->ReadInProgress = 0;
        LeaveCriticalSection(&q->Lock);
        return FALSE;
    }
    if (q->Wrap) {
        if (q->Tail == q->Wrap) {
            q->Tail = q->Begin;
            *begin = q->Begin;
            q->Wrap = 0;
        } else {
            *begin = q->Tail;
        }
    } else {
        *begin = q->Tail;
    }
    // we have one or more items //
    *end = SQB_NEXTBLOCK(q->Tail);
    LeaveCriticalSection(&q->Lock);
    return TRUE;
}

BOOL 
SimpleQueueReadComplete(
    IN PSIMPLEQUEUE q,
    IN PVOID newtail
    )
/*++

Routine Description:

    Use this function to signal that the block of data was
    consumed
    
Arguments:

    q     - a queue
    end   - receives a pointer past the end of the last consumed block.
            Usually this is a value returned by the PVOID end parameter of
            ReadOne and ReadAll
             
Return Value:

    TRUE  - There are more data
    FALSE - if the queue is empty
    
Important!!!
     
    If the result of this function is TRUE, the caller should consume the data
    using ReadOne or ReadAll functions followed by the calls 
    to ReadComplete until it returns FALSE.
    
    Otherwise, no futher DataAvailable notifications will be produced bu
    SimpleQueueTryAdd
    
 */
{
    BOOL moreData;
    EnterCriticalSection(&q->Lock);
    q->Tail = newtail;
    if (q->Tail == q->Head) {
        q->Empty = TRUE;
        moreData = FALSE;
    } else {
        moreData = TRUE;
    }
    q->ReadInProgress = moreData;
    LeaveCriticalSection(&q->Lock);
    return moreData;
}

#ifdef COUNT_DROPPED_PACKETS
VOID
CheckForDroppedData(
    IN PSIMPLEQUEUE q, 
    IN BOOL Now
    )
/*++

Routine Description:

    This function checks whether there were
    some data dropped and if the time is right,
    calls DropNotifyCallback function.
    
Arguments:

    q     - a queue
    Now   - If TRUE, than DropNotifyCallback will be called 
            immediately if there are dropped data.
            If FALSE, DropNotifyCallback will be called
            only if it is more then DroppedNotifyInterval
            seconds elapsed, since the last time we called
            DropNotifyCallback
            
Return Value:

    None
 */
{
    if (q->DroppedDataNotifyCallback) {
        ULARGE_INTEGER current;
        GetSystemTimeAsFileTime( (LPFILETIME)&current );
        EnterCriticalSection(&q->Lock);
        if ( q->DroppedDataCount &&
             (Now || CompareFileTime( (LPFILETIME)&current,
                                      (LPFILETIME)&q->NextDroppedDataNotify) > 0 ) 
           )
        {
            DWORD DroppedCount, DroppedSize;
            DroppedCount = q->DroppedDataCount;
            DroppedSize = q->DroppedDataSize;
            q->DroppedDataCount = 0;
            q->DroppedDataSize = 0;

            q->NextDroppedDataNotify.QuadPart = 
                current.QuadPart + q->DroppedDataNotifyInterval.QuadPart;

            LeaveCriticalSection(&q->Lock);
            q->DroppedDataNotifyCallback(q->Name, DroppedCount, DroppedSize);
        } else {
            LeaveCriticalSection(&q->Lock);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\evtlog\evtlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtlog.c

Abstract:

    Contains all the routines for supporting cluster wide eventlogging.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#include "evtlogp.h"
#include "simpleq.h"
#include "nm.h" // to get NmLocalNodeIdString //
#include "dm.h"


//since the eventlog replication requires services.exe calling into the 
//cluster service
LPWSTR  g_pszServicesPath = NULL;
DWORD   g_dwServicesPid = 0;

//
// Local data
//
#define OUTGOING_PROPAGATION_ENABLED 0x00000001
//#define INCOMING_PROPAGATION_ENABLED 0x00000002
#define TRACE_EVERYTHING_ENABLED     0x00001000
#define PROPAGATION_ENABLED OUTGOING_PROPAGATION_ENABLED

static WORD     LastFailHour = -1;
static WORD     LastFailDay  = -1;

static BITSET   EvpUpNodeSet = 0;

static SIMPLEQUEUE IncomingQueue;
static SIMPLEQUEUE OutgoingQueue;
static CLRTL_WORK_ITEM EvtlogWriterWorkItem;
static CLRTL_WORK_ITEM EvtBroadcasterWorkItem;
static DWORD DefaultNodePropagate    = PROPAGATION_ENABLED;
static DWORD DefaultClusterPropagate = PROPAGATION_ENABLED;

#define AsyncEvtlogReplication CLUSTER_MAKE_VERSION(NT5_MAJOR_VERSION,1978)

#define OUTGOING_QUEUE_SIZE (16384)
#define OUTGOING_QUEUE_NAME L"System Event Replication Output Queue"

#define INCOMING_QUEUE_SIZE (OUTGOING_QUEUE_SIZE * 3)
#define INCOMING_QUEUE_NAME L"System Event Replication Input Queue"

#define DROPPED_DATA_NOTIFY_INTERVAL (2*60) // in seconds (2mins)
#define CHECK_CLUSTER_REGISTRY_EVERY 10 // seconds

#define EVTLOG_TRACE_EVERYTHING 1

#ifdef EVTLOG_TRACE_EVERYTHING
# define EvtlogPrint(__evtlogtrace__) \
     do { if (EventlogTraceEverything) {ClRtlLogPrint __evtlogtrace__;} } while(0)
#else
# define EvtLogPrint(x)
#endif

DWORD EventlogTraceEverything = 0;

RPC_BINDING_HANDLE EvtRpcBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];
BOOLEAN EvInitialized = FALSE;


/////////////// Forward Declarations ////////////////
DWORD
InitializeQueues(
    VOID
    );
VOID
DestroyQueues(
    VOID);
VOID
ReadRegistryKeys(
    VOID);
VOID
PeriodicRegistryCheck(
    VOID);
///////////// End of forward Declarations ////////////


/****
@doc    EXTERNAL INTERFACES CLUSSVC EVTLOG
****/

/****
@func       DWORD | EvInitialize| This initializes the cluster
            wide eventlog replicating services.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm

@xref       <f EvShutdown>
****/

DWORD EvInitialize()
{
    DWORD       i;
    WCHAR       wServicesName[] = L"services.exe";
    WCHAR       wCallerModuleName[] = L"\\system32\\";
    WCHAR       wCallerPath[MAX_PATH + 1];
    LPWSTR      pszServicesPath;
    DWORD       dwNumChar;
    DWORD       dwStatus = ERROR_SUCCESS;
    
    //
    // Initialize Per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        EvtRpcBindings[i] = NULL;
    }

    //get the path name for %windir%\system32\services.exe
    
    dwNumChar = GetWindowsDirectoryW(wCallerPath, MAX_PATH);
    if(dwNumChar == 0)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }        

    
    //need to allocate more memory
    pszServicesPath = LocalAlloc(LMEM_FIXED, (sizeof(WCHAR) *
        (lstrlenW(wCallerPath) + lstrlenW(wCallerModuleName) + 
            lstrlenW(wServicesName) + 1)));
    if (!pszServicesPath)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    lstrcpyW(pszServicesPath, wCallerPath);
    lstrcatW(pszServicesPath, wCallerModuleName);
    lstrcatW(pszServicesPath, wServicesName);
    
    g_pszServicesPath = pszServicesPath;

    EvInitialized = TRUE;

FnExit:
    return(dwStatus);

} // EvInitialize


/****
@doc    EXTERNAL INTERFACES CLUSSVC EVTLOG
****/

/****
@func       DWORD | EvOnline| This finishes initializing the cluster
            wide eventlog replicating services.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This calls ElfrRegisterClusterSvc() and calls EvpPropPendingEvents()
            to propagate events logged since the start of the eventlog service.

@xref       <f EvShutdown>
****/
DWORD EvOnline()
{
    DWORD               dwError=ERROR_SUCCESS;
    PPACKEDEVENTINFO    pPackedEventInfo=NULL;
    DWORD               dwEventInfoSize;
    DWORD               dwSequence;
    CLUSTER_NODE_STATE  state;
    DWORD               i;
    PNM_NODE            node;


    ClRtlLogPrint(LOG_NOISE, "[EVT] EvOnline\n");

    dwError = InitializeQueues();
    if (dwError != ERROR_SUCCESS) {
        return dwError;
    }
    //
    // Register for node up/down events.
    //
    dwError = EpRegisterEventHandler(
                  (CLUSTER_EVENT_NODE_UP | CLUSTER_EVENT_NODE_DOWN_EX),
                  EvpClusterEventHandler
                  );

    if (dwError != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
        "[EVT] EvInitialize : Failed to register for cluster events, status %1!u!\n",
            dwError);
        return(dwError);
    }

    //
    // Initialize Per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
    {
        if (i != NmLocalNodeId) {
            node = NmReferenceNodeById(i);

            if (node != NULL) {
                DWORD version = NmGetNodeHighestVersion(node);
                state = NmGetNodeState(node);

                if ( (state == ClusterNodeUp) ||
                     (state == ClusterNodePaused)
                   )
                {
                    if (version >= AsyncEvtlogReplication) {
                        BitsetAdd(EvpUpNodeSet, i);

                        ClRtlLogPrint(LOG_NOISE, 
                            "[EVT] Node up: %1!u!, new UpNodeSet: %2!04x!\n",
                            i,
                            EvpUpNodeSet
                            );
                    } else {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[EVT] Evtlog replication is not allowed for node %1!u! (version %2!x!)\n",
                            i,
                            version
                            );
                    }
                }

                OmDereferenceObject(node);
            }
        }
    }


    //TODO :: SS - currently the eventlog propagation api
    //has been added to clusapi.  In future, if we need
    //to define a general purpose interface for communication
    //with other services on the same system, then we need
    //to register and advertize that interface here.
    //call the event logger to get routines that have been logged so far.

    ClRtlLogPrint(LOG_NOISE, "[EVT] EvOnline : calling ElfRegisterClusterSvc\n");

    dwError = ElfRegisterClusterSvc(NULL, &dwEventInfoSize, &pPackedEventInfo);

    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[EVT] EvOnline : ElfRegisterClusterSvc returned %1!u!\n",
            dwError);
        return(dwError);                    
    }

    //post them to other nodes in the cluster
    if (pPackedEventInfo && dwEventInfoSize)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[EVT] EvOnline: pPackedEventInfo->ulSize=%1!d! pPackedEventInfo->ulNulEventsForLogFile=%2!d!\r\n",
            pPackedEventInfo->ulSize, pPackedEventInfo->ulNumEventsForLogFile);
        EvpPropPendingEvents(dwEventInfoSize, pPackedEventInfo);
        MIDL_user_free ( pPackedEventInfo );

    }

    return (dwError);

}

/****
@func       DWORD | EvCreateRpcBindings| This creates an RPC binding
            for a specified node.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm

@xref
****/
DWORD
EvCreateRpcBindings(
    PNM_NODE  Node
    )
{
    DWORD               Status;
    RPC_BINDING_HANDLE  BindingHandle;
    CL_NODE_ID          NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[EVT] Creating RPC bindings for node %1!u!.\n",
        NodeId
        );

    //
    // Main binding
    //
    if (EvtRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(EvtRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[EVT] Failed to verify 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(EvtRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[EVT] Failed to create 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    return(ERROR_SUCCESS);

} // EvCreateRpcBindings


/****
@func       DWORD | EvShutdown| This deinitializes the cluster
            wide eventlog replication services.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       The cluster register deregisters with the eventlog service.

@xref       <f EvInitialize>
****/
DWORD EvShutdown(void)
{
    DWORD               dwError=ERROR_SUCCESS;


    if (EvInitialized) {
        PPACKEDEVENTINFO    pPackedEventInfo;
        DWORD               dwEventInfoSize;
        DWORD               i;


        ClRtlLogPrint(LOG_NOISE,
            "[EVT] EvShutdown\r\n");

        //call the event logger to get routines that have been logged so far.

        ElfDeregisterClusterSvc(NULL);
        DestroyQueues();

        // TODO [GorN 9/23/1999]
        //   When DestroyQueues starts doing what it is supposed to do,
        //   (i.e. flush/wait/destroy), enable the code below
        
        #if 0
        //
        // Free per-node information
        //
        for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
            if (EvtRpcBindings[i] != NULL) {
                ClMsgDeleteRpcBinding(EvtRpcBindings[i]);
                EvtRpcBindings[i] = NULL;
            }
        }
        #endif
    }

    return (dwError);

}

/****
@func       DWORD | EvpClusterEventHandler| Handler for internal cluster
            events.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm

@xref       <f EvInitialize>
****/
DWORD
EvpClusterEventHandler(
    IN CLUSTER_EVENT  Event,
    IN PVOID          Context
    )
{
    DWORD NodeId;


    if (Event == CLUSTER_EVENT_NODE_UP) {
        PNM_NODE   node = (PNM_NODE) Context;
        CL_NODE_ID  nodeId = NmGetNodeId(node);
        DWORD version = NmGetNodeHighestVersion(node);

        if ( version >= AsyncEvtlogReplication )
        {
            BitsetAdd(EvpUpNodeSet, nodeId);

            ClRtlLogPrint(LOG_NOISE, 
                "[EVT] Node up: %1!u!, new UpNodeSet: %2!04x!\n",
                nodeId,
                EvpUpNodeSet
                );
        } else {
            ClRtlLogPrint(LOG_NOISE, 
                "[EVT] Evtlog replication is not allowed for node %1!u! (version %2!x!)\n",
                nodeId,
                version
                );
        }
    }
    else if (Event == CLUSTER_EVENT_NODE_DOWN_EX) {
        BITSET downedNodes = (BITSET)((ULONG_PTR)Context);

        BitsetSubtract(EvpUpNodeSet, downedNodes);

        ClRtlLogPrint(LOG_NOISE, 
            "[EVT] Nodes down: %1!04X!, new UpNodeSet: %2!04x!\n",
            downedNodes,
            EvpUpNodeSet
            );
    }

    return(ERROR_SUCCESS);
}

/****
@func       DWORD | s_EvPropEvents| This is the server entry point for
            receiving eventlog information from other nodes of the cluster
            and logging them locally.

@parm       IN handle_t | IDL_handle | The rpc binding handle. Unused.
@parm       IN DWORD | dwEventInfoSize | the size of the packed event info structure.
@parm       IN UCHAR | *pBuffer| A pointer to the packed
            eventinfo structure.
@rdesc      returns ERROR_SUCCESS if successful else returns the error code.

@comm       This function calls ElfWriteClusterEvents() to log the event propagted
            from another node.
@xref
****/
DWORD
s_EvPropEvents(
    IN handle_t IDL_handle,
    IN DWORD dwEventInfoSize,
    IN UCHAR *pBuffer
    )
{
    PUCHAR end = pBuffer + dwEventInfoSize;

    if ( dwEventInfoSize >= sizeof(DWORD) && dwEventInfoSize == (*(PDWORD)pBuffer)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[EVT] Improperly formed packet received of size %1!u!.\n",
            dwEventInfoSize
            );
        return ERROR_SUCCESS;
    }

#ifdef CLUSTER_BETA
    EvtlogPrint((LOG_NOISE, "[EVT] s_EvPropEvents.  dwEventInfoSize=%1!d!\r\n",
                 dwEventInfoSize));
#endif

    while (pBuffer < end) {
        BOOL success;

        success = SimpleQueueTryAdd(&IncomingQueue, SQB_PAYLOADSIZE(pBuffer), SQB_PAYLOAD(pBuffer));
        if ( !success ) {
            EvtlogPrint((LOG_NOISE, "[EVT] s_EvPropEvents.  Put(IncomingQ,%1!d!) failed. empty=%2!d!\n",
                    SQB_PAYLOADSIZE(pBuffer), IncomingQueue.Empty) );
        }

        pBuffer = SQB_NEXTBLOCK(pBuffer);
    }
    return(ERROR_SUCCESS);
}

/****
@func       DWORD | EvpPropPendingEvents| This is called to propagate all the pending
            events since the start of the system.  And then to propagate any events
            generated during the life of the cluster.
@parm       IN DWORD | dwEventInfoSize | the size of the packed event info structure.
@parm       IN PPACKEDEVENTINFO | pPackedEventInfo| A pointer to the packed
            eventinfo structure.
@rdesc      returns ERROR_SUCCESS if successful else returns the error code.

@comm       This function is called during initialization when a cluster is being formed.
@xref
****/
DWORD EvpPropPendingEvents(
    IN DWORD            dwEventInfoSize,
    IN PPACKEDEVENTINFO pPackedEventInfo)
{
    BOOL success;

    success = SimpleQueueTryAdd(&OutgoingQueue, dwEventInfoSize, pPackedEventInfo);

    if ( !success ) {
        EvtlogPrint((LOG_NOISE, "[EVT] EvpPropPendingEvents:  Put(OutgoingQ,%1!d!) failed. empty=%2!d!\n",
                 dwEventInfoSize, OutgoingQueue.Empty));
    }

    return ERROR_SUCCESS;
}

/****
@func       DWORD | s_ApiEvPropEvents | This is called to propagate eventlogs from
            the local system to all other nodes of the cluster.

@parm       handle_t | IDL_handle | Not used.
@parm       DWORD | dwEventInfoSize | The number of bytes in the following structure.
@parm       UCHAR * | pPackedEventInfo | Pointer to a byte structure containing the
            PACKEDEVENTINFO structure.

@rdesc      Returns ERROR_SUCCESS if successfully propagated events,
            else returns the error code.

@comm       Currently this function is called for every eventlogged by the eventlog
            service.  Only the processes running in the SYSTEM account can call this
            function.
@xref
****/
error_status_t
s_ApiEvPropEvents(
    IN handle_t IDL_handle,
    IN DWORD dwEventInfoSize,
    IN UCHAR *pPackedEventInfo
    )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bIsLocalSystemAccount;

#if 0
    //
    // Chittur Subbaraman (chitturs) - 11/7/1999
    //
    // Modify this function to use ClRtlIsCallerAccountLocalSystemAccount
    // instead of GetUserName which 
    // (1) used to hang in security audit enabled systems if security 
    // audit log attempts to write to the event log at the time we 
    // made that API call since that API and the security audit log 
    // are mutually exclusive for some portions, and
    // (2) wrongly checked for an unlocalizable output value "SYSTEM"
    // from that API in order to grant access to the client.
    //
    
    //
    // Impersonate the client.
    //
    if ( ( dwError = RpcImpersonateClient( IDL_handle ) ) != RPC_S_OK )
    {
        ClRtlLogPrint( LOG_ERROR, 
                    "[EVT] s_ApiEvPropEvents: Error %1!d! trying to impersonate caller...\n",
                    dwError 
                    );
        goto FnExit;
    }

    //
    // Check that the caller's account is local system account
    //
    if ( ( dwError = ClRtlIsCallerAccountLocalSystemAccount( 
                &bIsLocalSystemAccount ) != ERROR_SUCCESS ) )
    {
        RpcRevertToSelf();
        ClRtlLogPrint( LOG_ERROR, 
                    "[EVT] s_ApiEvPropEvents: Error %1!d! trying to check caller's account...\n",
                    dwError);   
        goto FnExit;
    }

    if ( !bIsLocalSystemAccount )
    {
        RpcRevertToSelf();
        dwError = ERROR_ACCESS_DENIED;
        ClRtlLogPrint( LOG_ERROR, 
                    "[EVT] s_ApiEvPropEvents: Caller's account is not local system account, denying access...\n");   
        goto FnExit;
    }

    RpcRevertToSelf();
#endif
    //
    // All security checks have passed. Drop the eventlog info into
    // the queue.
    //
    if ( dwEventInfoSize && pPackedEventInfo ) 
    {
        dwError = EvpPropPendingEvents( dwEventInfoSize,
                                        ( PPACKEDEVENTINFO ) pPackedEventInfo );
    }

    return( dwError );
}

VOID
EvtlogWriter(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

     This work item reads events from the
     incoming queue and writes them to EventLog service


Arguments:

     Not used.

Return Value:

     None

--*/
{
    PVOID begin, end;
    SYSTEMTIME localTime;
    DWORD       eventsWritten = 0;

#ifdef CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter Work Item fired.\n") );
#endif

    do {
        DWORD dwError;

        if ( !SimpleQueueReadOne(&IncomingQueue, &begin, &end) )
        {
            break;
        }
#ifdef CLUSTER_BETA
        EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter got %1!d!.\n",
                     (PUCHAR)end - (PUCHAR)begin ) );
#endif

        dwError = ElfWriteClusterEvents(
                      NULL,
                      SQB_PAYLOADSIZE(begin),
                      (PPACKEDEVENTINFO)SQB_PAYLOAD(begin) );

        if ( dwError != ERROR_SUCCESS ) {
            GetLocalTime( &localTime );

// LastFailHour is initialized to -1, which should not equal any wHour!
// LastFailDay is initialized to -1, which should not equal any wDay!

            if ( (LastFailHour != localTime.wHour) || (LastFailDay != localTime.wDay) ) {
                LastFailHour = localTime.wHour;
                LastFailDay = localTime.wDay;
                ClRtlLogPrint(LOG_UNUSUAL,
                       "[EVT] ElfWriteClusterEvents failed: status = %1!u!\n",
                        dwError);
            }
        }
        PeriodicRegistryCheck();
    } while ( SimpleQueueReadComplete(&IncomingQueue, end) );

#ifdef CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter: done.\n" ) );
#endif

    if ( eventsWritten > 0 ) {
        EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter: wrote %u events to system event log.\n", eventsWritten ) );
    }
    CheckForDroppedData(&IncomingQueue, FALSE);
}

VOID
EvtBroadcaster(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

     This work item reads events from the
     outgoing queue and RPCs them to all active nodes

Arguments:

     Not used.

Return Value:

     None

--*/
{
    PVOID begin, end;

#ifdef CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtBroadcaster Work Item fired.\n") );
#endif

    do {
        DWORD i;

        if( !SimpleQueueReadAll(&OutgoingQueue, &begin, &end) )
        {
            break;
        }

#ifdef CLUSTER_BETA
        EvtlogPrint((LOG_NOISE, "[EVT] EvtBroadcaster got %1!d!.\n",
                    (PUCHAR)end - (PUCHAR)begin ) );
#endif

        for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
        {
            if (BitsetIsMember(i, EvpUpNodeSet) && (i != NmLocalNodeId))
            {
                DWORD dwError;

                CL_ASSERT(EvtRpcBindings[i] != NULL);

                NmStartRpc(i);
                dwError = EvPropEvents(EvtRpcBindings[i],
                                       (DWORD)((PUCHAR)end - (PUCHAR)begin),
                                       (PBYTE)begin);
                NmEndRpc(i);

                if ( dwError != ERROR_SUCCESS ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[EVT] EvpPropPendingEvents: EvPropEvents for node %1!u! "
                                "failed. status %2!u!\n",
                                i,
                                dwError);
                    NmDumpRpcExtErrorInfo(dwError);
                }
            }
        }

        PeriodicRegistryCheck();
    } while ( SimpleQueueReadComplete(&OutgoingQueue, end) );

#ifdef CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtBroadcaster: done.\n" ) );
#endif

    CheckForDroppedData(&OutgoingQueue, FALSE);
}

VOID
OutgoingQueueDataAvailable(
    IN PSIMPLEQUEUE q
    )
/*++

Routine Description:

     This routine is called by the queue to notify
     that there are data in the queue available for processing

Arguments:

     q - which queue has data

Return Value:

     None

--*/
{
    DWORD status = ClRtlPostItemWorkQueue(
                        CsDelayedWorkQueue,
                        &EvtBroadcasterWorkItem,
                        0,
                        0
                        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[EVT] OutgoingQueueDataAvailable, PostWorkItem failed, error %1!u! !\n",
            status);
    }
}

VOID
IncomingQueueDataAvailable(
    IN PSIMPLEQUEUE q
    )
/*++

Routine Description:

     This routine is called by the queue to notify
     that there are data in the queue available for processing

Arguments:

     q - which queue has data

Return Value:

     None

--*/
{
    DWORD status = ClRtlPostItemWorkQueue(
                        CsDelayedWorkQueue,
                        &EvtlogWriterWorkItem,
                        0,
                        0
                        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[EVT] IncomingQueueDataAvailable, PostWorkItem failed, error %1!u! !\n",
            status);
    }
}

VOID
DroppedDataNotify(
    IN PWCHAR QueueName,
    IN DWORD DroppedDataCount,
    IN DWORD DroppedDataSize
    )
/*++

Routine Description:

     This routine is called by the queue to notify
     that some data were lost because the queue was full

Arguments:

     QueueName - Queue Name
     DataCount - How many chunks of data were lost
     DataSize  - Total size fo the lost data

Return Value:

     None

--*/
{
    WCHAR  count[32];
    WCHAR  size[32];
    ClRtlLogPrint(LOG_UNUSUAL,
        "[EVT] %1!ws!: dropped %2!d!, total dropped size %3!d!.\n",
        QueueName,
        DroppedDataCount,
        DroppedDataSize );


    wsprintfW(count+0, L"%u", DroppedDataCount);
    wsprintfW(size+0, L"%u", DroppedDataSize);

    ClusterLogEvent3(LOG_UNUSUAL,
                LOG_CURRENT_MODULE,
                __FILE__,
                __LINE__,
                EVTLOG_DATA_DROPPED,
                0,
                NULL,
                QueueName,
                count,
                size);
}

////////////////////////////////////////////////////////////////////////////


LARGE_INTEGER RegistryCheckInterval;
LARGE_INTEGER NextRegistryCheckAt;

DWORD
InitializeQueues(
    VOID)
{
    DWORD status, OutgoingQueueStatus;
    status =
        SimpleQueueInitialize(
            &OutgoingQueue,
            OUTGOING_QUEUE_SIZE,
            OUTGOING_QUEUE_NAME,

            OutgoingQueueDataAvailable,
            DroppedDataNotify,
            DROPPED_DATA_NOTIFY_INTERVAL // seconds //
        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[EVT] Failed to create '%1!ws!', error %2!u!.\n",
                      OUTGOING_QUEUE_NAME, status );
    }
    OutgoingQueueStatus = status;
    status =
        SimpleQueueInitialize(
            &IncomingQueue,
            INCOMING_QUEUE_SIZE,
            INCOMING_QUEUE_NAME,

            IncomingQueueDataAvailable,
            DroppedDataNotify,
            DROPPED_DATA_NOTIFY_INTERVAL // seconds //
        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[EVT] Failed to create '%1!ws!', error %2!u!.\n",
                      INCOMING_QUEUE_NAME, status );
    }

    ClRtlInitializeWorkItem(
        &EvtBroadcasterWorkItem,
        EvtBroadcaster,
        (PVOID) &OutgoingQueue
        );
    ClRtlInitializeWorkItem(
        &EvtlogWriterWorkItem,
        EvtlogWriter,
        (PVOID) &IncomingQueue
        );
    RegistryCheckInterval.QuadPart = Int32x32To64(10 * 1000 * 1000, CHECK_CLUSTER_REGISTRY_EVERY);
    NextRegistryCheckAt.QuadPart = 0;

    ReadRegistryKeys();
    return OutgoingQueueStatus;
}

////////////////////////////////////////////////////////////////////////////

VOID
DestroyQueues(
    VOID)
{
    CheckForDroppedData(&IncomingQueue, TRUE);
    CheckForDroppedData(&OutgoingQueue, TRUE);

    // [GN] TODO
    // Add proper destruction of queues
}

VOID
ReadRegistryKeys(
    VOID)
/*
 *
 */
{
    HDMKEY nodeKey;
    DWORD NodePropagate;
    DWORD ClusterPropagate;
    static DWORD OldPropagateState = 0xCAFEBABE;
    DWORD status;

    nodeKey = DmOpenKey(
                  DmNodesKey,
                  NmLocalNodeIdString,
                  KEY_READ
                  );

    if (nodeKey != NULL) {
        status = DmQueryDword(
                     nodeKey,
                     CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION,
                     &NodePropagate,
                     &DefaultNodePropagate
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[EVT] Unable to query propagation mode for local node, status %1!u!.\n",
                status
                );
        }

        DmCloseKey(nodeKey);
    }
    else {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Unable to open database key to local node, status %1!u!. Assuming default settings.\n",
            GetLastError());
        NodePropagate = DefaultNodePropagate;
    }

    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION,
                 &ClusterPropagate,
                 &DefaultClusterPropagate
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Unable to query global propagation mode, status %1!u!.\n",
            status
            );
    }

    NodePropagate &= ClusterPropagate;

    if (NodePropagate != OldPropagateState) {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Set propagation state to %1!04x!\n", NodePropagate
            );
        if (NodePropagate & OUTGOING_PROPAGATION_ENABLED) {
            if (OutgoingQueue.Begin) {
                OutgoingQueue.Enabled = 1;
            }
        } else {
            OutgoingQueue.Enabled = 0;
        }
#if 0
        if (NodePropagate & INCOMING_PROPAGATION_ENABLED) {
            if (IncomingQueue.Begin) {
                IncomingQueue.Enabled = 1;
            }
        } else {
            IncomingQueue.Enabled = 0;
        }
#endif
        if(NodePropagate & TRACE_EVERYTHING_ENABLED) {
            EventlogTraceEverything = 1;
        } else {
            EventlogTraceEverything = 0;
        }
        OldPropagateState = NodePropagate;
    }
}

VOID
PeriodicRegistryCheck(
    VOID)
{
    LARGE_INTEGER currentTime;
    GetSystemTimeAsFileTime( (LPFILETIME)&currentTime);
    if( currentTime.QuadPart > NextRegistryCheckAt.QuadPart ) {
        ReadRegistryKeys();
        NextRegistryCheckAt.QuadPart = currentTime.QuadPart + RegistryCheckInterval.QuadPart;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\evtlog\simpleq.h ===
#ifndef _SIMPLE_QUEUE_H
#define _SIMPLE_QUEUE_H 1

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    simpleq.h

Abstract:

    Simple non-blocking queue, that allows
    multiple concurrent data providers
    and singe data consumer

Author:

    GorN 9-Feb-1999

Revision History:

--*/

#define COUNT_DROPPED_PACKETS 1 // Enable dropped packet counting 

// The queue can store blocks of variable sizes
// each block is prefixed by this structure

typedef struct _SIMPLEQUEUE_BLOCK_HEADER
{
    DWORD PayloadSize; // this is the size of the block 
                       // as it was passed to us by the client
} 
SIMPLEQUEUE_BLOCK_HEADER, *PSIMPLEQUEUE_BLOCK_HEADER;

#define SQB_ALIGNMENT           ( sizeof(DWORD) )
#define SQB_INFLATE_SIZE( size )( (size + SQB_ALIGNMENT - 1) & ~(SQB_ALIGNMENT - 1) )
#define SQB_PAYLOADSIZE_TO_BLOCKSIZE( size )( SQB_INFLATE_SIZE(size + sizeof(SIMPLEQUEUE_BLOCK_HEADER)) )

#define SQB_HEADER( ptr )       ( (PSIMPLEQUEUE_BLOCK_HEADER)(ptr) )
#define SQB_PAYLOADSIZE( ptr )  ( SQB_HEADER(ptr)->PayloadSize )
#define SQB_BLOCKSIZE( ptr )    ( SQB_PAYLOADSIZE_TO_BLOCKSIZE( SQB_PAYLOADSIZE( ptr ) ) )
#define SQB_NEXTBLOCK( ptr )    ( (PVOID)( (PUCHAR)(ptr) + SQB_BLOCKSIZE( ptr ) ) )
#define SQB_PAYLOAD( ptr )      ( (PVOID)(SQB_HEADER(ptr) + 1) )

typedef struct _SIMPLEQUEUE *PSIMPLEQUEUE;

// The following function will be called if there are dropped data and
// the last time we reported dropped data was NotifyInterval 
// or more seconds before.
typedef void (*DROPPED_DATA_NOTIFY) (
    IN PWCHAR QueueName, 
    IN DWORD DroppedDataCount, 
    IN DWORD DroppedDataSize);

// The following function will be called if there are data available
// in the queue. It will not be called again until
// Read/CompleteRead operations empty the queue.
typedef void (*DATA_AVAILABLE_CALLBACK)(
    IN PSIMPLEQUEUE q);

DWORD SimpleQueueInitialize(
    IN OUT PSIMPLEQUEUE q, 
    IN DWORD cbSize, 
    IN PWCHAR Name,

    IN DATA_AVAILABLE_CALLBACK DataAvailableCallback,
    IN DROPPED_DATA_NOTIFY DroppedDataNotifyCallback,
    IN DWORD NotifyInterval // in seconds //
    );
/*++

Routine Description:

    Initializes a queue
    
Arguments:

    q      - a queue to be initialized
    cbSize - size of the queue in bytes 
    Name   - Name of the queue. It will be supplied to DroppedDataNotifyCallback

    DataAvailableCallback     - This function will be called if there are data available
                                in the queue. This function will not be called again until
                                Read/CompleteRead operations empty the queue.
                                
    DroppedDataNotifyCallback - This function will be called if there are dropped data and
                                the last time we reported dropped data was NotifyInterval 
                                or more seconds before.
    
    NotifyInterval            - We will not report dropped data unless it has been longer
                                than NotifyInterval seconds since the last report
             
Return Value:

    ERROR_SUCCESS - success
    error code    - called failed
    
 */


VOID
SimpleQueueDelete(
    IN PSIMPLEQUEUE q
    );
/*++

Routine Description:

    Destroys a queue
    
Arguments:

    q      - a queue to be destroyed
             
Return Value:

    None
    
Comments:

    This routine will destroy queue's CriticalSection
    and deallocate queue's memory. It is the responsibility of
    the caller to guarantee that nobody will be using the queue
    after this function is called
    
 */

BOOL
SimpleQueueTryAdd(
    IN PSIMPLEQUEUE q, 
    IN DWORD      PayloadSize, 
    IN PVOID      Payload
    );
/*++

Routine Description:

    Tries to add data in a queue
    
Arguments:

    q           - a queue
    PayloadSise - size of the chunk to be added to a queue
    Payload     - pointer to a buffer that countains data to be added
             
Return Value:

    TRUE - if the data were put into the queue successfully
    FALSE - otherwise
    
Comments:

    DataAvailableCallback will be called 
    if there are data available. DataAvailableCallback will not be called 
    during subsequent add requests until Read/CompleteRead 
    operations empty the queue.
    
 */

BOOL
SimpleQueueReadAll(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
   );
/*++

Routine Description:

    Allows to read all available blocks
    
Arguments:

    q     - a queue
    begin - receives a pointer to the first queue block
    end   - receives a pointer past the end of the last queue block
             
Return Value:

    TRUE - if we get at least one block
    FALSE - if the queue is empty
    
Comments:

    This function not always give you ALL available blocks in the 
    queue. It gives you all blocks up until the hard end of the queue buffer or
    the writing head of the queue, whatever is smaller.
    If the function returns success, it guarantees that begin < end.
    
    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
    
    You can walk over these block using SQB_NEXTBLOCK macro.

 */

BOOL
SimpleQueueReadOne(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
    );
/*++

Routine Description:

    Allows to read a single block of data
    
Arguments:

    q     - a queue
    begin - receives a pointer to the beginning of the first available queue block
    end   - receives a pointer past the end of this block
             
Return Value:

    TRUE  - success
    FALSE - if the queue is empty
    
Comments:

    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
 */

BOOL 
SimpleQueueReadComplete(
    IN PSIMPLEQUEUE q,
    IN PVOID newtail
    );
/*++

Routine Description:

    Use this function to signal that the block of data was
    consumed
    
Arguments:

    q     - a queue
    end   - receives a pointer past the end of the last consumed block.
            Usually this is a value returned by the PVOID end parameter of
            ReadOne and ReadAll
             
Return Value:

    TRUE  - There are more data
    FALSE - if the queue is empty
    
Important!!!
     
    If the result of this function is TRUE, the caller should consume the data
    using ReadOne or ReadAll functions followed by the calls 
    to ReadComplete until it returns FALSE.
    
    Otherwise, no futher DataAvailable notifications will be produced bu
    SimpleQueueTryAdd
    
 */

#ifdef COUNT_DROPPED_PACKETS
VOID
CheckForDroppedData(
    IN PSIMPLEQUEUE q, 
    IN BOOL Now
    );
/*++

Routine Description:

    This function checks whether there were
    some data dropped and if the time is right,
    calls DropNotifyCallback function.
    
Arguments:

    q     - a queue
    Now   - If TRUE, than DropNotifyCallback will be called 
            immediately if there are dropped data.
            If FALSE, DropNotifyCallback will be called
            only if it is more then DroppedNotifyInterval
            seconds elapsed, since the last time we called
            DropNotifyCallback
            
Return Value:

    None
 */

#else

#define CheckForDroppedData(x,y) 

#endif


typedef struct _SIMPLEQUEUE {
    CRITICAL_SECTION Lock;
    PWCHAR           Name;  // arbitrary string
    PUCHAR           Begin; // queue buffer start
    PUCHAR           End;   // queue buffer end

    PUCHAR           Head;  // writing head
    PUCHAR           Tail;  // consuming end

    PUCHAR           Wrap;  // wrap == 0, if tail < head
                            // otherwise if it points past the end of 
                            // the last block before queue buffer end

    BOOL             Empty; // This flag is properly maintained by the queue,
                            // but not required for the queue to operate
                            // Can be removed if nobody needs it

    BOOL             Enabled; // Add operation to the queue will fail
                              // if the enabled flag is not set

    UINT32           ReadInProgress; // DataAvailableCallback notification
                                     // was issued and processing is not
                                     // complete.
                                     //
                                     // This flag is reset by ReadComplete
                                     // when there are no more data

    DATA_AVAILABLE_CALLBACK DataAvailableCallback;

#ifdef COUNT_DROPPED_PACKETS
    ULARGE_INTEGER   NextDroppedDataNotify;
    DROPPED_DATA_NOTIFY DroppedDataNotifyCallback;
    ULARGE_INTEGER   DroppedDataNotifyInterval;

    DWORD            DroppedDataCount; // These two variable are reset each time
    DWORD            DroppedDataSize;  // we call DroppedDataNotifyCallback
#endif
    //
} SIMPLEQUEUE;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\dllupgd.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    DllUpgd.c

Abstract:

    Routines for supporting resource DLL upgrade.

Author:

    Chittur Subbaraman (chitturs) 18-March-2001

Revision History:

    18-March-2001       Created

--*/
#include "fmp.h"

//
//  Defines used locally within this module
//
#define CLUSTER_RESDLL_BACKUP_FILE_EXTENSION    L".~WFPKDLLBKP$"
#define CLUSTER_RESDLL_RENAMED_FILE_EXTENSION   L".~WFPKDLLOLD$"
#define CLUSTER_RESDLL_BACKUP_FILES             L".~WFPKDLL*$"


DWORD
FmpUpgradeResourceDLL(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszInstallationPath
    )

/*++

Routine Description:

    Upgrades a resource DLL currently loaded in one or more monitors.

Arguments:

    pResource - A resource of the type implemented by the DLL.

    lpszInstallationPath - The full installation path of the DLL (including the full DLL name with
        extension)

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPWSTR          lpszNewDllName;
    WCHAR           szCurrentDllPath[MAX_PATH];

    //
    //  Get the DLL file name from the installation path. Also, get rid of any trailing '\' in
    //  the supplied path.
    //
    //  IMPORTANT: Note that lpszNewDLLName points into lpszInstallationPath buffer and so
    //  we should not modify the lpszInstallation path buffer (there is really no reason to
    //  do that) while we use lpszNewDllName.
    //
    dwStatus = FmpParsePathForFileName( lpszInstallationPath,
                                        TRUE,   // Check for path existence
                                        &lpszNewDllName );

    //
    //  If the parse fails or if the supplied "path" is a filename, bail.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( lpszNewDllName == NULL ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Unable to parse supplied path %1!ws! for file name, Status=%2!u!\n",
                      (lpszInstallationPath == NULL) ? L"NULL":lpszInstallationPath,
                      dwStatus);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpUpgradeResourceDLL: Installation path %1!ws!, resource [%2!ws!] %3!ws!\n",
                  lpszInstallationPath,
                  OmObjectName(pResource),
                  OmObjectId(pResource));

    //
    //  Validate the supplied parameters. If validation is successful, get the full path of the
    //  currently loaded DLL.
    //
    dwStatus = FmpValidateResourceDLLReplacement( pResource, 
                                                  lpszNewDllName,
                                                  szCurrentDllPath );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Validation for resource DLL replacement failed, Status=%1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Acquire the monitor lock so as to serialize one resource DLL upgrade process with
    //  others as well as with monitor restarts.
    //
    FmpAcquireMonitorLock();

    //
    //  Now, replace the DLL with the supplied DLL in a recoverable fashion.
    //
    dwStatus = FmpReplaceResourceDLL( lpszNewDllName,
                                      szCurrentDllPath,
                                      lpszInstallationPath );
  
    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Replacement of resource DLL failed, Status=%1!u!\n",
                      dwStatus);
        goto FnReleaseLockAndExit;
    }
    
    //
    //  Shutdown and restart the monitors that have the resource DLL loaded.
    //
    dwStatus = FmpRecycleMonitors( lpszNewDllName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Recycling of resource DLL failed, Status=%1!u!\n",
                      dwStatus);
        goto FnReleaseLockAndExit;
    }

    //
    //  Attempt deletion of backup files in case all the steps are successful so far. Note that
    //  this attempt is necessary here since it is not possible to delete the .old file
    //  before we recycle the monitors since the monitors hold references to the DLL.
    //
    FmpDeleteBackupFiles ( szCurrentDllPath );  //  Delete backup files

FnReleaseLockAndExit:
    FmpReleaseMonitorLock();

FnExit:
    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpUpgradeResourceDLL: Exit with status %1!u!...\n",
                  dwStatus);
    
    return ( dwStatus );   
} //  FmpUpgradeResourceDLL

DWORD
FmpParsePathForFileName(
    IN LPWSTR lpszPath,
    IN BOOL fCheckPathExists,
    OUT LPWSTR *ppszFileName
    )

/*++

Routine Description:

    Get the name of the file at the end of a supplied path.

Arguments:

    lpszPath - A path including the file name.

    fCheckPathExists - Check if the path exists.

    ppszFileName - The name of the file parsed from the path.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.

Note:

    This function will get rid of any trailing '\' in the supplied path. Also, this function
    will return a file name only if the input supplied is a valid path, else NULL file name
    will be returned.
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LPWSTR      s;

    *ppszFileName = NULL;
   
    //
    //  Check for invalid parameter.
    //
    if ( lpszPath == NULL )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpParsePathForFileName: Input param is NULL, Status=%1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Make sure the last character is NULL if it is a '\'. This is to avoid getting confused
    //  with paths such as C:\windows\cluster\clusres.dll\
    //
    if ( lpszPath[lstrlen ( lpszPath ) - 1] == L'\\' ) lpszPath[lstrlen ( lpszPath ) - 1] = L'\0';
    
    //
    //  Parse the supplied path and look for the last occurrence of '\'. If there is no '\' at all,
    //  may be the caller supplied a file name, bail with NULL out param but with success status.
    //
    s = wcsrchr( lpszPath, L'\\' );

    if ( s == NULL )
    {
        goto FnExit;
    }

    //
    //  If the supplied parameter is a path (as opposed to a plain file name) and the caller
    //  requested to check for validity, do so.
    //
    if ( fCheckPathExists && !ClRtlPathFileExists( lpszPath ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpParsePathForFileName: Path %1!ws! does not exist, Status=%2!u!\n",
                      lpszPath,
                      dwStatus);       
        goto FnExit;
    }
    
    //
    //  Return the pointer to the char after the last '\'.
    //
    s++;
    *ppszFileName = s;

FnExit:
    return ( dwStatus );
}// FmpParsePathForFileName

DWORD
FmpValidateResourceDLLReplacement(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszNewDllName,
    OUT LPWSTR lpszCurrentDllPath
    )

/*++

Routine Description:

    Validate the resource DLL replacement request.

Arguments:

    pResource - The resource which is implemeted by the DLL.
    
    lpszNewDllName - The name of the DLL.

    lpszCurrentDllPath - The full path of the currently loaded DLL.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LPWSTR      lpszFileName;
    LPWSTR      lpszDllName = NULL;
    WCHAR       szDLLNameOfRes[MAX_PATH];
    BOOL        fDllPathFound = TRUE;

    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //
    //  IMPORTANT: Do not write stuff into szDllNameOfRes while lpszDllName is being used
    //  since lpszDllName points inside szDllNameOfRes.
    //
    lstrcpy( szDLLNameOfRes, pResource->Type->DllName );
    
    dwStatus = FmpParsePathForFileName ( szDLLNameOfRes, 
                                         TRUE,  // Check for path existence
                                         &lpszDllName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpValidateResourceDLLReplacement: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      szDLLNameOfRes,
                      dwStatus);                                                        
        goto FnExit;
    }

    //
    //  If the dll information in the resource type structure is a file name, then you need to
    //  search the path to find the full path of the DLL. Otherwise, you can merely copy the
    //  information from the resource type structure and expand any environment strings in it.
    //
    if ( lpszDllName == NULL ) 
    {
        lpszDllName = pResource->Type->DllName;
        fDllPathFound = FALSE;
    } else
    {
        LPWSTR  pszDllName;
        
        //
        // Expand any environment variables included in the DLL path name.
        //
        pszDllName = ClRtlExpandEnvironmentStrings( pResource->Type->DllName );

        if ( pszDllName == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpValidateResourceDLLReplacement: Resource's DLL name %1!ws! cannot be expanded, Status=%2!u!\n",
                   pResource->Type->DllName,
                   dwStatus);       
            goto FnExit;
        }
        lstrcpy( lpszCurrentDllPath, pszDllName ); 
        LocalFree( pszDllName );
    }
    
    if ( lstrcmp( lpszDllName, lpszNewDllName ) != 0 ) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpValidateResourceDLLReplacement: Resource's DLL name %1!ws! does not match supplied name, Status=%2!u!\n",
                     lpszDllName,
                     dwStatus);       
        goto FnExit;    
    }

    //
    //  Search all the paths specified in the environment variable and get the full current
    //  path of the DLL that is loaded into the monitor.
    //
    if ( ( fDllPathFound == FALSE ) &&
         ( !SearchPath ( NULL,                     // Search all paths as LoadLibrary does
                         lpszNewDllName,         // File name to search for
                         NULL,                     // No extension required
                         MAX_PATH,                 // Size of out buffer
                         lpszCurrentDllPath,     // Buffer to receive full Dll path with file name
                         &lpszFileName ) ) )       //  Filename at the end of the path
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpValidateResourceDLLReplacement: SearchPath API for file %1!ws! failed, Status=%2!u!\n",
                     lpszNewDllName,
                     dwStatus);          
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpValidateResourceDLLReplacement: Current resource DLL full path %1!ws!\n",
                 lpszCurrentDllPath);       


FnExit:
    return ( dwStatus ); 
}// FmpValidateResourceDLLReplacement

DWORD
FmpReplaceResourceDLL(
    IN LPWSTR lpszNewDllName,
    IN LPWSTR lpszCurrentDllPath,
    IN LPWSTR lpszInstallationPath
    )

/*++

Routine Description:

    Replace the resource DLL with the one from the install path.

Arguments:
   
    lpszNewDllName - The name of the DLL.

    lpszCurrentDllPath - The full path of the currently loaded DLL.

    lpszInstallationPath - The installation path of the DLL.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    HKEY        hClussvcParamsKey = NULL;
    DWORD       cbListSize = 0, cchLen = 0;
    LPWSTR      lpmszUpgradeList = NULL;
    WCHAR       szBakFile[MAX_PATH], szOldFile[MAX_PATH];
    WCHAR       szClusterDirectory[MAX_PATH];
    DWORD       dwType, dwLen;

    //
    //
    //  This function works as follows. First we make a copy of the existing resource DLL file
    //  to a file with CLUSTER_RESDLL_BACKUP_FILE_EXTENSION extension. Then we set the registry
    //  value under the clussvc parameters key to indicate that an upgrade is starting. After
    //  this, the existing DLL file is renamed. If all steps are successful so far, we copy
    //  new DLL file from the supplied path. Once this is successful, the registry value set
    //  above is deleted.
    //
    //  This algorithm gives us the following guarantees:
    //
    //  1. If the registry value is set, then a good backup file with CLUSTER_RESDLL_BACKUP_FILE_EXTENSION
    //     must exist.
    //
    //  2. If the registry value is not set, then the existing DLL file was not touched by
    //     the upgrade process or the DLL upgrade was completely successful.
    //
    //  Thus, only if the registry value is set at the time FmpCreateMonitor is invoked, it
    //  will go through the elaborate recovery process implemented in FmpRecoverResourceDLLFiles.
    //  At recovery time, we can be sure that the backup file with CLUSTER_RESDLL_BACKUP_FILE_EXTENSION 
    //  is a perfectly good backup. Also, at recovery time we cannot be sure of the state (good/bad)
    //  of the existing DLL file (if it exists at all) or the renamed file with 
    //  CLUSTER_RESDLL_RENAMED_FILE_EXTENSION. So, the recovery process is pessimistic and just
    //  copies the backup file wit CLUSTER_RESDLL_BACKUP_FILE_EXTENSION over any existing DLL
    //  file.
    //
    //  Sideeffect: Even if the registry value is not set, there could be a stale backup file
    //  left. Thus wheneever FmpCreateMonitor is invoked, it has to cleanup those files.
    //  This is done by invoking FmpDeleteBackupFiles(NULL) from FmpRecoverResourceDLLFiles.
    //
    
    //
    //  Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hClussvcParamsKey );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: RegOpenKeyEx on %1!ws! failed, Status=%2!u!\n",
                     CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                     dwStatus);             
        goto FnExit;
    }

    //
    //  See whether a past failed upgrade has left any values in the upgrade progress list
    //
    dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                 0,
                                 &dwType,
                                 NULL,
                                 &cbListSize );

    if ( ( dwStatus != ERROR_SUCCESS ) &&
         ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: RegQueryValueEx (1st time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                
        goto FnExit;
    }

    if ( cbListSize != 0 )
    {
        //
        //  Found some values left out from past upgrade. Read those values.
        //
        lpmszUpgradeList = LocalAlloc ( LPTR, cbListSize );

        if ( lpmszUpgradeList == NULL )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: Mem alloc failure, Status=%1!u!\n",
                      dwStatus);                       
            goto FnExit;
        }

        dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                     CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                     0,
                                     &dwType,
                                     ( LPBYTE ) lpmszUpgradeList,
                                     &cbListSize );

        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpReplaceResourceDLL: RegQueryValueEx (2nd time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                          CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                          dwStatus);                       
            goto FnExit;
        }       
    }

    //
    //  Check whether a failed upgrade of the same DLL has occurred in the past.
    //
    if ( ClRtlMultiSzScan( lpmszUpgradeList,
                           lpszCurrentDllPath ) != NULL )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] FmpReplaceResourceDLL: ClRtlMultiSzScan detected %1!ws! in the multi-sz, skip append...\n",
                      lpszCurrentDllPath);                          
        goto skip_multisz_append;
    }
    
    //
    //  Append the current DLL path to the REG_MULTI_SZ
    //
    cchLen = cbListSize/sizeof( WCHAR );
    
    dwStatus = ClRtlMultiSzAppend( &lpmszUpgradeList,
                                   &cchLen,
                                   lpszCurrentDllPath );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: ClRtlMultiSzAppend failed for %1!ws!, Status=%2!u!\n",
                      lpszCurrentDllPath,
                      dwStatus);                          
        goto FnExit;
    }
    
    //
    //  Get the cluster bits installed directory
    //
    dwStatus = ClRtlGetClusterDirectory( szClusterDirectory, MAX_PATH );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    lstrcpy( szBakFile, szClusterDirectory );

    dwLen = lstrlenW( szBakFile );

    if ( szBakFile[dwLen-1] != L'\\' )
    {
        szBakFile[dwLen++] = L'\\';
        szBakFile[dwLen] = L'\0';
    }

    lstrcat( szBakFile, lpszNewDllName );
    lstrcat( szBakFile, CLUSTER_RESDLL_BACKUP_FILE_EXTENSION );

    //
    //  Copy the current DLL to a bak file and save it into the cluster installation directory.
    //  This needs to be done BEFORE the registry value is set so that you can be sure that once you
    //  perform a recovery, the file that you use from the backup is good.
    //
    if ( !CopyFileEx( lpszCurrentDllPath,   //  Source file
                      szBakFile,               //  Destination file
                      NULL,                    //  No progress routine
                      NULL,                    //  No data to progress routine
                      NULL,                    //  No cancel variable
                      0 ) )                    //  No flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: CopyFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      lpszCurrentDllPath,
                      szBakFile,
                      dwStatus);                          
        goto FnExit;
    }

    //
    //  Set the file attributes to RO and hidden. Continue even if an error occurs since it is
    //  not fatal.
    //
    if ( !SetFileAttributes( szBakFile, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpReplaceResourceDLL: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szBakFile,
                dwStatus);                                 
    }
    
    //
    //  Set the new upgrade list
    //
    dwStatus = RegSetValueExW( hClussvcParamsKey,
                               CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                               0,
                               REG_MULTI_SZ,
                               ( LPBYTE ) lpmszUpgradeList,
                               cchLen * sizeof ( WCHAR ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: RegSetValueExW (1st time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                          
        goto FnExit;
    }
    
skip_multisz_append:
    lstrcpy( szOldFile, szClusterDirectory );

    dwLen = lstrlenW( szOldFile );

    if ( szOldFile[dwLen-1] != L'\\' )
    {
        szOldFile[dwLen++] = L'\\';
        szOldFile[dwLen] = L'\0';
    }

    lstrcat( szOldFile, lpszNewDllName );
    lstrcat( szOldFile, CLUSTER_RESDLL_RENAMED_FILE_EXTENSION );

    //
    //  Rename the currently loaded DLL to the a .old file in the cluster installation directory
    //
    if ( !MoveFileEx( lpszCurrentDllPath,   // Source file 
                      szOldFile,              // Destination file
                      MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: MoveFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      lpszCurrentDllPath,
                      szOldFile,
                      dwStatus);                          
        goto FnExit;                
    }

    //
    //  Set the file attributes to RO and hidden. Continue even if an error occurs since it is
    //  not fatal.
    //
    if ( !SetFileAttributes( szOldFile, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpReplaceResourceDLL: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szOldFile,
                dwStatus);                                 
    }

    //
    //  Copy the new DLL from the installation path to the current DLL path. This should succeed
    //  since the current DLL has been renamed.
    //
    if ( !CopyFileEx( lpszInstallationPath,  //  Source file
                      lpszCurrentDllPath,    //  Destination file
                      NULL,                    //  No progress routine
                      NULL,                    //  No data to progress routine
                      NULL,                    //  No cancel variable
                      0 ) )                    //  No flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: CopyFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      lpszInstallationPath,
                      lpszCurrentDllPath,
                      dwStatus);                          
        goto FnExit;
    }   
   
    //
    //  Now get rid of the value we set in the registry. The BAK and OLD files are deleted later.
    //
    dwStatus =  FmpResetMultiSzValue ( hClussvcParamsKey,
                                       lpmszUpgradeList,
                                       &cchLen,
                                       CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                       lpszCurrentDllPath );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: Unable to remove %1!ws! from value %2!ws!, Status=%3!u!\n",
                      lpszCurrentDllPath,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                          
    
        goto FnExit;
    }
                              
FnExit:
    LocalFree( lpmszUpgradeList );

    if ( hClussvcParamsKey != NULL )
    {
        RegCloseKey( hClussvcParamsKey );
    }
    return ( dwStatus );
}//  FmpReplaceResourceDLL

DWORD
FmpRecycleMonitors(
    IN LPCWSTR lpszDllName
    )

/*++

Routine Description:

    Recycle all the monitors that have the specified resource DLL loaded.
Arguments:
   
    lpszDllName - The name of the loaded resource DLL.
    
Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD                   i, dwStatus = ERROR_SUCCESS;
    FM_MONITOR_ENUM_HEADER  MonitorEnumHeader;

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpRecycleMonitors: Attempting to recycle all monitors that have loaded the DLL %1!ws!\n",
                 lpszDllName);                                     

    MonitorEnumHeader.ppMonitorList = NULL;
    MonitorEnumHeader.fDefaultMonitorAdded = FALSE;

    //
    //  Create a list of monitors that have the resource DLL loaded.
    //
    dwStatus = FmpCreateMonitorList( lpszDllName, &MonitorEnumHeader );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpRecycleMonitors: FmpCreateMonitorList failed with status %1!u!\n",
                      dwStatus);                                         
        goto FnExit;
    }

    //
    //  Now, shutdown and restart the monitors identified above. Shutdown and restart of each
    //  monitor is done one by one so that the long shutdown time of some monitors will not affect
    //  the restart of others. The FmpRestartMonitor function invokes a shutdown on the monitor,
    //  waits until the monitor is fully shutdown and then restarts all the resources in the
    //  old monitor in the new monitor.
    //
    for ( i=0; i<MonitorEnumHeader.cEntries; i++ )
    {
        //
        //  Increment the ref count. It will be decremented by the restart function.
        //
        InterlockedIncrement( &MonitorEnumHeader.ppMonitorList[i]->RefCount );
        FmpRestartMonitor( MonitorEnumHeader.ppMonitorList[i] );
    } // for
    
FnExit:   
    LocalFree( MonitorEnumHeader.ppMonitorList );

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpRecycleMonitors: Return with status %1!u!\n",
                 dwStatus);                                        

    return ( dwStatus );
}// FmpRecycleMonitors

DWORD
FmpCreateMonitorList(
    IN LPCWSTR lpszDllName,
    OUT PFM_MONITOR_ENUM_HEADER pMonitorHeader
    )

/*++

Routine Description:

    Create a list of monitors that have the resource DLL implementing the resource loaded.

Arguments:

    lpszDllName - The resource DLL that is being upgraded.

    pMonitorHeader - The enumeration list header which points to a list of monitors that have 
        the DLL loaded.
    
Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

--*/

{
    DWORD                   dwStatus = ERROR_SUCCESS;

    pMonitorHeader->cEntries = 0;
    pMonitorHeader->cAllocated = ENUM_GROW_SIZE;

    pMonitorHeader->ppMonitorList = LocalAlloc( LPTR, ENUM_GROW_SIZE * sizeof ( PRESMON ) );

    if ( pMonitorHeader->ppMonitorList == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCreateMonitorList: Mem alloc failed with status %1!u!\n",
                      dwStatus);                                                        
        goto FnExit;
    }

    //
    //  Go through all the cluster resources to identify the monitors that have loaded the
    //  specified DLL.
    //
    OmEnumObjects( ObjectTypeResource,
                   FmpFindHostMonitors,
                   ( PVOID ) lpszDllName,
                   ( PVOID ) pMonitorHeader );
FnExit:
    return ( dwStatus );

}// FmpCreateMonitorList

BOOL
FmpFindHostMonitors(
    IN LPCWSTR lpszDllName,
    IN OUT PFM_MONITOR_ENUM_HEADER pMonitorEnumHeader,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR lpszResourceId
    )

/*++

Routine Description:

    Callback routine for enumerating all resources in the cluster. This routine will build a list
    of monitors that have loaded the specified DLL.

Arguments:

    lpszDllName - The DLL whose host processes have to be determined.

    pMonitorEnumHeader - The monitor list enumeration header

    pResource - The resource being enumerated.

    lpszResourceId - The Id of the resource object being enumerated.

Returns:

    TRUE - The enumeration should continue.

    FALSE - The enumeration must stop

--*/

{
    BOOL        fStatus = TRUE;
    PRESMON     *ppMonitorList;
    DWORD       i;
    LPWSTR      lpszDllNameOfRes = NULL;
    WCHAR       szDLLNameOfRes[MAX_PATH];
    DWORD       dwStatus;

    //
    //  Check whether the currently allocated monitor list has reached capacity. If so,
    //  create a new bigger list, copy the contents of the old list to the new one and 
    //  free the old list.
    //
    if ( pMonitorEnumHeader->cEntries == pMonitorEnumHeader->cAllocated )
    {
        ppMonitorList = LocalAlloc( LPTR,  pMonitorEnumHeader->cAllocated * 2 * sizeof ( PRESMON ) );

        if ( ppMonitorList == NULL )
        {
            fStatus = FALSE;
            ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpFindHostMonitors: Mem alloc failed with status %1!u!\n",
                      GetLastError());                                                               
            goto FnExit;
        }

        for ( i=0; i<pMonitorEnumHeader->cEntries; i++ )
        {
            ppMonitorList[i] = pMonitorEnumHeader->ppMonitorList[i];    
        }
        
        pMonitorEnumHeader->cAllocated *= 2;
        LocalFree( pMonitorEnumHeader->ppMonitorList );
        pMonitorEnumHeader->ppMonitorList = ppMonitorList;
    }

    
    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //
    //  IMPORTANT: Do not write stuff into szDllNameOfRes while lpszDllName is being used
    //  since lpszDllName points inside szDllNameOfRes.
    //
    lstrcpy( szDLLNameOfRes, pResource->Type->DllName );

    dwStatus = FmpParsePathForFileName ( szDLLNameOfRes, 
                                         TRUE,  // Check for path existence
                                         &lpszDllNameOfRes );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpFindHostMonitors: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      szDLLNameOfRes,
                      dwStatus);                                                        
        fStatus = FALSE;
        goto FnExit;
    }

    if ( lpszDllNameOfRes == NULL ) lpszDllNameOfRes = pResource->Type->DllName;

    //
    //  If this resource is not implemented in the specified DLL, you are done.
    //
    if ( lstrcmp( lpszDllNameOfRes, lpszDllName ) != 0 )
    {
        fStatus = TRUE;
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpFindHostMonitors: Resource DLL %1!ws! for resource %2!ws! [%3!ws!] is loaded currently in %4!ws! monitor...\n",
                 lpszDllName,
                 OmObjectId(pResource),
                 OmObjectName(pResource),
                 (pResource->Monitor == FmpDefaultMonitor) ? L"default":L"separate");                                                               

    //
    //  Since multiple resources can be loaded in the default monitor, you don't want to add
    //  the default monitor multiple times in the list. Use a global static variable to indicate
    //  that the default monitor has been added in the list. Also, note that only one resource can
    //  be loaded in a separate monitor process and so there is no question of adding the separate
    //  monitor multiple times in the list.
    //
    if ( pResource->Monitor == FmpDefaultMonitor ) 
    {
        if ( pMonitorEnumHeader->fDefaultMonitorAdded == TRUE ) 
        {
            fStatus = TRUE;
            goto FnExit;
        }
        pMonitorEnumHeader->fDefaultMonitorAdded = TRUE;
    }

    pMonitorEnumHeader->ppMonitorList[pMonitorEnumHeader->cEntries] = pResource->Monitor;
    pMonitorEnumHeader->cEntries ++;    
    
FnExit:
    return ( fStatus );
} // FmpFindHostMonitors

DWORD
FmpRecoverResourceDLLFiles(
    VOID
    )

/*++

Routine Description:

    Check whether any resource DLLs need to be recovered due to a crash during an upgrade.

Arguments:

    None.

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPWSTR          lpszDllPath = NULL;
    LPCWSTR         lpmszUpgradeList = NULL;
    LPWSTR          lpmszBegin = NULL;
    DWORD           cbListSize = 0, cchLen = 0;
    DWORD           dwType, dwIndex;
    HKEY            hClussvcParamsKey = NULL;
    
    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hClussvcParamsKey );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpRecoverResourceDLLFiles: RegOpenKeyEx on %1!ws! failed, Status=%2!u!\n",
                     CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                     dwStatus); 
        goto FnExit;
    }

    //
    //  See whether a past failed upgrade has left any values in the upgrade progress list
    //
    dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                 0,
                                 &dwType,
                                 NULL,
                                 &cbListSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND ) 
        {
            dwStatus = ERROR_SUCCESS;
            //
            //  Delete any backup files left over from past failed upgrades.
            //
            FmpDeleteBackupFiles( NULL );
        }
        else
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpRecoverResourceDLLFiles: RegQueryValueEx (1st time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                          CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                          dwStatus);  
        goto FnExit;
    }

    if ( cbListSize == 0 )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRecoverResourceDLLFiles: Value size is 0 for %1!ws! key, value %2!ws!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST);    
        goto FnExit;
    }
    
    //
    //  Found some values left out from past upgrade. Read those values. Also, copy
    //  those values into a temp buffer for allowing easy MULTI_SZ removal.
    //
    lpmszUpgradeList = LocalAlloc ( LPTR, 
                                    2 * cbListSize ); // Twice size needed for temp buffer below
   
    if ( lpmszUpgradeList == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpRecoverResourceDLLFiles: Mem alloc failure, Status=%1!u!\n",
                  dwStatus);                       
        goto FnExit;
    }

    lpmszBegin = ( LPWSTR ) lpmszUpgradeList;

    dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                 0,
                                 &dwType,
                                 ( LPBYTE ) lpmszUpgradeList,
                                 &cbListSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpRecoverResourceDLLFiles: RegQueryValueEx (2nd time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                       
        goto FnExit;
    } 

    CopyMemory( lpmszBegin + cbListSize/sizeof(WCHAR), lpmszUpgradeList, cbListSize );

    cchLen = cbListSize/sizeof(WCHAR);

    //
    //  This loop walks through the multi strings read from the registry and tries to
    //  see if the file exists in the path. If not, it tries to copy the file from 
    //  a backup. Once it succeeds in copying a file from the backup, it tries to
    //  delete the value from the MULTI_SZ and the appropriate backup files from the
    //  cluster directory.
    //
    for ( dwIndex = 0;  ; dwIndex++ )
    {       
        lpszDllPath = ( LPWSTR ) ClRtlMultiSzEnum( lpmszUpgradeList,
                                                   cbListSize/sizeof(WCHAR),
                                                   dwIndex );
        //
        //  If you reached the end of the multi-string, bail.
        //
        if ( lpszDllPath == NULL ) 
        {
            break;
        }

        //
        //  Assume the worst and copy the DLL file from the good backup.
        //
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRecoverResourceDLLFiles: Resource DLL binary %1!ws! cannot be trusted due to a failure during upgrade...\n",
                      lpszDllPath);      
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRecoverResourceDLLFiles: Attempting to use a copy from backup...\n",
                      lpszDllPath);      

        dwStatus = FmpCopyBackupFile( lpszDllPath );

        if ( dwStatus == ERROR_SUCCESS )
        {
            //
            //  The copy went fine. So, reset the registry value set during the upgrade.
            //
            dwStatus = FmpResetMultiSzValue ( hClussvcParamsKey,
                                              lpmszBegin + cbListSize/sizeof(WCHAR),
                                              &cchLen,
                                              CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                              lpszDllPath );

            if ( dwStatus == ERROR_SUCCESS )
                //
                //  The registry value reset went fine, so get rid of the backup files
                //
                FmpDeleteBackupFiles( lpszDllPath );
        } 
    } // for

FnExit:
    LocalFree( lpmszBegin );

    if ( hClussvcParamsKey != NULL )
    {
        RegCloseKey( hClussvcParamsKey );
    }

    return ( dwStatus );
}// FmpRecoverResourceDLLFiles

DWORD
FmpResetMultiSzValue(
    IN  HKEY hKey,
    IN  LPWSTR lpmszList,
    IN  OUT LPDWORD pcchLen,
    IN  LPCWSTR lpszValueName,
    IN  LPCWSTR lpszString 
    )

/*++

Routine Description:

    Gets rid of a specified string from a multi-string and sets the string to the given value name
    in the registry. The value is deleted if on the string removal the multi-string becomes
    empty.

Arguments:

    hKey - An open registry handle.

    lpmszList - A multi-string.

    pcchLen - A pointer to the length of the multi string. On return, it will be set to the
        new length of the multi-string.

    lpszValueName - The value name to be modified.

    lpszString - The string to be removed from the multi-string.

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    //
    //  Remove the supplied string from the multi-sz
    //
    dwStatus = ClRtlMultiSzRemove( lpmszList,
                                   pcchLen,
                                   lpszString );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: ClRtlMultiSzRemove failed for %1!ws!, Status=%2!u!\n",
                      lpszString,
                      dwStatus);                             
        goto FnExit;
    }

    //
    //  ClRtlMultiSzRemove will return a size of 1 character if the string is empty
    //
    if ( *pcchLen <= 2 )
    {
        //
        //  After removal from the multi-sz, there is nothing left, so delete the value
        //
        dwStatus = RegDeleteValue( hKey,
                                   lpszValueName ); 

        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] FmpResetMultiSzValue: RegDeleteValue on %1!ws! value failed, Status=%2!u!\n",
                         lpszValueName,
                         dwStatus);                              
            goto FnExit;
        }      
    } else
    {
        //
        //  Put the rest of the values back into the registry.
        //
        dwStatus = RegSetValueExW( hKey,
                                   lpszValueName,
                                   0,
                                   REG_MULTI_SZ,
                                   ( LPBYTE ) lpmszList,
                                   ( *pcchLen ) * sizeof ( WCHAR ) );

        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] FmpResetMultiSzValue: RegSetValueEx on %1!ws! value failed, Status=%2!u!\n",
                         lpszValueName,
                         dwStatus);                                     
            goto FnExit;
        } 
    }

FnExit:
    return ( dwStatus );
}// FmpResetMultiSzValue

DWORD
FmpCopyBackupFile(
    IN LPCWSTR  lpszPath
    )

/*++

Routine Description:

    Parse the path for the DLL file name and copy the backup version of the file.

Arguments:

    lpszPath - Path including the DLL file name.

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

Note:

    We can only trust CLUSTER_RESDLL_BACKUP_FILE_EXTENSION file as the good backup since that
    backup was made prior to setting the CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST value.
    So, we don't look at the CLUSTER_RESDLL_RENAMED_FILE_EXTENSION file in this function.

--*/
{
    WCHAR       szSourceFile[MAX_PATH];
    WCHAR       szTempFile[MAX_PATH];
    WCHAR       szClusterDir[MAX_PATH];
    LPWSTR      lpszFileName;
    DWORD       dwStatus = ERROR_SUCCESS, i, dwLen;
   
    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //  IMPORTANT: Dont write into szTempFile after you parse the file name since lpszFileName
    //  points into szTempFile.
    //
    lstrcpy( szTempFile, lpszPath );

    dwStatus = FmpParsePathForFileName ( szTempFile, 
                                         FALSE,       // Don't check for existence
                                         &lpszFileName ); 

    if ( ( dwStatus != ERROR_SUCCESS ) || ( lpszFileName == NULL ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCopyBackupFile: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      szTempFile,
                      dwStatus);                                                        
        goto FnExit;
    }

    //    
    //  Get the cluster bits installed directory
    //
    dwStatus = ClRtlGetClusterDirectory( szClusterDir, MAX_PATH );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCopyBackupFile: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    lstrcpy( szSourceFile, szClusterDir );
    
    dwLen = lstrlenW( szSourceFile );

    if ( szSourceFile[dwLen-1] != L'\\' )
    {
        szSourceFile[dwLen++] = L'\\';
        szSourceFile[dwLen] = L'\0';
    }

    lstrcat( szSourceFile, lpszFileName );
    lstrcat( szSourceFile, CLUSTER_RESDLL_BACKUP_FILE_EXTENSION );

    //
    //  Change the file attributes to normal
    //
    if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCopyBackupFile: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    //
    //  Copy the backup file to the DLL path.
    //
    if ( !CopyFileEx( szSourceFile,            //  Source file
                      lpszPath,               //  Destination file
                      NULL,                    //  No progress routine
                      NULL,                    //  No data to progress routine
                      NULL,                    //  No cancel variable
                      0 ) )                    //  No flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCopyBackupFile: CopyFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      szSourceFile,
                      lpszPath,
                      dwStatus);                          
    } else
    {
        dwStatus = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpCopyBackupFile: CopyFileEx of %1!ws! to %2!ws! successful...\n",
              szSourceFile,
              lpszPath,
              dwStatus);
        goto FnExit;
    }

FnExit:
    return ( dwStatus );
}// FmpCopyBackupFile

VOID
FmpDeleteBackupFiles(
    IN LPCWSTR  lpszPath    OPTIONAL
    )

/*++

Routine Description:

    Parse the path for the DLL file name and delete the backup files corresponding to it OR
    delete all files with the known backup extension in the %windir%\cluster directory.

Arguments:

    lpszPath - Path including the DLL file name.    OPTIONAL

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    WCHAR               szSourceFile[MAX_PATH];
    WCHAR               szTempFile[MAX_PATH];
    WCHAR               szClusterDir[MAX_PATH];
    LPWSTR              lpszFileName = L"*";    // Use in case IN param is NULL
    DWORD               dwStatus = ERROR_SUCCESS, i, dwLen;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    
    if ( lpszPath == NULL ) goto skip_path_parse;
    
    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //  IMPORTANT: Dont write into szTempFile after you parse the file name since lpszFileName
    //  points into szTempFile.
    //
    lstrcpy( szTempFile, lpszPath );

    dwStatus = FmpParsePathForFileName ( szTempFile, 
                                         FALSE,       // Don't check for existence
                                         &lpszFileName ); 

    if ( ( dwStatus != ERROR_SUCCESS ) || ( lpszFileName == NULL ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpDeleteBackupFiles: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      szTempFile,
                      dwStatus);                                                        
        goto FnExit;
    }

skip_path_parse:
    //    
    //  Get the cluster bits installed directory
    //
    dwStatus = ClRtlGetClusterDirectory( szClusterDir, MAX_PATH );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpDeleteBackupFiles: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    if ( lpszPath == NULL )
    {
        //
        //  Delete all files that match the backup file pattern.
        //
        lstrcpy( szSourceFile, szClusterDir );

        dwLen = lstrlenW( szSourceFile );

        if ( szSourceFile[dwLen-1] != L'\\' )
        {
            szSourceFile[dwLen++] = L'\\';
            szSourceFile[dwLen] = L'\0';
        }

        lstrcat( szSourceFile, lpszFileName );
        lstrcat( szSourceFile, CLUSTER_RESDLL_BACKUP_FILES );

        if ( ( hFind = FindFirstFile( szSourceFile, &FindData ) ) == INVALID_HANDLE_VALUE ) 
        {
            dwStatus = GetLastError();
            if ( dwStatus != ERROR_FILE_NOT_FOUND )
                ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpDeleteBackupFiles: Failed in FindFirstFile for %1!ws!, Status=%2!u!\n",
                       szSourceFile,
                       dwStatus);                              
            goto FnExit;
        }

        do
        {
            //
            //  Get the file name matching the pattern above and get the full path including
            //  the file name. Then change the file attributes to normal for allowing deletion.
            //
            lstrcpy( szSourceFile, szClusterDir );

            dwLen = lstrlenW( szSourceFile );

            if ( szSourceFile[dwLen-1] != L'\\' )
            {
                szSourceFile[dwLen++] = L'\\';
                szSourceFile[dwLen] = L'\0';
            }

            lstrcat( szSourceFile, FindData.cFileName );

            if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
            {
                dwStatus = GetLastError();
                ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpDeleteBackupFiles: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                        szSourceFile,
                        dwStatus);                                 
            }

            if ( !DeleteFile( szSourceFile ) )
            {
                dwStatus = GetLastError();
                ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpDeleteBackupFiles: Failed in DeleteFile for %1!ws!, Status=%2!u!\n",
                        szSourceFile,
                        dwStatus);                                 
            }
        } while ( FindNextFile( hFind, &FindData ) );

        FindClose ( hFind );
        goto FnExit;
    }

    lstrcpy( szSourceFile, szClusterDir );
    
    dwLen = lstrlenW( szSourceFile );

    if ( szSourceFile[dwLen-1] != L'\\' )
    {
        szSourceFile[dwLen++] = L'\\';
        szSourceFile[dwLen] = L'\0';
    }

    lstrcat( szSourceFile, lpszFileName );
    lstrcat( szSourceFile, CLUSTER_RESDLL_BACKUP_FILE_EXTENSION );

    if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    if ( !DeleteFile( szSourceFile ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in DeleteFile for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    lstrcpy( szSourceFile, szClusterDir );
    
    dwLen = lstrlenW( szSourceFile );

    if ( szSourceFile[dwLen-1] != L'\\' )
    {
        szSourceFile[dwLen++] = L'\\';
        szSourceFile[dwLen] = L'\0';
    }

    lstrcat( szSourceFile, lpszFileName );
    lstrcat( szSourceFile, CLUSTER_RESDLL_RENAMED_FILE_EXTENSION );

    if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    if ( !DeleteFile( szSourceFile ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in DeleteFile for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }
    
FnExit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmapi.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmapi.c
    
Abstract:

    Cluster manager api service routines.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE FMAPI

//
// Local Functions
//


//
// Functions Exported to the rest of the Cluster Manager
//



////////////////////////////////////////////////////////
//
// Group management functions.
//
////////////////////////////////////////////////////////

DWORD
WINAPI
FmOnlineGroup(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Bring the specified group online.  This means bringing all of the
    individual resources contained within the group online.  This is an
    atomic operation - so either all resources contained within the group
    are brought online, or none of them are.

Arguments:

    Group - Supplies a pointer to the group structure to bring online.

Retruns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    PLIST_ENTRY     listEntry;

    FmpMustBeOnline( );

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Make sure the owning node is not paused.
    //
    if (NmGetNodeState(Group->OwnerNode) == ClusterNodePaused) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SHARING_PAUSED);
    }

    //
    // Check if we are the owner... if not, ship the request off someplace
    // else.
    //
    if ( Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalGroupLock( Group );
        return(FmcOnlineGroupRequest(Group));
    }

    //
    // Set the PersistentState for this Group - the PersistentState is persistent.
    //
    FmpSetGroupPersistentState( Group, ClusterGroupOnline );

    status = FmpOnlineGroup( Group, TRUE );

    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmOnlineGroup


DWORD
WINAPI
FmOfflineGroup(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Bring the specified group offline.  This means bringing all of the
    individual resources contained within the group offline.

Arguments:

    Group - Supplies a pointer to the group structure to bring offline.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;

    FmpMustBeOnline( );

    //
    // Check if we are the owner... if not, ship the request off to some
    // other place.
    //

    if ( Group->OwnerNode != NmLocalNode ) {
        return(FmcOfflineGroupRequest(Group));
    }

    //
    // Set the PersistentState for this Group - the PersistentState is persistent.
    //
    FmpSetGroupPersistentState( Group, ClusterGroupOffline );

    status = FmpOfflineGroup( Group, FALSE, TRUE);


    return(status);

} // FmOfflineGroup


DWORD
WINAPI
FmMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    )

/*++

Routine Description:

    Failover the specified Group.  This means taking all of the individual
    resources contained within the group offline and requesting the
    DestinationNode to bring the Group Online.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to THE OTHER node.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

Notes:

    The Group may or may not be online on the DestinationNode, depending on
    whether the online request succeeded.  This means that the status return
    is merely the status return for the Online request for the DestinationNode.

--*/

{
    FmpMustBeOnline( );

    return(FmpDoMoveGroup( Group, DestinationNode, TRUE ));

} // FmMoveGroup



PFM_GROUP
WINAPI
FmCreateGroup(
    IN LPWSTR GroupId,
    IN LPCWSTR GroupName
    )

/*++

Routine Description:

    Create the specified GroupId.  This requires verifying that the
    specified GroupId does not already exist and then creating an
    empty Group container into which resources can be added.

    Note that the returned PFM_GROUP will have already been referenced.
    This prevents somebody from deleting the group before the caller
    gets a chance to reference it.

Arguments:

    GroupId - Supplies the Id of the Group to create.

    GroupName - Supplies the 'user-friendly' name of the Group.

Returns:

    Pointer to the newly created group if successful.

    NULL if unsuccessful. GetLastError() will return the specific error.

--*/

{
    DWORD Status;
    PFM_GROUP Group;
    PGUM_CREATE_GROUP GumGroup;
    DWORD BufSize;
    DWORD GroupIdLen;
    DWORD GroupNameLen;

    FmpMustBeOnlineEx( NULL );

    //
    // Allocate a message buffer.
    //
    GroupIdLen = (lstrlenW(GroupId)+1)*sizeof(WCHAR);
    GroupNameLen = (lstrlenW(GroupName)+1)*sizeof(WCHAR);
    BufSize = sizeof(GUM_CREATE_GROUP) - sizeof(WCHAR) + GroupIdLen +
              GroupNameLen + (lstrlenW( OmObjectId(NmLocalNode) ) + 1) * sizeof(WCHAR);
    GumGroup = LocalAlloc(LMEM_FIXED, BufSize);
    if (GumGroup == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Fill in message buffer.
    //
    GumGroup->Group = NULL;
    GumGroup->GroupIdLen = GroupIdLen;
    GumGroup->GroupNameLen = GroupNameLen;
    wcscpy(GumGroup->GroupId, GroupId);
    CopyMemory((PCHAR)GumGroup->GroupId + GroupIdLen,
               GroupName,
               GroupNameLen);
    CopyMemory((PCHAR)GumGroup->GroupId + GroupIdLen + GroupNameLen,
               OmObjectId(NmLocalNode),
               (lstrlenW( OmObjectId(NmLocalNode) ) + 1) * sizeof(WCHAR));

    //
    // Send message.
    //
    Status = GumSendUpdate(GumUpdateFailoverManager,
                           FmUpdateCreateGroup,
                           BufSize,
                           GumGroup);

    if ((GumGroup->Group == NULL) && (FmpShutdown)) {
        Status = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
    }
    
    if (Status != ERROR_SUCCESS) {
        LocalFree(GumGroup);
        SetLastError(Status);
        return(NULL);
    }

    Group = GumGroup->Group;
    CL_ASSERT(Group != NULL);
    LocalFree(GumGroup);
    return(Group);

} // FmCreateGroup


DWORD
WINAPI
FmDeleteGroup(
    IN PFM_GROUP pGroup
    )

/*--

Routine Description:

    Delete the specified Group.  This means verifying that the specified
    Group does not contain any resources (resources must be removed
    by a separate call to remove the resources), and then deleting the
    Group.

Arguments:

    Group - Supplies the Group to delete.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD   dwStatus;

    FmpMustBeOnline( );

    FmpAcquireLocalGroupLock( pGroup );

    if (pGroup->OwnerNode == NmLocalNode)
    {
        dwStatus = FmpDeleteGroup(pGroup);
    }
    else
    {
        //
        // FmcDeleteGroup releases the group lock
        //
        dwStatus = FmcDeleteGroupRequest(pGroup);
        goto FnExit;
    }

    FmpReleaseLocalGroupLock(pGroup);
    
FnExit:    
    return(dwStatus);

}  // FmDeleteGroup



DWORD
WINAPI
FmSetGroupName(
    IN PFM_GROUP Group,
    IN LPCWSTR FriendlyName
    )

/*++

Routine Description:

    Set the user-friendly name for the specified Group.

    Note that the Group must have already been created. It is also
    assumed that the caller of this routine (the cluster API) has already
    verified that the name is NOT a duplicate.

Arguments:

    Group - Supplies the Group to enter a new name.

    FriendlyName - Supplies the user-friendly name for the resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    LPCWSTR GroupId;
    DWORD Status;

    GroupId = OmObjectId(Group);

    Status = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateChangeGroupName,
                             2,
                             (lstrlenW(GroupId)+1)*sizeof(WCHAR),
                             GroupId,
                             (lstrlenW(FriendlyName)+1)*sizeof(WCHAR),
                             FriendlyName);
    return(Status);

} // FmSetGroupName



CLUSTER_GROUP_STATE
WINAPI
FmGetGroupState(
    IN PFM_GROUP Group,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength OPTIONAL
    )

/*++

Routine Description:

    Get the current state for the specified Group. The Group state
    consists of state of the group, along with the current node that is
    hosting the Group (if the state of the Group is anything but
    ClusterGroupOffline.

Arguments:

    Group - Supplies the group object to get the state.

    NodeName - Supplies a pointer to a buffer into which the name of
        the node in the cluster the specified Group is currently hosted.
        This field can be NULL, if NameLength is zero.

    NameLength - Supplies a pointer to a DWORD containing the number of
        characters available to the NodeName buffer (including the terminating
        NULL character. On return, it is the number of characters written
        into the NodeName buffer not including the NULL character.

Returns:

    Returns the current state of the group:

        ClusterGroupOnline
        ClusterGroupOffline
        ClusterGroupPending
        ClusterGroupPartialOnline
        ClusterGroupFailed

    If the function fails, then the return value is ClusterGroupStateUnknown.

--*/

{
    CLUSTER_GROUP_STATE state;
    DWORD nameLength=0;
    DWORD length;

    if ( ARGUMENT_PRESENT( NameLength ) ) {
        nameLength = *NameLength;
        *NodeName = (WCHAR)0;
        *NameLength = 0;
    }

    FmpMustBeOnlineEx( ClusterGroupStateUnknown );

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Check if the OwnerNodes exists 
    //
    // SS: dont filter out the node if it not in the preferred list
    // how is the poor user going to know who the current owner is??
    if (Group->OwnerNode != NULL) {
        //
        // The Group is 'owned' by some system
        //
        if ( ARGUMENT_PRESENT( NameLength ) ) {
            length = lstrlenW( OmObjectName(Group->OwnerNode) ) + 1;
            if ( nameLength < length ) {
                length = nameLength;
            }
            lstrcpynW( NodeName, OmObjectName(Group->OwnerNode), length );
            *NameLength = length;
        }
    }

    //
    // Get the group state which is not normalized
    //
    state = FmpGetGroupState( Group, FALSE );

    FmpReleaseLocalGroupLock( Group );

    if ( state == ClusterGroupStateUnknown ) {
        SetLastError(ERROR_INVALID_STATE);
    }

    return(state);

} // FmGetGroupState



DWORD
WINAPI
FmEnumerateGroupResources(
    IN PFM_GROUP Group,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    Enumerate all the resources in a group.

Arguments:

    Group - Supplies the group which must be enumerated.

    EnumerationRoutine - The enumeration function.

    Context1 - The enumeration list (allocated by the caller).

    Context2 - Size of the enumerated list.

Returns:

    ERROR_SUCCESS on success.

    A Win32 error code otherwise.

Comments:

    This function executes only when the FM is fully online.

--*/
{
    FmpMustBeOnline();

    FmpEnumerateGroupResources( Group,
                                EnumerationRoutine,
                                Context1,
                                Context2 );

    return(ERROR_SUCCESS);
} // FmEnumerateGroupResources

DWORD
FmpEnumerateGroupResources(
    IN PFM_GROUP pGroup,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE pfnEnumerationRoutine,
    IN PVOID pContext1,
    IN PVOID pContext2
    )
/*++

Routine Description:

    Enumerate all the resources in a group.

Arguments:

    pGroup - Supplies the group which must be enumerated.

    pfnEnumerationRoutine - The enumeration function.

    pContext1 - The enumeration list (allocated by the caller).

    pContext2 - Size of the enumerated list.

Returns:

    ERROR_SUCCESS.

Comments:

    This function executes even when the FM is not fully online. This is
    necessary for a joining node to query the resource states while the
    owner node of the group is shutting down.

--*/
{
    PFM_RESOURCE pResource;
    PLIST_ENTRY  pListEntry;
    
    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpEnumerateGroupResources: Entry for group <%1!ws!>....\n",
              OmObjectId(pGroup));

    FmpAcquireLocalGroupLock( pGroup );

    //
    // If the group has been marked for delete, then fail this call
    //
    if ( !IS_VALID_FM_GROUP( pGroup ) )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
              "[FM] FmpEnumerateGroupResources: Group <%1!ws!> marked for deletion....\n",
              OmObjectId(pGroup));
        goto FnExit;
    }

    //
    // Run through contains list, then find all resources under that tree.
    //
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &(pGroup->Contains);
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry, 
                                       FM_RESOURCE, 
                                       ContainsLinkage );

        if ( !pfnEnumerationRoutine( pContext1,
                                     pContext2,
                                     pResource,
                                     OmObjectId( pResource ) ) ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpEnumerateGroupResources: Enumeration routine for group <%1!ws!> fails....\n",
                      OmObjectId(pGroup));
            break;
        }
    }
    
FnExit:
    FmpReleaseLocalGroupLock( pGroup );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpEnumerateGroupResources: Exit for group <%1!ws!>....\n",
              OmObjectId(pGroup));
    return( ERROR_SUCCESS );
} // FmpEnumerateGroupResources




////////////////////////////////////////////////////////
//
// Resource management functions.
//
////////////////////////////////////////////////////////

PFM_RESOURCE
WINAPI
FmCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    Create the specified resource.

    Note that the returned PFM_RESOURCE will have already been referenced.
    This prevents somebody from deleting the resource before the caller
    gets a chance to reference it.

Arguments:

    Group - Supplies the group in which this resource belongs.

    ResourceId - Supplies the Id of the resource to create.

    ResourceName - Supplies the 'user-friendly' name of the resource.

    ResourceType - Supplies the 'user-friendly' name of the resource type.

    dwFlags - The flags for the resource.

Returns:

    Pointer to the newly created resource if successful.

    NULL if unsuccessful. GetLastError() will return the specific error.

--*/

{
    DWORD Status;
    PFM_RESOURCE Resource;
    LPCWSTR GroupId;
    PGUM_CREATE_RESOURCE GumResource;
    DWORD GroupIdLen;
    DWORD ResourceIdLen;
    DWORD ResourceNameLen;
    DWORD ResourceTypeLen;
    DWORD BufSize;
    HDMKEY ResourceKey;
    HDMKEY ParamsKey;
    DWORD  Disposition;

    FmpMustBeOnlineEx( NULL );

    FmpAcquireLocalGroupLock( Group );

    //
    // If we own the group then we can issue the Gum request to create
    // the resource. Otherwise, request the owner to initiate the request.
    //
    if ( Group->OwnerNode == NmLocalNode ) {
        //
        // Allocate a message buffer.
        //
        GroupId = OmObjectId(Group);
        GroupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
        ResourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
        ResourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
        ResourceTypeLen = (lstrlenW(ResourceType)+1) * sizeof(WCHAR);
        BufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
                  GroupIdLen + ResourceIdLen + ResourceNameLen + ResourceTypeLen + 2 * sizeof( DWORD );
        GumResource = LocalAlloc(LMEM_FIXED, BufSize);
        if (GumResource == NULL) {
            CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        //
        // Fill in message buffer.
        //
        GumResource->Resource = NULL;
        GumResource->GroupIdLen = GroupIdLen;
        GumResource->ResourceIdLen = ResourceIdLen;
        CopyMemory(GumResource->GroupId, GroupId, GroupIdLen);
        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen,
                   ResourceId,
                   ResourceIdLen);
        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen,
                   ResourceName,
                   ResourceNameLen);

        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen + ResourceNameLen,
                   &ResourceTypeLen,
                   sizeof( DWORD ) );

        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen + ResourceNameLen + sizeof( DWORD ),
                   ResourceType,
                   ResourceTypeLen );

        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen + ResourceNameLen + sizeof( DWORD ) + ResourceTypeLen,
                   &dwFlags,
                   sizeof( DWORD ) );

        //
        // Send message.
        //
        Status = GumSendUpdate(GumUpdateFailoverManager,
                               FmUpdateCreateResource,
                               BufSize,
                               GumResource);

        FmpReleaseLocalGroupLock( Group );
        if (Status != ERROR_SUCCESS) {
            LocalFree(GumResource);
            SetLastError(Status);
            return(NULL);
        }
        //The create resource by default adds all nodes
        //as possible nodes for a resource without filtering
        //out the nodes that dont support the resource type
        if( GumResource->Resource != NULL ) {
            FmpCleanupPossibleNodeList(GumResource->Resource);
       	}
        Resource = GumResource->Resource;
        if( ( Resource == NULL ) && FmpShutdown ) {
            SetLastError( ERROR_CLUSTER_NODE_SHUTTING_DOWN );
        }
        LocalFree(GumResource);
    } else {
        //
        // The Group lock is released by FmcCreateResource
        //
        Resource = FmcCreateResource( Group,
                                      ResourceId,
                                      ResourceName,
                                      ResourceType,
                                      dwFlags );
    }


    //giving a reference to the client, increment ref count
    if ( Resource ) {
        OmReferenceObject(Resource);
    }

    return(Resource);

} // FmCreateResource



DWORD
WINAPI
FmDeleteResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Delete the specified resource.

Arguments:

    Resource - Supplies the resource to delete.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD Status;
    LPCWSTR ResourceId;
    DWORD ResourceLen;

    FmpMustBeOnline( );

    FmpAcquireLocalResourceLock( Resource );

    //
    // Check if this is the quorum resource.
    //
    if ( Resource->QuorumResource ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_QUORUM_RESOURCE);
    }

    //other core resources cannot be deleted either
    if (Resource->ExFlags & CLUS_FLAG_CORE)
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_CORE_RESOURCE);
    }

    //
    // If we own the resource then we can issue the Gum request to delete
    // the resource. Otherwise, request the owner to initiate the request.
    //
    if ( Resource->Group->OwnerNode == NmLocalNode ) {

        //
        // Check the state of the resource, before attempting to delete it.
        // It must be offline or failed in order to perform the delete.
        //
        if ((Resource->State != ClusterResourceOffline) &&
            (Resource->State != ClusterResourceFailed)) {
            FmpReleaseLocalResourceLock( Resource );
            return(ERROR_RESOURCE_ONLINE);
        }

        //
        // Check whether this resource provides for any other resources.
        // If so, it cannot be deleted.
        //
        if (!IsListEmpty(&Resource->ProvidesFor)) {
            FmpReleaseLocalResourceLock( Resource );
            return(ERROR_DEPENDENT_RESOURCE_EXISTS);
        }

        if (Resource->Group->MovingList)
        {
            FmpReleaseLocalResourceLock( Resource );
            return(ERROR_INVALID_STATE);
        }
        
        Status = FmpBroadcastDeleteControl(Resource);
        if ( Status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            return(Status);
        }
        ResourceId = OmObjectId( Resource );
        ResourceLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);

        //
        // Send message.
        //
        Status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateDeleteResource,
                                 1,
                                 ResourceLen,
                                 ResourceId);
        FmpReleaseLocalResourceLock( Resource );
    } else {
        Status = FmcDeleteResource( Resource );
    }

    return(Status);

} // FmDeleteResource



DWORD
WINAPI
FmSetResourceName(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR FriendlyName
    )

/*++

Routine Description:

    Set the user-friendly name for the specified resource.

    Note that the resource must have already been created. It is also
    assumed that the caller of this routine (the cluster API) has already
    verified that the name is NOT a duplicate.

Arguments:

    Resource - Supplies the resource to enter a new name.

    FriendlyName - Supplies the user-friendly name for the resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    dwStatus = FmpSetResourceName( Resource, FriendlyName );
    
    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmSetResourceName: FmpSetResourceName for resource %1!ws! fails, Status = %2!d!...\n",
                   OmObjectId(Resource),
                   dwStatus);
    }
  
    return( dwStatus );
} // FmSetResourceName



DWORD
WINAPI
FmOnlineResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine brings a resource online. It also updates the registry to
    indicate the new persistent, desired state of the resource.


Arguments:

    Resource - A pointer to the resource to bring online.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD       status;

    FmpMustBeOnline( );

    FmpAcquireLocalResourceLock( Resource );

    //if the resource has been marked for delete, then dont let
    //it be brought online
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_RESOURCE_NOT_AVAILABLE);
    }


    //
    // Check if we are the owner... if not, ship the request off someplace
    // else.
    //
    CL_ASSERT( Resource->Group != NULL );
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalResourceLock( Resource );
        status = FmcOnlineResourceRequest( Resource );
        return(status);
    }

    //
    // Check if the resource has been initialized. If not, attempt
    // to initialize the resource now.
    //
    if ( Resource->Monitor == NULL ) {
        status = FmpInitializeResource( Resource, TRUE );
        if ( status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            return(status);
        }
    }

    //
    //  Chittur Subbaraman (chitturs) - 08/04/2000
    //
    //  If the group is moving, fail this operation.
    //
    if ( Resource->Group->MovingList != NULL )
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Try to bring the resource online.
    //
    status = FmpDoOnlineResource( Resource, TRUE );
    FmpReleaseLocalResourceLock( Resource );
    return(status);

} // FmOnlineResource



DWORD
WINAPI
FmOfflineResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine takes a resource offline. It also updates the registry
    to indicate the new persistent, desired state of the resource.


Arguments:

    Resource - A pointer to the resource to take offline.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD   status;

    FmpMustBeOnline( );


    FmpAcquireLocalResourceLock( Resource );

    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Check if this is the quorum resource.
    //
    if ( Resource->QuorumResource ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_QUORUM_RESOURCE);
    }


    //
    //  Chittur Subbaraman (chitturs) - 4/8/99
    //  
    //  Don't attempt to do anything if the resource has failed. You could
    //  get into some funny cases in which the resource switches between
    //  offline pending and failed states for ever.
    //
    if ( Resource->State == ClusterResourceFailed ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_INVALID_STATE);
    }
    
    //
    // Check if we are the owner... if not, ship the request off someplace
    // else.
    //
    CL_ASSERT( Resource->Group != NULL );
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalResourceLock( Resource );
        return(FmcOfflineResourceRequest(Resource));
    }

    //
    // Check if the resource has been initialized. If not, return
    // success because the resource is not online.
    //
    if ( Resource->Monitor == NULL ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    //  Chittur Subbaraman (chitturs) - 08/04/2000
    //
    //  If the group is moving, fail this operation.
    //
    if ( Resource->Group->MovingList != NULL )
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Take the resource offline.
    //
    FmpReleaseLocalResourceLock( Resource );
    return(FmpDoOfflineResource( Resource, TRUE));

} // FmOfflineResource



CLUSTER_RESOURCE_STATE
WINAPI
FmGetResourceState(
    IN PFM_RESOURCE Resource,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength OPTIONAL
    )

/*++

Routine Description:

    Get the current state for the specified resource. The resource state
    consists of state of the resource, along with the current node that is
    hosting the resource.

Arguments:

    Resource - Supplies the resource object to get the state.

    NodeName - Supplies a pointer to a buffer into which the name of
        the node in the cluster the specified resource is currently hosted.
        This field can be NULL, if NameLength is zero.

    NameLength - Supplies a pointer to a DWORD containing the number of
        characters available to the NodeName buffer (including the terminating
        NULL character. On return, it is the number of characters written
        into the NodeName buffer not including the NULL character.

Returns:

    Returns the current state of the resource:

        ClusterResourceOnline
        ClusterResourceOffline
        ClusterResourceFailed
        etc.

    If the function fails, then the return value is ClusterResourceStateUnknown.

--*/

{
    WCHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD nameLength;
    DWORD length;
    PNM_NODE OwnerNode;
    CLUSTER_RESOURCE_STATE state;
    BOOL    acquired;

    CL_ASSERT( OmObjectSignature(Resource) == FMP_RESOURCE_SIGNATURE );
    if ( ARGUMENT_PRESENT( NameLength ) ) {
        nameLength = *NameLength;
        *NodeName = (WCHAR)0;
        *NameLength = 0;
    }

    FmpMustBeOnlineEx( ClusterResourceStateUnknown );

    //
    // Try to acquire the lock to perform this work, so that resources
    // can query their current status and where the resource should be run.
    //
    // This does leave a potential window though if we can't get the lock,
    // some other thread could be changing the data!
    //

    FmpTryAcquireLocalResourceLock( Resource, acquired );

    OwnerNode = Resource->Group->OwnerNode;
    if ( OwnerNode != NULL ) {
        //
        // The Group is 'owned' by some system
        //
        if ( ARGUMENT_PRESENT( NameLength ) ) {
            length = lstrlenW( OmObjectName(OwnerNode) ) + 1;
            if ( nameLength < length ) {
                length = nameLength;
            }
            lstrcpynW( NodeName,
                       OmObjectName(OwnerNode),
                       length );
            *NameLength = length;
        }
    }

    state = Resource->State;

    if ( acquired ) {
        FmpReleaseLocalResourceLock( Resource );
    }

    if ( state == ClusterGroupStateUnknown ) {
        SetLastError(ERROR_INVALID_STATE);
    }

    return(state);

} // FmGetResourceState



DWORD
WINAPI
FmAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Add a dependency from one resource to another.

Arguments:

    Resource - The resource to add the dependent resource.

    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    LPCWSTR     pszResourceId;
    DWORD       dwResourceLen;
    LPCWSTR     pszDependsOnId;
    DWORD       dwDependsOnLen;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Modify this API to route requests to owner node. Handle the
    //  mixed mode case as well.
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmAddResourceDependency : Resource <%1!ws!>, DependentResource <%2!ws!>...\n",
               OmObjectId( pResource ),
               OmObjectId( pDependentResource ));

    FmpAcquireLocalResourceLock( pResource );
    
    //
    //  Check if we are the owner... if not, ship the request off some place
    //  else.
    //   
    if ( pResource->Group->OwnerNode != NmLocalNode ) 
    {
        //
        // FmcAddResourceDependency releases the local resource lock
        //
        dwStatus = FmcAddResourceDependency( pResource, pDependentResource );
        goto FnExit;
    }
    
    dwStatus = FmpValAddResourceDependency( pResource, pDependentResource );

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnUnlock;
    }


    pszResourceId = OmObjectId( pResource );
    dwResourceLen = ( lstrlenW( pszResourceId ) +1 ) * sizeof( WCHAR) ;

    pszDependsOnId = OmObjectId( pDependentResource );
    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );

    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateAddDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      FALSE );
    }

FnUnlock:
    FmpReleaseLocalResourceLock( pResource );

FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmAddResourceDependency Exit: Status = <%1!u!>...\n",
               dwStatus);

    return( dwStatus  );

}
 // FmAddResourceDependency



DWORD
WINAPI
FmRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Remove a dependency from a resource.

Arguments:

    Resource - The resource to remove the dependent resource.
    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{

    LPCWSTR     pszResourceId;
    DWORD       dwResourceLen;
    LPCWSTR     pszDependsOnId;
    DWORD       dwDependsOnLen;
    DWORD       dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Modify this API to route requests to owner node. Handle the
    //  mixed mode case as well.
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmRemoveResourceDependency : Resource <%1!ws!>, DependentResource <%2!ws!>...\n",
               OmObjectId( pResource ),
               OmObjectId( pDependentResource ));

    FmpAcquireLocalResourceLock( pResource );

    //
    //  Check if we are the owner... if not, ship the request off some place
    //  else.
    //   
    if ( pResource->Group->OwnerNode != NmLocalNode ) 
    {
        //
        // FmcRemoveResourceDependency releases the local resource lock
        //
        dwStatus = FmcRemoveResourceDependency( pResource, pDependentResource );
        goto FnExit;
    }

    dwStatus = FmpValRemoveResourceDependency( pResource, pDependentResource );
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmRemoveResourceDependency: FmpValRemoveResourceDependency returns status = <%1!u!>...\n",
               dwStatus);  
        goto FnUnlock;
    }

    pszResourceId = OmObjectId( pResource );
    dwResourceLen = ( lstrlenW( pszResourceId ) + 1 ) * sizeof( WCHAR );

    pszDependsOnId = OmObjectId( pDependentResource );
    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );


    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateRemoveDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      TRUE );
    }

FnUnlock:    
    FmpReleaseLocalResourceLock( pResource );
FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmRemoveResourceDependency Exit: Status = <%1!u!>...\n",
               dwStatus);

    return( dwStatus );

}

 // FmRemoveResourceDependency



DWORD
WINAPI
FmEnumResourceDependent(
    IN  PFM_RESOURCE Resource,
    IN  DWORD        Index,
    OUT PFM_RESOURCE *DependentResource
    )

/*++

Routine Description:

    Enumerate the dependencies of a resources.

Arguments:

    Resource - The resource to enumerate.

    Index - The index for this enumeration.

    DependentResource - The dependent resource. The returned resource
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY ListEntry;
    DWORD i = 0;
    PFM_RESOURCE Current;
    PDEPENDENCY Dependency;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline( );

    FmpAcquireResourceLock();
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        Status = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    ListEntry = Resource->DependsOn.Flink;
    while (ListEntry != &Resource->DependsOn) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       DependentLinkage);
        CL_ASSERT(Dependency->DependentResource == Resource);
        CL_ASSERT(Dependency->ProviderResource != Resource);
        if (i==Index) {
            //
            // Got the right index
            //
            OmReferenceObject(Dependency->ProviderResource);
            *DependentResource = Dependency->ProviderResource;
            Status = ERROR_SUCCESS;
            break;
        }
        ListEntry = ListEntry->Flink;
        ++i;
    }

FnExit:
    FmpReleaseResourceLock();

    return(Status);
} // FmEnumResourceDependent



DWORD
WINAPI
FmEnumResourceProvider(
    IN  PFM_RESOURCE Resource,
    IN  DWORD        Index,
    OUT PFM_RESOURCE *DependentResource
    )

/*++

Routine Description:

    Enumerate the providers for a resources.

Arguments:

    Resource - The resource to enumerate.

    Index - The index for this enumeration.

    DependentResource - The provider resource. The returned resource
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY ListEntry;
    DWORD i = 0;
    PFM_RESOURCE Current;
    PDEPENDENCY Dependency;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline( );

    FmpAcquireResourceLock();

    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        Status = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    ListEntry = Resource->ProvidesFor.Flink;
    while (ListEntry != &Resource->ProvidesFor) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       ProviderLinkage);
        CL_ASSERT(Dependency->DependentResource != Resource);
        CL_ASSERT(Dependency->ProviderResource == Resource);
        if (i==Index) {
            //
            // Got the right index
            //
            OmReferenceObject(Dependency->DependentResource);
            *DependentResource = Dependency->DependentResource;
            Status = ERROR_SUCCESS;
            break;
        }
        ListEntry = ListEntry->Flink;
        ++i;
    }

FnExit:
    FmpReleaseResourceLock();

    return(Status);

} // FmEnumResourceProvider


DWORD
WINAPI
FmEnumResourceNode(
    IN  PFM_RESOURCE Resource,
    IN  DWORD        Index,
    OUT PNM_NODE     *PossibleNode
    )

/*++

Routine Description:

    Enumerate the possible nodes for a resources.

Arguments:

    Resource - The resource to enumerate.

    Index - The index for this enumeration.

    PossibleNode - The possible node. The returned node
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY ListEntry;
    DWORD i = 0;
    PFM_RESOURCE Current;
    PPOSSIBLE_ENTRY PossibleEntry;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline( );

    FmpAcquireResourceLock();
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        Status = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    
    ListEntry = Resource->PossibleOwners.Flink;
    while (ListEntry != &Resource->PossibleOwners) {
        PossibleEntry = CONTAINING_RECORD(ListEntry,
                                          POSSIBLE_ENTRY,
                                          PossibleLinkage);
        if (i==Index) {
            //
            // Got the right index
            //
            OmReferenceObject(PossibleEntry->PossibleNode);
            *PossibleNode = PossibleEntry->PossibleNode;
            Status = ERROR_SUCCESS;
            break;
        }
        ListEntry = ListEntry->Flink;
        ++i;
    }

FnExit:
    FmpReleaseResourceLock();

    return(Status);

} // FmEnumResourceNode



DWORD
WINAPI
FmFailResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Cause the specified resource to fail.

Arguments:

    Resource - The resource to make fail.

Returns:

    ERROR_SUCCESS - if successful.

    A Win32 error code on failure.

--*/

{
    FmpMustBeOnline( );

    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        return(FmcFailResource( Resource ));
    }

    return(FmpRmFailResource( Resource ));

} // FmFailResource



DWORD
WINAPI
FmChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    )
/*++

Routine Description:

    Changes the list of nodes where the specified resource
    can be brought online.

Arguments:

    Resource - Supplies the resource whose list of possible nodes is
        to be modified.

    Node - Supplies the node to be added to the resource's list.

    Add - Supplies whether the specified node is to be added (TRUE) or
          deleted (FALSE) from the resource's node list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD Status;

    FmpAcquireLocalResourceLock( Resource );

    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        // Note: FmcChangeResourceNode must release the resource lock.
        Status = FmcChangeResourceNode( Resource, Node, Add );
    } 
    else 
    {

        Status = FmpChangeResourceNode(Resource, OmObjectId(Node), Add);
        FmpReleaseLocalResourceLock( Resource );
    }
    return(Status);
} // FmChangeResourceNode




DWORD
WINAPI
FmSetQuorumResource(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR      pszClusFileRootPath,
    IN DWORD        dwMaxQuorumLogSize
    )

/*++

Routine Description:

    Set the specified resource as the quorum resource. This requires making
    sure that the specified resource can perform an arbitrate. We do this
    by asking the owner node to perform an arbitrate of the resource.

Arguments:

    Resource - Supplies the resource that must be arbitrated.

    pszLogPathName - The root path where the log files will be moved. "Microsoft
        Cluster Manager Directory" is created under the root path provided. If NULL,
        a partition on the shared quorum device is picked up randomly. And
        the log files are placed in the directory specified by the
        CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE constant at the root of that partition.

    dwMaxQuorumLogSize - The maximum size of the quorum logs.  If 0, the default
        used.  If smaller that 32K, 32K is used.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           resourceIdLen;
    PFM_RESOURCE    quorumResource = NULL;
    PFM_RESOURCE    pOldQuoResource = NULL;
    PVOID           gumResource = NULL;
    DWORD           dwBytesReturned;
    DWORD           dwRequired;
    DWORD           dwBufSize;
    WCHAR           szQuoLogPath[MAX_PATH] = L"\0";
    WCHAR           szLogRootPath[MAX_PATH];
    CLUS_RESOURCE_CLASS_INFO   resClassInfo;
    PUCHAR          pBuf = NULL;
    LPWSTR          pszOldQuoLogPath = NULL;
    LPWSTR          pszNext = NULL;
    LPWSTR          pszExpClusFileRootPath = NULL;
    DWORD           dwCharacteristics;

    
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: Entry, pszClusFileRootPath=%1!ws!\r\n",
               ((pszClusFileRootPath)? pszClusFileRootPath:szQuoLogPath));

    // find the old quorum resource
    status  =  FmFindQuorumResource(&pOldQuoResource);
    if (status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //
    // Synchronize access to Quorum Resource changes.
    //
    //
    // Synchronize both the old and the new resource.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // if the old and new resource belong to the same group
    // the comparison will be be equal!
    //
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);

    if ( lstrcmpiW( OmObjectId( pOldQuoResource->Group ), 
        OmObjectId( Resource->Group ) )  <= 0 ) {
        FmpAcquireLocalGroupLock( pOldQuoResource->Group );
        FmpAcquireLocalGroupLock( Resource->Group );
    } else {
        FmpAcquireLocalGroupLock( Resource->Group );
        FmpAcquireLocalGroupLock( pOldQuoResource->Group );
    }

    
    if (Resource->State != ClusterResourceOnline)
    {
        status = ERROR_RESOURCE_NOT_ONLINE;
        goto FnExit;

    }
#if 0 // rodga - We can't guarantee the old quorum resource is available!!
// We want to be able to change this when the old quorum is dead.
    //
    //  Chittur Subbaraman (chitturs) - 6/24/99
    //
    //  Make sure the old quorum resource state is also online.
    //
    if ( pOldQuoResource->State != ClusterResourceOnline )
    {
        status = ERROR_RESOURCE_NOT_ONLINE;
        goto FnExit;
    }
#endif
    
    if (!IsListEmpty(&Resource->DependsOn)) 
    {
        status = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }

    //
    // Get the old log path.
    //
    dwBytesReturned = 0;
    dwRequired = 0;

    status = DmQuerySz( DmQuorumKey,
                        cszPath,
                        (LPWSTR*)&pszOldQuoLogPath,
                        &dwRequired,
                        &dwBytesReturned);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmSetQuorumResource Failed to get the old quo log path, error %1!u!.\n",
                   status);
        goto FnExit;
    }
    //SS: if you want to have a sub dir for logging files

    //check the resource class
    status = FmResourceControl(Resource, NULL, CLUSCTL_RESOURCE_GET_CLASS_INFO, NULL, 0,
        (PUCHAR)&resClassInfo, sizeof(resClassInfo), &dwBytesReturned, &dwRequired);
    if ( status != ERROR_SUCCESS )
    {
        goto FnExit;
    }
    if ( (resClassInfo.rc != CLUS_RESCLASS_STORAGE) ||
         ((resClassInfo.SubClass & CLUS_RESSUBCLASS_SHARED) == 0) )
    {
        status = ERROR_NOT_QUORUM_CLASS;
        goto FnExit;
    }

    //allocate info for the disk info
    //get disk info
    dwBufSize = 2048;
Retry:
    pBuf = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pBuf == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    status = FmResourceControl(Resource, NULL, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
        NULL, 0, pBuf, dwBufSize, &dwBytesReturned, &dwRequired);
    if ((status == ERROR_MORE_DATA) && (dwBufSize < dwRequired))
    {
        dwBufSize = dwRequired;
        LocalFree(pBuf);
        goto Retry;
    }

    if (status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    if (pszClusFileRootPath)
        pszExpClusFileRootPath = ClRtlExpandEnvironmentStrings(pszClusFileRootPath);

    //use the expanded path name for validation
    if (pszExpClusFileRootPath)
    {
        WCHAR   cColon=L':';
        
        pszNext = wcschr(pszExpClusFileRootPath, cColon);    
        //pick up just the drive letter
        if (pszNext)
        {
            lstrcpynW(szLogRootPath, pszExpClusFileRootPath, 
                      (UINT)(pszNext-pszExpClusFileRootPath+2));
        }
        else
        {
            //if there is no drive letter, pick up a drive letter at random
            szLogRootPath[0] = L'\0';
        }

    }
    else
    {
        szLogRootPath[0] = L'\0';
    }        

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: szLogRootPath=%1!ws!\r\n",
               szLogRootPath);

    //save the drive letter for the new quorum path
    status = FmpGetDiskInfoParseProperties(pBuf, dwBytesReturned, szLogRootPath);

    //if the status was invalid parameter for a local quorum, ignore the local
    //quorum path setting..what is specified through this api overrides
    if (FmpGetResourceCharacteristics(Resource, &dwCharacteristics) == ERROR_SUCCESS)
    {
        if ((status == ERROR_INVALID_PARAMETER) && 
            (dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM))
        {
            status = ERROR_SUCCESS;
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: LocalQuorum force success, szLogRootPath=%1!ws!\r\n",
                    szLogRootPath);
        }
    }
    else
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: getresourcecharacteristics failed, status=%1!u!\r\n",
               szLogRootPath);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: szLogRootPath=%1!ws!\r\n",
               szLogRootPath);
    
    if (status != ERROR_SUCCESS)
        goto FnExit;

    if (szLogRootPath[0] == L'\0')
    {
        //no valid drive letter is found
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    //got the drive letter
    lstrcpyW(szQuoLogPath, szLogRootPath);
    if (pszNext)
    {
        // if the driver letter was supplied, append the rest of the path
        lstrcatW(szQuoLogPath, pszNext+1);
    }            
    else
    {
        //if no drive letter was supplied 
        // if a path was supplied, append the path 
        if (pszExpClusFileRootPath) 
        {
            //an smb path is valid only for a local quorum
            //if it is a local quorum and if an smb path is specified
            //override the local quorum's path setting
            if ((lstrlenW(pszExpClusFileRootPath) >=2) &&
                (pszExpClusFileRootPath[0] == L'\\') &&
                (pszExpClusFileRootPath[1] == L'\\') &&
                (dwCharacteristics & CLUS_CHAR_QUORUM))
            {
                lstrcpyW(szQuoLogPath, L"\\\\?\\UNC\\");
                lstrcatW(szQuoLogPath, pszExpClusFileRootPath+2);
            }
            else if (pszExpClusFileRootPath[0] == L'\\')
            {
                lstrcatW(szQuoLogPath, pszExpClusFileRootPath);
            }                
            else
            {
                lstrcatW( szQuoLogPath, L"\\" );
                lstrcatW(szQuoLogPath, pszExpClusFileRootPath);
            }
        }                    
        else
        {
            // else append the default path
            lstrcatW( szQuoLogPath, L"\\" );
            lstrcatW(szQuoLogPath, CLUS_NAME_DEFAULT_FILESPATH);
        }            
    }   
    
    //if the path name is provided, check if it is terminated with '\'
    //if not, terminate it
    if (szQuoLogPath[lstrlenW(szQuoLogPath) - 1] != L'\\')
    {
        lstrcatW( szQuoLogPath, L"\\" );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: szQuoLogPath=%1!ws!\r\n",
               szQuoLogPath);
        
    //
    // Allocate a message buffer.
    //
    resourceIdLen = (lstrlenW(OmObjectId(Resource))+1) * sizeof(WCHAR);
    gumResource = LocalAlloc(LMEM_FIXED, resourceIdLen);
    if (gumResource == NULL)
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    //
    // Fill in message buffer.
    //
    CopyMemory(gumResource, OmObjectId(Resource), resourceIdLen);

    //
    // Make sure that we can arbitrate the new quorum resource.
    //
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        status = FmcArbitrateResource( Resource );
    } else {
        status = FmpRmArbitrateResource( Resource );
    }

    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //check the log size, if it not zero but less than the min
    //limit set it to 32K.
    if ((dwMaxQuorumLogSize) && (dwMaxQuorumLogSize < CLUSTER_QUORUM_MIN_LOG_SIZE))
    {
        dwMaxQuorumLogSize = CLUSTER_QUORUM_MIN_LOG_SIZE;
    }
    //Prepare to move to a new quorum resource
    //create a new quorum log file and
    //move the registry files there.
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        status = FmcPrepareQuorumResChange( Resource, szQuoLogPath, dwMaxQuorumLogSize );
    } else {
        status = FmpPrepareQuorumResChange( Resource, szQuoLogPath, dwMaxQuorumLogSize );
    }

    if ( status != ERROR_SUCCESS ) {
        if (dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM)
        {
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: Local quorum, map FmpPrepareQuorumResChange to success\r\n");
            status = ERROR_SUCCESS;               
        }
        else
            goto FnExit;
    }

    
    //
    // Send the message.
    //
    status = GumSendUpdateEx(GumUpdateFailoverManager,
                           FmUpdateChangeQuorumResource,
                           3,
                           resourceIdLen,
                           gumResource,
                           (lstrlenW(szQuoLogPath) + 1 ) * sizeof(WCHAR),
                           szQuoLogPath,
                           sizeof(DWORD),
                           &dwMaxQuorumLogSize
                           );

    //if the old path is not the same as the new path
    //create a tombstone for the quorum log files on the old path
    //this is to prevent nodes that are not present in this update
    //from doing a form.
    if ( (status == ERROR_SUCCESS) &&
         (lstrcmpiW(szQuoLogPath, pszOldQuoLogPath)) ) {
        //
        // delete the old quorum log files on the old resource and create a tombstone file
        // in there.
        //
        if ( pOldQuoResource->Group->OwnerNode != NmLocalNode ) {
            status = FmcCompleteQuorumResChange( pOldQuoResource, pszOldQuoLogPath );
        } else {
            status = FmpCompleteQuorumResChange( OmObjectId(pOldQuoResource), pszOldQuoLogPath );
        }

    }

        
FnExit:
    //not the order of release is not important
    FmpReleaseLocalGroupLock(pOldQuoResource->Group);
    FmpReleaseLocalGroupLock(Resource->Group);
    RELEASE_LOCK(gQuoChangeLock);
    
    if (pBuf) LocalFree(pBuf);
    if (gumResource) LocalFree(gumResource);
    if (pOldQuoResource) OmDereferenceObject(pOldQuoResource);
    if (pszOldQuoLogPath) LocalFree(pszOldQuoLogPath);
    if (pszExpClusFileRootPath) LocalFree(pszExpClusFileRootPath);
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: Exit, status=%1!u!\r\n",
               status);
    
    return(status);

} // FmSetQuorumResource


DWORD
FmCreateResourceType(
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    )
/*++

Routine Description:

    Issues a GUM update to instantiate a resource type on every
    node. The registry update as well as the FM in-memory state
    update is done as a transaction within the GUM handler (NT5
    clusters only).

Arguments:

    lpszTypeName - Supplies the name of the new cluster resource type.

    lpszDisplayName - Supplies the display name for the new resource
        type. While lpszResourceTypeName should uniquely identify the
        resource type on all clusters, the lpszDisplayName should be
        a localized friendly name for the resource, suitable for displaying
        to administrators.

    lpszDllName - Supplies the name of the new resource types DLL.

    dwLooksAlive - Supplies the default LooksAlive poll interval
        for the new resource type in milliseconds.

    dwIsAlive - Supplies the default IsAlive poll interval for
        the new resource type in milliseconds.   

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD       dwStatus = ERROR_SUCCESS;
    PFM_RESTYPE pResType = NULL;
    DWORD       dwTypeNameLen;
    DWORD       dwDisplayNameLen;
    DWORD       dwDllNameLen;
    DWORD       dwBufferLen;
    LPVOID      Buffer = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 2/8/2000
    //
    //  Rewrite this API to use a GUM handler which performs a local 
    //  transaction for NT5.1
    //
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmCreateResourceType: Entry for %1!ws!...\r\n",
               lpszTypeName);

    dwTypeNameLen = ( lstrlenW( lpszTypeName ) + 1 ) * sizeof( WCHAR );
    dwDisplayNameLen = ( lstrlenW( lpszDisplayName ) + 1 ) * sizeof( WCHAR );
    dwDllNameLen = ( lstrlenW( lpszDllName ) + 1 ) * sizeof( WCHAR );
    dwBufferLen = dwTypeNameLen + dwDisplayNameLen + dwDllNameLen +
                         2 * sizeof( DWORD );

    Buffer = LocalAlloc( LMEM_FIXED, dwBufferLen );

    if ( Buffer == NULL )
    {
        CsInconsistencyHalt( GetLastError() );
    }

    CopyMemory( Buffer, lpszTypeName, dwTypeNameLen );
    CopyMemory( ( PCHAR ) Buffer + dwTypeNameLen, lpszDisplayName, dwDisplayNameLen );
    CopyMemory( ( PCHAR ) Buffer + dwTypeNameLen + dwDisplayNameLen, lpszDllName, dwDllNameLen );
    CopyMemory( ( PCHAR ) Buffer + 
                dwTypeNameLen + 
                dwDisplayNameLen + 
                dwDllNameLen, &dwLooksAlive, sizeof( DWORD ) );
    CopyMemory( ( PCHAR ) Buffer + 
                dwTypeNameLen + 
                dwDisplayNameLen + 
                dwDllNameLen + sizeof( DWORD ), &dwIsAlive, sizeof( DWORD ) );
              
    dwStatus = GumSendUpdate( GumUpdateFailoverManager,
                              FmUpdateCreateResourceType,
                              dwBufferLen,
                              Buffer );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmCreateResourceType: FmUpdateCreateResourceType for %1!ws! returned %2!u!...\r\n",
                    lpszTypeName,
                    dwStatus);
        goto FnExit;
    }

    dwStatus = FmpSetPossibleNodeForResType( lpszTypeName , FALSE );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmCreateResourceType: FmpSetPossibleNodeForResType for %2!ws! returned <%1!u!>...\r\n",
                    lpszTypeName,
                    dwStatus);
        goto FnExit;
    }

    pResType = OmReferenceObjectById( ObjectTypeResType, lpszTypeName );

    ClusterWideEvent( CLUSTER_EVENT_RESTYPE_ADDED, pResType );

    OmDereferenceObject( pResType );
    
FnExit:
    LocalFree( Buffer );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmCreateResourceType: Exit for %1!ws!, Status=%2!u!...\r\n",
               lpszTypeName,
               dwStatus);
    
    return( dwStatus );   
} // FmCreateResourceType



DWORD
FmDeleteResourceType(
    IN LPCWSTR TypeName
    )
/*++

Routine Description:

    Issues a GUM update to delete a resource type on every
    node.

Arguments:

    TypeName - Supplies the name of the cluster resource type
        to delete

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    PFM_RESTYPE     pResType;

    //
    //  Chittur Subbaraman (chitturs) - 5/9/2001
    //  
    //  Make sure the resource type exists so that you can avoid a GUM if 
    //  that is not necessary. This also takes care of the case in which one node was
    //  shutting down and so the GUM returns success and another node fails in the GUM
    //  and gets evicted since the resource type does not exist.
    //
    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      TypeName );

    if ( pResType == NULL ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                     "[FM] FmDeleteResourceType: Resource type %1!ws! does not exist...\n",
                      TypeName);
        return( ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND );
    }

    OmDereferenceObject ( pResType );
    
    return(GumSendUpdate( GumUpdateFailoverManager,
                          FmUpdateDeleteResourceType,
                          (lstrlenW(TypeName)+1)*sizeof(WCHAR),
                          (PVOID)TypeName ));


} // FmDeleteResourceType

/****
@func       DWORD | FmEnumResTypeNode | Enumerate the possible nodes for
            a resource type

@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type
@parm       IN DWORD | dwIndex | The index for this enumeration.
@parm       OUT PNM_NODE | pPossibleNode | The possible node. The returned node
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

@comm       This routine helps enumerating all the nodes that a particular
            resource type can be supported on.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       
****/
DWORD
FmEnumResourceTypeNode(
    IN  PFM_RESTYPE  pResType,
    IN  DWORD        dwIndex,
    OUT PNM_NODE     *pPossibleNode
    )
{
    PLIST_ENTRY pListEntry;
    DWORD i = 0;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline();

    // 
    // Chittur Subbaraman (chitturs) - 09/06/98
    //
    // The creation and deletion of resource types are done
    // via atomic GUM operations. Hence these two operations
    // (i.e. API's) are guaranteed to be mutually exclusive.
    // In contrast, the resource type enumeration operation
    // is not mutually exclusive with either the create
    // or the delete operation. Thus, when a resource type is
    // being created/deleted, there is nothing that prevents a 
    // client from trying to enumerate the same resource type 
    // in a concurrent fashion, thus producing a potential race
    // condition. Thus, it is advisable to consider some form 
    // of locking to avoid this situation !
    //
    
    // update the list to include all nodes that now support 
    // the resource type
    if (dwIndex == 0) 
        FmpSetPossibleNodeForResType(OmObjectId(pResType), TRUE);

    ACQUIRE_SHARED_LOCK(gResTypeLock);

    pListEntry = pResType->PossibleNodeList.Flink;
    while (pListEntry != &pResType->PossibleNodeList) {
        pResTypePosEntry = CONTAINING_RECORD(pListEntry,
                                          RESTYPE_POSSIBLE_ENTRY,
                                          PossibleLinkage);
        if (i==dwIndex) {
            //
            // Got the right index
            //
            OmReferenceObject(pResTypePosEntry->PossibleNode);
            *pPossibleNode = pResTypePosEntry->PossibleNode;
            Status = ERROR_SUCCESS;
            break;
        }
        pListEntry = pListEntry->Flink;
        ++i;
    }

    RELEASE_LOCK(gResTypeLock);

    return(Status);

} // FmEnumResTypeNode


DWORD
FmChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    )
/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    Resource - Supplies the resource to move.

    Group - Supplies the new group that the resource should be in.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD               dwStatus;
    PFM_GROUP           pOldGroup;
    
    FmpMustBeOnline( );
  
    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmChangeResourceGroup : Resource <%1!ws!> NewGroup %2!lx!\n",
       OmObjectId( pResource ),
       OmObjectId( pNewGroup));

    //
    // Synchronize both the old and the new groups.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // strictly, the comparison below cannot be equal!
    //
    if ( lstrcmpiW( OmObjectId( pResource->Group ), OmObjectId( pNewGroup ) ) <= 0 ) {
        FmpAcquireLocalGroupLock( pResource->Group );
        FmpAcquireLocalGroupLock( pNewGroup );
    } else {
        FmpAcquireLocalGroupLock( pNewGroup );
        FmpAcquireLocalGroupLock( pResource->Group );
    }


    //remember the old group for freeing locks
    pOldGroup = pResource->Group;
    
    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnUnlock;
    }

    
    //
    // Check if we're moving to same group.
    //
    if (pResource->Group == pNewGroup) {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnUnlock;
    }


    if ( pResource->Group->OwnerNode != NmLocalNode ) {
        // Note: FmcChangeResourceNode must release the both resource lock.
        dwStatus = FmcChangeResourceGroup( pResource, pNewGroup);
        goto FnExit;
    } 
    else 
    {
        dwStatus = FmpChangeResourceGroup(pResource, pNewGroup );
    }


FnUnlock:
    FmpReleaseLocalGroupLock(pNewGroup);
    FmpReleaseLocalGroupLock(pOldGroup);
FnExit:
    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmChangeResourceGroup : returned <%1!u!>\r\n",
       dwStatus);
    return(dwStatus);

} // FmChangeResourceGroup


DWORD
FmChangeClusterName(
    IN LPCWSTR NewName
    )
/*++

Routine Description:

    Changes the name of the cluster

Arguments:

    NewName - Supplies the new cluster name.

Return Value:

    ERROR_SUCCESS if successful. ERROR_RESOURCE_PROPERTIES STORED if the name
    has been changed but wont be effective until the core network name resource
    is brought online again.

    Win32 error code otherwise

--*/

{
    DWORD Status=ERROR_INVALID_PARAMETER;

    Status = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateChangeClusterName,
                             1,
                             (lstrlenW(NewName)+1)*sizeof(WCHAR),
                             NewName);

    //the core network name property/cluster name has been set
    //but the name change isnt effective till the resource is brought
    //online again
    if (Status == ERROR_SUCCESS) {
        Status = ERROR_RESOURCE_PROPERTIES_STORED;
    }

    return(Status);

} // FmChangeClusterName




DWORD
FmpSetResourceName(
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      lpszFriendlyName
    )

/*++

Routine Description:

    Updates the resource name consistently in the fm databases across
    the cluster.

Arguments:

    pResource - The resource whose name is changed.

    lpszFriendlyName - The new name of the resource.


Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    LPCWSTR ResourceId;
    DWORD Status;

    ResourceId = OmObjectId(pResource);

    return(GumSendUpdateEx( GumUpdateFailoverManager,
                            FmUpdateChangeResourceName,
                            2,
                            (lstrlenW(ResourceId)+1)*sizeof(WCHAR),
                            ResourceId,
                            (lstrlenW(lpszFriendlyName)+1)*sizeof(WCHAR),
                            lpszFriendlyName ));

} // FmpSetResourceName




DWORD
FmpRegUpdateClusterName(
    IN LPCWSTR szNewClusterName
    )

/*++

Routine Description:

    This routine updates the cluster name in the cluster database.

Arguments:

    szNewClusterName - A pointer to the new cluster name string.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{

    return(DmSetValue( DmClusterParametersKey,
                       CLUSREG_NAME_CLUS_NAME,
                       REG_SZ,
                       (CONST BYTE *)szNewClusterName,
                       (lstrlenW(szNewClusterName)+1)*sizeof(WCHAR) ));

} // FmpRegUpdateClusterName



DWORD
FmEvictNode(
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Removes any references to the specified node that the FM might
    have put on.

Arguments:

    Node - Supplies the node that is being evicted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    //add a reference to the node object, the worker thread will remove this
    OmReferenceObject(Node);
    FmpPostWorkItem(FM_EVENT_NODE_EVICTED,
                    Node,
                    0);


    return(ERROR_SUCCESS);

} // FmEvictNode



BOOL
FmCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    )

/*++

Routine Description:

    Check if any IP Address resource has a dependency on a given network.

Arguments:

    DependentNetwork - the GUID for the network to check.

Return Value:

    TRUE - if an IP Address resource depends on the given network.
    FALSE otherwise.

--*/

{

    return( FmpCheckNetworkDependency( DependentNetwork ) );

} // FmCheckNetworkDependency

DWORD
WINAPI
FmBackupClusterDatabase(
    IN LPCWSTR      lpszPathName
    )

/*++

Routine Description:

    Attempts a backup of the quorum log files.
    
Arguments:

    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    PFM_RESOURCE    pQuoResource = NULL;

    FmpMustBeOnline( ); 

    //
    //  Chittur Subbaraman (chitturs) - 10/12/98
    //
    //  Find the quorum resource
    //
    status  =  FmFindQuorumResource( &pQuoResource );
    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmBackupQuorumLog: Could not find quorum resource...\r\n");
        goto FnExit;
    }
    // 
    //  Acquire the local resource lock
    //
    FmpAcquireLocalResourceLock( pQuoResource );
    
    //
    //  Handle the request here if this node is the owner of the
    //  quorum resource, else redirect it to the appropriate node.
    //
    if ( pQuoResource->Group->OwnerNode != NmLocalNode ) 
    {
        // 
        //  This function will release the resource lock
        //
        status = FmcBackupClusterDatabase( pQuoResource, lpszPathName );
    } else 
    {
        status = FmpBackupClusterDatabase( pQuoResource, lpszPathName );
        FmpReleaseLocalResourceLock( pQuoResource );
    }

FnExit:
    return( status );
} // FmBackupClusterDatabase

DWORD
FmpBackupClusterDatabase(
    IN PFM_RESOURCE pQuoResource,
    IN LPCWSTR      lpszPathName
    )

/*++

Routine Description:

    This routine first waits until the quorum resource becomes
    online. Then, it attempts to backup the quorum log file and the
    checkpoint file to the specified directory path. This function
    is called with the local resource lock held.

Arguments:

    pQuoResource - Pointer to the quorum resource.

    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Comments:

    The order in which the locks are acquired is very crucial here.
    Carelessness in following this strict order of acquisition can lead 
    to potential deadlocks. The order that is followed is
        (1) Local resource lock - pQuoResource->Group->Lock acquired 
            outside this function.
        (2) Global quorum resource lock - gQuoLock acquired here
        (3) Global Dm root lock - gLockDmpRoot acquired in 
            DmBackupClusterDatabase( ).

--*/

{
    DWORD   retry = 200;
    DWORD   Status = ERROR_SUCCESS;

    CL_ASSERT( pQuoResource->Group->OwnerNode == NmLocalNode );

    //
    //  Chittur Subbaraman (chitturs) - 10/12/1998
    //  
    //  If quorum logging is not turned on, then log an error
    //  and exit immediately.
    //
    if ( CsNoQuorumLogging )
    {        
        Status = ERROR_QUORUMLOG_OPEN_FAILED;
        CL_LOGFAILURE( ERROR_QUORUMLOG_OPEN_FAILED );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: Quorum logging is not turned on, can't backup...\r\n");
        goto FnExit;
    }

CheckQuorumState:
    ACQUIRE_EXCLUSIVE_LOCK( gQuoLock );
    //
    //  Check the state of the quorum resource. If it has failed or is
    //  offline, release the lock and exit immediately !
    //
    if ( pQuoResource->State == ClusterResourceFailed )
    {
        Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
        CL_LOGFAILURE( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: Quorum resource is in failed state, exiting...\r\n");
        RELEASE_LOCK( gQuoLock );
        goto FnExit;
    }

    //
    //  Check if the quorum resource is online. If the quorum resource 
    //  is marked as waiting and offlinepending, it is actually online.
    //  If the quorum resource still needs to come online, release the 
    //  lock and wait.
    //
    if ( ( ( pQuoResource->State != ClusterResourceOnline ) &&
          ( ( pQuoResource->State != ClusterResourceOfflinePending ) ||
           ( !( pQuoResource->Flags & RESOURCE_WAITING ) ) ) )
            ) 
    {
        //
        //  We release the lock here since the quorum resource
        //  state transition from pending needs to acquire the lock.
        //  In general it is a bad idea to do a wait holding locks.
        //
        RELEASE_LOCK( gQuoLock );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: Release ghQuoLock and wait on ghQuoOnlineEvent...\r\n");
        Status = WaitForSingleObject( ghQuoOnlineEvent, 500 );
        if ( Status == WAIT_OBJECT_0 ) 
        {
            //
            //  If we are going to retry, wait a little bit and retry.
            //
            Sleep( 500 );
        }
        if ( retry-- ) 
        {
            goto CheckQuorumState;
        }

        CL_LOGFAILURE( ERROR_QUORUM_RESOURCE_ONLINE_FAILED ) ;
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: All retries to check for quorum resource online failed, exiting...\r\n");
        return( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );
    }
    
    Status = DmBackupClusterDatabase( lpszPathName ); 
    
    RELEASE_LOCK( gQuoLock );
FnExit:
    return ( Status );
} // FmpBackupClusterDatabase



/****
@func       WORD| FmCheckQuorumState| If the quorum resource is online
            on this node right now, it calls the callback and the boolean
            value passed in is set to FALSE.  If not, the boolean is 
            set to TRUE.

@parm       LPWSTR | szQuorumLogPath | A pointer to a wide string of size MAX_PATH.
@parm       DWORD | dwSize | The size of szQuorumLogPath in bytes.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
void FmCheckQuorumState(
    FM_ONLINE_ONTHISNODE_CB OnlineOnThisNodeCb, 
    PBOOL pbOfflineOnThisNode)
{
    BOOL    bLocked = FALSE;
    DWORD   dwRetryCount = 1200; // Wait 10 min max
    
    // 
    // SS: The mutual exclusion between this event handler and
    // the synchronous resource online/offline callback is 
    // achieved by using the quorum change lock(gQuoChangeLock)
    //

    //
    // Chittur Subbaraman (chitturs) - 7/5/99
    // 
    // Modify group lock acquisition to release gQuoChangeLock and 
    // retry lock acquisition. This is necessary to take care of the
    // case in which the quorum online notification is stuck in
    // FmpHandleResourceTransition waiting for the gQuoChangeLock and
    // some other resource in the quorum group is stuck in FmpRmOnlineResource
    // holding the quorum group lock and waiting for the quorum resource
    // to go online.
    //
try_acquire_lock:

    ACQUIRE_EXCLUSIVE_LOCK( gQuoChangeLock );

    FmpTryAcquireLocalGroupLock( gpQuoResource->Group, bLocked );

    if ( bLocked == FALSE )
    {
        RELEASE_LOCK( gQuoChangeLock );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmCheckQuorumState - Release gQuoChangeLock, sleep and retry group lock acquisition...\r\n");
        if ( dwRetryCount == 0 )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmCheckQuorumState - Unable to get quorum group lock for 10 min, halting...\r\n");
            CsInconsistencyHalt( ERROR_LOCK_FAILED );
        }
        dwRetryCount --;
        Sleep( 500 );
        goto try_acquire_lock;
    }

    CL_ASSERT( bLocked == TRUE );

    *pbOfflineOnThisNode = FALSE;
    if (gpQuoResource->Group->OwnerNode == NmLocalNode)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmCheckQuorumState - I am owner, check the state of the resource .\r\n");

        //if the quorum resource is not online right now
        //it might be in the middle of a move and this node
        //might be the target of the move 
        //set a flag to indicate that a checkpoint is necessary
        //when it does come online
        if(gpQuoResource->State != ClusterResourceOnline)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmCheckQuorumState - Quorum is owned but not online on this node.\r\n");
            *pbOfflineOnThisNode = TRUE;
        }
        else
        {
            (*OnlineOnThisNodeCb)();
        }
    }
    else
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmCheckQuorumState - Quorum is owned by another node.\r\n");
        *pbOfflineOnThisNode = TRUE;
    }

    FmpReleaseLocalGroupLock(gpQuoResource->Group);
    
    RELEASE_LOCK(gQuoChangeLock);            
}

/****
@func       WORD| FmDoesQuorumAllowJoin| If the quorum resource doesnt support
            multiple nodes, return error.  Added to officially support local quorum resources.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD FmDoesQuorumAllowJoin()
{


    DWORD dwStatus = ERROR_SUCCESS;

    ACQUIRE_SHARED_LOCK(gQuoChangeLock);

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowJoin - Entry\r\n");

    //get the characteristics for the new quorum resource
    dwStatus = FmpGetResourceCharacteristics(gpQuoResource, 
                    &(gpQuoResource->Characteristic));
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmDoesQuorumAllowJoin - couldnt get quorum characteristics %1!u!\r\n",
            dwStatus);
        goto FnExit;
    }

    if ((gpQuoResource->Characteristic & CLUS_CHAR_LOCAL_QUORUM) &&
        !(gpQuoResource->Characteristic & CLUS_CHAR_LOCAL_QUORUM_DEBUG))
    {
        //Note :: we need an error code?
        dwStatus = ERROR_OPERATION_ABORTED;    
    }

FnExit:    
    RELEASE_LOCK(gQuoChangeLock);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowJoin - Exit, Status=%1!u!\r\n",
        dwStatus);

    return(dwStatus);
}

/****
@func       WORD| FmDoesQuorumAllowLogging| If the quorum resource doesnt support
            multiple nodes, return error.  Added to officially support local quorum resources.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD FmDoesQuorumAllowLogging()
{

    DWORD dwStatus = ERROR_SUCCESS;

    ACQUIRE_SHARED_LOCK(gQuoChangeLock);

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowLogging - Entry\r\n");

    //get the characteristics for the new quorum resource
    dwStatus = FmpGetResourceCharacteristics(gpQuoResource, 
                    &(gpQuoResource->Characteristic));
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmDoesQuorumAllowLogging - couldnt get quorum characteristics %1!u!\r\n",
            dwStatus);
        goto FnExit;            
    }

    if (gpQuoResource->Characteristic & CLUS_CHAR_LOCAL_QUORUM) 
    {
        WCHAR szQuorumFileName[MAX_PATH];
        
        //Note :: we need an error code?
        //if the path is an smb path name, we should allow logging
        //else we should disable it
        dwStatus = DmGetQuorumLogPath(szQuorumFileName, sizeof(szQuorumFileName));
        if ((szQuorumFileName[0] == L'\\') && (szQuorumFileName[1] == L'\\'))
        {
            //assume this is an smb path
            //allow logging
            dwStatus = ERROR_SUCCESS;
        }
        else
        {
            dwStatus = ERROR_OPERATION_ABORTED;    
        }            
    }


FnExit:    
    RELEASE_LOCK(gQuoChangeLock);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowLogging - Exit, status=%1!u!\r\n",
        dwStatus);

    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmevent.c

Abstract:

    Event Handler for the Failover Manager component of the
    NT Cluster Service

Author:

    Rod Gamache (rodga) 19-Mar-1996


Revision History:

--*/
#include "fmp.h"

#define LOG_MODULE EVENT

//
// Global data initialized in this module
//


//
// Local functions
//


DWORD
WINAPI
FmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles events for the Failover Manager.

    In many cases the request is posted to the FM's work queue, so
    that the mainline event process is not blocked.

Arguments:

    Event - The event to be processed. Only one event at a time.
            If the event is not handled, return ERROR_SUCCESS.

    Context - A pointer to context associated with the particular event.

Returns:

    ERROR_SHUTDOWN_CLUSTER - if the Cluster must be shutdown.

    A Win32 error code on other errors.

Notes:

    The conservation of energy, and laws of inertia apply here.

    If a resource comes online it is because someone requested it to be so.
    Therefore, the energy from that request goes into the state of the Group,
    by requesting the Group to go online.

    However, if a resource goes offline, it could be because of a failure.
    We therefore only mark the state of a Group as offline if all resources
    contained within the group are offline.

--*/

{
    DWORD status;

    switch ( Event ) {

    case CLUSTER_EVENT_GROUP_FAILED:
        CL_ASSERT( Context != NULL );
        FmpPostWorkItem( FM_EVENT_GROUP_FAILED, Context, 0 );
        break;
        
    case CLUSTER_EVENT_NODE_ADDED:
        CL_ASSERT( Context != NULL );
        FmpPostWorkItem( FM_EVENT_NODE_ADDED, Context, 0 );
        break;

    case CLUSTER_EVENT_NODE_UP:
        ClRtlLogPrint(LOG_NOISE,"[FM] Node up event\n");
        //
        // FM no longer cares about node up events.
        //
        break;

    case CLUSTER_EVENT_NODE_DOWN:
        FmpMajorEvent = TRUE;           // Node Down is a major event.
        ClRtlLogPrint(LOG_NOISE,"[FM] FmpEventHandler::Node down event\n");
        FmpHandleNodeDownEvent( Context );
        break;

    default:
        break;

    }

    return(ERROR_SUCCESS);

} // FmEventHandler


DWORD
WINAPI
FmpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes nodes down cluster events. Update locker/locking nodes
    state and decide if we need to replay last update in async handler.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/
{
    BITSET DownedNodes = (BITSET)((ULONG_PTR)Context);
    DWORD NodeId;


    if (Event != CLUSTER_EVENT_NODE_DOWN_EX) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(BitsetIsNotMember(NmLocalNodeId, DownedNodes));


    ClRtlLogPrint(LOG_NOISE, 
        "[FM] FmpSyncEventHandler:: %1!04X!.\n",
        DownedNodes);

    //
    // mark the nodes that go down
    // till the worker thread finishes processing the groups that belonged
    // to this node, we will block a join from the same node
    //
    for(NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) 
    {

       if (BitsetIsMember(NodeId, DownedNodes))
       {
            gFmpNodeArray[NodeId].dwNodeDownProcessingInProgress = 1;
        }            
    }


    return(ERROR_SUCCESS);
}


VOID
FmpHandleGroupFailure(
    IN PFM_GROUP    Group
    )

/*++

Routine Description:

    Handles Group failure notifications from the resource manager. If the
    Group can be moved to some other system and we are within the failover
    threshold, then move it. Otherwise, just leave the Group (partially)
    online on this system.

Arguments:

    Group - a pointer to the Group object for the failed Group.

Returns:

    None.

--*/

{
    DWORD   status;
    DWORD   tickCount;
    DWORD   withinFailoverPeriod;
    DWORD   failoverPeriodInMs;
    BOOL    newTime;
    PFM_RESOURCE Resource;
    PLIST_ENTRY     listEntry;
 
    FmpAcquireLocalGroupLock( Group );

    if ( ( !IS_VALID_FM_GROUP( Group ) ) || ( Group->OwnerNode != NmLocalNode ) ) {
        FmpReleaseLocalGroupLock( Group );
        return;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpHandleGroupFailure, Entry: Group failure for %1!ws!...\n",
               OmObjectId(Group));

    //
    // Convert Group's failover period from hours to milliseconds.
    //
    failoverPeriodInMs = Group->FailoverPeriod * (3600*1000);

    //
    // Get current time (in tick counts). We can save about 1193 hours worth
    // of milliseconds (or almost 50 days) in one DWORD.
    //
    tickCount = GetTickCount();

    //
    // Compute boolean that indicates if we are whithin the failover period.
    //
    withinFailoverPeriod = ( ((tickCount - Group->FailureTime) <=
                             failoverPeriodInMs ) ? TRUE : FALSE);

    //
    // Tally another failure.
    //
    if ( withinFailoverPeriod ) {
        ++Group->NumberOfFailures;
        newTime = FALSE;
    } else {
        Group->FailureTime = tickCount;
        Group->NumberOfFailures = 1;
        newTime = TRUE;
    }

    //
    // Tell everyone about our new FailureCount. Propagate failure
    // count
    //
    FmpPropagateFailureCount( Group, newTime );

    //
    // If this group is the same as the quorum group and the quorum 
    // resource has failed
    //
    if ( ( gpQuoResource->Group == Group ) && 
         ( gpQuoResource->State == ClusterResourceFailed ) ) 
    {
        FmpCleanupQuorumResource(gpQuoResource);
#if DBG
        if (IsDebuggerPresent())
        {
            DebugBreak();
        }
#endif            
        CsInconsistencyHalt(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
    }

    //
    // First check if we can move the Group someplace else.
    //
    if ( FmpGroupCanMove( Group ) &&
         (Group->NumberOfFailures <= Group->FailoverThreshold) ) {
        //
        //  Chittur Subbaraman (chitturs) - 4/13/99
        //
        //  Now create the FmpDoMoveGroupOnFailure thread to handle the
        //  group move. The thread will wait until the group state becomes
        //  stable and then initiate the move.
        //
        if( !( Group->dwStructState & 
               FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) )
        {
            PMOVE_GROUP  pContext = NULL;
            DWORD        dwThreadId = 0;
            HANDLE       hThread = NULL;

            pContext = LocalAlloc( LMEM_FIXED, sizeof( MOVE_GROUP ) );
            if ( pContext == NULL ) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Group failure for group <%1!ws!>. Unable to allocate memory.\n",
                           OmObjectId(Group));
                FmpReleaseLocalGroupLock( Group );
                return;
            }

            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Group failure for group <%1!ws!>. Create thread to take offline and move.\n",
                       OmObjectId(Group));

            //
            // Reference the Group object. You don't want the group object
            // to be deleted at the time the FmpDoMoveGroupOnFailure thread
            // executes.
            //
            OmReferenceObject( Group );

            pContext->Group = Group;
            pContext->DestinationNode = NULL;

            hThread = CreateThread( NULL,
                                    0,
                                    FmpDoMoveGroupOnFailure,
                                    pContext,
                                    0,
                                    &dwThreadId );

            if ( hThread == NULL ) {
                status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                            "[FM] Failed to create FmpDoMoveGroupOnFailure thread for group <%1!ws!>. Error %2!u!.\n",
                            OmObjectId(Group),
                            status);
                LocalFree( pContext );
                OmDereferenceObject( Group );
            } else {
                CloseHandle( hThread );
                //
                //  Mark the group as being moved on failure. This is necessary
                //  so that you don't spawn new FmpDoMoveGroupOnFailure threads 
                //  which try to concurrently move the group. Note that the
                //  worker thread which calls this function may deliver multiple
                //  failure notifications.
                //
                Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL;
            }
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Group failure for %1!ws!, but can't move. Failure count = %2!d!.\n",
                   OmObjectId(Group), Group->NumberOfFailures);

        // All attempts to bring group online failed - start the watchdog timer
        // to attempt a restart of all failed resources in this group.
        for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) 
        {
            Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
            FmpDelayedStartRes(Resource);
        }       
                   
    }
    
    FmpReleaseLocalGroupLock( Group );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpHandleGroupFailure, Exit: Group failure for %1!ws!...\n",
               OmObjectId(Group));

    return;

} // FmpHandleGroupFailure



BOOL
FmpGroupCanMove(
    IN PFM_GROUP    Group
    )

/*++

Routine Description:

    Indicates whether there is another system that is in the preferred owner
    list that can take a Group.

Arguments:

    Group - the Group to check if it can move.

Returns:

    TRUE - the Group can (probably) move to another system.
    FALSE - there is no place to move this Group.

--*/

{
    DWORD   status;
    PNM_NODE node;

    node = FmpFindAnotherNode( Group, FALSE );
    if (node != NULL ) {
        return(TRUE);
    }

    return(FALSE);

} // FmpGroupCanMove



DWORD
FmpNodeDown(
    PVOID Context
    )

/*++

Routine Description:

    This routine handles a node down event from the NM layer.

Arguments:

    Context - The node that went down.

Returns:

    ERROR_SUCCESS if everything was handled okay.

    ERROR_SHUTDOWN_CLUSTER if catastrophy happens.

    Win32 error code otherwise (???).

--*/
{
    PNM_NODE            pNode = (PNM_NODE)Context;
    DWORD               dwStatus;
    LPCWSTR             pszNodeId;
    DWORD               dwNodeLen;
    DWORD               dwClusterHighestVersion;
    
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpNodeDown::Node down %1!ws!\n",
                    OmObjectId(pNode));

    //
    //  Chittur Subbaraman (chitturs) - 3/30/99
    //
    //  Acquire the global group lock to synchronize with the shutdown
    //
    FmpAcquireGroupLock();
    
    if (!FmpFMOnline || FmpShutdown) 
    {
        //
        // We don't care about membership changes until we have finished
        // initializing and we're not shutting down.
        //
        FmpReleaseGroupLock();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpNodeDown - ignore node down event.\n" );
        return(ERROR_SUCCESS);
    }
    
    FmpReleaseGroupLock();

    //SS: Note all nodes will send this update
    //The latter updates should not find any groups that belong to 
    //this node
    //We cant rely on only the locker node making this update
    //since the locker node may die before it is able to do this and
    //that can result in these groups being orphaned
    pszNodeId = OmObjectId(pNode);
    dwNodeLen = (lstrlenW(pszNodeId)+1)*sizeof(WCHAR);

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    //
    //  If this is a non Win2k-Whistler mixed mode cluster, attempt to randomize the
    //  group preferred owners list and send it as a part of node down GUM.
    //
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) >= 
                NT51_MAJOR_VERSION ) 
    {
        PFM_GROUP_NODE_LIST pGroupNodeList = NULL;

        //
        //  Attempt to get a contiguous buffer containing the list of group IDs and suggested
        //  owners for them.
        //
        dwStatus = FmpPrepareGroupNodeList( &pGroupNodeList );

        if ( dwStatus != ERROR_SUCCESS )
        {
            //
            //  If the call returns ERROR_CLUSTER_INVALID_REQUEST, it means a user has turned
            //  off the randomization algorithm.
            //
            if ( dwStatus != ERROR_CLUSTER_INVALID_REQUEST )
                ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpNodeDown: FmpPrepareGroupNodeList returns %1!u!...\n",
                            dwStatus); 
            LocalFree( pGroupNodeList );
            goto use_old_gum;
        }

        //
        //  If the list does not even contain any entries, just switch to the old gum. No point in
        //  sending the list header around.
        //
        if ( pGroupNodeList->cbGroupNodeList < sizeof ( FM_GROUP_NODE_LIST ) )
        {
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpNodeDown: FmpPrepareGroupNodeList returns empty list...\n"); 
            LocalFree( pGroupNodeList );
            goto use_old_gum;
        }

        //
        //  Invoke GUM to pass around the dead node ID and the randomized group node list
        //
        dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                    FmUpdateUseRandomizedNodeListForGroups,
                                    2,
                                    dwNodeLen,
                                    pszNodeId,
                                    pGroupNodeList->cbGroupNodeList,
                                    pGroupNodeList );

        if ( dwStatus != ERROR_SUCCESS ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmpNodeDown: GUM update FmUpdateUseRandomizedNodeListForGroups failed %1!d!\n",
                       dwStatus);
        }

        LocalFree( pGroupNodeList );
        return( ERROR_SUCCESS );
    }

use_old_gum:      
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                   FmUpdateAssignOwnerToGroups,
                   1,
                   dwNodeLen,
                   pszNodeId);

    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpNodeDown: Gumupdate failed %1!d!\n",
                   dwStatus);
    }

    return(ERROR_SUCCESS);
} // FmpNodeDown



BOOL
WINAPI
FmVerifyNodeDown(
    IN  PNM_NODE Node,
    OUT LPBOOL   IsDown
    )

/*++

Routine Description:

    This routine attempts to verify whether a given node is down. This can
    only be done if there is some shared resource that the other system
    currently 'owns'.  We will attempt to negotiate the shared resource and
    if we 'win' the negotiation we'll declare that other system down. If we
    loose arbitration, we declare the other system as still up.

Arguments:

    Node - A pointer to the node structure for the other system.

    IsDown - A we can perform the verification, this indicates the results of
            that verification.

Returns:
    TRUE - If we can perform the verification.
    FALSE - If we can't perform the verification.

--*/

{
    return(FALSE);

} // FmVerifyNodeDown

DWORD
FmpHandleNodeDownEvent(
    IN  PVOID pContext
    )

/*++

Routine Description:

    This function creates a thread to handle the node down event.

Arguments:

    pContext - Pointer to the context structure
	
Returns:

    ERROR_SUCCESS
--*/

{
    HANDLE  hThread = NULL;
    DWORD   dwThreadId;
    DWORD   dwError;

    //
    //  Chittur Subbaraman (chitturs) - 7/31/99
    //
    //  Create a thread to handle the FM node down event. Let us not
    //  rely on the FM worker thread to handle this. This is because
    //  the FM worker thread could be trying to online some resource
    //  and that could get stuck for some time since the quorum resource 
    //  is not online. Now in some cases, only after the node down event 
    //  is processed the quorum resource could come online. (This is 
    //  highly likely especially in a 2 node cluster.)
    //
    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpHandleNodeDownEvent - Create thread to handle node down event....\n"
              );
    
    hThread = CreateThread( NULL, 
                            0, 
                            FmpNodeDown,
                            pContext, 
                            0, 
                            &dwThreadId );

    if ( hThread == NULL )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpHandleNodeDownEvent - Unable to create thread to handle node down event. Error=0x%1!08lx!\r\n",
        	     dwError);
        CsInconsistencyHalt( dwError );
    }
        
    CloseHandle( hThread );

    return( ERROR_SUCCESS );
} // FmpHandleNodeDownEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmclient.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmclient.c

Abstract:

    Cluster client side routines for RPC remote calls.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE FMCLIENT


DWORD
FmcOnlineGroupRequest(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    This routine requests (THE) remote system to bring the Group Online.

Arguments:

    Group - The Group to bring online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD OwnerId;

    CL_ASSERT(Group->OwnerNode != NmLocalNode);
    CL_ASSERT(Group->OwnerNode != NULL);

    OwnerId = NmGetNodeId(Group->OwnerNode);
    status = FmsOnlineGroupRequest( Session[OwnerId],
                                    OmObjectId(Group) );

    return(status);

} // FmcOnlineGroupRequest



DWORD
FmcOfflineGroupRequest(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    This routine requests a remote system to take the Group Offline.

Arguments:

    Group - The Group to take online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD OwnerId;

    CL_ASSERT(Group->OwnerNode != NmLocalNode);
    CL_ASSERT(Group->OwnerNode != NULL);

    OwnerId = NmGetNodeId(Group->OwnerNode);
    CL_ASSERT(Session[OwnerId] != NULL);
    status = FmsOfflineGroupRequest( Session[OwnerId],
                                     OmObjectId(Group) );

    return(status);

} // FmcOfflineGroupRequest



DWORD
FmcMoveGroupRequest(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    )

/*++

Routine Description:

    This routine requests (THE) remote system to move the Group there.

Arguments:

    Group - The Group to bring online.
    DestinationNode - The node to move the Group to.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Notes:

    The Group lock must be held on entry.
    The Group lock is releaseed before returning.

--*/

{
    DWORD status;
    DWORD OwnerId;

    CL_ASSERT(Group->OwnerNode != NmLocalNode);
#if 1
    if ( Group ->OwnerNode == NULL ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] MoveRequest for group with no owner!\n");
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }
#endif
    CL_ASSERT(Group->OwnerNode != NULL);

    OwnerId = NmGetNodeId(Group->OwnerNode);

    FmpReleaseLocalGroupLock( Group );

    if (DestinationNode != NULL) {
        status = FmsMoveGroupRequest( Session[OwnerId],
                                      OmObjectId(Group ),
                                      OmObjectId(DestinationNode));
    } else {
        status = FmsMoveGroupRequest( Session[OwnerId],
                                      OmObjectId(Group ),
                                      NULL);
    }

    return(status);

} // FmcMoveGroupRequest



DWORD
FmcTakeGroupRequest(
    IN PNM_NODE DestinationNode,
    IN LPCWSTR GroupId,
    IN PRESOURCE_ENUM ResourceList
    )

/*++

Routine Description:

    This routine requests a remote system to move the Group there.

Arguments:

    DestinationNode - The destination node
    GroupId - The Id of the Group to be moved.
    ResourceList - The list of the resources and their states.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status=ERROR_SUCCESS;
    RPC_BINDING_HANDLE Binding;
    PFM_GROUP group = NULL;
    DWORD nodeId;

    //
    // If the remote session is not established, then return failure.
    //
    if ( gpQuoResource == NULL ) {
        CsInconsistencyHalt(ERROR_INVALID_OPERATION_ON_QUORUM);
    }

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );
    if ( group == NULL ) {
        CsInconsistencyHalt(ERROR_GROUP_NOT_AVAILABLE);
    }

    if ( gpQuoResource->Group == group ) {
        // Quorum group
        // We don't need a lock on this usage, since there is only one
        Binding = FmpRpcQuorumBindings[NmGetNodeId(DestinationNode)];
        if ( Binding == NULL ) {
            ClRtlLogPrint(LOG_ERROR,"[FM] TakeRequest and no remote binding available\n");
            OmDereferenceObject( group );
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }

        OmDereferenceObject( group );
        nodeId = NmGetNodeId(DestinationNode);
        try {
            NmStartRpc(nodeId);
            status = FmsTakeGroupRequest( Binding,
                                          GroupId,
                                          ResourceList );
        } finally {
            NmEndRpc(nodeId);
            if( status != RPC_S_OK ) {
                NmDumpRpcExtErrorInfo(status);
            }
        }

    } else {
        // Non-quorum group
        OmDereferenceObject( group );
        Binding = FmpRpcBindings[NmGetNodeId(DestinationNode)];
        if ( Binding == NULL ) {
            ClRtlLogPrint(LOG_ERROR,"[FM] TakeRequest and no remote binding available\n");
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }

        // This is a shared binding, so serialize usage.
        //
        // Charlie Wickham (charlwi) - 10/30/00
        //
        // 185575: removing use of unique RPC binding handles hence no longer
        // any need to serialize take group requests.
        //
//        FmpAcquireBindingLock();

        //
        //  Chittur Subbaraman (chitturs) - 9/30/99
        //
        //  Enclose the RPC within a "try-finally" block so that the
        //  lock is released regardless of whether the RPC succeeds.
        //  Note that the caller of FmcTakeGroupRequest encloses
        //  that function in a "try-except" block.
        //
        nodeId = NmGetNodeId(DestinationNode);
        try {
            NmStartRpc(nodeId);
            status = FmsTakeGroupRequest( Binding,
                                          GroupId,
                                          ResourceList );
        } finally {
            NmEndRpc(nodeId);
            if( status != RPC_S_OK ) {
                NmDumpRpcExtErrorInfo(status);
            }

//            FmpReleaseBindingLock();
        }
    }

    return(status);

} // FmcTakeGroupRequest



DWORD
FmcOnlineResourceRequest(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests (THE) remote system to bring the Resource Online.

Arguments:

    Resource - The resource to bring online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD NodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsOnlineResourceRequest( Session[NodeId],
                                       OmObjectId(Resource) );

    return(status);

} // FmcOnlineResourceRequest



DWORD
FmcOfflineResourceRequest(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests (THE) remote system to take the Resource Offline.

Arguments:

    Resource - The resource to take offline.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD NodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsOfflineResourceRequest( Session[NodeId],
                                        OmObjectId(Resource) );
    return(status);

} // FmcOfflineResourceRequest


DWORD
FmcChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    )

/*++

Routine Description:

    This routine requests the owner of the resource to perform the change
    resource node operation.

Arguments:

    Resource - The resource to change the resource node.

    Node - The node to be added/removed from the resource list.

    Add - Specifies whether to add or remove the given node.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Note:

    The resource's lock must be held on entry. It is released prior to
    returning.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    FmpReleaseLocalResourceLock( Resource );
    status = FmsChangeResourceNode( Session[NodeId],
                                    OmObjectId(Resource),
                                    OmObjectId(Node),
                                    Add );

    return(status);

} // FmcChangeResourceNode



DWORD
FmcArbitrateResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests a remote system to arbitrate a resource.

Arguments:

    Resource - The resource to arbitrate.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsArbitrateResource( Session[nodeId],
                                   OmObjectId(Resource) );
    return(status);

} // FmcArbitrateResource



VOID
FmcDeleteEnum(
    IN PGROUP_ENUM Enum
    )

/*++

Routine Description:

    This routine deletes an GROUP_ENUM and associated name strings.

Arguments:

    Enum - The GROUP_ENUM to delete. This pointer can be NULL.

Returns:

    None.

Notes:

    This routine will take a NULL input pointer and just return.

--*/

{
    DWORD i;

    if ( Enum == NULL ) {
        return;
    }

    for ( i = 0; i < Enum->EntryCount; i++ ) {
        MIDL_user_free(Enum->Entry[i].Id);
    }

    MIDL_user_free(Enum);
    return;

} // FmcDeleteEnum



DWORD
FmcFailResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests a remote system to fail a resource.

Arguments:

    Resource - The resource to fail.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsFailResource( Session[nodeId],
                              OmObjectId(Resource) );
    return(status);

} // FmcFailResource



PFM_RESOURCE
FmcCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    This routine requests a remote system to create a resource. The
    remote system should 'own' the group.

Arguments:

    Group - The group that the resource should be created inside.

    ResourceId - The id of the resource to create.

    ResourceName - The name of the resource to create.

    ResourceType - Resource type name

    dwFlags - Flags for the resource.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Notes:

    The Group lock should be held... and is released by this routine.

--*/

{
    DWORD status;
    DWORD nodeId;
    PFM_RESOURCE resource = NULL;
    DWORD dwClusterHighestVersion;

    CL_ASSERT(Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    FmpReleaseLocalGroupLock( Group );

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );
                                    
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {   
        status = FmsCreateResource( Session[nodeId],
                                    OmObjectId(Group),
                                    ResourceId,
                                    ResourceName );
    } else
    {
        status = FmsCreateResource2( Session[nodeId],
                                     OmObjectId(Group),
                                     ResourceId,
                                     ResourceName,
                                     ResourceType,
                                     dwFlags );
    }

    if ( status == ERROR_SUCCESS ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceId );
        if ( resource != NULL ) {
            OmDereferenceObject( resource );
        }
    } else {
        SetLastError(status);
    }

    return(resource);

} // FmcCreateResource



DWORD
FmcDeleteResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests a remote system to delete a resource.

Arguments:

    Resource - The resource to delete.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Notes:

    The Resource lock should be held... and is released by this routine.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    FmpReleaseLocalResourceLock( Resource );

    status = FmsDeleteResource( Session[nodeId],
                                OmObjectId(Resource) );

    return(status);

} // FmcDeleteResource



DWORD
FmcResourceControl(
    IN PNM_NODE Node,
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request to a remote system.

Arguments:

    Node - the remote node to send the request to.

    Resource - the resource to handle the request.

    ControlCode - the control code for this request.

    InBuffer - the input buffer.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBuffer - the size of the output buffer.

    BytesReturned - the length of the returned data.

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   NodeId;
    DWORD   Dummy;
    DWORD   dwTmpBytesReturned;
    DWORD   dwTmpBytesRequired;

    NodeId = NmGetNodeId(Node);
    if ((NmGetNodeState(Node) != ClusterNodeUp) &&
        ( NmGetNodeState(Node) != ClusterNodePaused))
    {
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }

    CL_ASSERT(Session[NodeId] != NULL);

    //to take care of the output reference pointer which cannot be NULL.
    if (!OutBuffer)
    {
       OutBuffer = (PUCHAR)&Dummy;
       OutBufferSize = 0;
    }
    if (!BytesReturned)
        BytesReturned = &dwTmpBytesReturned;
    if (!Required)
        Required = &dwTmpBytesRequired;

    status = FmsResourceControl( Session[NodeId],
                                 OmObjectId(Resource),
                                 ControlCode,
                                 InBuffer,
                                 InBufferSize,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 Required );
    return(status);

} // FmcResourceControl



DWORD
FmcResourceTypeControl(
    IN PNM_NODE Node,
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource type control request to a remote system.

Arguments:

    Node - the remote node to send the request to.

    ResourceTypeName - the name of the resource type to handle the request.

    ControlCode - the control code for this request.

    InBuffer - the input buffer.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBuffer - the size of the output buffer.

    BytesReturned - the length of the returned data.

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    NodeId = NmGetNodeId(Node);
    if (( NmGetNodeState(Node) != ClusterNodeUp ) &&
        ( NmGetNodeState(Node) != ClusterNodePaused )) {
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }

    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsResourceTypeControl( Session[NodeId],
                                     ResourceTypeName,
                                     ControlCode,
                                     InBuffer,
                                     InBufferSize,
                                     OutBuffer,
                                     OutBufferSize,
                                     BytesReturned,
                                     Required );
    return(status);

} // FmcResourceTypeControl



DWORD
FmcGroupControl(
    IN PNM_NODE Node,
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request to a remote system.

Arguments:

    Node - the remote node to send the request to.

    Group - the group to handle the request.

    ControlCode - the control code for this request.

    InBuffer - the input buffer.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBuffer - the size of the output buffer.

    BytesReturned - the length of the returned data.

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    NodeId = NmGetNodeId(Node);
    if (( NmGetNodeState(Node) != ClusterNodeUp ) &&
        ( NmGetNodeState(Node) != ClusterNodePaused )) {
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }

    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsGroupControl( Session[NodeId],
                              OmObjectId(Group),
                              ControlCode,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              OutBufferSize,
                              BytesReturned,
                              Required );
    return(status);

} // FmcGroupControl


DWORD
FmcPrepareQuorumResChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    )

/*++

Routine Description:

    This routine requests a the owner of a potential quorum resource
    to prepare for quorum logging and registry replication.

Arguments:

    Resource - The resource to on which we want to start logging.

    lpszQuoLogPath - The Path where the cluster log files should be created.

    dwMaxQuoLogSize - The new max Quorum Log Size.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsPrepareQuorumResChange( Session[nodeId],
                            OmObjectId(Resource),
                            lpszQuoLogPath,
                            dwMaxQuoLogSize );
    return(status);

} // FmcPrepareQuorumResChange


DWORD
FmcCompleteQuorumResChange(
    IN PFM_RESOURCE pOldQuoRes,
    IN LPCWSTR      lpszOldQuoLogPath
    )

/*++

Routine Description:

    This routine requests a the owner of the previous quorum resource
    to clean up after quorum resource change is complete.

Arguments:

    pOldQuoRes - The resource to on which we want to start logging.

    lpszOldQuoLogPath - The Path where the cluster log files should be created.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(pOldQuoRes->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(pOldQuoRes->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsCompleteQuorumResChange( Session[nodeId],
                            OmObjectId(pOldQuoRes),
                            lpszOldQuoLogPath);
    return(status);

} // FmcCompleteQuorumResChange




DWORD
FmcChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    )
/*++

Routine Description:

    This routine requests the owner of the resource to move the resource
    from one group to another.

Arguments:

    Resource - The resource whose group is to be changed.

    pNewGroup - The group to which the resource should be moved to.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Note:

    The group locks for both the old and the new group must be held on entry.
    They are release before making the rpc call.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    CL_ASSERT(pResource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(pResource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    FmpReleaseLocalGroupLock( pResource->Group );
    FmpReleaseLocalGroupLock( pNewGroup );
    status = FmsChangeResourceGroup( Session[NodeId],
                                    OmObjectId(pResource),
                                    OmObjectId(pNewGroup));

    return(status);

} // FmcChangeResourceNode

DWORD
FmcBackupClusterDatabase(
    IN PFM_RESOURCE pQuoResource,
    IN LPCWSTR      lpszPathName
    )

/*++

Routine Description:

    This routine requests the owner of a potential quorum resource
    to backup the quorum log and the checkpoint file to the
    specified path. This function is called with the resource lock
    held.

Arguments:

    pQuoResource - The quorum resource.

    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT( pQuoResource->Group->OwnerNode != NULL );

    nodeId = NmGetNodeId( pQuoResource->Group->OwnerNode );
    CL_ASSERT( Session[nodeId] != NULL );

    //
    //  Chittur Subbaraman (chitturs) - 10/16/98
    //
    //  Release the resource lock. Releasing the resource lock
    //  here can create a window during which this node thinks
    //  the other node is the owner and the other node thinks
    //  this node is the owner. But, unfortunately we've to treat 
    //  this as an error case so that we don't run into deadlocks 
    //  across multiple machines due to the lock being held while
    //  making the RPC.
    //
    FmpReleaseLocalResourceLock( pQuoResource );

    status = FmsBackupClusterDatabase( Session[nodeId],
                                 OmObjectId( pQuoResource ),
                                 lpszPathName );

    return( status );
} // FmcBackupClusterDatabase


/****
@func       DWORD | FmcDeleteGroup| This makes a rpc call to the owner
            of the group to handle the delete group request.

@parm       IN PFM_GROUB | pGroup | The group that must be deleted.
            
@comm       The owner node should make the GUM request to avoid deadlocks.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD
FmcDeleteGroupRequest(
    IN PFM_GROUP pGroup
)
{
    DWORD   dwOwnerId;
    DWORD   dwStatus;
    
    dwOwnerId = NmGetNodeId(pGroup->OwnerNode);

    CL_ASSERT(dwOwnerId != NmLocalNodeId);

    //release the lock before making the rpc call
    FmpReleaseLocalGroupLock( pGroup );
    
    dwStatus = FmsDeleteGroupRequest( Session[dwOwnerId],
                    OmObjectId(pGroup) 
                    );
    return(dwStatus);                                   


}
    

/****
@func       DWORD | FmcAddResourceDependency | This makes an RPC to the 
            owner of the resource to handle the dependency addition.

@parm       IN PFM_RESOURCE | pResource | The resource to add the 
            dependent resource.

@parm       IN PFM_RESOURCE | pDependentResource | The dependent resource.
            
@comm       The owner node should make the GUM request to avoid deadlocks.

@rdesc      Returns an error code. ERROR_SUCCESS on success.
****/
DWORD
FmcAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
)
{
    DWORD   dwOwnerId;
    DWORD   dwStatus;
    
    dwOwnerId = NmGetNodeId( pResource->Group->OwnerNode );

    CL_ASSERT( dwOwnerId != NmLocalNodeId );
    //
    // Release the lock before making the RPC call
    //
    FmpReleaseLocalResourceLock( pResource );
    
    dwStatus = FmsAddResourceDependency( Session[dwOwnerId],
                                         OmObjectId( pResource ),
                                         OmObjectId( pDependentResource )
                                       );
    return( dwStatus );                                   
}

/****
@func       DWORD | FmcRemoveResourceDependency | This makes an RPC to the 
            owner of the resource to handle the dependency removal.

@parm       IN PFM_RESOURCE | pResource | The resource to remove the 
            dependent resource from.

@parm       IN PFM_RESOURCE | pDependentResource | The dependent resource.
            
@comm       The owner node should make the GUM request to avoid deadlocks.

@rdesc      Returns an error code. ERROR_SUCCESS on success.
****/
DWORD
FmcRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
)
{
    DWORD   dwOwnerId;
    DWORD   dwStatus;
    
    dwOwnerId = NmGetNodeId( pResource->Group->OwnerNode );

    CL_ASSERT( dwOwnerId != NmLocalNodeId );
    //
    // Release the lock before making the RPC call
    //
    FmpReleaseLocalResourceLock( pResource );
    
    dwStatus = FmsRemoveResourceDependency( Session[dwOwnerId],
                                            OmObjectId( pResource ),
                                            OmObjectId( pDependentResource )
                                          );
    return( dwStatus );                                   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmgum.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmgum.c

Abstract:

    Cluster FM Global Update processing routines.

Author:

    Rod Gamache (rodga) 24-Apr-1996


Revision History:


--*/

#include "fmp.h"

#include "ntrtl.h"

#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif


#define LOG_MODULE FMGUM


DWORD
WINAPI
FmpGumReceiveUpdates(
    IN DWORD    Context,
    IN BOOL     SourceNode,
    IN DWORD    BufferLength,
    IN PVOID    Buffer
    )

/*++

Routine Description:

    Updates the specified resource (contained within Buffer) with a new
    state.

Arguments:

    Context - The message update type.
    SourceNode - TRUE if this is the source node for this update.
                 FALSE otherwise.
    BufferLength - Length of the received buffer.
    Buffer - The actual buffer

Returns:

    ERROR_SUCCESS

--*/

{
    PFM_RESOURCE resource;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    switch ( Context ) {


        case FmUpdateFailureCount:
        {
            PGUM_FAILURE_COUNT failureCount;
            PFM_GROUP group;

            //
            // This update type is always sent.
            // On the originating node, all of the work must be done by
            // the sending thread.
            // On the non-originating nodes, no locks can be acquired! This
            // would cause hang situations with operations like move.
            // ... this is okay, since the locking must be done on the sending
            // node anyway, which owns the group.
            //
            if ( SourceNode == FALSE ) {
                if ( BufferLength <= sizeof(GUM_FAILURE_COUNT) ) {
                    ClRtlLogPrint(LOG_UNUSUAL, "[FM] Gum FailureCount receive buffer too small!\n");
                    return(ERROR_SUCCESS);
                }

                failureCount = (PGUM_FAILURE_COUNT)Buffer;
                group = OmReferenceObjectById( ObjectTypeGroup,
                                               (LPCWSTR)&failureCount->GroupId[0] );

                if ( group == NULL ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] Gum FailureCount failed to find group %1!ws!\n",
                               failureCount->GroupId);
                    return(ERROR_SUCCESS);
                }

                ClRtlLogPrint(LOG_NOISE,
                           "[FM] GUM update failure count %1!ws!, count %2!u!\n",
                           failureCount->GroupId,
                           failureCount->Count);

                //FmpAcquireLocalGroupLock( group );

                if ( group->OwnerNode == NmLocalNode ) {
                    ClRtlLogPrint(LOG_NOISE,
                               "[FM] Gum FailureCount wrong owner for %1!ws!\n",
                               failureCount->GroupId);
                } else {
                    group->NumberOfFailures = failureCount->Count;
                    if ( failureCount->NewTime ) {
                        group->FailureTime = GetTickCount();
                    }
                }

                //FmpReleaseLocalGroupLock( group );

                OmDereferenceObject( group );

            }

            break;
        }

        case FmUpdateCreateGroup:
            {
                PGUM_CREATE_GROUP GumGroup;
                DWORD Status = ERROR_SUCCESS;

                GumGroup = (PGUM_CREATE_GROUP)Buffer;

                Status = FmpUpdateCreateGroup( GumGroup, SourceNode );
                
                return(Status);
            }

        case FmUpdateCreateResource:
            {
                DWORD dwStatus = ERROR_SUCCESS;
                PGUM_CREATE_RESOURCE GumResource = 
                                (PGUM_CREATE_RESOURCE)Buffer;

                dwStatus = FmpUpdateCreateResource( GumResource );

                return( dwStatus );
            }



        case FmUpdateAddPossibleNode:
        case FmUpdateRemovePossibleNode:
            {

                PGUM_CHANGE_POSSIBLE_NODE pGumChange;
                PFM_RESOURCE              pResource;
                LPWSTR                    pszResourceId;
                LPWSTR                    pszNodeId;
                PNM_NODE                  pNode;
                DWORD                     dwStatus;
                DWORD                     dwControlCode;
                PFMP_POSSIBLE_NODE        pPossibleNode;

                pGumChange = (PGUM_CHANGE_POSSIBLE_NODE)Buffer;
                pszResourceId = pGumChange->ResourceId;
                pszNodeId = (LPWSTR)((PCHAR)pszResourceId +
                                         pGumChange->ResourceIdLen);
                                         
                pResource = OmReferenceObjectById(ObjectTypeResource,pszResourceId);
                pNode = OmReferenceObjectById(ObjectTypeNode, pszNodeId);
                CL_ASSERT(pResource != NULL);
                CL_ASSERT(pNode != NULL);
                pPossibleNode = LocalAlloc( LMEM_FIXED,
                    sizeof(FMP_POSSIBLE_NODE) );
                if ( pPossibleNode == NULL ) 
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                
                if (Context == FmUpdateAddPossibleNode) 
                {
                    dwControlCode = CLUSCTL_RESOURCE_ADD_OWNER;
                } 
                else 
                {
                    dwControlCode = CLUSCTL_RESOURCE_REMOVE_OWNER;
                }
                
                dwStatus = FmpUpdateChangeResourceNode(SourceNode, 
                    pResource, pNode, dwControlCode);
                //if status is not successful then return, else notify
                //resource dlls
                if (dwStatus != ERROR_SUCCESS)
                {
                    //dereference the objects
                    OmDereferenceObject(pResource);
                    OmDereferenceObject(pNode);
                    //free the memory
                    LocalFree(pPossibleNode);
                    return(dwStatus);
                }

                pPossibleNode->Resource = pResource;
                pPossibleNode->Node = pNode;
                pPossibleNode->ControlCode = dwControlCode;

                //
                // Tell the resource about the ADD/REMOVE in a worker thread.
                //

                FmpPostWorkItem( FM_EVENT_RESOURCE_CHANGE,
                                 pPossibleNode,
                                 0 );

                //
                //  Chittur Subbaraman (chitturs) - 6/7/99
                //  
                //  Don't reference pPossibleNode any more. It could have
                //  been freed by the worker thread by the time you get
                //  here.
                //
                ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                              pResource );

                // Let the worker thread perform the derefs/Frees
                return(dwStatus);
            }                

        case FmUpdateJoin:
            break;

        case FmUpdateCreateResourceType:
            {
                DWORD dwStatus;

                dwStatus = FmpUpdateCreateResourceType( Buffer );

                return( dwStatus );
            }
            break;
            
        case FmUpdateDeleteResourceType:
            {
                BOOL ResourceExists = FALSE;
                PFM_RESTYPE Type;

                Type = OmReferenceObjectById( ObjectTypeResType,
                                              (LPWSTR)Buffer);
                if (Type == NULL) {
                    return(ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND);
                }
                //
                // Make sure no resources exist of this type.
                //
                OmEnumObjects( ObjectTypeResource,
                               FmpFindResourceType,
                               Type,
                               &ResourceExists);
                if (ResourceExists) {
                    OmDereferenceObject(Type);
                    return(ERROR_DIR_NOT_EMPTY);
                }

                //
                // We need to dereference the object twice to get
                // rid of it. But then any notification handlers will
                // not get a chance to see the object by the time
                // the handler gets called. So we use the EP_DEREF_CONTEXT
                // flag to get the event processor to do the second deref
                // once everything has been dispatched.
                //
                FmpDeleteResType(Type);
                ClusterEventEx( CLUSTER_EVENT_RESTYPE_DELETED,
                                EP_DEREF_CONTEXT,
                                Type );
            }
            break;

        case FmUpdateChangeGroup:
            {
                PGUM_CHANGE_GROUP   pGumChange;
                PFM_RESOURCE        pResource;
                LPWSTR              pszResourceId;
                LPWSTR              pszGroupId;
                PFM_GROUP           pNewGroup;
                DWORD               dwStatus;
                DWORD               dwClusterHighestVersion;
                
                pGumChange = (PGUM_CHANGE_GROUP)Buffer;

                pszResourceId = pGumChange->ResourceId;
                pszGroupId = (LPWSTR)((PCHAR)pszResourceId +
                                          pGumChange->ResourceIdLen);
                //
                // Find the specified resource and group.
                //
                pResource = OmReferenceObjectById(ObjectTypeResource,
                                                 pszResourceId);
                if (pResource == NULL) {
                    return(ERROR_RESOURCE_NOT_FOUND);
                }
                pNewGroup = OmReferenceObjectById(ObjectTypeGroup, 
                                                    pszGroupId);
                if (pNewGroup == NULL) {
                    OmDereferenceObject(pResource);
                    return(ERROR_SUCCESS);
                }

                dwStatus = FmpUpdateChangeResourceGroup(SourceNode,
                              pResource, pNewGroup);

                OmDereferenceObject(pNewGroup);
                OmDereferenceObject(pResource);

                return(dwStatus);
            }
            break;

            
        default:
            {

            }
            ClRtlLogPrint(LOG_UNUSUAL,"[FM] Gum received bad context, %1!u!\n",
                Context);

    }

    return(ERROR_SUCCESS);

} // FmpGumReceiveUpdates


DWORD
FmpUpdateChangeQuorumResource(
    IN BOOL     SourceNode,
    IN LPCWSTR  NewQuorumResourceId,
    IN LPCWSTR  szRootClusFilePath,
    IN LPDWORD  pdwMaxQuorumLogSize
    )

/*++

Routine Description:

    Perform updates related to changing of the quorum resource.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code otherwise.

--*/

{
    PFM_RESOURCE    pResource;
    PFM_RESOURCE    pOldQuoResource=NULL;
    DWORD           dwStatus;
    WCHAR           lpszCheckPtFile[MAX_PATH];
    DWORD           dwChkPtSeq;
    HDMKEY          ResKey;
    HLOCALXSACTION  hXsaction = NULL;
    HLOG            hNewQuoLog=NULL;
    WCHAR           szQuorumLogPath[MAX_PATH];

    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    lstrcpyW(szQuorumLogPath, szRootClusFilePath);
    //lstrcatW(szQuorumLogPath, cszClusLogFileRootDir);

    pResource = OmReferenceObjectById( ObjectTypeResource,
                                      NewQuorumResourceId );
    if (pResource == NULL) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeQuorumResource: Resource <%1!ws!> could not be found....\n",
                   NewQuorumResourceId);
        return(ERROR_SUCCESS);
    }

    //since the resource->quorum is going to change, acquire the quocritsec
    //always acquire the gQuoCritsec before gQuoLock
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);
    
    //prevent any resources from going online at this time
    ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);

    //pause any changes to the cluster database
    //always acquire this lock after gQuoLock(refer to the ordering of locks
    // in fminit.c)
    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    DmPauseDiskManTimer();

    //if this resource was already a quorum resource
    if (!pResource->QuorumResource)
    {

        //
        // Now find the current quorum resource.
        //
        OmEnumObjects( ObjectTypeResource,
                       FmpFindQuorumResource,
                       &pOldQuoResource,
                       NULL );
        if ( pOldQuoResource != NULL )
        {
            CL_ASSERT( pOldQuoResource->QuorumResource );
            // Stop the quorum reservation thread!
            pOldQuoResource->QuorumResource = FALSE;
        }
        //set the new resource to be the quorum resource
        pResource->QuorumResource = TRUE;

    }

    //writes to the old log file
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    dwStatus = DmLocalSetValue( hXsaction,
                                DmQuorumKey,
                                cszPath,
                                REG_SZ,
                                (LPBYTE)szQuorumLogPath,
                                (lstrlenW(szQuorumLogPath)+1) * sizeof(WCHAR));

    if (dwStatus != ERROR_SUCCESS)
        goto FnExit;


#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailLocalXsaction) {
        LPWSTR  pszStr = szQuorumLogPath;
        dwStatus = (MAX_PATH * sizeof(WCHAR));
        dwStatus = DmQuerySz( DmQuorumKey,
                        cszPath,
                        &pszStr,
                        &dwStatus,
                        &dwStatus);
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Testing failing a local transaction midway- new quorum path %1!ws!\r\n",
                    szQuorumLogPath);
        dwStatus = 999999;
        goto FnExit;
    }
#endif

    dwStatus = DmLocalSetValue( hXsaction,
                                DmQuorumKey,
                                cszMaxQuorumLogSize,
                                REG_DWORD,
                                (LPBYTE)pdwMaxQuorumLogSize,
                                sizeof(DWORD));

    if (dwStatus != ERROR_SUCCESS)
        goto FnExit;


    //if the old quorum resource is different from the new quorum resource
    if ((pOldQuoResource) && (pOldQuoResource != pResource))
    {
        //get/set the new/old resource's flags
        //set the core flag on the new quorum resource
        ResKey = DmOpenKey( DmResourcesKey,
                            NewQuorumResourceId,
                            KEY_READ | KEY_SET_VALUE);
        if (!ResKey)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        pResource->ExFlags |= CLUS_FLAG_CORE;
        dwStatus = DmLocalSetValue( hXsaction,
                                    ResKey,
                                    CLUSREG_NAME_FLAGS,
                                    REG_DWORD,
                                    (LPBYTE)&(pResource->ExFlags),
                                    sizeof(DWORD));

        DmCloseKey( ResKey );

        if (dwStatus != ERROR_SUCCESS)
            goto FnExit;

        //unset the core flag on the old quorum resource
        ResKey = DmOpenKey( DmResourcesKey,
                            OmObjectId(pOldQuoResource),
                            KEY_READ | KEY_SET_VALUE);
        if (!ResKey)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        pOldQuoResource->ExFlags &= ~CLUS_FLAG_CORE;

        //unset the core flag on the old quorum resource
        dwStatus = DmLocalSetValue( hXsaction,
                                    ResKey,
                                    CLUSREG_NAME_FLAGS,
                                    REG_DWORD,
                                    (LPBYTE)&(pOldQuoResource->ExFlags),
                                    sizeof(DWORD));

        DmCloseKey( ResKey );

        if (dwStatus != ERROR_SUCCESS)
            goto FnExit;


    }
    //
    // Set the quorum resource value.
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                DmQuorumKey,
                                CLUSREG_NAME_QUORUM_RESOURCE,
                                REG_SZ,
                                (CONST BYTE *)OmObjectId(pResource),
                                (lstrlenW(OmObjectId(pResource))+1)*sizeof(WCHAR));


    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }


FnExit:
    if (dwStatus == ERROR_SUCCESS)
    {
        LPWSTR  szClusterName=NULL;
        DWORD   dwSize=0;
        //commit the update on the old log file,
        //any nodes that were done, will get this change
        //I cant delete this file
        DmCommitLocalUpdate(hXsaction);
        //close the old log file, open the new one and take a checkpoint
        DmSwitchToNewQuorumLog(szQuorumLogPath);
        // SS:the buffer should contain the current cluster name ?

        DmQuerySz( DmClusterParametersKey,
                        CLUSREG_NAME_CLUS_NAME,
                        &szClusterName,
                        &dwSize,
                        &dwSize);

        if (szClusterName)
            ClusterEventEx(CLUSTER_EVENT_PROPERTY_CHANGE,
                   EP_FREE_CONTEXT,
                   szClusterName);
        if ((pOldQuoResource) && (pOldQuoResource != pResource))
        {
            //generate the resource property change events
            ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, 
                pResource );
            ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, 
                pOldQuoResource );
            
        }            

    }
    else
    {
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
        //reinstall the tombstone
        DmReinstallTombStone(szQuorumLogPath);
    }
    if (pOldQuoResource) OmDereferenceObject(pOldQuoResource);
    OmDereferenceObject(pResource);
    DmRestartDiskManTimer();
    //release locks
    RELEASE_LOCK(gLockDmpRoot);
    RELEASE_LOCK(gQuoLock);
    RELEASE_LOCK(gQuoChangeLock);
    return(dwStatus);
}


DWORD
FmpUpdateResourceState(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN PGUM_RESOURCE_STATE ResourceState
    )
/*++

Routine Description:

    GUM update handler for resource state changes.

Arguments:

    SourceNode - Supplies whether or not this node was the source of the update

    ResourceId - Supplies the id of the resource whose state is changing

    ResourceState - Supplies the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE resource;

    if ( !FmpFMGroupsInited ) {
        return(ERROR_SUCCESS);
    }

    //
    // This update type is always sent.
    // On the originating node, all of the work must be done by
    // the sending thread.
    // On the non-originating nodes, no locks can be acquired! This
    // would cause some hang situations with operations like move.
    // ... this is okay, since the locking must be done on the sending
    // node anyway, which owns the group.
    //
    if ( SourceNode == FALSE ) {
        resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

        if ( resource == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Gum ResourceState failed to find resource %1!ws!\n",
                       ResourceId);
            CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
            return(ERROR_SUCCESS);
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Gum update resource %1!ws!, state %2!u!, current state %3!u!.\n",
                   ResourceId,
                   ResourceState->State,
                   ResourceState->PersistentState);

        //FmpAcquireLocalResourceLock( resource );

        if ( resource->Group->OwnerNode == NmLocalNode ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Gum ResourceState wrong owner for %1!ws!\n",
                       ResourceId);
        } else {
            resource->State = ResourceState->State;
            resource->PersistentState = ResourceState->PersistentState;
            resource->StateSequence = ResourceState->StateSequence;

            switch ( ResourceState->State ) {
                case ClusterResourceOnline:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_ONLINE, resource );
                    break;
                case ClusterResourceOffline:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_OFFLINE, resource );
                    break;
                case ClusterResourceFailed:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_FAILED, resource );
                    break;
                case ClusterResourceOnlinePending:
                case ClusterResourceOfflinePending:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_CHANGE, resource );
                    break;
                default:
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] Gum update resource state, bad state %1!u!\n",
                               ResourceState->State);
                    break;
            }
        }

        OmDereferenceObject( resource );
    }
    return(ERROR_SUCCESS);
}



DWORD
FmpUpdateGroupState(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId,
    IN PGUM_GROUP_STATE GroupState
    )
/*++

Routine Description:

    GUM update handler for group state changes.

Arguments:

    SourceNode - Supplies whether or not this node was the source of the update

    GroupId - Supplies the id of the resource whose state is changing

    NodeId - Supplies the node id of the group owner.

    GroupState - Supplies the new state of the group.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP group;
    PWSTR     nodeId;
    PNM_NODE  node;

    if ( !FmpFMGroupsInited ) {
        return(ERROR_SUCCESS);
    }

    //
    // This update type is always sent.
    // On the originating node, all of the work must be done by
    // the sending thread.
    // On the non-originating nodes, no locks can be acquired! This
    // would cause some hang situations with operations like move.
    // ... this is okay, since the locking must be done on the sending
    // node anyway, which owns the group.
    //
    if ( SourceNode == FALSE ) {
        group = OmReferenceObjectById( ObjectTypeGroup,
                                       GroupId );

        if ( group == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Gum GroupState failed to find group %1!ws!\n",
                       GroupId);
            return(ERROR_SUCCESS);
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] GUM update group %1!ws!, state %2!u!\n",
                   GroupId,
                   GroupState->State);

        if ( group->OwnerNode == NmLocalNode ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Gum GroupState wrong owner for %1!ws!\n",
                       GroupId);
        } else {
            group->State = GroupState->State;
            group->PersistentState = GroupState->PersistentState;
            group->StateSequence = GroupState->StateSequence;
            node = OmReferenceObjectById( ObjectTypeNode,
                                          NodeId );
            if ( node == NULL ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Owner of Group %1!ws! cannot be found %2!ws!\n",
                           GroupId,
                           NodeId);
            } else {
                ClRtlLogPrint(LOG_NOISE,
                       "[FM] New owner of Group %1!ws! is %2!ws!, state %3!u!, curstate %4!u!.\n",
                       OmObjectId( group ),
                       OmObjectId( node ),
                       group->State,
                       group->PersistentState);
                if ( !FmpInPreferredList( group, node, FALSE,  NULL ) ) {
                    ClRtlLogPrint( LOG_UNUSUAL,
                                "[FM] New owner %1!ws! is not in preferred list for group %2!ws!.\n",
                                OmObjectId( node ),
                                OmObjectId( group ));
                }
            }
            group->OwnerNode = node;

            switch ( GroupState->State ) {
            case ClusterGroupOnline:
            case ClusterGroupPartialOnline:
                ClusterEvent( CLUSTER_EVENT_GROUP_ONLINE, group );
                break;
            case ClusterGroupOffline:
                ClusterEvent( CLUSTER_EVENT_GROUP_OFFLINE, group );
                break;
            default:
                ClRtlLogPrint(LOG_UNUSUAL,"[FM] Gum update group state, bad state %1!u!\n", GroupState->State);
                break;
            }
        }

        OmDereferenceObject( group );

    }

    return(ERROR_SUCCESS);
}

DWORD
FmpUpdateGroupNode(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for group node changes. This is required for 
notification
    when a group moves between nodes but does not change state (i.e. it was
    already offline)

Arguments:

    SourceNode - Supplies whether or not this node was the source of the update

    GroupId - Supplies the id of the resource whose state is changing

    NodeId - Supplies the node id of the group owner.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP pGroup;
    DWORD     dwStatus = ERROR_SUCCESS;
    PNM_NODE  pNode = NULL;
    PNM_NODE  pPrevNode = NULL;
    
    if ( !FmpFMGroupsInited ) 
    {
        return(ERROR_SUCCESS);
    }

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    GroupId );

    if (pGroup == NULL)
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmpUpdateGroupNode: GroupID = %1!ws! could not be found...\n",
                   GroupId);
        //
        //  Chittur Subbaraman (chitturs) - 6/12/99
        //
        //  Return ERROR_SUCCESS here since this is what NT4 side does.
        //  Compatibility pain !
        //
        goto FnExit;
    }


    pNode = OmReferenceObjectById(ObjectTypeNode,
                                    NodeId);

    if (pNode == NULL)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
        goto FnExit;
    }
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpAcquireLocalGroupLock(pGroup);
    
    pPrevNode = pGroup->OwnerNode;

    //set the new owner node, incr ref count
    OmReferenceObject(pNode);
    pGroup->OwnerNode = pNode;

    //decr ref count on previous owner
    OmDereferenceObject(pPrevNode);
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpReleaseLocalGroupLock(pGroup);

    //generate an event to signify group owner node change
    ClusterEvent(CLUSTER_EVENT_GROUP_CHANGE, pGroup);
    
FnExit:
    if (pGroup) OmDereferenceObject(pGroup);
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}


DWORD
FmpUpdateChangeClusterName(
    IN BOOL     SourceNode,
    IN LPCWSTR  szNewName
    )
/*++

Routine Description:

    GUM update routine for changing the name of the cluster.

    This changes the name property of the core network name resource
    as well.  The resource is notified about it by a worker thread that
    the name has been changed.

Arguments:

    SourceNode - Supplies whether or not this node originated the update.

    NewName - Supplies the new name of the cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LPWSTR          Buffer;
    DWORD           Length;
    DWORD           Status = ERROR_SUCCESS;
    LPWSTR          ClusterNameId=NULL;
    DWORD           idMaxSize = 0;
    DWORD           idSize = 0;
    PFM_RESOURCE    Resource=NULL;
    HDMKEY          ResKey = NULL;
    HDMKEY          ParamKey = NULL;
    HLOCALXSACTION  hXsaction=NULL;


    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        Status = ERROR_SUCCESS;
        goto FnExit;

    }
    //find the core network name resource, set its private properties
    Status = DmQuerySz( DmClusterParametersKey,
                        CLUSREG_NAME_CLUS_CLUSTER_NAME_RES,
                        (LPWSTR*)&ClusterNameId,
                        &idMaxSize,
                        &idSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmpUpdateChangeClusterName failed to get cluster name resource, error %1!u!.\n",
                   Status);
        goto FnExit;
    }

    //
    // Reference the specified resource ID.
    //
    Resource = OmReferenceObjectById( ObjectTypeResource, ClusterNameId );
    if (Resource == NULL) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmpUpdateChangeClusterName failed to find the cluster name resource\n",
                   Status);
        goto FnExit;
    }


    ResKey = DmOpenKey(DmResourcesKey, ClusterNameId, KEY_READ | KEY_SET_VALUE);
    if (!ResKey)
    {
        Status = GetLastError();
        goto FnExit;
    }
    ParamKey = DmOpenKey(ResKey, cszParameters, KEY_READ | KEY_SET_VALUE);

    if (!ParamKey)
    {
        Status = GetLastError();
        goto FnExit;
    }

    Status = DmLocalSetValue(hXsaction,
                ParamKey,
                CLUSREG_NAME_RES_NAME,
                REG_SZ,
                (CONST BYTE *)szNewName,
                (lstrlenW(szNewName)+1)*sizeof(WCHAR));

    if ( Status != ERROR_SUCCESS )
       goto FnExit;

    //update the default cluster name
    Status = DmLocalSetValue(hXsaction,
                    DmClusterParametersKey,
                    CLUSREG_NAME_CLUS_NAME,
                    REG_SZ,
                    (CONST BYTE *)szNewName,
                    (lstrlenW(szNewName)+1)*sizeof(WCHAR));

    if (Status != ERROR_SUCCESS)
        goto FnExit;

    //notify the resource dll that the name has been changed
    //that will decrement the reference count on this object
    //current fm only has pending work associated with
    //this event on the name change case.  If other cases require
    //pending work, then CLUSTER_EVENT_PROPERTY_CONTEXT must
    //be used
    FmpPostWorkItem(FM_EVENT_CLUSTER_PROPERTY_CHANGE, Resource, 0);
    Resource = NULL;
    //
    // Need to allocate a new buffer for posting the new name to the event
    // processor
    //
    Length = (lstrlenW(szNewName)+1)*sizeof(WCHAR);
    Buffer = LocalAlloc(LMEM_FIXED,Length);
    if (Buffer == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    CopyMemory(Buffer, szNewName, Length);
    ClusterEventEx(CLUSTER_EVENT_PROPERTY_CHANGE,
                   EP_FREE_CONTEXT,
                   Buffer);

FnExit:
    if (ClusterNameId) LocalFree(ClusterNameId);
    if (ParamKey) DmCloseKey(ParamKey);
    if (ResKey) DmCloseKey(ResKey);
    if (Resource) OmDereferenceObject(Resource);
    if (hXsaction) 
    {
        if (Status == ERROR_SUCCESS) 
            DmCommitLocalUpdate(hXsaction);
        else 
            DmAbortLocalUpdate(hXsaction);
    }
    return(Status);
}


DWORD
FmpUpdateChangeResourceName(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszResourceId,
    IN LPCWSTR lpszNewName
    )
/*++

Routine Description:

    GUM dispatch routine for changing the friendly name of a resource.

Arguments:

    bSourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    lpszResourceId - Supplies the resource ID.

    lpszNewName - Supplies the new friendly name.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE pResource = NULL;
    DWORD dwStatus;
    HDMKEY      hKey = NULL;
    DWORD       dwDisposition;
    HLOCALXSACTION      
                hXsaction = NULL;
    PFM_RES_CHANGE_NAME  pResChangeName = NULL; 

    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return( ERROR_SUCCESS );
    }

    //
    //  Chittur Subbaraman (chitturs) - 6/28/99
    //
    //  Restructure this GUM update as a local transaction.
    //
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, lpszResourceId );

    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Resource <%1!ws!> could not be found....\n",
                   lpszResourceId);
        return( ERROR_RESOURCE_NOT_FOUND );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateChangeResourceName: Entry for resource <%1!ws!>, New name = <%2!ws!>...\n",
                lpszResourceId,
                lpszNewName);

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Failed in starting a transaction for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // Open the resources key.
    //
    hKey = DmLocalCreateKey( hXsaction,
                             DmResourcesKey,
                             lpszResourceId,
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &dwDisposition );
                            
    if ( hKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Failed in opening the resources key for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }
    
    CL_ASSERT( dwDisposition != REG_CREATED_NEW_KEY ); 

    //
    // Set the resource name in the registry
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hKey,
                                CLUSREG_NAME_RES_NAME,
                                REG_SZ,
                                ( CONST BYTE * ) lpszNewName,
                                ( lstrlenW( lpszNewName ) + 1 ) * 
                                    sizeof( WCHAR ) );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateChangeResourceName: DmLocalSetValue for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;     
    }

    pResChangeName = LocalAlloc( LMEM_FIXED,
                                 lstrlenW( lpszNewName ) * sizeof ( WCHAR ) + 
                                   sizeof( FM_RES_CHANGE_NAME ) );

    if ( pResChangeName == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Unable to allocate memory for ResChangeName structure for resource <%1!ws!>, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;    
    }

    dwStatus = OmSetObjectName( pResource, lpszNewName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateChangeResourceName: Unable to set name <%3!ws!> for resource <%1!ws!>, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus,
                   lpszNewName );
        LocalFree( pResChangeName );
        goto FnExit;
    }

    pResChangeName->pResource = pResource;

    lstrcpyW( pResChangeName->szNewResourceName, lpszNewName );

    //
    //  The FM worker thread will free the memory for the pResChangeName
    //  structure as well as dereference the pResource object.
    //
    FmpPostWorkItem( FM_EVENT_RESOURCE_NAME_CHANGE, pResChangeName, 0 );   

    pResource = NULL;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateChangeResourceName: Successfully changed name of resource <%1!ws!> to <%2!ws!>...\n",
                lpszResourceId,
                lpszNewName);

FnExit:
    if ( pResource != NULL )
    {
        OmDereferenceObject( pResource );
    }

    if ( hKey != NULL ) 
    {
        DmCloseKey( hKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && ( hXsaction ) ) 
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateChangeResourceName: Exit for resource %1!ws!, Status=%2!u!...\n",
                lpszResourceId,
                dwStatus);

    return( dwStatus );
}


/****
@func       DWORD | FmpUpdatePossibleNodesForResType| This update is called to 
            update the possible nodes for a resource type.  

@parm       IN BOOL | SourceNode | set to TRUE, if the update originated at this
            node.
            
@parm       IN LPCWSTR | lpszResTypeName | The name of the resource type.

@parm       IN DWORD | dwBufLength | The size of the multi-sz string pointed
            to by pBuf

@parm       IN PVOID | pBuf | A pointer to the buffer containing the names of 
            the nodes that support this resource type.

@comm       The possible list of nodes that supports the given resource type is 
            updated with the list provided.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpDecisionPossibleDmSwitchToNewQuorumLog>
****/
DWORD
FmpUpdatePossibleNodeForResType(
    IN BOOL         SourceNode,
    IN LPCWSTR      lpszResTypeName,
    IN LPDWORD      pdwBufLength,
    IN PVOID        pBuf
    )
{
    PFM_RESTYPE         pResType;
    DWORD               dwStatus;
    HDMKEY              hResTypeKey = NULL;
    HLOCALXSACTION      hXsaction = NULL;
    LIST_ENTRY          NewPosNodeList;
    PLIST_ENTRY         pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 5/13/99
    // 
    //  Don't check for FmpFMGroupsInited condition since this GUM
    //  handler is called by the forming node before that variable
    //  is set to TRUE. This update always comes after the 
    //  corresponding restypes have been created and is made
    //  internally by the clussvc following this order. Note that
    //  a joining node cannot receive this update until groups are
    //  inited since GUM receive updates are turned on only after 
    //  the FmpFMGroupsInited variable is set to TRUE. Also, the
    //  intracluster RPC is fired up in a forming node only after
    //  the groups are inited. Hence, there is no major danger 
    //  of this GUM handler being called if the corresponding 
    //  restype is not created.
    //
    if ( FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    InitializeListHead(&NewPosNodeList);

    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      lpszResTypeName);



    if (!pResType)
    {
        dwStatus = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        goto FnExit;
    }

    dwStatus = FmpAddPossibleNodeToList(pBuf, *pdwBufLength, &NewPosNodeList);

    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }


    //writes to the old log file
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    hResTypeKey = DmOpenKey(DmResourceTypesKey,
                   lpszResTypeName,
                   KEY_READ | KEY_WRITE);
    if (hResTypeKey == NULL) 
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //if there are no possible owners, delete the value
    if (pBuf && *pdwBufLength)
    {
        dwStatus = DmLocalSetValue( hXsaction,
                                hResTypeKey,
                                CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                                REG_MULTI_SZ,
                                (LPBYTE)pBuf,
                                *pdwBufLength);
    }
    else
    {
        dwStatus = DmLocalDeleteValue( hXsaction,
                                hResTypeKey,
                                CLUSREG_NAME_RESTYPE_POSSIBLE_NODES);
                                
        if (dwStatus == ERROR_FILE_NOT_FOUND)
        {
            dwStatus = ERROR_SUCCESS;
        }
    }


FnExit:
    if (dwStatus == ERROR_SUCCESS)
    {
        //commit the update on the old log file,
        //any nodes that were done, will get this change
        //I cant delete this file
        DmCommitLocalUpdate(hXsaction);

        ACQUIRE_EXCLUSIVE_LOCK(gResTypeLock);
        
        //free the old list
        while (!IsListEmpty(&pResType->PossibleNodeList))
        {
            pListEntry = RemoveHeadList(&pResType->PossibleNodeList);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            OmDereferenceObject(pResTypePosEntry->PossibleNode);
            LocalFree(pResTypePosEntry);
        }
        //now switch the possible owners list for the
        //resource type
        while (!IsListEmpty(&(NewPosNodeList)))
        {
            //remove from the new prepared list and hang
            //it of the restype structure
            pListEntry = RemoveHeadList(&NewPosNodeList);
            InsertTailList(&pResType->PossibleNodeList, pListEntry);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpUpdatePossibleNodesForRestype:Adding node  %1!ws! to %2!ws! resource type's possible node list...\n",
                        OmObjectId(pResTypePosEntry->PossibleNode),
                        lpszResTypeName);
            

        }

        RELEASE_LOCK(gResTypeLock);
        
        ClusterEvent( CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE,
                                pResType );

    
    }
    else
    {
        //free up the NewPostNodeList
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
        //if a new list was prepared, free it
        while (!IsListEmpty(&(NewPosNodeList)))
        {
            pListEntry = RemoveHeadList(&NewPosNodeList);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            OmDereferenceObject(pResTypePosEntry->PossibleNode);
            LocalFree(pResTypePosEntry);
        }

        
    }
    if (hResTypeKey) DmCloseKey(hResTypeKey);
    if (pResType) OmDereferenceObject(pResType);

    return(dwStatus);
}


/****
@func       DWORD | FmpDecidePossibleNodeForResType| When the quorum resource is changed,
            the FM invokes this api on the owner node of the new quorum resource
            to create a new quorum log file.

@parm       IN PVOID | pResource | The new quorum resource.
@parm       IN LPCWSTR | lpszPath | The path for temporary cluster files.
@parm       IN DWORD | dwMaxQuoLogSize | The maximum size limit for the quorum log file.

@comm       When a quorum resource is changed, the fm calls this funtion before it
            updates the quorum resource.  If a new log file needs to be created,
            a checkpoint is taken.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD FmpDecidePossibleNodeForResType
(
    IN PGUM_VOTE_DECISION_CONTEXT pDecisionContext,
    IN DWORD dwVoteBufLength,
    IN PVOID pVoteBuf,
    IN DWORD dwNumVotes,
    IN BOOL  bDidAllActiveNodesVote,
    OUT LPDWORD pdwOutputBufSize,
    OUT PVOID   *ppOutputBuf
)
{
    DWORD                               dwStatus = ERROR_SUCCESS;
    DWORD                               i;
    PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE pFmpVote;
    LPWSTR                              lpmszPossibleNodes = NULL;
    DWORD                               dwlpmszLen = 0;
    PVOID                               pGumBuffer = NULL;
    DWORD                               dwNodeId;
    WCHAR                               szNodeId[6];
    LPWSTR                              lpmszCurrentPossibleNodes=NULL;
    BOOL                                bChange = FALSE;
    HDMKEY                              hResTypeKey = NULL;
    DWORD                               dwSize;
    DWORD                               dwStringBufSize = 0;
    BOOL                                bAssumeSupported;
    LPWSTR                              TypeName = NULL;

    //First get the type name from pDecisionContext
    
    TypeName=(LPWSTR)LocalAlloc(LMEM_FIXED,pDecisionContext->dwInputBufLength);

    if(TypeName==NULL)
    {
        ClRtlLogPrint(LOG_ERROR,"[FM] FmpDecidePossibleNodeForResType: Not Enough Memory, error= %1!d!\r\n",
                              GetLastError());
        goto FnExit;                             
    }

    CopyMemory(TypeName,pDecisionContext->pInputBuf,pDecisionContext->dwInputBufLength);

    //initialize the out params
    *ppOutputBuf = NULL;
    *pdwOutputBufSize = 0;

    bAssumeSupported= *((BOOL*)pDecisionContext->pContext);

    if (bAssumeSupported)
    {
        hResTypeKey = DmOpenKey(DmResourceTypesKey,
                   TypeName,
                   KEY_READ | KEY_WRITE);
        if (hResTypeKey == NULL) 
        {
            dwStatus = GetLastError();
            CL_LOGFAILURE(dwStatus);
            goto FnExit;
        }

        //pass the current possible node list to the decider
        dwStatus = DmQueryString(hResTypeKey,
                                CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                                REG_MULTI_SZ,
                                &lpmszCurrentPossibleNodes,
                                &dwStringBufSize,
                                &dwSize);
        if (dwStatus != ERROR_SUCCESS)
        {
            //if the possible node list is not found this is ok
            //ie. only if there is some other error we give up
            if ( dwStatus != ERROR_FILE_NOT_FOUND ) 
            {
                CL_LOGFAILURE(dwStatus);
                goto FnExit;
            }
            
        }
        DmCloseKey(hResTypeKey);
        hResTypeKey = NULL;
    }
    
    //if the current list is passed in, dont remove any possible
    //nodes from the list if they dont vote, simply add the new ones
    if (lpmszCurrentPossibleNodes)
    {
        DWORD   dwStrLen;
        
        //make a copy of the multi-sz
        dwlpmszLen = ClRtlMultiSzLength(lpmszCurrentPossibleNodes);

        dwStrLen = dwlpmszLen * sizeof(WCHAR);
        lpmszPossibleNodes = LocalAlloc(LMEM_FIXED, dwStrLen);
        if (!lpmszPossibleNodes)
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            CL_LOGFAILURE(dwStatus);
            goto FnExit;
        }
        CopyMemory(lpmszPossibleNodes, lpmszCurrentPossibleNodes, dwStrLen);
    }        
    for (i = 0; i< dwNumVotes; i++)
    {
        pFmpVote = (PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE) 
            GETVOTEFROMBUF(pVoteBuf, pDecisionContext->dwVoteLength, i+1 , &dwNodeId);         
        //if not a valid vote, skip
        if (!pFmpVote)
            continue;
        CL_ASSERT((PBYTE)pFmpVote <= ((PBYTE)pVoteBuf + dwVoteBufLength - 
            sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE)));            
        wsprintfW(szNodeId, L"%d" , dwNodeId);
        if (pFmpVote->bPossibleNode)
        {
            if (lpmszCurrentPossibleNodes)
            {
                //if the string is already there, dont append it again
                if (ClRtlMultiSzScan(lpmszCurrentPossibleNodes, szNodeId))
                    continue;

            }
            dwStatus = ClRtlMultiSzAppend(&lpmszPossibleNodes,
                    &dwlpmszLen, szNodeId);
            bChange = TRUE;                    
            if (dwStatus != ERROR_SUCCESS)
                goto FnExit;
                    
        }
        else
        {
            //if a current list was specified
            //this node is not a possible node anymore, remove it from the list
            if (lpmszCurrentPossibleNodes)
            {
                ClRtlLogPrint(LOG_NOISE,
                            "[FM] FmpDecidePossibleNodesForRestype: Removing node %1!ws! from  %2!ws! restype possibleowner list \r\n",
                            szNodeId,TypeName);
                dwStatus = ClRtlMultiSzRemove(lpmszPossibleNodes, &dwlpmszLen, szNodeId);
                if (dwStatus == ERROR_SUCCESS)
                {
                    //if the node is successfully removed
                    bChange = TRUE;
                }
                else if (dwStatus != ERROR_FILE_NOT_FOUND)
                {
                    //if the node exists but cannot be removed return with error
                    //if the node didnt exist, we dont do anything bChange remains
                    //set at FALSE
                    goto FnExit;
                }
                else
                {
                    dwStatus = ERROR_SUCCESS;
                }
                
            }                
        }
    }

    //if nothing has changed dont issue a gum update
    if (!bChange)
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //dwlpmszLen contains the size of the multi-sz string in the
    //number of characters, make it the number of bytes
    dwlpmszLen *= sizeof(WCHAR);
    
    pGumBuffer = GumMarshallArgs(pdwOutputBufSize, 3, 
        pDecisionContext->dwInputBufLength, pDecisionContext->pInputBuf, 
        sizeof(DWORD), &dwlpmszLen, dwlpmszLen, lpmszPossibleNodes);

    *ppOutputBuf = pGumBuffer;
        
FnExit:
    if (lpmszPossibleNodes) LocalFree(lpmszPossibleNodes);
    if (hResTypeKey)
        DmCloseKey(hResTypeKey);
    if (lpmszCurrentPossibleNodes)
        LocalFree(lpmszCurrentPossibleNodes);
    if(TypeName)
        LocalFree(TypeName);

    return(dwStatus);
}



/****
@func       DWORD | FmpUpdateChangeResourceNode| This update is called to 
            update the possible nodes for a resource.  

@parm       IN BOOL | SourceNode | set to TRUE, if the update originated at this
            node.
            
@parm       IN PFM_RESOURCE | pResource | A pointer to the resource whose
            possible node list is being updated.

@parm       IN PNM_NODE | pNode | A pointer to the node to be added/removed
            from the possible node lis.

@parm       IN  DWORD | dwControlCode | If CLUSCTL_RESOURCE_ADD_OWNER then
            the node is added to the possible node list, else it is removed.

@comm       The possible list of nodes for a resource is updated.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/
DWORD
FmpUpdateChangeResourceNode(
    IN BOOL         SourceNode,
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode,
    IN DWORD        dwControlCode
    )
{
    DWORD               dwStatus;
    HDMKEY              hResKey = NULL;
    HLOCALXSACTION      hXsaction = NULL;

    //Dont acquire the local resource lock since acquiring that
    //within gum updates causes deadlock
    //use the global resource lock to synchronize this call
    //with the enumeration of possible nodes
    FmpAcquireResourceLock();

    //start a transaction
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    
    if (dwControlCode == CLUSCTL_RESOURCE_ADD_OWNER) 
    {
        dwStatus = FmpAddPossibleNode(pResource,
                                    pNode);
    } else 
    {
        dwStatus = FmpRemovePossibleNode(pResource,
                                       pNode,
                                       FALSE);
    }
    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint( LOG_NOISE,
                    "[FM] FmpUpdateChangeResourceNode, failed possible node updatefor resource <%1!ws!>, error %2!u!\n",
                    OmObjectName(pResource),
                    dwStatus );
        goto FnExit;                    
    }
                
    //fix the registry
    //SS - do we need to fix the preferred node list
    hResKey = DmOpenKey(DmResourcesKey,
                       OmObjectId(pResource),
                       KEY_READ | KEY_WRITE);
    if (hResKey == NULL) 
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    if (dwControlCode == CLUSCTL_RESOURCE_ADD_OWNER) 
    {
        dwStatus = DmLocalAppendToMultiSz(
                            hXsaction,
                            hResKey,
                            CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                            OmObjectId(pNode));
    }
    else
    {
        dwStatus = DmLocalRemoveFromMultiSz(
                            hXsaction,
                            hResKey,
                            CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                            OmObjectId(pNode));
        if (dwStatus == ERROR_FILE_NOT_FOUND) 
        {
            DWORD       i;
            DWORD       Result;
            PNM_NODE    pEnumNode;                

            //
            // Possible nodes did not exist, so create a new entry
            // with every possible node in it. FM will already have
            // removed the passed in node from the possible node list.
            //
            i=0;
            do {
                Result = FmEnumResourceNode(pResource,
                                            i,
                                            &pEnumNode);
                if (Result == ERROR_SUCCESS) 
                {
                    dwStatus = DmLocalAppendToMultiSz(
                                    hXsaction,
                                    hResKey,
                                    CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                                    OmObjectId(pEnumNode));
                    OmDereferenceObject(pEnumNode);

                } 
                else if ((Result == ERROR_NO_MORE_ITEMS) &&
                           (i == 0)) 
                {
                    //
                    // This is a funny corner case where there is a one
                    // node cluster and a resource with no possibleowners
                    // entry, and somebody removes the only node in the cluster
                    // from the possible owners list. Set PossibleOwners to
                    // the empty set.
                    //
                    dwStatus = DmLocalSetValue(
                                    hXsaction,
                                    hResKey,
                                    CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                                    REG_MULTI_SZ,
                                    (CONST BYTE *)L"\0",
                                    2);

                }
                ++i;
            } while ( Result == ERROR_SUCCESS );
            //map the error to success
            dwStatus = ERROR_SUCCESS;
        }
    }
    
    DmCloseKey(hResKey);
            

FnExit:        
    //release the lock
    FmpReleaseResourceLock();
    if (dwStatus == ERROR_SUCCESS)
    {
        //commit the update on the old log file,
        //any nodes that were done, will get this change
        //I cant delete this file
        DmCommitLocalUpdate(hXsaction);

    }
    else
    {
        //SS: BUGBUG :: validation for possible node should
        //be done before the registry is switched
        //the inmemory structure should be changed only on success
        //if there is a failure in the registry apis..the
        //in memory structure will be out of sync with registry
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
    }

    return(dwStatus);
}


/****
@func       DWORD | FmpUpdateChangeResourceGroup| This update is called to 
            update the group to which the resource belongs.

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at this
            node.
            
@parm       IN PFM_RESOURCE | pResource | A pointer to the resource whose
            possible node list is being updated.

@parm       IN PFM_GROUP | pNewGroup | A pointer to the node to be added/removed
            from the possible node lis.

@comm       The possible list of nodes for a resource is updated.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/
DWORD FmpUpdateChangeResourceGroup(
    IN BOOL         bSourceNode,
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup)
{
    DWORD               dwStatus = ERROR_SUCCESS;
    PFM_GROUP           pOldGroup;
    PFM_DEPENDENCY_TREE pTree = NULL;
    HLOCALXSACTION      hXsaction = NULL;
    HDMKEY              hOldGroupKey = NULL;
    HDMKEY              hNewGroupKey = NULL;
    PLIST_ENTRY         pListEntry;
    PFM_DEPENDTREE_ENTRY pEntry;

    pOldGroup = pResource->Group;

    //
    // Check to make sure the resource is not already in the group.
    //
    if (pOldGroup == pNewGroup) 
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //
    // Synchronize both the old and the new groups.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // strictly, the comparison below cannot be equal!
    //
    if ( lstrcmpiW( OmObjectId( pOldGroup ), OmObjectId( pNewGroup ) ) <= 0 ) 
    {
        FmpAcquireLocalGroupLock( pOldGroup );
        FmpAcquireLocalGroupLock( pNewGroup );
    } 
    else 
    {
        FmpAcquireLocalGroupLock( pNewGroup );
        FmpAcquireLocalGroupLock( pOldGroup );
    }

    //start a transaction
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnUnlock;
    }

    //
    // For now... both Groups must be owned by the same node.
    //
    if ( pResource->Group->OwnerNode != pNewGroup->OwnerNode ) 
    {
        dwStatus = ERROR_HOST_NODE_NOT_GROUP_OWNER;
        goto FnUnlock;
    }


    //
    // Create a full dependency tree, 
    //
    pTree = FmCreateFullDependencyTree(pResource);
    if ( pTree == NULL )
    {
        dwStatus = GetLastError();        
        goto FnUnlock;
    }
   

    //
    // Add each resource in the dependency tree to its new group's list.
    //
    hNewGroupKey = DmOpenKey(DmGroupsKey,
                            OmObjectId(pNewGroup),
                            KEY_READ | KEY_WRITE);
    if (hNewGroupKey == NULL) {
        dwStatus = GetLastError();
        goto FnUnlock;
    }
    hOldGroupKey = DmOpenKey(DmGroupsKey,
                            OmObjectId(pOldGroup),
                            KEY_READ | KEY_WRITE);
    if (hOldGroupKey == NULL) {
        dwStatus = GetLastError();
        goto FnUnlock;
    }

    //
    // For each resource in the dependency tree, remove it from the
    // old group list and add it to the new group list
    //
    pListEntry = pTree->ListHead.Flink;
    while (pListEntry != &pTree->ListHead) {
        pEntry = CONTAINING_RECORD(pListEntry,
                                  FM_DEPENDTREE_ENTRY,
                                  ListEntry);
        pListEntry = pListEntry->Flink;

        dwStatus = DmLocalRemoveFromMultiSz(hXsaction,
                        hOldGroupKey,
                        CLUSREG_NAME_GRP_CONTAINS,
                        OmObjectId(pEntry->Resource));

        if (dwStatus != ERROR_SUCCESS) {
            goto FnUnlock;
        }

        dwStatus = DmLocalAppendToMultiSz(hXsaction,
                        hNewGroupKey,
                        CLUSREG_NAME_GRP_CONTAINS,
                        OmObjectId(pEntry->Resource));

        if (dwStatus != ERROR_SUCCESS) {
            goto FnUnlock;
        }

    }
    
    //
    // Passed all the checks, do the in-memorymove.
    //
    pListEntry = pTree->ListHead.Flink;
    while (pListEntry != &pTree->ListHead) 
    {
        pEntry = CONTAINING_RECORD(pListEntry,
                                  FM_DEPENDTREE_ENTRY,
                                  ListEntry);
        pListEntry = pListEntry->Flink;

        //
        // Move this resource
        //
        RemoveEntryList(&pEntry->Resource->ContainsLinkage);

        InsertHeadList(&pNewGroup->Contains,
                       &pEntry->Resource->ContainsLinkage);
        OmReferenceObject(pNewGroup);
        pEntry->Resource->Group = pNewGroup;
        ++pEntry->Resource->StateSequence;

        ClusterEvent(CLUSTER_EVENT_RESOURCE_CHANGE,pEntry->Resource);
        OmDereferenceObject(pOldGroup);
    }

FnUnlock:
    //
    // Now release all locks.
    //
    FmpReleaseLocalGroupLock( pNewGroup );
    FmpReleaseLocalGroupLock( pOldGroup );

FnExit:
    if (pTree) FmDestroyFullDependencyTree(pTree);
    if (hOldGroupKey) DmCloseKey(hOldGroupKey);
    if (hNewGroupKey) DmCloseKey(hNewGroupKey);
    if (dwStatus == ERROR_SUCCESS)
    {
        ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,pNewGroup);
        ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,pOldGroup);
        DmCommitLocalUpdate(hXsaction);
    }
    else
    {
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
    }

    
    return(dwStatus);

}

DWORD
FmpUpdateAddDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    )
/*++

Routine Description:

    GUM dispatch routine for adding a dependency

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    ResourceId - Supplies the resource ID of the resource that should have a
        dependency added.

    DependsOnId - Supplies the resource ID of the resource that should provide
        for ResourceId.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    PDEPENDENCY dependency;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    dependency = LocalAlloc(LMEM_FIXED, sizeof(DEPENDENCY));
    if (dependency == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Resource = OmReferenceObjectById(ObjectTypeResource,
                                     ResourceId);
    if (Resource == NULL) {
        CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
        LocalFree(dependency);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DependsOn = OmReferenceObjectById(ObjectTypeResource,
                                      DependsOnId);
    if (DependsOn == NULL) {
        OmDereferenceObject(Resource);
        LocalFree(dependency);
        CL_LOGFAILURE( ERROR_DEPENDENCY_NOT_FOUND );
        return(ERROR_DEPENDENCY_NOT_FOUND);
    }

    dependency->DependentResource = Resource;
    dependency->ProviderResource = DependsOn;
    FmpAcquireResourceLock();
    InsertTailList( &DependsOn->ProvidesFor,
                    &dependency->ProviderLinkage );
    InsertTailList( &Resource->DependsOn,
                    &dependency->DependentLinkage );
    FmpReleaseResourceLock();

    ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                  Resource );

    //SS: we leave the reference counts on both the objects
    //as a dependency referrring to them has been created.
    return(ERROR_SUCCESS);

} // FmpUpdateAddDependency



DWORD
FmpUpdateRemoveDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    )
/*++

Routine Description:

    GUM dispatch routine for adding a dependency

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    ResourceId - Supplies the resource ID of the resource that should have a
        dependency removed.

    DependsOnId - Supplies the resource ID of the resource that provides
        for ResourceId.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    PDEPENDENCY dependency;
    PLIST_ENTRY ListEntry;
    DWORD       Status=ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    Resource = OmReferenceObjectById(ObjectTypeResource,
                                     ResourceId);
    if (Resource == NULL) {
        CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DependsOn = OmReferenceObjectById(ObjectTypeResource,
                                      DependsOnId);
    if (DependsOn == NULL) {
        OmDereferenceObject(Resource);
        CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Walk through the dependency list of the resource searching
    // for a match.
    //
    FmpAcquireResourceLock();
    ListEntry = Resource->DependsOn.Flink;
    while (ListEntry != &Resource->DependsOn) {
        dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       DependentLinkage);
        CL_ASSERT(dependency->DependentResource == Resource);
        if (dependency->ProviderResource == DependsOn) {
            //
            // Found a match. Remove it from its list and
            // free it up.
            //
            RemoveEntryList(&dependency->ProviderLinkage);
            RemoveEntryList(&dependency->DependentLinkage);
            // dereference the providor and dependent resource
            OmDereferenceObject(dependency->DependentResource);
            OmDereferenceObject(dependency->ProviderResource);
            LocalFree(dependency);
            break;
        }
        ListEntry = ListEntry->Flink;
    }
    FmpReleaseResourceLock();

    if (ListEntry != &Resource->DependsOn) {
        //
        // A match was found. Dereference the provider resource
        // to account for the dependency removal and return success.
        //
        ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                      Resource );
        Status = ERROR_SUCCESS;
    } else {
        Status = ERROR_DEPENDENCY_NOT_FOUND;
    }

    //SS: dereference the objects earlier referenced
    OmDereferenceObject(Resource);
    OmDereferenceObject(DependsOn);
    return(Status);

} // FmpUpdateRemoveDependency

DWORD
FmpUpdateDeleteGroup(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId
    )
/*++

Routine Description:

    GUM dispatch routine for deleting a group.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    GroupId - Supplies the group ID.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD           dwStatus = ERROR_SUCCESS;
    PFM_GROUP       pGroup = NULL;
    PLIST_ENTRY     listEntry;
    PPREFERRED_ENTRY preferredEntry;
    BOOL            bLocked = FALSE;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    //
    // Find the specified Group.
    //
    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    GroupId );
    if ( pGroup == NULL ) {
        dwStatus = ERROR_GROUP_NOT_FOUND;
        return(dwStatus);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] DeleteGroup %1!ws!, address = %2!lx!.\n",
               OmObjectId(pGroup),
               pGroup );
    //
    // Chittur Subbaraman (chitturs) - 1/12/99
    //
    // Try to acquire lock, and make sure the Contains list is empty.
    //
    // Most of the calls to manipulate groups make calls to the owner
    // node of the group and this operation is serialized by GUM. So,
    // there is no major danger if we do the operations in this function
    // without holding the group lock. However, we can't rule out
    // corruption 100% as of now.
    //
    // If you block within the GUM handler here, then no events in
    // the cluster proceed forward and things come to a grinding halt.
    //
    // A case in point:
    // (1) Thread 1 (the thread that calls this function) grabs the 
    // GUM lock and waits for the group lock.
    // (2) Thread 2 (FmWorkerThread) grabs the group lock and calls
    // resmon attempting to close a resource. It gets blocked on
    // the resmon eventlist lock.
    // (3) Thread 3 calls RmResourceControl to set the resource name
    // which grabs the resmon eventlist lock and then in turn calls 
    // ClusterRegSetValue and then gets blocked on the GUM lock.
    //
    FmpTryAcquireLocalGroupLock( pGroup, bLocked );

    if ( !IsListEmpty( &pGroup->Contains ) ) 
    {
        dwStatus = ERROR_DIR_NOT_EMPTY;
        goto FnExit;
    }

    //
    // Close the Group's registry key.
    //
    DmRundownList( &pGroup->DmRundownList );
    if ( pGroup->RegistryKey != NULL ) {
        DmCloseKey( pGroup->RegistryKey );
        pGroup->RegistryKey = NULL;
    }

    //
    // Remove from the node list
    //
    dwStatus = OmRemoveObject( pGroup );
    
    ClusterEvent( CLUSTER_EVENT_GROUP_DELETED, pGroup );
    //
    // This dereference would normally cause the group to eventually disappear,
    // however the event notification above will keep a ref on the object
    // until all notifications have been delivered.
    //
    OmDereferenceObject( pGroup );

    //
    // Make sure the preferred owners list is drained.
    //
    while ( !IsListEmpty( &pGroup->PreferredOwners ) ) {
        listEntry = RemoveHeadList(&pGroup->PreferredOwners);
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        OmDereferenceObject( preferredEntry->PreferredNode );
        LocalFree( preferredEntry );
    }

    //
    //  Free the string associated with the AntiAffinityClassName field.
    //
    LocalFree ( pGroup->lpszAntiAffinityClassName );

    pGroup->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_DELETE;
    
FnExit:
    if( bLocked ) 
    {
        FmpReleaseLocalGroupLock( pGroup );
    }

    //
    // Dereference for reference above.
    //
    if (pGroup) OmDereferenceObject( pGroup );

    return(dwStatus);

} // FmpUpdateDeleteGroup

/****
@func       DWORD | FmpUpdateGroupIntendedOwner| This update is called on
            a move just before the source node requests the target node
            to take over the group.  

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at 
this
            node.
            
@parm       IN PFM_GROUP | pszGroupId | The ID of the group that is about 
            to move.

@parm       IN PDWORD | pdwNodeId| A pointer to a DWORD that contains the
            ID of the node that is the destination of this move.  It is 
            set to ClusterInvalidNodeId by the destination node when it has 
            accepted the group.

@comm       The purpose of this update is to let all nodes know that a move
            is impending.  If the source node dies while a move is in progress
            then preference is given to the target of the move rather than the
            node that is chosen by the FmpUpdateAssignOwnerToGroups

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD
FmpUpdateGroupIntendedOwner(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszGroupId,
    IN PDWORD   pdwNodeId
    )
{
    PFM_GROUP   pGroup = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNode = NULL;
    PNM_NODE    pPrevNode;
    WCHAR       pszNodeId[6];
    
    if ( !FmpFMGroupsInited ) 
    {
        return(ERROR_SUCCESS);
    }

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                   pszGroupId );

    if (pGroup == NULL)
    {
        dwStatus =  ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    if (*pdwNodeId != ClusterInvalidNodeId)
    {
        wsprintfW(pszNodeId, L"%u", *pdwNodeId);

        pNode = OmReferenceObjectById(ObjectTypeNode,
                                        pszNodeId);

        if (pNode == NULL)
        {
            dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
            goto FnExit;
        }
    } else if (pGroup->pIntendedOwner == NULL)
    {
        dwStatus = ERROR_CLUSTER_INVALID_NODE;
        ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateGroupIntendedOwner: Group <%1!ws!> intended owner is already invalid, not setting....\n",
              pszGroupId);
        goto FnExit;
    }
    
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpAcquireLocalGroupLock(pGroup);
    
    pPrevNode = pGroup->pIntendedOwner;

    //set the new owner node, incr ref count
    if (pNode) OmReferenceObject(pNode);
    pGroup->pIntendedOwner = pNode;

    //decr ref count on previous owner
    if (pPrevNode) OmDereferenceObject(pPrevNode);
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpReleaseLocalGroupLock(pGroup);
    
FnExit:
    if (pGroup) OmDereferenceObject(pGroup);
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}


/****
@func       DWORD | FmpUpdateAssignOwnerToGroups| This update is made when
            a node goes down to take ownership of all the orphaned groups.

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at 
this
            node.
            
@parm       IN LPCWSTR | pszGroupId | The ID of the group that is about 
            to move.

@parm       IN PDWORD | pdwNodeId| A pointer to a DWORD that contains the
            ID of the node that is the destination of this move.  It is 
            set to ClusterInvalidNodeId by the destination node when it has 
            accepted the group.

@comm       The purpose of this update is to let all nodes know that a move
            is impending.  If the source node dies while a move is in progress
, 
            then preference is given to the target of the move rather than the
            node that is chosen by the FmpClaimNodeGroups algorithm.

@rdesc      returns ERROR_SUCCESS.
****/
DWORD
FmpUpdateAssignOwnerToGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    )
{
    PNM_NODE    pNode = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return(ERROR_SUCCESS);
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   pszNodeId );

    if (!pNode)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateAssignOwnersToGroups, %1!ws! node not found\n",
                   pszNodeId);
        //should we return failure here
        //is evict of a node synchronized with everything
        goto FnExit;                   
    }

    //if this update has already been seen after the node down
    //ignore this one
    if (gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingInProgress == 0)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateAssignOwnersToGroups, %1!ws! node down has been processed already\n",
                   pszNodeId);
        goto FnExit;                   
    }
    //
    // Assign ownership to all groups owned by the dead node
    //
    dwStatus = FmpAssignOwnersToGroups(pNode, NULL, NULL);

    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateAssignOwnersToGroups failed %1!d!\n",
                   dwStatus);
    }                   
    
    //mark that the node down processing has been done
    gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingInProgress = 0;
    
FnExit:        
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}

/****
@func       DWORD | FmpUpdateApproveJoin| The joining node
            makes this update call.

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at 
this
            node.
            
@parm       IN LPCWSTR | pszGroupId | The ID of the group that is about 
            to move.

@parm       IN PDWORD | pdwNodeId| A pointer to a DWORD that contains the
            ID of the node that is the destination of this move.  It is 
            set to ClusterInvalidNodeId by the destination node when it has 
            accepted the group.

@comm       The purpose of this update is to let all nodes know that a move
            is impending.  If the source node dies while a move is in progress
, 
            then preference is given to the target of the move rather than the
            node that is chosen by the FmpClaimNodeGroups algorithm.

@rdesc      returns ERROR_SUCCESS.
****/
DWORD
FmpUpdateApproveJoin(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    )
{

    PNM_NODE    pNode = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return(ERROR_SUCCESS);
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   pszNodeId );

    if (!pNode)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateAssignOwnersToGroups, %1!ws! node not found\n",
                   pszNodeId);
        //should we return failure here
        //is evict of a node synchronized with everything
        goto FnExit;                   
    }

    if (pNode == NmLocalNode)
    {
        // SS: can I become the locker now
        // If so, there what do I do
        //i approve of my own join
        goto FnExit;
    }
    //if a node is trying to join before the processing
    //for its last death has been completed, ask it to retry
    if (gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingInProgress == 1)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateApproveJoin, %1!ws! node down hasnt been processed as yet\n",
                   pszNodeId);
        dwStatus = ERROR_RETRY;                   
        goto FnExit;                   
    }
FnExit:        
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}

/****
@func       DWORD | FmpUpdateCreateGroup | GUM update handler for creating
            a group.
           
@parm       IN OUT PGUM_CREATE_GROUP | pGumGroup | Buffer containing group info

@parm       IN BOOL | bSourceNode | Indicates whether this call originated
            from this node.

@comm       This GUM update creates a group and is structured as a local 
            transaction so that both registry entries and in-memory
            structures are updated consistently.

@rdesc      Returns ERROR_SUCCESS on success. A Win32 error code otherwise.
****/
DWORD
FmpUpdateCreateGroup(
    IN OUT PGUM_CREATE_GROUP pGumGroup,
    IN BOOL    bSourceNode
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    HDMKEY      hKey = NULL;
    DWORD       dwDisposition;
    HLOCALXSACTION      
                hXsaction = NULL;
    LPCWSTR     lpszNodeId = NULL;
    PNM_NODE    pNode = NULL;
    DWORD       dwGroupIdLen = 0;
    DWORD       dwGroupNameLen = 0;
    LPWSTR      lpszGroupId = NULL;
    LPCWSTR     lpszGroupName = NULL;
    BOOL        bLocked = FALSE;

    //
    //  Chittur Subbaraman (chitturs) - 5/27/99
    //
    //  Restructure this GUM update as a local transaction.
    //
    dwGroupIdLen = pGumGroup->GroupIdLen;  
    dwGroupNameLen = pGumGroup->GroupNameLen;  
    lpszGroupId = pGumGroup->GroupId; 
    lpszGroupName = (PWSTR)((PCHAR)lpszGroupId +
                                   dwGroupIdLen );
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateGroup: Entry for group %1!ws!...\n",
                lpszGroupId);
    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateGroup, Failed in starting a transaction for group %1!ws!, Status =%2!d!....\n",
                   lpszGroupId,
                   dwStatus);
        return( dwStatus );
    }

    //
    // Create the new group key.
    //
    hKey = DmLocalCreateKey( hXsaction,
                             DmGroupsKey,
                             lpszGroupId,
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &dwDisposition );
                            
    if ( hKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateGroup, Failed in creating the group key for group %1!ws!, Status =%2!d!....\n",
                   lpszGroupId,
                   dwStatus);
        goto FnExit;
    }
    
    if ( dwDisposition != REG_CREATED_NEW_KEY ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateGroup used GUID %1!ws! that already existed! This is impossible.\n",
                   lpszGroupId);
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    CL_ASSERT( dwDisposition == REG_CREATED_NEW_KEY );

    //
    // Set the group name in the registry
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hKey,
                                CLUSREG_NAME_GRP_NAME,
                                REG_SZ,
                                ( CONST BYTE * ) lpszGroupName,
                                ( lstrlenW( lpszGroupName ) + 1 ) * 
                                    sizeof( WCHAR ) );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateGroup: DmLocalSetValue for group %1!ws! fails, Status = %2!d!...\n",
                   lpszGroupId,
                   dwStatus);
        goto FnExit;     
    }
    
    //
    // We really shouldn't be acquiring locks here... but
    // we'll try anyway. If we fail, we must return an error
    // because we have nothing to return.
    //
    FmpTryAcquireGroupLock( bLocked, 500 );
    if ( !bLocked ) 
    {
        pGumGroup->Group = NULL;
        dwStatus = ERROR_SHARING_VIOLATION;
        goto FnExit;
    }

    pGumGroup->Group = FmpCreateGroup( lpszGroupId, TRUE );
    
    if ( pGumGroup->Group == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateGroup, FmpCreateFroup failed for group %1!ws!, Status =%2!d!....\n",
                   lpszGroupId,
                   dwStatus);
        goto FnExit;
    } else 
    {
        if ( bSourceNode ) 
        {
            OmReferenceObject( pGumGroup->Group );
            OmReferenceObject( NmLocalNode );
            pNode = NmLocalNode;
        } else {
            lpszNodeId = (PWSTR)((PCHAR)lpszGroupId +
                                   dwGroupIdLen +
                                   dwGroupNameLen );
            pNode = OmReferenceObjectById( ObjectTypeNode, lpszNodeId );
            if ( pNode == NULL ) 
            {
                CL_LOGFAILURE( ERROR_CLUSTER_NODE_NOT_FOUND );
                dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
                ClRtlLogPrint(LOG_UNUSUAL,
                            "[FM] FmpUpdateCreateGroup, Could not find node for group %1!ws!, Status =%2!d!....\n",
                            lpszGroupId,
                            dwStatus);
                CsInconsistencyHalt( ERROR_CLUSTER_NODE_NOT_FOUND );
            }
        }

        CL_ASSERT( pGumGroup->Group->OwnerNode == NULL );

        if ( !FmpInPreferredList( pGumGroup->Group, pNode , FALSE, NULL) ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                        "[FM] FmpUpdateCreateGroup, node %1!ws! is not in preferred list for group %2!ws!.\n",
                         OmObjectId( pNode ),
                         OmObjectId( pGumGroup->Group ));
        }

        pGumGroup->Group->OwnerNode = pNode;
              
        if ( OmSetObjectName( pGumGroup->Group, lpszGroupName ) != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                        "[FM] FmpUpdateCreateGroup, Cannot set name for group %1!ws!...\n",
                        OmObjectId( pGumGroup->Group ));
        }
        
        ClusterEvent( CLUSTER_EVENT_GROUP_ADDED, pGumGroup->Group );
    }
                           
FnExit:
    if ( bLocked ) 
    {
        FmpReleaseGroupLock( );
    }
    
    if ( hKey != NULL ) 
    {
        DmCloseKey( hKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateGroup: Exit for group %1!ws!, Status=%2!u!...\n",
                lpszGroupId,
                dwStatus);

    return( dwStatus );
}

/****
@func       DWORD | FmpUpdateCompleteGroupMove | This update is made when
            FmpTakeGroupRequest fails with an RPC error.

@parm       IN BOOL | bSourceNode | Set to TRUE, if the update originated at 
            this node. Not used.
            
@parm       IN LPCWSTR | pszNodeId | The ID of the dead node.

@parm       IN LPCWSTR | pszGroupId | The ID of the group which was in the
            middle of the move.

@comm       The purpose of this update is to let the ownership of the
            group which was in the middle of the move determined consistently.

@rdesc      Returns ERROR_SUCCESS.
****/
DWORD
FmpUpdateCompleteGroupMove(
    IN BOOL     bSourceNode,
    IN LPCWSTR  pszNodeId,
    IN LPCWSTR  pszGroupId
    )
{

    PNM_NODE    pNode = NULL;
    PFM_GROUP   pGroup = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/2/2000
    // 
    //  If FM groups are not fully initialized, then  don't do anything.
    //  Don't check for shutdown since we need to handle take group
    //  exceptions for the quorum group even during a shutdown.
    //
    if ( !FmpFMGroupsInited ) 
    {
        return( ERROR_SUCCESS );
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   pszNodeId );

    if ( !pNode )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateCompleteGroupMove, %1!ws! node not found\n",
                   pszNodeId);
        goto FnExit;                   
    }

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    pszGroupId );

    if ( !pGroup )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateCompleteGroupMove, %1!ws! group not found\n",
                   pszGroupId);
        goto FnExit;                   
    }

    //
    // Assign ownership to this group which was in the middle of a move
    //
    dwStatus = FmpAssignOwnersToGroups( pNode, pGroup, NULL );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCompleteGroupMove failed with error %1!d!\n",
                   dwStatus);
    }                   
    
FnExit:        
    if ( pNode ) OmDereferenceObject( pNode );
    
    if ( pGroup ) OmDereferenceObject( pGroup );

    return( dwStatus );
}

DWORD
FmpUpdateCheckAndSetGroupOwner(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszGroupId,
    IN LPCWSTR lpszNodeId
    )
/*++

Routine Description:

    GUM update handler called from FmpTakeGroupRequest for NT5 cluster
    to set the group owner ONLY IF its intended owner is the future
    owner node.

Arguments:

    bSourceNode - Supplies whether or not this node was the source of the update

    lpszGroupId - Supplies the id of the resource whose state is changing

    lpszNodeId - Supplies the node id of the group owner.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP pGroup = NULL;
    DWORD     dwStatus = ERROR_SUCCESS;
    PNM_NODE  pNode = NULL;
    PNM_NODE  pPrevNode = NULL;

    //dont check for shutdown - we cant afford to lose ownership notifications
    //while we are shutting down
    //since we dont destroy any fm structures - there shouldnt be a problem in
    //handling these
    if ( !FmpFMGroupsInited ) 
    {
        return( ERROR_SUCCESS );
    }

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateCheckAndSetGroupOwner: Entry for Group = <%1!ws!>....\n",
              lpszGroupId);
    //
    //  Chittur Subbaraman (chitturs) - 7/27/99
    //
    //  This GUM handler sets the group ownership only if the future owner
    //  node is the group's intended owner. If the intended owner is NULL, 
    //  it means the node down processing GUM handler has taken charge 
    //  of this group. If the intended owner is not NULL and not the 
    //  future owner node, then it means that the node down processing 
    //  GUM handler has assigned ownership to the group and the group 
    //  started moving to a different target before the FmpTakeGroupRequest 
    //  that issued this GUM due as a part of the first move operation 
    //  got a chance to execute. In both cases, lay your hands off the 
    //  group.
    //
    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    lpszGroupId );

    if ( pGroup == NULL )
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmpUpdateCheckAndSetGroupOwner: GroupID = %1!ws! could not be found...\n",
                   lpszGroupId);
        dwStatus = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   lpszNodeId );

    if ( pNode == NULL )
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmpUpdateCheckAndSetGroupOwner: NodeID = %1!ws! could not be found, Group = %2!ws!...\n",
                   lpszNodeId,
                   lpszGroupId);
        dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
        goto FnExit;
    }

    if ( pGroup->pIntendedOwner != pNode )
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmpUpdateCheckAndSetGroupOwner: Group = <%1!ws!> intended owner is invalid, not setting group ownership...\n",
                   lpszGroupId);
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }
    
    pPrevNode = pGroup->OwnerNode;

    //
    // Set the new owner node, incr ref count
    //
    OmReferenceObject( pNode );
    
    pGroup->OwnerNode = pNode;

    //
    // Decrement the ref count on previous owner
    //
    OmDereferenceObject( pPrevNode );

    //
    // Generate an event to signify group owner node change
    //
    ClusterEvent( CLUSTER_EVENT_GROUP_CHANGE, pGroup );
    
FnExit:
    if ( pGroup ) OmDereferenceObject( pGroup );
    
    if ( pNode ) OmDereferenceObject( pNode );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateCheckAndSetGroupOwner: Exit for Group = <%1!ws!>, Status=%2!u!....\n",
              lpszGroupId,
              dwStatus);
    
    return( dwStatus );
}

DWORD
FmpUpdateCreateResourceType(
    IN PVOID Buffer    
    )
/*++

Routine Description:

    GUM update handler called for creating a resource type. For
    NT5.1 clusters, this GUM handler does both the registry and
    in-memory updates as a local transaction.

Arguments:

    Buffer - Buffer containing resource type information.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESTYPE         pResType = NULL;
    LPWSTR              lpszTypeName;
    LPWSTR              lpszDisplayName;
    LPWSTR              lpszDllName;
    DWORD               dwStatus = ERROR_SUCCESS;
    DWORD               dwLooksAlive;
    DWORD               dwIsAlive;
    DWORD               dwDllNameLen;
    DWORD               dwDisplayNameLen;
    DWORD               dwTypeNameLen;
    DWORD               dwClusterHighestVersion;
    DWORD               dwDisposition;
    HLOCALXSACTION      hXsaction = NULL;
    HDMKEY              hTypeKey = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 2/8/2000
    //
    //  Rewrite this GUM handler as a local transaction (for NT5.1 only)
    //
    lpszTypeName = ( LPWSTR ) Buffer;

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateCreateResourceType, Entry for resource type %1!ws!...\n",
               lpszTypeName);       

    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      lpszTypeName );
    if ( pResType )
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Resource type %1!ws! already exists, Status = %2!d!...\n",
                  lpszTypeName,
                  dwStatus);       
        OmDereferenceObject( pResType );
        return( dwStatus );
    }

    dwTypeNameLen = ( lstrlenW( lpszTypeName ) + 1 ) * sizeof( WCHAR );

    lpszDisplayName = ( LPWSTR ) ( ( PCHAR ) Buffer + dwTypeNameLen );

    dwDisplayNameLen = ( lstrlenW( lpszDisplayName ) + 1 ) * sizeof( WCHAR );

    lpszDllName = ( LPWSTR ) ( ( PCHAR ) Buffer +
                               dwTypeNameLen +
                               dwDisplayNameLen );

    dwDllNameLen = ( lstrlenW( lpszDllName ) + 1 ) * sizeof( WCHAR );

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) 
    {   
        goto skip_registry_updates;
    }

    dwLooksAlive = *( DWORD UNALIGNED * ) ( ( ( PCHAR ) Buffer +
                               dwTypeNameLen +
                               dwDisplayNameLen + 
                               dwDllNameLen ) );
                              
    dwIsAlive = *( DWORD UNALIGNED * ) ( ( ( PCHAR ) Buffer +
                            dwTypeNameLen +
                            dwDisplayNameLen + 
                            dwDllNameLen + 
                            sizeof( DWORD ) ) );

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in starting a transaction for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);
        return( dwStatus );
    }

    hTypeKey = DmLocalCreateKey( hXsaction,
                                 DmResourceTypesKey,
                                 lpszTypeName,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &dwDisposition );
    if ( hTypeKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in creating the resource types key for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);       
        goto FnExit;
    }

    if ( dwDisposition != REG_CREATED_NEW_KEY ) 
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Duplicate resource types key exists for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_DLL_NAME,
                                REG_SZ,
                                ( CONST BYTE * )lpszDllName,
                                dwDllNameLen );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the DLL name for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_IS_ALIVE,
                                REG_DWORD,
                                ( CONST BYTE * )&dwIsAlive,
                                sizeof( DWORD ) );


    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the Is Alive interval for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                                REG_DWORD,
                                ( CONST BYTE * )&dwLooksAlive,
                                sizeof( DWORD ) );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the Looks Alive interval for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_NAME,
                                REG_SZ,
                                ( CONST BYTE * )lpszDisplayName,
                                dwDisplayNameLen );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the display name for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }
    
skip_registry_updates:
    pResType = FmpCreateResType( lpszTypeName );

    if ( pResType != NULL ) 
    {
        dwStatus = FmpRmLoadResTypeDll( pResType );
        if ( dwStatus == ERROR_SUCCESS )
        {
            pResType->State = RESTYPE_STATE_LOADS;
        } else
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpUpdateCreateResourceType: Unable to load dll for resource type %1!ws!, Status=%2!u!...\n",
                       lpszTypeName,
                       dwStatus);
            //
            //  Some nodes may not support this resource type. So, consider
            //  the loading failure as success. However, log the error.
            //
            dwStatus = ERROR_SUCCESS;
        }
    } else
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpUpdateCreateResourceType: Unable to create resource type %1!ws!, Status=%2!u!...\n",
                   lpszTypeName,
                   dwStatus);
    }

FnExit:
    if ( hTypeKey != NULL ) 
    {
        DmCloseKey( hTypeKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResourceType: Exit for resource type %1!ws!, Status=%2!u!...\n",
                lpszTypeName,
                dwStatus);

    return( dwStatus ); 
}

DWORD
FmpUpdateCreateResource(
    IN OUT PGUM_CREATE_RESOURCE pGumResource
    )
{
/*++

Routine Description:

    GUM update handler called for creating a resource. For
    NT5.1 clusters, this GUM handler does both the registry and
    in-memory updates as a local transaction.

Arguments:

    pGumResource - Structure containing resource information.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
    DWORD       dwStatus = ERROR_SUCCESS;
    HDMKEY      hResourceKey = NULL;
    HDMKEY      hGroupKey = NULL;
    DWORD       dwDisposition;
    HLOCALXSACTION      
                hXsaction = NULL;
    DWORD       dwClusterHighestVersion;
    PGUM_CREATE_RESOURCE GumResource;
    LPWSTR      lpszResourceId = NULL;
    LPWSTR      lpszResourceName = NULL;
    LPWSTR      lpszResourceType = NULL;
    PFM_GROUP   pGroup = NULL;
    PFM_RESTYPE pResType = NULL;
    DWORD       dwpollIntervals = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
    DWORD       dwPersistentState = 0;
    DWORD       dwResourceTypeLen = 0;
    DWORD       dwFlags = 0;
    HDMKEY      hParamKey = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 1/30/2000
    //
    //  Restructure this GUM update as a local transaction.
    //

    lpszResourceId = (LPWSTR)( (PCHAR) pGumResource->GroupId +
                                       pGumResource->GroupIdLen );

    lpszResourceName = (LPWSTR)( (PCHAR) pGumResource->GroupId +
                                         pGumResource->GroupIdLen +
                                         pGumResource->ResourceIdLen );

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    pGumResource->GroupId );

    if ( pGroup == NULL ) 
    {
        CL_LOGFAILURE( ERROR_GROUP_NOT_FOUND );
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: Group for resource %1!ws! not found.\n",
                   lpszResourceId);
        return( ERROR_GROUP_NOT_FOUND );
    }
 
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResource: Entry for resource %1!ws!...\n",
                lpszResourceId);
    //
    //  If we are dealing with the mixed mode cluster, don't bother to
    //  do these registry updates since the API layer would do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResource: Skipping registry updates for resource %1!ws!...\n",
                lpszResourceId);
        goto skip_registry_updates;
    }

    dwResourceTypeLen = *( DWORD UNALIGNED * )( (PCHAR) pGumResource->GroupId +
                                         pGumResource->GroupIdLen +
                                         pGumResource->ResourceIdLen +
                                         (lstrlenW(lpszResourceName)+1) * sizeof(WCHAR) );

    lpszResourceType = (LPWSTR)( (PCHAR) pGumResource->GroupId +
                                         pGumResource->GroupIdLen +
                                         pGumResource->ResourceIdLen +
                                         (lstrlenW(lpszResourceName)+1) * sizeof(WCHAR) + 
                                         sizeof( DWORD ) );
    
    dwFlags = *( DWORD UNALIGNED * )( (PCHAR) pGumResource->GroupId +
                               pGumResource->GroupIdLen +
                               pGumResource->ResourceIdLen +
                               (lstrlenW(lpszResourceName)+1) * sizeof(WCHAR) +
                               sizeof( DWORD ) + 
                               dwResourceTypeLen );

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateResource, Failed in starting a transaction for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        OmDereferenceObject( pGroup );
        return( dwStatus );
    }

    //
    // Create the new resources key.
    //
    hResourceKey = DmLocalCreateKey( hXsaction,
                                     DmResourcesKey,
                                     lpszResourceId,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &dwDisposition );
                            
    if ( hResourceKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateResource, Failed in creating the resource key for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }
    
    if ( dwDisposition != REG_CREATED_NEW_KEY ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource used GUID %1!ws! that already existed! This is impossible.\n",
                   lpszResourceId);
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    CL_ASSERT( dwDisposition == REG_CREATED_NEW_KEY );

    //
    // Set the resource name in the registry
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_NAME,
                                REG_SZ,
                                (CONST BYTE *)lpszResourceName,
                                (lstrlenW(lpszResourceName)+1)*sizeof(WCHAR) );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (resource name) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;     
    }

    //
    // Set the resource's type in the registry
    // Note we reference the resource type and use its ID
    // so that the case is correct.
    //
    pResType = OmReferenceObjectById( ObjectTypeResType, lpszResourceType );
    CL_ASSERT( pResType != NULL );
    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_TYPE,
                                REG_SZ,
                                (CONST BYTE *) OmObjectId( pResType ),
                                (lstrlenW( lpszResourceType ) + 1 )*sizeof(WCHAR) );
    OmDereferenceObject( pResType );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (resource type) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // Set the resource's poll intervals in the registry.
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_LOOKS_ALIVE,
                                REG_DWORD,
                                (CONST BYTE *)&dwpollIntervals,
                                4 );
                              
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (looks alive) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_IS_ALIVE,
                                REG_DWORD,
                                (CONST BYTE *)&dwpollIntervals,
                                4);

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (is alive) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // If this resource should be started in a separate monitor, set that
    // parameter now.
    //
    if ( dwFlags & CLUSTER_RESOURCE_SEPARATE_MONITOR ) 
    {
        DWORD dwSeparateMonitor = 1;

        dwStatus = DmLocalSetValue( hXsaction,
                                    hResourceKey,
                                    CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                    REG_DWORD,
                                    (CONST BYTE *)&dwSeparateMonitor,
                                    sizeof( dwSeparateMonitor ) );
                                  
        if ( dwStatus != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (separate monitor) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
            goto FnExit;
        }
    }

    //
    // Create a Parameters key for the resource.
    //
    hParamKey = DmLocalCreateKey( hXsaction,
                                  hResourceKey,
                                  CLUSREG_KEYNAME_PARAMETERS,                   
                                  0,
                                  KEY_READ,
                                  NULL,
                                  &dwDisposition );
    if ( hParamKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalCreateKey (parameters) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        CL_LOGFAILURE( dwStatus );
        goto FnExit;
    } else 
    {
        DmCloseKey( hParamKey );
    }

    hGroupKey = DmOpenKey( DmGroupsKey, 
                           OmObjectId(pGroup), 
                           KEY_READ | KEY_WRITE);

    if ( hGroupKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmOpenKey (group key) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 5/25/99
    //
    //  Make sure you set the persistent state of the resource to 
    //  ClusterResourceOffline before you create the resource. If
    //  this is not done, if you create a resource in a group which
    //  is online, the group's persistent state value (i.e., 1 in
    //  this case) is inherited by the resource in FmpQueryResourceInfo
    //  (only the memory state is set and not the registry state and
    //  this was a problem as well) and if you move such a group to 
    //  another node, it will bring the newly created resource online.
    //
    dwStatus = DmLocalSetValue(  hXsaction,
                                 hResourceKey,
                                 CLUSREG_NAME_RES_PERSISTENT_STATE,
                                 REG_DWORD,
                                 ( CONST BYTE * )&dwPersistentState,
                                 sizeof( DWORD ) );
                         
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (persistent state) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
         goto FnExit;
    }

    //
    // Add the resource to the Contains value of the specified group.
    //      
    dwStatus = DmLocalAppendToMultiSz( hXsaction,
                                       hGroupKey,
                                       CLUSREG_NAME_GRP_CONTAINS,
                                       lpszResourceId );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalAppendToMultiSz (contains key) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }
    
skip_registry_updates:
    FmpAcquireResourceLock();

    pGumResource->Resource = FmpCreateResource( pGroup,
                                                lpszResourceId,
                                                lpszResourceName,
                                                FALSE );
                                               
    if ( pGumResource->Resource == NULL ) 
    {
       dwStatus = GetLastError();
       ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: FmpCreateResource for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);      
    } else 
    {
        ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,
                                  pGroup );
        ClusterEvent( CLUSTER_EVENT_RESOURCE_ADDED,
                                  pGumResource->Resource );
        if ( pGumResource->Resource ) 
        {
            OmReferenceObject( pGumResource->Resource );
            FmpPostWorkItem( FM_EVENT_RESOURCE_ADDED,
                             pGumResource->Resource,
                             0 );
        }
    }

    FmpReleaseResourceLock();

FnExit:
    if ( pGroup != NULL )
    {
        OmDereferenceObject( pGroup );
    }
    
    if ( hResourceKey != NULL ) 
    {
        DmCloseKey( hResourceKey );
    }

    if ( hGroupKey != NULL ) 
    {
        DmCloseKey( hGroupKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResource: Exit for resource %1!ws!, Status=%2!u!...\n",
                lpszResourceId,
                dwStatus);

    return( dwStatus );
}

DWORD
FmpUpdateDeleteResource(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszResourceId
    )
/*++

Routine Description:

    GUM dispatch routine for deleting a resource.  For NT5.1 clusters, this is structured as
    as local transaction.

Arguments:

    bSourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    lpszResourceId - Supplies the resource ID.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/
{
    PFM_RESOURCE    pResource = NULL;
    PFM_GROUP       pGroup = NULL;
    PLIST_ENTRY     pListEntry = NULL;
    PDEPENDENCY     pDependency = NULL;
    PPOSSIBLE_ENTRY pPossibleEntry = NULL;
    DWORD           dwStatus;
    HLOCALXSACTION      
                    hXsaction = NULL;
    DWORD           dwClusterHighestVersion;
    HDMKEY          pGroupKey;

    //
    //  Chittur Subbaraman (chitturs) - 9/7/2000
    //  
    //  Structure this GUM update as a local transaction.
    //
    
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return( ERROR_SUCCESS );
    }

    pResource = OmReferenceObjectById( ObjectTypeResource, lpszResourceId );
    
    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                     "[FM] FmpUpdateDeleteResource: Resource %1!ws! cannot be found....\n",
                     lpszResourceId );
        return( ERROR_RESOURCE_NOT_FOUND );
    }

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpUpdateDeleteResource: Delete resource %1!ws!, address %2!lx!....\n",
                 lpszResourceId,
                 pResource );

    //
    //  NOTE: It is difficult to include the checkpoint removal in a local transaction, so keep it 
    //  out for now.  Also, note that these functions MUST be called BEFORE the Resources key is
    //  deleted since they enumerate the values under "Resources\RegSync" and "Resources\CryptoSync".
    //
    if ( pResource->Group->OwnerNode == NmLocalNode ) 
    {
        CpckRemoveResourceCheckpoints( pResource );
        CpRemoveResourceCheckpoints( pResource );
    }

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateDeleteResource: Failed in starting a transaction for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // Cannot acquire group lock here to avoid deadlocks with this current design.
    //
    
    //
    // Remove all registry entries corresponding to the DependsOn list.
    //
    pListEntry = pResource->DependsOn.Flink;
    while ( pListEntry != &pResource->DependsOn ) 
    {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         DependentLinkage );
        CL_ASSERT( pDependency->DependentResource == pResource );
        pListEntry = pListEntry->Flink;
        //
        //  Note that the removal of registry entries is done as a local transaction.
        //
        dwStatus = FmpRemoveResourceDependency( hXsaction, 
                                                pResource,
                                                pDependency->ProviderResource );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateDeleteResource: Unable to remove 'DependsOn' registry entries for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);   
            goto FnExit;
        }
    }

    //
    // Remove all registry entries corresponding to the ProvidesFor list.
    //
    pListEntry = pResource->ProvidesFor.Flink;
    while ( pListEntry != &pResource->ProvidesFor ) 
    {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         ProviderLinkage );
        CL_ASSERT( pDependency->ProviderResource == pResource );
        pListEntry = pListEntry->Flink;
        //
        //  Note that the removal of registry entries is done as a local transaction.
        //
        dwStatus = FmpRemoveResourceDependency( hXsaction, 
                                                pDependency->DependentResource,
                                                pResource );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateDeleteResource: Unable to remove 'ProvidesFor' registry entries for resource %1!ws!, Status=%2!d!....\n",
                   lpszResourceId,
                   dwStatus);   
            goto FnExit;
        }
    }

    //
    //  If we are dealing with a Whistler-Win2K cluster, don't bother to
    //  do these registry updates since the API layer would do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateDeleteResource: Skipping registry updates for resource %1!ws!...\n",
                lpszResourceId);
        goto skip_registry_updates;
    }

    dwStatus = DmLocalDeleteTree( hXsaction, 
                                  DmResourcesKey, 
                                  OmObjectId( pResource ) );

    if ( ( dwStatus != ERROR_SUCCESS ) &&
         ( dwStatus != ERROR_FILE_NOT_FOUND ) ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateDeleteResource: Unable to remove 'Resources' tree for resource %1!ws!, Status=%2!d!....\n",
                      lpszResourceId,
                      dwStatus);   
        goto FnExit;
    }

    pGroupKey = DmOpenKey( DmGroupsKey,
                           OmObjectId( pResource->Group ),
                           KEY_READ | KEY_SET_VALUE );

    if ( pGroupKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateDeleteResource: Unable to find 'Groups' key for resource %1!ws!, Status=%2!d!....\n",
                      lpszResourceId,
                      dwStatus);   
        goto FnExit;
    }

    dwStatus = DmLocalRemoveFromMultiSz( hXsaction,
                                         pGroupKey,
                                         CLUSREG_NAME_GRP_CONTAINS,
                                         OmObjectId( pResource ) );

    DmCloseKey( pGroupKey );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                     "[FM] FmpUpdateDeleteResource: Unable to remove contains list for resource %1!ws! in group %2!ws!, Status=%3!d!....\n",
                      lpszResourceId,
                      OmObjectId( pResource->Group ),
                      dwStatus);   
        goto FnExit;
    }
    
skip_registry_updates:
    //
    // Remove all list entries corresponding to the DependsOn list.
    //
    pListEntry = pResource->DependsOn.Flink;
    while ( pListEntry != &pResource->DependsOn ) {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         DependentLinkage );
        pListEntry = pListEntry->Flink;
        RemoveEntryList( &pDependency->ProviderLinkage );
        RemoveEntryList( &pDependency->DependentLinkage );
        OmDereferenceObject( pDependency->DependentResource );
        OmDereferenceObject( pDependency->ProviderResource );
        LocalFree( pDependency );
    }

    //
    // Remove all list entries corresponding to the ProvidesFor list.
    //
    pListEntry = pResource->ProvidesFor.Flink;
    while ( pListEntry != &pResource->ProvidesFor ) {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         ProviderLinkage );
        pListEntry = pListEntry->Flink;
        RemoveEntryList( &pDependency->ProviderLinkage );
        RemoveEntryList( &pDependency->DependentLinkage );
        OmDereferenceObject( pDependency->DependentResource );
        OmDereferenceObject( pDependency->ProviderResource );
        LocalFree( pDependency );
    }
    
    //
    // Remove all entries from the possible owners list.
    //
    while ( !IsListEmpty( &pResource->PossibleOwners ) ) 
    {
        pListEntry = RemoveHeadList( &pResource->PossibleOwners );
        pPossibleEntry = CONTAINING_RECORD( pListEntry,
                                            POSSIBLE_ENTRY,
                                            PossibleLinkage );
        OmDereferenceObject( pPossibleEntry->PossibleNode );
        LocalFree( pPossibleEntry );
    }

    //
    // Remove this resource from the Contains list.
    //
    RemoveEntryList( &pResource->ContainsLinkage );

    OmDereferenceObject( pResource );

    //
    // Close the resource's registry key.
    //
    DmRundownList( &pResource->DmRundownList );
    if ( pResource->RegistryKey != NULL ) 
    {
        DmCloseKey( pResource->RegistryKey );
        pResource->RegistryKey = NULL;
    }

    //
    // SS: we do not delete the reference to the resource here
    // since we will shortly have to add one before posting a notification
    // to the fm worker thread.
    //
    // Post a work item to close the resource in the resource handler.
    // Note that this must be done asynchronously as we cannot call
    // the resource monitor from a GUM handler. If we do, resources
    // do funny things and make deadlocks.
    //
    FmpPostWorkItem( FM_EVENT_RESOURCE_DELETED, pResource, 0 );

    //
    // Decrement resource type reference.
    //
    if ( pResource->Type != NULL ) {
        OmDereferenceObject( pResource->Type );
        pResource->Type = NULL;
    }

    //
    // Remove the resource from the resource list.
    //
    dwStatus = OmRemoveObject( pResource );

    ClusterEvent( CLUSTER_EVENT_RESOURCE_DELETED, pResource );
    ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,
                  pResource->Group );

    //
    // Mark the resource as deleted
    //
    pResource->dwStructState = FM_RESOURCE_STRUCT_MARKED_FOR_DELETE;

FnExit:
    OmDereferenceObject( pResource );

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateDeleteResource: Exit for resource %1!ws!, Status=%2!u!...\n",
                lpszResourceId,
                dwStatus);

    return( dwStatus );
} // FmpUpdateDeleteResource

DWORD
FmpUpdateUseRandomizedNodeListForGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId,
    IN PFM_GROUP_NODE_LIST  pGroupNodeList
    )
/*++

Routine Description:

    GUM dispatch routine for using a randomized preferred list for group ownership on
    node down.

Arguments:

    bSourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    pszNodeId - Supplies the ID of the node that is down.

    pGroupNodeList - Randomized preferred node list for groups.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/
{
    PNM_NODE    pNode = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/2001
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return( ERROR_SUCCESS );
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   pszNodeId );

    if ( !pNode )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateUseRandomizedNodeListForGroups: %1!ws! node not found...\n",
                      pszNodeId);
        //
        //  Should we return failure here, is evict of a node synchronized with everything
        //
        goto FnExit;                   
    }

    //
    // If this update has already been seen after the node down, ignore this one
    //
    if ( gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingInProgress == 0 )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpUpdateUseRandomizedNodeListForGroups: %1!ws! node down has been processed already...\n",
                      pszNodeId);
        goto FnExit;                   
    }

    //
    // Assign ownership to all groups owned by the dead node
    //
    dwStatus = FmpAssignOwnersToGroups( pNode, 
                                        NULL,
                                        pGroupNodeList );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateUseRandomizedNodeListForGroups: FmpAssignOwnersToGroups failed %1!d!\n",
                      dwStatus);
    }                   

    //
    // Mark that the node down processing has been done
    //
    gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingInProgress = 0;
    
FnExit:        
    if ( pNode ) OmDereferenceObject( pNode );

    return( dwStatus );
}// FmpUpdateUseRandomizedNodeListForGroups
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fminit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fminit.c

Abstract:

    Initialization for the Failover Manager component of the
    NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996
    Rod Gamache (rodga) 14-Mar-1996


Revision History:

--*/
#include "..\nm\nmp.h"                /* For NmpEnumNodeDefinitions */
#ifdef LOG_CURRENT_MODULE
#undef LOG_CURRENT_MODULE
#endif
#include "fmp.h"


#define LOG_MODULE FMINIT

// The order in which the locks should be acquired is
// 1) gQuoChangeLock
// 2) GroupLock
// 3) gQuoLock
// 4) GumLocks
// 4*) gResTypeLock - this lock is acquired inside gum updates 
// 5) gLockDmpRoot
// 6) pLog->Lock


//A lock for synchronizing online/offline with respect to the quorum
//resource
//This lock is held in exclusive mode when bringing the quorum resource
//online/offline and in shared mode when other resources are brought online
//offline
#if NO_SHARED_LOCKS
    CRITICAL_SECTION    gQuoLock;
#else
    RTL_RESOURCE        gQuoLock;
#endif    

//A lock for synchronizing changes to the resource->quorumresource field   
//and allowing changes to the quorum resource's group in form phase1
// and phase 2 of fm.
#if NO_SHARED_LOCKS
    CRITICAL_SECTION    gQuoChangeLock;
#else
    RTL_RESOURCE        gQuoChangeLock;
#endif    

//A lock for synchronizing changes to the resource type field entries.
//shared by all resource types.
#if NO_SHARED_LOCKS
    CRITICAL_SECTION    gResTypeLock;
#else
    RTL_RESOURCE        gResTypeLock;
#endif    


GUM_DISPATCH_ENTRY FmGumDispatchTable[] = {
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeResourceName},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeGroupName},
    {1, FmpUpdateDeleteResource},
    {1, FmpUpdateDeleteGroup},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateAddDependency},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateRemoveDependency},
    {1, FmpUpdateChangeClusterName},
    {3, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeQuorumResource},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateResourceState},
    {3, (PGUM_DISPATCH_ROUTINE1)FmpUpdateGroupState},
    {4, (PGUM_DISPATCH_ROUTINE1)EpUpdateClusWidePostEvent},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateGroupNode},
    {3, (PGUM_DISPATCH_ROUTINE1)FmpUpdatePossibleNodeForResType},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateGroupIntendedOwner},
    {1, (PGUM_DISPATCH_ROUTINE1)FmpUpdateAssignOwnerToGroups},
    {1, (PGUM_DISPATCH_ROUTINE1)FmpUpdateApproveJoin},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateCompleteGroupMove},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateCheckAndSetGroupOwner},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateUseRandomizedNodeListForGroups}
    };


#define WINDOW_TIMEOUT (15*60*1000)    // Try every 15 minutes

//
// Global data initialized in this module
//

PRESMON FmpDefaultMonitor = NULL;
DWORD FmpInitialized = FALSE;
DWORD FmpFMOnline = FALSE;
DWORD FmpFMGroupsInited = FALSE;
DWORD FmpFMFormPhaseProcessing = FALSE; //this is set to true when form new cluster phase processing starts
BOOL FmpShutdown = FALSE;
BOOL FmpMajorEvent = FALSE;     // Signals a major event while joining
DWORD FmpQuorumOnLine = FALSE;

HANDLE FmpShutdownEvent;
HANDLE FmpTimerThread;

HANDLE  ghQuoOnlineEvent = NULL;    // the event that is signalled when the quorum res is online
DWORD   gdwQuoBlockingResources = 0; // the number of resources in pending stated which prevent the quorum res state change

PFM_NODE    gFmpNodeArray = NULL;

// 185575: remove unique RPC binding handles
//CRITICAL_SECTION FmpBindingLock;

//
// Local functions
//
BOOL
FmpEnumNodes(
    OUT DWORD *pStatus,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    );

DWORD
FmpJoinPendingThread(
    IN LPVOID Context
    );


DWORD FmpGetJoinApproval();

static 
DWORD 
FmpBuildForceQuorumInfo(
    IN LPCWSTR pszNodesIn,
    OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    );

static 
void
FmpDeleteForceQuorumInfo(
    IN OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    );


DWORD
WINAPI
FmInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the failover manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    OM_OBJECT_TYPE_INITIALIZE ObjectTypeInit;
    DWORD NodeId;

    CL_ASSERT(!FmpInitialized);

    if ( FmpInitialized ) {
        return(ERROR_SUCCESS);
    }
    Status = EpRegisterEventHandler(CLUSTER_EVENT_ALL,FmpEventHandler);
    if (Status != ERROR_SUCCESS) {
        CsInconsistencyHalt( Status );
    }

    //register for synchronous node down notifications
    Status = EpRegisterSyncEventHandler(CLUSTER_EVENT_NODE_DOWN_EX,
                                    FmpSyncEventHandler);

    if (Status != ERROR_SUCCESS){
        CsInconsistencyHalt( Status );
    }

    //
    // Initialize Critical Sections.
    //

    InitializeCriticalSection( &FmpResourceLock );
    InitializeCriticalSection( &FmpGroupLock );
    InitializeCriticalSection( &FmpMonitorLock );

// 185575: remove unique RPC binding handles
//    InitializeCriticalSection( &FmpBindingLock );

    // initialize the quorum lock
    // This is used to synchronize online/offlines of other resources
    // with respect to the quorum resource
    INITIALIZE_LOCK(gQuoLock);
    //this is used to check/change the resource->quorum value
    //This synchronization is needed between the resource transition
    //processing that needs to do special processing for quorum 
    //resource and the gum update handler to change the quorum resource
    INITIALIZE_LOCK(gQuoChangeLock);

    //Initialize the restype lock
    INITIALIZE_LOCK(gResTypeLock);
    
    // create a unnamed event that is used for waiting for quorum resource
    // to go online
    // This is a manual reset event and is initialized to unsignalled state.
    // When the quorum resource goes to pending state this is manually reset 
    // to unsignalled state. When the quorum resource goes online it is set 
    // to signalled state
    ghQuoOnlineEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ghQuoOnlineEvent)
    {
        CL_UNEXPECTED_ERROR((Status = GetLastError()));
        return(Status);

    }

    gFmpNodeArray = (PFM_NODE)LocalAlloc(LMEM_FIXED,
                     (sizeof(FM_NODE) * (NmGetMaxNodeId() + 1))
                     );

    if (gFmpNodeArray == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(Status);
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //initialize it and the RPC binding table
    for (NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) 
    {
        FmpRpcBindings[NodeId] = NULL;
        FmpRpcQuorumBindings[NodeId] = NULL;
        gFmpNodeArray[NodeId].dwNodeDownProcessingInProgress = 0;
    }

    //
    // Initialize the FM work queue.
    //
    Status = ClRtlInitializeQueue( &FmpWorkQueue );
    if (Status != ERROR_SUCCESS) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Create a pending event notification.
    //
    FmpShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( FmpShutdownEvent == NULL ) {
        return(GetLastError());
    }

    //
    // Initialize Group Types.
    //
    ObjectTypeInit.Name = FMP_GROUP_NAME;
    ObjectTypeInit.Signature = FMP_GROUP_SIGNATURE;
    ObjectTypeInit.ObjectSize = sizeof(FM_GROUP);
    ObjectTypeInit.DeleteObjectMethod = FmpGroupLastReference;

    Status = OmCreateType( ObjectTypeGroup,
                           &ObjectTypeInit );

    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Initialize Resource Types.
    //
    ObjectTypeInit.Name = FMP_RESOURCE_NAME;
    ObjectTypeInit.Signature = FMP_RESOURCE_SIGNATURE;
    ObjectTypeInit.ObjectSize = sizeof(FM_RESOURCE);
    ObjectTypeInit.DeleteObjectMethod = FmpResourceLastReference;

    Status = OmCreateType( ObjectTypeResource,
                           &ObjectTypeInit );

    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Initialize ResType Types.
    //
    ObjectTypeInit.Name = FMP_RESOURCE_TYPE_NAME;
    ObjectTypeInit.Signature = FMP_RESOURCE_TYPE_SIGNATURE;
    ObjectTypeInit.ObjectSize = sizeof(FM_RESTYPE);
    ObjectTypeInit.DeleteObjectMethod = FmpResTypeLastRef;

    Status = OmCreateType( ObjectTypeResType,
                           &ObjectTypeInit );

    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Initialize the Notify thread.
    //
    Status = FmpInitializeNotify();
    if (Status != ERROR_SUCCESS) {
        CsInconsistencyHalt(Status);
        return(Status);
    }



    //
    // Initialize the FM worker thread.
    //
    Status = FmpStartWorkerThread();
    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    FmpInitialized = TRUE;

    return(ERROR_SUCCESS);

} // FmInitialize



BOOL
FmpEnumGroupsInit(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. This phase completes initialization
    of every group.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{


    //
    // Finish initializing the group.
    //
    FmpCompleteInitGroup( Group );


    return(TRUE);

} // FmpEnumGroupsInit

BOOL
FmpEnumFixupResources(
    IN PCLUSTERVERSIONINFO pClusterVersionInfo,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. This phase completes initialization
    of every group.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;

    FmpAcquireLocalGroupLock( Group );

    //
    // For each resource in the Group, make sure it gets an
    // opportunity to do fixups.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        FmpRmResourceControl( Resource,
                    CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED, 
                    (LPBYTE)pClusterVersionInfo,
                    pClusterVersionInfo->dwVersionInfoSize,
                    NULL,
                    0,
                    NULL,
                    NULL
                    );
                  

    }

    FmpReleaseLocalGroupLock( Group);

    return(TRUE);

} // FmpEnumFixupResources


BOOL
FmpEnumJoinGroupsMove(
    IN LPBOOL Deferred,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. Queries the preferred owners
    groups and moves those that belong on this system and that can move.

Arguments:

    Deferred - TRUE if a move was deferred because of Failback Window. Must
               be FALSE on first call.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PLIST_ENTRY listEntry;
    PPREFERRED_ENTRY preferredEntry;
    SYSTEMTIME  localTime;
    BOOL        failBackWindowOkay = FALSE;
    DWORD       threadId;
    DWORD       status;

    GetLocalTime( &localTime );

    FmpAcquireLocalGroupLock( Group );

    //
    // Adjust ending time if needed.
    //
    if ( Group->FailbackWindowStart > Group->FailbackWindowEnd ) {
        Group->FailbackWindowEnd += 24;
        if ( Group->FailbackWindowStart > localTime.wHour ) {
            localTime.wHour += 24;
        }
    }

    //
    // If the Failback start and end times are valid, then check if we need
    // to start a timer thread to move the group at the appropriate time.
    //
    if ( (Group->FailbackType == GroupFailback) &&
         ((Group->FailbackWindowStart != Group->FailbackWindowEnd) &&
         (localTime.wHour >= Group->FailbackWindowStart) &&
         (localTime.wHour < Group->FailbackWindowEnd)) ||
         (Group->FailbackWindowStart == Group->FailbackWindowEnd) ) {
        failBackWindowOkay = TRUE;
    }

    //
    // Check if we need to move the group.
    //
    if ( !IsListEmpty( &Group->PreferredOwners ) ) {
        listEntry = Group->PreferredOwners.Flink;
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        //
        // Move group if:
        //  0. Remote system is paused, and we're not OR
        //  1. Our system is in the preferred list and the owner node is not OR
        //  2. Group is Offline or Group is Online/PartialOnline and it can
        //     failback AND
        //  3. Group's preferred list is ordered and our system is higher
        //

        if ( Group->OwnerNode == NULL ) {
            // Should we shoot ourselves because we got an incomplete snapshot
            // of the joint attempt.
            CsInconsistencyHalt(ERROR_CLUSTER_JOIN_ABORTED);
        } else if ( Group->OwnerNode != NmLocalNode) {
            if (((NmGetNodeState(NmLocalNode) != ClusterNodePaused) &&
                    (NmGetNodeState(Group->OwnerNode) == ClusterNodePaused)) ||

                (FmpInPreferredList(Group, NmLocalNode, FALSE, NULL) &&
                    !FmpInPreferredList( Group, Group->OwnerNode, FALSE, NULL)) ||

                 ((((Group->State == ClusterGroupOnline) ||
                    (Group->State == ClusterGroupPartialOnline)) &&
                      (Group->FailbackType == FailbackOkay) ||
                      (Group->State == ClusterGroupOffline)) &&
                     ((Group->OrderedOwners) &&
                     (FmpHigherInPreferredList(Group, NmLocalNode, Group->OwnerNode)))) ) {
                if ( failBackWindowOkay ) {
                    PNM_NODE OwnerNode = Group->OwnerNode;
                    
                    status = FmcMoveGroupRequest( Group, NmLocalNode );
                    if ( ( status == ERROR_SUCCESS ) || ( status == ERROR_IO_PENDING ) ) {
                        //
                        //  Chittur Subbaraman (chitturs) - 7/31/2000
                        //
                        //  Log an event indicating an impending failback.
                        //
                        CsLogEvent3( LOG_NOISE,
                                     FM_EVENT_GROUP_FAILBACK,
                                     OmObjectName(Group),
                                     OmObjectName(OwnerNode), 
                                     OmObjectName(NmLocalNode) );
                    }
                    FmpAcquireLocalGroupLock( Group );
                } else {
                    //
                    // Start timer thread if not already running. If it fails,
                    // what possibly can we do?
                    //
                    if ( FmpTimerThread == NULL ) {
                        FmpTimerThread = CreateThread( NULL,
                                                       0,
                                                       FmpJoinPendingThread,
                                                       NULL,
                                                       0,
                                                       &threadId );
                    }
                    *Deferred = TRUE;
                }
            }                
        }
    }

    FmpReleaseLocalGroupLock( Group );

    return(TRUE);

} // FmpEnumJoinGroups



BOOL
FmpEnumSignalGroups(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback to indicate state change on all groups
    and resources.

    For the quorum resource, if we're forming a cluster, we'll also
    fixup information that was not available when the resource was created.

Arguments:

    Context1 - Pointer to a BOOL that is TRUE if this is a FormCluster.
               FALSE otherwise.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PLIST_ENTRY listEntry;
    PFM_RESOURCE resource;
    BOOL    formCluster = *(PBOOL)Context1;
    DWORD   status;
    BOOL    quorumGroup = FALSE;

    //
    // For each resource in the group, generate an event notification.
    //

    for (listEntry = Group->Contains.Flink;
         listEntry != &(Group->Contains);
         listEntry = listEntry->Flink ) {
        resource = CONTAINING_RECORD( listEntry,
                                      FM_RESOURCE,
                                      ContainsLinkage );
        //
        // If this is the quorum resource and we're performing a Form
        // Cluster, then fixup the quorum resource info.
        //
        if ( resource->QuorumResource ) {
            status = FmpFixupResourceInfo( resource );
            quorumGroup = TRUE;
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint( LOG_NOISE,
                            "[FM] Warning, failed to fixup quorum resource %1!ws!, error %2!u!.\n",
                            OmObjectId(resource),
                            status );
            }
        }

        if ( resource->State == ClusterResourceOnline ) {
            ClusterEvent( CLUSTER_EVENT_RESOURCE_ONLINE, resource );
        } else {
            ClusterEvent( CLUSTER_EVENT_RESOURCE_OFFLINE, resource );
        }
    }

    if ( quorumGroup ) {
        status = FmpFixupGroupInfo( Group );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_NOISE,
                        "[FM] Warning, failed to fixup quorum group %1!ws!, error %2!u!.\n",
                        OmObjectId( Group ),
                        status );
        }
    }

    if ( Group->State == ClusterGroupOnline ) {
        ClusterEvent( CLUSTER_EVENT_GROUP_ONLINE, Group );
    } else {
        ClusterEvent( CLUSTER_EVENT_GROUP_OFFLINE, Group );
    }

    return(TRUE);

} // FmpEnumSignalGroups



DWORD
FmpJoinPendingThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Thread to keep trying to move groups, as long we are blocked by a
    FailbackWindow problem. This thread runs every 15 minutes to attempt to
    move Groups.

Arguments:

    Context - Not used.

Return Value:

    ERROR_SUCCESS.

--*/

{
    DWORD   status;
    BOOL    deferred;

    //
    // As long as we have deferred Group moves, keep going.
    do {

        status = WaitForSingleObject( FmpShutdownEvent, WINDOW_TIMEOUT );

        if ( FmpShutdown ) {
            goto finished;
        }

        deferred = FALSE;

        //
        // For each group, see if it should be moved to the local system.
        //
        OmEnumObjects( ObjectTypeGroup,
                       FmpEnumJoinGroupsMove,
                       &deferred,
                       NULL );

    } while ( (status != WAIT_FAILED) && deferred );

finished:

    CloseHandle( FmpTimerThread );
    FmpTimerThread = NULL;

    return(ERROR_SUCCESS);

} // FmpJoinPendingThread



DWORD
WINAPI
FmGetQuorumResource(
    OUT PFM_GROUP   *ppQuoGroup,
    OUT LPDWORD     lpdwSignature  OPTIONAL
    )

/*++

Routine Description:

    Find the quorum resource, arbitrate it and return a name that can be
    used to open the device in order to perform reads. Optionally,
    return the signature of the quorum disk.

    There are 3 items that we need:

        1. The name of the quorum resource.
        2. The name of the Group that the quorum resource is a member of.
        3. The resource type for the quorum resource.

Arguments:

    ppQuoGroup - Supplies a pointer to a buffer into which the 
        quorum group info is returned.

    lpdwSignature - An optional argument which is used to return
        the signature of the quorum disk from the cluster hive.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    LPWSTR  quorumId = NULL;
    LPWSTR  groupId = NULL;
    LPCWSTR stringId;
    LPWSTR  containsString = NULL;
    PFM_GROUP group = NULL;
    PFM_RESOURCE resource = NULL;
    HDMKEY  hGroupKey;
    DWORD   groupIdSize = 0;
    DWORD   idMaxSize = 0;
    DWORD   idSize = 0;
    DWORD   status;
    DWORD   keyIndex;
    DWORD   stringIndex;
    PCLUS_FORCE_QUORUM_INFO pForceQuorumInfo = NULL;

    *ppQuoGroup = NULL;

    //
    // Get the quorum resource value.
    //
    status = DmQuerySz( DmQuorumKey,
                        CLUSREG_NAME_QUORUM_RESOURCE,
                        (LPWSTR*)&quorumId,
                        &idMaxSize,
                        &idSize );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Failed to get quorum resource, error %1!u!.\n",
                   status);
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    //  If the user is forcing a database restore operation, you
    //  also need to verify whether the quorum disk signature in
    //  the registry matches that in the disk itself. So, go get 
    //  the signature from the Cluster\Resources\quorumId\Parameters
    //  key
    //
    if ( lpdwSignature != NULL ) {
        status = FmpGetQuorumDiskSignature( quorumId, lpdwSignature );
        if ( status != ERROR_SUCCESS ) {
            //
            //  This is not a fatal error. So log an error and go on.
            //
            ClRtlLogPrint(LOG_ERROR,
                "[FM] Failed to get quorum disk signature, error %1!u!.\n",
                   status);
        }
    }

    //
    // Initialize the default Resource Monitor
    //
    if ( FmpDefaultMonitor == NULL ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
    }

    if (FmpDefaultMonitor == NULL) {
        status = GetLastError();
        CsInconsistencyHalt(status);
        goto FnExit;
    }

    //
    // Now find the group that the quorum resource is a member of.
    //
    idMaxSize = 0;
    idSize = 0;
    for ( keyIndex = 0;  ; keyIndex++ )
    {
        status = FmpRegEnumerateKey( DmGroupsKey,
                                     keyIndex,
                                     &groupId,
                                     &groupIdSize );
        if ( status == ERROR_NO_MORE_ITEMS )
        {
            break;
        }
        if (status != ERROR_SUCCESS)
        {

            continue;
        }
        //open the group key
        hGroupKey = DmOpenKey( DmGroupsKey,
                              groupId,
                              KEY_READ );
        if (!hGroupKey)
            continue;
        //
        // Get the contains string.
        //
        status = DmQueryMultiSz( hGroupKey,
                                 CLUSREG_NAME_GRP_CONTAINS,
                                 &containsString,
                                 &idMaxSize,
                                 &idSize );
        DmCloseKey(hGroupKey);

        if ( status != ERROR_SUCCESS )
            continue;
        for ( stringIndex = 0;  ; stringIndex++ )
        {
            stringId = ClRtlMultiSzEnum( containsString,
                                         idSize/sizeof(WCHAR),
                                         stringIndex );
            if ( stringId == NULL ) {
                break;
            }
            if ( lstrcmpiW( stringId, quorumId ) == 0 )
            {
                // We will now create the group, which will also
                // create the resource, and the resource type.
                //
                // TODO - this will also create all resources
                // within the group. What should we do about that?
                // We could require the quorum resource to be in
                // a group by itself! (rodga) 17-June-1996.
                //
                group = FmpCreateGroup( groupId,
                                        FALSE );
                if (CsNoQuorum)
                    FmpSetGroupPersistentState(group, ClusterGroupOffline);
                                        
                break;
            }
        }
        //if we found the group, thre is no need to search for more
        if (group != NULL)
            break;
    }

    //
    // Check if we found the Quorum resource's group.
    //
    if ( group == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Did not find group for quorum resource.\n");
        status = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    //
    // Get the quorum resource structure.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, quorumId );
    if ( resource == NULL )
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Failed to find quorum resource object.\n");
        status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    resource->QuorumResource = TRUE;

    if (!CsNoQuorum)
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Arbitrate for quorum resource id %1!ws!.\n",
                   OmObjectId(resource));

        //
        // First finish initializing the quorum resource.
        //
        if ( resource->Monitor == NULL )
        {
            status = FmpInitializeResource( resource, TRUE );
            if ( status != ERROR_SUCCESS )
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Error completing initialization of quorum resource '%1!ws!, error %2!u!.\n",
                           OmObjectId(resource),
                           status );
                goto FnExit;
            }
        }

        //
        // If we have a force quorum of nodes then drop a control code to the
        // resource with the list of nodes.  This must be done before
        // arbitrate.  First we build force quorum info - this makes sure that the node list is valid etc.
        // Note that the list can be NULL.
        //
        if ( CsForceQuorum ) {
            ClRtlLogPrint(LOG_NOISE,
                          "[FM] force quorum specified, sending CLUSCTL_RESOURCE_FORCE_QUORUM == 0x%1!08lx!\n",
                          CLUSCTL_RESOURCE_FORCE_QUORUM );

            status = FmpBuildForceQuorumInfo( CsForceQuorumNodes,
                                              &pForceQuorumInfo );
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[FM] Error building force quorum info for resource '%1!ws!, error %2!u!.\n",
                              OmObjectId(resource),
                              status );
                goto FnExit;
            }

            status = FmpRmResourceControl( resource,
                                           CLUSCTL_RESOURCE_FORCE_QUORUM,
                                           (LPBYTE)pForceQuorumInfo,
                                           pForceQuorumInfo->dwSize,
                                           NULL,
                                           0,
                                           NULL,
                                           NULL );
            //
            // Tolerate ERROR_INVALID_FUNCTION since this just means that the
            // resource doesn't handle it.
            //
            if ( status == ERROR_INVALID_FUNCTION )
                status = ERROR_SUCCESS;
            
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_ERROR,
                              "[FM] Resource control for Force Quorum for resource '%1!ws! encountered error %2!u!.\n",
                              OmObjectId(resource),
                              status );
                goto FnExit;
            }
        }

        //
        // Now arbitrate for the resource.
        //
        status = FmpRmArbitrateResource( resource );

    }

FnExit:
    if ( status == ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmGetQuorumResource successful\r\n");
        *ppQuoGroup = group;
    }
    else
    {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] FmGetQuorumResource failed, error %1!u!.\n",
                   status);
        //the group will be cleaned by fmshutdown()

    }
    if (pForceQuorumInfo) FmpDeleteForceQuorumInfo( &pForceQuorumInfo );
    if (resource) OmDereferenceObject(resource);
    if (quorumId) LocalFree(quorumId);
    if (groupId) LocalFree(groupId);
    //
    //  Chittur Subbaraman (chitturs) - 10/05/98
    //  Fix memory leak
    //
    if (containsString) LocalFree(containsString);
    return(status);
} // FmGetQuorumResource




DWORD
WINAPI
FmFindQuorumResource(
    OUT PFM_RESOURCE *ppResource
    )
/*++

Routine Description:

    Finds the quorum resource and returns a pointer to the resource
    object.

Arguments:

    *ppResource - A pointer to the Quorum resource object is returned in this.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD dwError = ERROR_SUCCESS;

    //enumerate all the resources
    *ppResource = NULL;

    OmEnumObjects( ObjectTypeResource,
                   FmpFindQuorumResource,
                   ppResource,
                   NULL );

    if ( *ppResource == NULL )
    {
        dwError = ERROR_RESOURCE_NOT_FOUND;
        CL_LOGCLUSERROR(FM_QUORUM_RESOURCE_NOT_FOUND);
    }

    return(dwError);
}


DWORD WINAPI FmFindQuorumOwnerNodeId(IN PFM_RESOURCE pResource)
{
    DWORD dwNodeId;

    CL_ASSERT(pResource->Group->OwnerNode != NULL);
    dwNodeId = NmGetNodeId(pResource->Group->OwnerNode);

    return (dwNodeId);
}



BOOL
FmpReturnResourceType(
    IN OUT PFM_RESTYPE *FoundResourceType,
    IN LPCWSTR ResourceTypeName,
    IN PFM_RESTYPE ResourceType,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. Queries the preferred owners
    groups and moves those that belong on this system and that can move.

Arguments:

    ResourceType - Returns the found ResourceType, if found.

    Context2 - The input resource type name to find.

    Resource - Supplies the current ResourceType.

    Name - Supplies the ResourceType's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{

    if ( lstrcmpiW( Name, ResourceTypeName ) == 0 ) {
        OmReferenceObject( ResourceType );
        *FoundResourceType = ResourceType;
        return(FALSE);
    }

    return(TRUE);

} // FmpReturnResourceType


DWORD
WINAPI
FmFormNewClusterPhase1(
    IN PFM_GROUP pQuoGroup
    )

/*++

Routine Description:

    Destroys the quorum group that was created.  The quorum resource is left
    behind and its group adjusted according to the new logs.

Arguments:

    None.

Returns:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD           status;


    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmFormNewClusterPhase1, Entry.  Quorum quorum will be deleted\r\n");

    //
    // Enable the GUM.
    //
    GumReceiveUpdates(FALSE,
                      GumUpdateFailoverManager,
                      FmpGumReceiveUpdates,
                      NULL,
                      sizeof(FmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      FmGumDispatchTable,
                      FmpGumVoteHandler);

    //Acquire the exclusive lock for the quorum
    // This is done so that we can ignore any resource transition events from
    // the quorum resource between phase 1 and phase 2 of FM initialization on Form
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);

    FmpFMFormPhaseProcessing = TRUE;

    //release the quorum lock
    RELEASE_LOCK(gQuoChangeLock);

    //the group lock will be freed by FmpDestroyGroup
    FmpAcquireLocalGroupLock( pQuoGroup );

    //destroy the quorum group object, dont bring the quorum resource online/offline
    //All resources in the quorum group must get deleted, except the quorum resource
    //All resources in the quorum group must get recreated in FmFormNewClusterPhase2.
    //The quorum group is removed from the group list, hence it will be recreated in phase2.
    //Since the quorum resource must not get deleted we will increment its ref count
    //This is because in phase 2 it is not created and its ref count is not incremented at create
    //By the time it is put on the contains list, we expect the resource count to be 2.
    OmReferenceObject(gpQuoResource);
    status = FmpDestroyGroup(pQuoGroup, TRUE);

    //We prefer that the quorum group is deleted
    //since after rollback the old group may no longer exist and we
    //dont want it to be on the group list
    gpQuoResource->Group = NULL;
    OmDereferenceObject(pQuoGroup);
    
    return(status);

} // FmFormNewClusterPhase1



DWORD
WINAPI
FmFormNewClusterPhase2(
    VOID
    )

/*++

Routine Description:

    Bring the Failover Manager Online, this means claiming all groups and
    finishing the initialization of resources.

Arguments:

    None.

Returns:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD           status;
    BOOL            formCluster = TRUE;
    PFM_GROUP       group;
    PFM_RESOURCE    pQuoResource=NULL;
    CLUSTERVERSIONINFO ClusterVersionInfo;
    PCLUSTERVERSIONINFO pClusterVersionInfo = NULL;
    PGROUP_ENUM     MyGroups = NULL;
    BOOL            QuorumGroup;



    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmFormNewClusterPhase2, Entry.\r\n");


    //
    // Initialize resource types
    //
    status = FmpInitResourceTypes();
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        goto error_exit;
    }

    //
    // Initialize Groups, 
    //
    status = FmpInitGroups( FALSE );
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    // refigure out the state for the quorum group
    status = FmFindQuorumResource(&pQuoResource);
    if (status != ERROR_SUCCESS)
    {
        goto error_exit;
    }
    //
    // Set the state of the quorum group depending upon the state of 
    // the quorum resource
    //
    //now we should enable resource events to come in for the quorum resource as well
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);
    FmpFMFormPhaseProcessing = FALSE;

    group = pQuoResource->Group;
    group->State = FmpGetGroupState(group, TRUE);
    OmDereferenceObject(pQuoResource);

    //if the noquorum flag is set, dont bring the quorum group online 
    if (CsNoQuorum)
        FmpSetGroupPersistentState(pQuoResource->Group, ClusterGroupOffline);

    RELEASE_LOCK(gQuoChangeLock);

    //
    // Initialize the default Resource Monitor
    //
    if ( FmpDefaultMonitor == NULL ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
    }

    if (FmpDefaultMonitor == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Failed to create default resource monitor on Form.\n");
        goto error_exit;
    }

    
    if (NmLocalNodeVersionChanged)
    {
        //initialize the version information
        CsGetClusterVersionInfo(&ClusterVersionInfo);
        pClusterVersionInfo = &ClusterVersionInfo;
    }


    //enable votes and gum updates since the fixups for
    //resource types require that
    FmpFMGroupsInited = TRUE;

    //
    // The resource type possible node list is built
    // using a voting protocol, hence we need to
    // fix it up since the vote could have been conducted
    // while this node was down.
    // Also call the resource type control code if the
    // local node version has changed
    //
    status = FmpFixupResourceTypesPhase1(FALSE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        goto error_exit;
    }


    //
    // Find and sort all known groups
    //
    status = FmpEnumSortGroups(&MyGroups, NULL, &QuorumGroup);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }


    //
    // Find the state of the Groups.
    //
    FmpGetGroupListState( MyGroups );

    //
    // Set the Group owner.
    //
    FmpSetGroupEnumOwner( MyGroups, NmLocalNode, NULL, QuorumGroup, NULL );


    //
    // For each group, finish initialization of all groups and resources.
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumGroupsInit,
                   NULL,
                   NULL );

    // if the resource type is not supported, remove it from the possible 
    // owners list of all resources of that type
    status = FmpFixupPossibleNodesForResources(FALSE);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    if (NmLocalNodeVersionChanged)
    {

        //
        // For each group, allow all resources to do any fixups
        // they might need to do to the cluster registry to
        // run in a mixed mode cluster.
        //
        // Get the version info
        OmEnumObjects( ObjectTypeGroup,
                       FmpEnumFixupResources,
                       &ClusterVersionInfo,
                       NULL );

    }
    

    
    //
    // Take ownership of all the groups in the system. This also completes
    // the initialization of all resources.
    //
    status = FmpClaimAllGroups(MyGroups);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,"[FM] FmpClaimAllGroups failed %1!d!\n",status);
        goto error_exit;
    }

    //
    // Cleanup
    //
    FmpDeleteEnum(MyGroups);

    FmpFMOnline = TRUE;

    //
    // Signal a state change for every group and resource!
    //
    OmEnumObjects( ObjectTypeGroup,
                  FmpEnumSignalGroups,
                  &formCluster,
                  NULL );

    //
    //  Chittur Subbaraman (chitturs) - 5/3/2000
    //
    //  Make sure the phase 2 notifications are delivered only after all initialization is
    //  complete. This includes fixing up the possible owners of the quorum resource by
    //  FmpEnumSignalGroups. Once phase 2 notifications are delivered, resource type DLLs
    //  would be free to issue cluster API calls into FM and the lack of possible owners should
    //  not be the reason to reject these calls.
    //
    status = FmpFixupResourceTypesPhase2(FALSE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);

    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt( status );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,"[FM] FmFormNewClusterPhase2 complete.\n");
    return(ERROR_SUCCESS);


error_exit:

    if (MyGroups) FmpDeleteEnum(MyGroups);
    
    FmpShutdown = TRUE;
    FmpFMOnline = FALSE;

    FmpCleanupGroups(FALSE);
    if (FmpDefaultMonitor != NULL) {
        FmpShutdownMonitor( FmpDefaultMonitor );
        FmpDefaultMonitor = NULL;
    }

    FmpShutdown = FALSE;

    return(status);



} // FmFormNewClusterPhase2



DWORD
WINAPI
FmJoinPhase1(
    VOID
    )
/*++

Routine Description:

    Performs the FM initialization and join procedure. This creates skeletal
    groups and resources, which are not fully initialized. After the API is
    fully enabled (in Phase 2) we will finish initialization of the groups
    and resources (which causes the resource monitors to run and opens
    the resource DLL's.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD   status;
    DWORD   sequence;

    //
    // Enable Gum updates.
    //
    GumReceiveUpdates(TRUE,
                      GumUpdateFailoverManager,
                      FmpGumReceiveUpdates,
                      NULL,
                      sizeof(FmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      FmGumDispatchTable,
                      FmpGumVoteHandler);

retry:
    status = GumBeginJoinUpdate(GumUpdateFailoverManager, &sequence);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] GumBeginJoinUpdate failed %1!d!\n",
                   status);
        return(status);
    }

    //
    // Build up all the FM data structures for resource types.
    //
    //
    // Initialize resource types
    //
    status = FmpInitResourceTypes();
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    //
    // Initialize Groups, but don't fully initialize them yet.
    //
    status = FmpInitGroups( FALSE );
    if (status != ERROR_SUCCESS) {
        return(status);
    }

    //
    // Initialize the default Resource Monitor. This step must be done before end join update
    // since this node can receive certain updates such as s_GumCollectVoteFromNode immediately
    // after GumEndJoinUpdate which may need the services of the default monitor.
    //
    if ( FmpDefaultMonitor == NULL ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
    }
    if ( FmpDefaultMonitor == NULL ) {
        status = GetLastError();
        CsInconsistencyHalt(status);
        return(status);
    }

    //
    // Get the group and resource state from each node which is online.
    //
    status = ERROR_SUCCESS;
    OmEnumObjects( ObjectTypeNode,
                   FmpEnumNodes,
                   &status,
                   NULL );
    if (status == ERROR_SUCCESS) {
        FmpFMGroupsInited = TRUE;
        // Gum Update handlers for resource and group state changes
        // can process the updates now.
        status = GumEndJoinUpdate(sequence,
                                  GumUpdateFailoverManager,
                                  FmUpdateJoin,
                                  0,
                                  NULL);
        if (status == ERROR_CLUSTER_DATABASE_SEQMISMATCH) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] GumEndJoinUpdate with sequence %1!d! failed with a sequence mismatch\n",
                       sequence);
        } else if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] GumEndJoinUpdate with sequence %1!d! failed with status %2!d!\n",
                       sequence,
                       status);
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmJoin: FmpEnumNodes failed %1!d!\n",
                   status);
        return(status); // we will loop forever without this
    }

    if (status != ERROR_SUCCESS) {
        //
        // clean up resources
        //
        FmpShutdown = TRUE;
        FmpCleanupGroups(FALSE);
        FmpShutdown = FALSE;

        //
        // Better luck next time!
        //
        goto retry;
    }   
    
    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase1 complete.\n");

    return(ERROR_SUCCESS);

} // FmJoinPhase1


DWORD
WINAPI
FmJoinPhase2(
    VOID
    )
/*++

Routine Description:

    Performs the second phase of FM initialization and join procedure.
    Finish creation of resources by allowing the resource monitors to be
    created. Claim any groups which should failback to this node.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD   status;
    CLUSTERVERSIONINFO ClusterVersionInfo;
    PCLUSTERVERSIONINFO pClusterVersionInfo = NULL;
    DWORD   dwRetryCount=60;//try for atleast a minute


GetJoinApproval:
    status = FmpGetJoinApproval();

    if (status == ERROR_RETRY)
    {
        // if the other nodes have pending work to do 
        //after this node last died and are not willing
        // to accept it back till that is over, we will stall
        // the join
        //sleep for a second
        dwRetryCount--;
        if (dwRetryCount)
        {
            Sleep(1000);
            goto GetJoinApproval;
        }
        else
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmJoinPhase2 : timed out trying to get join approval.\n");
            CsInconsistencyHalt(status);                
        }
    }

    
    if (NmLocalNodeVersionChanged)
    {
        //initialize the cluster versioninfo structure
        CsGetClusterVersionInfo(&ClusterVersionInfo);
        pClusterVersionInfo = &ClusterVersionInfo;
    }
    //
    // The resource type possible node list is built
    // using a voting protocol, hence we need to
    // fix it up since the vote could have been conducted
    // while this node was down.
    //
    status = FmpFixupResourceTypesPhase1(TRUE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    
    //
    // For each group, finish initialization of all groups and resources.
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumGroupsInit,
                   NULL,
                   NULL );


    // if the resource type is not supported, remove it from the possible 
    // owners list of all resources of that type
    status = FmpFixupPossibleNodesForResources(TRUE);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    if (NmLocalNodeVersionChanged)
    {
        //
        // For each group, allow all resources to do any fixups
        // they might need to do to the cluster registry to
        // run in a mixed mode cluster.
        //
        OmEnumObjects( ObjectTypeGroup,
                       FmpEnumFixupResources,
                       &ClusterVersionInfo,
                       NULL );
    }
    //
    // The FM is now in sync with everybody else.
    //
    FmpFMOnline = TRUE;

    if ( FmpMajorEvent ) {
        return(ERROR_NOT_READY);
    }

    
    status = FmpFixupResourceTypesPhase2(TRUE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);

    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase2 complete, now online!\n");

    return(ERROR_SUCCESS);

} // FmJoinPhase2

VOID
FmJoinPhase3(
    VOID
    )
/*++

Routine Description:

    Handles any group moves and resource/group state change signaling as
    a part of join. This MUST be done only AFTER the extended node state
    is UP.
    
Arguments:

    None.

Return Value:

    None.
--*/
{
    BOOL    formCluster = FALSE;
    DWORD   deferred = FALSE;

    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase3 entry...\n");

    //
    // Chittur Subbaraman (chitturs) - 10/28/99
    //
    //
    // For each group, see if it should be moved to the local system.
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumJoinGroupsMove,
                   &deferred,
                   NULL );

    //
    // Signal a state change for every group and resource!
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumSignalGroups,
                   &formCluster,
                   NULL );

    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase3 exit...\n");
} // FmJoinPhase3

BOOL
FmpFindQuorumResource(
    IN OUT PFM_RESOURCE *QuorumResource,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM findquorumresource.

Arguments:

    QuorumResource - Returns the found quorum resource, if found.

    Context2 - Not used.

    Resource - Supplies the current resource.

    Name - Supplies the Resource's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{

    if ( Resource->QuorumResource ) {
        OmReferenceObject( Resource );
        *QuorumResource = Resource;
        return(FALSE);
    }

    return(TRUE);

} // FmpFindQuorumResource



BOOL
FmArbitrateQuorumResource(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

    TRUE - if the quorum resource was successfully arbitrated and acquired.

    FALSE - it the quorum resource was not successfully arbitrated.

--*/

{
    PFM_RESOURCE resource = NULL;
    DWORD       status;
    WCHAR       localComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD       localComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // Next try to find the Quorum resource.
    //

    FmFindQuorumResource(&resource);

    if ( resource == NULL ) {
        SetLastError(ERROR_RESOURCE_NOT_FOUND);
        return(FALSE);
    }

    //
    // Now arbitrate for the resource.
    //
    status = FmpRmArbitrateResource( resource );

    if ( status == ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Successfully arbitrated quorum resource %1!ws!.\n",
                   OmObjectId(resource));
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FMArbitrateQuoRes: Current State %1!u! State=%2!u! Owner %3!u!\r\n",
                           resource->PersistentState,
                           resource->State,
                           NmGetNodeId((resource->Group)->OwnerNode));
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FMArbitrateQuoRes: Group state :Current State %1!u! State=%2!u! Owner %3!u!\r\n",
                           resource->Group->PersistentState,
                           resource->Group->State,
                           NmGetNodeId((resource->Group)->OwnerNode));
        //
        // The quorum resource will be brought online by REGROUP.
        //
        // RNG: what happens if we can't online the quorum resource?
        // A: The node will halt.

        //SS: dereference the object referenced by fmfindquorumresource
        OmDereferenceObject(resource);

        return(TRUE);
    } else {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Failed to arbitrate quorum resource %1!ws!, error %2!u!.\n",
                   OmObjectId(resource),
                   status);
        //SS: dereference the object referenced by fmfindquorumresource
        OmDereferenceObject(resource);
        return(FALSE);
    }

} // FmArbitrateQuorumResource



BOOL
FmpEnumHoldIO(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Send a HOLD_IO control code to all resource types of class STORAGE.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    ResType - Supplies the Resource Type.

    Name - Supplies the Resource Type's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/
{
    DWORD   dwStatus;
    DWORD   bytesReturned;
    DWORD   bytesRequired;

    if ( ResType->Class == CLUS_RESCLASS_STORAGE ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Hold IO for storage resource type: %1!ws!\n",
                   Name );

        // Hold IO for this resource type
        dwStatus = FmpRmResourceTypeControl(
                        Name,
                        CLUSCTL_RESOURCE_TYPE_HOLD_IO,
                        NULL,
                        0,
                        NULL,
                        0,
                        &bytesReturned,
                        &bytesRequired );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resource DLL Hold IO returned status %1!u!\n",
                   dwStatus );
    }

    return(TRUE);

} // FmpEnumHoldIO



VOID
FmHoldIO(
    VOID
    )
/*++

Routine Description:

    This routine holds all I/O for all storage class resource types.
    It does this by calling the resource dll with a 
    CLUSCTL_RESOURCE_TYPE_HOLD_IO resource type control code.

Inputs:

    None

Outputs:

    None

--*/
{
    OmEnumObjects( ObjectTypeResType,
                  FmpEnumHoldIO,
                  NULL,
                  NULL );
    return;

} // FmHoldIO



BOOL
FmpEnumResumeIO(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Send a RESUME_IO control code to all resource types of class STORAGE.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    ResType - Supplies the Resource Type.

    Name - Supplies the Resource Type's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/
{
    DWORD   dwStatus;
    DWORD   bytesReturned;
    DWORD   bytesRequired;

    if ( ResType->Class == CLUS_RESCLASS_STORAGE ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resume IO for storage Resource Type %1!ws!\n",
                   Name );

        // Resume IO for this resource type
        dwStatus = FmpRmResourceTypeControl(
                        Name,
                        CLUSCTL_RESOURCE_TYPE_RESUME_IO,
                        NULL,
                        0,
                        NULL,
                        0,
                        &bytesReturned,
                        &bytesRequired );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resource DLL Resume IO returned status %1!u!\n",
                   dwStatus );
    }

    return(TRUE);

} // FmpEnumResumeIO



VOID
FmResumeIO(
    VOID
    )
/*++

Routine Description:

    This routine resumes all I/O for all storage class resource types.
    It does this by calling the resource dll with a
    CLUSCTL_RESOURCE_TYPE_RESUME_IO resource type control code.

Inputs:

    None

Outputs:

    None

--*/
{

    OmEnumObjects( ObjectTypeResType,
                  FmpEnumResumeIO,
                  NULL,
                  NULL );
    return;

} // FmResumeIO



BOOL
FmpEnumNodes(
    OUT DWORD *pStatus,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback for FM join. Queries the state
    of owned groups and resources for each online node.

Arguments:

    pStatus - Returns any error that may occur.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    DWORD Status;
    DWORD NodeId;
    PGROUP_ENUM NodeGroups = NULL;
    PRESOURCE_ENUM NodeResources = NULL;
    DWORD i;
    PFM_GROUP Group;
    PFM_RESOURCE Resource;

    if (Node == NmLocalNode) {
        CL_ASSERT(NmGetNodeState(Node) != ClusterNodeUp);
        return(TRUE);
    }

    //
    // Enumerate all other node's group states. This includes all nodes
    // that are up, as well as nodes that are paused.
    //
    if ((NmGetNodeState(Node) == ClusterNodeUp) ||
        (NmGetNodeState(Node) == ClusterNodePaused)){
        NodeId = NmGetNodeId(Node);
        CL_ASSERT(Session[NodeId] != NULL);

        Status = FmsQueryOwnedGroups(Session[NodeId],
                                     &NodeGroups,
                                     &NodeResources);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] FmsQueryOwnedGroups to node %1!ws! failed %2!d!\n",
                       OmObjectId(Node),
                       Status);
            *pStatus = Status;
            return(FALSE);
        }

        //
        // Enumerate the groups and set their owner and state.
        //
        for (i=0; i < NodeGroups->EntryCount; i++) {
            Group = OmReferenceObjectById(ObjectTypeGroup,
                                          NodeGroups->Entry[i].Id);
            if (Group == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] FmpEnumNodes: group %1!ws! not found\n",
                           NodeGroups->Entry[i].Id);
            } else {
                if ( FmpInPreferredList( Group, Node, FALSE, NULL ) ) {
                    ClRtlLogPrint(LOG_NOISE,
                               "[FM] Setting group %1!ws! owner to node %2!ws!, state %3!d!\n",
                               OmObjectId(Group),
                               OmObjectId(Node),
                               NodeGroups->Entry[i].State);
                } else {
                    ClRtlLogPrint(LOG_NOISE,
                               "[FM] Init, Node %1!ws! is not in group %2!ws!.\n",
                               OmObjectId(Node),
                               OmObjectId(Group));
                }
                OmReferenceObject( Node );
                Group->OwnerNode = Node;
                Group->State = NodeGroups->Entry[i].State;
                Group->StateSequence = NodeGroups->Entry[i].StateSequence;
                OmDereferenceObject(Group);
            }

            MIDL_user_free(NodeGroups->Entry[i].Id);
        }
        MIDL_user_free(NodeGroups);

        //
        // Enumerate the resources and set their current state.
        //
        for (i=0; i < NodeResources->EntryCount; i++) {
            Resource = OmReferenceObjectById(ObjectTypeResource,
                                             NodeResources->Entry[i].Id);
            if (Resource == NULL) {

                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] FmpEnumNodes: resource %1!ws! not found\n",
                           NodeResources->Entry[i].Id);
            } else {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Setting resource %1!ws! state to %2!d!\n",
                           OmObjectId(Resource),
                           NodeResources->Entry[i].State);
                Resource->State = NodeResources->Entry[i].State;
                Resource->StateSequence = NodeResources->Entry[i].StateSequence;
                OmDereferenceObject(Resource);
            }
            MIDL_user_free(NodeResources->Entry[i].Id);
        }
        MIDL_user_free(NodeResources);

    }

    return(TRUE);

} // FmpEnumNodes



VOID
WINAPI
FmShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the Failover Manager

Arguments:

    None

Return Value:

    None.

--*/

{
    DWORD   i;

    if ( !FmpInitialized ) {
        return;
    }

    FmpInitialized = FALSE;

    ClRtlLogPrint(LOG_UNUSUAL,
               "[FM] Shutdown: Failover Manager requested to shutdown.\n");

    //
    // For now, we really can't delete these critical sections. There is a
    // race condition where the FM is shutting down and someone is walking
    // the lists. Keep this critical sections around... just in case.
    //
    //DeleteCriticalSection( &FmpResourceLock );
    //DeleteCriticalSection( &FmpGroupLock );
    //DeleteCriticalSection( &FmpMonitorLock );

    if ( FmpDefaultMonitor != NULL ) {
        FmpShutdownMonitor(FmpDefaultMonitor);
        FmpDefaultMonitor = NULL;
    }

    CloseHandle( FmpShutdownEvent );

#if 0 // RNG - don't run the risk of other threads using these handles
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        if ( FmpRpcBindings[i] != NULL ) {
            ClMsgDeleteRpcBinding( FmpRpcBindings[i] );
            FmpRpcBindings[i] = NULL;
        }
        if ( FmpRpcQuorumBindings[i] != NULL ) {
            ClMsgDeleteRpcBinding( FmpRpcQuorumBindings[i] );
            FmpRpcQuorumBindings[i] = NULL;
        }
    }
#endif
    
    ClRtlDeleteQueue( &FmpWorkQueue );

    return;

} // FmShutdown


VOID
WINAPI
FmShutdownGroups(
    VOID
    )

/*++

Routine Description:

    Moves or takes offline all groups owned by this node.

Arguments:

    None

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_UNUSUAL,
               "[FM] Shutdown: Failover Manager requested to shutdown groups.\n");

    //if we didnt initialize, we dont have to do anything
    if (!FmpInitialized)
        return;
    //
    // Use the Group Lock to synchronize the shutdown
    //
    FmpAcquireGroupLock();

    //if shutdown is already in progress, return
    if ( FmpShutdown) {
        FmpReleaseGroupLock();
        return;
    }


    FmpShutdown = TRUE;
    FmpFMOnline = FALSE;

    FmpReleaseGroupLock();

    //
    // Now cleanup all Groups/Resources.
    // 
    FmpCleanupGroups(TRUE);


    return;

} // FmShutdownGroups



/****
@func           DWORD | FmBringQuorumOnline| This routine finds the quorum resource and
                        brings it online.

@comm           This is called by the FmFormClusterPhase 1.
@xref
****/
DWORD FmBringQuorumOnline()
{
    PFM_RESOURCE pQuoResource;
    DWORD        dwError=ERROR_SUCCESS;

    //
    // Synchronize with shutdown.
    //
    FmpAcquireGroupLock();
    if ( FmpShutdown ) {
        FmpReleaseGroupLock();
        return(ERROR_SUCCESS);
    }

    if ((dwError = FmFindQuorumResource(&pQuoResource)) != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[Fm] FmpBringQuorumOnline : failed to find resource 0x%1!08lx!\r\n",
                        dwError);
        goto FnExit;
    }

    //mark yourself as owner
    if ( pQuoResource->Group->OwnerNode != NULL ) 
    {
        OmDereferenceObject( pQuoResource->Group->OwnerNode );
    }

    OmReferenceObject( NmLocalNode );
    pQuoResource->Group->OwnerNode = NmLocalNode;

    //prepare the group for onlining it
    FmpPrepareGroupForOnline(pQuoResource->Group);
    dwError = FmpOnlineResource(pQuoResource, TRUE);
    //SS:decrement the ref count on the quorum resource object
    //provided by fmfindquorumresource
    OmDereferenceObject(pQuoResource);

FnExit:
    FmpReleaseGroupLock();
    return(dwError);

}

/****
@func       DWORD | FmpGetQuorumDiskSignature | Get the signature of
            the quorum disk from the cluster hive.

@parm       IN LPWSTR | lpQuorumId | Identifier of the quorum resource.

@parm       OUT LPDWORD | lpdwSignature | Quorum disk signature.
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       This function attempts to open the Resources\lpQuorumId\Parameters
            key under the cluster hive and read the quorum disk signature.

@xref       <f FmGetQuorumResource> 
****/
DWORD 
FmpGetQuorumDiskSignature(
    IN  LPCWSTR lpQuorumId,
    OUT LPDWORD lpdwSignature
    )
{
    HDMKEY  hQuorumResKey = NULL;
    HDMKEY  hQuorumResParametersKey = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    hQuorumResKey = DmOpenKey( DmResourcesKey,
                               lpQuorumId,
                               KEY_READ );
    if ( hQuorumResKey != NULL ) 
    {
        //
        //  Open up the Parameters key
        //
        hQuorumResParametersKey = DmOpenKey( hQuorumResKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             KEY_READ );
        DmCloseKey( hQuorumResKey );
        if ( hQuorumResParametersKey != NULL ) 
        {
            //
            //  Read the disk signature value
            //
            dwStatus = DmQueryDword( hQuorumResParametersKey,
                                   CLUSREG_NAME_PHYSDISK_SIGNATURE,
                                   lpdwSignature,
                                   NULL );
            DmCloseKey( hQuorumResParametersKey );
        } else
        {
            dwStatus = GetLastError();
        }
    } else
    {
        dwStatus = GetLastError();
    }

    //
    //  If you failed, then reset the signature to 0 so that the
    //  caller won't take any actions based on an invalid signature.
    //
    if ( dwStatus != ERROR_SUCCESS )
    {
        *lpdwSignature = 0;
    }
    
    return( dwStatus );
}


DWORD FmpGetJoinApproval()
{
    DWORD       dwStatus;
    LPCWSTR     pszNodeId;
    DWORD       dwNodeLen;
    

    pszNodeId = OmObjectId(NmLocalNode);
    dwNodeLen = (lstrlenW(pszNodeId)+1)*sizeof(WCHAR);

    dwStatus = GumSendUpdateEx(
                GumUpdateFailoverManager,
                FmUpdateApproveJoin, 
                1,
                dwNodeLen,
                pszNodeId);
                
    return(dwStatus);                

}

/****
@func       DWORD | FmpBuildForceQuorumInfo | Build the force quorum info that
            will be passed to the resource DLL via a control code.  This
            involves enumerating nodes and checking that the nodes that make up
            the list passed on the command line are all valid cluster nodes.

@parm       IN LPCWSTR | pszNodesIn | Comma separated list of node names.  If 
            this is NULL then the routine just fills the quorum info structure
            with 0 and a NULL node list.

@parm       OUT PCLUS_FORCE_QUORUM_INFO | pForceQuorumInfo | Structure that gets
            filled in with info
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       Assumes NmInitialize was called prior to calling this routine.

@xref       <f FmpBuildForceQuorumInfo> 
****/
static 
DWORD 
FmpBuildForceQuorumInfo(
    IN LPCWSTR pszNodesIn,
    OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    )
{
    WCHAR *pszOut = NULL;
    WCHAR *pszComma = NULL;
    DWORD status = ERROR_SUCCESS;
    PNM_NODE_ENUM2 pNodeEnum = NULL;
    int iCurrLen = 0, iOffset = 0;
    DWORD dwNodeIndex;
    DWORD dwSize;
    PCLUS_FORCE_QUORUM_INFO pForceQuorumInfo = NULL;

    // Need to allocate a structure that can hold the nodes list.
    //
    dwSize = sizeof( CLUS_FORCE_QUORUM_INFO ) + sizeof( WCHAR ) * (wcslen( pszNodesIn ) + 1);
    pForceQuorumInfo = LocalAlloc( LMEM_FIXED, dwSize );
    if ( pForceQuorumInfo == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    ZeroMemory( pForceQuorumInfo, dwSize );

    pForceQuorumInfo->dwSize = dwSize;
    pForceQuorumInfo->dwNodeBitMask = 0;
    pForceQuorumInfo->dwMaxNumberofNodes = 0;

    if ( pszNodesIn == NULL ) {
        pForceQuorumInfo->multiszNodeList[0] = L'\0';
        goto ret;
    }

    // Now get the enumeration of all cluster nodes so we can check we have
    // valid nodes in the list.
    //
    status = NmpEnumNodeDefinitions( &pNodeEnum );
    if ( status != ERROR_SUCCESS )
        goto ErrorExit;

    // Go through all the nodes we have and ensure that they are cluster nodes.
    // Get the corresponding ID and incorporate in the bitmask
    //
    do {
        pszComma = wcschr( pszNodesIn, (int) L',');
        if ( pszComma == NULL ) 
            iCurrLen = wcslen( pszNodesIn );
        else
            iCurrLen = (int) (pszComma - pszNodesIn);
        
        // At this point pszNodesIn is the start of a node name, iCurrLen chars long
        // or iCurrLen is 0 in which case we have ,, in the input stream.
        //
        if (iCurrLen > 0) {
            
            // Work out if this node is part of the cluster and if so get its
            // ID and setup the bitmask.
            //
            for ( dwNodeIndex = 0; dwNodeIndex < pNodeEnum->NodeCount; dwNodeIndex++ ) {
                int iNodeNameLen = wcslen( pNodeEnum->NodeList[ dwNodeIndex ].NodeName );
                ClRtlLogPrint( LOG_NOISE, "[Fm] FmpBuildForceQuorumInfo: trying %1\r\n",
                               pNodeEnum->NodeList[ dwNodeIndex ].NodeName );

                if ( _wcsnicmp( pNodeEnum->NodeList[ dwNodeIndex ].NodeName, 
                                pszNodesIn, 
                                max(iCurrLen, iNodeNameLen) ) == 0 ) {

                    ClRtlLogPrint( LOG_NOISE, "[Fm] FmpBuildForceQuorumInfo: got match %1\r\n",
                                   pNodeEnum->NodeList[ dwNodeIndex ].NodeName );
                    
                    // Set the mask and max nodes and break - ignore duplicates.
                    //
                    if ( !(pForceQuorumInfo->dwNodeBitMask & (1 << dwNodeIndex)) ) {
                        pForceQuorumInfo->dwMaxNumberofNodes += 1;
                        pForceQuorumInfo->dwNodeBitMask |= 1 << dwNodeIndex;
                        wcscpy( &pForceQuorumInfo->multiszNodeList[iOffset], pNodeEnum->NodeList[ dwNodeIndex ].NodeName );
                        iOffset += wcslen( pNodeEnum->NodeList[ dwNodeIndex ].NodeName ) + 1;
                    }
                    break;
                }
            }
            if ( dwNodeIndex == pNodeEnum->NodeCount ) {
                ClRtlLogPrint( LOG_UNUSUAL, "[Fm] FmpBuildForceQuorumInfo: no match for %1\r\n", pszNodesIn );
                status = ERROR_INVALID_PARAMETER;
                goto ErrorExit;
            }
        } else if ( pszComma != NULL ) {
            ClRtlLogPrint( LOG_ERROR,
                           "[Fm] FmpBuildForceQuorumInfo: iCurrLen was 0 so ,, was in node list: %1\r\n", 
                           CsForceQuorumNodes );
            status = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }
        pszNodesIn = pszComma + 1;
    } while ( pszComma != NULL);
    pForceQuorumInfo->multiszNodeList[ iOffset ] = L'\0';
    goto ret;

ErrorExit:
    if ( pForceQuorumInfo != NULL ) {
        LocalFree( pForceQuorumInfo );
        pForceQuorumInfo = NULL;
    }
ret:
    if ( pNodeEnum != NULL ) {
        ClNetFreeNodeEnum( pNodeEnum );
    }
    
    if ( status == ERROR_SUCCESS ) {
        *ppForceQuorumInfo = pForceQuorumInfo;
    }
    return status;
}

static 
void
FmpDeleteForceQuorumInfo(
    IN OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    )
{
    (void) LocalFree( *ppForceQuorumInfo );
    *ppForceQuorumInfo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmprop.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmprop.c

Abstract:

    Implements the management of group properties.

Author:

    Rod Gamache (rodga) 7-Jan-1996

Revision History:

--*/
#include "fmp.h"
//#include "stdio.h"

#define MAX_DWORD ((DWORD)-1)

//
// Group Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
FmpGroupCommonProperties[] = {
    { CLUSREG_NAME_GRP_DESC,               NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0 },
    { CLUSREG_NAME_GRP_PERSISTENT_STATE,   NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0 },
    { CLUSREG_NAME_GRP_FAILOVER_THRESHOLD, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD, 0, MAX_DWORD, 0 },
    { CLUSREG_NAME_GRP_FAILOVER_PERIOD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD, 0, CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD, 0 },
    { CLUSREG_NAME_GRP_FAILBACK_TYPE,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE, 0, CLUSTER_GROUP_MAXIMUM_AUTO_FAILBACK_TYPE, 0 },
    { CLUSREG_NAME_GRP_FAILBACK_WIN_START, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START, CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_START, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START, RESUTIL_PROPITEM_SIGNED },
    { CLUSREG_NAME_GRP_FAILBACK_WIN_END,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END, CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_END, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END, RESUTIL_PROPITEM_SIGNED },
    { CLUSREG_NAME_GRP_LOADBAL_STATE,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_LOADBAL_STATE, 0, 1, 0 },
    { CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME, NULL, CLUSPROP_FORMAT_MULTI_SZ,    0, 0, 0, 0 },
    { 0 }
};

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
FmpGroupROCommonProperties[] = {
    { CLUSREG_NAME_GRP_NAME, NULL, CLUSPROP_FORMAT_SZ,
      0, 0, 0,
      RESUTIL_PROPITEM_READ_ONLY,
      0
    },
//    { CLUSREG_NAME_GRP_CONTAINS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY, 0 },
//    { CLUSREG_NAME_GRP_PREFERRED_OWNERS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY, 0 },
    { 0 }
};



//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
FmpClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    NULL,
    NULL,
    NULL
};



DWORD
FmpGroupEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given group.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Enumerate the common properties.
    //
    status = ClRtlEnumProperties( FmpGroupCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // FmpGroupEnumCommonProperties



DWORD
FmpGroupGetCommonProperties(
    IN PFM_GROUP Group,
    IN BOOL     ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given group.

Arguments:

    Group - Supplies the group.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           outBufferSize = OutBufferSize;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Get the common properties.
    //
    if ( ReadOnly ) {
        //
        // We have to be particularly careful about the group name.
        // If a remote node owns the group, and changes the name, then
        // the registry field is updated after the name is set into OM.
        // Therefore, we must read the OM info, rather than the registry
        // which could be stale.
        //
        status = ClRtlPropertyListFromParameterBlock(
                            FmpGroupROCommonProperties,
                            OutBuffer,
                            &outBufferSize,
                            (LPBYTE) &OmObjectName(Group),
                            BytesReturned,
                            Required );
    } else {
        status = ClRtlGetProperties(
                            Group->RegistryKey,
                            &FmpClusterRegApis,
                            FmpGroupCommonProperties,
                            OutBuffer,
                            OutBufferSize,
                            BytesReturned,
                            Required );
    }

    return(status);

} // FmpGroupGetCommonProperties



DWORD
FmpGroupValidateCommonProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( FmpGroupCommonProperties,
                                       NULL,   // Reserved
                                       FALSE,  // Don't allow uknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_ERROR,
                    "[FM] ValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // FmpGroupValidateCommonProperties



DWORD
FmpGroupSetCommonProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( FmpGroupCommonProperties,
                                       NULL,   // Reserved
                                       FALSE,  // Don't allow uknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status == ERROR_SUCCESS ) {

        status = ClRtlSetPropertyTable( NULL, 
                                        Group->RegistryKey,
                                        &FmpClusterRegApis,
                                        FmpGroupCommonProperties,
                                        NULL,   // Reserved
                                        FALSE,  // Don't allow unknowns
                                        InBuffer,
                                        InBufferSize,
                                        FALSE,  // bForceWrite
                                        NULL );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_ERROR,
                       "[FM] SetCommonProperties, error in set routine.\n");
        }
    } else {
        ClRtlLogPrint( LOG_ERROR,
                    "[FM] SetCommonProperties, error in verify routine.\n");
    }

    return(status);

} // FmpGroupSetCommonProperties



DWORD
FmpGroupEnumPrivateProperties(
    PFM_GROUP Group,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given group.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      groupKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster group parameters key.
    //
    groupKey = DmOpenKey( Group->RegistryKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED );
    if ( groupKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enumerate the private properties.
    //
    status = ClRtlEnumPrivateProperties( groupKey,
                                         &FmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );
    DmCloseKey( groupKey );

    return(status);

} // FmpGroupEnumPrivateProperties



DWORD
FmpGroupGetPrivateProperties(
    IN PFM_GROUP Group,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given group.

Arguments:

    Group - Supplies the group.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      groupKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster group parameters key.
    //
    groupKey = DmOpenKey( Group->RegistryKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED );
    if ( groupKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the group.
    //
    status = ClRtlGetPrivateProperties( groupKey,
                                        &FmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( groupKey );

    return(status);

} // FmpGroupGetPrivateProperties



DWORD
FmpGroupValidatePrivateProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // FmpGroupValidatePrivateProperties



DWORD
FmpGroupSetPrivateProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      groupKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster group\parameters key
        //
        groupKey = DmOpenKey( Group->RegistryKey,
                              CLUSREG_KEYNAME_PARAMETERS,
                              MAXIMUM_ALLOWED );
        if ( groupKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                groupKey = DmCreateKey( Group->RegistryKey,
                                        CLUSREG_KEYNAME_PARAMETERS,
                                        0,
                                        KEY_READ | KEY_WRITE,
                                        NULL,
                                        &disposition );
                if ( groupKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              groupKey,
                                              &FmpClusterRegApis,
                                              InBuffer,
                                              InBufferSize );
        DmCloseKey( groupKey );

    }

    return(status);

} // FmpGroupSetPrivateProperties



DWORD
FmpGroupGetFlags(
    IN PFM_GROUP Group,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given group.

Arguments:

    Group - Supplies the group.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the group.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( Group->RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // FmpGroupGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmreg.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    fmreg.c

Abstract:

    Object Manager registry query routines for the Failover Manager
    component of the NT Cluster Service.

Author:

    Rod Gamache (rodga) 14-Mar-1996

Revision History:

--*/
#include "fmp.h"
#include <stdlib.h>
#include <search.h>

#define LOG_MODULE FMREG

//
// Global data initialized in this module
//
ULONG   FmpUnknownCount = 0;

//
// Local functions
//

VOID
FmpGroupChangeCallback(
    IN DWORD_PTR    Context1,
    IN DWORD_PTR    Context2,
    IN DWORD        CompletionFilter,
    IN LPCWSTR      RelativeName
    );

VOID
FmpResourceChangeCallback(
    IN DWORD_PTR    Context1,
    IN DWORD_PTR    Context2,
    IN DWORD        CompletionFilter,
    IN LPCWSTR      RelativeName
    );




/////////////////////////////////////////////////////////////////////////////
//
// Configuration Database Access Routines
//
/////////////////////////////////////////////////////////////////////////////

DWORD
FmpRegEnumerateKey(
    IN     HDMKEY     ListKey,
    IN     DWORD      Index,
    OUT    LPWSTR    *Name,
    IN OUT LPDWORD    NameMaxSize
    )

/*++

Routine Description:

Arguments:

Returns:

--*/

{
    DWORD           status;
    FILETIME        fileTime;


    status = DmEnumKey( ListKey,
                        Index,
                        *Name,
                        NameMaxSize,
                        NULL );

    if ( status == ERROR_SUCCESS ) {
        return(ERROR_SUCCESS);
    }

    if ( status == ERROR_MORE_DATA ) {
        PWCHAR   nameString = NULL;
        DWORD    maxSubkeyNameSize = 0;
        DWORD    temp = 0;

        //
        // The name string isn't big enough. Reallocate it.
        //

        //
        // Find out the length of the longest subkey name.
        //
        status = DmQueryInfoKey( ListKey,
                                 &temp,
                                 &maxSubkeyNameSize,
                                 &temp,
                                 &temp,
                                 &temp,
                                 NULL,
                                 &fileTime );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_MORE_DATA) ) {
            ClRtlLogPrint(LOG_NOISE,"[FM] DmQueryInfoKey returned status %1!u!\n",
                status);
            return(status);
        }

        CL_ASSERT(maxSubkeyNameSize != 0);

        //
        // The returned subkey name size does not include the terminating null.
        // It is also an ANSI string count.
        //
        maxSubkeyNameSize *= sizeof(WCHAR);
        maxSubkeyNameSize += sizeof(UNICODE_NULL);

        nameString = LocalAlloc( LMEM_FIXED,
                                 maxSubkeyNameSize );

        if ( nameString == NULL ) {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] Unable to allocate key name buffer of size %1!u!\n",
                maxSubkeyNameSize
                );
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        LocalFree(*Name);
        *Name = nameString;
        *NameMaxSize = maxSubkeyNameSize;

        status = DmEnumKey( ListKey,
                            Index,
                            *Name,
                            NameMaxSize,
                            NULL );

        CL_ASSERT(status != ERROR_MORE_DATA);
        CL_ASSERT(status != ERROR_NO_MORE_ITEMS);
    }

    return(status);

} // FmpRegEnumerateKey


VOID
FmpPruneGroupOwners(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Prunes the entire preferred group list based on the possible
    nodes of each resource in the group.

Arguments:

    Group - Supplies the group object to be pruned

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PFM_RESOURCE Resource;

    ListEntry = Group->Contains.Flink;
    while (ListEntry != &Group->Contains) {
        Resource = CONTAINING_RECORD(ListEntry,
                                     FM_RESOURCE,
                                     ContainsLinkage);
        FmpPrunePreferredList(Resource);
        ListEntry = ListEntry->Flink;
    }

    return;
}


VOID
FmpPrunePreferredList(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Prune out nodes from the preferred owners list, if the resource cannot
    run on that node.

Arguments:

    Resource - Pointer to the resource object with a possible owners list.

Return Value:

    None.

--*/

{
    PFM_GROUP        group;
    PLIST_ENTRY      listEntry;
    PLIST_ENTRY      entry;
    PPREFERRED_ENTRY preferredEntry;
    PPOSSIBLE_ENTRY   possibleEntry;
    DWORD            orderedEntry = 0;

    group = Resource->Group;

    //
    // For each entry in the Preferred list, it must exist in the possible
    // list.
    //

    for ( listEntry = group->PreferredOwners.Flink;
          listEntry != &(group->PreferredOwners);
          ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        //
        // Scan the Possible owners list in the resource to make sure that
        // the group can run on all of the preferred owners.
        //
        for ( entry = Resource->PossibleOwners.Flink;
              entry != &(Resource->PossibleOwners);
              entry = entry->Flink ) {
            possibleEntry = CONTAINING_RECORD( entry,
                                               POSSIBLE_ENTRY,
                                               PossibleLinkage );
            if ( preferredEntry->PreferredNode == possibleEntry->PossibleNode ) {
                break;
            }
        }

        listEntry = listEntry->Flink;

        //
        // If we got to the end of the possible owners list and didn't find
        // an entry, then remove the current preferred entry.
        //
        if ( entry == &(Resource->PossibleOwners) ) {
            ClRtlLogPrint( LOG_NOISE,
                        "[FM] Removing preferred node %1!ws! because of resource %2!ws!\n",
                        OmObjectId(preferredEntry->PreferredNode),
                        OmObjectId(Resource));

            //
            // If this was an ordered entry, then decrement count.
            //
            if ( orderedEntry < group->OrderedOwners ) {
                --group->OrderedOwners;
            }
            RemoveEntryList( &preferredEntry->PreferredLinkage );
            OmDereferenceObject(preferredEntry->PreferredNode);
            LocalFree(preferredEntry);
            if ( IsListEmpty( &group->PreferredOwners ) ) {
                ClRtlLogPrint( LOG_ERROR,
                            "[FM] Preferred owners list is now empty! No place to run group %1!ws!\n",
                            OmObjectId(group));
            }
        } else {
            orderedEntry++;
        }
    }

} // FmpPrunePreferredList



BOOL
FmpAddNodeToPrefList(
    IN PNM_NODE     Node,
    IN PFM_GROUP    Group
    )
/*++

Routine Description:

    Node enumeration callback for including all remaining nodes
    in a group's preferred owners list.

Arguments:

    Group - a pointer to the group object to add this node as a preferred owner.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    //if it is already in the list FmpSetPrefferedEntry returns ERROR_SUCCESS
    if ( FmpSetPreferredEntry( Group, Node ) != ERROR_SUCCESS ) {
        return(FALSE);
    }

    return(TRUE);

} // FmpAddNodeToPrefList

BOOL
FmpAddNodeToListCb(
    IN OUT PNM_NODE_ENUM2 *ppNmNodeEnum,
    IN LPDWORD  pdwAllocatedEntries,
    IN PNM_NODE pNode,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of nodes.
    This routine adds the specified node to the list that is being
    generated.

Arguments:

    ppNmNodeEnum - The node Enumeration list. Can be an output if a new list is
            allocated.

    EnumData - Supplies the current enumeration data structure.

    Group - The Group object being enumerated.

    Id - The Id of the node object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.

Side Effects:

    Makes the quorum group first in the list.

--*/

{
    PNM_NODE_ENUM2  pNmNodeEnum;
    PNM_NODE_ENUM2  pNewNmNodeEnum;
    DWORD           dwNewAllocated;
    DWORD           dwStatus;



    pNmNodeEnum = *ppNmNodeEnum;

    if ( pNmNodeEnum->NodeCount >= *pdwAllocatedEntries ) 
    {
        //
        // Time to grow the GROUP_ENUM
        //

        dwNewAllocated = *pdwAllocatedEntries + ENUM_GROW_SIZE;
        pNewNmNodeEnum = LocalAlloc(LMEM_FIXED, NODE_SIZE(dwNewAllocated));
        if ( pNewNmNodeEnum == NULL ) 
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            CL_UNEXPECTED_ERROR(dwStatus);
            return(FALSE);
        }

        CopyMemory(pNewNmNodeEnum, pNmNodeEnum, NODE_SIZE(*pdwAllocatedEntries));
        *pdwAllocatedEntries = dwNewAllocated;
        *ppNmNodeEnum = pNewNmNodeEnum;
        LocalFree(pNmNodeEnum);
        pNmNodeEnum = pNewNmNodeEnum;
    }

    //dont copy more that the sixe        
    lstrcpyW(pNmNodeEnum->NodeList[pNmNodeEnum->NodeCount].NodeId, Id );
    ++pNmNodeEnum->NodeCount;


    return(TRUE);

} // FmpAddNodeToListCb

int
__cdecl
SortNodesInAscending(
    const PVOID Elem1,
    const PVOID Elem2
    )
{
    PNM_NODE_INFO2 El1 = (PNM_NODE_INFO2)Elem1;
    PNM_NODE_INFO2 El2 = (PNM_NODE_INFO2)Elem2;

    return(lstrcmpiW( El1->NodeId, El2->NodeId ));

}// SortNodesInAsceding


DWORD
FmpEnumNodesById(
    IN DWORD    dwOptions, 
    OUT PNM_NODE_ENUM2 *ppNodeEnum
    )

/*++

Routine Description:

    Enumerates and sorts the list of Groups.

Arguments:

    *ppNodeEnum - Returns the requested objects.

    dwOptions - 
    
Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

--*/

{
    DWORD               dwStatus;
    PNM_NODE_ENUM2      pNmNodeEnum = NULL;
    DWORD               dwAllocatedEntries;

    //
    // initialize output params to NULL
    //
    *ppNodeEnum = NULL;

    dwAllocatedEntries = ENUM_GROW_SIZE;

    pNmNodeEnum = LocalAlloc( LMEM_FIXED, NODE_SIZE(ENUM_GROW_SIZE) );
    if ( pNmNodeEnum == NULL ) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    pNmNodeEnum->NodeCount = 0;

    //
    // Enumerate all nodes
    //

    OmEnumObjects( ObjectTypeNode,
                FmpAddNodeToListCb,
                &pNmNodeEnum,
                &dwAllocatedEntries );

    CL_ASSERT( pNmNodeEnum->NodeCount != 0 );
    //
    // Sort the groups by their collating sequence number.
    //
    
    qsort( (PVOID)(&pNmNodeEnum->NodeList[0]),
           (size_t)pNmNodeEnum->NodeCount,
           sizeof(NM_NODE_INFO2),          
           (int (__cdecl *)(const void*, const void*)) SortNodesInAscending
           );

    *ppNodeEnum = pNmNodeEnum;
    return( ERROR_SUCCESS );

error_exit:
    if ( pNmNodeEnum != NULL ) {
        LocalFree( pNmNodeEnum );
    }

    return( dwStatus );

} // FmpEnumNodesById


BOOL
FmpEnumAddAllOwners(
    IN PFM_RESOURCE Resource,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback for adding all nodes to a resource's
    list of possible nodes.

Arguments:

    Resource - a pointer to the resource object to add this node as a possible owner.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    if ( !Resource->PossibleList ) {
        FmpAddPossibleEntry(Resource, Node);
    }
    return(TRUE);

} // FmpEnumAddAllOwners


DWORD
FmpQueryGroupNodes(
    IN PFM_GROUP Group,
    IN HDMKEY hGroupKey
    )
/*++

Routine Description:

    Rebuilds and orders the list of preferred nodes associated with
    a group.

Arguments:

    Group - Supplies the group whose list of preferred nodes should
            be rebuilt.

    hGroupKey - Supplies a handle to the group's registry key

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LPWSTR          preferredOwnersString = NULL;
    DWORD           preferredOwnersStringSize = 0;
    DWORD           preferredOwnersStringMaxSize = 0;
    DWORD           mszStringIndex;
    PPREFERRED_ENTRY preferredEntry;
    DWORD           status;
    PLIST_ENTRY     listEntry;
    PNM_NODE_ENUM2  pNmNodeEnum = NULL;
    PNM_NODE        pNmNode;
    DWORD           i;
    //
    // First, delete the old list.
    //
    while ( !IsListEmpty(&Group->PreferredOwners) ) {
        listEntry = Group->PreferredOwners.Flink;
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        RemoveEntryList( &preferredEntry->PreferredLinkage );
        OmDereferenceObject( preferredEntry->PreferredNode );
        LocalFree( preferredEntry );
    }
    Group->OrderedOwners = 0;

    CL_ASSERT ( IsListEmpty(&Group->PreferredOwners) );

    status = DmQueryMultiSz( hGroupKey,
                             CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                             &preferredOwnersString,
                             &preferredOwnersStringMaxSize,
                             &preferredOwnersStringSize );

    if ( status == NO_ERROR ) {

        //
        // Now Create the Preferred Owners list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR     nameString;
            PNM_NODE    preferredNode;

            nameString = ClRtlMultiSzEnum( preferredOwnersString,
                                           preferredOwnersStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }

            //
            // Create the Preferred Owners List entry
            //

            preferredEntry = LocalAlloc( LMEM_FIXED, sizeof(PREFERRED_ENTRY) );

            if ( preferredEntry == NULL ) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                return(status);
            }

            //
            // Create the preferred owners. This will implicitly create
            // additional reference required for the preferred owner nodes.
            //

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Group %1!ws! preferred owner %2!ws!.\n",
                       OmObjectId(Group),
                       nameString);

            preferredNode = OmReferenceObjectById( ObjectTypeNode,
                                                   nameString );

            if ( preferredNode == NULL ) {
                LocalFree(preferredEntry);
                status = GetLastError();
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Failed to find node %1!ws! for Group %2!ws!\n",
                           nameString,
                           OmObjectId(Group));
            } else {
                Group->OrderedOwners++;
                preferredEntry->PreferredNode = preferredNode;
                InsertTailList( &Group->PreferredOwners,
                                &preferredEntry->PreferredLinkage );
            }

        }
        LocalFree( preferredOwnersString );
    }

    //
    // We now include all remaining nodes in the preferred owners list.
    //
    // Every node must maintain the same ordering for the preferred list
    // for the multi-node cluster to work
    //
    status = FmpEnumNodesById( 0, &pNmNodeEnum );

    if ( status != ERROR_SUCCESS )
    {
        CL_UNEXPECTED_ERROR( status );
        ClRtlLogPrint(LOG_UNUSUAL, 
        	   "[FM] FmpQueryGroupNodes: FmpEnumNodesById failed, status = %1!u!\r\n",
        	    status);
        // return error                    
    }

    for ( i=0; i<pNmNodeEnum->NodeCount; i++ )
    {
        pNmNode = OmReferenceObjectById( ObjectTypeNode, 
                        pNmNodeEnum->NodeList[i].NodeId );
        CL_ASSERT( pNmNode != NULL );
        FmpAddNodeToPrefList( pNmNode, Group );
        OmDereferenceObject( pNmNode );     
    }

    //
    // Now prune out all the unreachable nodes.
    //
    FmpPruneGroupOwners( Group );

    //
    //  Chittur Subbaraman (chitturs) - 12/11/98
    //
    //  Free the memory allocated for pNmNodeEnum.
    //  (Fix memory leak)
    //
    LocalFree( pNmNodeEnum );

    return( ERROR_SUCCESS );

} // FmpQueryGroupNodes



DWORD
WINAPI
FmpQueryGroupInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    )

/*++

Routine Description:

    Queries Group info from the registry when creating a Group Object.

Arguments:

    Object - A pointer to the Group object being created.

    Initialize - TRUE if the resource objects should be initialized. FALSE
                 otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_GROUP       Group = (PFM_GROUP)Object;
    PFM_RESOURCE    Resource;
    DWORD           status;
    LPWSTR          containsString = NULL;
    DWORD           containsStringSize = 0;
    DWORD           containsStringMaxSize = 0;
    DWORD           temp;
    DWORD           mszStringIndex;
    DWORD           failoverThreshold = CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD;
    DWORD           failoverPeriod = CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD;
    DWORD           autoFailbackType = CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE;
    DWORD           zero = 0;
    PLIST_ENTRY     listEntry;
    HDMKEY          groupKey;
    DWORD           groupNameStringMaxSize = 0;
    DWORD           groupNameStringSize = 0;
    LPWSTR          groupName;
    PPREFERRED_ENTRY preferredEntry;
    DWORD           dwBufferSize = 0;
    DWORD           dwStringSize;


    //
    // Initialize the Group object from the registry info.
    //
    if ( Group->Initialized ) {
        return(ERROR_SUCCESS);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Initializing group %1!ws! from the registry.\n",
                OmObjectId(Group));

    //
    // Open the group key.
    //
    groupKey = DmOpenKey( DmGroupsKey,
                          OmObjectId(Group),
                          MAXIMUM_ALLOWED );

    if ( groupKey == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Unable to open group key %1!ws!, %2!u!\n",
                    OmObjectId(Group),
                    status);

        return(status);
    }

    //
    // Read the required group values. The strings will be allocated
    // by the DmQuery* functions.
    //

    //
    // Get the Name.
    //
    status = DmQuerySz( groupKey,
                        CLUSREG_NAME_GRP_NAME,
                        &groupName,
                        &groupNameStringMaxSize,
                        &groupNameStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read name for Group %1!ws!\n",
                    OmObjectId(Group));
        goto error_exit;
    }

    status = OmSetObjectName( Group, groupName );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Unable to set name %1!ws! for group %2!ws!, error %3!u!.\n",
                    groupName,
                    OmObjectId(Group),
                    status );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Name for Group %1!ws! is '%2!ws!'.\n",
                OmObjectId(Group),
                groupName);

    LocalFree(groupName);
    //
    // Get the PersistentState.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_PERSISTENT_STATE,
                           &temp,
                           &zero );

    //
    // If the group state is non-zero then we go online.
    //
    if ( temp ) {
        Group->PersistentState = ClusterGroupOnline;
    } else {
        Group->PersistentState = ClusterGroupOffline;
    }

    //
    // Get the OPTIONAL PreferredOwners list.
    // *** NOTE *** This MUST be done before processing the contains list!
    //
    status = FmpQueryGroupNodes(Group, groupKey);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,"[FM] Error %1!d! creating preferred owners list\n",status);
        goto error_exit;
    }


    //
    // Get the Contains string.
    //
    status = DmQueryMultiSz( groupKey,
                             CLUSREG_NAME_GRP_CONTAINS,
                             &containsString,
                             &containsStringMaxSize,
                             &containsStringSize );

    if ( status != NO_ERROR ) {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Unable to read Contains for group %1!ws!\n",
                       OmObjectId(Group));
        }
    } else {
        //
        // Now Create the Contains list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR      nameString;
            PFM_RESOURCE containedResource;

            nameString = ClRtlMultiSzEnum( containsString,
                                           containsStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Group %1!ws! contains Resource %2!ws!.\n",
                       OmObjectId(Group),
                       nameString);

            //
            // Try to create the object.
            //
            FmpAcquireResourceLock();
            FmpAcquireLocalGroupLock( Group );

            containedResource = FmpCreateResource( Group,
                                                   nameString,
                                                   NULL,
                                                   Initialize );
            FmpReleaseLocalGroupLock( Group );
            FmpReleaseResourceLock();

            //
            // Check if we got a resource.
            //
            if ( containedResource == NULL ) {
                //
                // This group claims to contain a non-existent resource.
                // Log an error, but keep going. This should not tank the
                // whole group. Also, let the arbitration code know about
                // the failure of a resource.
                //
                Group->InitFailed = TRUE;
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Failed to find resource %1!ws! for Group %2!ws!\n",
                           nameString,
                           OmObjectId(Group));
            }
        }
        LocalFree(containsString);

    }

    //
    // Get the AutoFailbackType.
    //

    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_TYPE,
                           &temp,
                           &autoFailbackType );

    //
    // Verify that AutoFailbackType is okay.
    //

    if ( temp >= FailbackMaximum ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal value for AutoFailbackType on %1!ws!, setting to default\n",
                   OmObjectId(Group));
        temp = autoFailbackType;
    }

    Group->FailbackType = (UCHAR)temp;

    //
    // Get the FailbackWindowStart.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_START,
                           &temp,
                           &zero );

    //
    // Verify that FailbackWindowStart is okay.
    //
    if ( temp > 24 ) {
        if ( temp != CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START ) {
            ClRtlLogPrint(LOG_NOISE,
                      "[FM] Illegal value for FailbackWindowStart on %1!ws!,setting to default\n",
                      OmObjectId(Group));
            temp = zero;
        }
    }
    Group->FailbackWindowStart = (UCHAR)temp;

    //
    // Get the FailbackWindowEnd.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_END,
                           &temp,
                           &zero );

    //
    // Verify that FailbackWindowEnd is okay.
    //

    if ( temp > 24 ) {
        if ( temp != CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Illegal value for FailbackWindowEnd on %1!ws!, setting to default\n",
                       OmObjectId(Group));
            temp = zero;
        }
    }
    Group->FailbackWindowEnd = (UCHAR)temp;

    //
    // Get the FailoverPeriod.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_PERIOD,
                           &temp,
                           &failoverPeriod );

    //
    // Verify that FailoverPeriod is okay. Take any value up to UCHAR max.
    // In theory we could take any value... but in practice we have to convert
    // this time to milliseconds (currently). That means that 1193 hours can
    // fit in a DWORD - so that is the maximum we can take. (We are limited
    // because we use GetTickCount, which returns a DWORD in milliseconds.)
    //

    if ( temp > CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD ) {      // Keep it positive?
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal value for FailolverPeriod on %1!ws!. Max is 1193\n",
                   OmObjectId(Group));
        temp = failoverPeriod;                   
    } 

    Group->FailoverPeriod = (UCHAR)temp;
    

    //
    // Get the FailoverThreshold.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_THRESHOLD,
                           &(Group->FailoverThreshold),
                           &failoverThreshold );

    //
    // Verify that FailoverThreshold is okay. Take any value.
    //

    //
    // Get the AntiAffinityClassName property if present.
    //
    status = DmQueryMultiSz( groupKey,
                             CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME,
                             &Group->lpszAntiAffinityClassName,
                             &dwBufferSize,
                             &dwStringSize );

    //
    //  Handle the case in which the string is empty.
    //
    if ( ( status == ERROR_SUCCESS ) &&
         ( Group->lpszAntiAffinityClassName != NULL ) &&
         ( Group->lpszAntiAffinityClassName[0] == L'\0' ) )
    {
        LocalFree( Group->lpszAntiAffinityClassName );
        Group->lpszAntiAffinityClassName = NULL;
    }
         
    //
    // We're done. We should only get here if Group->Initialized is FALSE.
    //
    CL_ASSERT( Group->Initialized == FALSE );
    Group->Initialized = TRUE;
    Group->RegistryKey = groupKey;

    //
    // Now register for any changes to the resource key.
    //

    status = DmNotifyChangeKey(
                    groupKey,
                    (DWORD) CLUSTER_CHANGE_ALL,
                    FALSE,              // Only watch the top of the tree
                    &Group->DmRundownList,
                    FmpGroupChangeCallback,
                    (DWORD_PTR)Group,
                    0 );

    if ( status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Error registering for DM change notify on group %1!ws!, error %2!u!.\n",
                    OmObjectId(Group),
                    status);
        goto error_exit;
    }

    return(ERROR_SUCCESS);


error_exit:

    Group->Initialized = FALSE;
    Group->RegistryKey = NULL;

    DmCloseKey(groupKey);

    //
    // Cleanup any contained resources
    //
    while ( !IsListEmpty(&Group->Contains) ) {
        listEntry = RemoveHeadList(&Group->Contains);
        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        OmDereferenceObject(Resource);
    }

    //
    // Cleanup any preferred nodes
    //
    while ( !IsListEmpty(&Group->PreferredOwners) ) {
        listEntry = RemoveHeadList(&Group->PreferredOwners);
        preferredEntry = CONTAINING_RECORD(listEntry, PREFERRED_ENTRY, PreferredLinkage);
        OmDereferenceObject(preferredEntry->PreferredNode);
        LocalFree(preferredEntry);
    }

    return(status);

} // FmpQueryGroupInfo



DWORD
WINAPI
FmpFixupGroupInfo(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Re-queries Group info from the registry to fixup items that may have
    changed since the quorum resource (and the Group that it is in) was
    first created.

    This routine exists because we may have created the quorum resource
    (and its Group) early in the 'life' of the cluster, before all the node
    objects (for example) were created. We then would have failed generating
    the list of possible owners for the resource. This in turn would have
    caused some entries from the preferred list to get pruned. We need to
    redo this operation again here.

Arguments:

    Group - A pointer to the Group object to fix up.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

Notes:

    It is assumed that the quorum resource fixup already has happened.

--*/

{
    DWORD   status;

    status = FmpQueryGroupNodes(Group, Group->RegistryKey);

    return(status);

} // FmpFixupGroupInfo



DWORD
WINAPI
FmpQueryResourceInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    )

/*++

Routine Description:

    Queries Resource info from the registry when creating a Resource Object.

Arguments:

    Object - A pointer to the Resource object being created.

    Initialize - TRUE if the resource should be fully initialized.
                 FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE    Resource = (PFM_RESOURCE)Object;
    DWORD           status;
    DWORD           dllNameStringSize = 0;
    DWORD           dllNameStringMaxSize = 0;
    LPWSTR          resourceTypeString = NULL;
    DWORD           resourceTypeStringMaxSize = 0;
    DWORD           resourceTypeStringSize = 0;
    DWORD           dependenciesStringMaxSize = 0;
    DWORD           restartThreshold = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
    DWORD           restartPeriod = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
    DWORD           pendingTimeout = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;
    DWORD           RetryPeriodOnFailure = CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE;
    DWORD           defaultRestartAction = RestartGroup;
    DWORD           DefaultExFlags = 0;
    DWORD           zero = 0;
    DWORD           temp;
    DWORD           separateMonitor;
    HDMKEY          resourceKey;
    DWORD           resourceNameStringMaxSize = 0;
    DWORD           resourceNameStringSize = 0;
    LPWSTR          resourceName = NULL;
    LPWSTR          possibleOwnersString = NULL;
    DWORD           possibleOwnersStringSize = 0;
    DWORD           possibleOwnersStringMaxSize = 0;
    DWORD           mszStringIndex;
    PPOSSIBLE_ENTRY possibleEntry;
    PLIST_ENTRY     listEntry;
    WCHAR           unknownName[] = L"_Unknown9999";
    DWORD           nameSize = 0;
    DWORD           stringSize;

    //if the key is non null, this resource has already been initialized
    if (Resource->RegistryKey != NULL)
        return(ERROR_SUCCESS);

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Initializing resource %1!ws! from the registry.\n",
                OmObjectId(Resource));

    //
    // Begin initializing the resource from the registry.
    //
    //
    // Open the resource key.
    //
    resourceKey = DmOpenKey( DmResourcesKey,
                             OmObjectId(Resource),
                             MAXIMUM_ALLOWED );

    if ( resourceKey == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to open resource key %1!ws!, %2!u!\n",
                   OmObjectId(Resource),
                   status);
        return(ERROR_INVALID_NAME);
    }

    //
    // Read the required resource values. The strings will be allocated
    // by the DmQuery* functions.
    //

    //
    // Get the Name.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_NAME,
                        &resourceName,
                        &resourceNameStringMaxSize,
                        &resourceNameStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read name for resource %1!ws!\n",
                   OmObjectId(Resource));
        if ( OmObjectName( Resource ) == NULL ) {
            wsprintf( unknownName,
                      L"_Unknown%u",
                      InterlockedIncrement( &FmpUnknownCount ));
            status = OmSetObjectName( Resource, unknownName );
        } else {
            status = ERROR_SUCCESS;
        }
    } else {
        status = OmSetObjectName( Resource, resourceName );
    }
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Unable to set name %1!ws! for resource %2!ws!, error %3!u!.\n",
                   resourceName,
                   OmObjectId(Resource),
                   status );
        LocalFree(resourceName);
        status = ERROR_INVALID_NAME;
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Name for Resource %1!ws! is '%2!ws!'.\n",
                OmObjectId(Resource),
                resourceName);

    LocalFree(resourceName);

    //
    // Get the dependencies list.
    //

    status = DmQueryMultiSz( resourceKey,
                             CLUSREG_NAME_RES_DEPENDS_ON,
                             &(Resource->Dependencies),
                             &dependenciesStringMaxSize,
                             &(Resource->DependenciesSize) );

    if (status != NO_ERROR) {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read Dependencies for resource %1!ws!\n",
                   OmObjectId(Resource));
        }
    }

    //
    // Get the OPTIONAL PossibleOwners list.
    //
    // We do this here, because we must have a possible owners list for the
    // CluAdmin to start the resource.
    //

    status = DmQueryMultiSz( resourceKey,
                             CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                             &possibleOwnersString,
                             &possibleOwnersStringMaxSize,
                             &possibleOwnersStringSize );

    if ( status == NO_ERROR ) {

        //
        // Now Create the Possible Owners list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR     nameString;
            PNM_NODE    possibleNode;

            nameString = ClRtlMultiSzEnum( possibleOwnersString,
                                           possibleOwnersStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }
            possibleNode = OmReferenceObjectById( ObjectTypeNode,
                                                  nameString );

            if ( possibleNode == NULL ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Warning, failed to find node %1!ws! for Resource %2!ws!\n",
                           nameString,
                           OmObjectId(Resource));
            } else {
                Resource->PossibleList = TRUE;
                status = FmpAddPossibleEntry(Resource, possibleNode);
                OmDereferenceObject(possibleNode);
                if (status != ERROR_SUCCESS) {
                    goto error_exit;
                }
            }
        }
        LocalFree(possibleOwnersString);

        //
        // Now prune out unusable nodes from the preferred owners list.
        //
        FmpPrunePreferredList( Resource );

    } else {
        //
        // No possible owners value was specified. Add all the nodes
        // to the possible owners list. Note there is no point in pruning
        // the preferred list after this since this resource can run
        // anywhere.
        //
        OmEnumObjects( ObjectTypeNode,
                       FmpEnumAddAllOwners,
                       Resource,
                       NULL );
    }

    //
    // Get the resource type.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_TYPE,
                        &resourceTypeString,
                        &resourceTypeStringMaxSize,
                        &resourceTypeStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read ResourceType for resource %1!ws!\n",
                   OmObjectId(Resource));
        goto error_exit;
    }

    //
    // Open (and reference) the resource type.
    //
    if (Resource->Type == NULL)
    {
        Resource->Type = OmReferenceObjectById( ObjectTypeResType,
                                            resourceTypeString );
    }                                            
    if (Resource->Type == NULL) {

        PFM_RESTYPE pResType;
        //
        // If we can't find a resource type, then try to create it.
        //
        pResType = FmpCreateResType(resourceTypeString );

        if (pResType == NULL) {
            status = ERROR_INVALID_PARAMETER;
            LocalFree(resourceTypeString);
            goto error_exit;
        }

        //bump the ref count before saving a pointer to it in the
        //resource structure.
        OmReferenceObject(pResType);
        Resource->Type = pResType;
    }

    LocalFree(resourceTypeString);

    if ( !Initialize ) {
        //
        // We're not supposed to fully initialize the resource. This is
        // when we're early in the init process. We need to keep the registry
        // key closed when leaving.
        //
        DmCloseKey(resourceKey);
        return(ERROR_SUCCESS);
    }


    //
    // Get the IsAlive poll interval
    //
    CL_ASSERT( Resource->Type->IsAlivePollInterval != 0 );
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_IS_ALIVE,
                           &Resource->IsAlivePollInterval,
                           &Resource->Type->IsAlivePollInterval );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read IsAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);

        goto error_exit;
    }

    if ( Resource->IsAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
        Resource->IsAlivePollInterval = Resource->Type->IsAlivePollInterval;
    }

    //
    // Get the LooksAlive poll interval
    //
    CL_ASSERT( Resource->Type->LooksAlivePollInterval != 0 );
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_LOOKS_ALIVE,
                           &Resource->LooksAlivePollInterval,
                           &Resource->Type->LooksAlivePollInterval );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read LooksAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
        goto error_exit;
    }

    if ( Resource->LooksAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
        Resource->LooksAlivePollInterval = Resource->Type->LooksAlivePollInterval;
    }

    //
    // Get the current persistent state of the resource.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PERSISTENT_STATE,
                           &temp,
                           NULL );

    //
    // Save the current resource state.
    //

    if ( ( status == ERROR_FILE_NOT_FOUND )  || 
         ( ( status == ERROR_SUCCESS ) && ( temp == CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE ) ) ) {
        switch ( Resource->Group->PersistentState ) {
        case ClusterGroupOnline:
            Resource->PersistentState = ClusterResourceOnline;
            break;
        case ClusterGroupOffline:
            Resource->PersistentState = ClusterResourceOffline;
            break;
        default:
            break;
        }
    } else if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read PersistentState for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
        goto error_exit;
    } else if ( temp ) {
        Resource->PersistentState = ClusterResourceOnline;
    } else {
        Resource->PersistentState = ClusterResourceOffline;
    }

    //
    // Determine the monitor to run this in.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_SEPARATE_MONITOR,
                           &separateMonitor,
                           &zero );
    if ( separateMonitor ) {
        Resource->Flags |= RESOURCE_SEPARATE_MONITOR;
    }

    //
    // Get the RestartThreshold.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_THRESHOLD,
                           &Resource->RestartThreshold,
                           &restartThreshold );

    // Verify the RestartThreshold. Take any value.

    //
    // Get the RestartPeriod.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_PERIOD,
                           &Resource->RestartPeriod,
                           &restartPeriod );

    // Verify the RestartPeriod. Take any value.

    //
    // Get the RestartAction.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_ACTION,
                           &Resource->RestartAction,
                           &defaultRestartAction );

    // Verify the RestartAction.

    if ( Resource->RestartAction >= RestartMaximum ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal RestartAction for resource %1!ws!\n",
                   OmObjectId(Resource));
        goto error_exit;
    }

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE,
                           &Resource->RetryPeriodOnFailure,
                           &RetryPeriodOnFailure );

    // make sure that RetryPeriodOnFailure >= RestartPeriod
    if (Resource->RetryPeriodOnFailure < Resource->RestartPeriod)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Specified RetryPeriodOnFailure value is less than RestartPeriod value - setting RetryPeriodOnFailure equal to RestartPeriod \n");
        Resource->RetryPeriodOnFailure = Resource->RestartPeriod;              
        
    }    

                           
    //
    // Get the extrinsic Flags
    //
    DefaultExFlags = 0;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_FLAGS,
                           &Resource->ExFlags,
                           &DefaultExFlags );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read Extrinsic Flags for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);

        goto error_exit;
    }

    //
    // Get the PendingTimeout value.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PENDING_TIMEOUT,
                           &Resource->PendingTimeout,
                           &pendingTimeout );

    // Verify the PendingTimeout. Take any value.

    //
    // Now register for any changes to the resource key.
    //

    if (IsListEmpty(&Resource->DmRundownList))
    {
        status = DmNotifyChangeKey(
                    resourceKey,
                    (DWORD) CLUSTER_CHANGE_ALL,
                    FALSE,              // Only watch the top of the tree
                    &Resource->DmRundownList,
                    FmpResourceChangeCallback,
                    (DWORD_PTR)Resource,
                    0 );

        if ( status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] Error registering for DM change notify on resource %1!ws!, error %2!u!.\n",
                    OmObjectId(Resource),
                    status);
            goto error_exit;
        }
    }
    //
    // Get the DebugPrefix string... this is on the resource type.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_DEBUG_PREFIX,
                        &Resource->DebugPrefix,
                        &nameSize,
                        &stringSize );

    //
    // Finally save the resource key for registry updates of the
    // PersistentState.
    //
    Resource->RegistryKey = resourceKey;

    return(ERROR_SUCCESS);


error_exit:

    DmCloseKey(resourceKey);

    if ( Resource->Type != NULL ) {
        OmDereferenceObject(Resource->Type);
    }

    //
    // Cleanup any dependencies
    //
    if ( Resource->Dependencies != NULL ) {
        LocalFree(Resource->Dependencies);
        Resource->Dependencies = NULL;
    }

    //
    // Cleanup any possible nodes
    //
    while ( !IsListEmpty(&Resource->PossibleOwners) ) {
        listEntry = RemoveHeadList(&Resource->PossibleOwners);
        possibleEntry = CONTAINING_RECORD(listEntry, POSSIBLE_ENTRY, PossibleLinkage);
        OmDereferenceObject(possibleEntry->PossibleNode);
        LocalFree(possibleEntry);
    }

    return(status);

} // FmpQueryResourceInfo



DWORD
WINAPI
FmpFixupResourceInfo(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Re-queries Resource info from the registry to fixup items that may have
    changed since the quorum resource was first created.

    This routine exists because we may have created the quorum resource early
    in the 'life' of the cluster, before all the node objects (for example)
    were created. We then would have failed generating the list of possible
    owners for the resource. In FmpQueryResourceInfo, we treat failures to
    find node objects as non-fatal errors, which we will now cleanup.

Arguments:

    Resource - A pointer to the Resource object to fix up.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    LPWSTR          possibleOwnersString = NULL;
    DWORD           possibleOwnersStringSize = 0;
    DWORD           possibleOwnersStringMaxSize = 0;
    DWORD           mszStringIndex;
    DWORD           status;


    if ( Resource->RegistryKey == NULL ) {
        return(ERROR_NOT_READY);
    }

    //
    // Get the OPTIONAL PossibleOwners list.
    //

    status = DmQueryMultiSz( Resource->RegistryKey,
                             CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                             &possibleOwnersString,
                             &possibleOwnersStringMaxSize,
                             &possibleOwnersStringSize );

    if ( status == NO_ERROR ) {

        //
        // Now Create the Possible Owners list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR     nameString;
            PNM_NODE    possibleNode;

            nameString = ClRtlMultiSzEnum( possibleOwnersString,
                                           possibleOwnersStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }
            possibleNode = OmReferenceObjectById( ObjectTypeNode,
                                                  nameString );

            if ( possibleNode == NULL ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Warning, failed to find node %1!ws! for Resource %2!ws!\n",
                           nameString,
                           OmObjectId(Resource));
            } else {
                Resource->PossibleList = TRUE;
                status = FmpAddPossibleEntry(Resource, possibleNode);
                OmDereferenceObject(possibleNode);
                if (status != ERROR_SUCCESS) {
                    return(status);
                }
            }
        }
        LocalFree(possibleOwnersString);

        //
        // Now prune out unusable nodes from the preferred owners list.
        //
        FmpPrunePreferredList( Resource );

    } else {
        //
        // No possible owners value was specified. Add all the nodes
        // to the possible owners list. Note there is no point in pruning
        // the preferred list after this since this resource can run
        // anywhere.
        //
        OmEnumObjects( ObjectTypeNode,
                       FmpEnumAddAllOwners,
                       Resource,
                       NULL );

    }

    return(ERROR_SUCCESS);

} // FmpFixupQuorumResourceInfo



DWORD
WINAPI
FmpQueryResTypeInfo(
    IN PVOID Object
    )

/*++

Routine Description:

    Queries Resource Type info from the registry when creating a ResType Object.

Arguments:

    Object - A pointer to the Resource Type object being created.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESTYPE     resType = (PFM_RESTYPE)Object;
    DWORD           status;
    DWORD           dwSize = 0;
    DWORD           stringSize;
    HDMKEY          resTypeKey;
    DWORD           temp;
    LPWSTR          pmszPossibleNodes = NULL;
    
    //
    // Open the resource type key.
    //
    resTypeKey = DmOpenKey( DmResourceTypesKey,
                            OmObjectId(resType),
                            MAXIMUM_ALLOWED );

    if ( resTypeKey == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to open resource type key %1!ws!, %2!u!\n",
                   OmObjectId(resType),
                   status);

        return(status);
    }

    //
    // Read the required resource type DLL name. The strings will be allocated
    // by the DmQuery* functions.
    //

    status = DmQuerySz( resTypeKey,
                        CLUSREG_NAME_RESTYPE_DLL_NAME,
                        &resType->DllName,
                        &dwSize,
                        &stringSize );
    if ( status != NO_ERROR ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The DllName value for the %1!ws! resource type does not exist. "
                          "Resources of this type will not be monitored.\n",
                          OmObjectId(resType));
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The DllName value for the %1!ws! resource type could not be read "
                          "from the registry. Resources of this type will not be monitored. "
                          "The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
        }

        goto error_exit;
    }


    //
    // Get the optional LooksAlive poll interval
    //
    status = DmQueryDword( resTypeKey,
                           CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                           &resType->LooksAlivePollInterval,
                           NULL );

    if ( status != NO_ERROR ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            resType->LooksAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The LooksAlive poll interval for the %1!ws! resource type could "
                          "not be read from the registry. Resources of this type will not be "
                          "monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    //
    // Get the optional IsAlive poll interval
    //
    status = DmQueryDword( resTypeKey,
                           CLUSREG_NAME_RESTYPE_IS_ALIVE,
                           &resType->IsAlivePollInterval,
                           NULL );

    if ( status != NO_ERROR ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            resType->IsAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The IsAlive poll interval for the %1!ws! resource type "
                          "could not be read from the registry. Resources of this type "
                          "will not be monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    //
    // Get the optional DebugPrefix string... this is on the resource type.
    //
    dwSize = 0;
    status = DmQuerySz( resTypeKey,
                        CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,
                        &resType->DebugPrefix,
                        &dwSize,
                        &stringSize );

    //
    // Get the optional DebugControlFunctions registry value
    //
    resType->Flags &= ~RESTYPE_DEBUG_CONTROL_FUNC;
    temp = 0;
    status = DmQueryDword( resTypeKey,
                           CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC,
                           &temp,
                           NULL );

    if ( status != NO_ERROR ) {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The Debug control functions for the %1!ws! resource type "
                          "could not be read from the registry. Resources of this type "
                          "will not be monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    if ( temp ) {
        resType->Flags |= RESTYPE_DEBUG_CONTROL_FUNC;
    }


    //ss: bug make sure you free the old memory
    InitializeListHead(&(resType->PossibleNodeList));
    
    //
    // Get the Possible Nodes
    //
    dwSize = 0;
    status = DmQueryMultiSz( resTypeKey,
                           CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                           &pmszPossibleNodes,
                           &dwSize,
                           &stringSize);


    if ( status != NO_ERROR ) 
    {
        //if the possible node list is not found this is ok
        if ( status != ERROR_FILE_NOT_FOUND ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The Possible nodes list for the %1!ws! resource type "
                          "could not be read from the registry. Resources of this type "
                          "will not be monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpQueryResTypeInfo: Calling FmpAddPossibleNodeToList for restype %1!ws!\r\n",
        OmObjectId(resType));

    status = FmpAddPossibleNodeToList(pmszPossibleNodes, stringSize, 
        &resType->PossibleNodeList);
    if ( status != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpCreateResType: FmpAddPossibleNodeToList() failed, status=%1!u!\r\n",
            status);
        goto error_exit;
    }


error_exit:
    if (pmszPossibleNodes) LocalFree(pmszPossibleNodes);
    DmCloseKey(resTypeKey);

    return(status);

} // FmpQueryResTypeInfo



VOID
FmpGroupChangeCallback(
    IN DWORD_PTR  Context1,
    IN DWORD_PTR  Context2,
    IN DWORD      CompletionFilter,
    IN LPCWSTR    RelativeName
    )

/*++

Routine Description:

    This routine basically flushes our cached data for the given group.

Arguments:

    Context1 - A pointer to the Group object that was modified.

    Context2 - Not used.

    CompletionFilter - Not used.

    RelativeName - The registry path relative to the entry that was modified.
                   Not used.

Return Value:

    None.

--*/

{
    PFM_GROUP   Group = (PFM_GROUP)Context1;
    HDMKEY      groupKey;
    DWORD       status;
    DWORD       temp;
    BOOL        notify = FALSE;
    DWORD       dwBufferSize = 0;
    DWORD       dwStringSize;

    groupKey = Group->RegistryKey;
    if ( groupKey == NULL ) {
        return;
    }

    //
    // Re-fetch all of the data for the group.
    //
    // Name changes are managed elsewhere.
    // The Contains list is managed elsewhere.
    //

    //
    // Get the OPTIONAL PreferredOwners list.
    // *** NOTE *** This MUST be done before processing the contains list!
    //
    status = FmpQueryGroupNodes(Group, groupKey);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,"[FM] Error %1!d! refreshing preferred owners list\n",status);
    }

    //
    // Get the AutoFailbackType.
    //
    temp = Group->FailbackType;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_TYPE,
                           &temp,
                           &temp );

    //
    // Verify that AutoFailbackType is okay.
    //

    if ( temp >= FailbackMaximum ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for AutoFailbackType on %1!ws!\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailbackType ) {
            notify = TRUE;
        }
        Group->FailbackType = (UCHAR)temp;
    }

    //
    // Get the FailbackWindowStart.
    //
    temp = Group->FailbackWindowStart;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_START,
                           &temp,
                           &temp );

    //
    // Verify that FailbackWindowStart is okay.
    //

    if ( temp > 24 ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for FailbackWindowStart on %1!ws!\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailbackWindowStart ) {
            notify = TRUE;
        }
        Group->FailbackWindowStart = (UCHAR)temp;
    }

    //
    // Get the FailbackWindowEnd.
    //
    temp = Group->FailbackWindowEnd;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_END,
                           &temp,
                           &temp );

    //
    // Verify that FailbackWindowEnd is okay.
    //

    if ( temp > 24 ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for FailbackWindowEnd on %1!ws!\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailbackWindowEnd ) {
            notify = TRUE;
        }
        Group->FailbackWindowEnd = (UCHAR)temp;
    }

    //
    // Get the FailoverPeriod.
    //
    temp = Group->FailoverPeriod;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_PERIOD,
                           &temp,
                           &temp );

    //
    // Verify that FailoverPeriod is okay. Take any value up to UCHAR max.
    // In theory we could take any value... but in practice we have to convert
    // this time to milliseconds (currently). That means that 1193 hours can
    // fit in a DWORD - so that is the maximum we can take. (We are limited
    // because we use GetTickCount, which returns a DWORD in milliseconds.)
    //

    if ( temp > (1193) ) {    // we dont bother Keeping it positive?
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for FailolverPeriod on %1!ws!. Max is 596\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailoverPeriod ) {
            notify = TRUE;
        }
        Group->FailoverPeriod = (UCHAR)temp;
    }

    //
    // Get the FailoverThreshold.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_THRESHOLD,
                           &(Group->FailoverThreshold),
                           &(Group->FailoverThreshold) );

    //
    // Verify that FailoverThreshold is okay. Take any value.
    //

    //
    // Get the current persistent state of the group.
    //
    if ( Group->PersistentState == ClusterGroupOnline ) {
        temp = 1;
    } else {
        temp = 0;
    }
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_PERSISTENT_STATE,
                           &temp,
                           &temp );
    //
    // If the group state is non-zero then we go online.
    //
    // Don't bother with change notifications... they should happen elsewhere.
    //
    if ( temp ) {
        if ( ClusterGroupOnline != Group->PersistentState ) {
            //notify = TRUE;
        }
        Group->PersistentState = ClusterGroupOnline;
    } else {
        if ( ClusterGroupOffline != Group->PersistentState ) {
            //notify = TRUE;
        }
        Group->PersistentState = ClusterGroupOffline;
    }

    //
    // Get the AntiAffinityClassName property if present.
    //
    LocalFree( Group->lpszAntiAffinityClassName );
    Group->lpszAntiAffinityClassName = NULL;
    status = DmQueryMultiSz( groupKey,
                             CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME,
                             &Group->lpszAntiAffinityClassName,
                             &dwBufferSize,
                             &dwStringSize );

    //
    //  Handle the case in which the string is empty.
    //
    if ( ( status == ERROR_SUCCESS ) &&
         ( Group->lpszAntiAffinityClassName != NULL ) &&
         ( Group->lpszAntiAffinityClassName[0] == L'\0' ) )
    {
        LocalFree( Group->lpszAntiAffinityClassName );
        Group->lpszAntiAffinityClassName = NULL;
    }

    // We're done!
    if ( !FmpShutdown &&
         notify ) {
        ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group );
    }

    return;

} // FmpGroupChangeCallback



VOID
FmpResourceChangeCallback(
    IN DWORD_PTR  Context1,
    IN DWORD_PTR  Context2,
    IN DWORD      CompletionFilter,
    IN LPCWSTR    RelativeName
    )

/*++

Routine Description:

    This routine basically flushes our cached data for the given resource.

Arguments:

    Context1 - A pointer to the resource object that was modified.

    Context2 - Not used.

    CompletionFilter - Not used.

    RelativeName - The registry path relative to the entry that was modified.
                   Not used.

Return Value:

    None.

--*/

{
    PFM_RESOURCE Resource = (PFM_RESOURCE)Context1;
    HDMKEY      resourceKey;
    DWORD       status;
    DWORD       separateMonitor;
    DWORD       zero = 0;
    DWORD       temp;
    BOOL        notify = FALSE;
    DWORD       dwDefault;

    resourceKey = Resource->RegistryKey;
    if ( resourceKey == NULL ) {
        return;
    }

    //
    // Re-fetch all of the data for the resource.
    //
    // Name changes are managed elsewhere.
    // The dependency list is managed elsewhere.
    //
    // We can't change the resource type here!
    // We can't stop the resource to start it in a separate monitor either.
    //

#if 0
    //
    // Get the Name.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_NAME,
                        &resourceName,
                        &resourceNameStringMaxSize,
                        &resourceNameStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read name for resource %1!ws!\n",
                   OmObjectId(Resource));
        if ( OmObjectName( Resource ) == NULL ) {
            wsprintf( unknownName,
                      L"_Unknown%u",
                      InterlockedIncrement( &FmpUnknownCount ));
            status = OmSetObjectName( Resource, unknownName );
        } else {
            status = ERROR_SUCCESS;
        }
    } else {
        status = OmSetObjectName( Resource, resourceName );
    }

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Unable to set name %1!ws! for resource %2!ws!, error %3!u!.\n",
                   resourceName,
                   OmObjectId(Resource),
                   status );
    }
#endif

    //
    // Get the IsAlive poll interval
    //
    temp = Resource->IsAlivePollInterval;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_IS_ALIVE;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_IS_ALIVE,
                           &Resource->IsAlivePollInterval,
                           &dwDefault );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to refresh IsAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);

    } else {
        CL_ASSERT( Resource->Type->IsAlivePollInterval != 0 );
        if ( temp != Resource->IsAlivePollInterval ) {
            notify = TRUE;
        }
        if ( Resource->IsAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
            Resource->IsAlivePollInterval = Resource->Type->IsAlivePollInterval;
        }
    }

    //
    // Get the LooksAlive poll interval
    //
    temp = Resource->LooksAlivePollInterval;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_LOOKS_ALIVE,
                           &Resource->LooksAlivePollInterval,
                           &dwDefault );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to refresh LooksAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
    } else {
        CL_ASSERT( Resource->Type->IsAlivePollInterval != 0 );
        if ( temp != Resource->LooksAlivePollInterval ) {
            notify = TRUE;
        }
        if ( Resource->LooksAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
            Resource->LooksAlivePollInterval = Resource->Type->LooksAlivePollInterval;
        }
    }

    //
    // Get the RestartThreshold.
    //
    temp = Resource->RestartThreshold;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_THRESHOLD,
                           &Resource->RestartThreshold,
                           &dwDefault);

    // Verify the RestartThreshold. Take any value.
    if ( (status == NO_ERROR) &&
         (temp != Resource->RestartThreshold) ) {
        notify = TRUE;
    }

    //
    // Get the RestartPeriod.
    //
    temp = Resource->RestartPeriod;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_PERIOD,
                           &Resource->RestartPeriod,
                           &dwDefault );

    if ( (status ==  NO_ERROR) &&
         (temp != Resource->RestartPeriod) ) {
        notify = TRUE;
    }

    // Verify the RestartPeriod. Take any value.

    //
    // Get the RestartAction.
    //
    temp = Resource->RestartAction;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_ACTION,
                           &Resource->RestartAction,
                           &dwDefault);

    // Verify the RestartAction.

    if ( status == NO_ERROR ) {
        if ( temp != Resource->RestartAction ) {
            notify = TRUE;
        }
        if ( Resource->RestartAction >= RestartMaximum ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Illegal RestartAction refresh for resource %1!ws!\n",
                       OmObjectId(Resource));
        }
    }

    temp = Resource->RetryPeriodOnFailure;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE,
                           &Resource->RetryPeriodOnFailure,
                           &dwDefault );

    // make sure that RetryPeriodOnFailure >= RestartPeriod
    if (Resource->RetryPeriodOnFailure < Resource->RestartPeriod)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Specified RetryPeriodOnFailure value is less than RestartPeriod value - setting RetryPeriodOnFailure equal to RestartPeriod \n");
        Resource->RetryPeriodOnFailure = Resource->RestartPeriod;              
        
    }   
    if( temp != Resource->RetryPeriodOnFailure)
        notify = TRUE;
    
    //
    // Get the PendingTimeout value.
    //
    temp = Resource->PendingTimeout;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PENDING_TIMEOUT,
                           &Resource->PendingTimeout,
                           &dwDefault);

    // Verify the PendingTimeout. Take any value.

    if ( (status == NO_ERROR) &&
         (temp != Resource->PendingTimeout) ) {
        notify = TRUE;
    }


    //
    // Get the current persistent state of the resource.
    //
    // Don't bother with change notifications... they should happen elsewhere.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PERSISTENT_STATE,
                           &temp,
                           NULL );

    //
    // Save the current resource state.
    //

    if ( ( status == ERROR_FILE_NOT_FOUND )  || 
       ( ( status == ERROR_SUCCESS ) && ( temp == CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE ) ) ) {
        switch ( Resource->Group->PersistentState ) {
        case ClusterGroupOnline:
            Resource->PersistentState = ClusterResourceOnline;
            break;
        case ClusterGroupOffline:
            Resource->PersistentState = ClusterResourceOffline;
            break;
        default:
            break;
        }
    } else if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read PersistentState for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
        return;
    } else if ( temp ) {
        Resource->PersistentState = ClusterResourceOnline;
    } else {
        Resource->PersistentState = ClusterResourceOffline;
    }

#if 0  // Do this work when bringing the resource online!
    //
    // Determine the monitor to run this in. This is only updated from
    // the node that owns the resource.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_SEPARATE_MONITOR,
                           &separateMonitor,
                           &zero );
    //
    // Only do work if the flag changes.
    //
    if ( (!separateMonitor &&
         (Resource->Flags & RESOURCE_SEPARATE_MONITOR)) ||
         (separateMonitor &&
         ((Resource->Flags & RESOURCE_SEPARATE_MONITOR) == 0)) ) {

        //
        // If the resource is not offline or the quorum resource, then
        // we'll have to wait until the cluster service restarts.
        //
        //
        // The separate monitor flag has changed... tell ResMon to close
        // the resource and then create it again.
        //
        if ( (Resource->State != ClusterResourceOffline) ||
             Resource->QuorumResource ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Can't change separate monitor flag on the fly... we'll pick this up on next cluster start\n",
                       OmObjectId(Resource) );
            // Now fall through to post the other changes.
        } else {
            if ( FmpPostNotification( (RM_NOTIFY_KEY)Resource,
                                      RmRestartResource,
                                      Resource->PersistentState ) ) {
                return;
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Failed to post notification to restart resource '%1!ws!'.\n",
                           OmObjectId(Resource) );
            }
        }
    }
#endif

    if ( !FmpShutdown &&
         notify ) {
        //
        // Comments from sunitas: Tell the resource monitor about the 
        // changes but do this from the worker thread. Originally, this
        // used to be a post notification to the FmpRmWorkerThread
        // which posts resmon notifications to clussvc.
        //
        OmReferenceObject(Resource);
        FmpPostWorkItem(FM_EVENT_INTERNAL_RESOURCE_CHANGE_PARAMS,
                        Resource,
                        0);
    }

#if 0   // The post notification above handles the event notification
    if ( !FmpShutdown &&
         notify ) {
        ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, Resource );
    }
#endif

    return;

} // FmpResourceChangeCallback



DWORD
FmpChangeResourceMonitor(
    IN PFM_RESOURCE Resource,
    IN DWORD        SeparateMonitor
    )

/*++

Routine Description:

    This routine switches the resource from one resource monitor to another.

Arguments:

    Resource - pointer to the resource that was modified.

    SeparateMonitor - flag to indicate whether to run in a separate monitor;

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

Notes:

    The resource should be offline.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       separateMonitor;
    DWORD       zero = 0;

    if ( Resource->RegistryKey == NULL ) {
        return(ERROR_INVALID_STATE);
    }

    if ( (Resource->State != ClusterResourceOffline) &&
         (Resource->State != ClusterResourceFailed) ) {
        return(ERROR_INVALID_STATE);
    }

    //
    // Determine the monitor to run this in. This is only updated from
    // the node that owns the resource.
    //
    if ( (!SeparateMonitor &&
         (Resource->Flags & RESOURCE_SEPARATE_MONITOR)) ||
         (SeparateMonitor &&
         ((Resource->Flags & RESOURCE_SEPARATE_MONITOR) == 0)) ) {

        //
        // The separate monitor flag has changed... tell ResMon to close
        // the resource and then create it again.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Changing Separate Resource Monitor state\n");

        status = FmpRmCloseResource( Resource );
        if ( status == ERROR_SUCCESS ) {
            if ( Resource->Flags & RESOURCE_SEPARATE_MONITOR ) {
                Resource->Flags &= ~RESOURCE_SEPARATE_MONITOR;
            } else {
                Resource->Flags |= RESOURCE_SEPARATE_MONITOR;
            }
            status = FmpRmCreateResource( Resource );
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Separate resource monitor changed for '%1!ws!', but failed to re-open the resource, error %2!u!.\n",
                           OmObjectId(Resource),
                           status );
            }
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Separate resource monitor changed for '%1!ws!', but failed to close the resource, error %2!u!.\n",
                       OmObjectId(Resource),
                       status );
            return(status);
        }
    }

    return(status);

} // FmpChangeResourceMonitor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmp.h ===
#ifndef _FMP_H
#define _FMP_H

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmp.h

Abstract:

    Private data structures and procedure prototypes for
    the Failover Manager subcomponent of the NT Cluster
    Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#include "clusudef.h"
#include "rm_rpc.h"
#include "stdlib.h"

#define LOG_CURRENT_MODULE LOG_MODULE_FM

#define FMGUM        1
#define RMNOTIFY     2
#define RESOURCE     3
#define FMAPI        4
#define GROUP        5
#define RECV         6
#define EVENT        7
#define FMCLIENT     8
#define TREE         9
#define FMINIT      10
#define IOCTL       11
#define FMREG       12
#define RESMONF     13  //for resmon.c
#define WORKER      14
#define RESFAIL     15
#define GROUPARB    16

//
// RPC timeout constant (borrowed from nmp.h)
// Node Intracluster RPC record/cancellation routines.
// Useful to terminate outstanding RPCs to failed nodes.
//

#define FM_RPC_TIMEOUT 45000  // 45 secs

//
//  Monitor shutdown timeout
//
#define FM_MONITOR_SHUTDOWN_TIMEOUT  15 * 60 * 1000    //  15 min


typedef CLUSTER_EVENT FM_EVENT;

//fm event handling
//events generated by the service
#define FM_EVENT_NODE_DOWN                  1
#define FM_EVENT_SHUTDOWN                   2
#define FM_EVENT_RESOURCE_ADDED             3
#define FM_EVENT_RESOURCE_DELETED           4
#define FM_EVENT_GROUP_FAILED               5
#define FM_EVENT_NODE_ADDED                 6
#define FM_EVENT_CLUSTER_PROPERTY_CHANGE    7
#define FM_EVENT_RESOURCE_PROPERTY_CHANGE   8
//#define FM_EVENT_GROUP_PROPERTY_CHANGE      9
#define FM_EVENT_RESOURCE_CHANGE            10
#define FM_EVENT_NODE_EVICTED               11

//events generated due to resource dll's
#define FM_EVENT_RES_RESOURCE_TRANSITION    128
#define FM_EVENT_RES_RESOURCE_FAILED        129

//generated when DealyedRestart timer fires
#define FM_EVENT_RES_RETRY_TIMER            131

#define FM_EVENT_INTERNAL_PROP_GROUP_STATE  256

#define FM_EVENT_INTERNAL_SHUTDOWN_CLEANUP  258
#define FM_EVENT_INTERNAL_RETRY_ONLINE      259
#define FM_EVENT_INTERNAL_RESOURCE_CHANGE_PARAMS    260
#define FM_EVENT_INTERNAL_ONLINE_GROUPLIST  261
#define FM_EVENT_RESOURCE_NAME_CHANGE       262

// timer activities ( in msec)
#define FM_TIMER_RESLIST_ONLINE_RETRY  1 * 60 * 1000 //( 1 minute)
//
// Global defines
//

#define FMP_GROUP_NAME L"Group"
#define FMP_RESOURCE_NAME L"Resource"
#define FMP_RESOURCE_TYPE_NAME L"ResType"

#define FMP_GROUP_SIGNATURE 'rGmF'
#define FMP_RESOURCE_SIGNATURE 'sRmF'
#define FMP_RESOURCE_TYPE_SIGNATURE 'tRmF'
#define FMP_RESMON_SIGNATURE 'mRmF'

#define PENDING_TIMEOUT     (4*1000)    // retry pending operations every 4 secs

//
// Globals
//
extern HANDLE FmpShutdownEvent;
extern DWORD FmpFMOnline;
extern DWORD FmpFMFormPhaseProcessing;
extern DWORD FmpFMGroupsInited;
extern BOOL FmpShutdown;
extern BOOL FmpMajorEvent;

extern CRITICAL_SECTION FmpResourceLock;
extern CRITICAL_SECTION FmpGroupLock;
extern CRITICAL_SECTION FmpMonitorLock;

//
// 185575: remove use of unique RPC binding handles.
//
//extern CRITICAL_SECTION FmpBindingLock;

extern CL_QUEUE FmpWorkQueue;

//global data relating to the quorum resource
#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION gQuoLock;
#else
    extern RTL_RESOURCE     gQuoLock;
#endif    

#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION    gQuoChangeLock;
#else
    extern RTL_RESOURCE        gQuoChangeLock;
#endif    

#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION    gResTypeLock;
#else
    extern RTL_RESOURCE        gResTypeLock;
#endif    

extern  PFM_RESOURCE        gpQuoResource;
extern  HANDLE              ghQuoOnlineEvent;
extern  DWORD               gdwQuoBlockingResources;

extern  RPC_BINDING_HANDLE  FmpRpcBindings[];
extern  RPC_BINDING_HANDLE  FmpRpcQuorumBindings[];

extern  RESUTIL_PROPERTY_ITEM FmpGroupCommonProperties[];

typedef struct FM_NODE{
    DWORD       dwNodeDownProcessingInProgress;
    PNM_NODE    pNode;
}FM_NODE, *PFM_NODE;    

extern  PFM_NODE            gFmpNodeArray;

//
// Macros
//

#define FmpMustBeOnline( )                              \
        if ( !FmpFMOnline ) {                           \
            if ( FmpShutdown ) {                        \
                return(ERROR_CLUSTER_NODE_SHUTTING_DOWN); \
            } else {                                    \
                return(ERROR_CLUSTER_NODE_NOT_READY);   \
            }                                           \
        }

#define FmpMustBeOnlineEx( ReturnValue )                \
        if ( !FmpFMOnline ) {                           \
            if ( FmpShutdown ) {                        \
                SetLastError(ERROR_CLUSTER_NODE_SHUTTING_DOWN); \
            } else {                                    \
                SetLastError(ERROR_CLUSTER_NODE_NOT_READY); \
            }                                           \
            return(ReturnValue);                        \
        }

typedef struct WORK_ITEM {
    LIST_ENTRY      ListEntry;
    CLUSTER_EVENT   Event;
    PVOID           Context1;
    ULONG_PTR       Context2;
} WORK_ITEM, *PWORK_ITEM;

// structures for timer activity
typedef struct _FM_RESLIST_ONLINE_RETRY_INFO{
    PFM_GROUP       pGroup;
    RESOURCE_ENUM   ResourceEnum;
}FM_RESLIST_ONLINE_RETRY_INFO, *PFM_RESLIST_ONLINE_RETRY_INFO;

    
//structure for cleanup at shutdown
typedef struct FM_CLEANUP_INFO{
    PGROUP_ENUM     pGroupEnum;
    BOOL            bContainsQuorumGroup;
    DWORD           dwTimeOut;
}FM_CLEANUP_INFO, *PFM_CLEANUP_INFO;


//
// Wait block used for waiting on completion of pending
// events
//
typedef struct FM_WAIT_BLOCK {
    LIST_ENTRY ListEntry;
    HANDLE hEvent;
    DWORD Status;
} FM_WAIT_BLOCK, *PFM_WAIT_BLOCK;

//
// Group Move structure
//

typedef struct MOVE_GROUP {
    PFM_GROUP   Group;
    PNM_NODE    DestinationNode;
} MOVE_GROUP, *PMOVE_GROUP;

//
//  Information for group affinity calculation.
//
typedef struct GROUP_AFFINITY_NODE_INFO {
    PFM_GROUP   pGroup;
    PNM_NODE    *ppNmNodeList;
    BOOL        fDidPruningOccur;
} GROUP_AFFINITY_NODE_INFO, *PGROUP_AFFINITY_NODE_INFO;

//
// Define types of pending routines
//

typedef enum {
    OfflinePending
} PENDING_ROUTINE;


//
// Define types of Group failbacks
//

typedef enum {
    FailbackNot,
    FailbackOkay,
    FailbackMaximum
} FAILBACK_TYPE;

//
// Define resource restart actions
//

typedef enum {
    RestartNot,
    RestartLocal,
    RestartGroup,
    RestartMaximum
} RESTART_ACTION;


//
// Define FM to Resmon event types.
//

typedef enum {
    ResourceTransition,
    ResourceResuscitate,
    RmWorkerTerminate,
    RmUpdateResource,
    RmRestartResource
} RM_EVENT_TYPE;



DWORD
WINAPI
FmpGumReceiveUpdates(
    IN DWORD    Context,
    IN BOOL     SourceNode,
    IN DWORD    BufferLength,
    IN PVOID    Buffer
    );

DWORD
WINAPI
FmpGumVoteHandler(
    IN  DWORD dwContext,
    IN  DWORD dwInputBufLength,
    IN  PVOID pInputBuf,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
);

//
// Gum update message buffers.
//

// UpdateResourceState

typedef struct GUM_RESOURCE_STATE {
    CLUSTER_RESOURCE_STATE  State;
    CLUSTER_RESOURCE_STATE  PersistentState;
    DWORD                   StateSequence;
} GUM_RESOURCE_STATE, *PGUM_RESOURCE_STATE;

// UpdateGroupState

typedef struct GUM_GROUP_STATE {
    CLUSTER_GROUP_STATE State;
    CLUSTER_GROUP_STATE PersistentState;
    DWORD               StateSequence;
} GUM_GROUP_STATE, *PGUM_GROUP_STATE;

// UpdateGroupFailureCount

typedef struct GUM_FAILURE_COUNT {
    DWORD   Count;
    DWORD   NewTime;
    WCHAR   GroupId[1];
} GUM_FAILURE_COUNT, *PGUM_FAILURE_COUNT;

typedef struct GUM_CREATE_GROUP {
    PFM_GROUP Group;
    DWORD GroupIdLen;
    DWORD GroupNameLen;
    WCHAR GroupId[1];
    // WCHAR GroupName[1];
    // WCHAR NodeName[1];
} GUM_CREATE_GROUP, *PGUM_CREATE_GROUP;

typedef struct GUM_DELETE_GROUP {
    WCHAR GroupId[1];
} GUM_DELETE_GROUP, *PGUM_DELETE_GROUP;

typedef struct GUM_CREATE_RESOURCE {
    PFM_RESOURCE Resource;
    DWORD GroupIdLen;
    DWORD ResourceIdLen;
    WCHAR GroupId[1];
    // WCHAR ResourceId[1];
    // WCHAR ResourceName[1];
} GUM_CREATE_RESOURCE, *PGUM_CREATE_RESOURCE;

typedef struct GUM_INIT_RESOURCE {
    DWORD   ResourceIdLen;
    WCHAR   ResourceId[1];
} GUM_INIT_RESOURCE, *PGUM_INIT_RESOURCE;

typedef struct GUM_CHANGE_POSSIBLE_NODE {
    DWORD ResourceIdLen;
    WCHAR ResourceId[1];
    // WCHAR NodeName[1];
} GUM_CHANGE_POSSIBLE_NODE, *PGUM_CHANGE_POSSIBLE_NODE;

typedef struct GUM_CREATE_RESOURCE_TYPE {
    WCHAR TypeName[1];
} GUM_CREATE_RESOURCE_TYPE, *PGUM_CREATE_RESOURCE_TYPE;

typedef struct GUM_DELETE_RESOURCE_TYPE {
    WCHAR TypeName[1];
} GUM_DELETE_RESOURCE_TYPE, *PGUM_DELETE_RESOURCE_TYPE;

typedef struct GUM_CHANGE_GROUP {
    DWORD ResourceIdLen;
    WCHAR ResourceId[1];
    // WCHAR GroupName[1];
} GUM_CHANGE_GROUP, *PGUM_CHANGE_GROUP;

#if 0
typedef struct GUM_SET_POSSIBLE_NODE_FORRESTYPE{
    DWORD ResTypeNameLen;
    WCHAR ResTypeName[1];
} GUM_SET_POSSIBLE_OWNER_FORRESTYPE, *PGUM_SET_POSSIBLE_OWNER_FORRESTYPE;
#endif

typedef struct _FMP_POSSIBLE_NODE {
    PFM_RESOURCE    Resource;
    PNM_NODE        Node;
    DWORD           ControlCode;
} FMP_POSSIBLE_NODE, *PFMP_POSSIBLE_NODE;


//VOTE STRUCTURES
typedef struct _FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE{
    DWORD   dwSize;
    DWORD   dwNodeId;
    BOOL    bPossibleNode;
}FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE, *PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE;    

typedef struct _FM_RES_CHANGE_NAME {
    PFM_RESOURCE    pResource;
    WCHAR           szNewResourceName[1];
} FM_RES_CHANGE_NAME, *PFM_RES_CHANGE_NAME;

//
// Monitor resource enumeration
//

typedef struct MONITOR_RESOURCE_ENUM {
    DWORD       EntryCount;
    DWORD       CurrentIndex;
    BOOL        fCreateMonitors;
    PFM_RESOURCE Entry[1];
} MONITOR_RESOURCE_ENUM, *PMONITOR_RESOURCE_ENUM;

#define ENUM_GROW_SIZE 16

//
// Resource enumeration interface
//

#define RESOURCE_SIZE(Entries) ((Entries-1) * sizeof(RESOURCE_ENUM_ENTRY) + sizeof(RESOURCE_ENUM))

#define MONITOR_RESOURCE_SIZE(Entries) ((Entries-1) * sizeof(PFM_GROUP) + \
            sizeof(MONITOR_RESOURCE_ENUM))

//
// Group and resource enumeration entries.
//

#define GROUP_SIZE(Entries) ((Entries-1) * sizeof(GROUP_ENUM_ENTRY) + sizeof(GROUP_ENUM))

#define NODE_SIZE(Entries) ((Entries-1) * sizeof (NM_NODE_INFO2) + sizeof(NM_NODE_ENUM2))

#define RESOURCE_SIZE(Entries) ((Entries-1) * sizeof(RESOURCE_ENUM_ENTRY) + sizeof(RESOURCE_ENUM))

//
// Define structure for a Resource Monitor process
//
typedef struct RESMON {
    DWORD  Signature;
    HANDLE Process;
    HANDLE NotifyThread;
    BOOL   Shutdown;
    DWORD  RefCount;
    RPC_BINDING_HANDLE Binding;
    struct MONITOR_STATE *SharedState;
} RESMON, *PRESMON;

//
//  Monitor list enumeration info used for resource DLL upgrade.
//
typedef struct _FM_MONITOR_ENUM_HEADER 
{
    DWORD   cEntries;
    DWORD   cAllocated;
    BOOL    fDefaultMonitorAdded;
    PRESMON *ppMonitorList;
} FM_MONITOR_ENUM_HEADER, *PFM_MONITOR_ENUM_HEADER;

//
//  Structure definitions for passing around group preferred node list info on a node
//  down.
//
typedef struct _FM_GROUP_NODE_LIST_ENTRY
{
    DWORD                       dwPreferredNodeId;
    WCHAR                       szGroupId[1]; //  Always at the end to help marshalling
} FM_GROUP_NODE_LIST_ENTRY, *PFM_GROUP_NODE_LIST_ENTRY;

typedef struct _FM_GROUP_NODE_LIST
{
    DWORD                       cbGroupNodeList;
    FM_GROUP_NODE_LIST_ENTRY    leGroupNodeList[1]; // Always at the end to help marshalling
} FM_GROUP_NODE_LIST, *PFM_GROUP_NODE_LIST;

//flags for cluster propery change
#define     CLUSTER_NAME_CHANGE     0x00000001
#define     CLUSTER_QUORUM_CHANGE   0x00000002

// FM event handling structures
typedef struct CLUSTER_EVENT_PROPERTY_CONTEXT{
    DWORD   dwFlags;    
    PVOID   pContext1;
    PVOID   pContext2;
}CLUSTER_EVENT_PROPERTY_CONTEXT, *PCLUSTER_EVENT_PROPERTY_CONTEXT;


typedef struct RESOURCE_STATE_CHANGE{
    PFM_RESOURCE            pResource;
    CLUSTER_RESOURCE_STATE  OldState;
    CLUSTER_RESOURCE_STATE  NewState;
}RESOURCE_STATE_CHANGE, *PRESOURCE_STATE_CHANGE;

//Cluster Name management
DWORD
FmpRegUpdateClusterName(
    IN LPCWSTR szNewClusterName
    );

//
// Quorum resource Arbitration.
//

DWORD
FmpRmArbitrateResource(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpRmReleaseResource(
    IN PFM_RESOURCE Resource
    );

//
// Interfaces for managing the registry.
//

DWORD
FmpRegEnumerateKey(
    IN     HDMKEY   ListKey,
    IN     DWORD    Index,
    IN     LPWSTR  *Name,
    IN OUT LPDWORD  NameMaxSize
    );

//
// Gum interfaces
//

DWORD
FmpEnableGum(
    );

//
// Interfaces for managing Resource Monitor processes
//

PRESMON
FmpCreateMonitor(
    LPWSTR DebugPrefix,
    BOOL   SeparateMonitor
    );

VOID
FmpShutdownMonitor(
    IN PRESMON Monitor
    );

BOOL
FmpRestartMonitor(
    IN PRESMON Monitor
    );

DWORD 
FmpCreateMonitorRestartThread(
    IN PRESMON pMonitor
);

//
// Interfaces for managing resources via the Resource Monitors
//

DWORD
FmpRmCreateResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmCloseResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmOnlineResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmOfflineResource(
    PFM_RESOURCE    Resource
    );

VOID
FmpRmTerminateResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmFailResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmChangeResourceParams(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmpRmResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD FmpRmLoadResTypeDll(
    IN PFM_RESTYPE  pResType
    );

DWORD
FmpPostProcessResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Interfaces for managing resources
//

DWORD
FmpInitResource(
    VOID
    );

VOID
FmpCleanupResource(
    VOID
    );

PFM_RESOURCE
FmpCreateResource(
    IN  PFM_GROUP   Group,
    IN  LPCWSTR     ResourceId,
    IN  LPCWSTR     ResourceName,
    IN  BOOL        Initialize
    );

VOID
FmpDestroyResource(
    IN PFM_RESOURCE Resource,
    IN BOOL         bDeleteObjOnly
    );

VOID
FmpResourceLastReference(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpInitializeResource(
    IN PFM_RESOURCE Resource,
    IN BOOL         Initialize
    );

DWORD
FmpOnlineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL ForceOnline
    );

DWORD
FmpOfflineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL bForceOffline
    );

DWORD
FmpDoOnlineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL ForceOnline
    );

DWORD
FmpDoOfflineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL bForceOffline
    );

VOID
FmpSetResourcePersistentState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    );

VOID
FmpCallResourceNotifyCb(
    IN PFM_RESOURCE Resource, 
    IN CLUSTER_RESOURCE_STATE State
    );

DWORD
FmpPropagateResourceState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    );

DWORD
FmpGetResourceList(
    OUT PRESOURCE_ENUM *ReturnEnum,
    IN PFM_GROUP Group
    );

DWORD FmpSubmitRetryOnline(
    IN PRESOURCE_ENUM   pResourceEnum);

VOID
FmpDeleteResourceEnum(
    IN PRESOURCE_ENUM Enum
    );

DWORD
FmpOnlineResourceList(
    IN PRESOURCE_ENUM   Enum,
    IN PFM_GROUP        pGroup
    );

DWORD
FmpOfflineResourceList(
    IN PRESOURCE_ENUM Enum,
    IN BOOL Restore
    );

DWORD
FmpTerminateResourceList(
    IN PRESOURCE_ENUM Enum
    );

VOID
FmpPrunePreferredList(
    IN PFM_RESOURCE Resource
    );

DWORD 
FmpCleanupPossibleNodeList(
    IN PFM_RESOURCE pResource
    );

DWORD
FmpSetPreferredEntry(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node
    );

DWORD
FmpAddPossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    );

DWORD
FmpAddPossibleEntry(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    );

DWORD
FmpRemovePossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL RemoveQuorum
    );

DWORD
FmpRemoveResourceDependency(
    IN HXSACTION hXsaction,
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependsOn
    );

BOOL
FmpFindQuorumResource(
    IN OUT PFM_RESOURCE *QuorumResource,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );

DWORD 
FmpGetQuorumDiskSignature(
    IN LPCWSTR lpQuorumId,
    OUT LPDWORD lpdwSignature
    );

BOOL
FmpReturnResourceType(
    IN OUT PFM_RESTYPE *FoundResourceType,
    IN LPCWSTR ResourceTypeName,
    IN PFM_RESTYPE ResourceType,
    IN LPCWSTR Name
    );

DWORD
FmpChangeResourceMonitor(
    IN PFM_RESOURCE Resource,
    IN DWORD        SeparateMonitor
    );

DWORD
FmpChangeResourceGroup(
    IN PFM_RESOURCE Resource,
    IN PFM_GROUP Group
    );

DWORD
FmpValAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    );

DWORD
FmpValRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    ); 

DWORD
FmpUpdateChangeResourceName(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszResourceId,
    IN LPCWSTR lpszNewName
    );

DWORD
FmpUpdateDeleteResource(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId
    );

DWORD
FmpUpdateAddDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    );

DWORD
FmpUpdateRemoveDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    );

DWORD
FmpUpdateAssignOwnerToGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    );

DWORD
FmpUpdateApproveJoin(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    );

DWORD
FmpUpdateCreateGroup(
    IN PGUM_CREATE_GROUP pGumGroup,
    IN BOOL    bSourceNode
    );

DWORD
FmpUpdateCreateResource(
    IN OUT PGUM_CREATE_RESOURCE pGumResource
    );

DWORD
FmpUpdateCompleteGroupMove(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId,
    IN LPCWSTR  pszGroupId
    );

DWORD
FmpUpdateCheckAndSetGroupOwner(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszGroupId,
    IN LPCWSTR lpszNodeId
    );

DWORD
FmpUpdateCreateResourceType(
    IN PVOID Buffer    
    );

DWORD FmpSetResourceName(
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      lpszFriendlyName
    );

DWORD
FmpClusterEventPropHandler(
    IN PFM_RESOURCE pResource
    );

BOOL
FmpEnumResourceNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

DWORD FmpPrepareQuorumResChange(
    IN PFM_RESOURCE pNewQuoRes,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    );

DWORD
FmpCompleteQuorumResChange(
    IN LPCWSTR      lpszOldQuoResId,
    IN LPCWSTR      lpszQuoLogPath
    );

DWORD
FmpBackupClusterDatabase(
    IN PFM_RESOURCE pQuoRes,
    IN LPCWSTR      lpszPathName
    );

//
// Interfaces for handling pending online/offline requests.
//
VOID
FmpSignalGroupWaiters(
    IN PFM_GROUP Group
    );

DWORD
FmpWaitForGroup(
    IN PFM_GROUP Group
    );

#define FmpIsGroupPending(_group_) (!IsListEmpty(&((_group_)->WaitQueue)))

//
// There is currently one default monitor process, and resources
// with the SeparateMonitor property have a monitor created for them.
//

extern PRESMON FmpDefaultMonitor;

//
// Interface for notification module
//
DWORD
FmpInitializeNotify(
    VOID
    );

BOOL
FmpPostNotification(
    IN RM_NOTIFY_KEY NotifyKey,
    IN DWORD  NotifyEvent,
    IN CLUSTER_RESOURCE_STATE CurrentState
    );


//
// Event processing routines
//

DWORD
FmpStartWorkerThread(
    VOID
    );

VOID
FmpPostWorkItem(
    IN CLUSTER_EVENT Event,
    IN PVOID Context1,
    IN ULONG_PTR Context2
    );

VOID
FmpHandleGroupFailure(
    IN PFM_GROUP    Group
    );

DWORD
FmpNodeUp(
    PVOID Context
    );

DWORD
FmpNodeDown(
    PVOID Context
    );

VOID
FmpPropagateState(
    VOID
    );

DWORD
FmpSetPossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN BOOL    bAssumeSupported
    );


DWORD
FmpRemovePossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN PNM_NODE pNode
    );

//
// Object Manager callback routines.
//

DWORD
WINAPI
FmpQueryGroupInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    );

DWORD
WINAPI
FmpQueryResourceInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    );

DWORD
WINAPI
FmpQueryResTypeInfo(
    IN PVOID Object
    );

DWORD
WINAPI
FmpFixupGroupInfo(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmpFixupResourceInfo(
    IN PFM_RESOURCE Resource
    );

//
// Synchronization macros
//
#define FmpAcquireResourceLock()  EnterCriticalSection(&FmpResourceLock)

#define FmpReleaseResourceLock()  LeaveCriticalSection(&FmpResourceLock)

#define FmpAcquireGroupLock()  EnterCriticalSection(&FmpGroupLock)

#define FmpReleaseGroupLock()  LeaveCriticalSection(&FmpGroupLock)

#define FmpAcquireMonitorLock()  EnterCriticalSection(&FmpMonitorLock)

#define FmpReleaseMonitorLock()  LeaveCriticalSection(&FmpMonitorLock)

#if 0
// 185575: remove unique RPC binding handles
#define FmpAcquireBindingLock()  EnterCriticalSection(&FmpBindingLock)

#define FmpReleaseBindingLock()  LeaveCriticalSection(&FmpBindingLock)
#endif

#define FmpTryAcquireGroupLock( Locked, Timeout )       \
{                                                       \
    DWORD   _retry = (Timeout + 19) / 20;               \
    do {                                                \
        Locked = TryEnterCriticalSection(&FmpGroupLock); \
        if ( !Locked ) Sleep( 20 );                     \
    } while (_retry-- && !Locked );                     \
}    

// Group and Resource Specific locks

#if 1 // DBG

#define FmpAcquireLocalGroupLock( Group )   \
{                                           \
    DWORD _fmpLockIndx;                     \
    EnterCriticalSection( &Group->Lock );   \
    _fmpLockIndx = Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Group->LockTable[_fmpLockIndx].Module = LOG_MODULE;     \
    Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Group->LockTable[_fmpLockIndx].LineNumber = __LINE__; \
    Group->LockIndex = ++_fmpLockIndx;      \
}    

#define FmpTryAcquireLocalGroupLock( Group, Locked )   \
{                                               \
    DWORD _fmpLockIndx;                         \
    Locked = TryEnterCriticalSection( &Group->Lock );   \
    if ( Locked ) {                             \
      _fmpLockIndx = Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
      Group->LockTable[_fmpLockIndx].Module = LOG_MODULE;   \
      Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
      Group->LockTable[_fmpLockIndx].LineNumber = __LINE__; \
      Group->LockIndex = ++_fmpLockIndx;        \
    }                                           \
}    

#define FmpReleaseLocalGroupLock( Group )   \
{                                           \
    DWORD _fmpLockIndx;                     \
    CL_ASSERT(HandleToUlong(Group->Lock.OwningThread) == GetCurrentThreadId()); \
    _fmpLockIndx = Group->UnlockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Group->UnlockTable[_fmpLockIndx].Module = LOG_MODULE;   \
    Group->UnlockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Group->UnlockTable[_fmpLockIndx].LineNumber = __LINE__; \
    Group->UnlockIndex = ++_fmpLockIndx;    \
    LeaveCriticalSection( &Group->Lock );   \
}    

#define FmpAcquireLocalResourceLock( Resource )     \
{                                           \
    DWORD _fmpLockIndx;                     \
    PFM_GROUP pGroup;                       \
    while( 1 ) {                            \
        pGroup = Resource->Group;           \
        EnterCriticalSection( &pGroup->Lock );\
        if( pGroup == Resource->Group ) break;   \
        LeaveCriticalSection( &pGroup->Lock );  \
    }                                       \
    _fmpLockIndx = Resource->Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Resource->Group->LockTable[_fmpLockIndx].Module = LOG_MODULE;   \
    Resource->Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Resource->Group->LockTable[_fmpLockIndx].LineNumber =  __LINE__; \
    Resource->Group->LockIndex = ++_fmpLockIndx;    \
}    

#define FmpReleaseLocalResourceLock( Resource ) \
{                                           \
    DWORD _fmpLockIndx;                     \
    CL_ASSERT(HandleToUlong(Resource->Group->Lock.OwningThread) == GetCurrentThreadId()); \
    _fmpLockIndx = Resource->Group->UnlockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Resource->Group->UnlockTable[_fmpLockIndx].Module = LOG_MODULE;     \
    Resource->Group->UnlockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Resource->Group->UnlockTable[_fmpLockIndx].LineNumber = __LINE__; \
    Resource->Group->UnlockIndex = ++_fmpLockIndx;    \
    LeaveCriticalSection( &Resource->Group->Lock );  \
}    

#define FmpTryAcquireLocalResourceLock( Resource, _Status_ )     \
{                                                                \
    (_Status_) = TryEnterCriticalSection(&Resource->Group->Lock); \
    if ( !(_Status_) ) { \
        Sleep(100);                                               \
        (_Status_) = TryEnterCriticalSection( &Resource->Group->Lock ); \
    }                                                               \
    if (_Status_) {                                                 \
        DWORD _fmpLockIndx;                                         \
        _fmpLockIndx = Resource->Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1); \
        Resource->Group->LockTable[_fmpLockIndx].Module = LOG_MODULE; \
        Resource->Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
        Resource->Group->LockTable[_fmpLockIndx].LineNumber = __LINE__; \
        Resource->Group->LockIndex = ++_fmpLockIndx;                \
    }   \
}    
    

#else // DBG

#define FmpAcquireLocalGroupLock( Group )   \
    EnterCriticalSection( &Group->Lock )

#define FmpTryAcquireLocalGroupLock( Group, Locked )   \
    Locked = TryEnterCriticalSection( &Group->Lock )

#define FmpReleaseLocalGroupLock( Group )   \
    LeaveCriticalSection( &Group->Lock )

#define FmpAcquireLocalResourceLock( Resource )     \
{                                           \
    PFM_GROUP pGroup;                       \
    while( 1 ) {                            \
        pGroup = Resource->Group;           \
        EnterCriticalSection( &pGroup->Lock );\
        if( pGroup == Resource->Group ) break;   \
        LeaveCriticalSection( &pGroup->Lock );  \
    }                                             \
}                                 

#define FmpReleaseLocalResourceLock( Resource )     \
    LeaveCriticalSection( &Resource->Group->Lock )

#define FmpTryAcquireLocalResourceLock( Resource, _result_ )     \
    if ( !((_result_) = TryEnterCriticalSection(&Resource->Group->Lock)) ) { \
        sleep(100);                                               \
        (_result_) = TryEnterCriticalSection( &Resource->Group->Lock ); \
    }

#endif // DBG

//
// Global Data
//
extern CRITICAL_SECTION FmpResourceLock;


//
// Resource Management Routines
//


//
// Interfaces for managing resource trees.
//


DWORD
FmpRestartResourceTree(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpOnlineWaitingTree(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpOfflineWaitingTree(
    IN PFM_RESOURCE Resource
    );


//++
//
// Routine Description:
//
//     Processes the Cluster resource list in the registry. For each
//     resource key found, a cluster resource is created.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--
DWORD
FmpInitResources(
    VOID
    );

VOID
FmpCleanupResources(
    VOID
    );

BOOL
FmpInPossibleListForResource(
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode
    );

    
DWORD
FmpInitResourceTypes(
    VOID
    );

PFM_RESTYPE
FmpCreateResType(
    IN LPWSTR ResTypeName
    );

DWORD
FmpDeleteResType(
    IN PFM_RESTYPE pResType
    );

BOOL
FmpFindResourceType(
    IN PFM_RESTYPE Type,
    IN PBOOL ResourceExists,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );

BOOL
FmpInPossibleListForResType(
    IN PFM_RESTYPE pResType,
    IN PNM_NODE     pNode
    );

DWORD
FmpHandleResourceTypeControl(
    IN PFM_RESTYPE Type,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

BOOL
FmpEnumResTypeNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

VOID
FmpResTypeLastRef(
    IN PFM_RESTYPE Resource
    );

DWORD FmpAddPossibleNodeToList(
    IN LPCWSTR      pmszPossibleNodes,
    IN DWORD        dwStringSize,         
    IN PLIST_ENTRY  pPosNodeList
);    

BOOL
FmpFixupPossibleNodesForResTypeCb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      ResTypeName
);

BOOL
FmpFixupResTypePhase2Cb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      pszResTypeName
);


DWORD
FmpFixupResourceTypesPhase1(
    BOOL    bJoin,
    BOOL    bNmLocalNodeVersionChanged,
    PCLUSTERVERSIONINFO pClusterVersionInfo
);

DWORD
FmpFixupResourceTypesPhase2(
    BOOL    bJoin,
    BOOL    bNmLocalNodeVersionChanged,
    PCLUSTERVERSIONINFO pClusterVersionInfo
);

DWORD FmpDecidePossibleNodeForResType
(
    IN PGUM_VOTE_DECISION_CONTEXT pDecisionContext,
    IN DWORD dwVoteBufLength,
    IN PVOID pVoteBuf,
    IN DWORD dwNumVotes,
    IN BOOL  bDidAllActiveNodesVote,
    OUT LPDWORD pdwOutputBufSize,
    OUT PVOID   *ppOutputBuf
);
    

PFM_RESOURCE
FmpFindResourceByNotifyKey(
    RM_NOTIFY_KEY  NotifyKey
    );

DWORD
FmpTerminateResource(
    IN PFM_RESOURCE  Resource
    );


DWORD
WINAPI
FmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
WINAPI
FmpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
FmpSyncArbitration(
    IN DWORD NewPhase,
    OUT LPDWORD CurrentPhase
    );

DWORD
FmpEnumSortGroups(
    OUT PGROUP_ENUM *ReturnEnum,
    IN PNM_NODE OwnerNode OPTIONAL,
    OUT PBOOL QuorumGroup
    );

VOID
FmpPrepareGroupForOnline(
    IN PFM_GROUP Group
    );

DWORD
FmpSetGroupEnumOwner(
    IN PGROUP_ENUM  pGroupEnum,
    IN PNM_NODE     pDefaultOwnerNode,
    IN PNM_NODE     pDeadNode,
    IN BOOL         bQuorumGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList
    );

DWORD
FmpOnlineGroupList(
    IN PGROUP_ENUM GroupEnum,
    IN BOOL bPrepareQuoForOnline
    );

DWORD FmpOnlineGroupFromList(
    IN PGROUP_ENUM GroupEnum,
    IN DWORD       Index,
    IN BOOL bPrepareQuoForOnline
    );

DWORD FmpOnlineResourceFromList(
    IN PRESOURCE_ENUM GroupEnum
    );

BOOL
FmpEqualGroupLists(
    IN PGROUP_ENUM Group1,
    IN PGROUP_ENUM Group2
    );

DWORD
FmpOnlineGroup(
    IN PFM_GROUP    Group,
    IN BOOL         ForceOnline
    );

DWORD
FmpOfflineGroup(
    IN PFM_GROUP    Group,
    IN BOOL         OfflineQuorum,
    IN BOOL         SetPersistent
    );

DWORD 
FmpDeleteGroup(
    IN PFM_GROUP pGroup
    );

DWORD
FmpMoveGroup(
    IN  PFM_GROUP    Group,
    IN  PNM_NODE     DestinationNode,
    IN  BOOL         ShutdownHandler,
    OUT PNM_NODE     *pChosenDestinationNode,
    IN BOOL          bChooseMostPreferredNode
    );

DWORD
FmpCompleteMoveGroup(
    IN PFM_GROUP    Group,
    IN PNM_NODE     DestinationNode
    );

DWORD
FmpDoMoveGroup(
    IN PFM_GROUP    Group,
    IN PNM_NODE     DestinationNode,
    IN BOOL         bChooseMostPreferredNode
    );

BOOL
FmpGroupCanMove(
    IN PFM_GROUP    Group
    );

DWORD
FmpUpdateChangeGroupName(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NewName
    );


DWORD
FmpUpdateDeleteGroup(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId
    );

BOOL
FmpEnumGroupNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

PNM_NODE
FmpFindAnotherNode(
    IN PFM_GROUP Group,
    IN BOOL  bChooseMostPreferredNode
    );

PNM_NODE
FmpGetPreferredNode(
    IN PFM_GROUP Group
    );

//++
//
// Routine Description:
//
//     Takes appropriate action based on resource state transitions indicated
//     by the Resource Monitor.
//
// Arguments:
//
//     Resource   - The resource which has transitioned.
//
//     NewState   - The new state of Resource.
//
// Return Value:
//
//     None.
//
//--
VOID
FmpHandleResourceTransition(
    IN PFM_RESOURCE   Resource,
    IN CLUSTER_RESOURCE_STATE NewState
    );

DWORD FmpCreateResStateChangeHandler(
    IN PFM_RESOURCE pResource, 
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState
    );

VOID
FmpProcessResourceEvents(
    IN PFM_RESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState
    );
    


VOID
FmpHandleResourceFailure(
    IN PFM_RESOURCE Resource
    );

//
// Group Management Routines
//


//++
//
// Routine Description:
//
//     Processes the Cluster Group list in the registry. For each
//     Group key found, a cluster Group is created.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--

DWORD
FmpInitGroups(
    IN BOOL Initialize
    );

DWORD
FmpCompleteInitGroup(
    IN PFM_GROUP Group
    );

VOID
FmpCleanupGroups(
    IN BOOL  ClusterShutDownEvent 
    );

DWORD
FmpCleanupGroupPhase1(
    IN PFM_GROUP Group,
    IN DWORD     dwTimeOut
    );

DWORD
FmpCleanupGroupsWorker(
    IN PFM_CLEANUP_INFO pFmCleanupInfo
    );

DWORD
FmpCleanupGroupPhase2(
    IN PFM_GROUP Group
    );

DWORD  FmpCleanupQuorumResource(
    IN PFM_RESOURCE Resource
    );

BOOL
FmpInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node,
    IN BOOL      bRecalc,
    IN PFM_RESOURCE pRefResource
    );

BOOL
FmpHigherInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node1,
    IN PNM_NODE  Node2
    );


PFM_GROUP
FmpCreateGroup(
    IN LPWSTR   GroupId,
    IN BOOL     Initialize
    );

DWORD FmpInitializeGroup(
    IN PFM_GROUP Group, 
    IN BOOL Initialize
    );

DWORD
FmpDestroyGroup(
    IN PFM_GROUP Group,
    IN BOOL      bDeleteObjOnly
    );


VOID
FmpSetGroupPersistentState(
    IN PFM_GROUP Group,
    IN CLUSTER_GROUP_STATE State
    );

DWORD
FmpPropagateGroupState(
    IN PFM_GROUP    Group
    );

DWORD
FmpPropagateFailureCount(
    IN PFM_GROUP    Group,
    IN BOOL         NewTime
    );

DWORD
FmpGetGroupListState(
    IN PGROUP_ENUM GroupEnum
    );


DWORD
FmpOfflineGroupList(
    IN PGROUP_ENUM GroupEnum
    );

VOID
FmpGroupLastReference(
    IN PFM_GROUP pGroup
    );


//
// Stuff previously in fmclient.h
//
typedef
DWORD
(WINAPI *PSEND_MSG_ROUTINE) (
    IN PGROUP_ENUM MyGroups,
    IN PGROUP_ENUM OtherGroups,
    OUT PGROUP_ENUM *ResponseOtherGroups,
    OUT PGROUP_ENUM *ResponseMyGroups
    );
//
// Global function prototypes
//

DWORD
FmcOnlineGroupRequest(
    IN PFM_GROUP Group
    );

DWORD
FmcOfflineGroupRequest(
    IN PFM_GROUP Group
    );

DWORD
FmcMoveGroupRequest(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    );

DWORD
FmcTakeGroupRequest(
    IN PNM_NODE DestinationNode,
    IN LPCWSTR GroupId,
    IN PRESOURCE_ENUM ResourceList
    );

DWORD
FmcDeleteGroupRequest(
    IN PFM_GROUP pGroup
);
    

DWORD
FmcOnlineResourceRequest(
    IN PFM_RESOURCE Resource
    );

DWORD
FmcOfflineResourceRequest(
    IN PFM_RESOURCE Resource
    );

DWORD
FmcArbitrateResource(
    IN PFM_RESOURCE Resource
    );

DWORD
FmcFailResource(
    IN PFM_RESOURCE Resource
    );

PFM_RESOURCE
FmcCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD dwFlags
    );

DWORD
FmcDeleteResource(
    IN PFM_RESOURCE Resource
    );

CLUSTER_GROUP_STATE
FmcGetGroupState(
    IN LPCWSTR GroupId,
    OUT LPWSTR *NodeName
    );

DWORD
FmcChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    );

DWORD
FmcResourceControl(
    IN PNM_NODE Node,
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmcResourceTypeControl(
    IN PNM_NODE Node,
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmcGroupControl(
    IN PNM_NODE Node,
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmcPrepareQuorumResChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    );


DWORD
FmcCompleteQuorumResChange(
    IN PFM_RESOURCE pOldQuoRes,
    IN LPCWSTR      lpszOldQuoLogPath
    );

DWORD
FmcBackupClusterDatabase(
    IN PFM_RESOURCE pQuoResource,
    IN LPCWSTR      lpszPathName
    );

DWORD
FmcChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    );

DWORD
FmcAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    );

DWORD
FmcRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    );
    

DWORD
FmpGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmpHandleGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmpTakeGroupRequest(
    IN PFM_GROUP Group,
    IN PRESOURCE_ENUM ResourceList
    );

CLUSTER_GROUP_STATE
FmpGetGroupState(
    IN PFM_GROUP Group,
    IN BOOL      IsNormalized
    );

VOID
FmpDeleteEnum(
    IN PGROUP_ENUM Enum
    );

DWORD
FmpClaimAllGroups(
    PGROUP_ENUM MyGroups
    );

DWORD
FmpAssignOwnersToGroups(
    IN PNM_NODE pDeadNode,
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList
    );


VOID
FmpPruneGroupOwners(
    IN PFM_GROUP Group
    );

DWORD
FmpQueryGroupNodes(
    IN PFM_GROUP Group,
    IN HDMKEY hGroupKey
    );

DWORD
FmpUpdateChangeClusterName(
    IN BOOL SourceNode,
    IN LPCWSTR NewName
    );

DWORD
FmpUpdateChangeQuorumResource(
    IN BOOL SourceNode,
    IN LPCWSTR  NewQuorumResId,
    IN LPCWSTR  pszQuorumLogPath,
    IN LPDWORD  pdwMaxQuorumLogSize
    );

DWORD
FmpUpdateResourceState(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN PGUM_RESOURCE_STATE ResourceState
    );

DWORD
FmpUpdateGroupState(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId,
    IN PGUM_GROUP_STATE ResourceState
    );

DWORD
FmpUpdateGroupNode(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId
    );

DWORD
FmpUpdateGroupIntendedOwner(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszGroupId,
    IN PDWORD   pdwNodeId
    );
    
//
// Handle group property requests
//

DWORD
FmpGroupEnumCommonProperties(
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupEnumPrivateProperties(
    IN PFM_GROUP    Group,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupGetCommonProperties(
    IN PFM_GROUP    Group,
    IN BOOL         ReadOnly,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupValidateCommonProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupSetCommonProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupGetPrivateProperties(
    IN PFM_GROUP    Group,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupValidatePrivateProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupSetPrivateProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupGetFlags(
    IN PFM_GROUP    Group,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

//property parse routines
DWORD FmpGetDiskInfoParseProperties(
    IN PUCHAR   InBuffer,
    IN DWORD    InBufferSize,
    IN OUT LPWSTR  pszPath
    );

DWORD
FmpBroadcastDeleteControl(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpBroadcastDependencyChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR DependsOnId,
    IN BOOL Remove
    );

BOOL
FmpCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    );


DWORD FmpVotePossibleNodeForResType(
    IN  DWORD dwInputBufLength,
    IN  LPCWSTR lpszResType,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
);

DWORD
FmpUpdatePossibleNodeForResType(
    IN BOOL         SourceNode,
    IN LPCWSTR      lpszResTypeName,
    IN LPDWORD      pdwBufLength,
    IN PVOID        pBuf
    );

DWORD
FmpUpdateChangeResourceNode(
    IN BOOL         SourceNode,
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode,
    IN DWORD        dwControlCode
    );

DWORD FmpUpdateChangeResourceGroup(
    IN BOOL         bSourceNode,
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    );

DWORD FmpChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR NodeId,
    IN BOOL Add

    );

DWORD
FmpFixupPossibleNodesForResources(
    BOOL    bJoin
    );

BOOL
FmpEnumFixupPossibleNodesForResource(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      pszResName
    );

DWORD
FmpQueueTimerActivity(
    IN DWORD                dwInterval,
    IN PFN_TIMER_CALLBACK   pfnTimerCb, 
    IN PVOID                pContext    
);    

DWORD
FmpDelayedStartRes(
    IN PFM_RESOURCE pResource
    );

//timer callback functions
void
WINAPI
FmpReslistOnlineRetryCb(
    IN HANDLE   hTimer,
    IN PVOID    pContext
);

VOID 
FmpDelayedRestartCb(
    IN HANDLE hTimer, 
    IN PVOID pContext
);

DWORD
FmpDoMoveGroupOnFailure(
    IN LPVOID pContext
    );

DWORD   
FmpSetOwnerForGroup(
    IN PFM_GROUP pGroup,
    IN PNM_NODE  pNode
    );

DWORD   
FmpSetIntendedOwnerForGroup(
    IN PFM_GROUP    pGroup,
    IN DWORD        dwNodeId
    );

VOID
FmpResetGroupIntendedOwner(
    IN PGROUP_ENUM  pGroupEnum
    );

DWORD
FmpGetGroupInNodeGroupList(
    OUT PGROUP_ENUM *pReturnEnum,
    IN PFM_GROUP pGroup,
    IN PNM_NODE pDeadNode,
    OUT PBOOL pbQuorumGroup
    );
    
VOID
FmpPrepareGroupEnumForOnline(
    IN PGROUP_ENUM pGroupEnum
    );

DWORD
FmpRmExceptionFilter(
    DWORD ExceptionCode
    );

DWORD
FmpBringQuorumGroupListOnline(
    IN LPVOID pContext
    );

DWORD
FmpHandleNodeDownEvent(
    IN  PVOID pContext
    );

DWORD
FmpEnumerateGroupResources(
    IN PFM_GROUP pGroup,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE pfnEnumerationRoutine,
    IN PVOID pContext1,
    IN PVOID pContext2
    );

PNM_NODE
FmpGetNonLocalPreferredNode(
    IN PFM_GROUP Group
    );

DWORD 
FmpGetResourceCharacteristics(
    IN PFM_RESOURCE pQuoResource, 
    OUT LPDWORD pdwCharacteristics
    );
    
BOOL
FmpIsAnyResourcePersistentStateOnline(
    IN PFM_GROUP pGroup
    );

PNM_NODE
FmpGetNodeNotHostingUndesiredGroups(
    IN PFM_GROUP pGroup,
    IN BOOL fRuleOutLocalNode
    );

BOOL
FmpCheckForAntiAffinityProperty(
    IN LPCWSTR lpszLimitOneGroupPerName,
    IN PGROUP_AFFINITY_NODE_INFO pGroupAffinityNodeInfo,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupName
    );

DWORD
FmpUpgradeResourceDLL(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszInstallationPath
    );

DWORD
FmpParsePathForFileName(
    IN LPWSTR lpszPath,
    IN BOOL fCheckPathExists,
    OUT LPWSTR *ppszFileName
    );

DWORD
FmpValidateResourceDLLReplacement(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszNewDllName,
    OUT LPWSTR lpszCurrentDllPath
    );

DWORD
FmpReplaceResourceDLL(
    IN LPWSTR lpszNewDllName,
    IN LPWSTR lpszCurrentDllPath,
    IN LPWSTR lpszInstallationPath
    );

DWORD
FmpRecycleMonitors(
    IN LPCWSTR lpszDllName
    );

DWORD
FmpCreateMonitorList(
    IN LPCWSTR lpszDllName,
    OUT PFM_MONITOR_ENUM_HEADER pMonitorHeader
    );

BOOL
FmpFindHostMonitors(
    IN LPCWSTR lpszDllName,
    IN OUT PFM_MONITOR_ENUM_HEADER pMonitorEnumHeader,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR lpszResourceId
    );

DWORD
FmpRecoverResourceDLLFiles(
    VOID
    );

DWORD
FmpResetMultiSzValue(
    IN  HKEY hKey,
    IN  LPWSTR lpmszList,
    IN  OUT LPDWORD pcchLen,
    IN  LPCWSTR lpszValueName,
    IN  LPCWSTR lpszString 
    );

DWORD
FmpCopyBackupFile(
    IN LPCWSTR  lpszPath
    );

VOID
FmpDeleteBackupFiles(
    IN LPCWSTR  lpszPath    OPTIONAL
    );

PNM_NODE
FmpPickNodeFromPreferredListAtRandom(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pSuggestedPreferredNode  OPTIONAL,
    IN BOOL fRuleOutLocalNode,
    IN BOOL fCheckForDisablingRandomization
    );

BOOL
FmpIsNodeUserPreferred(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pPreferredNode
    );

DWORD
FmpPrepareGroupNodeList(
    OUT PFM_GROUP_NODE_LIST *ppGroupNodeList
    );

DWORD
FmpAddGroupNodeToList(
    IN PFM_GROUP_NODE_LIST *ppGroupNodeList,
    IN LPDWORD pcbBuffer,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupId
    );

PNM_NODE
FmpParseGroupNodeListForPreferredOwner(
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList,
    IN PNM_NODE pSuggestedPreferredNode
    );

DWORD
FmpUpdateUseRandomizedNodeListForGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId,
    IN PFM_GROUP_NODE_LIST  pGroupNodeList
    );

#endif //ifndef _FMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmval.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmval.c
    
Abstract:

    Cluster manager api validation/support routines.

Author:

    Sunita Shrivastava (sunitas) 29-April-1999.

Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE FMVAL

////////////////////////////////////////////////////////
//
// Validation routines for Group operations.
//
////////////////////////////////////////////////////////

DWORD
FmpValOnlineGroup(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Validation routine before group is brought online.

Arguments:

    Group - Supplies a pointer to the group structure to bring online.

Comments:

    Is called with the localgroup lock held

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY     listEntry;


    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Make sure the owning node can run the group.
    //
    if ( !FmpInPreferredList( Group, Group->OwnerNode ) ) 
    {
        dwStatus = ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST;
        goto FnExit;
    }

    //
    // Make sure the owning node is not paused.
    //
    if (NmGetNodeState(Group->OwnerNode) == ClusterNodePaused) 
    {
        dwStatus = ERROR_SHARING_PAUSED;
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpValOnlineGroup


DWORD
FmpValMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    )

/*++

Routine Description:

    Validation routine for group move.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to THE OTHER node.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    
    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( FmpIsGroupPending(Group) ) 
    {
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( Group->OwnerNode == NULL ) 
    {
        dwStatus = ERROR_HOST_NODE_NOT_AVAILABLE;
        goto FnExit;
    }            

FnExit:
    return(dwStatus);

} // FmpValMoveGroup

////////////////////////////////////////////////////////
//
// Validation routines for resource operations
//
////////////////////////////////////////////////////////

DWORD
FmpValCreateResource(
    IN PFM_GROUP        Group,
    IN LPWSTR           ResourceId,
    IN LPCWSTR          ResourceName,
    OUT PGUM_CREATE_RESOURCE  *ppGumResource,
    OUT PDWORD          pdwBufSize
    )

/*++

Routine Description:

    Validation routine for resource creation.

Arguments:

    Group - Supplies the group in which this resource belongs.

    ResourceId - Supplies the Id of the resource to create.

    ResourceName - Supplies the 'user-friendly' name of the resource.

    ppGumResource - Message buffer to hold resource info.

    pdwBufSize - Message buffer size.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.


--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    PFM_RESOURCE    Resource;
    LPCWSTR         GroupId;
    PGUM_CREATE_RESOURCE GumResource;
    DWORD           GroupIdLen;
    DWORD           ResourceIdLen;
    DWORD           ResourceNameLen;
    DWORD           BufSize;
    HDMKEY          ResourceKey;
    HDMKEY          ParamsKey;
    DWORD           Disposition;

    *ppGumResource = NULL;
    *pdwBufSize = 0;
    
    //
    // First create the parameters field.
    //
    ResourceKey = DmOpenKey( DmResourcesKey,
                             ResourceId,
                             MAXIMUM_ALLOWED );
    if ( ResourceKey == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] CreateResource: Failed to open registry key for %1!ws!, status = %2!u!.\n",
                   ResourceId,
                   GetLastError() );
        dwStatus = GetLastError();
        goto FnExit;
    } 
    
    ParamsKey = DmCreateKey( ResourceKey,
                             CLUSREG_KEYNAME_PARAMETERS,
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &Disposition );
    if ( ParamsKey != NULL ) 
    {
        DmCloseKey( ParamsKey );
    }
    DmCloseKey( ResourceKey );

    //
    // Allocate a message buffer.
    //
    GroupId = OmObjectId(Group);
    GroupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
    ResourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
    ResourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
    BufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
              GroupIdLen + ResourceIdLen + ResourceNameLen;
    GumResource = LocalAlloc(LMEM_FIXED, BufSize);
    if (GumResource == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Fill in message buffer.
    //
    GumResource->Resource = NULL;
    GumResource->GroupIdLen = GroupIdLen;
    GumResource->ResourceIdLen = ResourceIdLen;
    CopyMemory(GumResource->GroupId, GroupId, GroupIdLen);
    CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen,
               ResourceId,
               ResourceIdLen);
    CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen,
               ResourceName,
               ResourceNameLen);



    *ppGumResource = GumResource;
    *pdwBufSize = BufSize;

FnExit:    
    return(dwStatus);

} // FmpValCreateResource



DWORD
FmpValDeleteResource(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Validation routine for delete resource.

Arguments:

    Resource - Supplies the resource to delete.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;


    //
    // Check if this is the quorum resource.
    //
    if ( pResource->QuorumResource ) 
    {
        dwStatus = ERROR_QUORUM_RESOURCE;
        goto FnExit;
    }

    //other core resources cannot be deleted either
    if (pResource->ExFlags & CLUS_FLAG_CORE)
    {
        dwStatus = ERROR_CORE_RESOURCE;
        goto FnExit;
    }

    //
    // Check the state of the resource, before attempting to delete it.
    // It must be offline or failed in order to perform the delete.
    //
    if ((pResource->State != ClusterResourceOffline) &&
        (pResource->State != ClusterResourceFailed)) 
    {
        dwStatus = ERROR_RESOURCE_ONLINE;
        goto FnExit;
    }

    //
    // Check whether this resource provides for any other resources.
    // If so, it cannot be deleted.
    //
    if (!IsListEmpty(&pResource->ProvidesFor)) 
    {
        dwStatus = ERROR_DEPENDENT_RESOURCE_EXISTS;
        goto FnExit;
    }

    if (pResource->Group->MovingList)
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }
        
FnExit:
    return(dwStatus);

} // FmpValDeleteResource


DWORD
FmpValOnlineResource(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    This routine validates if a resource can be brought online.

Arguments:

    Resource - A pointer to the resource to bring online.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/
{

    DWORD   dwStatus = ERROR_SUCCESS;
    
    //if the resource has been marked for delete, then dont let
    //it be brought online
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Check if the resource has been initialized. If not, attempt
    // to initialize the resource now.
    //
    if ( pResource->Monitor == NULL )
    {
        dwStatus = FmpInitializeResource( pResource, TRUE );
    }

FnExit:
    return(dwStatus);
} // FmpValOnlineResource


DWORD
FmpValOfflineResource(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    This routine validates if a given resource can be taken offline.

Arguments:

    Resource - A pointer to the resource to take offline.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;


    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Check if this is the quorum resource.
    //
    if ( pResource->QuorumResource ) 
    {
        dwStatus = ERROR_QUORUM_RESOURCE;
        goto FnExit;
    }

    //
    // Check if the resource has been initialized. If not, return
    // success because the resource is not online.
    //
    if ( pResource->Monitor == NULL ) 
    {
        dwStatus = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 4/8/99
    //  
    //  Don't attempt to do anything if the resource has failed. You could
    //  get into some funny cases in which the resource switches between
    //  offline pending and failed states for ever.
    //
    if ( pResource->State == ClusterResourceFailed ) 
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }
    
FnExit:
    return(dwStatus);

} // FmpValOfflineResource



DWORD
FmpValAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Validation routine for dependency addition.

Arguments:

    Resource - The resource to add the dependent resource.

    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    //if the resource has been marked for delete, then dont let
    //it be brought online
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if (pResource->QuorumResource)
    {
        dwStatus = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }
    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((pResource->Group != pDependentResource->Group) ||
        (pResource == pDependentResource)) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // The resource to which the dependency is being added must be offline
    // Otherwise, it looks like the dependency is in effect when the depending
    // resource was not really brought online at the time the dependency existed
    // must also be offline or failed.
    // SS:  For instance if a network name is dependent on two ip addresesses and
    // is online and a third ip address resource dependency is added, the
    // network name must be brought offline and online for the dependency
    // to be truly in effect
    //
    if ((pResource->State != ClusterResourceOffline) &&
         (pResource->State != ClusterResourceFailed)) 
    {
        dwStatus = ERROR_RESOURCE_ONLINE;
        goto FnExit;
    }

    //
    // Make sure that we don't have any circular dependencies!
    //
    if ( FmDependentResource( pDependentResource, pResource, FALSE ) ) 
    {
        dwStatus = ERROR_CIRCULAR_DEPENDENCY;
        goto FnExit;
    }

    //
    // Make sure that this dependency does not already exist!
    //
    if ( FmDependentResource(pResource, pDependentResource, TRUE)) 
    {
        dwStatus = ERROR_DEPENDENCY_ALREADY_EXISTS;
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpValAddResourceDependency


DWORD
FmpValChangeResourceNode(
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      pszNodeId,
    IN BOOL         bAdd,
    OUT PGUM_CHANGE_POSSIBLE_NODE *ppGumChange,
    OUT PDWORD      pdwBufSize
    )

/*++

Routine Description:

    Validation routine for changing the possible owner node of a resource.

Arguments:

    pResource - A pointer to the resource structure.

    pszNodeId - A pointer to the node id

    bAdd - Indicates add or remove

    ppGumChange - Message buffer to hold the resource info

    pdwBufSize - Size of the message buffer
    
Comments: 

    Lock must be held when this routine is called

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    BOOL    bNodeSupportsResType = FALSE;
    LPCWSTR pszResourceId;
    DWORD   dwResourceLen;
    DWORD   dwNodeLen;
    DWORD   dwBufSize;
    PGUM_CHANGE_POSSIBLE_NODE   pGumChange;

    *ppGumChange = NULL;
    *pdwBufSize = 0;


    //if the resource has been marked for delete, then perform
    //any operations on it
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( pResource->QuorumResource ) 
    {
        dwStatus = ERROR_INVALID_OPERATION_ON_QUORUM;
        goto FnExit;
    }

    //
    // We can't allow the owner node to be removed if the state
    // of the resource or the group is not offline or failed.
    //
    if ( !bAdd &&
         (pszNodeId == OmObjectId(NmLocalNode)) &&
         (((pResource->State != ClusterResourceOffline) &&
            (pResource->State != ClusterResourceFailed)) ||
         (FmpGetGroupState( pResource->Group, TRUE ) != ClusterGroupOffline)) ) 
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }

    //make sure the node is on the list of possible nodes for this
    // resource type
    if (bAdd)
    {
        pListEntry = &(pResource->Type->PossibleNodeList);
        for (pListEntry = pListEntry->Flink; 
            pListEntry != &(pResource->Type->PossibleNodeList);
            pListEntry = pListEntry->Flink)
        {    

            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

            if (!lstrcmpW(OmObjectId(pResTypePosEntry->PossibleNode), pszNodeId))
            {
                bNodeSupportsResType = TRUE;
                break;
            }            
                    
        }    
    
        if (!bNodeSupportsResType)
        {
            dwStatus = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }
    }
    
    pszResourceId = OmObjectId(pResource);
    dwResourceLen = (lstrlenW(pszResourceId)+1)*sizeof(WCHAR);

    dwNodeLen = (lstrlenW(pszNodeId)+1)*sizeof(WCHAR);

    dwBufSize = sizeof(GUM_CHANGE_POSSIBLE_NODE) - sizeof(WCHAR) + 
                    dwResourceLen + dwNodeLen;
    pGumChange = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pGumChange == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pGumChange->ResourceIdLen = dwResourceLen;
    CopyMemory(pGumChange->ResourceId, pszResourceId, dwResourceLen);
    CopyMemory((PCHAR)pGumChange->ResourceId + dwResourceLen,
               pszNodeId,
               dwNodeLen);


    *ppGumChange = pGumChange;
    *pdwBufSize = dwBufSize;

FnExit:    
    return(dwStatus);
} // FmpValChangeResourceNode


DWORD
FmpValChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup,
    OUT PGUM_CHANGE_GROUP  *ppGumChange,
    OUT LPDWORD     pdwBufSize)
/*++

Routine Description:

    Validation routine for changing a resource's group.

Arguments:

    pResource - Pointer to the resource structure

    pNewGroup - Pointer to the group to which the resource is moved to

    ppGumChange - Message buffer to hold the resource info

    pdwBufSize - Size of the message buffer

Comments: 

    Lock must be held when this routine is called

Returns:

    ERROR_SUCCESS if validation is successful.

    A Win32 error code otherwise.

--*/
{
    DWORD               dwBufSize;
    LPCWSTR             pszResourceId;
    DWORD               dwResourceLen;
    LPCWSTR             pszGroupId;
    DWORD               dwGroupLen;
    DWORD               dwStatus = ERROR_SUCCESS;
    PGUM_CHANGE_GROUP   pGumChange;
    
    *pdwBufSize = 0;
    *ppGumChange = NULL;

    // we need to validate here as well
    // this is called by the server side
    // this will help avoid a gum call if things have changed
    // since the request started from the originator
    // and got to the server
    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Check if we're moving to same group.
    //
    if (pResource->Group == pNewGroup) 
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //
    // For now... both Groups must be owned by the same node.
    //
    if ( pResource->Group->OwnerNode != pNewGroup->OwnerNode ) 
    {
        dwStatus = ERROR_HOST_NODE_NOT_GROUP_OWNER;
        goto FnExit;
    }


    pszResourceId = OmObjectId(pResource);
    dwResourceLen = (lstrlenW(pszResourceId)+1)*sizeof(WCHAR);

    pszGroupId = OmObjectId(pNewGroup);
    dwGroupLen = (lstrlenW(pszGroupId)+1)*sizeof(WCHAR);

    dwBufSize = sizeof(GUM_CHANGE_GROUP) - sizeof(WCHAR) + dwResourceLen + dwGroupLen;
    pGumChange = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pGumChange == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    pGumChange->ResourceIdLen = dwResourceLen;
    CopyMemory(pGumChange->ResourceId, pszResourceId, dwResourceLen);
    CopyMemory((PCHAR)pGumChange->ResourceId + dwResourceLen,
               pszGroupId,
               dwGroupLen);

    *ppGumChange = pGumChange;
    *pdwBufSize = dwBufSize;
    
FnExit:
    return(dwStatus);
} // FmpValChangeResourceGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\fmvote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmvote.c

Abstract:

    Cluster FM Global Update processing routines.

Author:

    Sunita shrivastava (sunitas) 24-Apr-1996


Revision History:


--*/

#include "fmp.h"

#include "ntrtl.h"

#define LOG_MODULE FMVOTE


/****
@func       DWORD | FmpGumVoteHandler| This is invoked by gum when fm requests
            a vote for a given context.

@parm       IN DWORD | dwContext| The gum update type for which the vote is
            being collected.
            
@parm       IN DWORD | dwInputBufLength| The length of the input buffer.

@parm       IN PVOID | pInputBuf| A pointer to the input buffer based on 
            which a vote must be cast.

@parm       IN DWORD | dwVoteLength | The length of the buffer pointed to
            by pVoteBuf.

@parm       OUT POVID | pVoteBuf | A pointer to a buffer of size dwVoteLength
            where the vote must be cast.

            
@comm       The votes are collected by gum and returned to the node that is taking
            the poll.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/

DWORD
WINAPI
FmpGumVoteHandler(
    IN  DWORD dwContext,
    IN  DWORD dwInputBufLength,
    IN  PVOID pInputBuf,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
)
{

    DWORD  dwStatus = ERROR_SUCCESS;
    
    if ( !FmpFMGroupsInited  ||
         FmpShutdown ) 
    {
        return(ERROR_NOT_READY);
    }

    switch ( dwContext ) 
    {
        case FmUpdatePossibleNodeForResType:
            dwStatus = FmpVotePossibleNodeForResType(dwInputBufLength, 
                (LPCWSTR)pInputBuf, dwVoteLength, pVoteBuf);
            break;
            
        default:
            dwStatus = ERROR_REQUEST_ABORTED;
            

    }

    return(dwStatus);

} // FmpGumVoteHandler


/****
@func       DWORD | FmpGumVoteHandler| This is invoked by gum when fm requests
            a vote for a given context.

@parm       IN DWORD | dwContext| The gum update type for which the vote is
            being collected.
            
@parm       IN DWORD | dwInputBufLength| The length of the input buffer.

@parm       IN PVOID | pInputBuf| A pointer to the input buffer based on 
            which a vote must be cast.

@parm       IN DWORD | dwVoteLength | The length of the buffer pointed to
            by pVoteBuf.

@parm       OUT POVID | pVoteBuf | A pointer to a buffer of size dwVoteLength
            where the vote must be cast.

            
@comm       The votes are collected by gum and returned to the node that is taking
            the poll.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/

DWORD FmpVotePossibleNodeForResType(
    IN  DWORD dwInputBufLength,
    IN  LPCWSTR lpszResType,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwVoteStatus;
    PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE pVoteResType;
    PFM_RESTYPE pResType=NULL;

    
    if (dwVoteLength != sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE))
        return (ERROR_INVALID_PARAMETER);

    pVoteResType = (PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE)pVoteBuf;

    pResType = OmReferenceObjectById(ObjectTypeResType, lpszResType);

    if (!pResType)
        return (ERROR_INVALID_PARAMETER);
        
    dwVoteStatus = FmpRmLoadResTypeDll(pResType);

    pVoteResType->dwNodeId = NmLocalNodeId;
    pVoteResType->dwSize = sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE);
    if (dwVoteStatus == ERROR_SUCCESS)
        pVoteResType->bPossibleNode = TRUE;
    else
        pVoteResType->bPossibleNode = FALSE;


    if (pResType) OmDereferenceObject(pResType);
    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\group.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    group.c

Abstract:

    Cluster group management routines.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Notes:

    WARNING: All of the routines in this file assume that the group
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE GROUP

//
// Global Data
//

CRITICAL_SECTION  FmpGroupLock;



//
// Local function prototypes
//


/////////////////////////////////////////////////////////////////////////////
//
// Group Management Routines
//
/////////////////////////////////////////////////////////////////////////////

BOOL
FmpInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node,
    IN BOOL      bRecalc,
    IN PFM_RESOURCE pRefResource
    )

/*++

Routine Description:

    Check if a node is in the preferred list for the Group.

Arguments:

    Group - Pointer to the group object with the preferred owners list.

    Node - The Node to check for.

    bRecalc - If set to TRUE, we recalculate the preferred list for the group 
        based on the possible node list for the reference resource.

    pRefResource - If NULL, we walk all the resources in the
        group and calculate their possible node list to see
        if it has since expanded due to the fact that dlls
        were copied to nodes.
        
Return Value:

    TRUE - if the node is in the list.
    FALSE - if the node is NOT in the list.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;
    BOOL             bRet = FALSE;
    //
    // For each entry in the Preferred list, it must exist in the possible
    // list.
    //
ChkInPrefList:
    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        if ( preferredEntry->PreferredNode == Node ) {
            return(TRUE);
        }
    }

    if (bRecalc)
    {
        PFM_RESOURCE    pResource;
        DWORD           dwStatus;
        LPWSTR          lpszOwners = NULL;
        DWORD           dwMaxSize=0;
        HDMKEY          hGroupKey;
        DWORD           dwSize = 0;

        hGroupKey = DmOpenKey(DmGroupsKey, OmObjectId(Group),
                        KEY_READ);
        if (hGroupKey == NULL)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmInPreferredList: Couldnt open group key\r\n",
                dwStatus);
            CL_UNEXPECTED_ERROR(dwStatus);
            goto FnExit;
        }
        //the group preferred list must not be set by the user
        //if it is then there is no point in doing this recalculation
        dwStatus = DmQueryMultiSz( hGroupKey,
                             CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                             &lpszOwners,
                             &dwMaxSize,
                             &dwSize );
        if (lpszOwners) 
            LocalFree(lpszOwners);
        DmCloseKey(hGroupKey);            
        if (dwStatus == ERROR_FILE_NOT_FOUND)
        {
            DWORD   dwUserModified;
            
            for (listEntry = Group->Contains.Flink;
                listEntry != &(Group->Contains);
                listEntry = listEntry->Flink)
            {            
                pResource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);

                //the resource possible node list must not be set by the user
                //if it is, then we can skip this resource
                dwStatus = DmQueryDword( pResource->RegistryKey,
                             CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST,
                             &dwUserModified,
                             NULL );
                if (dwStatus == ERROR_FILE_NOT_FOUND)
                {
                    FmpSetPossibleNodeForResType(OmObjectId(pResource->Type), 
                        TRUE);
                    if (FmpInPossibleListForResType(pResource->Type,Node) && 
                        !FmpInPossibleListForResource(pResource, Node))
                    {
                        //add to the resource possible node list
                        //this will or add to the pref list of the group
                        FmChangeResourceNode(pResource, Node, TRUE);
                    }
                }
            }     
            //set bRecalc to be FALSE so that we dont evaluate this again
            bRecalc = FALSE;
            goto ChkInPrefList;
        }        
    }
FnExit: 
    return(bRet);

} // FmpInPreferredList



BOOL
FmpHigherInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node1,
    IN PNM_NODE  Node2
    )

/*++

Routine Description:

    Check if Node1 is higher (in priority) in the preferred owners list than
    Node1.

Arguments:

    Group - Pointer to the group object with the preferred owners list.

    Node1 - The Node that should be higher in the list.

    Node2 - The Node that should be lower in the list.

Return Value:

    TRUE - if Node1 is higher in the list.
    FALSE - if Node2 is higher in the list, or Node1 is not in the list at all.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;
    DWORD            orderedOwners = 0;

    //
    // For each entry in the Preferred list, check whether Node1 or Node2 is
    // higher.
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners),
            orderedOwners < Group->OrderedOwners;
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        if ( preferredEntry->PreferredNode == Node1 ) {
                return(TRUE);
        }
        if ( preferredEntry->PreferredNode == Node2 ) {
                return(FALSE);
        }
        orderedOwners++;
    }

    return(FALSE);

} // FmpHigherInPreferredList



DWORD
FmpSetPreferredEntry(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node
    )

/*++

Routine Description:

    Add a node to the preferred list for the Group.

Arguments:

    Group - Pointer to the group object with the preferred owners list.

    Node - The Node to add.

Return Value:

    ERROR_SUCCESS if node is added.
    ERROR_NOT_ENOUGH_MEMORY on failure.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;

    //
    // Make sure entry is not already present in list.
    //
    if ( FmpInPreferredList( Group, Node, FALSE, NULL ) ) {
        return(ERROR_SUCCESS);
    }

    //
    // Create the Preferred Owners List entry.
    //
    preferredEntry = LocalAlloc( LMEM_FIXED, sizeof(PREFERRED_ENTRY) );

    if ( preferredEntry == NULL ) {
        ClRtlLogPrint( LOG_ERROR,
                    "[FM] Error allocating preferred owner entry for group %1!ws!. Stopped adding.\n",
                    OmObjectId(Group));
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Create the preferred owner entry and keep a reference on the node object.
    //
    OmReferenceObject( Node );

    preferredEntry->PreferredNode = Node;
    InsertTailList( &Group->PreferredOwners,
                    &preferredEntry->PreferredLinkage );

    return(ERROR_SUCCESS);

} // FmpSetPreferredEntry

BOOL FmpFindNodeThatMightBeAddedToPrefList(
    IN PFM_GROUP    pGroup,
    IN PNM_NODE     *pDestNode,
    IN PVOID pNode, 
    IN LPCWSTR szName)
{
    BOOL    bRet = TRUE;   //assume we will continue enumeration

    *pDestNode = NULL;
    //if this node is not up or if this is the local node, continue
    if ((pNode == NmLocalNode) || (NmGetNodeState(pNode) != ClusterNodeUp))
    {
        return(bRet);
    }
    if (FmpInPreferredList(pGroup, pNode, TRUE, NULL))
    {    
        bRet = FALSE;
        *pDestNode = pNode;
    }        
    return(bRet);
}



PNM_NODE
FmpFindAnotherNode(
    IN PFM_GROUP Group,
    IN BOOL  bChooseMostPreferredNode
    )

/*++

Routine Description:

    Check if another node is up that can take the group.

Arguments:

    Group - Pointer to the group object we're checking.

    bChooseMostPreferredNode - Whether to choose the most preferred node or not.

Return Value:

    Pointer to node object that the group can move to.

    NULL if another system is not found.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;
    PNM_NODE	first = NULL;
    BOOLEAN	flag = FALSE;

    //
    //  First, let us give the anti-affinity algorithm a shot at picking the node.
    //
    first = FmpGetNodeNotHostingUndesiredGroups ( Group, 
                                                  TRUE ); // Rule out local node

    if ( first != NULL )
    {
        goto FnExit;
    }

    //
    // For each entry in the Preferred list, find a system (other than the
    // local system that is up).
    //

    if ( bChooseMostPreferredNode )
    {
        first = FmpGetNonLocalPreferredNode( Group );

        //
        //  In this case in which you are doing a user-initiated move, give the randomized
        //  preferred list algorithm a chance to pick the node. Note that if the randomized
        //  algorithm could not pick a node, it will return the supplied suggested node itself.
        //
        if ( first != NULL )
        {
            first = FmpPickNodeFromPreferredListAtRandom ( Group, 
                                                           first,   // Suggested default
                                                           TRUE,    // Dont choose local node
                                                           TRUE );  // Check whether randomization 
                                                                    // should be disabled
        }
    }
    else
    {
        for ( listEntry = Group->PreferredOwners.Flink;
            listEntry != &(Group->PreferredOwners);
            listEntry = listEntry->Flink ) {

            preferredEntry = CONTAINING_RECORD( listEntry,
                                                PREFERRED_ENTRY,
                                                PreferredLinkage );

            if ( (preferredEntry->PreferredNode != NmLocalNode) &&
                (NmGetExtendedNodeState(preferredEntry->PreferredNode) == ClusterNodeUp) ) {
	        if (flag == TRUE)
	            return(preferredEntry->PreferredNode);
	        else if (first == NULL)
	            first = preferredEntry->PreferredNode;
            } else if (preferredEntry->PreferredNode == NmLocalNode) {
	            flag = TRUE;
	        }
        }
    }

    //if we couldnt find a node, we retry again since the user might have
    //expanded the possible node list for resource type since then
    //if the group preferred list is not set by the user,
    //we recalculate it since it could have 
    if (first == NULL)
    {
        LPWSTR          lpszOwners = NULL;
        DWORD           dwMaxSize=0;
        HDMKEY          hGroupKey;
        DWORD           dwSize = 0;
        DWORD           dwStatus;
        
        hGroupKey = DmOpenKey(DmGroupsKey, OmObjectId(Group),
                        KEY_READ);
        if (hGroupKey == NULL)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmInPreferredList: Couldnt open group key\r\n",
                dwStatus);
            CL_UNEXPECTED_ERROR(dwStatus);
            goto FnExit;
        }
        //the group preferred list must not be set by the user
        //if it is then there is no point in doing this recalculation
        dwStatus = DmQueryMultiSz( hGroupKey,
                             CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                             &lpszOwners,
                             &dwMaxSize,
                             &dwSize );
        if (lpszOwners) 
            LocalFree(lpszOwners);
        DmCloseKey(hGroupKey);            

    
        if (dwStatus == ERROR_FILE_NOT_FOUND)
            OmEnumObjects(ObjectTypeNode, FmpFindNodeThatMightBeAddedToPrefList,
                Group, &first);
    }
    
FnExit:        
    return(first);

} // FmpFindAnotherNode


PNM_NODE
FmpGetPreferredNode(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Find best node that can take the group

Arguments:

    Group - Pointer to the group object we're checking.

Return Value:

    Pointer to node object that the group can move to.

    NULL if another system is not found.

--*/

{
    PLIST_ENTRY         listEntry;
    PPREFERRED_ENTRY    preferredEntry;
    PNM_NODE            pNode = NULL;

    //
    //  First, let us give the anti-affinity algorithm a shot at picking the node.
    //
    pNode = FmpGetNodeNotHostingUndesiredGroups ( Group, 
                                                  FALSE ); // Don't rule out local node

    if ( pNode != NULL )
    {
        return ( pNode );
    }

    //
    // For each entry in the Preferred list, find a system that is up.
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );

        if (NmGetNodeState(preferredEntry->PreferredNode) == ClusterNodeUp ) {
            return(preferredEntry->PreferredNode);
        }
    }

    return(NULL);

} // FmpGetPreferredNode


PNM_NODE
FmpGetNonLocalPreferredNode(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Find best node that can take the group which is not the local node.

Arguments:

    Group - Pointer to the group object we're checking.

Return Value:

    Pointer to node object that the group can move to.

    NULL if another system is not found.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;

    //
    // For each entry in the Preferred list, find a system (other than the
    // local system that is up).
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );

        if ( preferredEntry->PreferredNode == NmLocalNode ) {
            continue;
        }
        
        if (NmGetNodeState(preferredEntry->PreferredNode) == ClusterNodeUp ) {
            return(preferredEntry->PreferredNode);
        }
    }

    return(NULL);

} // FmpGetNonLocalPreferredNode

BOOL
FmpIsGroupQuiet(
    IN PFM_GROUP Group,
    IN CLUSTER_GROUP_STATE WantedState
    )

/*++

Routine Description:

    Checks if the group has any pending resources.

Arguments:

    Group - the Group to check.

    WantedState - the state the Group wants to get to.

Return Value:

    TRUE - if the Group is not doing anything now.

    FALSE otherwise.

--*/

{
    DWORD           status;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;


    if ( Group->MovingList ) {
        return(FALSE);
    }

    //
    // Check all of the resources contained within this group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);

        switch ( WantedState ) {
        case ClusterGroupOnline:
            // if resource is pending, then offline pending is bad
            if ( Resource->State == ClusterResourceOfflinePending ) {
                return(FALSE);
            }
            break;

        case ClusterGroupOffline:
            // if resource is pending, then online pending is bad
            if ( Resource->State == ClusterResourceOnlinePending ) {
                return(FALSE);
            }
            break;

        default:
            // any pending state is bad
            if ( Resource->State >= ClusterResourcePending ) {
                return(FALSE);
            }
            break;
        }
    }

    return(TRUE);

} // FmpIsGroupQuiet



VOID
FmpSetGroupPersistentState(
    IN PFM_GROUP Group,
    IN CLUSTER_GROUP_STATE State
    )

/*++

Routine Description:

    Sets the PersistentState of a Group. This includes the registry.

Arguments:

    Group - The Group to set the state for.
    State - The new state for the Group.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    The LocalGroupLock must be held.

--*/

{
    DWORD   persistentState;
    LPWSTR  persistentStateName = CLUSREG_NAME_GRP_PERSISTENT_STATE;

    if (!gbIsQuoResEnoughSpace)
        return;

    FmpAcquireLocalGroupLock( Group );

    //
    // If the current state has changed, then do the work. Otherwise,
    // skip the effort.
    //
    if ( Group->PersistentState != State ) {
        Group->PersistentState = State;
        CL_ASSERT( Group->RegistryKey != NULL );
        //
        // Set the new value, but only if it is online or offline.
        //
        if ( State == ClusterGroupOnline ) {
            persistentState = 1;
            DmSetValue( Group->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        } else if ( State == ClusterGroupOffline ) {
            persistentState = 0;
            DmSetValue( Group->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        }
    }

    FmpReleaseLocalGroupLock( Group );

} // FmpSetGroupPersistentState



DWORD
FmpOnlineGroup(
    IN PFM_GROUP Group,
    IN BOOL ForceOnline
    )

/*++

Routine Description:

    Bring the specified group online.  This means bringing all of the
    individual resources contained within the group online.  This is an
    atomic operation - so either all resources contained within the group
    are brought online, or none of them are.

Arguments:

    Group - Supplies a pointer to the group structure to bring online.

    ForceOnline - TRUE if all resources in the Group should be forced online.

Retruns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status, retstatus = ERROR_SUCCESS;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;
    BOOL            bPending = FALSE;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] OnlineGroup for %1!ws! owner %2!d!\n",
               OmObjectId(Group), OmObjectId(Group->OwnerNode));

    FmpAcquireLocalGroupLock( Group );

    //
    // Check if we are the owner... if not, return failure.
    //
    if ( gpQuoResource->Group != Group && 
	  ((Group->OwnerNode != NmLocalNode) ||
         !FmpInPreferredList( Group, Group->OwnerNode, TRUE, NULL) ) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    //
    // Make sure the group is quiet
    //
    if ( !FmpIsGroupQuiet( Group, ClusterGroupOnline ) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_INVALID_STATE);
    }


    //if the quorum group is in this group bring it online first
    //This is called when a node goes down and its groups are
    //being reclaimed, the order in which the resoures are brought
    //online is important
    if ( gpQuoResource->Group == Group)
    {
        //SS:: if the quorum resource is in the group, it must be
        //brought online irrespective of the persistent state
        //so we will pass in true here
        //Apps can mess with persistent state via the common
        //properties and then cause havoc so we need to force the
        //quorum resource online despite that
        status = FmpDoOnlineResource( gpQuoResource,
                                      TRUE );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OnlineGroup: Failed on resource %1!ws!. Status %2!u!\n",
                       OmObjectId(gpQuoResource),
                       status);
            CL_UNEXPECTED_ERROR(status);
        }


    }
    //
    // Bring online all of the resources contained within this group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        status = FmpDoOnlineResource( Resource,
                                      ForceOnline );

        if (status == ERROR_IO_PENDING) {
            bPending = TRUE;
        }

        if ( (status != ERROR_SUCCESS) &&
	     (status != ERROR_NODE_CANT_HOST_RESOURCE) &&
             (status != ERROR_IO_PENDING) ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OnlineGroup: Failed on resource %1!ws!. Status %2!u!\n",
                       OmObjectId(Resource),
                       status);
            retstatus = status;
        }
    }

    //
    // Normally bringing the resources online propagates the group state,
    // but in order to get the state right for a group with no resources,
    // manually propagate the state here.
    //
    FmpPropagateGroupState(Group);

    ClRtlLogPrint(LOG_NOISE,
               "[FM] OnlineGroup: setting group state to Online for %1!ws!\n",
               OmObjectId(Group));

    FmpReleaseLocalGroupLock( Group );

    if (retstatus == ERROR_SUCCESS) {
        if (bPending) {
            retstatus = ERROR_IO_PENDING;
        }
    }

    return(retstatus);

} // FmpOnlineGroup



DWORD
FmpOfflineGroup(
    IN PFM_GROUP Group,
    IN BOOL OfflineQuorum,
    IN BOOL SetPersistent
    )

/*++

Routine Description:

    Bring the specified group offline.  This means bringing all of the
    individual resources contained within the group offline.

Arguments:

    Group - Supplies a pointer to the group structure to bring offline.

    OfflineQuorum - TRUE if any quorum resource in this group should
            be taken offline. FALSE if the quorum resource should be left online.

    SetPersistent - TRUE if the persistent state of each resource should be
            updated.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;
    DWORD           returnStatus = ERROR_SUCCESS;
    PRESOURCE_ENUM  ResourceEnum=NULL;
    DWORD           i;

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineGroup, Group=%1!ws!\n",
               OmObjectId(Group));

    //
    // Check if we are the owner... if not, return failure.
    //
    if ( Group->OwnerNode != NmLocalNode ) {
        returnStatus = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto error_exit;
    }

    //
    // Make sure the group is quiet
    //
    if ( !FmpIsGroupQuiet( Group, ClusterGroupOffline ) ) {
        returnStatus = ERROR_INVALID_STATE;
        goto error_exit;
    }


    //
    // Get the list of resources in the group and their states.
    //
    returnStatus = FmpGetResourceList( &ResourceEnum, Group );
    if ( returnStatus != ERROR_SUCCESS ) {
        goto error_exit;
    }


    // offline all resources except the quorum resource
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        Resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );

        if ( Resource == NULL ) {
            returnStatus = ERROR_RESOURCE_NOT_FOUND;
            goto error_exit;
        }

        //quorum resource is brought offline last
        if (Resource->QuorumResource)
        {
            OmDereferenceObject(Resource);
            continue;
        }
        if (SetPersistent) {
            FmpSetResourcePersistentState( Resource, ClusterResourceOffline );
        }

        status = FmpOfflineResource( Resource, FALSE);

        OmDereferenceObject( Resource );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
             returnStatus = status;
            goto error_exit;
        }
        if ( status == ERROR_IO_PENDING ) {
            returnStatus = ERROR_IO_PENDING;
        }

    }

    // bring the quorum resource offline now, if asked to bring quorum offline
    // This allows other resources to come offline and save their checkpoints
    // The quorum resource offline should block till the resources have
    // finished saving the checkpoint
    if (ResourceEnum->ContainsQuorum >= 0)
    {
        if (!OfflineQuorum)
        {
            //if the quorum resource should not be taken offline
            returnStatus = ERROR_QUORUM_RESOURCE;
        }
        else if (returnStatus == ERROR_SUCCESS)
        {
            CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);

            Resource = OmReferenceObjectById( ObjectTypeResource,
                    ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );

            if ( Resource == NULL ) {
                returnStatus = ERROR_RESOURCE_NOT_FOUND;
                goto error_exit;
            }

            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpOfflineGroup: Bring quorum resource offline\n");

            if ( !(Resource->Flags & RESOURCE_WAITING) ) {
                if (Resource->State != ClusterResourceOffline) {
                    Resource->State = ClusterResourceOnline; // [HACKHACK]
                }
                status = FmpOfflineResource( Resource , FALSE);

                OmDereferenceObject( Resource );

                if ( (status != ERROR_SUCCESS) &&
                     (status != ERROR_IO_PENDING) )
                {
                    returnStatus = status;
                    goto error_exit;
                }
                if ( status == ERROR_IO_PENDING )
                    returnStatus = ERROR_IO_PENDING;
            } else {
                OmDereferenceObject( Resource );
            }
        }
    }

    //
    // Normally bringing the resources offline propagates the group state,
    // but in order to get the state right for a group with no resources,
    // manually propagate the state here.
    //
    if (SetPersistent)
        FmpPropagateGroupState(Group);

error_exit:
    FmpReleaseLocalGroupLock( Group );
    if (ResourceEnum)
            FmpDeleteResourceEnum( ResourceEnum );

    return(returnStatus);

} // FmpOfflineGroup



CLUSTER_GROUP_STATE
FmpGetGroupState(
    IN PFM_GROUP Group,
    IN BOOL      IsNormalized
    )

/*++

Routine Description:

    Get the Group state, either normalized to ClusterGroupOnline or
    ClusterGroupOffline or not normalized.

Arguments:

    Group - The Group we're interested in.

    IsNormalized - Should the Group state be normalized ?

Returns:

    The current Group state which is one of (in increasing order of
    precedence)

        ClusterGroupOnline, ClusterGroupOffline
        ClusterGroupPartialOnline 
        ClusterGroupPending (only if IsNormalized is FALSE)
        ClusterGroupFailed  (only if IsNormalized is FALSE)

--*/

{
    PLIST_ENTRY                 listEntry;
    PFM_RESOURCE                resource;
    CLUSTER_GROUP_STATE         state;
    CLUSTER_RESOURCE_STATE      firstResourceState;
    CLUSTER_RESOURCE_STATE      resourceState;

    // Chittur Subbaraman (chitturs) - 09/16/98 (Modified this function
    // to work with IsNormalized flag)

    FmpAcquireLocalGroupLock( Group );

    if ( !IsListEmpty(&Group->Contains) ) {
        listEntry = Group->Contains.Flink;
        resource = CONTAINING_RECORD(listEntry,
                         FM_RESOURCE,
                         ContainsLinkage);
        //
        // Get the first resource's state
        //
        firstResourceState = resource->State;

        if ( IsNormalized == FALSE ) {
            BOOL    IsPending = FALSE;
            BOOL    IsPartialOnline = FALSE;
            //
            // First check whether any resource in the group has
            // failed. If so, set the group state to ClusterGroupFailed
            // and exit immediately. If no resource in the group has
            // failed, but at least one of them is in the pending state,
            // then set the group state to ClusterGroupPending and exit
            // immediately. If no resource in the group is in either
            // the failed or in the pending state, then check whether 
            // some resources in the group are in online and some in the
            // offline state. Then, set the group state to 
            // ClusterGroupPartialOnline and exit immediately.
            //  
            for ( ;
                  listEntry != &(Group->Contains);
                  listEntry = listEntry->Flink ) {
                resource = CONTAINING_RECORD(listEntry,
                                     FM_RESOURCE,
                                     ContainsLinkage);

                resourceState = resource->State;

                if ( resourceState == ClusterResourceFailed ) {
                    state = ClusterGroupFailed;
                    //
                    // This state has the highest precedence, so
                    // exit immediately.
                    //
                    goto FnExit;
                } else if ( (resourceState == ClusterResourceOnlinePending) ||
                            (resourceState == ClusterResourceOfflinePending) ) {
                    IsPending = TRUE;
                } else {
                    CL_ASSERT( (resourceState == ClusterResourceOffline) ||
                       (resourceState == ClusterResourceOnline) ||
                       (resourceState == ClusterResourceInitializing) );
                    if ( resourceState == ClusterResourceInitializing ) {
                        //
                        // Normalize this state to offline state
                        //
                        resourceState = ClusterResourceOffline;
                    }
                    if ( firstResourceState == ClusterResourceInitializing ) {
                        //
                        // Normalize this state to offline state
                        //
                        firstResourceState = ClusterResourceOffline;
                    }
                    if ( firstResourceState != resourceState ) {
                        IsPartialOnline = TRUE;
                    }           
                }
            }   

            if ( IsPending == TRUE ) {
                state = ClusterGroupPending;
                //
                // This state has the next highest precedence after
                // ClusterGroupFailed state
                //
                goto FnExit;
            }
            if ( IsPartialOnline == TRUE ) {
                state = ClusterGroupPartialOnline;
                //
                // This state has the next highest precedence after
                // ClusterGroupFailed and ClusterGroupPending states
                //
                goto FnExit;
            }
            if ( firstResourceState == ClusterResourceOnline ) {
                state = ClusterGroupOnline;
                //
                // If the first resource is in an online state,
                // then the group state should be online.
                //
                goto FnExit;
            }
            if ( firstResourceState == ClusterResourceOffline ) {
                state = ClusterGroupOffline;
                //
                // If the first resource is in an offline state,
                // then the group state should be offline.
                //
                goto FnExit;
            }           
        }

        //
        // The control gets here only if IsNormalized is TRUE 
        //
        if ( (firstResourceState == ClusterResourceOnline) ||
             (firstResourceState == ClusterResourceOnlinePending) ) {
            state = ClusterGroupOnline;
            firstResourceState = ClusterResourceOnline;
        } else {
            CL_ASSERT( (firstResourceState == ClusterResourceOffline) ||
                       (firstResourceState == ClusterResourceFailed) ||
                       (firstResourceState == ClusterResourceOfflinePending) ||
                       (firstResourceState == ClusterResourceInitializing) );
            state = ClusterGroupOffline;
            firstResourceState = ClusterResourceOffline;
        }

        //
        // Now check each resource to see if they match the first.
        // 

        for (listEntry = Group->Contains.Flink;
              listEntry != &(Group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry,
                                         FM_RESOURCE,
                                         ContainsLinkage);

            resourceState = resource->State;

            //
            // Normalize pending states to their final state, and Failed and Initializing
            // to Offline.
            //

            if ( resourceState == ClusterResourceOnlinePending ) {
                resourceState = ClusterResourceOnline;
            } else if ( (resourceState == ClusterResourceOfflinePending) ||
                        (resourceState == ClusterResourceFailed) ||
                        (resourceState == ClusterResourceInitializing) ) {
                resourceState = ClusterResourceOffline;
            }

            //
            // We only need 1 resource that is not the same as the first resource
            // to be in a partially online state.
            //
            if ( firstResourceState != resourceState ) {
                state = ClusterGroupPartialOnline;
                break;
            }
        }
    } else {
        //
        // The group is empty, so I guess it must be offline.
        //
        state = Group->PersistentState;
    }
    
FnExit:    
    FmpReleaseLocalGroupLock( Group );

    return(state);

} // FmpGetGroupState



DWORD
FmpPropagateGroupState(
    IN PFM_GROUP    Group
    )

/*++

Routine Description:

    Set and propagate the state of the group to other components on the
    local system and to other systems in the cluster.

Arguments:

    Group - The Group to propagate the state.

Return:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    We will use the first resource's state to determine what should be the
    state for the whole group. If all resources match the state of the first
    resource, then that is the state of the Group. If any resource disagrees
    with the first resource, then the state is PartialOnline.

--*/

{
    GUM_GROUP_STATE         groupState;
    LPCWSTR                 groupId;
    DWORD                   groupIdSize;
    DWORD                   status;
    PLIST_ENTRY             listEntry;
    CLUSTER_RESOURCE_STATE  firstResourceState;
    CLUSTER_GROUP_STATE     state;

    FmpAcquireLocalGroupLock( Group );

    //
    // If we no longer own the Group, then just return now.
    //
    // This can happen when a resource goes offline (via a terminate), but
    // the group ownership has already migrated to another system.
    // We will assume that returning success is okay in this case.
    //
    if ( Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SUCCESS);
    }

    //
    //  Chittur Subbaraman (chitturs) - 6/28/99
    //
    //  If the group is marked for deletion, then don't do anything.
    //
    if ( !IS_VALID_FM_GROUP( Group ) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SUCCESS);
    }


    state = FmpGetGroupState( Group, TRUE );

    //
    // If the state has changed, then update the local system.
    //
    ++Group->StateSequence;
    if ( state != Group->State ) {

        Group->State = state;

        switch ( state ) {
        case ClusterGroupOnline:
        case ClusterGroupPartialOnline:
            ClusterEvent(CLUSTER_EVENT_GROUP_ONLINE, Group);
            break;

        case ClusterGroupOffline:
        case ClusterGroupFailed:
            ClusterEvent(CLUSTER_EVENT_GROUP_OFFLINE, Group);
            break;

        default:
            break;
        }

        //
        // Prepare to notify the other systems.
        //
        groupId = OmObjectId( Group );
        groupIdSize = (lstrlenW( groupId ) + 1) * sizeof(WCHAR);

        //
        // Set Group state
        //
        groupState.State = state;
        groupState.PersistentState = Group->PersistentState;
        groupState.StateSequence = Group->StateSequence;

        status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateGroupState,
                                 3,
                                 groupIdSize,
                                 groupId,
                                 (lstrlenW(OmObjectId(NmLocalNode))+1)*sizeof(WCHAR),
                                 OmObjectId(NmLocalNode),
                                 sizeof(groupState),
                                 &groupState);

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateGroupState: Group %1!ws! state = %2!u!, persistent state = %3!u!\n",
                   OmObjectId(Group),
                   groupState.State,
                   groupState.PersistentState);

    } else {
        //
        // Assume that the state didn't change, but the owning node did.
        //
        //
        // Prepare to notify the other systems.
        //
        groupId = OmObjectId( Group );
        groupIdSize = (lstrlenW( groupId ) + 1) * sizeof(WCHAR);
        status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateGroupNode,
                                 2,
                                 groupIdSize,
                                 groupId,
                                 (lstrlenW(OmObjectId(NmLocalNode))+1)*sizeof(WCHAR),
                                 OmObjectId(NmLocalNode));
    }

    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmpPropagateGroupState



DWORD
FmpPropagateFailureCount(
    IN PFM_GROUP    Group,
    IN BOOL         NewTime
    )

/*++

Routine Description:

    Propagate NumberOfFailures for the group to other systems in the cluster.

Arguments:

    Group - The Group to propagate the state.

    NewTime - TRUE if last failure time should be reset also. FALSE otherwise.

Return:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    The Local Group lock must be held.

--*/

{
    PGUM_FAILURE_COUNT  failureCount;
    DWORD               failureCountSize;
    LPCWSTR             groupId;
    DWORD               status;

    //
    // Prepare to notify the other systems.
    //

    groupId = OmObjectId( Group );

    failureCountSize = sizeof(GUM_FAILURE_COUNT) - 1 +
                       ((lstrlenW(groupId) + 1) * sizeof(WCHAR));

    failureCount = LocalAlloc(LMEM_FIXED, failureCountSize);

    if ( failureCount == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    failureCount->Count = Group->NumberOfFailures;
    failureCount->NewTime = (DWORD)NewTime;
    wcscpy(&failureCount->GroupId[0], groupId);


    status = GumSendUpdate( GumUpdateFailoverManager,
                            FmUpdateFailureCount,
                            failureCountSize,
                            failureCount );

    LocalFree( failureCount );

    return(status);

} // FmpPropagateFailureCount



PFM_GROUP
FmpCreateGroup(
    IN  LPWSTR         GroupId,
    IN  BOOL           Initialize
    )

/*++

Routine Description:

    Creates a new Group object.

Arguments:

    GroupId - The Id of the new Group.

    Initialize - TRUE if the Group should be initialized, FALSE otherwise.

Returns:

    A non-NULL pointer to the Group if successful.
    NULL - The Group could not be created.

Notes:

    1) Passing Initialize as FALSE allows for creating the group and it
    resources, but complete initialization can happen later.

    2) The Group List lock must be held.

    3) If the Group is created, the reference count on the object is 1. If
    the group is not create (i.e., it already exists) then the reference count
    is not incremented and the caller may add a reference as needed.

--*/

{
    PFM_GROUP       group = NULL;
    DWORD           status = ERROR_SUCCESS;
    BOOL            Created;


    //
    // Open an existing group or create a new one.
    //

    group = OmCreateObject( ObjectTypeGroup,
                            GroupId,
                            NULL,
                            &Created);
    if (group == NULL) {
        return(NULL);
    }

    if (!Created) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Opened existing group %1!ws!\n",
                   GroupId);
        //this is the quorum group being recreated again,
        if ((!FmpFMOnline) && (group->RegistryKey == NULL))
        {
            status = FmpInitializeGroup(group, Initialize);
        }
        OmDereferenceObject( group );
        goto FnExit;
    }
    else
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] Creating group %1!ws!\n",
               GroupId);


        group->State = ClusterGroupOffline;
        InitializeCriticalSection( &group->Lock );
        group->dwStructState = FM_GROUP_STRUCT_CREATED;

        //
        // Insert the group into its list.
        //
        status = FmpInitializeGroup( group , Initialize);

        if ( status != ERROR_SUCCESS ) {
            goto FnExit;
        }

        //
        // Insert the group into its list.
        //
        status = OmInsertObject( group );

        if ( status != ERROR_SUCCESS ) {
            goto FnExit;
        }


    }

FnExit:
    if (status != ERROR_SUCCESS)
    {
        FmpAcquireLocalGroupLock( group );

        FmpDestroyGroup( group, FALSE );

        SetLastError(status);
        group = NULL;
    }
    return(group);

} // FmpCreateGroup


DWORD FmpInitializeGroup(
    IN PFM_GROUP Group,
    IN BOOL Initialize
    )
{

    DWORD   status;

    //
    // Initialize the Group
    //
    InitializeListHead( &(Group->Contains) );
    InitializeListHead( &(Group->PreferredOwners) );
    InitializeListHead( &(Group->DmRundownList) );
    InitializeListHead( &(Group->WaitQueue) );
    Group->MovingList = NULL;

    //
    // Read the registry information if directed to do so.
    //
    status = FmpQueryGroupInfo( Group, Initialize );
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpInitializeGroup: FmpQueryGroupInfo failed, status=%1!u!\n",
           status);

    }

    return(status);
}





DWORD
FmpDestroyGroup(
    IN PFM_GROUP  Group,
    IN BOOL       bDeleteObjOnly
    )
/*++

Routine Description:

    Closes a group.

    First, this routine verifies that all resources contained within
    the Group are closed.

    If the group is online, it is brought offline.

    Note that the group object itself is not dereferenced here. This is
    done so that FmpCleanupGroups can simply enumerate all the groups,
    destroying each one in turn. This approach means a group may be
    destroyed multiple times if there are outstanding references to it, but
    that is not a problem since no work will be done on subsequent calls.

    IF bDeleteObjOnly is TRUE, then the resource monitor is not invoked and
    group state is not touched.

Arguments:

    FoundGroup - Returns the found group.

    Group - Supplies the current group.

    Name - Supplies the current group's name.

Return Value:

    TRUE - to continue searching

    FALSE - to stop the search. The matching group is returned in
        *FoundGroup

Notes:

    The LocalGroupLock MUST be held! This routine will release that lock
    as part of cleanup.

--*/
{
    PLIST_ENTRY   listEntry;
    PFM_RESOURCE  Resource;
    PPREFERRED_ENTRY preferredEntry;
    DWORD         status = ERROR_SUCCESS;



    ClRtlLogPrint(LOG_NOISE,
               "[FM] DestroyGroup: destroying %1!ws!\n",
               OmObjectId(Group));



    //
    // Make sure there are no resources in the Group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
           ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        listEntry = listEntry->Flink;
        RemoveEntryList( &Resource->ContainsLinkage );
        //dereference for removing from the contains list
        OmDereferenceObject( Resource );
        FmpAcquireLocalResourceLock( Resource );
        if (!bDeleteObjOnly)
            Resource->QuorumResource = FALSE;
        FmpDestroyResource( Resource, bDeleteObjOnly );
        //the reference count on the group wrt to being
        //referenced by the resource is handled in FmpDestroyResource
    }

    CL_ASSERT(IsListEmpty(&Group->Contains));

    //
    //
    // Make sure the preferred owners list is drained.
    //
    while ( !IsListEmpty( &Group->PreferredOwners ) ) {
        listEntry = RemoveHeadList(&Group->PreferredOwners);
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        OmDereferenceObject( preferredEntry->PreferredNode );
        LocalFree( preferredEntry );
    }

    //
    // Now that there are no remaining resources in this group
    // we're done, so remove it from it's object type list.
    //

    status = OmRemoveObject( Group );


    //
    // Close the Group's registry key.
    //
    DmRundownList( &Group->DmRundownList );
    if ( Group->RegistryKey != NULL ) {
        DmCloseKey( Group->RegistryKey );
        Group->RegistryKey = NULL;
        Group->Initialized = FALSE;
    }


    //
    // We must release the lock prior to the dereference, in case this is
    // the last dereference of the object!
    //
    FmpReleaseLocalGroupLock( Group );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDestroyGroup: Group %1!ws! destroyed.\n",
               OmObjectId(Group));

    OmDereferenceObject( Group );

    return(status);
} // FmpDestroyGroup




///////////////////////////////////////////////////////////////////////////
//
// Initialization/Cleanup Routines
//
///////////////////////////////////////////////////////////////////////////

DWORD
FmpInitGroups(
    IN BOOL Initialize
    )
/*++

Routine Description:

    Processes the Cluster group list in the registry. For each
    group key found, a cluster group is created.

Arguments:

    Initialize - TRUE if resources should be initialized. FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD          status;
    DWORD          keyIndex = 0;
    LPWSTR         groupId = NULL;
    DWORD          groupIdMaxSize = 0;
    PFM_GROUP      ignored;


    ClRtlLogPrint(LOG_NOISE,"[FM] Processing groups list.\n");

    FmpAcquireGroupLock();

    //
    // Enumerate the subkeys. Each subkey name corresponds to a group name.
    //

    for (keyIndex = 0; ; keyIndex++) {
        status = FmpRegEnumerateKey( DmGroupsKey,
                                     keyIndex,
                                     &groupId,
                                     &groupIdMaxSize
                                    );

        if (status == NO_ERROR) {
            ignored = FmpCreateGroup( groupId,
                                      Initialize );
            continue;
        }

        if (status == ERROR_NO_MORE_ITEMS) {
            status = NO_ERROR;
        } else {
            ClRtlLogPrint(LOG_NOISE,"[FM] EnumGroup error %1!u!\n", status);
        }

        break;
    }

    FmpReleaseGroupLock();

    ClRtlLogPrint(LOG_NOISE,"[FM] All groups created.\n");

    if (groupId != NULL) {
        LocalFree(groupId);
    }

    return(status);

} // FmpInitGroups



DWORD
FmpCompleteInitGroup(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Finish initialization of all resources within the group.

Arguments:

    Group - The group to finish initializing.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE Resource;

    FmpAcquireLocalGroupLock(Group);

    //
    // For each resource in the Group, make sure that it has been fully
    // initialized.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        FmpInitializeResource( Resource, TRUE );

    }

    FmpReleaseLocalGroupLock(Group);

    return(ERROR_SUCCESS);

} // FmpCompleteInitGroup


DWORD
FmpCleanupGroupsWorker(
    IN PFM_CLEANUP_INFO pFmCleanupInfo
    )
/*++

Routine Description:

    This routine walks through an enumerated list of  all the groups
    owned by the local node and tries to shut them down cleanly.

    In the first phase it tries to bring
    all resources offline except the quorum one.

    In the second phase it waits for the group to reach stable state
    and then move it.  It tries to bring the quorum resource offline as
    well by moving the quorum group.

Arguments:

    pFmCleanupInfo - ptr to a strucuture containing the groups to be
    offlined/moved and the timelimit in which to do so.

Returns:

    None.

Assumptions:


--*/
{


    DWORD       Status = ERROR_SUCCESS;
    DWORD       i;
    PFM_GROUP   pGroup;
    PGROUP_ENUM pGroupEnum;
    BOOL        bContainsQuorumGroup;
    BOOL        bQuorumGroup = FALSE;
    DWORD       CleanupStatus = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsWorker: Entry\r\n");


    //
    // This is done in two passes. In the first pass, we offline/move all
    // resources except the quorum resource. In the second pass, we offline/move
    // everything and then destroy the group. This allows resources that are
    // being shutdown to write to the registry and have the updates logged to
    // the quorum disk.
    //

    pGroupEnum = pFmCleanupInfo->pGroupEnum;
    bContainsQuorumGroup = pFmCleanupInfo->bContainsQuorumGroup;


    // Now offline all of the non-quorum resources...
    // but don't wait for them to finish. I.E. get as much work done as
    // possible as fast as possible.
    //
    for ( i = 0; i < pGroupEnum->EntryCount; i++ )
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                               pGroupEnum->Entry[i].Id );

        //try and offline all resources except the quorum
         //resource
        Status = FmpCleanupGroupPhase1(pGroup, pFmCleanupInfo->dwTimeOut);

        if ((Status != ERROR_IO_PENDING) && (Status != ERROR_SUCCESS) &&
            (Status != ERROR_QUORUM_RESOURCE))
            CleanupStatus = Status;
        OmDereferenceObject(pGroup);
    }

    //this finishes the second phase of the cleanup on shutdown
    //if the quorum group is in this list, skip it and process it
    //at the end
    if (CleanupStatus == ERROR_SUCCESS)
    {
        for ( i = 0; i < pGroupEnum->EntryCount; i++ )
        {
            pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                   pGroupEnum->Entry[i].Id );

            if (gpQuoResource->Group == pGroup)
            {

                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpCleanupGroupsWorker: Quorum group belongs to this node, process phase 2 later\r\n");
                bQuorumGroup = TRUE;
                OmDereferenceObject(pGroup);
                continue;
            }

            //try and offline all groups, including the quorum resource
            //also try and move the resource to other nodes
            Status = FmpCleanupGroupPhase2(pGroup);

            OmDereferenceObject(pGroup);
        }
        if (bQuorumGroup)
            Status = FmpCleanupGroupPhase2(gpQuoResource->Group);

    }
    else
    {
        //phase 1 didnt work for some reason
        //try and offline the quorum resource alone.
        //TODO::Should we also terminate all resources
        // No way to terminate services ???
        if (bContainsQuorumGroup)
            FmpCleanupQuorumResource(gpQuoResource);


    }
    return(Status);

} // FmpCleanupGroupsWorker



DWORD
FmpCleanupGroupPhase1(
    IN PFM_GROUP Group,
    IN DWORD     dwTimeOut
    )
/*++

Routine Description:

    This routine is the first phase for clean up all groups owned by the node
    on shutdown.

    In this phase, we try and bring all resources offline except the quorum
    resource.  In this phase we dont block for the resources to reach a stable
    state

    We give the group the shutdown timeout specified for the cluster
    to reach a stable state before we try to offline it. If it doesnt
    reach a stable state in this period then we shut it down abruptly.


Arguments:

    Group - The Group to offline.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    DWORD dwRetryCount = (2 * dwTimeOut)/1000;//we check after every 1/2 sec

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase1: Entry, Group = %1!ws!\r\n",
        OmObjectId(Group));

ChkGroupState:
    FmpAcquireLocalGroupLock( Group );

    //
    // Just offline the group
    //
    if ( Group->OwnerNode == NmLocalNode )
    {


        //
        // Make sure the group is quiet
        //
        if ( !FmpIsGroupQuiet( Group, ClusterGroupOffline ) )
        {
            FmpReleaseLocalGroupLock( Group );
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCleanupGroupsPhase1: Group is not quiet, wait\r\n");
            //we give it a minute to recover totally
            Sleep(500);
            if (dwRetryCount--)
                goto ChkGroupState;
            else
            {
                Status = ERROR_REQUEST_ABORTED;
                goto FnExit;
            }

        }

        //
        // Just take the group offline. Don't wait, don't pass go...
        //
        // Dont take the quorum resource offline in phase 1
        // The quorum resource must be the last one to be taken offline
        Status = FmpOfflineGroup(Group, FALSE, FALSE);
    }

    FmpReleaseLocalGroupLock( Group );
FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase1: Exit, status=%1!u!\r\n",
        Status);

    return(Status);

} // FmpCleanupGroupsPhase1



DWORD
FmpCleanupGroupPhase2(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    This routine is the second phase for clean up all groups owned by the node
    on shutdown.

    In this phase, we try and bring all resources offline including the quorum
    resource.  We also try to move the quorum resource

    We give the group 10 seconds to reach a stable state before we try to
    move it.

Arguments:

    Group - The Group to offline.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwRetryCount= 120 * 12;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase2: Entry, Group = %1!ws!\r\n",
        OmObjectId(Group));

    FmpAcquireLocalGroupLock( Group );

    //
    // Try to move the Group before destroying it if we own it.
    //
    if ( Group->OwnerNode == NmLocalNode )
    {
        //
        // First make sure the group is really offline.
        // In phase 1 we began the offline process... we need to check it here.
        //
WaitSomeMore:

        //
        // [GorN] [10/05/1999]
        // We need to wait for the quorum to go offline, otherwise
        // the surviving node will not be able to arbitrate.
        //
        // FmpWaitForGroup keeps issuing RmOffline for the quorum,
        // resrcmon returns ERROR_INVALID_STATE, for the second offline,
        // since offline is already in progress.
        //
        // This causes us to break out of this look while the quorum resource
        // is still being offline.
        //
        // [HACKHACK] The following fix for the problem is a hack.
        // It would be better either to make resmon return IO_PENDING when
        // somebody is trying to offline the resource that is in offline pending
        //
        // Or not to call FmRmOffline the second time in FM.
        //

        Status = FmpOfflineGroup(Group, TRUE, FALSE);
        if (Status == ERROR_IO_PENDING ||
            (Status == ERROR_INVALID_STATE 
          && Group == gpQuoResource->Group) )
        {
            //FmpWaitForGroup() will release the lock
            Status = FmpWaitForGroup(Group);
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCleanupGroupsPhase2: Sleep and retry\r\n");
            Sleep(2*1000);
            //Reacquire the group lock and check if the group is offline
            FmpAcquireLocalGroupLock(Group);
            if (dwRetryCount--)
                goto WaitSomeMore;

        }
        else if (Status != ERROR_SUCCESS)
        {
            goto FnExit;
        }
        else
        {
            // The Move routine frees the LocalGroupLock!
            FmpMoveGroup( Group, NULL, TRUE, NULL, TRUE );
            FmpAcquireLocalGroupLock( Group );
        }
    }
FnExit:
    FmpReleaseLocalGroupLock(Group);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase2: Exit\n");

    return(TRUE);

} // FmpCleanupGroupsPhase2



BOOL
FmpEnumNodeState(
    OUT DWORD *pStatus,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback for FM shutdown. Queries the state
    of other nodes to see if any are up.

Arguments:

    pStatus - Returns TRUE if other node is up.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    DWORD Status;
    DWORD NodeId;
    PGROUP_ENUM NodeGroups = NULL;
    PRESOURCE_ENUM NodeResources = NULL;
    DWORD i;
    PFM_GROUP Group;
    PFM_RESOURCE Resource;

    if (Node == NmLocalNode) {
        return(TRUE);
    }

    //
    // Enumerate all other node's group states. This includes all nodes
    // that are up, as well as nodes that are paused.
    //
    if ((NmGetNodeState(Node) == ClusterNodeUp) ||
        (NmGetNodeState(Node) == ClusterNodePaused)){
        *pStatus = TRUE;
        return(FALSE);
    }

    return(TRUE);

} // FmpEnumNodeState



VOID
FmpCleanupGroups(
    IN BOOL ClusterShutDownEvent
    )
/*++

Routine Description:

    This routine kicks off the cleanup of the FM layer.

Arguments:

    None.

Returns:

    None.

--*/
{
    DWORD           Status;
    DWORD           dwTimeOut;
    DWORD           dwDefaultTimeOut;
    HANDLE          hCleanupThread;
    DWORD           otherNodesUp = FALSE;
    DWORD           dwThreadId;
    DWORD           i,dwTimeOutCount;
    PGROUP_ENUM     pGroupEnum;
    BOOL            bQuorumGroup = FALSE;
    PFM_CLEANUP_INFO pFmCleanupInfo;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroups: Entry\r\n");

    //
    // If we don't know the quorum resource or we are not online,
    // then leave immediately
    //
    if ( !gpQuoResource )  {
        goto FnExit;
    }

    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);
    //if this is called when fmformphaseprocessing is going on
    //then the quorum group doesnt exist, other groups dont exist
    //either
    if (FmpFMFormPhaseProcessing)
            FmpCleanupQuorumResource(gpQuoResource);
    else
        CL_ASSERT(gpQuoResource->Group != NULL)
    RELEASE_LOCK(gQuoChangeLock);


    //
    // Find and sort all known groups, hold the group lock while enumerating
    //
    FmpAcquireGroupLock();

    Status = FmpEnumSortGroups(&pGroupEnum, NmLocalNode, &bQuorumGroup);

    FmpReleaseGroupLock();

    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }


    //
    // See if any other node in the cluster is up...
    // If so, we will use the default timeout value.
    // Otherwise, we will use what we believe is a more reasonable time.
    //
    OmEnumObjects( ObjectTypeNode,
                   FmpEnumNodeState,
                   &otherNodesUp,
                   NULL );

    dwDefaultTimeOut = CLUSTER_SHUTDOWN_TIMEOUT * 60; // default timeout (secs)

    switch ( CsShutdownRequest ) {
    case CsShutdownTypeShutdown:
        if ( otherNodesUp ) {
            dwTimeOut = 15;   // other node will time us out quickly - say 15 secs
        } else {
            dwTimeOut = 30;  // otherwise use 30 seconds
        }
        break;

    default:
        // apply default value to registry
        dwDefaultTimeOut = CLUSTER_SHUTDOWN_TIMEOUT; // default timeout (mins)
        Status = DmQueryDword( DmClusterParametersKey,
                               CLUSREG_NAME_CLUS_SHUTDOWN_TIMEOUT,
                               &dwTimeOut,
                               &dwDefaultTimeOut);
        dwTimeOut *= 60;         // convert to secs.
        break;
    }

    //convert to msecs
    dwTimeOut *= 1000;

    pFmCleanupInfo = (PFM_CLEANUP_INFO)LocalAlloc(LMEM_FIXED, sizeof(FM_CLEANUP_INFO));
    if (!pFmCleanupInfo)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;

    }

    pFmCleanupInfo->pGroupEnum = pGroupEnum;
    pFmCleanupInfo->dwTimeOut = dwTimeOut; //in msecs
    pFmCleanupInfo->bContainsQuorumGroup = bQuorumGroup;

    //
    // Start the worker thread to perform cleanup.
    //
    hCleanupThread = CreateThread( NULL,
                                   0,
                                   FmpCleanupGroupsWorker,
                                   pFmCleanupInfo,
                                   0,
                                   &dwThreadId );

    if ( hCleanupThread == NULL ) {
        //SS: if we own the quorum resource should we cleanup the quorum resource
        //this will avoid corruption
        if (bQuorumGroup)
            FmpCleanupQuorumResource(gpQuoResource);
        goto FnExit;
    }

    // Rohit (rjain): This path is taken when Cluster Service is shutting 
    // down. ServiceStatus checkpoint is incremented after every WaitHint
    // units of time. For this the waiting period of dwTimeOut is divided into
    // multiple waiting periods of dwWaitHint units each.
    
    
    if((ClusterShutDownEvent==TRUE) && (dwTimeOut > CsServiceStatus.dwWaitHint))
    {
        dwTimeOutCount=dwTimeOut/CsServiceStatus.dwWaitHint;
        ClRtlLogPrint(LOG_ERROR,
            "[FM] FmpCleanupGroups: dwTimeOut=%1!u! dwTimoutCount=%2!u! waithint =%3!u! \r\n",
                dwTimeOut,dwTimeOutCount, CsServiceStatus.dwWaitHint);
 
        for(i=0;i<dwTimeOutCount;i++){
            Status = WaitForSingleObject(hCleanupThread, CsServiceStatus.dwWaitHint);
            switch(Status) {
                case WAIT_OBJECT_0:
                    //everything is fine
                    ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpCleanupGroups: Cleanup thread finished in time\r\n");
                    break;

                case WAIT_TIMEOUT:
                    //should we terminate the thread
                    //try and clean up the quorum resource
                    //this will avoid corruption on the quorum disk
                    //TODO::Should we also terminate all resources
                    // No way to terminate services ???
                    if(i == (dwTimeOutCount-1)){
                        ClRtlLogPrint(LOG_UNUSUAL,
                                "[FM] FmpCleanupGroups: Timed out on the CleanupThread\r\n");
                        if (bQuorumGroup)
                            FmpCleanupQuorumResource(gpQuoResource);
                    }
                    break;
                case WAIT_FAILED:
                    ClRtlLogPrint(LOG_UNUSUAL,
                            "[DM] FmpCleanupGroups: wait on CleanupEvent failed 0x%1!08lx!\r\n",
                            GetLastError());
                    break;
            }
            if(Status== WAIT_OBJECT_0 || Status==WAIT_FAILED)
                break;
            CsServiceStatus.dwCheckPoint++;
            CsAnnounceServiceStatus();
        }
        goto FnExit;
    }

    //
    // Wait for the thread to complete or a timeout.
    //
    Status = WaitForSingleObject(hCleanupThread, dwTimeOut);

    switch(Status) {
    case WAIT_OBJECT_0:
        //everything is fine
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpCleanupGroups: Cleanup thread finished in time\r\n");
        break;

    case WAIT_TIMEOUT:
        //should we terminate the thread
        //try and clean up the quorum resource
        //this will avoid corruption on the quorum disk
        //TODO::Should we also terminate all resources
        // No way to terminate services ???
        ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpCleanupGroups: Timed out on the CleanupThread\r\n");
        if (bQuorumGroup)
            FmpCleanupQuorumResource(gpQuoResource);
        break;

    case WAIT_FAILED:
        ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] FmpCleanupGroups: wait on CleanupEvent failed 0x%1!08lx!\r\n",
                GetLastError());
        break;
    }

FnExit:
    //SS: dont bother cleaning up, we are going to exit after this
#if 0
    if (pGroupEnum) LocalFree(GroupEnum);
#endif

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroups: Exit\r\n");

    return;

} // FmpCleanupGroups



DWORD
FmpCleanupQuorumResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine is for emergency clean up of the quorum resource.

    In this phase, we dont try and acquire any locks.  We just try to
    bring the quorum resource offline.  Hopefully the api is offline and
    nothing funky is attempted on the quorum group/resource during this
    time.  This should only be called during the shutdown of FM.


Arguments:

    Group - The Group to offline.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD       status = ERROR_SUCCESS;
    DWORD       state;


    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpCleanupQuorum: Offline resource <%1!ws!> <%2!ws!>\n",
               OmObjectName(Resource),
               OmObjectId(Resource) );

    //
    // If the resource is already offline, then return immediately.
    //
    // We should not have to check if a resource has been initialized,
    // since if it hasn't, then we will return because the pre-initialized
    // state of a resource is Offline.
    //
    if ( Resource->State == ClusterResourceOffline ) {
        //
        // If this is the quorum resource, make sure any reservation
        // threads are stopped!
        //
        FmpRmTerminateResource( Resource );
        return(ERROR_SUCCESS);
    }


    if (Resource->State > ClusterResourcePending ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpCleanupQuorum: Offline resource <%1!ws!> is in pending state\n",
                   OmObjectName(Resource) );
        FmpRmTerminateResource( Resource );
        return(ERROR_SUCCESS);
    }

    //make sure the quorum logs can be flushed and closed
    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREOFFLINE);

    //it may not be prudent to call offline without holding any locks
    //just call terminate
    FmpRmTerminateResource( Resource );


    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpCleanupQuorum: RmOfflineResource returns %1!u!\r\n",
               status);

    return(status);
}


DWORD
FmpMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL,
    IN BOOL ShutdownHandler,
    OUT PNM_NODE *pChosenDestinationNode OPTIONAL,
    IN  BOOL bChooseMostPreferredNode
    )

/*++

Routine Description:

    Move the specified Group.  This means taking all of the individual
    resources contained within the group offline and requesting the
    DestinationNode to bring the Group Online.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to 'highest' entry in the preferred list.

    ShutdownHandler - TRUE if the shutdown handler is invoking this function.

    pChosenDestinationNode - Set to the destination node of the move and
        will be passed on to FmpCompleteMoveGroup, if necessary.

    bChooseMostPreferredNode - If the destination node is not supplied,
        indicates whether to choose the most preferred node or not.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

Notes:

    It is assumed that the Group and all contained resources are offline
    from the requesting node when this call returns.  The Group may or
    may not be online on the DestinationNode, depending on whether the
    online request succeeded.  This means that the status return is merely
    the status return for the Online request for the DestinationNode.

    The LocalGroupLock MUST also be held. The LocalGroupLock is released
    by this routine.

--*/
{
    PNM_NODE node;
    DWORD status;
    PFM_RESOURCE resource;
    PLIST_ENTRY  listEntry;
    PRESOURCE_ENUM  resourceList=NULL;
    DWORD  dwMoveStatus = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpMoveGroup: Entry\r\n");

    if ( !ShutdownHandler ) 
    {
        if ( !FmpFMOnline ) 
        {
            status = ERROR_CLUSTER_NODE_NOT_READY;
            goto FnExit;
        }

        if ( FmpShutdown ) 
        {
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            goto FnExit;
        }
    }

    //
    // See which system owns the group in order to control the move request.
    //
    if ( Group->OwnerNode != NmLocalNode ) 
    {
        if ( Group->OwnerNode == NULL ) 
        {
            status = ERROR_HOST_NODE_NOT_AVAILABLE;
            goto FnExit;
        }
        //
        // The other system owns the Group ... let them do the work.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpMoveGroup: Request node %1!ws! to move Group %2!ws!\n",
                   OmObjectId(Group->OwnerNode),
                   OmObjectId(Group));
        // FmcMoveGroupRequest must release the Group lock.
        status = FmcMoveGroupRequest( Group,
                                      DestinationNode );
        if ( status != ERROR_SUCCESS ) 
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpMoveGroup: Requested system %1!ws! to move group %2!ws! failed with status %3!u!.\n",
                       OmObjectId(Group->OwnerNode),
                       OmObjectId(Group),
                       status);
        }
        FmpAcquireLocalGroupLock( Group );
        goto FnExit;
    } 
    else 
    {
        //
        // We control the move.
        //
        if ( !FmpIsGroupQuiet(Group, ClusterGroupStateUnknown) ) 
        {
            //
            // If a move is pending or resources are pending,
            // then return now.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpMoveGroup: Request to move group <%1!ws!> when it is busy.\n",
                       OmObjectName(Group) );
            status = ERROR_INVALID_STATE;
            goto FnExit;
        }

        if ( ARGUMENT_PRESENT( DestinationNode ) ) 
        {
            //
            // Check if we are the destination... if so, we're done.
            //
            if ( NmLocalNode == DestinationNode ) 
            {
                status = ERROR_SUCCESS;
                goto FnExit;
            }
            node = DestinationNode;
        } 
        else 
        {
            node = FmpFindAnotherNode( Group, bChooseMostPreferredNode );
            if ( node == NULL ) 
            {
                status = ERROR_HOST_NODE_NOT_AVAILABLE;
                goto FnExit;
            }

        }

        if ( ARGUMENT_PRESENT ( pChosenDestinationNode ) )
        {
            *pChosenDestinationNode = node;
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpMoveGroup: Moving group %1!ws! to node %2!ws! (%3!d!)\n",
                   OmObjectId(Group),
                   OmObjectId(node),
                   NmGetNodeId(node));

        //
        // If the other system is not up, then fail now.
        //
        if ( NmGetExtendedNodeState(node) != ClusterNodeUp ) 
        {
            status = ERROR_HOST_NODE_NOT_AVAILABLE;
            goto FnExit;
        }

        //
        // If the other system is not in the preferred list, then fail this
        // now.
        //
        if ( !FmpInPreferredList( Group, node, TRUE, NULL) ) 
        {
            status = ERROR_CLUSTER_NODE_NOT_FOUND;
            goto FnExit;
        }

        //
        // Get the list of resources in the group and their states.
        //
        status = FmpGetResourceList( &resourceList, Group );
        if ( status != ERROR_SUCCESS ) 
        {
            goto FnExit;
        }

        Group->MovingList = resourceList;

        //
        // At this point the other system should be up!
        //
        status = FmpOfflineResourceList( resourceList, TRUE );

        //SS: avoid the window when the group lock is released
        //and the moving flag is not set true
        //moving will be continued in another thread context if pending is
        //returned

        if ( status != ERROR_SUCCESS ) 
        {
            goto FnRestore;
        }


        // for now make sure that the group state is propagated here
        // In general it is propagated by the worker thread. Since
        // the ownership is going to change, we want to make sure that the
        // last known state is propagated from this node to others before
        // that.
        FmpPropagateGroupState(Group);
       
        //
        // Assume the other node is going to take ownership. This is done
        // before, in case the Group state changes. We want to accept the
        // Group/resource state changes from the remote system when they
        // arrive. We've already verified that node is in the preferred list!
        //

        TESTPT(TpFailPreMoveWithNodeDown) 
        {
            ClusterEvent( CLUSTER_EVENT_NODE_DOWN, node );
        }

        //
        //  Chittur Subbaraman (chitturs) - 5/18/99
        //
        //  Modified to handle the move group request of a quorum group in 
        //  case the destination node could not arbitrate for the quorum
        //  resource.
        //
        do
        {
            //
            // Before making the RPC, set the intended owner of the group
            //
            FmpSetIntendedOwnerForGroup( Group, NmGetNodeId( node ) );

            try {
                ClRtlLogPrint(LOG_NOISE,
                            "[FM] FmpMoveGroup: Take group %2!ws! request to remote node %1!ws!\n",
                            OmObjectId(node),
                            OmObjectId(Group));

                dwMoveStatus = status = FmcTakeGroupRequest( node, OmObjectId( Group ), resourceList );                                 
            } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                LPCWSTR     pszNodeId;
                LPCWSTR     pszGroupId;

                status = GetExceptionCode ();
                
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpMoveGroup: Exception in FmcTakeGroupRequest %2!ws! request to remote node %1!ws!, status=%3!u!\n",
                    OmObjectId(node),
                    OmObjectId(Group),
                    status);

                //
                // An exception from RPC indicates that the other node is either dead
                // or insane. We dont know whether it took ownership or not.
                // So, let the FM node down handler handle the group.
                //
                GumCommFailure( GumUpdateFailoverManager,
                                NmGetNodeId(node),
                                GetExceptionCode(),
                                TRUE );
                //
                // The new owner node that is now dead might have set the intended
                // owner as NULL or it might not have set this. It might have 
                // set the owner node to himself or might not have.
                // If it has set the owner node for this group as himself, then
                // the FM node down handler will assume responsibility for this
                // group. If the target node dies before it sets himself as the owner,
                // then again, the FM node down handler will assume responsibility
                // for the group. We wake up when the gum sync handling is over.
                // Right now, the gum update for the owner node may still be in
                // progress so we cant be sure if that update was completed on
                // all nodes.
                //

                //
                //  Chittur Subbaraman (chitturs) - 6/7/99
                //
                //  Issue a GUM update to handle this group. Using this
                //  GUM update prevents any race condition with the
                //  node down processing code. 
                //
                //  TODO: This does not cover the case in which 
                //  FmpTakeGroupRequest crashes after setting the
                //  intended owner to invalid ID. In such a case, 
                //  the following handler won't take ownership of the
                //  group. Also, claim handler will not touch the
                //  group.
                //
                pszNodeId = OmObjectId( node );
                pszGroupId = OmObjectId( Group );
    
                GumSendUpdateEx( GumUpdateFailoverManager,
                                 FmUpdateCompleteGroupMove,
                                 2,
                                 (lstrlenW(pszNodeId)+1)*sizeof(WCHAR),
                                 pszNodeId,
                                 (lstrlenW(pszGroupId)+1)*sizeof(WCHAR),
                                 pszGroupId);

                status = ERROR_HOST_NODE_NOT_AVAILABLE;
                goto FnExit;
            }

            if ( status == ERROR_RETRY )
            {
                //
                //  The destination refused to take the quorum group since it
                //  did not win the arbitration. So let us see who won the
                //  arbitration.
                //
                DWORD  dwSelectedQuorumOwnerId;

                CL_ASSERT( Group == gpQuoResource->Group ); 

                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpMoveGroup: Remote node asked us to resend take group request for group %1!ws! to another node ...\n",
                           OmObjectId( Group ));

                //
                //  Get the ID of the node which the MM believes is the best
                //  candidate to own the quorum resource. This is a call that
                //  blocks while RGP is in progress.
                //
                MMApproxArbitrationWinner( &dwSelectedQuorumOwnerId );

                if ( ( dwSelectedQuorumOwnerId == NmGetNodeId( NmLocalNode ) )  ||
                     ( dwSelectedQuorumOwnerId == MM_INVALID_NODE ) )
                {
                    //
                    //  The local node is chosen by MM or no node is chosen by
                    //  the MM. The latter case will happen if no RGP has
                    //  occurred at the time this call is made. Let us see if we 
                    //  can arbitrate for the quorum resource.
                    //
                    status = FmpRmArbitrateResource( gpQuoResource );
         
                    if ( status != ERROR_SUCCESS ) 
                    {
                        //
                        //  Too bad. We will halt and let FmpNodeDown handler
                        //  handle the quorum group.
                        //
                        ClRtlLogPrint(LOG_CRITICAL,
                                "[FM] FmpMoveGroup: Local node %1!u! cannot arbitrate for quorum, Status = %1!u!...\n",
                                dwSelectedQuorumOwnerId,
                                status);
                        CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
                    }
                    status = ERROR_RETRY;
                    break;
                } 
                           
                node = NmReferenceNodeById( dwSelectedQuorumOwnerId );

                if ( node == NULL )
                {
                    ClRtlLogPrint(LOG_CRITICAL,
                                "[FM] FmpMoveGroup: Selected node %1!u! cannot be referenced...\n",
                                dwSelectedQuorumOwnerId);
                    CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
                } 
            } // if
        } while ( status == ERROR_RETRY );

        TESTPT(TpFailPostMoveWithNodeDown)
        {
            ClusterEvent( CLUSTER_EVENT_NODE_DOWN, node );
        }
        

        CL_ASSERT( status != ERROR_IO_PENDING );
        if ( status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpMoveGroup: FmcTakeGroupRequest to node %1!ws! to take group %2!ws! failed, status %3!u!.\n",
                       OmObjectId(node),
                       OmObjectId(Group),
                       status );
            goto FnRestore;                       
        }


        //
        // If the group is empty, then generate a Group state change event.
        //
        if ( IsListEmpty( &Group->Contains ) ) 
        {
            ClusterWideEvent( CLUSTER_EVENT_GROUP_OFFLINE,
                              Group );
        }
    }
    
FnRestore:
    if ((status != ERROR_SUCCESS) && (status != ERROR_IO_PENDING))
    {
        //
        //  Chittur Subbaraman (chitturs) - 3/22/2000
        //
        //  Reset the group's intended owner to invalid node ID if the
        //  node down handler did not do that.
        //
        if ( dwMoveStatus != ERROR_SUCCESS )
        {
            if ( FmpSetIntendedOwnerForGroup( Group, ClusterInvalidNodeId )
                  == ERROR_CLUSTER_INVALID_NODE )
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpMoveGroup: Group <%1!ws!> has already been processed by node down handler....\r\n",
                    OmObjectName(Group));
                goto FnExit;
            }
        }
        
        // the move failed
        // In all failure cases we want to bring the resources
        // back online
        // if it is pending, then we let FmpCompleteMoveGroup finish
        // the work
        if (resourceList)
        {
            //
            // Terminate all of the resources in the group.
            //
            FmpTerminateResourceList( resourceList );

            //
            //  Chittur Subbaraman (chitturs) - 4/10/2000
            //
            //  Make sure to online the quorum group even if this node is
            //  shutting down. This is necessary so that other groups
            //  can be brought offline during this node's shutdown. Note
            //  that FmpOnlineResourceList would only online a group
            //  during a shutdown if the group is the quorum group.
            //
            if ( FmpFMGroupsInited )
                FmpOnlineResourceList( resourceList, Group );
        }

    }

FnExit:
    ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpMoveGroup: Exit group <%1!ws!>, status = %2!u!\r\n",
            OmObjectName(Group),
            status);

    if ( status != ERROR_IO_PENDING ) 
    {
        if (resourceList) 
        {
            FmpDeleteResourceEnum( resourceList );
            Group->MovingList = NULL;
        }
    }

    if ( ( status == ERROR_SUCCESS ) || ( status == ERROR_IO_PENDING ) )
    {
        //
        //  Chittur Subbaraman (chitturs) - 4/13/99
        //
        //  If the FmpDoMoveGroupOnFailure thread is also waiting to do the
        //  move, then tell that thread to take its hands off.
        //
        if ( Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL )
        {
            Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE;
        }
    }

    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmpMoveGroup



DWORD
FmpCompleteMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode
    )

/*++

Routine Description:

    This completes the move of a group by asking the other node to take
    ownership.
    This function is called by FmpMovePendingThread() after all the resources
    are offline.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to 'highest' entry in the preferred list.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

Notes:

    It is assumed that the Group and all contained resources are offline
    when this is called.

    The LocalGroupLock MUST also be held. The LocalGroupLock is released
    by this routine, especially before requesting a remote system to move
    a group!

--*/

{
    PNM_NODE node;
    DWORD status = ERROR_SUCCESS;
    PFM_RESOURCE resource;
    PLIST_ENTRY  listEntry;
    PRESOURCE_ENUM  resourceList=NULL;
    DWORD  dwMoveStatus = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
            "[FM] CompleteMoveGroup: Entry for <%1!ws!>\r\n",
            OmObjectName(Group) );

    resourceList = Group->MovingList;

    if ( resourceList == NULL ) {
        ClRtlLogPrint( LOG_NOISE,
                    "[FM] CompleteMoveGroup: No moving list!\n" );
        status = ERROR_SUCCESS;
        goto FnRestore;
    }

    node = DestinationNode;

    CL_ASSERT( node != NULL );
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] CompleteMoveGroup: Completing the move for group %1!ws! to node %2!ws! (%3!d!)\n",
               OmObjectName(Group),
               OmObjectId(node),
               NmGetNodeId(node));


    status = FmpOfflineResourceList( resourceList, TRUE );

    if ( status != ERROR_SUCCESS )  {
        //by now the group must be offline!
        //if not, mail the move, the resource that fails to go
        //offline will force the other resources to come online
        //again.
        //how do we handle shutdowns
        goto FnRestore;
    }

    // for now make sure that the group state is propagated here
    // In general it is propagated by the worker thread. Since
    // the ownership is going to change, we want to make sure that the
    // last known state is propagated from this node to others before
    // that.
    FmpPropagateGroupState(Group);

    //
    // Chittur Subbaraman (chitturs) - 10/01/1999
    //
    // If the other system is not up, then fail now. Note that this
    // check must be done only AFTER ensuring that the group state
    // is stable. Otherwise some funny corner cases can result.
    // E.g., If the complete move operation is aborted when one or
    // more resources are in offline pending state since the destination
    // node went down, then you first terminate the resource list and
    // then online the list. As a part of all this, the online pending
    // or the online states of the resources could be propagated
    // synchronously. Now, the offline notification from the previous
    // offline attempt could come in and be processed by the FM worker
    // thread way too late and you could have spurious resource states
    // in FM while the real resource state is different. Another
    // issue here is during the lengthy offline operation here, the
    // destination node could go down and come back up soon after and
    // so aborting the move may not be prudent in such a case.
    //
    // But, don't do this optimization for the quorum group. This is
    // because once the quorum group is made offline, then MM
    // could decide who the group owner is. So, you may not be able to
    // bring the group online necessarily in this node. To avoid such
    // a case, we let FmcTakeGroupRequest fail and then let either the
    // retry loop here move the group somewhere else or let the
    // FM node down handler decide on the group's owner consulting
    // with MM.
    //
    if ( ( NmGetExtendedNodeState(node) != ClusterNodeUp ) &&
         ( Group != gpQuoResource->Group ) )  
    {
        status = ERROR_HOST_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpCompleteMoveGroup: Restoring group <%1!ws!> on local node due to destination node unavailability...\n",
                      OmObjectName(Group));
        goto FnRestore;
    }

    // SS::
    // After this point the responsibility of failing the group
    // back due to resource failures is with the destination code.
    // If there is a failure to bring the resources online,
    // the local restart policy on the destination node must kick
    // in.
    //
    // if there is an rpc failure to communicate with the other node
    // I suppose we should bring the resources online here again
    // However, rpc failures can be pretty non descriptive - there is
    // no way to determine from rpc errors if the rpc call actually
    // executed on the remote side
    //
    // but unless we are pretty careful about this and do what gum does
    // on rpc failures(banish the destination node) there is no way to
    // guarantee that both nodes dont retry to restart the group

    // If the destination node begins the process of bringing resources
    // in the group online, FmsTakeGroupRequest must return success(note
    // it should not return ERROR_IO_PENDING), else
    // it returns an error code and this node will bring the group back
    // to its previous state.

    // Assume the other node is going to take ownership. This is done
    // before, in case the Group state changes. We want to accept the
    // Group/resource state changes from the remote system when they
    // arrive. We've already verified that node is in the preferred list!
    //
    //we will reacquire the lock after making the rpc call

    // SS::
    // After this point the responsibility of failing the group
    // back due to resource failures is with the destination code.
    // If there is a failure to bring the resources online,
    // the local restart policy on the destination node must kick
    // in.
    //
    // if there is an rpc failure to communicate with the other node
    // I suppose we should bring the resources online here again
    // However, rpc failures can be pretty non descriptive - there is
    // no way to determine from rpc errors if the rpc call actually
    // executed on the remote side
    //
    // but unless we are pretty careful about this and do what gum does
    // on rpc failures(banish the destination node) there is no way to
    // guarantee that both nodes dont retry to restart the group

    // If the destination node begins the process of bringing resources
    // in the group online, FmsTakeGroupRequest must return success(note
    // it should not return ERROR_IO_PENDING), else
    // it returns an error code and this node will bring the group back
    // to its previous state.

    // Assume the other node is going to take ownership. This is done
    // before, in case the Group state changes. We want to accept the
    // Group/resource state changes from the remote system when they
    // arrive. We've already verified that node is in the preferred list!
    //

    //
    //  Chittur Subbaraman (chitturs) - 5/18/99
    //
    //  Modified to handle the move group request of a quorum group in 
    //  case the destination node could not arbitrate for the quorum
    //  resource.
    //
    do
    {
        //
        // Before making the RPC, set the intended owner of the group
        //
        FmpSetIntendedOwnerForGroup( Group, NmGetNodeId( node ) );

        try {
            ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpCompleteMoveGroup: Take group %2!ws! request to remote node %1!ws!\n",
                        OmObjectId(node),
                        OmObjectId(Group));

            dwMoveStatus = status = FmcTakeGroupRequest( node, OmObjectId( Group ), resourceList );
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            LPCWSTR     pszNodeId;
            LPCWSTR     pszGroupId;

            status = GetExceptionCode ();

            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCompleteMoveGroup: Exception in FmcTakeGroupRequest %2!ws! request to remote node %1!ws!, status=%3!u!\n",
                OmObjectId(node),
                OmObjectId(Group),
                status);

            //
            // An exception from RPC indicates that the other node is either dead
            // or insane. We dont know whether it took ownership or not.
            // So, let the FM node down handler handle the group.
            //
            GumCommFailure( GumUpdateFailoverManager,
                            NmGetNodeId(node),
                            GetExceptionCode(),
                            TRUE );
            //
            // The new owner node that is now dead might have set the intended
            // owner as NULL or it might not have set this. It might have 
            // set the owner node to himself or might not have.
            // If it has set the owner node for this group as himself, then
            // the FM node down handler will assume responsibility for this
            // group. If the target node dies before it sets himself as the owner,
            // then again, the FM node down handler will assume responsibility
            // for the group. We wake up when the gum sync handling is over.
            // Right now, the gum update for the owner node may still be in
            // progress so we cant be sure if that update was completed on
            // all nodes.
            //

            //
            //  Chittur Subbaraman (chitturs) - 6/7/99
            //
            //  Issue a GUM update to handle this group. Using this
            //  GUM update prevents any race condition with the
            //  node down processing code.
            //

            //
            //  TODO: This does not cover the case in which 
            //  FmpTakeGroupRequest crashes after setting the
            //  intended owner to invalid ID. In such a case, 
            //  the following handler won't take ownership of the
            //  group. Also, claim handler will not touch the
            //  group.
            //
            pszNodeId = OmObjectId( node );
            pszGroupId = OmObjectId( Group );
            
            GumSendUpdateEx( GumUpdateFailoverManager,
                             FmUpdateCompleteGroupMove,
                             2,
                             (lstrlenW(pszNodeId)+1)*sizeof(WCHAR),
                             pszNodeId,
                             (lstrlenW(pszGroupId)+1)*sizeof(WCHAR),
                             pszGroupId);
                             
            status = ERROR_HOST_NODE_NOT_AVAILABLE;                     
            goto FnExit;
        }

        if ( status == ERROR_RETRY )
        {
            //
            //  The destination refused to take the quorum group since it
            //  did not win the arbitration. So let us see who won the
            //  arbitration.
            //
            DWORD  dwSelectedQuorumOwnerId;

            CL_ASSERT( Group == gpQuoResource->Group ); 

            ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpCompleteMoveGroup: Remote node asked us to resend take group request for group %1!ws! to another node ...\n",
                       OmObjectId( Group ));

            //
            //  Get the ID of the node which the MM believes is the best
            //  candidate to own the quorum resource. This is a call that
            //  blocks while RGP is in progress.
            //
            MMApproxArbitrationWinner( &dwSelectedQuorumOwnerId );

            if ( ( dwSelectedQuorumOwnerId == NmGetNodeId( NmLocalNode ) ) ||
                 ( dwSelectedQuorumOwnerId == MM_INVALID_NODE ) )
            {
                //
                //  The local node is chosen by MM or no node is chosen by
                //  the MM. The latter case will happen if no RGP has
                //  occurred at the time this call is made. Let us see if we 
                //  can arbitrate for the quorum resource.
                //
                status = FmpRmArbitrateResource( gpQuoResource );
         
                if ( status != ERROR_SUCCESS ) 
                {
                    //
                    //  Too bad. We will halt and let FmpNodeDown handler
                    //  handle the quorum group.
                    //
                    ClRtlLogPrint(LOG_NOISE,
                              "[FM] FmpCompleteMoveGroup: Local node %1!u! cannot arbitrate for quorum group %3!ws!, Status = %2!u!...\n",
                               dwSelectedQuorumOwnerId,
                               status,
                               OmObjectId( Group ));
                    CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
                }
                status = ERROR_RETRY;
                break;
            } 
                           
            node = NmReferenceNodeById( dwSelectedQuorumOwnerId );

            if ( node == NULL )
            {
                ClRtlLogPrint(LOG_CRITICAL,
                            "[FM] FmpCompleteMoveGroup: Selected node %1!u! cannot be referenced...\n",
                            dwSelectedQuorumOwnerId);
                CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
            }           
        } // if
    } while ( status == ERROR_RETRY );
        
    // At this point, the onus of taking care of the group is with the
    // destination node whether it means restarting the group or
    // failing it back

FnRestore:
    //if there is any failure try and restore the previous states
    if ((status != ERROR_IO_PENDING) && (status != ERROR_SUCCESS))
    {
        //
        //  Chittur Subbaraman (chitturs) - 3/22/2000
        //
        //  Reset the group's intended owner to invalid node ID if the
        //  node down handler did not do that.
        //
        if ( dwMoveStatus != ERROR_SUCCESS )
        {
            if ( FmpSetIntendedOwnerForGroup( Group, ClusterInvalidNodeId )
                  == ERROR_CLUSTER_INVALID_NODE )
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpCompleteMoveGroup: Group <%1!ws!> has already been processed by node down handler....\r\n",
                    OmObjectName(Group));
                goto FnExit;
            }
        }

        if (resourceList)
        {           
            FmpTerminateResourceList( resourceList );
            //
            //  Chittur Subbaraman (chitturs) - 4/10/2000
            //
            //  Make sure to online the quorum group even if this node is
            //  shutting down. This is necessary so that other groups
            //  can be brought offline during this node's shutdown. Note
            //  that FmpOnlineResourceList would only online a group
            //  during a shutdown if the group is the quorum group.
            //
            if ( FmpFMGroupsInited )
                FmpOnlineResourceList( resourceList, Group );
        }
    } else
    {
        //
        //  Chittur Subbaraman (chitturs) - 4/19/99
        //
        //  If the FmpDoMoveGroupOnFailure thread is also waiting to do the
        //  move, then tell that thread to take its hands off.
        //
        if ( Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL )
        {
            Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE;
        }
    }
    
FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCompleteMoveGroup: Exit, status = %1!u!\r\n",
            status);

    //if the status is success or some other error, clean up the resource list
    if (status != ERROR_IO_PENDING)
    {
        if (resourceList)
        {
            FmpDeleteResourceEnum( resourceList );
            Group->MovingList = NULL;
        }

    }
    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmpCompleteMoveGroup



DWORD
FmpMovePendingThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Continue trying to move a group if ERROR_IO_PENDING is returned.
    We need to perform this operation, because part way through a move
    request, we could get a pending return status. The processing of the
    request is halted and the pending status is returned. However, the
    remainder of the move operation needs to be performed.

Arguments:

    Context - Pointer to the MOVE_GROUP structure to move.

Returns:

    ERROR_SUCCESS.

--*/

{
    PMOVE_GROUP moveGroup = (PMOVE_GROUP)Context;
    PFM_GROUP group;
    PNM_NODE node;
    DWORD   status;
    DWORD   loopCount = 100;   // Only try this so many times and then give up
    HANDLE  waitArray[2];

    group = moveGroup->Group;
    node = moveGroup->DestinationNode;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpMovePendingThread Entry.\n");

    //
    // We must attempt to finish the move request for this Group.
    //
    // We are waiting for a resource to go offline and it finally goes
    // offline and the Group's pending event is set.
    //
    // Or we are waiting for cluster shutdown (FmpShutdownEvent)
    //
WaitSomeMore:
    //acquire the lock since fmpwaitforgroup() releases it
    FmpAcquireLocalGroupLock( group );
    status = FmpWaitForGroup(group);
    if (status == ERROR_SHUTDOWN_IN_PROGRESS) {
        //
        // We've been asked to shutdown
        //

    } else if (status == ERROR_SUCCESS) {
        //acquire the group lock before calling FmpCompleteMoveGroup
        FmpAcquireLocalGroupLock( group );
        status = FmpCompleteMoveGroup( group, node );
        if ( status == ERROR_IO_PENDING ) {
            Sleep(500); // [HACKHACK] kludgy, I know, but nice solution might break something else
            goto WaitSomeMore;
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmpMovePendingThread got error %1!d! waiting for group to shutdown.\n",
                   status);
    }
    //
    // We're done with the move now.
    //
    if ( status != ERROR_IO_PENDING ) {
        CL_ASSERT( group->MovingList == NULL );
    }

    //
    // Now dereference the Group and node object (if non-NULL) and
    // free our local context.
    //
    OmDereferenceObject( group );
    if ( node != NULL ) {
        OmDereferenceObject( node );
    }
    LocalFree( Context );

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpMovePendingThread Exit.\n");

    return(ERROR_SUCCESS);
} // FmpMovePendingThread



DWORD
FmpCreateMovePendingThread(
    IN PFM_GROUP Group,
    IN PNM_NODE  DestinationNode
    )

/*++

Routine Description:

    Crate a thread that will continue to call the move routine for a given
    Group.

Arguments:

    Group - A pointer to the Group to move.

    DestinationNode - The destination node for the move request.

Returns:

    ERROR_IO_PENDING if the thread was created successfully. This assumes
        that this routine was called because of this error return.

    A Win32 error code on failure.

--*/
{
    HANDLE          threadHandle=NULL;
    DWORD           threadId;
    PMOVE_GROUP     context=NULL;
    DWORD           status=ERROR_IO_PENDING;    //assume success

    FmpAcquireLocalGroupLock( Group );

    if ( Group->OwnerNode != NmLocalNode ) {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnExit;
    }
    //
    // If there is a pending event, then the group is not available for any
    // new requests.
    //
    if ( FmpIsGroupPending(Group) ) {
        status = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    context = LocalAlloc(LMEM_FIXED, sizeof(MOVE_GROUP));
    if ( context == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Keep reference on the Group and node object (if present) while we
    // retain pointers.
    //
    OmReferenceObject( Group );
    if ( DestinationNode != NULL ) {
        OmReferenceObject( DestinationNode );
    }

    //
    // Fill in context fields
    //
    context->Group = Group;
    context->DestinationNode = DestinationNode;

    threadHandle = CreateThread( NULL,
                                 0,
                                 FmpMovePendingThread,
                                 context,
                                 0,
                                 &threadId );

    if ( threadHandle == NULL )
    {
        OmDereferenceObject( Group );
        if ( DestinationNode != NULL ) {
            OmDereferenceObject( DestinationNode );
        }
        status = GetLastError();
        LocalFree(context);
        goto FnExit;
    }


FnExit:
    if (threadHandle) CloseHandle( threadHandle );
    FmpReleaseLocalGroupLock( Group );
    return(status);

} // FmpCreateMovePendingThread



DWORD
FmpDoMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode,
    IN BOOL bChooseMostPreferredNode
    )

/*++

Routine Description:

    This routine performs the action of moving a Group. This requires taking
    a Group offline and then bringing the Group online. The Offline and
    Online requests may pend, so we have to pick up the work in order to
    complete the request. This means handling the offline pending case, since
    the online pending request will eventually complete.

Arguments:

    Group - The Group to move.

    DestinationNode - The destination node for the move request.

    bChooseMostPreferredNode - If the destination node is not supplied,
        indicates whether to choose the most preferred node or not.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    PNM_NODE    node;
    PNM_NODE    ChosenDestinationNode = NULL;

    //
    // We can only support one request on this Group at a time.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpDoMoveGroup: Entry\r\n");

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    if ( FmpIsGroupPending(Group) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_GROUP_NOT_AVAILABLE);
    }

    node = Group->OwnerNode;
    // Note: the local group lock is released by the FmpMoveGroup routine.
    status = FmpMoveGroup( Group, DestinationNode, FALSE, &ChosenDestinationNode, bChooseMostPreferredNode );

    //
    // If we were the owner of the group and the request is pending, then
    // start a thread to complete the move request.
    //
    if ( (node == NmLocalNode) &&
         (status == ERROR_IO_PENDING) ) {
        status = FmpCreateMovePendingThread( Group, ChosenDestinationNode );
    }

    //
    //  Chittur Subbaraman (chitturs) - 7/31/2000
    //
    //  Log an event to the eventlog if the group is moving due to a failure.
    //
    if ( ( bChooseMostPreferredNode == FALSE ) &&
         ( ( status == ERROR_SUCCESS ) || ( status == ERROR_IO_PENDING ) ) )
    {
        CsLogEvent3( LOG_NOISE,
                     FM_EVENT_GROUP_FAILOVER,
                     OmObjectName(Group),
                     OmObjectName(NmLocalNode), 
                     OmObjectName(ChosenDestinationNode) );
    }

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpDoMoveGroup: Exit, status = %1!u!\r\n",
        status);
    return(status);

} // FmpDoMoveGroup



DWORD
FmpTakeGroupRequest(
    IN PFM_GROUP Group,
    IN PRESOURCE_ENUM ResourceList
    )

/*++

Routine Description:

    Performs a Take Group Request from (THE) remote system and returns
    status for that request.

Arguments:

    Group - The Group to take online locally.
    ResourceList - The list of resources and their states.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    DWORD   status = ERROR_SUCCESS;
   
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpTakeGroupRequest: To take group '%1!ws!'.\n",
               OmObjectId(Group) );

    FmpAcquireLocalGroupLock( Group );

    if ( !FmpFMOnline ) 
    {
        if (FmpShutdown)
            status = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
        else
            status = ERROR_CLUSTER_NODE_NOT_READY;
        CL_LOGFAILURE(status);

        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpTakeGroupRequest: Group '%1!ws!' cannot be accepted, status=%2!u!...\n",
                    OmObjectId(Group),
                    status);
        //
        //  Chittur Subbaraman (chitturs) - 7/5/2000
        //
        //  Make sure you ask the source node to relocate the quorum group some place else
        //  after consulting with MM.
        //
        if ( gpQuoResource->Group == Group ) status = ERROR_RETRY;
        
        goto FnExit;            
    }


    //every body should be able to host the quorum group
    //so we dont check the prefferred owner list for this group
    if ( ( gpQuoResource->Group != Group) && 
        !FmpInPreferredList( Group, NmLocalNode, FALSE, NULL) ) 
    {

        //
        // Nobody should ever ask us to take a group that can't run here.
        //
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        CL_LOGFAILURE( status);
        goto FnExit;
    }

    //
    // Take ownership of the Group.
    //
    if ( Group->OwnerNode == NmLocalNode ) {
        //SS:://We are alreay the owner ?? How did this happen
        status = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 5/18/99
    //
    //  Handle quorum group in a special way. Make sure you can arbitrate
    //  for the quorum resource. If not, you could get killed when you
    //  try to bring it online and you fail.
    //
    if ( Group == gpQuoResource->Group )
    {      
        status = FmpRmArbitrateResource( gpQuoResource );

        if ( status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpTakeGroupRequest: MM did not select local node %1!u! as the arbitration winner...\n\r",
                      NmLocalNodeId,
                      status);
            status = ERROR_RETRY;
            goto FnExit;
        }
    }

    status = FmpSetOwnerForGroup( Group, NmLocalNode );

    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpTakeGroupRequest: Set owner GUM update returns %1!u! for group <%2!ws!>...\n\r",
                      status,
                      OmObjectId(Group)); 
        if ( status == ERROR_GROUP_NOT_AVAILABLE )
        {
            //
            // If the node down processing GUM handler has claimed ownership
            // of this group, consider everything as being fine.
            //
            status = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    FmpSetIntendedOwnerForGroup(Group, ClusterInvalidNodeId);

    // prepare to bring this group online
    FmpPrepareGroupForOnline( Group );

    //
    // Online what needs to be online.
    //
    //  SS: Note that we ignore the error from FmpOnlineResourceList
    //  This is because at this point the onus of taking care of the group
    //  is with us.
    //
    FmpOnlineResourceList( ResourceList, Group );

FnExit:
    FmpReleaseLocalGroupLock( Group );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpTakeGroupRequest: Exit for group <%1!ws!>, Status = %2!u!...\n",
               OmObjectId(Group),
               status);

    return(status);

} // FmpTakeGroupRequest






DWORD
FmpUpdateChangeGroupName(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NewName
    )
/*++

Routine Description:

    GUM dispatch routine for changing the friendly name of a group.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    ResourceId - Supplies the group ID.

    NewName - Supplies the new friendly name.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_GROUP Group;
    DWORD Status;

    //
    // Chittur Subbaraman (chitturs) - 4/19/98
    //
    // If FM groups are not initialized or FM is shutting down, don't
    // do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    Group = OmReferenceObjectById(ObjectTypeGroup, GroupId);
    if (Group == NULL) {
        return(ERROR_GROUP_NOT_FOUND);
    }

    Status = OmSetObjectName( Group, NewName);
    if (Status == ERROR_SUCCESS) {
        ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group);
    }
    OmDereferenceObject(Group);

    return(Status);

} // FmpUpdateChangeGroupName



BOOL
FmpEnumGroupNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Group enumeration callback for removing node references when
    a node is evicted.

Arguments:

    Context1 - Supplies the node that is being evicted.

    Context2 - not used

    Object - Supplies a pointer to the group object

    Name - Supplies the object name.

Return Value:

    TRUE to continue enumeration

--*/

{
    PFM_GROUP Group = (PFM_GROUP)Object;
    PNM_NODE Node = (PNM_NODE)Context1;
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] EnumGroupNodeEvict: Removing references to node %1!ws! from group %2!ws!\n",
               OmObjectId(Node),
               OmObjectId(Group));

    FmpAcquireLocalGroupLock(Group);

    //
    // Walk the list of preferred owners. If this node is in the list, remove it.
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        if ( preferredEntry->PreferredNode == Node ) {
            RemoveEntryList(&preferredEntry->PreferredLinkage);
            OmDereferenceObject(preferredEntry->PreferredNode);
            LocalFree(preferredEntry);
            break;
        }
    }

    FmpReleaseLocalGroupLock(Group);
    ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group);

    return(TRUE);

} // FmpEnumGroupNodeEvict


VOID
FmpSignalGroupWaiters(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Wakes up any threads waiting for this group to achieve a
    stable state.

Arguments:

    Group - Supplies the group.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PFM_WAIT_BLOCK WaitBlock;

    FmpAcquireLocalGroupLock( Group );

    while (!IsListEmpty(&Group->WaitQueue)) {
        ListEntry = RemoveHeadList(&Group->WaitQueue);
        WaitBlock = CONTAINING_RECORD(ListEntry,
                                      FM_WAIT_BLOCK,
                                      ListEntry);
        WaitBlock->Status = ERROR_SUCCESS;
        SetEvent(WaitBlock->hEvent);
    }

    FmpReleaseLocalGroupLock( Group );
}


DWORD
FmpWaitForGroup(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Waits for a group to reach a stable state.

Arguments:

    Group - supplies the group

Comments - Assumption, is that the group lock is held when this is called.
    This function releases the group lock before the wait

Return Value:

    ERROR_SUCCESS if successful

    ERROR_SHUTDOWN_IN_PROGRESS if the cluster is being shutdown

    Win32 error code otherwise

--*/

{
    FM_WAIT_BLOCK WaitBlock;
    HANDLE WaitArray[2];
    DWORD Status;
    CLUSTER_GROUP_STATE GroupState;

    WaitBlock.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (WaitBlock.hEvent == NULL) {
        FmpReleaseLocalGroupLock( Group );
        return(GetLastError());
    }


    //
    // Check to see if it transitioned before we got the lock.
    //
    GroupState = FmpGetGroupState( Group , TRUE );
    if ((GroupState == ClusterGroupOffline) ||
        (GroupState == ClusterGroupOnline) ||
        (GroupState == ClusterGroupFailed)) {

        CloseHandle( WaitBlock.hEvent );
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SUCCESS);
    }

    //
    // Chittur Subbaraman (chitturs) - 10/31/1999
    //
    // Now before waiting, really make sure one or more resources in the 
    // group is in pending state.
    //
    GroupState = FmpGetGroupState( Group, FALSE );

    if ( GroupState != ClusterGroupPending ) {
        CloseHandle( WaitBlock.hEvent );
        FmpReleaseLocalGroupLock( Group );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpWaitForGroup: Group <%1!ws!> state is %2!d!, not waiting for event...\r\n",
            OmObjectName(Group),
            GroupState );
        return( ERROR_SUCCESS );       
    }

    //
    // Add this wait block to the queue.
    //

    InsertTailList(&Group->WaitQueue, &WaitBlock.ListEntry);

    FmpReleaseLocalGroupLock( Group );

    //
    // Wait for the group to become stable or for the cluster to shutdown.
    //
    WaitArray[0] = FmpShutdownEvent;
    WaitArray[1] = WaitBlock.hEvent;

    Status = WaitForMultipleObjects(2, WaitArray, FALSE, INFINITE);
    CloseHandle(WaitBlock.hEvent);
    if (Status == 0) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    } else {
        return(WaitBlock.Status);
    }
}

/****
@func       DWORD | FmpDeleteGroup| This makes the gum call to delete the
            group.

@parm       IN PFM_GROUP | pGroup | The group that must be deleted.
            
@comm       The group lock must be held when calling this api.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD 
FmpDeleteGroup(
    IN PFM_GROUP pGroup)
{
    PCWSTR  pszGroupId;
    DWORD   dwBufSize;
    DWORD   dwGroupLen;
    DWORD   dwStatus;

    pszGroupId = OmObjectId( pGroup );
    dwGroupLen = (lstrlenW(pszGroupId)+1) * sizeof(WCHAR);

    //
    // Send message.
    //
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateDeleteGroup,
                             1,
                             dwGroupLen,
                             pszGroupId);


    return(dwStatus);

}


VOID
FmpGroupLastReference(
    IN PFM_GROUP pGroup
    )

/*++

Routine Description:

    Last dereference to group object processing routine.
    All cleanup for a group should really be done here!

Arguments:

    Resource - pointer the group being removed.

Return Value:

    None.

--*/

{
    if ( pGroup->OwnerNode != NULL )
        OmDereferenceObject(pGroup->OwnerNode);
    if (pGroup->dwStructState  & FM_GROUP_STRUCT_CREATED)
        DeleteCriticalSection(&pGroup->Lock);
    
    return;

} // FmpGroupLastReference

DWORD
FmpDoMoveGroupOnFailure(
    IN LPVOID pContext
    )

/*++

Routine Description:

    Move a group after ensuring that all resources in the group are
    in stable state. This thread is forked from FmpHandleGroupFailure.

Arguments:

    pContext - Pointer to the MOVE_GROUP structure to move.

Returns:

    ERROR_SUCCESS.

--*/

{
    PMOVE_GROUP     pMoveGroup = ( PMOVE_GROUP ) pContext;
    PFM_GROUP       pGroup;
    DWORD           dwStatus;
    PLIST_ENTRY     pListEntry;
    PFM_RESOURCE    pResource;

    //
    //  Chittur Subbaraman (chitturs) - 4/13/99
    //
    //  This thread first waits until all the resources within the
    //  failed group are in stable state and then initiates the
    //  move.
    //
    pGroup = pMoveGroup->Group;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpDoMoveGroupOnFailure: Entry for Group <%1!ws!>...\n",
        OmObjectId(pGroup));

TryAgain:
    FmpAcquireLocalGroupLock( pGroup );

    //
    //  This thread must yield if someone else takes responsibility for
    //  the move. 
    //
    //  Condition 1: Protects against the case in which someone moves
    //  the group to another node and back to you while this thread is
    //  sleeping (very rare, I agree).
    //
    //  Condition 2: Protects against the common move case.
    //
    //  Condition 3: Protects against the case in which the 
    //  FmpMovePendingThread is waiting in FmpWaitForGroup while
    //  this thread got the resource lock and reached here.
    //
    if ( ( pGroup->dwStructState & 
           FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE ) ||
         ( pGroup->OwnerNode != NmLocalNode ) ||
         ( pGroup->MovingList != NULL ) )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpDoMoveGroupOnFailure: Group <%1!ws!> move being yielded to someone else who is moving it...\n",
                  OmObjectId(pGroup));      
        goto FnExit;
    } 

    //
    //  If FM is shutting down, just exit.
    //
    if ( FmpShutdown )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpDoMoveGroupOnFailure: Giving up Group <%1!ws!> move. FM is shutting down ...\n",
                  OmObjectId(pGroup));      
        goto FnExit;
    } 
    
    //
    // If the group has been marked for delete, then also exit. This is 
    // just an optimization. FmpDoMoveGroup does this check also.
    //
    if ( !IS_VALID_FM_GROUP( pGroup ) )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpDoMoveGroupOnFailure: Group <%1!ws!> marked for delete. Exiting ...\n",
                  OmObjectId(pGroup));      
        goto FnExit;
    }
    
    //
    // Wait until all resources within the group become stable.
    //
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &(pGroup->Contains);
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry, 
                                       FM_RESOURCE, 
                                       ContainsLinkage );
        if ( pResource->State > ClusterResourcePending )
        {
            FmpReleaseLocalGroupLock( pGroup );
            Sleep ( 200 );
            goto TryAgain;
        }
    }    

    //
    //  Initiate a move now that the group is quiet.
    //
    dwStatus = FmpDoMoveGroup( pGroup, NULL, FALSE );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDoMoveGroupOnFailure: FmpDoMoveGroup returns %1!u!\n",
                 dwStatus);

FnExit:     
    LocalFree( pContext );

    pGroup->dwStructState &= 
        ~( FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL | FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE );
                 
    FmpReleaseLocalGroupLock( pGroup ); 

    OmDereferenceObject( pGroup );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDoMoveGroupOnFailure Exit.\n");

    return( ERROR_SUCCESS );
} // FmpDoMoveGroupOnFailure


/****
@func       DWORD | FmpSetIntendedOwnerForGroup| This makes the gum call
            to set the intended owner for the group before a move.

@parm       IN PFM_GROUP | pGroup | The group whose intended owner 
            is to be set.

@comm       The local group lock is held while making this call.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD   FmpSetIntendedOwnerForGroup(
    IN PFM_GROUP pGroup,
    IN DWORD     dwNodeId)
{

    PCWSTR  pszGroupId;
    DWORD   dwGroupLen;
    DWORD   dwStatus;


    pszGroupId = OmObjectId( pGroup );
    dwGroupLen = (lstrlenW(pszGroupId)+1) * sizeof(WCHAR);

    //
    // Send message.
    //
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateGroupIntendedOwner,
                             2,
                             dwGroupLen,
                             pszGroupId,
                             sizeof(DWORD),
                             &dwNodeId
                             );


    return(dwStatus);
}

/****
@func       DWORD | FmpSetOwnerForGroup | On a move the new owner
            node makes this gum call to inform all nodes that it
            owns this particular group.

@parm       IN PFM_GROUP | pGroup | The group whose owner must be set.

@parm       IN PNM_NODE | pNode | The group's owner node.

@comm       The local group lock is held while making this call.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD   FmpSetOwnerForGroup(
    IN PFM_GROUP pGroup,
    IN PNM_NODE  pNode
    )
{

    PCWSTR  pszGroupId;
    PCWSTR  pszNodeId;
    DWORD   dwGroupLen;
    DWORD   dwNodeLen;
    DWORD   dwStatus;

    pszGroupId = OmObjectId( pGroup );
    dwGroupLen = (lstrlenW(pszGroupId)+1) * sizeof(WCHAR);
    pszNodeId = OmObjectId(pNode);
    dwNodeLen = (lstrlenW(pszNodeId)+1) * sizeof(WCHAR);

    //
    // Send message.
    //
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateCheckAndSetGroupOwner,
                             2,
                             dwGroupLen,
                             pszGroupId,
                             dwNodeLen,
                             pszNodeId
                             );


    return(dwStatus);
}

PNM_NODE
FmpGetNodeNotHostingUndesiredGroups(
    IN PFM_GROUP pGroup,
    IN BOOL fRuleOutLocalNode
    )

/*++

Routine Description:

    Find a preferred node that does not host groups with CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME
    property set to the same value as the supplied group.

Arguments:

    pGroup - Pointer to the group object we're checking.

    fRuleOutLocalNode - Should the local node be considered or not.

Return Value:

    Pointer to node object that satisfies the anti-affinity condition.

    NULL if a node cannot be not found.

Note:

    The antiaffinity property value is defined as a MULTI_SZ property. However for this implementation
    we ignore all the string values beyond the first value. The MULTI_SZ definition is to allow
    future expansion of the algorithm implemented by this function.

--*/

{
    PLIST_ENTRY                 plistEntry;
    PPREFERRED_ENTRY            pPreferredEntry;
    GROUP_AFFINITY_NODE_INFO    GroupAffinityNodeInfo;
    PNM_NODE                    pNode = NULL;
    DWORD                       dwIndex = 0, i;
    DWORD                       dwClusterHighestVersion;

    GroupAffinityNodeInfo.ppNmNodeList = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 3/6/2001
    //
    //  This function works as follows.  First, it makes a list of possible candidate nodes that the
    //  group can be hosted on.  Next, it enumerates all groups in the cluster and for those
    //  groups that have the AntiAffinityClassName property set, it will remove those group's
    //  current owner nodes from the list of possible candidate nodes if they are present there.
    //  Note that this function will return a node only if the pruning has positively taken place.
    //  Else, it will return NULL. 
    //
    //  IMPORTANT NOTE: This function is called by all nodes from the node down processing FM
    //  GUM handler. For all nodes to reach exactly the same decision on the group placement,
    //  it is crucial that all nodes call this function for groups in exactly the same order.
    //  E.g., if node 1 was hosting groups A, B and C and it died, then all the remaining nodes
    //  must call this function first for group A, then for group B and finally for group C.
    //  This is because once group A is placed by this function, then group B's placement is
    //  influenced by group A's placement and similarly for groups B and C. This order is 
    //  ensured since all nodes OM will maintain groups in the same order since OM creates this
    //  list based on enumerating the group key (under Cluster\Groups) and that must occur in the
    //  same order in all nodes.
    //
    
    //
    //  It is too bad that we can't hold any locks while enumerating groups and looking at the
    //  property field since that will soon result in a deadlock (since we can't hold group locks
    //  from within a GUM and this function is invoked from a GUM).
    //
    
    //
    //  If we are dealing with the mixed mode cluster or if the group does not have the antiaffinity
    //  property set, then don't do anything.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < NT51_MAJOR_VERSION ) ||
         ( pGroup->lpszAntiAffinityClassName == NULL ) )
    {
        goto FnExit;
    }
    
    //
    //  Initialize the node list.
    //
    GroupAffinityNodeInfo.ppNmNodeList = LocalAlloc ( LPTR, 
                                                      ClusterDefaultMaxNodes * sizeof ( PNM_NODE ) );

    if ( GroupAffinityNodeInfo.ppNmNodeList == NULL )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpGetNodeNotHostingUndesiredGroups: Failed in alloc, Status %1!d!\n",
                      GetLastError());
        goto FnExit;
    }
    
    //
    //  For each entry in the preferred list, find a system that is up and that does not
    //  host any groups with an anti-affinity to the supplied group.
    //
    for ( plistEntry = pGroup->PreferredOwners.Flink;
          plistEntry != &(pGroup->PreferredOwners);
          plistEntry = plistEntry->Flink ) 
    {
        pPreferredEntry = CONTAINING_RECORD( plistEntry,
                                             PREFERRED_ENTRY,
                                             PreferredLinkage );

        if ( NmGetNodeState( pPreferredEntry->PreferredNode ) == ClusterNodeUp ) 
        {
            if ( ( fRuleOutLocalNode ) &&
                 ( pPreferredEntry->PreferredNode == NmLocalNode ) ) continue;              
            GroupAffinityNodeInfo.ppNmNodeList[dwIndex] = pPreferredEntry->PreferredNode;
            dwIndex ++;
        }
    } // for

    //
    //  Initialize the other fields in the GroupAffinityNodeInfo structure.
    //
    GroupAffinityNodeInfo.pGroup = pGroup;
    GroupAffinityNodeInfo.fDidPruningOccur = FALSE;

    //
    //  Enumerate all the groups and rule out nodes that host groups with the supplied
    //  anti-affinity property set.
    //
    OmEnumObjects ( ObjectTypeGroup,
                    FmpCheckForAntiAffinityProperty,
                    pGroup->lpszAntiAffinityClassName,
                    &GroupAffinityNodeInfo );

    //
    //  No pruning occurred so far. So, don't proceed further and let the caller decide on
    //  a best node for the group using some other algorithm.
    //
    if ( GroupAffinityNodeInfo.fDidPruningOccur == FALSE )
    {
        goto FnExit;
    }

    //
    //  Now, pick the first node from the list that is a valid node.
    //
    for ( i=0; i<ClusterDefaultMaxNodes; i++ )
    {
        if ( GroupAffinityNodeInfo.ppNmNodeList[i] != NULL )
        {
            pNode = GroupAffinityNodeInfo.ppNmNodeList[i];
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpGetNodeNotHostingUndesiredGroups: Choosing node %1!d! for group %2!ws! [%3!ws!]...\n",
                          NmGetNodeId(pNode),
                          OmObjectId(pGroup),
                          OmObjectName(pGroup));       
            goto FnExit;
        }
    } // for

FnExit:
    LocalFree( GroupAffinityNodeInfo.ppNmNodeList );
    return( pNode );
} // FmpGetNodeNotHostingUndesiredGroups

BOOL
FmpCheckForAntiAffinityProperty(
    IN LPCWSTR lpszAntiAffinityClassName,
    IN PGROUP_AFFINITY_NODE_INFO pGroupAffinityNodeInfo,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupName
    )
/*++

Routine Description:

    Remove a node from the supplied node list if it hosts the supplied group with the supplied
    anti-affinity property set.

Arguments:

    lpszAntiAffinityClassName - The name property to check for.

    pGroupAffinityNodeInfo - Structure containing a list of nodes that is to be pruned possibly.

    pGroup - Supplies the group.

    lpszGroupName - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    
    FALSE - to indicate that the enumeration should not continue.

--*/
{
    DWORD   i;
    
    //
    //  If the supplied group has the anti-affinity property not set or if it has the
    //  property set but is not same as the one we are checking against or if it is same
    //  as the group we are interested in placing, then just return specifying that the 
    //  enum should continue.
    //
    if ( ( pGroup->lpszAntiAffinityClassName == NULL ) ||
         ( pGroup == pGroupAffinityNodeInfo->pGroup ) ||
         ( lstrcmp ( lpszAntiAffinityClassName, pGroup->lpszAntiAffinityClassName ) != 0 ) )
    {
        goto FnExit;
    }

    //
    //  If you reached here, this means that the supplied group has the anti-affinity property
    //  set and is same as the property we are checking against. So, prune the node list.
    //
    for ( i=0; i<ClusterDefaultMaxNodes; i++ )
    {
        if ( ( pGroupAffinityNodeInfo->ppNmNodeList[i] != NULL ) &&
             ( pGroup->OwnerNode == pGroupAffinityNodeInfo->ppNmNodeList[i] ) )
        {
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpCheckForAntiAffinityProperty: Pruning node %1!d! for group %2!ws! due to "
                          "group %3!ws!, AntiAffinityClassName=%4!ws!...\n",
                          NmGetNodeId(pGroupAffinityNodeInfo->ppNmNodeList[i]),
                          OmObjectId(pGroupAffinityNodeInfo->pGroup),
                          OmObjectId(pGroup),
                          lpszAntiAffinityClassName);                  
            pGroupAffinityNodeInfo->ppNmNodeList[i] = NULL;
            //
            //  Mark that pruning was attempted. 
            //
            pGroupAffinityNodeInfo->fDidPruningOccur = TRUE; 
            goto FnExit;
        } // if
    } // for

FnExit:    
    return( TRUE );
} // FmpCheckForAntiAffinityProperty

PNM_NODE
FmpPickNodeFromPreferredListAtRandom(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pSuggestedPreferredNode  OPTIONAL,
    IN BOOL fRuleOutLocalNode,
    IN BOOL fCheckForDisablingRandomization
    )

/*++

Routine Description:

    Find a preferred node for the group that is UP in a random fashion.

Arguments:

    pGroup - Pointer to the group object we're interested in.

    pSuggestedPreferredNode - Suggested fallback option in case this random result is undesired. OPTIONAL

    fRuleOutLocalNode - Should the local node be ruled out from consideration.

    fCheckForDisablingRandomization - Check whether randomization should be disabled.

Return Value:

    The preferred node that is picked.

    NULL if a node cannot be not found.

Comments:

    This function is called from both FmpMoveGroup as well as from FmpNodeDown. In the former case,
    we will have a non-NULL suggested preferred node, rule out local node option, check
    for property setting disabling randomization and check for mixed mode clusters to disable
    randomization. In the latter case, these parameters are the opposite.

--*/
{
    UUID                uuId;
    USHORT              usHashValue;
    PNM_NODE            pNode = NULL, pSelectedNode = pSuggestedPreferredNode;
    DWORD               dwNodeId;
    DWORD               dwRetry = 0;
    DWORD               dwStatus;
    DWORD               dwDisabled = 0;
    DWORD               dwClusterHighestVersion;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/2001
    //
    if ( fCheckForDisablingRandomization )
    {
        //
        //  If you are here, this means you are coming as a part of a user-initiated move.
        //  Check whether the randomization applies.
        //
        
        //
        //  First, check if are operating in a mixed version cluster. If so, don't randomize.
        //
        NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                        NULL, 
                                        NULL );

        if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                    NT51_MAJOR_VERSION ) 
        {
            return ( pSelectedNode );
        }

        //
        //  Next check if the user has turned off the randomization algorithm by setting
        //  HKLM\Cluster\DisableGroupPreferredOwnersRandomization DWORD to 1.
        //      
        dwStatus = DmQueryDword( DmClusterParametersKey,
                                 CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
                                 &dwDisabled,
                                 NULL );
       
        if ( ( dwStatus == ERROR_SUCCESS ) &&
             ( dwDisabled == 1 ) )
        {
            return ( pSelectedNode );
        }
    }
    
    //
    //  This function will attempt to pick a node at random from the group's preferred owners list
    //  in case the caller does not suggest a preferred node which is set by the user. So, first
    //  this function checks this case and bails out if the condition is met. Otherwise, it
    //  will generate a random number between 1 and NmMaxNodeId and see if (a) that node is in
    //  the group's preferred list, and (b) that node is UP. If so, it picks up the node. Note
    //  that the function will try 10 times to pick a node and then gives up. If no
    //  node is found, this function will return the suggested node which in some cases could be
    //  NULL.
    //
    ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Picking node for group %1!ws! [%2!ws!], suggested node %3!u!...\n",
                  OmObjectId(pGroup),
                  OmObjectName(pGroup),
                  (pSuggestedPreferredNode == NULL) ? 0:NmGetNodeId(pSuggestedPreferredNode));


    if ( ( pSuggestedPreferredNode != NULL ) &&
         ( FmpIsNodeUserPreferred ( pGroup, pSuggestedPreferredNode ) ) )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Node %2!u! for group %1!ws! is user preferred...\n",
                      OmObjectId(pGroup),
                      NmGetNodeId(pSuggestedPreferredNode));
        goto FnExit;
    }

    if ( pGroup->lpszAntiAffinityClassName != NULL )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Group %1!ws! has antiaffinity property set...\n",
                      OmObjectId(pGroup));
        goto FnExit;
    }

    //
    //  Retry 25 times so that we can have a good chance of getting a valid node. Note that we
    //  supply NmMaxNodeId to the srand() function and its value is equal to the node limit of 
    //  16. So, to get a valid node in a smaller size cluster, we have to have the retry count
    //  to be reasonable.
    //
    while ( dwRetry++ < 25 )
    {
        dwStatus = UuidFromString( ( LPWSTR ) OmObjectId(pGroup), &uuId );
        
        if ( dwStatus != RPC_S_OK ) 
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpPickNodeFromPreferredListAtRandom: Unable to get UUID from string %1!ws!, Status %2!u!...\n",
                          OmObjectId(pGroup),
                          dwStatus);
            goto FnExit;
        }

        usHashValue = UuidHash( &uuId, &dwStatus );

        if ( dwStatus != RPC_S_OK ) 
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpPickNodeFromPreferredListAtRandom: Unable to get hash value for UUID %1!ws!, Status %2!u!...\n",
                          OmObjectId(pGroup),
                          dwStatus);
            goto FnExit;
        }

        //
        //  Seed the random number generate with a value that is as random as it gets.
        //
        srand( GetTickCount() * usHashValue * ( dwRetry + 1 ) );

        //
        //  Find the node ID that is between ClusterMinNodeId and NmMaxNodeId. We use NmMaxNodeId 
        //  here since there is no simple way to get the count of configured nodes. Note that we
        //  have to ensure that the node ID falls within this range, otherwise assertion trips
        //  in NmReferenceNodeById.
        //       
        dwNodeId  = ( DWORD ) ( ( double ) rand() / ( double ) ( RAND_MAX ) * NmMaxNodeId ) + 1;

        if ( dwNodeId > NmMaxNodeId ) dwNodeId = NmMaxNodeId;
        if ( dwNodeId < ClusterMinNodeId ) dwNodeId = ClusterMinNodeId;

        //
        //  In case the caller asks you to rule out local node, do so.
        //
        if ( ( fRuleOutLocalNode ) && ( dwNodeId == NmLocalNodeId ) ) continue;

        //
        //  Reference and dereference the node objects. Note that we are only interested in
        //  getting a pointer to the node object and we use the fact that the node in the preferred 
        //  list must be referenced.
        //
        pNode = NmReferenceNodeById ( dwNodeId );

        if ( pNode == NULL ) continue;           
       
        if ( ( FmpInPreferredList( pGroup, pNode, FALSE, NULL ) ) && 
             ( NmGetExtendedNodeState( pNode ) == ClusterNodeUp ) )
        {
            pSelectedNode = pNode;
            break;
        }
        
        OmDereferenceObject ( pNode );
        pNode = NULL;
    }// while

FnExit:
    if ( pNode != NULL ) OmDereferenceObject ( pNode );

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Selected node %2!u! for group %1!ws!...\n",
                  OmObjectId(pGroup),
                  (pSelectedNode == NULL) ? 0:NmGetNodeId(pSelectedNode));   
    
    return ( pSelectedNode );
}// FmpPickNodeFromPreferredNodeAtRandom

BOOL
FmpIsNodeUserPreferred(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pPreferredNode
    )

/*++

Routine Description:

    Check whether the supplied node is set as a preferred node by the user.

Arguments:

    pGroup - Pointer to the group object we're interested in.

    pPreferredNode - Preferred node to check for.

Return Value:

    TRUE - The supplied preferred node is user set.

    FALSE otherwise

--*/
{
    DWORD               dwStatus;
    BOOL                fPreferredByUser = FALSE;        
    LPWSTR              lpmszPreferredNodeList = NULL;
    LPCWSTR             lpszPreferredNode;
    DWORD               cbPreferredNodeList = 0;
    DWORD               cbBuffer = 0;
    DWORD               dwIndex;
    PNM_NODE            pNode;

    //
    //  Look for any preferred owners set by the user
    //
    dwStatus = DmQueryMultiSz( pGroup->RegistryKey,
                               CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                               &lpmszPreferredNodeList,
                               &cbBuffer,
                               &cbPreferredNodeList );

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    //
    //  Parse the multisz and check whether the supplied node exists in the list
    //
    for ( dwIndex = 0; ; dwIndex++ ) 
    {
        lpszPreferredNode = ClRtlMultiSzEnum( lpmszPreferredNodeList,
                                              cbPreferredNodeList/sizeof(WCHAR),
                                              dwIndex );

        if ( lpszPreferredNode == NULL ) 
        {
            break;
        }

        pNode = OmReferenceObjectById( ObjectTypeNode,
                                       lpszPreferredNode );

        if ( pNode == NULL )
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpIsNodeUserPreferred: Unable to reference node %1!ws!, Status %2!u!...\n",
                          lpszPreferredNode,
                          dwStatus);      
            continue;
        }

        if ( pNode == pPreferredNode )
        {
            fPreferredByUser = TRUE;
            OmDereferenceObject ( pNode );
            break;
        }

        OmDereferenceObject ( pNode );
    } // for

FnExit:
    LocalFree ( lpmszPreferredNodeList );

    return ( fPreferredByUser );
}// FmpIsNodeUserPreferred

DWORD
FmpPrepareGroupNodeList(
    OUT PFM_GROUP_NODE_LIST *ppGroupNodeList
    )

/*++

Routine Description:

    Prepares a buffer containing the group ID and preferred owner node ID of all groups.

Arguments:

    ppGroupNodeList - Pointer to a buffer containing group IDs and preferred nodes.

Return Value:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    DWORD       cbBuffer = 512; // Let us try a 512 byte buffer to start with.
    DWORD       dwStatus;
    DWORD       dwDisabled = 0;

    //
    //  First check if the user has turned off the randomization algorithm by setting
    //  HKLM\Cluster\DisableGroupPreferredOwnersRandomization DWORD to 1.
    //      
    dwStatus = DmQueryDword( DmClusterParametersKey,
                             CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
                             &dwDisabled,
                             NULL );
   
    if ( ( dwStatus == ERROR_SUCCESS ) &&
         ( dwDisabled == 1 ) )
    {
        dwStatus = ERROR_CLUSTER_INVALID_REQUEST;
        return ( dwStatus );
    }
    
    //
    //  This function allocates contiguous memory for a list so that the entire buffer
    //  can be passed on to GUM.
    //
    *ppGroupNodeList = LocalAlloc( LPTR, cbBuffer );

    if ( *ppGroupNodeList == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpPrepareGroupNodeList: Memory alloc failed, Status %1!u!...\n",
                      dwStatus);      
        return ( dwStatus );
    }

    //
    //  Initialize the size of the list to the size of the header minus first element.
    //
    ( *ppGroupNodeList )->cbGroupNodeList = sizeof ( FM_GROUP_NODE_LIST ) - 
                                                sizeof ( FM_GROUP_NODE_LIST_ENTRY );
    
    //
    //  Enumerate all the groups, find a possibly random preferred owner for each group and
    //  return all the info in the buffer.
    //
    return OmEnumObjects ( ObjectTypeGroup,
                            FmpAddGroupNodeToList,
                            ppGroupNodeList,
                            &cbBuffer );
    
}// FmpPrepareGroupNodeList

DWORD
FmpAddGroupNodeToList(
    IN PFM_GROUP_NODE_LIST *ppGroupNodeList,
    IN LPDWORD pcbBuffer,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupId
    )

/*++

Routine Description:

    Find a random preferred owner for the given group and add the info to a buffer.

Arguments:

    ppGroupNodeList - Pointer to a buffer containing group IDs and preferred nodes.

    pcbBuffer - Size of the buffer.

    pGroup - Group whose preferred node is to be found.

    lpszGroupId - ID of the group.

Return Value:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    PNM_NODE                    pNode;
    PFM_GROUP_NODE_LIST_ENTRY   pGroupNodeListEntry;
    PFM_GROUP_NODE_LIST         pBuffer;
    PLIST_ENTRY                 pListEntry;
    DWORD                       dwStatus;

    //
    //  Get the group lock since you manipulate group lists here.
    //
    FmpAcquireLocalGroupLock ( pGroup );
    
    //
    //  Skip the quorum group since we cannot randomize its preferred owners list since MM has a
    //  choke hold on the placement of quorum group.
    //
    if ( pGroup == gpQuoResource->Group )  goto FnExit;

    //
    //  Try to pick a preferred node list for the group at random.
    //
    pNode = FmpPickNodeFromPreferredListAtRandom( pGroup, 
                                                  NULL,     // No suggested preferred owner
                                                  FALSE,    // Can choose local node
                                                  FALSE );  // Check whether randomization should be
                                                            // disabled

    //
    //  If no node could be picked, bail out
    //
    if ( pNode == NULL ) goto FnExit;        

    //
    //  Check whether the allocated buffer is big enough to hold the new entry. Note that the
    //  RHS of the equality need not contain the NULL char size since we allocate 1 WCHAR for it in
    //  the FM_GROUP_NODE_LIST_ENTRY structure.  Also, note that we have to see if the current
    //  buffer size is big enough to hold the padding for DWORD alignment.
    //
    if ( *pcbBuffer < ( ( *ppGroupNodeList )->cbGroupNodeList + 
                                ( sizeof ( FM_GROUP_NODE_LIST_ENTRY ) + 
                                  lstrlenW ( lpszGroupId ) * sizeof ( WCHAR ) +
                                  sizeof ( DWORD ) - 1 
                                ) & ~( sizeof ( DWORD ) - 1 ) 
                        ) )
    {
        //
        //  Reallocate a bigger buffer
        //
        pBuffer = LocalAlloc( LPTR, 2 * ( *pcbBuffer ) );

        if ( pBuffer == NULL )
        {       
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpAddGroupNodeToList: Memory alloc failed, Status %1!u!...\n",
                          dwStatus);      
            goto FnExit;            
        }

        ( *pcbBuffer ) *= 2;

        //
        //  Copy the contents of the old list to the new list. 
        //
        CopyMemory( pBuffer, *ppGroupNodeList, ( *ppGroupNodeList )->cbGroupNodeList );
                
        LocalFree ( *ppGroupNodeList );

        *ppGroupNodeList = pBuffer;    
    }

    //
    //  Find the pointer to the beginning of the new list entry
    //
    pGroupNodeListEntry = ( PFM_GROUP_NODE_LIST_ENTRY )
                                ( ( LPBYTE ) ( *ppGroupNodeList ) + 
                                  ( *ppGroupNodeList )->cbGroupNodeList );

    //
    //  Adjust the size of the list.  As above, size of NULL char is excluded. Align the length
    //  to a multiple of DWORD since we want the PFM_GROUP_NODE_LIST_ENTRY structure to be
    //  DWORD aligned since the structure starts with a DWORD.
    //
    ( *ppGroupNodeList )->cbGroupNodeList += ( sizeof ( FM_GROUP_NODE_LIST_ENTRY ) + 
                                                    lstrlenW ( lpszGroupId ) * sizeof ( WCHAR ) +
                                                    sizeof ( DWORD ) - 1 ) & ~( sizeof ( DWORD ) - 1 );
    //
    //  Set the contents of the list entry
    //
    pGroupNodeListEntry->dwPreferredNodeId = NmGetNodeId ( pNode );
    lstrcpy( pGroupNodeListEntry->szGroupId, lpszGroupId );

FnExit:
    FmpReleaseLocalGroupLock( pGroup );
    
    return ( TRUE );                
}// FmpPrepareGroupNodeList

PNM_NODE
FmpParseGroupNodeListForPreferredOwner(
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList,
    IN PNM_NODE pSuggestedPreferredNode
    )

/*++

Routine Description:

    Parse the supplied group node list looking for a preferred node for the supplied group.
    
Arguments:

    pGroup - The group whose preferred node must be found.

    pGroupNodeList - The list contains preferred nodes of the group.

    pSuggestedPreferredNode - Suggested preferred node fallback option.
    
Return Value:

    The preferred node for the group.
    
--*/
{
    PNM_NODE                    pSelectedNode = pSuggestedPreferredNode;
    PFM_GROUP_NODE_LIST_ENTRY   pGroupNodeListEntry;
    BOOL                        fFoundGroup = FALSE;
    PNM_NODE                    pNode = NULL;
    DWORD                       dwStatus;
    DWORD                       cbGroupNodeList;

    //
    //  If the suggested node is user preferred or if it has an anti-affinity class name
    //  property set, don't do anything else. Just return the suggested owner.
    //
    if ( ( FmpIsNodeUserPreferred ( pGroup, pSuggestedPreferredNode ) ) ||
         ( pGroup->lpszAntiAffinityClassName != NULL ) )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Node %2!u! for group %1!ws! is user preferred/antiaffinity property set...\n",
                      OmObjectId(pGroup),
                      NmGetNodeId(pSuggestedPreferredNode));
        goto FnExit;
    }

    cbGroupNodeList = sizeof ( FM_GROUP_NODE_LIST ) - 
                                sizeof ( FM_GROUP_NODE_LIST_ENTRY );
        
    //
    //  Walk the supplied list looking for the group entry.
    //
    while ( cbGroupNodeList < pGroupNodeList->cbGroupNodeList )
    {
        pGroupNodeListEntry = ( PFM_GROUP_NODE_LIST_ENTRY ) ( ( LPBYTE ) pGroupNodeList +
                                                                    cbGroupNodeList );
        
        if ( lstrcmp( pGroupNodeListEntry->szGroupId, OmObjectId( pGroup ) ) == 0 )  
        {
            fFoundGroup = TRUE;
            break;
        }
        cbGroupNodeList += ( sizeof ( FM_GROUP_NODE_LIST_ENTRY ) + 
                                    lstrlenW ( pGroupNodeListEntry->szGroupId ) * sizeof ( WCHAR ) +
                                            sizeof ( DWORD ) - 1 ) & ~( sizeof ( DWORD ) - 1 );
    } // while

    //
    //  Fallback to the suggested option if:
    //      (1) You did not find the group in the list
    //      (2) The preferred node for the group is invalid in the list
    //      (3) The preferred node for the group is down
    //
    if ( fFoundGroup == FALSE )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Did not find group %1!ws! in supplied list...\n",
                      OmObjectId(pGroup));
        goto FnExit;
    }

    if ( ( pGroupNodeListEntry->dwPreferredNodeId == 0 ) ||
         ( pGroupNodeListEntry->dwPreferredNodeId > NmMaxNodeId ) )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Invalid node %1!u! for group %1!ws! in supplied list...\n",
                      pGroupNodeListEntry->dwPreferredNodeId,
                      OmObjectId(pGroup));
        goto FnExit;
    }

    pNode = NmReferenceNodeById( pGroupNodeListEntry->dwPreferredNodeId );

    if ( pNode == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpParseGroupNodeListForPreferredOwner: Unable to reference node %1!u! for group %1!ws!, Status %3!u!...\n",
                      pGroupNodeListEntry->dwPreferredNodeId,
                      OmObjectId(pGroup),
                      dwStatus);
        goto FnExit;
    }

    if ( NmGetNodeState( pNode ) != ClusterNodeUp ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpParseGroupNodeListForPreferredOwner: Preferred node %1!u! for group %1!ws! is not UP...\n",
                      pGroupNodeListEntry->dwPreferredNodeId,
                      OmObjectId(pGroup));
        goto FnExit;
    }

    pSelectedNode = pNode;

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Selected node %1!u! for group %2!ws! from supplied randomized list...\n",
                  pGroupNodeListEntry->dwPreferredNodeId,
                  OmObjectId(pGroup));

FnExit:
    //
    //  Dereference the node object since we depend on the original reference added to the
    //  group's preferred owner when it was added to the group structure.
    //
    if ( pNode != NULL ) OmDereferenceObject( pNode );

    return ( pSelectedNode );
}// FmpParseGroupNodeListForPreferredOwner
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\ioctl.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Resource and Resource Type control functions.

Author:

    John Vert (jvert) 10/16/1996

Revision History:

--*/
#include "fmp.h"

#define LOG_MODULE IOCTL


DWORD
WINAPI
FmResourceControl(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    Resource - Supplies the resource to be controlled.

    Node - Supplies the node on which the resource control should
           be delivered. If this is NULL, then if the owner is up, it
           is used.  Else one of the other possible nodes is used.
           Else, one of the nodes that can support a resource of this type is used.
           

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD           status;
    PNM_NODE        node;
    PLIST_ENTRY     pListEntry;

    //SS: dont require FM to be online, since these calls
    //can be made by the Open() call in resource dlls which
    //is called before the resource is online.
    //FmpMustBeOnline( );

    //
    // TODO - we should verify the access mode - in the future!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_RESOURCE ) {
        return(ERROR_INVALID_FUNCTION);
    }

    //
    // Check if this is an internal, private control code.
    //
    if ( ControlCode & CLCTL_INTERNAL_MASK ) {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    // If a Node was specified, then ship the request off to that node.
    //
    if ( Node != NULL ) {
        if ( Node == NmLocalNode ) {
            status = FmpRmResourceControl( Resource,
                                           ControlCode,
                                           InBuffer,
                                           InBufferSize,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required
                                           );
        } else {
            status = FmcResourceControl( Node,
                                         Resource,
                                         ControlCode,
                                         InBuffer,
                                         InBufferSize,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required
                                         );
        }
    } else {

        PLIST_ENTRY             pListEntry;
        PPOSSIBLE_ENTRY         pPossibleEntry;

        pListEntry = &Resource->PossibleOwners;
        node = Node;

        //
        // If there is no supplied node, then use a possible node that is up.
        //

        for (pListEntry = pListEntry->Flink; pListEntry != &Resource->PossibleOwners;
            pListEntry = pListEntry->Flink)
        {
            pPossibleEntry = CONTAINING_RECORD(pListEntry, POSSIBLE_ENTRY, 
                    PossibleLinkage);

            // if Node is not given, then attempt to use a node that is
            // UP - giving preference to the group owner node node.
            node = pPossibleEntry->PossibleNode;
            if ( node == Resource->Group->OwnerNode ) {
                break;
            } 
            if ( NmGetNodeState(node) != ClusterNodeUp ) {
                node = NULL;
                // try again
            }
        }

        //if no such node was found, find a node that can host this resource type
        if (!node)
        {
            PFM_RESTYPE             pResType;
            PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;
            PNM_NODE                prev_node = NULL;

            pResType = Resource->Type;
            // protect with the ResType lock

            ACQUIRE_SHARED_LOCK(gResTypeLock);
            
            pListEntry = &pResType->PossibleNodeList;

            //
            // If there is no supplied node, then use a possible node that is up.
            //

            for (pListEntry = pListEntry->Flink; pListEntry != &pResType->PossibleNodeList;
                pListEntry = pListEntry->Flink)
            {
                pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                        PossibleLinkage);

                // if Node is not given, then attempt to use a node that is
                // UP - giving preference to the local node.
                node = pResTypePosEntry->PossibleNode;
                if ( node == NmLocalNode ) {
                    break;
                } 
                if ( NmGetNodeState(node) != ClusterNodeUp ) {
                    node = NULL;
                    // try again
                }
                else
                    if (prev_node == NULL)
                        prev_node = node;
            }

            RELEASE_LOCK(gResTypeLock);

            if(!node && prev_node)
                node=prev_node;        

        }

        //if we still dont have a node, we have to throw up a failure
        if ( !node ) {
            // either the restype is not supported - or the supporting node is
            // not up!
            status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            return(status);
        }

        //
        // If we are the owner, then do the work, otherwise...
        // Ship the request off to the owner node.
        //
        if ( node == NmLocalNode ) {
            status = FmpRmResourceControl( Resource,
                                           ControlCode,
                                           InBuffer,
                                           InBufferSize,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required
                                           );
        } else {
            status = FmcResourceControl( node,
                                         Resource,
                                         ControlCode,
                                         InBuffer,
                                         InBufferSize,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required
                                         );
        }
    }

    return(status);

} // FmResourceControl


DWORD
WINAPI
FmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    ResourceTypeName - Supplies the name of the resource type to be
        controlled.

    Node - Supplies the node on which the resource control should be
        delivered. If this is NULL, the local node is used.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    DWORD   retry = TRUE;
    PNM_NODE node = NULL;
    PNM_NODE prev_node=NULL;
    PFM_RESTYPE pResType = NULL;

    FmpMustBeOnline( );

    //
    // TODO - we should verify the access mode - in the future!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_RESOURCE_TYPE ) {
        status = ERROR_INVALID_FUNCTION;
        goto FnExit;
    }

    //
    // Check if this is an internal, private control code.
    //
    if ( ControlCode & CLCTL_INTERNAL_MASK ) {
        status = ERROR_PRIVILEGE_NOT_HELD;
        goto FnExit;
    }


    //find a node that can handle this resource type control
    pResType = OmReferenceObjectById(ObjectTypeResType,
                ResourceTypeName);
    if (!pResType)
    {
        status = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        goto FnExit;
    }

retry_search:
    prev_node = NULL;
    //if node wasnt specified choose a node
    if ( !Node ) 
    {
        PLIST_ENTRY             pListEntry;
        PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;
        
        // protect with the ResType lock

        ACQUIRE_SHARED_LOCK(gResTypeLock);
        
        pListEntry = &pResType->PossibleNodeList;

        //
        // If there is no supplied node, then use a possible node that is up.
        //

        for (pListEntry = pListEntry->Flink; pListEntry != &pResType->PossibleNodeList;
            pListEntry = pListEntry->Flink)
        {
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                    PossibleLinkage);

            // if Node is not given, then attempt to use a node that is
            // UP - giving preference to the local node.
            node = pResTypePosEntry->PossibleNode;
            if ( node == NmLocalNode ) {
                break;
            } 
            if ( NmGetNodeState(node) != ClusterNodeUp ) {
                node = NULL;
                // try again
            }
            else
                if (prev_node == NULL)
                    prev_node = node;
        }

        RELEASE_LOCK(gResTypeLock);

        
        if(!node && prev_node)
            node=prev_node;        

        // node should now contain a valid node to use or NULL!
        // if NULL, then let's see if the required ResDLL has been updated
        // on some other nodes.        
        if ( !node &&
             retry ) {
            retry = FALSE;
            ClRtlLogPrint(LOG_NOISE,
                          "[FM] FmResourceTypeControl: No possible nodes for restype %1!ws!, "
                          "calling FmpSetPossibleNodeForRestype\r\n",
                          ResourceTypeName);
            FmpSetPossibleNodeForResType( ResourceTypeName, TRUE );
            // ignore status
            goto retry_search;
        }

        // node should now contain a valid node to use or NULL!
        // if NULL, then it is hopeless!
        if ( !node ) {
            // either the restype is not supported - or the supporting node is
            // not up!
            status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }

    }
    else
    {
        // If the supplied node is on the list of possible nodes, then use it.
        // else return error
        if (!FmpInPossibleListForResType(pResType, Node))
        {
            // either the restype is not supported - or the supporting node is
            // not up!
            status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }
        node = Node;
    }

    
    CL_ASSERT(node != NULL);

    if ( (node != NmLocalNode) &&
         (NmGetNodeState(node) != ClusterNodeUp) ) {
        status = ERROR_HOST_NODE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // If the node is remote, then ship the request off to that node, else
    // do the work locally.
    //
    if ( node == NmLocalNode ) 
    {
        status = FmpRmResourceTypeControl( ResourceTypeName,
                                           ControlCode,
                                           InBuffer,
                                           InBufferSize,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required
                                           );
        //if no node was specified and the local node doesnt support the resource
        //dll, remove it from the list and then retry
        if ((Node == NULL) && 
                ((status == ERROR_MOD_NOT_FOUND) || (status == ERROR_PROC_NOT_FOUND)))
        {
            ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmResourceTypeControl: Removing Local Node from Possible Owners List for %1!ws! restype because of error %2!u! \r\n",
                        ResourceTypeName,status);                                       
            FmpRemovePossibleNodeForResType(ResourceTypeName, NmLocalNode);
            node = NULL;
            retry = FALSE;
            goto retry_search;

        }
    } 
    else 
    {
        status = FmcResourceTypeControl( node,
                                         ResourceTypeName,
                                         ControlCode,
                                         InBuffer,
                                         InBufferSize,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required
                                         );
        if ((Node == NULL) && 
                ((status == ERROR_MOD_NOT_FOUND) || (status == ERROR_PROC_NOT_FOUND)))
        {
            node = NULL;
            retry = FALSE;
            goto retry_search;
        }

    }


FnExit:
    if (pResType)
        OmDereferenceObject(pResType);
    return(status);

} // FmResourceTypeControl


DWORD
WINAPI
FmGroupControl(
    IN PFM_GROUP Group,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    Group - Supplies the group to be controlled.

    Node - Supplies the node on which the resource control should
           be delivered. If this is NULL, the node where the group
           is owned is used.

    ControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    FmpMustBeOnline( );

    //
    // TODO - we should verify the access mode - in the future!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_GROUP ) {
        return(ERROR_INVALID_FUNCTION);
    }

    //
    // Check if this is an internal, private control code.
    //
    if ( ControlCode & CLCTL_INTERNAL_MASK ) {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    // If a Node was specified, then ship the request off to that node, else
    //
    // If we are the owner, then do the work, otherwise...
    // Ship the request off to the owner node.
    //
    if ( (Node != NULL) && (Node != NmLocalNode) ) 
    {
        status = FmcGroupControl( Node,
                                  Group,
                                  ControlCode,
                                  InBuffer,
                                  InBufferSize,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required
                                  );
    } 
    else 
    {

        CL_ASSERT( Group != NULL );
        if ( (Node == NULL) &&
             (Group->OwnerNode != NmLocalNode) ) 
        {
            status = FmcGroupControl( Group->OwnerNode,
                                      Group,
                                      ControlCode,
                                      InBuffer,
                                      InBufferSize,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      Required
                                      );
        } 
        else 
        {
            status = FmpGroupControl( Group, ControlCode, InBuffer,
                         InBufferSize, OutBuffer, OutBufferSize, BytesReturned, Required);
        }
    }

    return(status);

} // FmGroupControl

DWORD
FmpGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
{
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;
    DWORD   status;

    //
    // Handle any requests that must be done without locks helds.
    //

    switch ( ControlCode ) {

        case CLUSCTL_GROUP_GET_COMMON_PROPERTY_FMTS:
            status = ClRtlGetPropertyFormats( FmpGroupCommonProperties,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
            break;


        case CLUSCTL_GROUP_GET_NAME:
            if ( OmObjectName( Group ) == NULL ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Group ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Group ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_GROUP_GET_ID:
            if ( OmObjectId( Group ) == NULL ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Group ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Group ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        default:
            break;

    }

    FmpAcquireLocalGroupLock( Group );
    
    status = FmpHandleGroupControl( Group,
                                    ControlCode,
                                    InBuffer,
                                    InBufferSize,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    Required
                                    );
    FmpReleaseLocalGroupLock( Group );
    if ( ((status == ERROR_SUCCESS) ||
          (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {

        ClusterWideEvent(
            CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,
            Group
            );
    }

    return(status);

}



DWORD
WINAPI
FmpHandleGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    Group - Supplies the group to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    switch ( ControlCode ) {

    case CLUSCTL_GROUP_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_GROUP_GET_FLAGS:
        status = FmpGroupGetFlags( Group,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required );
        break;

    case CLUSCTL_GROUP_ENUM_COMMON_PROPERTIES:
        status = FmpGroupEnumCommonProperties( OutBuffer,
                                               OutBufferSize,
                                               BytesReturned,
                                               Required );
        break;

    case CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES:
        status = FmpGroupGetCommonProperties( Group,
                                              TRUE,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_GROUP_GET_COMMON_PROPERTIES:
        status = FmpGroupGetCommonProperties( Group,
                                              FALSE,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES:
        status = FmpGroupValidateCommonProperties( Group,
                                                   InBuffer,
                                                   InBufferSize );
        break;

    case CLUSCTL_GROUP_SET_COMMON_PROPERTIES:
        status = FmpGroupSetCommonProperties( Group,
                                              InBuffer,
                                              InBufferSize );
        break;

    case CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_GROUP_ENUM_PRIVATE_PROPERTIES:
        status = FmpGroupEnumPrivateProperties( Group,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                Required );
        break;

    case CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES:
        status = FmpGroupGetPrivateProperties( Group,
                                               OutBuffer,
                                               OutBufferSize,
                                               BytesReturned,
                                               Required );
        break;

    case CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES:
        status = FmpGroupValidatePrivateProperties( Group,
                                                    InBuffer,
                                                    InBufferSize );
        break;

    case CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES:
        status = FmpGroupSetPrivateProperties( Group,
                                               InBuffer,
                                               InBufferSize );
        break;

    case CLUSCTL_GROUP_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    return(status);

} // FmpHandleGroupControl


/****
@func       DWORD | FmNetNameParseProperties| Updates the cluster name in
            the cluster database.

@parm       PUCHAR | InBuffer | A pointer to special property list.

@parm       DWORD | InBufferSize | The size of the InBuffer in bytes.

@parm       LPCWSTR | * ppszClusterName | A cluster name string is returned via this.

@comm       The string must be freed by the caller using LocalFree().

@rdesc      returns ERROR_SUCCESS if successful in getting the cluster name
            from the private properties.

@xref
****/
DWORD
FmNetNameParseProperties(
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT LPWSTR *ppszClusterName)
{
    //
    // Find the Cluster Name property
    //
    *ppszClusterName = NULL;

    return (ClRtlpFindSzProperty(
            InBuffer,
            InBufferSize,
            CLUSREG_NAME_NET_NAME,
            ppszClusterName,
            TRUE
            ));

} // FmNetNameParseProperties


/****
@func       DWORD | FmGetDiskInfoParseProperties| Updates the cluster name in
            the cluster database.

@parm       PUCHAR | InBuffer | A pointer to special property list.

@parm       DWORD | InBufferSize | The size of the InBuffer in bytes.

@parm       LPWSTR | pszPath | If this a null string, the first drive letter
            on the disk resource is returned, else you can validate
            a path of form "g:" on this storage class resource.

@comm       The string must be freed by the caller using LocalFree().

@rdesc      returns ERROR_SUCCESS if successful in getting the cluster name
            from the private properties.

@xref
****/
DWORD FmpGetDiskInfoParseProperties(
    IN PUCHAR   InBuffer,
    IN DWORD    InBufferSize,
    IN OUT LPWSTR  pszPath)
{
    DWORD                       status = ERROR_INVALID_PARAMETER;
    DWORD                       dwValueSize;
    CLUSPROP_BUFFER_HELPER      props;
    PCLUSPROP_PARTITION_INFO    pPartitionInfo;
    WCHAR                       szRootPath[MAX_PATH];

    props.pb = InBuffer;

    szRootPath[0] = L'\0';

    //
    // Set defaults in the parameter block.
    //

    // Loop through each property.
    while ( (InBufferSize > sizeof(CLUSPROP_SYNTAX)) &&
            (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) )
    {
        // Get the size of this value and verify there is enough buffer left.
        dwValueSize = sizeof(*props.pValue) + ALIGN_CLUSPROP( props.pValue->cbLength );
        if ( dwValueSize > InBufferSize )
        {
            break;
        }

        if ( props.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
        {
            // Validate the data.  There must be a device name.
            pPartitionInfo = props.pPartitionInfoValue;
            if ( (dwValueSize != sizeof(*pPartitionInfo)) ||
                 (pPartitionInfo->szDeviceName[0] == L'\0'))
            {
                break;
            }

            if (!(pPartitionInfo->dwFlags & CLUSPROP_PIFLAG_USABLE))
            {
                //check that it is formatted with NTFS.
                //if it is not usable,skip to the next one
                goto SkipToNext;
            }
            
            if (pszPath[0] == L'\0')
            {
                //
                //  Chittur Subbaraman (chitturs) - 12/12/2000
                //
                //  Save the first available NTFS partition if the user does not explicitly
                //  indicate any partition in the SetClusterQuorumResource API. This path will be 
                //  returned in two cases. 
                //
                //  (1) This cluster is a Whistler-Win2K cluster and the quorum disk
                //  is currently owned by the Win2K node. The Win2K disk resource does not
                //  set the CLUSPROP_PIFLAG_DEFAULT_QUORUM flags and so we have to revert the
                //  behavior of the SetClusterQuorumResource API to the old behavior. 
                //
                //  (2) A pre-Whistler third party implemented quorum resource is used in a 
                //  Whistler cluster. In this case, this resource may not support the
                //  CLUSPROP_PIFLAG_DEFAULT_QUORUM flags and so we have to revert the
                //  behavior of the SetClusterQuorumResource API to the old behavior.
                //  
                if ( szRootPath[0] == L'\0' )
                {
                    lstrcpyW( szRootPath, pPartitionInfo->szDeviceName );
                }

                //
                //  See whether you can find a default quorum partition (one that is
                //  larger than 50 MB and still the minimum among the usable partitions.)
                //
                if ( !( pPartitionInfo->dwFlags & CLUSPROP_PIFLAG_DEFAULT_QUORUM ) )
                {
                    goto SkipToNext;
                }

                // Construct a path from the device name.
                lstrcpyW( pszPath, pPartitionInfo->szDeviceName );
                status = ERROR_SUCCESS;
                break;
            }
            else
            {
                // Construct a path from the device name.
                if (!lstrcmpiW( pszPath, pPartitionInfo->szDeviceName ))
                {
                    status = ERROR_SUCCESS;
                    break;
                }
            }
        }

SkipToNext:
        InBufferSize -= dwValueSize;
        props.pb += dwValueSize;
    }

    //
    //  No path was found. However, a usable path got saved. So, use this saved path.
    //
    if ( ( status != ERROR_SUCCESS ) && ( szRootPath[0] != L'\0' ) )
    {
        lstrcpyW( pszPath, szRootPath );
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpGetDiskInfoParseProperties: Using saved path %1!ws!...\n",
                      pszPath);
        status = ERROR_SUCCESS;    
    }
    
    return(status);

} // FmpGetDiskInfoParseProperties


DWORD
FmpBroadcastDeleteControl(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Broadcasts a resource control to each node that notifies it that
    the resource is being deleted.

Arguments:

    Resource - Supplies the resource that is being deleted.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   characteristics;
    DWORD   i;
    PNM_NODE Node;

    //
    // Only perform the broadcast if delete notification is required.
    // Otherwise, just perform the notification on the local node.
    //
    status = FmpRmResourceControl( Resource,
                                   CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                   NULL,
                                   0,
                                   (PUCHAR)&characteristics,
                                   sizeof(DWORD),
                                   NULL,
                                   NULL );
    if ( (status != ERROR_SUCCESS) ||
         !(characteristics & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES) ) {
        //
        // Note: the following 'local node only' notification is fairly useless.
        //
        FmpRmResourceControl( Resource,
                              CLUSCTL_RESOURCE_DELETE,
                              NULL,
                              0,
                              NULL,
                              0,
                              NULL,
                              NULL );
        return(ERROR_SUCCESS);
    }

    //
    // All nodes must be up in the cluster in order to perform this operation.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        Node = NmReferenceNodeById(i);
        if ( Node != NULL ) {
            if ( NmGetNodeState(Node) != ClusterNodeUp ) {
                return(ERROR_ALL_NODES_NOT_AVAILABLE);
            }
        }
    }

    //
    // Passed all checks, now broadcast to all nodes in the cluster.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        //
        // If this is the local node, do the ioctl directly
        //
        if (i == NmLocalNodeId) {
            FmpRmResourceControl( Resource,
                                  CLUSCTL_RESOURCE_DELETE,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL );

        } else {
            Node = NmReferenceNodeById(i);
            if ((Node != NULL) &&
                (NmGetNodeState(Node) == ClusterNodeUp)) {
                CL_ASSERT(Session[i] != NULL);

                FmcResourceControl( Node,
                                    Resource,
                                    CLUSCTL_RESOURCE_DELETE,
                                    NULL,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
                OmDereferenceObject(Node);
            }
        }
    }

    return(ERROR_SUCCESS);

} // FmpBroadcastDeleteControl

DWORD
FmpBroadcastDependencyChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR DependsOnId,
    IN BOOL Remove
    )
/*++

Routine Description:

    Broadcasts a resource control to each node that notifies it that
    the resource has had a dependency added or removed.

Arguments:

    Resource - Supplies the resource that has had the dependency added
               or removed

    DependsOnId - Supplies the id of the provider resource

    Remove - TRUE indicates that the dependency is being removed
             FALSE indicates that the dependency is being added.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   i;
    PNM_NODE Node;
    DWORD Control;
    DWORD Length;
    PFM_RESOURCE providerResource;

    if (Remove) {
        Control = CLUSCTL_RESOURCE_REMOVE_DEPENDENCY;
    } else {
        Control = CLUSCTL_RESOURCE_ADD_DEPENDENCY;
    }

    //
    // Get the provider resource.
    //
    providerResource = OmReferenceObjectById( ObjectTypeResource,
                                              DependsOnId );
    if ( providerResource == NULL )  {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    Length = (lstrlenW(OmObjectName(providerResource)) + 1) * sizeof(WCHAR);

    //
    // Broadcast to all nodes in the cluster.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        //
        // If this is the local node, do the ioctl directly
        //
        if (i == NmLocalNodeId) {
            FmpRmResourceControl( Resource,
                                  Control,
                                  (PUCHAR)OmObjectName(providerResource),
                                  Length,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL );

        } else {
            Node = NmReferenceNodeById(i);
            if ((Node != NULL) &&
                (NmGetNodeState(Node) == ClusterNodeUp)) {
                CL_ASSERT(Session[i] != NULL);

                FmcResourceControl( Node,
                                    Resource,
                                    Control,
                                    (PUCHAR)OmObjectName(providerResource),
                                    Length,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
                OmDereferenceObject(Node);
            }
        }
    }

    OmDereferenceObject( providerResource );

    return(ERROR_SUCCESS);

} // FmpBroadcastDeleteControl


/****
@func       DWORD | FmpGetResourceCharacteristics| Gets the characteristics
            for a given resource.

@parm       IN PFM_RESOURCE | pResource | Points to a FM_RESOURCE.
            
@parm       OUT LPDWORD | pdwCharacteristics | The ID of the dead node.

@comm       This is used to get the quorum characteristics during join since
            local quorums cant support multi-node clusters.

@rdesc      Returns ERROR_SUCCESS.
****/
DWORD FmpGetResourceCharacteristics(
    IN PFM_RESOURCE pResource,
    OUT LPDWORD pdwCharacteristics)
{

    DWORD   dwStatus;

    dwStatus = FmpRmResourceControl( pResource,
                                   CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                   NULL,
                                   0,
                                   (PUCHAR)pdwCharacteristics,
                                   sizeof(DWORD),
                                   NULL,
                                   NULL );

    SetLastError(dwStatus);
    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\grouparb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    grouparb.c

Abstract:

    Cluster group arbitration and sorting routines.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE GROUPARB

//
// Global data
//

//
// Local function prototypes
//

typedef struct FM_GROUP_ENUM_DATA {
    DWORD Allocated;
    PNM_NODE OwnerNode;
    BOOL  QuorumGroup;
} FM_GROUP_ENUM_DATA, *PFM_GROUP_ENUM_DATA;


BOOL
FmpEnumGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN PFM_GROUP_ENUM_DATA EnumData,
    IN PFM_GROUP        Group,
    IN LPCWSTR          Name
    );

BOOL
FmpEqualGroupLists(
    IN PGROUP_ENUM Group1,
    IN PGROUP_ENUM Group2
    );

int
_cdecl
SortCompare(
    IN const void * Elem1,
    IN const void * Elem2
    );


DWORD
FmpEnumSortGroups(
    OUT PGROUP_ENUM *ReturnEnum,
    IN OPTIONAL PNM_NODE OwnerNode,
    OUT PBOOL  QuorumGroup
    )

/*++

Routine Description:

    Enumerates and sorts the list of Groups.

Arguments:

    ReturnEnum - Returns the requested objects.

    OwnerNode - If present, supplies the owner node to filter
                the list of groups. (i.e. if you supply this, you
                get a list of groups owned by that node)

                If not present, all groups are returned.

    QuorumGroup - Returns TRUE if the quorum resource in one of the groups
                returned in the ENUM.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

--*/

{
    DWORD status;
    PGROUP_ENUM groupEnum = NULL;
    FM_GROUP_ENUM_DATA EnumData;

    EnumData.Allocated = ENUM_GROW_SIZE;
    EnumData.OwnerNode = OwnerNode;
    EnumData.QuorumGroup = FALSE;

    groupEnum = LocalAlloc(LMEM_FIXED, GROUP_SIZE(ENUM_GROW_SIZE));
    if ( groupEnum == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    groupEnum->EntryCount = 0;

    //
    // Enumerate all groups, sort with Quorum Group first in the list.
    //

    OmEnumObjects(ObjectTypeGroup,
                FmpEnumGroups,
                &groupEnum,
                &EnumData);


    *ReturnEnum = groupEnum;
    *QuorumGroup = EnumData.QuorumGroup;
    return(ERROR_SUCCESS);

error_exit:

    if ( groupEnum != NULL ) {
        LocalFree( groupEnum );
    }

    *ReturnEnum = NULL;
    *QuorumGroup = FALSE;
    return(status);

} // FmpEnumSortGroups



DWORD
FmpGetGroupListState(
    PGROUP_ENUM GroupEnum
    )

/*++

Routine Description:

    This routine gets the Group state for each of the Groups in the list.

Arguments:

    GroupEnum - The list of Groups we now own.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_GROUP group;
    DWORD i;

    for ( i = 0; i < GroupEnum->EntryCount; i++ ) {
        group = OmReferenceObjectById( ObjectTypeGroup,
                                       GroupEnum->Entry[i].Id );
        if ( group == NULL ) {
            return(ERROR_GROUP_NOT_FOUND);
        }

        ClRtlLogPrint( LOG_NOISE,
            "[FM] GetGroupListState, Group <%1!ws!> state = %2!d!\n",
            OmObjectName(group), group->State );
        if ( (group->State == ClusterGroupFailed) ||
             (group->State == ClusterGroupPartialOnline) ) {
            GroupEnum->Entry[i].State = ClusterGroupOnline;
        } else {
            GroupEnum->Entry[i].State = group->State;
        }

        OmDereferenceObject( group );
    }

    return(ERROR_SUCCESS);

} // FmpGetGroupListState



DWORD
FmpOnlineGroupList(
    IN PGROUP_ENUM GroupEnum,
    IN BOOL bPrepareQuoForOnline
    )

/*++

Routine Description:

    Brings online all Groups in the Enum list. If the quorum group
    is present in the list, then it must be first.

Arguments:

    GroupEnum - The list of Groups to bring online.

    bPrepareQuoForOnline - Indicates whether the quorum resource should be 
    forced prepared for onlining
Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_GROUP group;
    DWORD   status = ERROR_SUCCESS;
    int     i;
    int     iQuoGroup=-1;

    //
    // see if the quorum group is present in the list.
    //
    for ( i = 0; (DWORD)i < GroupEnum->EntryCount; i++ ) 
    {

        if (NmGetNodeId(NmLocalNode) !=
	    NmGetNodeId(gpQuoResource->Group->OwnerNode)) {
	    continue;
	}
        if (!lstrcmpW(OmObjectId(gpQuoResource->Group), 
                            GroupEnum->Entry[i].Id))
        {
            iQuoGroup = i;
            break;
        }
    }

    //if quorum group was found, bring it online first. It would normally
    //be first in the list.
    //the quorum group online must return success, or invalid state
    //because of the online pending quorum resource.
    //if the quorum resource needs to be brought online, it must
    //be brought into online or online pending state.  This is
    // not required in fix quorum mode.

    if (iQuoGroup != -1)
    {
        ClRtlLogPrint(LOG_NOISE,
             "[FM] FmpOnlineGroupList: bring quorum group online\n");
        status = FmpOnlineGroupFromList(GroupEnum, iQuoGroup, bPrepareQuoForOnline);
        if ( status != ERROR_SUCCESS && status != ERROR_IO_PENDING) 
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineGroupFromList: quorum online returned %1!u!.\n",
                       status );
            CL_LOGFAILURE(status);
        }

    }

    // bring the non-quorum groups online
    for ( i = 0; (DWORD)i < GroupEnum->EntryCount; i++ ) 
    {
        //quorum resource should be online now
        if (i != iQuoGroup)
            FmpOnlineGroupFromList(GroupEnum, i, bPrepareQuoForOnline);
    }


    return(status);

} // FmpOnlineGroupList
    

DWORD FmpOnlineGroupFromList(
    IN PGROUP_ENUM GroupEnum,
    IN DWORD       Index,
    IN BOOL        bPrepareQuoForOnline
)
{

    PFM_GROUP group;
    DWORD     status=ERROR_SUCCESS; //assume success
    PLIST_ENTRY listEntry;
    PFM_RESOURCE resource;
    
    group = OmReferenceObjectById( ObjectTypeGroup,
                                   GroupEnum->Entry[Index].Id );

    //
    // If we fail to find a group, then just continue.
    //
    if ( group == NULL ) {
        status = ERROR_GROUP_NOT_FOUND;
        return(status);
    }

    FmpAcquireLocalGroupLock( group );
    
    if (group->OwnerNode != NmLocalNode) {
        FmpReleaseLocalGroupLock( group );
        OmDereferenceObject(group);
        return (ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }
  
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineGroupFromList: Previous group state for %1!ws! is %2!u!\r\n",
               OmObjectId(group), GroupEnum->Entry[Index].State);

    //
    // First make sure the group has completed initialization.
    //
    FmpCompleteInitGroup( group );

    //
    // First check if the Group failed to initialize. If so,
    // then attempt a failover immediately.
    //
    if ( GroupEnum->Entry[Index].State == ClusterGroupPartialOnline ) {
        GroupEnum->Entry[Index].State = ClusterGroupOnline;
    }

    if (!bPrepareQuoForOnline)
    {
        //
        // Normalize the state of each resource within the group.
        // except the quorum resource - this is because at initialization
        // we dont want to touch the quorum resource
        //
        for ( listEntry = group->Contains.Flink;
              listEntry != &(group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);

            if ( !resource->QuorumResource ) {
                // don't touch the quorum resource

                switch ( resource->State ) {
                // all active resources should be brought online.
                case ClusterResourceOnlinePending:
                case ClusterResourceOfflinePending:
                case ClusterResourceOnline:
                    resource->State = ClusterResourceOffline;
                    break;

                default:
                    // otherwise do nothing
                    break;
                }
            }
        }
    }
    FmpSignalGroupWaiters( group );

    if ( group->InitFailed ) {
        //
        // Bring the Group online... and then fail it!
        //
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpOnlineGroupFromList: group->InitFailed is true for %1!ws!\n",
                OmObjectId(group));

        status = FmpOnlineGroup( group, FALSE );
        ClusterEvent( CLUSTER_EVENT_GROUP_FAILED, group );
    } else if ((group->PersistentState == ClusterGroupOnline) ||
         (GroupEnum->Entry[Index].State == ClusterGroupOnline) ||
         FmpIsAnyResourcePersistentStateOnline( group ) ) {
        //
        // Chittur Subbaraman (chitturs) - 01/07/2001
        //
        // Now bring the Group online if that is it's current state or if any one of the 
        // resources in the group has an online persistent state.  The third check is
        // required since it is possible for a group to have a persistent state of ClusterGroupOffline,
        // a state of ClusterGroupOffline and yet one or more resources in the group has a persistent 
        // state of ClusterResourceOnline. This happens for a group in which the client never ever 
        // calls OnlineGroup but calls OnlineResource for one or more resources in the group and you
        // reached this call either at the cluster service startup time or as a part of node down
        // processing when the source node died just after the group became ClusterGroupOffline
        // and before the destination node brought the appropriate resources within the group online.
        // In such a case, we still want to bring each resource that has a persistent state of 
        // ClusterResourceOnline to online state. Note that it is tricky to muck with the group 
        // persistent state in an OnlineResource call due to atomicity issues (we really need a 
        // transaction to update both group and resource persistent states in one shot) and also 
        // due to the fuzzy definition of group persistent state when the group has some resources 
        // online and some offline.
        //
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpOnlineGroupFromList: trying to bring group %1!ws! online\n",
                      OmObjectId(group));

        status = FmpOnlineGroup( group, FALSE );
        if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
        {
            PRESOURCE_ENUM pResourceEnum;
            // This fn is either called at startup or during
            // a node down event on claiming a group  - so we must 
            // try our darn best to bring resources
            // online after a quorum resource failure
            // With quorum resource failure the failure policy is
            // not invoked for resources so something must try to bring
            // these resources online.  This is why we are adding this
            // here 
            //
            // Get the list of resources in the group and their states.
            //
            status = FmpGetResourceList( &pResourceEnum, group );
            if ( status == ERROR_SUCCESS ) 
            {

                //submit a timer callback to try and bring these resources
                //online
                //the worker thread will clean up the resource list
                FmpSubmitRetryOnline(pResourceEnum);
            }                
        }                         
    }

    FmpReleaseLocalGroupLock( group );

    OmDereferenceObject( group );

    return(status);

} // FmpOnlineGroupFromList

DWORD
FmpOnlineResourceFromList(
    IN PRESOURCE_ENUM  ResourceEnum
    )

/*++

Routine Description:

    Brings online all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to bring online.

Comments : This function is called from the worker thread.  We
    dont assume that the resource hasnt changed groups since the
    work item was posted.  The local resource lock is acquired and
    released for each resource.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD returnStatus = ERROR_SUCCESS;
    DWORD i;

    if ( !FmpFMOnline ||
         FmpShutdown ) {
        return(ERROR_INVALID_STATE);
    }

    // if the quorum resource is contained in here, bring it online first
    if (ResourceEnum->ContainsQuorum >= 0)
    {
        CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);
        
        resource = OmReferenceObjectById( ObjectTypeResource,
                        ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );


        // the resource should not vanish, we are holding the group lock after all
        CL_ASSERT(resource != NULL);

        //
        // If we fail to find a resource, then just continue
        //
        if ( resource != NULL ) {

            //acquire the local resource lock
            FmpAcquireLocalResourceLock(resource);

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceFromList: Previous quorum resource state for %1!ws! is %2!u!\r\n",
                       OmObjectId(resource), ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State);

            if ( (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceOnline) ||
                 (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceFailed) ) {
                //
                // Now bring the resource online if that is it's current state.
                //
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOnlineResourceFromList: trying to bring quorum resource %1!ws! online, state %2!u!\n",
                           OmObjectId(resource),
                           resource->State);

                status = FmpOnlineResource( resource, FALSE );
                if ( status != ERROR_SUCCESS ) {
                    returnStatus = status;
                }
            }
            OmDereferenceObject( resource );
            
            FmpReleaseLocalResourceLock(resource);
            
        }

    }

    // SS::: TODO what happens to the persistent state of the
    // other resources - is it handled correctly - note that this is 
    // called on moving a group
    // Will the restart policy do the right thing in terms of bringing
    // them online
    // if the quorum resource has failed, dont bother trying
    // to bring the rest of the resourcess online
    if ((returnStatus != ERROR_SUCCESS) && (returnStatus != ERROR_IO_PENDING))
    {
        FmpSubmitRetryOnline(ResourceEnum);
        goto FnExit;
    }

    // bring online all of the other resources
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );


        //
        // If we fail to find a resource, then just continue.
        //
        if ( resource == NULL ) {
            status = ERROR_RESOURCE_NOT_FOUND;
            continue;
        }

        FmpAcquireLocalResourceLock(resource);
        
        //if the resource has been marked for delete, then dont let
        //it be brought online
        if (!IS_VALID_FM_RESOURCE(resource))
        {
            FmpReleaseLocalResourceLock( resource );
            OmDereferenceObject(resource);
            continue;
        }


        //quorum resource has already been handled 
        if (resource->QuorumResource)
        {
            FmpReleaseLocalResourceLock( resource );
            OmDereferenceObject(resource);
            continue;
        }           
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOnlineResourceFromList: Previous resource state for %1!ws! is %2!u!\r\n",
                   OmObjectId(resource), ResourceEnum->Entry[i].State);

        if ( (ResourceEnum->Entry[i].State == ClusterResourceOnline) ||
             (ResourceEnum->Entry[i].State == ClusterResourceFailed) ) 
        {
            //
            // Now bring the resource online if that is it's current state.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceFromList: trying to bring resource %1!ws! online\n",
                       OmObjectId(resource));

            status = FmpOnlineResource( resource, FALSE );
            if ( returnStatus == ERROR_SUCCESS ) 
            {
                returnStatus = status;
            }
            //if this resource didnt come online because the quorum resource                
            //didnt come online, dont bother bringing the other resources online
            //just a waste of time
            if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
            {
                //submit a timer callback to try and bring these resources
                //online
                FmpReleaseLocalResourceLock( resource );
                OmDereferenceObject( resource );
                FmpSubmitRetryOnline(ResourceEnum);
                break;
            }                
        }
        FmpReleaseLocalResourceLock( resource );
        OmDereferenceObject( resource );
    }

FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineResourceFromList: Exit, status=%1!u!\r\n",
               returnStatus);
    return(returnStatus);

} // FmpOnlineResourceFromList



BOOL
FmpEqualGroupLists(
    IN PGROUP_ENUM Group1,
    IN PGROUP_ENUM Group2
    )

/*++

Routine Description:

    This routine verifies that two group lists are equal.

Arguments:

    Group1 - The first group to compare.
    Group2 - The second group to compare.

Returns:

    TRUE - if the two lists are equal.
    FALSE - otherwise.

--*/

{
    DWORD i;

    if ( (Group1 == NULL) ||
         (Group2 == NULL) ) {
        ClRtlLogPrint(LOG_NOISE,"[FM] One of the Group lists is NULL for equality check\n");
        return(FALSE);
    }

    if ( Group1->EntryCount != Group2->EntryCount ) {
        ClRtlLogPrint(LOG_NOISE,"[FM] Group entry counts not equal! Left: %1!u!, Right: %2!u!.\n",
                              Group1->EntryCount, Group2->EntryCount);
        return(FALSE);
    }

    for ( i = 0; i < Group1->EntryCount; i++ ) {
        if ( lstrcmpiW(Group1->Entry[i].Id, Group2->Entry[i].Id) != 0 ) {
            ClRtlLogPrint(LOG_NOISE,"[FM] Group Lists do not have same names!\n");
            return(FALSE);
        }
    }

    return(TRUE);

} // FmpEqualGroupLists



BOOL
FmpEnumGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN PFM_GROUP_ENUM_DATA EnumData,
    IN PFM_GROUP Group,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of Groups.
    This routine adds the specified Group to the list that is being
    generated.

Arguments:

    Enum - The Group Enumeration list. Can be an output if a new list is
            allocated.

    EnumData - Supplies the current enumeration data structure.

    Group - The Group object being enumerated.

    Id - The Id of the Group object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.

Side Effects:

    Makes the quorum group first in the list.

--*/

{
    PGROUP_ENUM groupEnum;
    PGROUP_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;
    LPWSTR tmpId;
    DWORD  status;
    PFM_RESOURCE quorumResource;

    //HACKHACK::
    //SS: Since this is invoked from within a gum call and
    // the owner node is changed only within a gum call 
    // we wont acquire locks. 
    // there is a window if the dead node is the source of a
    // move and if it does a move after it is declared dead by
    // other nodes, the target of move and the fmpassignownerstogroup
    // might both land up bringing the group online on two nodes
    // However, if we could be guaranteed virtual synchrony, then
    // the target of move wouldnt accept calls from a dead node and
    // we wont land up in this soup.  Now, it is upto the xport layer
    // to provide this guarantee.  
    // For now we acquire no locks 
    
    //FmpAcquireLocalGroupLock( Group );
    
    if ((EnumData->OwnerNode != NULL) &&
        (EnumData->OwnerNode != Group->OwnerNode) &&
        (EnumData->OwnerNode != Group->pIntendedOwner)) {
        //
        // This group does not match the owner criteria
        //
        //FmpReleaseLocalGroupLock( Group );
        return(TRUE);
    }

    //FmpReleaseLocalGroupLock( Group );

    groupEnum = *Enum;

    if ( groupEnum->EntryCount >= EnumData->Allocated ) {
        //
        // Time to grow the GROUP_ENUM
        //

        newAllocated = EnumData->Allocated + ENUM_GROW_SIZE;
        newEnum = LocalAlloc(LMEM_FIXED, GROUP_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(FALSE);
        }

        CopyMemory(newEnum, groupEnum, GROUP_SIZE(EnumData->Allocated));
        EnumData->Allocated = newAllocated;
        *Enum = newEnum;
        LocalFree(groupEnum);
        groupEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = LocalAlloc(LMEM_FIXED, (lstrlenW(Id)+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyW(newId, Id);

    //
    // Find the quorum resource, and see if it is this group.
    //
    status = FmFindQuorumResource( &quorumResource );
    if ( status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(status);
    }
    
    groupEnum->Entry[groupEnum->EntryCount].Id = newId;
    if ( quorumResource->Group == Group ) {
        // found the quorum resource group, put it first in the list.
        tmpId = groupEnum->Entry[0].Id;
        groupEnum->Entry[0].Id = newId;
        groupEnum->Entry[groupEnum->EntryCount].Id = tmpId;
        EnumData->QuorumGroup = TRUE;
    }
    ++groupEnum->EntryCount;

    OmDereferenceObject( quorumResource );

    return(TRUE);

} // FmpEnumGroups



#if 0
int
_cdecl
SortCompare(
    IN const PVOID Elem1,
    IN const PVOID Elem2
    )

{
    PGROUP_ENUM_ENTRY El1 = (PGROUP_ENUM_ENTRY)Elem1;
    PGROUP_ENUM_ENTRY El2 = (PGROUP_ENUM_ENTRY)Elem2;

    return(lstrcmpiW( El1->Id, El2->Id ));

} // SortCompare
#endif


DWORD
FmpClaimAllGroups(
    PGROUP_ENUM MyGroups
    )
/*++

Routine Description:

    Takes ownership of all the groups defined in the cluster. This
    is used when a new cluster is being formed.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise

--*/

{
    //
    // Bring online any Group that needs to be online.
    //
    FmpOnlineGroupList( MyGroups, FALSE );

    return(ERROR_SUCCESS);
}



VOID
FmpDeleteEnum(
    IN PGROUP_ENUM Enum
    )

/*++

Routine Description:

    This routine deletes an GROUP_ENUM and associated name strings.

Arguments:

    Enum - The GROUP_ENUM to delete. This pointer can be NULL.

Returns:

    None.

Notes:

    This routine will take a NULL input pointer and just return.

--*/

{
    PGROUP_ENUM_ENTRY enumEntry;
    DWORD i;

    if ( Enum == NULL ) {
        return;
    }

    for ( i = 0; i < Enum->EntryCount; i++ ) {
        enumEntry = &Enum->Entry[i];
        LocalFree(enumEntry->Id);
    }

    LocalFree(Enum);
    return;

} // FmpDeleteEnum


/****
@func       VOID | FmpPrepareGroupForOnline| This routine sets the Group
            up for onlining it on this node post a failure of a node
            or at initialization.

@parm       IN PFM_GROUP | pGroup| A pointer to the group.

@comm       The group lock must be held.  Except when called at bootstrapping
            by FmBringQuorumOnline.
            MUST BE CALLED ONLY BY THE OWNER NODE OF THE GROUP.

@rdesc      returns ERROR_SUCCESS if succesful else w32 error code. 
            MUST BE CALLED ONLY BY THE OWNER NODE OF THE GROUP.
****/
VOID FmpPrepareGroupForOnline(
    IN PFM_GROUP   pGroup
)
{
    PLIST_ENTRY     pListEntry;
    PFM_RESOURCE    pResource;

    pGroup->State = ClusterGroupOffline;
    ++pGroup->StateSequence;
    //
    // Mark offline all of the resources contained within this group.
    //
    for (pListEntry = pGroup->Contains.Flink;
         pListEntry != &pGroup->Contains;
         pListEntry = pListEntry->Flink)
    {
        pResource = CONTAINING_RECORD(pListEntry, FM_RESOURCE, ContainsLinkage);
        pResource->State = ClusterResourceOffline;
        ++pResource->StateSequence;
    }
}

/****
@func       DWORD | FmpSetGroupEnumOwner| This routine sets the Group
            owner for all Groups in the list.

@parm       IN PGROUP_ENUM | pGroupEnum| The list of Groups.
@parm       IN PNM_NODE | pDefaultOwnerNode | A pointer to the default owner
            node.
@parm       IN PNM_NODE | pDeadNode | A pointed to the node that died.  If
            this routine is being called other wise, this is set to NULL.
@parm       IN BOOL | bQuorumGroup | set to TRUE if the quorum group is
            on the list of groups.

@parm       IN PFM_GROUP_NODE_LIST | pGroupNodeList | The randomized suggested preferred 
            owner for all groups.

@comm       If the group was in the process of moving and had an intended
            owner and the intended owner is not dead, the intended owner is
            allowed to take care of the group. Else, the first node on the
            preferred list that is up is chosen as the owner.  If no such
            node exits, then the ownership is assigned to the default owner
            provided. This routine is called by the forming node at
            initialization to claimownership of all groups and by the gum
            update procedure FmpUpdateAssignOwnerToGroups.

@rdesc      returns ERROR_SUCCESS if succesful else w32 error code.
****/
DWORD
FmpSetGroupEnumOwner(
    IN PGROUP_ENUM  pGroupEnum,
    IN PNM_NODE     pDefaultOwnerNode,
    IN PNM_NODE     pDeadNode,
    IN BOOL         bQuorumGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList
    )
{
    PFM_GROUP   pGroup;
    DWORD       i;
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pOwnerNode;


    for ( i = 0; i < pGroupEnum->EntryCount; i++ )
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                        pGroupEnum->Entry[i].Id );
        if ( pGroup == NULL )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetGroupEnumOwner: Group %1!ws! not found\n",
                pGroupEnum->Entry[i].Id);
            dwStatus = ERROR_GROUP_NOT_FOUND;
            goto FnExit;
        }
        //
        // SS: HACKHACK : cant get the group lock within a gum update
	    // FmpAcquireLocalGroupLock( pGroup );
	    //
        // SS: In case of a node death, see if there was an intended owner
        // if the intended owner is set and if the intended owner is
        // not the one that died then we use the normal procedure
        // else we let the intended owner take care of the group.

        //
        // Chittur Subbaraman (chitturs) - 7/26/99
        //
        // Condition 2: Means the group was being moved and FmpTakeGroupRequest
        // has not taken 100% responsibility for the group.
        //
        // Condition 3: Means the source node crashed and NOT the destination node.
        //
        // Added condition 4 to cover the case in which the source node of
        // the move crashed AFTER setting the intended owner as the
        // destination node and BEFORE the FmpTakeGroupRequest has set
        // the group ownership to the destination node.
        //
        // If the group's owner node and the group's intended owner node are
        // not the same, then let this GUM handler take care of assigning
        // the group ownership. This means that the FmpTakeGroupRequest
        // has not yet set the ownership for the group to the destination
        // node of the move. Now, once this GUM handler sets the 
        // ownership for the group and then resets the intended owner to
        // NULL, FmpTakeGroupRequest which could follow behind this GUM handler
        // will not succeed in setting the ownership to the local node and that 
        // will just return doing nothing.  This is TRUE only for an NT5 cluster. 
        // For a mixed-mode cluster, all bets are off.
        //
        if ( (pDeadNode) && 
             (pGroup->pIntendedOwner != NULL) &&
             (pGroup->pIntendedOwner != pDeadNode) &&
             (pGroup->OwnerNode == pGroup->pIntendedOwner) )
        {
            //
            //  Chittur Subbaraman (chitturs) - 7/27/99
            //
            //  Looks like this code inside "if" will never ever be
            //  executed. Keeping it so as to make the changes minimal.
            //
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpSetGroupEnumOwner: Group %1!ws! will be handled by node %2!ws!\n",
               OmObjectId(pGroup), OmObjectId(pGroup->pIntendedOwner));
            continue;
        }


        //
        // Find first preferred node that is UP, if we can't find any use
        // default OwnerNode
        //
        //
        // If this is the quorum group, then use the node that was selected
        // by the MM layer. The quorum group is the first entry in the list
        // and the Boolean QuorumGroup must be TRUE!
        //
        if ( (i == 0) && bQuorumGroup )
        {
            DWORD dwOwnerNodeId;

            //for the quorum group find the node that had last
            //arbitrated for it.
            //We do this by asking MM about it.
            //If there was no arbitration during the last regroup
            //but there was one in the one before that one, the
            //node that arbitrated is returned.
            //This node should be able to online the group.
            //We use MMApproxArbitrationWinner instead if 
            // MMGetArbitrationWinner() since multiple-regroups 
            // might occur before the FM handles the node down
            // event for this node.
            MMApproxArbitrationWinner( &dwOwnerNodeId );
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetGroupEnumOwner:: MM suggests node %1!u! for quorum owner\r\n",
                dwOwnerNodeId);
            
            if ( dwOwnerNodeId != MM_INVALID_NODE )
            {
                pOwnerNode = NmReferenceNodeById( dwOwnerNodeId );
            }
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpSetGroupEnumOwner:: MM returned MM_INVALID_NODE, chose the default target\r\n");
                //else just use the default target
                pOwnerNode = pDefaultOwnerNode;
            }
        }
        else
        {
            pOwnerNode = FmpGetPreferredNode(pGroup);
            if ( pOwnerNode == NULL )
            {
	            pOwnerNode = pDefaultOwnerNode;
            }

            //
            //  If the caller (GUM) has supplied a randomized preferred owner of the group, then
            //  see if it can be used.
            //
            if ( pGroupNodeList != NULL )
            {
                pOwnerNode = FmpParseGroupNodeListForPreferredOwner( pGroup, 
                                                                     pGroupNodeList, 
                                                                     pOwnerNode );
            }
        }


        if ( pGroup->OwnerNode != NULL )
        {
            OmDereferenceObject( pGroup->OwnerNode );
        }

        OmReferenceObject( pOwnerNode );
        pGroup->OwnerNode = pOwnerNode;

        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpSetGroupEnumOwner: Group's %1!ws! new owner is node %2!ws!\n",
               OmObjectId(pGroup), OmObjectId(pOwnerNode));

	    //FmpReleaseLocalGroupLock( pGroup );
        OmDereferenceObject(pGroup);
    }

FnExit:
    return(dwStatus);

} // FmpSetGroupEnumOwner


DWORD
FmpAssignOwnersToGroups(
    IN PNM_NODE pDeadNode,
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST  pGroupNodeList
    )
/*++

Routine Description:

    Takes ownership of all the groups defined in the cluster that
    are owned by another node. This is used when a node fails.

    The current algorithm is very dumb and simple. Node with the
    lowest ID gets all the groups.

Arguments:

    pDeadNode - Supplies the node that all the groups should be taken
           from.

    pGroup - Supplies the group which alone is to be claimed.

    pGroupNodeList - The randomized suggested preferred owner for all groups.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise

--*/

{
    DWORD               i;
    DWORD               dwStatus;
    PGROUP_ENUM         pNodeGroups = NULL;
    PNM_NODE            pDefaultTarget = NULL;
    PNM_NODE            pPausedTarget = NULL;
    BOOL                bQuorumGroup;

    //
    // Acquire the global group lock
    //
    FmpAcquireGroupLock();

    //
    // Check if groups are initialized
    //
    if ( !FmpFMGroupsInited )
    {
        dwStatus = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    // Find and sort all known groups
    //
    if ( pGroup == NULL )
    {
        dwStatus = FmpEnumSortGroups(&pNodeGroups, pDeadNode, &bQuorumGroup);
    } else
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/7/99
        //
        //  This means you got here due to an RPC exception raised in
        //  FmpTakeGroupRequest. So, see where this sole group goes.
        //
        dwStatus = FmpGetGroupInNodeGroupList(&pNodeGroups, pGroup, pDeadNode, &bQuorumGroup);
    }
    
    if (dwStatus != ERROR_SUCCESS)
    {
        CL_ASSERT(pNodeGroups == NULL);
        goto FnExit;
    }

    CL_ASSERT(pNodeGroups != NULL);

    //if no nodes were owned by this node, just return
    if (pNodeGroups->EntryCount == 0)
    {
        FmpDeleteEnum(pNodeGroups);
        goto FnExit;
    }

    //
    // Find the state of the Groups.
    //
    FmpGetGroupListState( pNodeGroups );

    //
    // Find the active node with the lowest ID to be the default
    // owner of these groups.
    //
    // If we can't find an active node then select the lowest node id for
    // a node that is paused.
    //
    CL_ASSERT(NmMaxNodeId != ClusterInvalidNodeId);
    CL_ASSERT(Session != NULL);

    for (i=ClusterMinNodeId; i<=NmMaxNodeId; i++)
    {
        pDefaultTarget = NmReferenceNodeById(i);

        if ( pDefaultTarget != NULL )
        {
            //if this node is up, there is no need to use a paused target
            if ( NmGetNodeState(pDefaultTarget) == ClusterNodeUp )
            {
                if ( pPausedTarget )
                {
                    OmDereferenceObject(pPausedTarget);
                    pPausedTarget = NULL;
                }
                //found a node, leave this loop
                break;
            }
            //node is not up, check if it paused
            //if is is paused and no other paused node has been found
            //set this one to be the lowest paused node
            if ( !pPausedTarget && 
                (NmGetNodeState(pDefaultTarget) == ClusterNodePaused) )
            {
                pPausedTarget = pDefaultTarget;
            }
            else
            {
                OmDereferenceObject(pDefaultTarget);
            }
            pDefaultTarget = NULL;
        }
    }

    if ( (pDefaultTarget == NULL) && (pPausedTarget == NULL) ) {
        //
        // There are no online/paused nodes, this node must be paused,
        // so don't do anything.
        //
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpAssignOwnersToGroups - no online/paused nodes remaining\n");
        //SS: then what are we doing here
        FmpDeleteEnum(pNodeGroups);
        goto FnExit;
    }

    //if no node is up, use the lowest paused node as the default owner for
    //the groups
    if ( pDefaultTarget == NULL )
    {
        pDefaultTarget = pPausedTarget;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpAssignOwnersToGroups - DefaultTarget is %1!ws!\n",
        OmObjectId(pDefaultTarget));

    //
    //  Chittur Subbaraman (chitturs) - 7/20/99
    //
    //  Prepare the entire group list for subsequent online. You have
    //  to do this here to have a consistent resource state view
    //  among different nodes in the cluster since this is the GUM
    //  handler. Also, the DM node down handler which follows this
    //  GUM handler may think that the quorum resource is owned by 
    //  this node and its state is online while it has not been 
    //  brought online on this node. Note also the order of this
    //  call and the call to set the group ownership. THIS ORDER
    //  MUST BE FOLLOWED since we don't hold any groups lock here
    //  (since we are paranoid about deadlocks) and we don't want 
    //  the FmCheckQuorumState function called as a part of the 
    //  DM node down handler to think that the group is owned by 
    //  this node and is also online on this node.
    //
    FmpPrepareGroupEnumForOnline( pNodeGroups );

    //
    // Set the Group owner.
    //
    FmpSetGroupEnumOwner( pNodeGroups, 
                          pDefaultTarget, 
                          pDeadNode,
                          bQuorumGroup,
                          pGroupNodeList );

    //
    //  Chittur Subbaraman (chitturs) - 5/26/99
    //
    //  Clear the intended owner fields of all the groups. This is done
    //  since there is no guarantee that FmpTakeGroupRequest will do this.
    //
    FmpResetGroupIntendedOwner( pNodeGroups );
  
    //
    //  Chittur Subbaraman (chitturs) - 7/14/99
    //
    //  Handle the online of group list containing the quorum resource with  
    //  a separate thread and let the worker thread handle group lists
    //  not containing the quorum resource. This is necessary since it is
    //  possible that this node can take ownership at roughly the same
    //  time of a quorum group and a non-quorum group each resident 
    //  in a different node due to back-to-back node crashes. In such a
    //  case, we can't order these groups for online globally with the
    //  quorum group first in the list. So, we don't want the worker thread 
    //  to be "stuck" in FmpRmOnlineResource for the non-quorum group's 
    //  resource waiting for the quorum group to be brought online since 
    //  the quorum group online work item is queued behind the non-quorum 
    //  group online work item.
    //
    if ( bQuorumGroup )
    {
        HANDLE  hThread = NULL;
        DWORD   dwThreadId;

        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpAssignOwnersToGroups - Create thread to handle group list containing quorum group....\n"
                  );
    
        hThread = CreateThread( NULL, 
                                0, 
                                FmpBringQuorumGroupListOnline,
                                pNodeGroups, 
                                0, 
                                &dwThreadId );

        if ( hThread == NULL )
        {
            CL_UNEXPECTED_ERROR( GetLastError() );
            OmDereferenceObject( pDefaultTarget );
            goto FnExit;
        }
        
        CloseHandle( hThread );
    } else
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpAssignOwnersToGroups - Post work item to worker thread to handle group list containing non-quorum groups....\n"
                  );
        FmpPostWorkItem(FM_EVENT_INTERNAL_ONLINE_GROUPLIST, pNodeGroups, 0);
    }

    OmDereferenceObject(pDefaultTarget);

FnExit:
    //
    // Release the global group lock
    //
    FmpReleaseGroupLock();


    return(ERROR_SUCCESS);
}

/****
@func       DWORD | FmpResetGroupIntendedOwner| This routine resets the 
            intended owner for all groups in the list.

@parm       IN PGROUP_ENUM | pGroupEnum| The list of Groups.

@rdesc      Returns ERROR_SUCCESS.
****/
VOID
FmpResetGroupIntendedOwner(
    IN PGROUP_ENUM  pGroupEnum
    )
{
    DWORD i;
    PFM_GROUP pGroup;

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpResetGroupIntendedOwner: Entry.\n");
    
    for ( i = 0; i < pGroupEnum->EntryCount; i++ )
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                        pGroupEnum->Entry[i].Id );
        if ( pGroup == NULL )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpResetGroupIntendedOwner: Group %1!ws! not found\n");
            continue;
        }
        
        pGroup->pIntendedOwner = NULL;

        OmDereferenceObject( pGroup );
    }

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpResetGroupIntendedOwner: Exit.\n");

}

/****
@func       DWORD | FmpGetGroupInNodeGroupList | This routine checks whether
            the supplied group is to be included in the list to be brought
            online.

@parm       OUT PGROUP_ENUM | pReturnEnum | The group list possibly 
            containing the supplied group.

@parm       IN PFM_GROUP | pGroup | The group which is to be brought online
            possibly.

@parm       IN PNM_NODE | pDeadNode | The node which is dead.

@parm       OUT PBOOL | pbQuorumGroup | Does the group list contain the quorum group ?

@rdesc      Returns ERROR_SUCCESS on success OR a Win32 error code on a 
            failure.
****/
DWORD
FmpGetGroupInNodeGroupList(
    OUT PGROUP_ENUM *pReturnEnum,
    IN PFM_GROUP pGroup,
    IN PNM_NODE pDeadNode,
    OUT PBOOL pbQuorumGroup
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PGROUP_ENUM pGroupEnum = NULL;
    PFM_RESOURCE pQuoResource = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 6/7/99
    //
    //  This function is only called if an RPC exception is raised in
    //  FmpTakeGroupRequest. This function will check to see whether this
    //  group is to be brought online in this node.
    //
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Entry for group <%1!ws!>\n",
                OmObjectId(pGroup));

    *pbQuorumGroup = FALSE;
   
    pGroupEnum = LocalAlloc( LPTR, 
                             sizeof( GROUP_ENUM_ENTRY ) + sizeof( GROUP_ENUM ) );
    
    if ( pGroupEnum == NULL ) 
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    pGroupEnum->Entry[0].Id = pGroupEnum->Entry[1].Id = NULL;

    pGroupEnum->EntryCount = 0;

    //
    //  Check whether this group was in the dead node or was in the
    //  process of moving to the dead node.
    //
    if( ( pDeadNode != NULL ) &&
        ( pDeadNode != pGroup->OwnerNode ) &&
        ( pDeadNode != pGroup->pIntendedOwner ) ) 
    {
        //
        // This group does not match the owner criteria
        //
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    dwStatus = FmFindQuorumResource( &pQuoResource );
    
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpGetGroupInNodeGroupList: Cannot find quorum resource, Status = %1!u!\n",
                dwStatus);
        CsInconsistencyHalt( dwStatus );
    }

    //
    //  Handle the quorum group first, if necessary. This is needed since
    //  otherwise you may not be able to bring the other group online.
    //
    if( ( pGroup != pQuoResource->Group ) && 
        ( ( pDeadNode == NULL ) ||
          ( pDeadNode == pQuoResource->Group->OwnerNode ) ||
          ( pDeadNode == pQuoResource->Group->pIntendedOwner ) ) ) 
    {
        //
        // The quorum group matches the owner criteria. Include it first
        // in the list.
        //
        pGroupEnum->Entry[pGroupEnum->EntryCount].Id = 
            LocalAlloc( LMEM_FIXED, ( lstrlenW(OmObjectId(pQuoResource->Group)) + 1 ) * sizeof( WCHAR ) );

        if ( pGroupEnum->Entry[pGroupEnum->EntryCount].Id == NULL )
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }

        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Dead node contains quorum group also, including it...\n");
        lstrcpyW( pGroupEnum->Entry[pGroupEnum->EntryCount].Id, OmObjectId( pQuoResource->Group ) );
        pGroupEnum->EntryCount++;
        *pbQuorumGroup = TRUE;
    } else if ( pGroup == pQuoResource->Group )
    {
        *pbQuorumGroup = TRUE;
    }

    pGroupEnum->Entry[pGroupEnum->EntryCount].Id = 
        LocalAlloc( LMEM_FIXED, ( lstrlenW(OmObjectId(pGroup)) + 1 ) * sizeof( WCHAR ) );

    if ( pGroupEnum->Entry[pGroupEnum->EntryCount].Id == NULL )
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    lstrcpyW( pGroupEnum->Entry[pGroupEnum->EntryCount].Id, OmObjectId( pGroup ) );

    pGroupEnum->EntryCount++;

    *pReturnEnum = pGroupEnum;
    
    OmDereferenceObject( pQuoResource );
    
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Exit with SUCCESS.\n");

    return( ERROR_SUCCESS );

FnExit:
    if ( pGroupEnum != NULL ) 
    {
        FmpDeleteEnum( pGroupEnum );
    }

    if ( pQuoResource != NULL )
    {   
        OmDereferenceObject( pQuoResource );
    }

    *pReturnEnum = NULL;

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Exit, Status = %1!u!\n",
                dwStatus);
 
    return( dwStatus );
}

/****
@func       VOID | FmpPrepareGroupEnumForOnline | Prepare a list of
            groups for online.

@parm       IN PGROUP_ENUM | pGroupEnum | The group list.

@rdesc      None.
****/
VOID
FmpPrepareGroupEnumForOnline(
    IN PGROUP_ENUM pGroupEnum
    )
{
    PFM_GROUP pGroup = NULL;
    DWORD     i;

    //
    //  Chittur Subbaraman (chitturs) - 6/21/99
    //
    //  Prepare an entire group list for online.
    //
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpPrepareGroupEnumForOnline - Entry...\n");
   
    for ( i=0; i<pGroupEnum->EntryCount; i++ ) 
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                        pGroupEnum->Entry[i].Id );

        //
        // If we fail to find a group, then just continue.
        //
        if ( pGroup == NULL ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpPrepareGroupEnumForOnline - Group %1!ws! cannot be found !\n",
                pGroupEnum->Entry[i].Id);
            continue;
        }

        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpPrepareGroupEnumForOnline - Preparing group <%1!ws!> for online...\n",
                pGroupEnum->Entry[i].Id);

        FmpPrepareGroupForOnline( pGroup );
    }

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpPrepareGroupEnumForOnline - Exit...\n");

}

/****
@func       DWORD | FmpBringQuorumGroupListOnline | Bring a list of groups
            containing the quorum group online.

@parm       IN LPVOID | pContext | A pointer to the group list to be brought
            online.

@rdesc      Returns ERROR_SUCCESS.
****/
DWORD
FmpBringQuorumGroupListOnline(
    IN LPVOID pContext
    )
{
    PGROUP_ENUM pGroupList = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 7/14/99
    //
    //  This function tries to bring a list of groups containing the quorum
    //  group online. Note that if the group's owner turns out to be some
    //  other node, this function will not online the group.
    //
    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpBringQuorumGroupListOnline - Entry: Trying to online group list containing quorum group....\n"
                  );

    pGroupList = pContext;

    CL_ASSERT( pGroupList != NULL );
    
    FmpOnlineGroupList( pGroupList, TRUE );
    
    FmpDeleteEnum( pGroupList );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpBringQuorumGroupListOnline - Exit ....\n"
                  );

    return( ERROR_SUCCESS );
}

/****
@func       BOOL | FmpIsAnyResourcePersistentStateOnline | Is the persistent state of any
            resource in the group online ?

@parm       IN PFM_GROUP | pGroup | The group which is to be checked.

@rdesc      TRUE if at least one resource's persistent state is ClusterResourceOnline, FALSE otherwise.
****/
BOOL
FmpIsAnyResourcePersistentStateOnline(
    IN PFM_GROUP pGroup
    )
{
    PFM_RESOURCE    pResource;
    PLIST_ENTRY     pListEntry;

    if ( CsNoQuorum ) return FALSE;
    
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &( pGroup->Contains );
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry, 
                                       FM_RESOURCE, 
                                       ContainsLinkage );

        if ( pResource->PersistentState == ClusterResourceOnline ) 
        {
            ClRtlLogPrint(LOG_NOISE,
                          "[FM] FmpIsAnyResourcePersistentStateOnline: Persistent state of resource %1!ws! in group %2!ws! is online...\r\n",
                          OmObjectId(pResource), 
                          OmObjectId(pGroup));
            return ( TRUE );
        }
    } // for

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpIsAnyResourcePersistentStateOnline: No resource in group %1!ws! has persistent state online...\r\n",
                 OmObjectId(pGroup));
    
    return( FALSE );
} // FmpIsAnyResourcePersistentStateOnline
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\recv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    Cluster FM remote receive request routines.

Author:

    Rod Gamache (rodga) 21-Mar-1996


Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE RECV

//
// Global data
//

extern BOOL FmpOkayToProceed;

//
// Local function prototypes
//
BOOL
FmpEnumMyGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Id
    );

BOOL
FmpEnumResources(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Id
    );


error_status_t
s_FmsOnlineGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId
    )

/*++

Routine Description:

    Receives a Group Online Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to bring online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsOnlineGroupRequest: To bring group '%1!ws!' online\n",
               GroupId);

    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsOnlineGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    // Only one of these requests per group at a time.
    //
    FmpAcquireLocalGroupLock( group );


    //
    // Now bring it online.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Set the Group's Current State.
        //
        FmpSetGroupPersistentState( group, ClusterGroupOnline );

        status = FmpOnlineGroup( group, TRUE );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalGroupLock( group );

    OmDereferenceObject( group );

    return(status);

} // FmsOnlineGroupRequest



error_status_t
s_FmsOfflineGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId
    )

/*++

Routine Description:

    Receives a Group Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to bring offline.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsOfflineGroupRequest: To take group '%1!ws!' offline\n",
               GroupId);

    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsOfflineGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    // Now take it offline if we are the owner.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Set the Group's Current State.
        //
        FmpSetGroupPersistentState( group, ClusterGroupOffline );

        status = FmpOfflineGroup( group, FALSE, TRUE );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    OmDereferenceObject( group );

    return(status);

} // FmsOfflineGroupRequest



error_status_t
s_FmsMoveGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN LPCWSTR DestinationNode OPTIONAL
    )

/*++

Routine Description:

    Receives a Group Move Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to move.
    DestinationNode - The Id of the node to move the Group to.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    PNM_NODE node = NULL;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsMoveGroupRequest: To move group '%1!ws!'\n",
               GroupId);

    //
    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsMoveGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    // Find the specified destination node.
    //

    if ( ARGUMENT_PRESENT( DestinationNode ) ) {
        node = OmReferenceObjectById( ObjectTypeNode, DestinationNode );

        if ( node == NULL ) {
            OmDereferenceObject( group );
            ClRtlLogPrint(LOG_NOISE,"[FM] FmsMoveGroupRequest: Could not find Node %1!ws!\n", DestinationNode);
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }
    }

    //
    // Make sure we are the owner of the Group.
    //
    FmpAcquireLocalGroupLock( group );
    if ( group->OwnerNode == NmLocalNode ) {
        status = FmpDoMoveGroup( group, node, TRUE );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }
    FmpReleaseLocalGroupLock( group );

    OmDereferenceObject( group );
    if ( node != NULL ) {
        OmDereferenceObject( node );
    }

    return(status);

} // FmsMoveGroupRequest



error_status_t
s_FmsTakeGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN PRESOURCE_ENUM ResourceList
    )

/*++

Routine Description:

    Receives a Take Group Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to take locally.
    ResourceList - The list of resources and their states.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    DWORD status = ERROR_SUCCESS;

    //SS: removing this check from here 
    //FmpTakeGroupRequest does this check since if this call returns a failure,
    //the intended owner needs to be reset to invalidnode to avoid inconsistencies
    //FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsTakeGroupRequest: To take group '%1!ws!'.\n",
               GroupId );

    //
    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsTakeGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        if ( !FmpFMOnline ) {
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }
        return(ERROR_GROUP_NOT_FOUND);
    }

    status = FmpTakeGroupRequest(group, ResourceList);
    OmDereferenceObject(group);

    return(status);

} // FmsTakeGroupRequest



error_status_t
s_FmsOnlineResourceRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Resource Online Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to bring online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsOnlineResourceRequest: To bring resource '%1!ws!' online\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsOnlineResourceRequest: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    if (!(resource->QuorumResource) && 
        !FmpInPreferredList( resource->Group, resource->Group->OwnerNode, TRUE, resource ) ) {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnExit;
    }

    //
    // Now bring it online.
    //
    CL_ASSERT( resource->Group != NULL );
    if ( resource->Group->OwnerNode == NmLocalNode ) {
        //
        // This can only be invoked through the API, so force all
        // resources online.
        //
        status = FmOnlineResource( resource );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

FnExit:
    FmpReleaseLocalResourceLock( resource );

    OmDereferenceObject( resource );

    return(status);

} // FmsOnlineResourceRequest



error_status_t
s_FmsOfflineResourceRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Resource Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to bring offline.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmsOfflineResourceRequest: To take resource '%1!ws!' offline\n",
              ResourceId);

    //
    // Find the specified resource.
    //

    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsOfflineResourceRequest: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock(resource);
    //
    // Now take it offline if we are the owner.
    //
    CL_ASSERT( resource->Group != NULL );
    if ( resource->Group->OwnerNode != NmLocalNode ) 
    {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnExit;
    } 
    //else handle it locally
    status = FmOfflineResource( resource );

FnExit:
    FmpReleaseLocalResourceLock(resource);
    OmDereferenceObject( resource );

    return(status);

} // FmsOfflineResourceRequest



error_status_t
s_FmsChangeResourceNode(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NodeId,
    IN BOOL Add
    )

/*++

Routine Description:

    Receives a Resource change node request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to change a node.
    NodeId - The node id of the node to add or remove.
    Add - Indicates whether to add or remove the node.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD        status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsChangeResourceNode: To %1!ws! node %2!ws! to/from resource '%3!ws!'.\n",
               Add ? L"Add" : L"Remove",
               NodeId,
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsChangeResourceNode: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    status = FmpChangeResourceNode(resource, NodeId, Add);
    FmpReleaseLocalResourceLock( resource );
    OmDereferenceObject( resource );

    return(status);

} // FmsChangeResourceNode



error_status_t
s_FmsArbitrateResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Arbitrates a Resource for a remote system.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to bring online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsArbitrateResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    status = FmpRmArbitrateResource( resource );

    OmDereferenceObject( resource );

    return(status);

} // FmsArbitrateResource



error_status_t
s_FmsQueryOwnedGroups(
    IN handle_t IDL_handle,
    OUT PGROUP_ENUM *OwnedGroups,
    OUT PRESOURCE_ENUM *OwnedResources
    )
/*++

Routine Description:

    Server side used to propagate FM state to a joining node.

Arguments:

    IDL_handle - Supplies RPC binding handle, not used.

    OwnedGroups - Returns the list of groups owned by this node and
        their state.

    OwnedResources - Returns the list of resources contained by groups
        owned by this node and their state.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           allocated;
    PGROUP_ENUM     groupEnum = NULL;
    PFM_GROUP       group;
    PRESOURCE_ENUM  resourceEnum = NULL;
    PFM_RESOURCE    resource;
    DWORD i;

    allocated = ENUM_GROW_SIZE;

    groupEnum = MIDL_user_allocate(GROUP_SIZE(allocated));
    if ( groupEnum == NULL ) {
        CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    groupEnum->EntryCount = 0;
    //
    // Enumerate all groups
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumMyGroups,
                   &groupEnum,
                   &allocated );

    //
    // Enumerate all the resources in each group.
    //
    allocated = ENUM_GROW_SIZE;
    resourceEnum = MIDL_user_allocate(RESOURCE_SIZE(allocated));
    if (resourceEnum == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(status);
        goto error_exit;
    }
    resourceEnum->EntryCount = 0;

    for (i=0; i < groupEnum->EntryCount; i++) {
        //
        // Get the group given its name.
        //
        group = OmReferenceObjectById( ObjectTypeGroup,
                                       groupEnum->Entry[i].Id );
        if (group == NULL) {
            continue;
        }

        //
        // Enumerate all the resources in this group.
        //
        status = FmpEnumerateGroupResources(group,
                                  FmpEnumResources,
                                  &resourceEnum,
                                  &allocated);
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmsQueryOwnedGroups: Failed group '%1!ws!', status %2!u!.\n",
                       OmObjectId(group),
                       status);
        }
        OmDereferenceObject(group);
    }

    *OwnedGroups = groupEnum;
    *OwnedResources = resourceEnum;

    return(ERROR_SUCCESS);

error_exit:
    if (groupEnum != NULL) {
        //
        // Free up group enum
        //
        for (i=0; i < groupEnum->EntryCount; i++) {
            MIDL_user_free(groupEnum->Entry[i].Id);
        }
        MIDL_user_free(groupEnum);
    }
    return(status);
}


error_status_t
s_FmsFailResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Resource Fail Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to fail.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsFailResource: To fail resource '%1!ws!'.\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsFailResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    //
    // Now fail it.
    //
    if ( resource->Group->OwnerNode == NmLocalNode ) {
        status = FmpRmFailResource( resource );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalResourceLock( resource );

    return(status);

} // FmsFailResource


error_status_t
s_FmsCreateResource(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName
    )

/*++

Routine Description:

    Receives a Create Resource Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to create the resource inside.
    ResourceId - The Id of the Resource to create.
    ResourceName - The name of the Resource to create.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    The Resource lock is acquired to synchronize access to the resource. This
    satisfies locking the resource on all nodes in the cluster... so long
    as the local node is the owner of the resource.

--*/

{
    PFM_GROUP group;
    DWORD status;
    PGUM_CREATE_RESOURCE gumResource;
    DWORD groupIdLen;
    DWORD resourceIdLen;
    DWORD resourceNameLen;
    DWORD bufSize;
    HDMKEY resourceKey;
    HDMKEY paramsKey;
    DWORD  disposition;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsCreateResource: To create resource '%1!ws!'\n",
               ResourceId);

    //
    // Find the specified group.
    //
    group = OmReferenceObjectById( ObjectTypeGroup,
                                   GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsCreateResource: Could not find Group %1!ws!\n",
                  GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    FmpAcquireLocalGroupLock( group );

    //
    // Now delete it on all nodes in the cluster if we are the owner.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Allocate a message buffer.
        //
        groupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
        resourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
        resourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
        bufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
                  groupIdLen + resourceIdLen + resourceNameLen;
        gumResource = LocalAlloc(LMEM_FIXED, bufSize);
        if (gumResource == NULL) {
            CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Fill in message buffer.
        //
        gumResource->Resource = NULL;
        gumResource->GroupIdLen = groupIdLen;
        gumResource->ResourceIdLen = resourceIdLen;
        CopyMemory(gumResource->GroupId, GroupId, groupIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen,
                   ResourceId,
                   resourceIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen,
                   ResourceName,
                   resourceNameLen);

        //
        // Send message.
        //
        status = GumSendUpdate(GumUpdateFailoverManager,
                               FmUpdateCreateResource,
                               bufSize,
                               gumResource);
        if ( ( status == ERROR_SUCCESS ) && 
             ( gumResource->Resource != NULL ) )
            FmpCleanupPossibleNodeList(gumResource->Resource);                               
        LocalFree(gumResource);
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalGroupLock( group );

    return(status);

} // FmsCreateResource


error_status_t
s_FmsDeleteResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Delete Resource Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to delete.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    The Resource lock is acquired to synchronize access to the resource. This
    satisfies locking the resource on all nodes in the cluster... so long
    as the local node is the owner of the resource.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD resourceLen;

    FmpMustBeOnline();

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsDeleteResource: To delete resource '%1!ws!'\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource,
                                      ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsDeleteResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    //
    // Now delete it on all nodes in the cluster if we are the owner.
    //
    if ( resource->Group->OwnerNode == NmLocalNode ) {
        //
        // Check if this is the quorum resource.
        //
        if ( resource->QuorumResource ) {
            status =  ERROR_QUORUM_RESOURCE;
            goto FnExit;
        }

        //other core resources cannot be deleted either
        if (resource->ExFlags & CLUS_FLAG_CORE)
        {
            status = ERROR_CORE_RESOURCE;
            goto FnExit;
        }


        //
        // Check the state of the resource, before attempting to delete it.
        // It must be offline or failed in order to perform the delete.
        //
        if ((resource->State != ClusterResourceOffline) &&
            (resource->State != ClusterResourceFailed)) {
            status = ERROR_RESOURCE_ONLINE;
            goto FnExit;
        }

        //
        // Check whether this resource provides for any other resources.
        // If so, it cannot be deleted.
        //
        if (!IsListEmpty(&resource->ProvidesFor)) {
            status = ERROR_DEPENDENT_RESOURCE_EXISTS;
            goto FnExit;
        }

        if (resource->Group->MovingList)
        {
            status = ERROR_INVALID_STATE;
            goto FnExit;
        }
        
        resourceLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);

        FmpBroadcastDeleteControl(resource);
        //
        // Send message.
        //
        status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateDeleteResource,
                                 1,
                                 resourceLen,
                                 ResourceId);
    } else {
    
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        
    }


FnExit:
    FmpReleaseLocalResourceLock( resource );
    return(status);

} // FmsDeleteResource


BOOL
FmpEnumMyGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of Groups.
    This routine adds the specified Group to the list that is being
    generated if it is owned by the local system.

Arguments:

    Enum - The Group Enumeration list. Can be an output if a new list is
            allocated.
    Allocated - The current number of allocated entries in Enum.
    Group - The Group object being enumerated.
    Id - The Id of the Group object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    PGROUP_ENUM groupEnum;
    PGROUP_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;
    CLUSTER_GROUP_STATE state;

    //
    // If we don't own the Group, return now.
    //
    if (Group->OwnerNode != NmLocalNode) {
        return(TRUE);
    }

    groupEnum = *Enum;

    if ( groupEnum->EntryCount >= *Allocated ) {
        //
        // Time to grow the GROUP_ENUM
        //

        newAllocated = *Allocated + ENUM_GROW_SIZE;
        newEnum = MIDL_user_allocate(GROUP_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(FALSE);
        }

        CopyMemory(newEnum, groupEnum, GROUP_SIZE(*Allocated));
        *Allocated = newAllocated;
        *Enum = newEnum;
        MIDL_user_free(groupEnum);
        groupEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = MIDL_user_allocate((lstrlenW(Id)+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        return(FALSE);
    }

    lstrcpyW(newId, Id);
    groupEnum->Entry[groupEnum->EntryCount].Id = newId;
    groupEnum->Entry[groupEnum->EntryCount].State = Group->State;
    groupEnum->Entry[groupEnum->EntryCount].StateSequence = Group->StateSequence;
    ++groupEnum->EntryCount;

    return(TRUE);

} // FmpEnumMyGroups


BOOL
FmpEnumResources(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of Group resources.
    This routine adds the specified resource to the list that is being
    generated.

Arguments:

    Enum - The resource enumeration list. Can be an output if a new list is
            allocated.
    Allocated - The current number of allocated entries in Enum.
    Resource - The Resource object being enumerated.
    Id - The Id of the resource object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PRESOURCE_ENUM resourceEnum;
    PRESOURCE_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;

    resourceEnum = *Enum;

    if ( resourceEnum->EntryCount >= *Allocated ) {
        //
        // Time to grow the RESOURCE_ENUM
        //
        newAllocated = *Allocated + ENUM_GROW_SIZE;
        newEnum = MIDL_user_allocate(RESOURCE_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(FALSE);
        }

        CopyMemory(newEnum, resourceEnum, RESOURCE_SIZE(*Allocated));
        *Allocated = newAllocated;
        *Enum = newEnum;
        MIDL_user_free(resourceEnum);
        resourceEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = MIDL_user_allocate((lstrlenW(Id)+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        return(FALSE);
    }

    lstrcpyW(newId, Id);
    resourceEnum->Entry[resourceEnum->EntryCount].Id = newId;
    resourceEnum->Entry[resourceEnum->EntryCount].State = Resource->State;
    resourceEnum->Entry[resourceEnum->EntryCount].StateSequence = Resource->StateSequence;
    ++resourceEnum->EntryCount;

    return(TRUE);

} // FmpEnumResources



error_status_t
s_FmsResourceControl(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request from a remote system.

Arguments:

    IDL_handle - the binding context - not used

    ResourceId - the Id of the Resource to control

    ControlCode - the control code for this request

    InBuffer - the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - the output buffer

    OutBufferSize - the size of the output buffer

    ByteReturned - the number of bytes returned in the output buffer

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD bufSize;
    DWORD dataLength;
    CLUSPROP_BUFFER_HELPER props;

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsResourceControl: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    CL_ASSERT( resource->Group != NULL );

    status = FmpRmResourceControl( resource,
                                   ControlCode,
                                   InBuffer,
                                   InBufferSize,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required
                                   );
    OmDereferenceObject(resource);

    return(status);
} // FmsResourceControl



error_status_t
s_FmsResourceTypeControl(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request from a remote system.

Arguments:

    IDL_handle - the binding context - not used

    ResourceTypeName - the name of the Resource Type to control

    ControlCode - the control code for this request

    InBuffer - the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - the output buffer

    OutBufferSize - the size of the output buffer

    ByteReturned - the number of bytes returned in the output buffer

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    status = FmpRmResourceTypeControl( ResourceTypeName,
                                       ControlCode,
                                       InBuffer,
                                       InBufferSize,
                                       OutBuffer,
                                       OutBufferSize,
                                       BytesReturned,
                                       Required
                                       );

    if ((status == ERROR_MOD_NOT_FOUND) || (status == ERROR_PROC_NOT_FOUND))
    {
        FmpRemovePossibleNodeForResType(ResourceTypeName, NmLocalNode);
    }
#if 0
    if ( ((status == ERROR_SUCCESS) ||
          (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {
        ClusterEvent( CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE, XXX );
    }
#endif

    return(status);

} // FmsResourceTypeControl


error_status_t
s_FmsGroupControl(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine processes a group control request from a remote system.

Arguments:

    IDL_handle - the binding context - not used

    GroupId - the Id of the Group to control

    ControlCode - the control code for this request

    InBuffer - the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - the output buffer

    OutBufferSize - the size of the output buffer

    ByteReturned - the number of bytes returned in the output buffer

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_GROUP group;
    DWORD status;

    //
    // Find the specified group
    //
    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsGroupControl: Could not find Group %1!ws!\n",
                  GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }


    status = FmpGroupControl(group, ControlCode, InBuffer, InBufferSize,
        OutBuffer, OutBufferSize, BytesReturned, Required);
        
    OmDereferenceObject(group);
    return(status);

} // FmsGroupControl


error_status_t
s_FmsPrepareQuorumResChange(
    IN handle_t IDL_handle,
    IN LPCWSTR  ResourceId,
    IN LPCWSTR  lpszQuoLogPath,
    IN DWORD    dwMaxQuoLogSize
    )

/*++

Routine Description:

    Receives a request to prepare a resource to become the quorum resource.
    A resource must be able to support a quorum log file and registry replication
    files.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the resource to be made the quorum resource.
    lpszQuoLogPath - The path where the logs must be created.
    dwMaxQuoLogSize - The maximum size of the quorum log file.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource=NULL;
    DWORD           Status;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsPrepareQuorumResChange: Entry\r\n");

    // Find the specified resource.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( pResource == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsPrepareQuorumResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    CL_ASSERT( pResource->Group != NULL );
    if ( pResource->Group->OwnerNode == NmLocalNode )
        Status = FmpPrepareQuorumResChange(pResource, lpszQuoLogPath, dwMaxQuoLogSize);
    else
        Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;

FnExit:
    if (pResource) OmDereferenceObject( pResource );
    return(Status);

} // FmsPrepareQuorumResChange



error_status_t
s_FmsCompleteQuorumResChange(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszOldQuoResId,
    IN LPCWSTR  lpszOldQuoLogPath
    )

/*++

Routine Description:

    Receives a request to clean up quorum logging and cluster registry files
    on the old quorum resource.

Arguments:

    IDL_handle - The binding context - not used.
    lpszOldQuoResId - The Id of the resource to be made the quorum resource.
    lpszQuoLogPath - The path where the logs must be created.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource=NULL;
    DWORD           Status;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsCompleteQuorumResChange: Entry\r\n");

    // Find the specified resource.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, lpszOldQuoResId );

    if ( pResource == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsCompleteQuorumResource: Could not find Resource %1!ws!\n",
                  lpszOldQuoResId);
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    CL_ASSERT( pResource->Group != NULL );
    if ( pResource->Group->OwnerNode == NmLocalNode )
        Status = FmpCompleteQuorumResChange(lpszOldQuoResId, lpszOldQuoLogPath);
    else
        Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;

FnExit:
    if (pResource) OmDereferenceObject( pResource );
    return(Status);

} // FmsCompleteQuorumResChange



error_status_t
s_FmsQuoNodeOnlineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NodeId,
    OUT LPDWORD State
    )

/*++

Routine Description:

    Receives a RmResourceOnline request from (THE) remote system and returns
    status for that request.

    This system must own the quorum resource.

    This is the first half of the sling shot. We acquire locks
    and then RPC back to the originating node with a request to perform
    the online.

    This request is only valid for non-quorum resources.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring online.

    NodeId - The Id of the Node that originated the request.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/
{
    //not used
    return(ERROR_INVALID_FUNCTION);        
}
 // FmsQuoNodeOnlineResource



error_status_t
s_FmsQuoNodeOfflineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NodeId,
    OUT LPDWORD State
    )

/*++

Routine Description:

    Receives a Resource Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring offline.

    NodeId - The Id of the Node that originated the request.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/
{
    //not used
    return(ERROR_INVALID_FUNCTION);
}// FmsQuoNodeOfflineResource



error_status_t
s_FmsRmOnlineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Receives a RmResourceOnline request from quorum node and returns
    status for that request.

    This system was the originator of the original online request.

    This is the second half of the sling shot. It just does the online
    request.

    This request is only valid for non-quorum resources.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring online.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    We can't acquire any locks... but the originating thread has the
    lock held for us.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] s_FmsRmOnlineResource: To bring resource '%1!ws!' online\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRmOnlineResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // This must not be done on the quorum resource, and the local system
    // must not own the quorum resource. We'll assume that the quorum
    // resource migrated while we were performng this request.
    //
    CL_ASSERT( gpQuoResource != NULL );
    CL_ASSERT( gpQuoResource->Group != NULL );
    CL_ASSERT( gpQuoResource->Group->OwnerNode != NULL );

    if ( resource->QuorumResource ||
         (gpQuoResource->Group->OwnerNode == NmLocalNode) ) {
        OmDereferenceObject( resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    //
    // The local node must own the resource.
    //
    CL_ASSERT( resource->Group != NULL );
    CL_ASSERT( resource->Group->OwnerNode != NULL );
    if ( resource->Group->OwnerNode != NmLocalNode ) {
        OmDereferenceObject( resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Just call the function that does the work.
    //
    OmNotifyCb( resource, NOTIFY_RESOURCE_PREONLINE );

    status = RmOnlineResource( resource->Id, pdwState );
    //call the synchronous notifications on the resource
    FmpCallResourceNotifyCb(resource, *pdwState);

    OmDereferenceObject( resource );

    return(status);

} // FmsRmOnlineResource



error_status_t
s_FmsRmOfflineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Receives a Resource Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring offline.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    We can't acquire any locks... but the originating thread has the
    lock held for us.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] s_FmsRmOfflineResource: To take resource '%1!ws!' offline\n",
              ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRmOfflineResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // This must not be done on the quorum resource, and the local system
    // must not own the quorum resource. We'll assume that the quorum
    // resource migrated while we were performng this request.
    //
    CL_ASSERT( gpQuoResource != NULL );
    CL_ASSERT( gpQuoResource->Group != NULL );
    CL_ASSERT( gpQuoResource->Group->OwnerNode != NULL );

    if ( resource->QuorumResource ||
         (gpQuoResource->Group->OwnerNode == NmLocalNode) ) {
        OmDereferenceObject( resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    //
    // The local node must own the resource.
    //
    CL_ASSERT( resource->Group != NULL );
    CL_ASSERT( resource->Group->OwnerNode != NULL );
    if ( resource->Group->OwnerNode != NmLocalNode ) {
        OmDereferenceObject( resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Just call the function that does the work.
    //
    OmNotifyCb( resource, NOTIFY_RESOURCE_PREOFFLINE );

    status = RmOfflineResource( resource->Id, pdwState );

    //call the post offline obj synchronous notifications
    FmpCallResourceNotifyCb(resource, *pdwState);

    OmDereferenceObject( resource );

    return(status);

} // FmsRmOfflineResource

error_status_t
s_FmsBackupClusterDatabase(
    IN handle_t IDL_handle,
    IN LPCWSTR  ResourceId,
    IN LPCWSTR  lpszPathName
    )

/*++

Routine Description:

    Receives a request to backup the quorum log file and the checkpoint
    file

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the quorum resource
    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    DWORD           Status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] s_FmsBackupClusterDatabase: Entry...\r\n");

    //
    //  Chittur Subbaraman (chitturs) - 10/12/1998
    //
    //  Find the specified quorum resource
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( pResource == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsBackupClusterDatabase: Could not find Resource %1!ws!\n",
                  ResourceId);
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    FmpAcquireLocalResourceLock( pResource );

    CL_ASSERT( pResource->Group != NULL );

    //
    //  Make sure the local node owns the quorum resource
    //
    if ( pResource->Group->OwnerNode == NmLocalNode )
    {
        Status = FmpBackupClusterDatabase( pResource, lpszPathName );
    }
    else
    {
        Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsBackupClusterDatabase: This node is not the quorum resource owner...\n"
                  );
    }
    
    FmpReleaseLocalResourceLock( pResource );

FnExit:
    if ( pResource ) OmDereferenceObject( pResource );
    return( Status );
} // FmsBackupClusterDatabase

error_status_t
s_FmsChangeResourceGroup(
    IN handle_t IDL_handle,
    IN LPCWSTR pszResourceId,
    IN LPCWSTR pszGroupId
    )

/*++

Routine Description:

    Receives a Resource change group request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    pszResourceId - The Id of the Resource to change a resource
    pszGroupId - The Id of the Group to change to.
    
Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    PFM_GROUP       pNewGroup = NULL;
    DWORD           dwStatus;
    PFM_GROUP       pOldGroup;

    FmpMustBeOnline( );

    //
    // Find the specified resource.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, pszResourceId );

    if ( pResource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsChangeResourceNode: Could not find Resource %1!ws!\n",
                  pszResourceId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    //
    // Find the specified group.
    //
    pNewGroup = OmReferenceObjectById( ObjectTypeGroup, pszGroupId );

    if ( pNewGroup == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsChangeResourceGroupe: Could not find NewGroup %1!ws!\n",
                  pszGroupId);
        dwStatus = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
       "[FM] s_FmChangeResourceGroup : Resource <%1!ws!> NewGroup %2!ws!\n",
       OmObjectId( pResource ),
       OmObjectId( pNewGroup ));

    //
    // Synchronize both the old and the new groups.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // strictly, the comparison below cannot be equal!
    //
    if ( lstrcmpiW( OmObjectId( pResource->Group ), OmObjectId( pNewGroup ) ) <= 0 ) {
        FmpAcquireLocalGroupLock( pResource->Group );
        FmpAcquireLocalGroupLock( pNewGroup );
    } else {
        FmpAcquireLocalGroupLock( pNewGroup );
        FmpAcquireLocalGroupLock( pResource->Group );
    }

    //remember the old group for freeing locks
    pOldGroup = pResource->Group;

    //boy if we are not the owner any more
    //shunt the request to the new owner
    if ( pResource->Group->OwnerNode != NmLocalNode ) 
    {
        // Note: FmcChangeResourceNode must release the resource lock.
        dwStatus = FmcChangeResourceGroup( pResource, pNewGroup );
        goto FnExit;
    } 
    else 
    {
        dwStatus = FmpChangeResourceGroup( pResource, pNewGroup );
    }

    FmpReleaseLocalGroupLock( pNewGroup );
    FmpReleaseLocalGroupLock( pOldGroup );
    
FnExit:
    if ( pResource ) OmDereferenceObject( pResource );
    if ( pNewGroup ) OmDereferenceObject( pNewGroup );
    ClRtlLogPrint(LOG_NOISE,
       "[FM] s_FmsChangeResourceGroup : returned <%1!u!>\r\n",
       dwStatus);
    return( dwStatus );
} //s_FmsChangeResourceGroup



error_status_t
s_FmsDeleteGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR pszGroupId
    )

/*++

Routine Description:

    Receives a delete group request from a remote system and returns
    the status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    pszGroupId - The Id of the group to be deleted.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP    pGroup = NULL;
    DWORD        dwStatus = ERROR_SUCCESS;

    FmpMustBeOnline( );

    //
    // Find the specified group.
    //
    pGroup = OmReferenceObjectById( ObjectTypeGroup, pszGroupId );

    if ( pGroup == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsDeleteGroupRequest: Could not find group %1!ws!\n",
                  pszGroupId);
        dwStatus = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    FmpAcquireLocalGroupLock( pGroup );

    if ( pGroup->OwnerNode == NmLocalNode )
    {
        dwStatus = FmpDeleteGroup( pGroup );
    }
    else
    {
        //
        // FmcDeleteGroup releases the group lock
        //
        dwStatus = FmcDeleteGroupRequest( pGroup );
        goto FnExit;
    }

    FmpReleaseLocalGroupLock( pGroup );
    
FnExit:
    if ( pGroup ) OmDereferenceObject( pGroup );
    return( dwStatus );
} //s_FmsChangeResourceGroup


error_status_t
s_FmsAddResourceDependency(
    IN handle_t IDL_handle,
    IN LPCWSTR pszResourceId,
    IN LPCWSTR pszDependsOnId
    )

/*++

Routine Description:

    Receives an add resource dependency request from a remote system 
    and returns the status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    
    pszResourceId - The Id of the resource to add a dependent resource.

    pszDependentResourceId - The Id of the dependent resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    PFM_RESOURCE    pDependentResource = NULL;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwResourceLen;
    DWORD           dwDependsOnLen;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Handle add resource dependency RPC calls from non-owner nodes
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsAddResourceDependency: Resource <%1!ws!>, Dependent Resource <%2!ws!>\n",
                  pszResourceId,
                  pszDependsOnId);

    //
    // Find the specified resources.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, pszResourceId );

    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsAddResourceDependency: Could not find resource <%1!ws!>\n",
                  pszResourceId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    pDependentResource = OmReferenceObjectById( ObjectTypeResource, 
                                                pszDependsOnId );

    if ( pDependentResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsAddResourceDependency: Could not find dependent resource <%1!ws!>\n",
                  pszDependsOnId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }
    //    
    // Acquire the resource lock 
    //
    FmpAcquireLocalResourceLock( pResource );

    if ( pResource->Group->OwnerNode != NmLocalNode )
    {
        dwStatus = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnUnlock;
    }

    dwStatus = FmpValAddResourceDependency( pResource, pDependentResource );

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnUnlock;
    }

    dwResourceLen = ( lstrlenW( pszResourceId ) + 1 ) * sizeof( WCHAR );

    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );

    
    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateAddDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      FALSE );
    }

FnUnlock:
    FmpReleaseLocalResourceLock( pResource );


FnExit:
    if ( pResource ) OmDereferenceObject( pResource );

    if ( pDependentResource ) OmDereferenceObject( pDependentResource );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsAddResourceDependency Exit: Status = %1!u!\n",
                  dwStatus);

    return( dwStatus );
} // s_FmsAddResourceDependency

error_status_t
s_FmsRemoveResourceDependency(
    IN handle_t IDL_handle,
    IN LPCWSTR pszResourceId,
    IN LPCWSTR pszDependsOnId
    )

/*++

Routine Description:

    Receives a remove resource dependency request from a remote system 
    and returns the status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    
    pszResourceId - The Id of the resource to remove a dependent resource from.

    pszDependentResourceId - The Id of the dependent resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    PFM_RESOURCE    pDependentResource = NULL;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwResourceLen;
    DWORD           dwDependsOnLen;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Handle remove resource dependency RPC calls from non-owner nodes
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: Resource <%1!ws!>, Dependent Resource <%2!ws!>\n",
                  pszResourceId,
                  pszDependsOnId);

    //
    // Find the specified resources.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, pszResourceId );

    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: Could not find resource <%1!ws!>\n",
                  pszResourceId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    pDependentResource = OmReferenceObjectById( ObjectTypeResource, 
                                                pszDependsOnId );

    if ( pDependentResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: Could not find dependent resource <%1!ws!>\n",
                  pszDependsOnId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }
    //    
    // Acquire the resource lock 
    //
    FmpAcquireLocalResourceLock( pResource );

    dwStatus = FmpValRemoveResourceDependency( pResource, pDependentResource );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: FmpValRemoveResourceDependency returns %1!u!\n",
                  dwStatus);
        goto FnUnlock;
    }

    if ( pResource->Group->OwnerNode != NmLocalNode )
    {
        dwStatus = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnUnlock;
    }

    pszResourceId = OmObjectId( pResource );
    dwResourceLen = ( lstrlenW( pszResourceId ) + 1 ) * sizeof( WCHAR );

    pszDependsOnId = OmObjectId( pDependentResource );
    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );


    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateRemoveDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      TRUE );
    }
    
FnUnlock:
    FmpReleaseLocalResourceLock( pResource );

FnExit:
    if ( pResource ) OmDereferenceObject( pResource );

    if ( pDependentResource ) OmDereferenceObject( pDependentResource );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsRemoveResourceDependency Exit: Status = %1!u!\n",
                  dwStatus);

    return( dwStatus );
} // s_FmsRemoveResourceDependency

error_status_t
s_FmsCreateResource2(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    Receives a Create Resource Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to create the resource inside.
    ResourceId - The Id of the Resource to create.
    ResourceName - The name of the Resource to create.
    ResourceType - The name of the Resource Type.
    dwFlags - Flags for the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    The Resource lock is acquired to synchronize access to the resource. This
    satisfies locking the resource on all nodes in the cluster... so long
    as the local node is the owner of the resource.

--*/

{
    PFM_GROUP group;
    DWORD status;
    PGUM_CREATE_RESOURCE gumResource;
    DWORD groupIdLen;
    DWORD resourceIdLen;
    DWORD resourceNameLen;
    DWORD resourceTypeLen;
    DWORD bufSize;
    HDMKEY resourceKey;
    HDMKEY paramsKey;
    DWORD  disposition;

    FmpMustBeOnline();

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsCreateResource2: To create resource '%1!ws!'\n",
               ResourceId);

    //
    // Find the specified group.
    //
    group = OmReferenceObjectById( ObjectTypeGroup,
                                   GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsCreateResource2: Could not find Group %1!ws!\n",
                  GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    FmpAcquireLocalGroupLock( group );

    //
    // Now delete it on all nodes in the cluster if we are the owner.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Allocate a message buffer.
        //
        groupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
        resourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
        resourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
        resourceTypeLen = (lstrlenW(ResourceType)+1) * sizeof(WCHAR);
        bufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
                  groupIdLen + resourceIdLen + resourceNameLen + resourceTypeLen + 2 * sizeof( DWORD );
        gumResource = LocalAlloc(LMEM_FIXED, bufSize);
        if (gumResource == NULL) {
            CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Fill in message buffer.
        //
        gumResource->Resource = NULL;
        gumResource->GroupIdLen = groupIdLen;
        gumResource->ResourceIdLen = resourceIdLen;
        CopyMemory(gumResource->GroupId, GroupId, groupIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen,
                   ResourceId,
                   resourceIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen,
                   ResourceName,
                   resourceNameLen);

        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen + resourceNameLen,
                   &resourceTypeLen,
                   sizeof( DWORD ) );

        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen + resourceNameLen + sizeof( DWORD ),
                   ResourceType,
                   resourceTypeLen );

        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen + resourceNameLen + sizeof( DWORD ) + resourceTypeLen,
                   &dwFlags,
                   sizeof( DWORD ) );
        //
        // Send message.
        //
        status = GumSendUpdate(GumUpdateFailoverManager,
                               FmUpdateCreateResource,
                               bufSize,
                               gumResource);
        if ( ( status == ERROR_SUCCESS ) && 
             ( gumResource->Resource != NULL ) )
            FmpCleanupPossibleNodeList(gumResource->Resource); 
        if( ( gumResource->Resource == NULL ) && FmpShutdown ) {
            status = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
        }
        LocalFree(gumResource);
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalGroupLock( group );

    return(status);

} // FmsCreateResource2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\reslist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reslist.c

Abstract:

    Cluster resource list processing routines.

Author:

    Rod Gamache (rodga) 21-Apr-1997


Revision History:


--*/

#include "fmp.h"


//
// Global data
//

//
// Local function prototypes
//
DWORD
FmpAddResourceEntry(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource
    );



DWORD
FmpGetResourceList(
    OUT PRESOURCE_ENUM *ReturnEnum,
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Enumerates all the list of all resources in the Group and returns their
    state.

Arguments:

    ReturnEnum - Returns the requested objects.

    Resource - Supplies the resource to filter. (i.e. if you supply this, you
                get a list of resources within that Resource)

                If not present, all resources are returned.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

Notes:

    This routine should be called with the LocalGroupLock held.

--*/

{
    DWORD status;
    PRESOURCE_ENUM resourceEnum = NULL;
    DWORD          allocated;
    PFM_RESOURCE   resource;
    PLIST_ENTRY    listEntry;

    allocated = ENUM_GROW_SIZE;

    resourceEnum = LocalAlloc(LMEM_FIXED, RESOURCE_SIZE(ENUM_GROW_SIZE));
    if ( resourceEnum == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEnum, RESOURCE_SIZE(ENUM_GROW_SIZE) );
    //set the contains quorum to -1, if the quorum  is present
    // in this group then the containsquorum is set to the index
    // of the quorum resource
    // The quorum resource should be brought offline last and be
    // brought online first so that the registry replication data
    // can be flushed
    resourceEnum->ContainsQuorum = -1;
    //resourceEnum->EntryCount = 0;

    //
    // Enumerate all resources in the group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {
        resource = CONTAINING_RECORD( listEntry,
                                      FM_RESOURCE,
                                      ContainsLinkage );
        status = FmpAddResourceEntry( &resourceEnum,
                                      &allocated,
                                      resource );
        if ( status != ERROR_SUCCESS ) {
            FmpDeleteResourceEnum( resourceEnum );
            goto error_exit;
        }
        //check if the resource is a quorum resource
        if (resource->QuorumResource)
            resourceEnum->ContainsQuorum = resourceEnum->EntryCount - 1;            
        resourceEnum->Entry[resourceEnum->EntryCount-1].State = resource->PersistentState;
    }

    *ReturnEnum = resourceEnum;
    return(ERROR_SUCCESS);

error_exit:

    *ReturnEnum = NULL;
    return(status);

} // FmpGetResourceList



DWORD
FmpOnlineResourceList(
    IN PRESOURCE_ENUM  ResourceEnum,
    IN PFM_GROUP       pGroup
    )

/*++

Routine Description:

    Brings online all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to bring online.

    pGroup - the group with which the resources are associated.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD returnStatus = ERROR_SUCCESS;
    DWORD i;


    //
    // If the cluster service is shutting and this is not the quorum group,
    // then fail immediately. Otherwise, try to bring the quorum online first.
    //
    if ( FmpShutdown &&
         ResourceEnum->ContainsQuorum == -1 ) {
        return(ERROR_INVALID_STATE);
    }

    // if the quorum resource is contained in here, bring it online first
    if (ResourceEnum->ContainsQuorum >= 0)
    {
        CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);
        
        resource = OmReferenceObjectById( ObjectTypeResource,
                        ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );


        // the resource should not vanish, we are holding the group lock after all
        CL_ASSERT(resource != NULL);
        //
        // If we fail to find a resource, then just continue
        //
        if ( resource != NULL ) {

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceList: Previous quorum resource state for %1!ws! is %2!u!\r\n",
                       OmObjectId(resource), ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State);

            if ( (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceOnline) ||
                 (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceFailed) ) {
                //
                // Now bring the resource online if that is it's current state.
                //
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOnlineResourceList: trying to bring quorum resource %1!ws! online, state %2!u!\n",
                           OmObjectId(resource),
                           resource->State);

                status = FmpOnlineResource( resource, FALSE );
                if ( status != ERROR_SUCCESS ) {
                    returnStatus = status;
                }
            }
            OmDereferenceObject( resource );
        }            
    }

    // SS::: TODO what happens to the persistent state of the
    // other resources - is it handled correctly - note that this is 
    // called on moving a group
    // Will the restart policy do the right thing in terms of bringing
    // them online
    // if the quorum resource has failed, dont bother trying
    // to bring the rest of the resourcess online
    if ((returnStatus != ERROR_SUCCESS) && (returnStatus != ERROR_IO_PENDING))
    {
        FmpSubmitRetryOnline(ResourceEnum);
        goto FnExit;
    }

    // bring online all of the other resources
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );


        //
        // If we fail to find a resource, then just continue.
        //
        if ( resource == NULL ) {
            status = ERROR_RESOURCE_NOT_FOUND;
            continue;
        }

        //quorum resource has already been handled 
        if (resource->QuorumResource)
        {
            OmDereferenceObject(resource);
            continue;
        }           
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOnlineResourceList: Previous resource state for %1!ws! is %2!u!\r\n",
                   OmObjectId(resource), ResourceEnum->Entry[i].State);

        if ( (ResourceEnum->Entry[i].State == ClusterResourceOnline) ||
             (ResourceEnum->Entry[i].State == ClusterResourceFailed) ) {
            //
            // Now bring the resource online if that is it's current state.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceList: trying to bring resource %1!ws! online\n",
                       OmObjectId(resource));

            status = FmpOnlineResource( resource, FALSE );
            if ( returnStatus == ERROR_SUCCESS ) {
                returnStatus = status;
            }
            //if this resource didnt come online because the quorum resource                
            //didnt come online, dont bother bringing the other resources online
            //just a waste of time
            if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
            {
                //submit a timer callback to try and bring these resources
                //online
                FmpSubmitRetryOnline(ResourceEnum);
                OmDereferenceObject( resource );
                break;
            }                

        }
        OmDereferenceObject( resource );
    }

FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineResourceList: Exit, status=%1!u!\r\n",
               returnStatus);
    return(returnStatus);

} // FmpOnlineResourceList




DWORD
FmpOfflineResourceList(
    IN PRESOURCE_ENUM ResourceEnum,
    IN BOOL Restore
    )

/*++

Routine Description:

    Takes offline all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to take offline.

    Restore - TRUE if we should set the resource back to it's previous state

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status=ERROR_SUCCESS;
    DWORD returnStatus = ERROR_SUCCESS;
    DWORD i;
    CLUSTER_RESOURCE_STATE prevState;

    // offline all resources except the quorum resource
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );

        if ( resource == NULL ) {
            return(ERROR_RESOURCE_NOT_FOUND);
        }

        //quorum resource is brought offline last
        if (resource->QuorumResource)
        {
            OmDereferenceObject(resource);
            continue;
        }
        //
        // Now take the Resource offline, if we own it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            prevState = resource->State;
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResourceList: Bring non quorum resource offline\n");

            status = FmpOfflineResource( resource, FALSE );
            if ( Restore ) {
                //FmpPropagateResourceState( resource, prevState );
                //resource->State = prevState;
            }
        }

        OmDereferenceObject( resource );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
            return(status);
        }
        if ( status == ERROR_IO_PENDING ) {
            returnStatus = ERROR_IO_PENDING;
        }

    }

    // bring the quorum resource offline now
    // This allows other resources to come offline and save their checkpoints
    // The quorum resource offline should block till the resources have
    // finished saving the checkpoint
    if ((ResourceEnum->ContainsQuorum >= 0) && (returnStatus == ERROR_SUCCESS))
    {
        CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);

        resource = OmReferenceObjectById( ObjectTypeResource,
                ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );

        if ( resource == NULL ) {
            return(ERROR_RESOURCE_NOT_FOUND);
        }

        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpOfflineResourceList: Bring quorum resource offline\n");

        //
        // Now take the Resource offline, if we own it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            status = FmpOfflineResource( resource, FALSE );
        }

        OmDereferenceObject( resource );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
            return(status);
        }
        if ( status == ERROR_IO_PENDING ) {
            returnStatus = ERROR_IO_PENDING;
        }
    }
    
    return(returnStatus);

} // FmpOfflineResourceList



DWORD
FmpTerminateResourceList(
    PRESOURCE_ENUM ResourceEnum
    )

/*++

Routine Description:

    Terminates all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to take offline.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD i;

    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );

        if ( resource == NULL ) {
            return(ERROR_RESOURCE_NOT_FOUND);
        }

        //
        // Now take the Resource offline, if we own it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            FmpTerminateResource( resource );
        }

        OmDereferenceObject( resource );
    }
    //for now we dont care about the return
    return(ERROR_SUCCESS);
    
} // FmpTerminateResourceList



DWORD
FmpAddResourceEntry(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Worker routine for the enumeration of Resources.
    This routine adds the specified Resource to the list that is being
    generated.

Arguments:

    Enum - The Resource Enumeration list. Can be an output if a new list is
            allocated.
    Allocated - The number of entries allocated.
    Resource - The Resource object being enumerated.

Returns:

    ERROR_SUCCESS - if successful.
    A Win32 error code on failure.

--*/

{
    PRESOURCE_ENUM resourceEnum;
    PRESOURCE_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;

    resourceEnum = *Enum;

    if ( resourceEnum->EntryCount >= *Allocated ) {
        //
        // Time to grow the RESOURCE_ENUM
        //

        newAllocated = *Allocated + ENUM_GROW_SIZE;
        newEnum = LocalAlloc(LMEM_FIXED, RESOURCE_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        CopyMemory(newEnum, resourceEnum, RESOURCE_SIZE(*Allocated));
        *Allocated = newAllocated;
        *Enum = newEnum;
        LocalFree(resourceEnum);
        resourceEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = LocalAlloc(LMEM_FIXED, (lstrlenW(OmObjectId(Resource))+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyW(newId, OmObjectId(Resource));
    resourceEnum->Entry[resourceEnum->EntryCount].Id = newId;
    ++resourceEnum->EntryCount;

    return(ERROR_SUCCESS);

} // FmpAddResourceEntry



VOID
FmpDeleteResourceEnum(
    IN PRESOURCE_ENUM Enum
    )

/*++

Routine Description:

    This routine deletes an RESOURCE_ENUM and associated name strings.

Arguments:

    Enum - The RESOURCE_ENUM to delete. This pointer can be NULL.

Returns:

    None.

Notes:

    This routine will take a NULL input pointer and just return.

--*/

{
    PRESOURCE_ENUM_ENTRY enumEntry;
    DWORD i;

    if ( Enum == NULL ) {
        return;
    }

    for ( i = 0; i < Enum->EntryCount; i++ ) {
        enumEntry = &Enum->Entry[i];
        LocalFree(enumEntry->Id);
    }

    LocalFree(Enum);
    return;

} // FmpDeleteResourceEnum


DWORD FmpSubmitRetryOnline(
    IN PRESOURCE_ENUM   pResourceEnum)
{

    PFM_RESLIST_ONLINE_RETRY_INFO   pFmOnlineRetryInfo;
    PRESOURCE_ENUM_ENTRY            enumEntry;
    DWORD                           dwSizeofResourceEnum;
    DWORD                           dwStatus = ERROR_SUCCESS;
    DWORD                           i;
    DWORD                           dwSize;
    
    //there is nothing to do
    if (pResourceEnum->EntryCount < 1)
        goto FnExit;
        
    dwSizeofResourceEnum = sizeof(RESOURCE_ENUM) - sizeof(RESOURCE_ENUM_ENTRY) + 
        (sizeof(RESOURCE_ENUM_ENTRY) * pResourceEnum->EntryCount);
    pFmOnlineRetryInfo = LocalAlloc(LMEM_FIXED, 
        (sizeof(FM_RESLIST_ONLINE_RETRY_INFO) - sizeof(RESOURCE_ENUM) + 
            dwSizeofResourceEnum));

    if (!pFmOnlineRetryInfo)
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(dwStatus);
        goto FnExit;
    }

    //SS: unused for now
    //reference the group object
    pFmOnlineRetryInfo->pGroup = NULL;        
    memcpy(&(pFmOnlineRetryInfo->ResourceEnum), pResourceEnum, dwSizeofResourceEnum);

    // allocate memory for Resource ID's and copy them from pResourceEnum
    for ( i = 0; i < pResourceEnum->EntryCount; i++ ) {
        enumEntry = &pResourceEnum->Entry[i];
        pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id = NULL;
        dwSize = (lstrlenW(enumEntry->Id) +1)*sizeof(WCHAR);
        pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id = (LPWSTR)(LocalAlloc(LMEM_FIXED,dwSize));
        if (!pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id )
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            CL_UNEXPECTED_ERROR(dwStatus);
            goto FnExit;
        }
        CopyMemory(pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id, enumEntry->Id, dwSize);        
    }


    dwStatus = FmpQueueTimerActivity(FM_TIMER_RESLIST_ONLINE_RETRY, 
        FmpReslistOnlineRetryCb, pFmOnlineRetryInfo );
        
FnExit: 
    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\monitor.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    Monitor.c

Abstract:

    Routines for interfacing with the Resource Monitor process

Author:

    John Vert (jvert) 3-Jan-1996

Revision History:

--*/
#include "fmp.h"

//
// Global data
//

CRITICAL_SECTION    FmpMonitorLock;

//
// Local function prototypes
//
DWORD
FmpInitializeResourceMonitorNotify(
    VOID
    );

DWORD
FmpRmNotifyThread(
    IN LPVOID lpThreadParameter
    );


PRESMON
FmpCreateMonitor(
    LPWSTR DebugPrefix,
    BOOL   SeparateMonitor
    )

/*++

Routine Description:

    Creates a new monitor process and initiates the RPC communication
    with it.

Arguments:

    None.

Return Value:

    Pointer to the resource monitor structure if successful.

    NULL otherwise.

--*/

{
#define FM_MAX_RESMON_COMMAND_LINE_SIZE    128

    SECURITY_ATTRIBUTES Security;
    HANDLE WaitArray[2];
    HANDLE ThreadHandle;
    HANDLE Event = NULL;
    HANDLE FileMapping = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    PROCESS_INFORMATION DebugInfo;
    BOOL Success;
    WCHAR CommandBuffer[FM_MAX_RESMON_COMMAND_LINE_SIZE];
    PWCHAR resmonCmdLine = CommandBuffer;
    TCHAR DebugLine[512];
    TCHAR *Binding;
    RPC_BINDING_HANDLE RpcBinding;
    DWORD Status;
    PRESMON Monitor;
    DWORD ThreadId;
    DWORD Retry = 0;
    DWORD creationFlags;

    //
    //  Recover any DLL files left impartially upgraded.
    //
    FmpRecoverResourceDLLFiles ();

    Monitor = LocalAlloc(LMEM_ZEROINIT, sizeof(RESMON));
    if (Monitor == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Failed to allocate a Monitor structure.\n");
        return(NULL);
    }

    Monitor->Shutdown = FALSE;
    Monitor->Signature = FMP_RESMON_SIGNATURE;

    //
    // Create an event and a file mapping object to be passed to
    // the Resource Monitor process. The event is for the Resource
    // Monitor to signal its initialization is complete. The file
    // mapping is for creating the shared memory region between
    // the Resource Monitor and the cluster manager.
    //
    Security.nLength = sizeof(Security);
    Security.lpSecurityDescriptor = NULL;
    Security.bInheritHandle = TRUE;
    Event = CreateEvent(&Security,
                        TRUE,
                        FALSE,
                        NULL);
    if (Event == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Failed to create a ResMon event, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    Security.nLength = sizeof(Security);
    Security.lpSecurityDescriptor = NULL;
    Security.bInheritHandle = TRUE;
    FileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
                                    &Security,
                                    PAGE_READWRITE,
                                    0,
                                    sizeof(MONITOR_STATE),
                                    NULL);
    if (FileMapping == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] File Mapping for ResMon failed, error = %1!u!.\n",
                   Status);
        goto create_failed;
    }

    //
    // Create our own (read-only) view of the shared memory section
    //
    Monitor->SharedState = MapViewOfFile(FileMapping,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         0);
    if (Monitor->SharedState == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Mapping shared state for ResMon failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    ZeroMemory( Monitor->SharedState, sizeof(MONITOR_STATE) );
    if ( !CsDebugResmon && DebugPrefix != NULL && *DebugPrefix != UNICODE_NULL ) {
        Monitor->SharedState->ResmonStop = TRUE;
    }

    //
    // build cmd line for Resource Monitor process
    //
    wsprintf(resmonCmdLine,
             TEXT("resrcmon -e %d -m %d -p %d"),
             Event,
             FileMapping,
             GetCurrentProcessId() );
    if ( CsDebugResmon ) {
        wcscat( resmonCmdLine, L" -d" );

        if ( CsResmonDebugCmd ) {
            DWORD cmdLineSize = wcslen( resmonCmdLine );
            DWORD debugCmdSize = wcslen( CsResmonDebugCmd );

            //
            // make sure our static buffer is large enough; 4 includes the
            // space, 2 double quotes and. 5 adds in the terminating NULL.
            //
            if (( cmdLineSize + debugCmdSize ) > ( FM_MAX_RESMON_COMMAND_LINE_SIZE - 4 )) {
                resmonCmdLine = LocalAlloc(LMEM_FIXED,
                                           ( cmdLineSize + debugCmdSize + 5 ) * sizeof( WCHAR ));

                if ( resmonCmdLine != NULL ) {
                    wcscpy( resmonCmdLine, CommandBuffer );
                    wcscat( resmonCmdLine, L" \"" );
                    wcscat( resmonCmdLine, CsResmonDebugCmd );
                    wcscat( resmonCmdLine, L"\"" );
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] Unable to allocate space for debug command line\n");
                    resmonCmdLine = CommandBuffer;
                }
            } else {
                wcscat( resmonCmdLine, L" \"" );
                wcscat( resmonCmdLine, CsResmonDebugCmd );
                wcscat( resmonCmdLine, L"\"" );
            }
        }
    }

    //
    // Attempt to start ResMon process.
    //
retry_resmon_start:

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    creationFlags = DETACHED_PROCESS;           // so ctrl-c won't kill it

    Success = CreateProcess(NULL,
                            resmonCmdLine,
                            NULL,
                            NULL,
                            FALSE,                          // Inherit handles
                            creationFlags,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInfo);
    if (!Success) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Failed to create resmon process, error %1!u!.\n",
                   Status);
        CL_LOGFAILURE(Status);
        goto create_failed;
    } else if ( CsDebugResmon && !CsResmonDebugCmd ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Waiting for debugger to connect to resmon process %1!u!\n",
                   ProcessInfo.dwProcessId);
    }

    CloseHandle(ProcessInfo.hThread);           // don't need this

    //
    // Wait for the ResMon process to terminate, or for it to signal
    // its startup event.
    //
    WaitArray[0] = Event;
    WaitArray[1] = ProcessInfo.hProcess;
    Status = WaitForMultipleObjects(2,
                                    WaitArray,
                                    FALSE,
                                    INFINITE);
    if (Status == WAIT_FAILED) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Wait for ResMon to start failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    if (Status == ( WAIT_OBJECT_0 + 1 )) {
        if ( ++Retry > 1 ) {
           //
           // The resource monitor terminated prematurely.
           //
           GetExitCodeProcess(ProcessInfo.hProcess, &Status);
           ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] ResMon terminated prematurely, error %1!u!.\n",
                      Status);
            goto create_failed;
        } else {
            goto retry_resmon_start;
        }
    } else {
        //
        // The resource monitor has successfully initialized
        //
        CL_ASSERT(Status == 0);
        Monitor->Process = ProcessInfo.hProcess;

        //
        // invoke the DebugPrefix process only if we're not already debugging
        // the resmon process
        //
        if ( CsDebugResmon && DebugPrefix && *DebugPrefix != UNICODE_NULL ) {

            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] -debugresmon overrides DebugPrefix property\n");
        }

        if ( !CsDebugResmon && ( DebugPrefix != NULL ) && ( *DebugPrefix != UNICODE_NULL )) {

            wsprintf(DebugLine, TEXT("%ws -p %d"), DebugPrefix, ProcessInfo.dwProcessId);
            ZeroMemory(&StartupInfo, sizeof(StartupInfo));
            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.lpDesktop = TEXT("WinSta0\\Default");

            Success = CreateProcess(NULL,
                                    DebugLine,
                                    NULL,
                                    NULL,
                                    FALSE,                 // Inherit handles
                                    CREATE_NEW_CONSOLE,
                                    NULL,
                                    NULL,
                                    &StartupInfo,
                                    &DebugInfo);
            Monitor->SharedState->ResmonStop = FALSE;
            if ( !Success ) {
                Status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] ResMon debug start failed, error %1!u!.\n",
                            Status);
            } else {
                CloseHandle(DebugInfo.hThread);           // don't need this
                CloseHandle(DebugInfo.hProcess);          // don't need this
            }
        }
    }

    CloseHandle(Event);
    CloseHandle(FileMapping);
    Event = NULL;
    FileMapping = NULL;

    //
    // Initiate RPC with resource monitor process
    //
    wsprintf(resmonCmdLine, TEXT("resrcmon%d"), ProcessInfo.dwProcessId);
    Status = RpcStringBindingCompose(TEXT("e76ea56d-453f-11cf-bfec-08002be23f2f"),
                                     TEXT("ncalrpc"),
                                     NULL,
                                     resmonCmdLine,
                                     NULL,
                                     &Binding);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] ResMon RPC binding compose failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }
    Status = RpcBindingFromStringBinding(Binding, &Monitor->Binding);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] ResMon RPC binding creation failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }
    RpcStringFree(&Binding);

    //
    // Start notification thread.
    //
    Monitor->NotifyThread = CreateThread(NULL,
                                         0,
                                         FmpRmNotifyThread,
                                         Monitor,
                                         0,
                                         &ThreadId);

    if (Monitor->NotifyThread == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Creation of notify thread for ResMon failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    Monitor->RefCount = 2;

    if ( resmonCmdLine != CommandBuffer ) {
        LocalFree( resmonCmdLine );
    }

    return(Monitor);

create_failed:

    if ( Monitor->NotifyThread != NULL ) {
        CloseHandle( Monitor->NotifyThread );
    }
    LocalFree( Monitor );

    if ( FileMapping != NULL ) {
        CloseHandle( FileMapping );
    }

    if ( Event != NULL ) {
        CloseHandle( Event );
    }

    if ( resmonCmdLine != CommandBuffer ) {
        LocalFree( resmonCmdLine );
    }

    SetLastError(Status);

    return(NULL);

} // FmpCreateMonitor



VOID
FmpShutdownMonitor(
    IN PRESMON Monitor
    )

/*++

Routine Description:

    Performs a clean shutdown of the Resource Monitor process.
    Note that this does not make any changes to the state of
    any resources being monitored by the Resource Monitor, it
    only asks the Resource Monitor to clean up and terminate.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD Status;

    CL_ASSERT(Monitor != NULL);

    FmpAcquireMonitorLock();

    if ( Monitor->Shutdown ) {
        return;
    }

    Monitor->Shutdown = TRUE;

    FmpReleaseMonitorLock();

    //
    // RPC to the server process to tell it to shutdown.
    //
    RmShutdownProcess(Monitor->Binding);

    //
    // Wait for the process to exit so that the monitor fully cleans up the resources if necessary.
    //
    if ( Monitor->Process ) {
        Status = WaitForSingleObject(Monitor->Process, FM_MONITOR_SHUTDOWN_TIMEOUT);
        if ( Status != WAIT_OBJECT_0 ) {
            ClRtlLogPrint(LOG_ERROR,"[FM] Failed to shutdown resource monitor.\n");
            TerminateProcess( Monitor->Process, 1 );
        }
        CloseHandle(Monitor->Process);
        Monitor->Process = NULL;
    }

    RpcBindingFree(&Monitor->Binding);

    //
    // Wait for the notify thread to exit, but just a little bit.
    //
    if ( Monitor->NotifyThread ) {
        Status = WaitForSingleObject(Monitor->NotifyThread, 
                                     FM_RPC_TIMEOUT*2); // Increased timeout to try to ensure RPC completes
        if ( Status != WAIT_OBJECT_0 ) {
            ;                   // call removed: Terminate Thread( Monitor->NotifyThread, 1 );
                                // Bad call to make since terminating threads on NT can cause real problems.
        }
        CloseHandle(Monitor->NotifyThread);
        Monitor->NotifyThread = NULL;
    }
    //
    // Clean up shared memory mapping
    //
    UnmapViewOfFile(Monitor->SharedState);

    if ( InterlockedDecrement(&Monitor->RefCount) == 0 ) {
        PVOID caller, callersCaller;
        RtlGetCallersAddress(
                &caller,
                &callersCaller );
        ClRtlLogPrint(LOG_NOISE,
                   "[FMY] Freeing monitor structure (1) %1!lx!, caller %2!lx!, callerscaller %3!lx!\n",
                   Monitor, caller, callersCaller );
        LocalFree(Monitor);
    }

    return;

} // FmpShutdownMonitor



DWORD
FmpRmNotifyThread(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This is the thread that receives resource monitor notifications.

Arguments:

    lpThreadParameter - Pointer to resource monitor structure.

Return Value:

    None.

--*/

{
    PRESMON Monitor;
    PRESMON NewMonitor;
    RM_NOTIFY_KEY  NotifyKey;
    DWORD   NotifyEvent;
    DWORD   Status;
    CLUSTER_RESOURCE_STATE CurrentState;
    BOOL Success;

    Monitor = lpThreadParameter;

    //
    // Loop forever picking up resource monitor notifications.
    // When the resource monitor returns FALSE, it indicates
    // that shutdown is occurring.
    //
    do {
        try {
            Success = RmNotifyChanges(Monitor->Binding,
                                      &NotifyKey,
                                      &NotifyEvent,
                                      (LPDWORD)&CurrentState);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // RPC communications failure, treat it as a shutdown.
            //
            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] NotifyChanges got an RPC failure, %1!u!.\n",
                       Status);
            Success = FALSE;
        }

        if (Success) {
            Success = FmpPostNotification(NotifyKey, NotifyEvent, CurrentState);
        } else {
            //
            // If we are shutting down... then this is okay.
            //
            if ( FmpShutdown ||
                 Monitor->Shutdown ) {
                break;
            }

            //
            // We will try to start a new resource monitor. If this fails,
            // then shutdown the cluster service.
            //
            ClRtlLogPrint(LOG_ERROR,
                       "[FM] Resource monitor terminated!\n");

            ClRtlLogPrint(LOG_ERROR,
                       "[FM] Last resource monitor state: %1!u!, resource %2!u!.\n",
                       Monitor->SharedState->State,
                       Monitor->SharedState->ActiveResource);
                       
            CsLogEvent(LOG_UNUSUAL, FM_EVENT_RESMON_DIED);

            //
            // Use a worker thread to start new resource monitor(s).
            //
            if (FmpCreateMonitorRestartThread(Monitor))
                CsInconsistencyHalt(ERROR_INVALID_STATE);
        }

    } while ( Success );

    ClRtlLogPrint(LOG_NOISE,"[FM] RmNotifyChanges returned\n");

    if ( InterlockedDecrement( &Monitor->RefCount ) == 0 ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FMY] Freeing monitor structure (2) %1!lx!\n",
                   Monitor );
        LocalFree( Monitor );
    }

    return(0);

} // FmpRmNotifyThread



BOOL
FmpFindMonitorResource(
    IN PRESMON OldMonitor,
    IN PMONITOR_RESOURCE_ENUM *PtrEnumResource,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Finds all resources that were managed by the old resource monitor and
    starts them under the new resource monitor. Or adds them to the list
    of resources to be restarted.

Arguments:

    OldMonitor - pointer to the old resource monitor structure.

    PtrEnumResource - pointer to a pointer to a resource enum structure.

    Resource - the current resource being enumerated.

    Name - name of the current resource.

Return Value:

    TRUE - if we should continue enumeration.
    FALSE - otherwise.

Notes:

    Nothing in the old resource monitor structure should be used.

--*/

{
    DWORD   status;
    BOOL    returnNow = FALSE;
    PMONITOR_RESOURCE_ENUM enumResource = *PtrEnumResource;
    PMONITOR_RESOURCE_ENUM newEnumResource;
    DWORD   dwOldBlockingFlag;

    if ( Resource->Monitor == OldMonitor ) {
        if ( enumResource->fCreateMonitors == FALSE ) goto skip_monitor_creation;
        
        //
        // If this is not the quorum resource and it is blocking the
        // quorum resource, then fix it up now.
        //

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );
        if ( dwOldBlockingFlag ) {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] RestartMonitor: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                    OmObjectId(Resource));
            InterlockedDecrement(&gdwQuoBlockingResources);
        }

        //
        // If the resource had been previously create in Resmon, then recreate
        // it with a new resource monitor.
        //
        if ( Resource->Flags & RESOURCE_CREATED ) {
            // Note - this will create a new resource monitor as needed.
            status = FmpRmCreateResource(Resource);
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_ERROR,"[FM] Failed to restart resource %1!ws!. Error %2!u!.\n",
                Name, status );
                return(TRUE);
            }
        } else {
            return(TRUE);
        }
    } else {
        return(TRUE);
    }
    
skip_monitor_creation:
    //
    // If we successfully recreated a resource monitor, then add it to the
    // list of resources to indicate failure.
    //
    if ( enumResource->CurrentIndex >= enumResource->EntryCount ) {
        newEnumResource = LocalReAlloc( enumResource,
                            MONITOR_RESOURCE_SIZE( enumResource->EntryCount +
                                                   ENUM_GROW_SIZE ),
                            LMEM_MOVEABLE );
        if ( newEnumResource == NULL ) {
            ClRtlLogPrint(LOG_ERROR,
                "[FM] Failed re-allocating resource enum to restart resource monitor!\n");
            return(FALSE);
        }
        enumResource = newEnumResource;
        enumResource->EntryCount += ENUM_GROW_SIZE;
        *PtrEnumResource = newEnumResource;
    }

    enumResource->Entry[enumResource->CurrentIndex] = Resource;
    ++enumResource->CurrentIndex;

    return(TRUE);

} // FmpFindMonitorResource



BOOL
FmpRestartMonitor(
    PRESMON OldMonitor
    )

/*++

Routine Description:

    Creates a new monitor process and initiates the RPC communication
    with it. Restarts all resources that were attached to the old monitor
    process.

Arguments:

    OldMonitor - pointer to the old resource monitor structure.

Return Value:

    TRUE if successful.

    FALSE otherwise.

Notes:

    The old monitor structure is deallocated when done.

--*/

{
    DWORD   enumSize;
    DWORD   i;
    DWORD   status;
    PMONITOR_RESOURCE_ENUM enumResource;
    PFM_RESOURCE resource;
    DWORD   dwOldBlockingFlag;

    FmpAcquireMonitorLock();

    if ( FmpShutdown ) {
        FmpReleaseMonitorLock();
        return(TRUE);
    }

    enumSize = MONITOR_RESOURCE_SIZE( ENUM_GROW_SIZE );
    enumResource = LocalAlloc( LMEM_ZEROINIT, enumSize );
    if ( enumResource == NULL ) {
        ClRtlLogPrint(LOG_ERROR,
            "[FM] Failed allocating resource enum to restart resource monitor!\n");
        FmpReleaseMonitorLock();
        CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    enumResource->EntryCount = ENUM_GROW_SIZE;
    enumResource->CurrentIndex = 0;
    enumResource->fCreateMonitors = FALSE;

    //
    // Enumerate all resources controlled by the old resource monitor so that we can invoke the
    // handlers registered for those resources. Both preoffline and postoffline handlers are
    // invoked prior to monitor shutdown so that the assumption made about underlying resource 
    // access (such as quorum disk access) remain valid in a graceful monitor shutdown case. 
    // We would issue a specific shutdown command in the case of a graceful shutdown occurring 
    // as a part of resource DLL upgrade.
    //
    OmEnumObjects( ObjectTypeResource,
                   (OM_ENUM_OBJECT_ROUTINE)FmpFindMonitorResource,
                   OldMonitor,
                   &enumResource );

    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        if ( ( resource->PersistentState == ClusterResourceOnline ) &&
             ( resource->Group->OwnerNode == NmLocalNode ) ) {
            OmNotifyCb( resource, NOTIFY_RESOURCE_PREOFFLINE );
            OmNotifyCb( resource, NOTIFY_RESOURCE_POSTOFFLINE );
        }
    }

    FmpShutdownMonitor( OldMonitor );

    if ( FmpDefaultMonitor == OldMonitor ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
        if ( FmpDefaultMonitor == NULL ) {
            LocalFree( enumResource );
            FmpReleaseMonitorLock();
            CsInconsistencyHalt(GetLastError());
            return(FALSE);
        }
    }

    enumResource->CurrentIndex = 0;
    enumResource->fCreateMonitors = TRUE;

    //
    // Enumerate all resources controlled by the old resource monitor,
    // and connect them into the new resource monitor.
    //
    OmEnumObjects( ObjectTypeResource,
                   (OM_ENUM_OBJECT_ROUTINE)FmpFindMonitorResource,
                   OldMonitor,
                   &enumResource );

    //
    // First set each resource in the list to the Offline state.
    //
    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        //
        // If the resource is owned by the local system, then do it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            resource->State = ClusterResourceOffline;

            //
            // If this is not the quorum resource and it is blocking the
            // quorum resource, then fix it up now.
            //


            dwOldBlockingFlag = InterlockedExchange( &resource->BlockingQuorum, 0 );
            if ( dwOldBlockingFlag ) {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] RestartMonitor: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                        OmObjectId(resource));
                InterlockedDecrement(&gdwQuoBlockingResources);
            }
        }
    }

    //
    // Find the quorum resource - if present bring online first.
    //
    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        //
        // If the resource is owned by the local system and is the
        // quorum resource, then do it.
        //
        if ( (resource->Group->OwnerNode == NmLocalNode) &&
             resource->QuorumResource ) {
            FmpRestartResourceTree( resource );
        }
    }

    //
    // Now restart the rest of the resources in the list.
    //
    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        //
        // If the resource is owned by the local system, then do it.
        //
        if ( (resource->Group->OwnerNode == NmLocalNode) &&
             !resource->QuorumResource ) {
            FmpRestartResourceTree( resource );
        }
    }

    FmpReleaseMonitorLock();

    //
    // Don't delete the old monitor block until we've reset the resources
    // to point to the new resource monitor block.
    // Better to get an RPC failure, rather than some form of ACCVIO.
    //
    LocalFree( enumResource );
    
    if ( InterlockedDecrement( &OldMonitor->RefCount ) == 0 ) {
#if 0
        PVOID caller, callersCaller;
        RtlGetCallersAddress(
                &caller,
                &callersCaller );
        ClRtlLogPrint(LOG_NOISE,
                   "[FMY] Freeing monitor structure (3) %1!lx!, caller %2!lx!, callerscaller %3!lx!\n",
                   OldMonitor, caller, callersCaller );
#endif
        LocalFree( OldMonitor );
    }

    return(TRUE);

} // FmpRestartMonitor



/****
@func       DWORD | FmpCreateMonitorRestartThread| This creates a new
            thread to restart a monitor.  

@parm       IN PRESMON | pMonitor| Pointer to the resource monitor that n
            needs to be restarted.

@comm       A monitor needs to be started in a separate thread as it
            decrements the gquoblockingrescount for resources therein.  
            This cannot be done by fmpworkerthread because that causes 
            deadlocks if other items, like failure handling, being 
            processed by the fmpworkerthread are waiting for work that 
            will done by the items, like restart monitor, still in queue.
            
@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/
DWORD FmpCreateMonitorRestartThread(
    IN PRESMON pMonitor
)
{

    HANDLE                  hThread = NULL;
    DWORD                   dwThreadId;
    DWORD                   dwStatus = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateMonitorRestartThread: Entry\r\n");

    //reference the resource
    //the thread will dereference it
    InterlockedIncrement( &pMonitor->RefCount );

    hThread = CreateThread( NULL, 0, FmpRestartMonitor,
                pMonitor, 0, &dwThreadId );

    if ( hThread == NULL )
    {
        dwStatus = GetLastError();
        CL_UNEXPECTED_ERROR(dwStatus);
        goto FnExit;
    }

FnExit:
    //do general cleanup
    if (hThread)
        CloseHandle(hThread);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateMonitorRestartThread: Exit, status %1!u!\r\n",
        dwStatus);
        
    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\resfail.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    resfail.c

Abstract:

    Cluster resource state management routines.

Author:

    Mike Massa (mikemas) 14-Jan-1996


Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE RESFAIL

// globals

//
// Local Functions
//

DWORD
FmpHandleResStateChangeProc(
    IN LPVOID pContext
    );
    

VOID
FmpHandleResourceFailure(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Handles resource failure notifications from the resource monitor.

Arguments:

    Resource   - The resource which has failed.

Return Value:

    None.

Note:

    This routine is only called if the resource was online at the time of
    the failure.

--*/
{
    DWORD   dwStatus;
    BOOL    bRestartGroup = TRUE;
    DWORD   tickCount;
    DWORD   withinFailurePeriod;
    
    CsLogEvent1(LOG_CRITICAL,
        FM_RESOURCE_FAILURE,
        OmObjectName(pResource) );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpHandleResourceFailure: taking resource %1!ws! and dependents offline\n",
               OmObjectId(pResource));



    if ( pResource->State == ClusterResourceOnline ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resource %1!ws! failed, but still online!\n",
                   OmObjectId(pResource));
    }


    dwStatus = FmpTerminateResource(pResource);

    if (dwStatus != NO_ERROR) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpHandleResourceFailure: offline of resource %1!ws! failed\n",
                   OmObjectId(pResource));
    }

    //
    // If system shutdown has begun, then don't bother trying to restart anything.
    // We can see spurious failures during shutdown as the network goes away, but
    // we do not want to be restarting resources while FmShutdownGroups is trying
    // to take them offline!
    //
    if (FmpShutdown) 
    {
        return;
    }
    // SS: We handle the failure of the quorum resource specially
    // since other resources rely on it and may be blocked waiting
    // for the quorum resource to come online.

    ++ pResource->NumberOfFailures;
    switch ( pResource->RestartAction ) 
    {

    case RestartNot:
        // Don't do anything.
        // However, if this is a quorum resource cause it to halt
        if (pResource->QuorumResource)
        {
            //cleanup quorum resource and cause the node to halt
            if (pResource->RestartAction == RestartNot)
            {
                FmpCleanupQuorumResource(pResource);
                CsInconsistencyHalt(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            }            
        }
        
        break;


    case RestartLocal:
        // fall through is correct for this case
        bRestartGroup = FALSE;
    case RestartGroup:
        //
        // If the number of failures is too high, then don't restart locally.
        // If this was a local restart then don't notify FM so that Group
        // doesn't move because of this guy; otherwise notify the FM that the
        // group has failed.
        //
        //
        // Get our current time, in milliseconds.
        //
        tickCount = GetTickCount();

        //
        // Compute a boolean that tells if we are withing the allotted
        // failure period.
        //
        withinFailurePeriod = ( ((tickCount - pResource->FailureTime) <=
                                pResource->RestartPeriod) ? TRUE : FALSE);

        //
        // If it's been a long time since our last failure, then
        // get the current time of this failure, and reset the count
        // of failures.
        //
        if ( !withinFailurePeriod ) {
            pResource->FailureTime = tickCount;
            pResource->NumberOfFailures = 1;
        }
        if ( pResource->NumberOfFailures <= pResource->RestartThreshold ) 
        {
            FmpRestartResourceTree( pResource );
        } 

        else if ( bRestartGroup ) 
        {
            ClusterEvent( CLUSTER_EVENT_GROUP_FAILED, pResource->Group );
        } 
        else 
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] RestartLocal: resource %1!ws! has exceeded its restart limit!\n",
                       OmObjectId(pResource));
            if (pResource->QuorumResource)
            {
                FmpCleanupQuorumResource(pResource);
                CsInconsistencyHalt(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            }
            // Start a timer for which will attempt to restart the resource later
            FmpDelayedStartRes(pResource);
        }
        
        break;

    default:
        ClRtlLogPrint(LOG_NOISE,"[FM] FmpHandleResourceFailure: unknown restart action! Value = %1!u!\n",
            pResource->RestartAction);

    }

    return;

} // FmpHandleResourceFailure



VOID
FmpHandleResourceTransition(
    IN PFM_RESOURCE   Resource,
    IN CLUSTER_RESOURCE_STATE NewState
    )
/*++

Routine Description:

    Takes appropriate action based on resource state transitions indicated
    by the Resource Monitor.

Arguments:

    Resource   - The resource which has transitioned.

    NewState   - The new state of Resource.

Return Value:

    None.

--*/

{
    DWORD       status;
    DWORD       dwOldBlockingFlag;

ChkFMState:    
    ACQUIRE_SHARED_LOCK(gQuoChangeLock);
    if (!FmpFMGroupsInited)
    {
        DWORD   dwRetryCount = 50;
        

        //FmFormNewClusterPhaseProcessing is in progress
        if (FmpFMFormPhaseProcessing)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpHandleResourceTransition: resource notification from quorum resource "
                "during phase processing. Sleep and retry\n");
            RELEASE_LOCK(gQuoChangeLock);
            Sleep(500);
            if (dwRetryCount--)
                goto ChkFMState;
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpHandleResourceTransition: waited for too long\n");
                //terminate the process                    
                CL_ASSERT(FALSE);
                CsInconsistencyHalt(ERROR_CLUSTER_NODE_DOWN);
            }
        }
        //this can only come from the quorum resource
        CL_ASSERT(Resource->QuorumResource);
    }

    // if this is from the quorum resource, we need to do some special handling
    // protect the check for quorum resource by acquiring the shared lock

    if (Resource->QuorumResource) 
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/25/99
        //
        //  Handle the sync notifications for the quorum resource. This is
        //  done here instead of in FmpRmDoInterlockedDecrement since we
        //  need to hold the gQuoChangeLock for this to synchronize with
        //  other threads such as the FmCheckQuorumState called by the DM
        //  node down handler. Note that FmpRmDoInterLockedDecrement needs
        //  to be done with NO LOCKS held since it easily runs into deadlock
        //  situations in which the quorum resource offline is waiting to
        //  have the blocking resources count go to 0 and FmpRmDoInterLockedDecrement
        //  which alone can make this count to 0 could be stuck waiting for
        //  the lock.
        //
        DWORD dwBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );

        CL_ASSERT( dwBlockingFlag == FALSE );

        FmpCallResourceNotifyCb( Resource, NewState );
        
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
        
    } 
    else 
    {
        FmpAcquireLocalResourceLock(Resource);
    }


    ClRtlLogPrint(
        NewState == ClusterResourceFailed ? LOG_UNUSUAL : LOG_NOISE,
        "[FM] HandleResourceTransition: Resource Name = %1!ws! old state=%2!u! new state=%3!u!\r\n",
        OmObjectId(Resource),
        Resource->State,
        NewState
        );

    if ( Resource->State == NewState ) 
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] HandleResourceTransition: Resource %1!ws! already in state=%2!u!\r\n",
            OmObjectId(Resource),
            NewState );
        goto FnExit;
    }

    switch (Resource->State) {

    case ClusterResourceOnline:
        // if there is a resource failure, then let the worker thread handle it
        // if there is a state change call the resource state change handler
        if (Resource->State != NewState)
            FmpPropagateResourceState( Resource, NewState );
        if (NewState == ClusterResourceFailed) 
        {
            if (Resource->QuorumResource)
            {
                RELEASE_LOCK(gQuoLock);

                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnline);
                ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
                                            
            }                                        
            else
            {
                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnline);
            }
        } 
        else 
        {
            CL_ASSERT( (NewState == ClusterResourceOnline) ||
                       (NewState == ClusterResourceOffline) );
        }
        break;


    case ClusterResourceFailed:
        if (Resource->State != NewState)
            FmpPropagateResourceState( Resource, NewState );
        break;

    case ClusterResourceOfflinePending:
        //SS: a resource cannot go from one pending state to another
        CL_ASSERT( NewState < ClusterResourcePending )
        // fall through
    case ClusterResourceOffline:
        //
        // Because this resource is now unstuck... there may be other
        // pending threads waiting to clear up. If not, they'll just get
        // stuck again, until the next notification.
        //
        switch ( NewState ) {

        case ClusterResourceFailed:
            if ( Resource->State != NewState ) 
                FmpPropagateResourceState( Resource, NewState );
                
            // if it is the quorum resource handle the locking appropriately
            if (Resource->QuorumResource)
            {

                //
                //  Chittur Subbaraman (chitturs) - 9/20/99
                //
                //  Release and reacquire the gQuoLock to maintain
                //  locking order between group lock and gQuoLock.
                //
                RELEASE_LOCK(gQuoLock);

                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOffline);

                ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
            }
            else
            {
                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOffline);
            }                                
            break;                

        case ClusterResourceOffline:
            if ( Resource->Group->OwnerNode == NmLocalNode ) 
            {
                if ( Resource->State != NewState ) 
                {
                    FmpPropagateResourceState( Resource, NewState );
                }
                
                // if it is the quorum resource handle the locking appropriately
                if (Resource->QuorumResource)
                {
                    //
                    //  Chittur Subbaraman (chitturs) - 9/20/99
                    //
                    //  Release and reacquire the gQuoLock to maintain
                    //  locking order between group lock and gQuoLock.
                    //
                    RELEASE_LOCK(gQuoLock);

                    FmpProcessResourceEvents(Resource, ClusterResourceOffline,
                                                ClusterResourceOfflinePending);

                    ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
                }
                else
                {
                    FmpProcessResourceEvents(Resource, ClusterResourceOffline,
                                                ClusterResourceOfflinePending);
                }                                
            } 
            else 
            {
                if ( Resource->State != NewState ) 
                {
                    FmpPropagateResourceState( Resource, NewState );
                }
            }
            break;

        default:
            if ( Resource->State != NewState ) {
                FmpPropagateResourceState( Resource, NewState );
            }
            break;

        }
        break;

    case ClusterResourceOnlinePending:
        //SS: a resource cannot go from one pending state to another
        CL_ASSERT( NewState < ClusterResourcePending )

        //
        // Because this resource is now unstuck... there may be other
        // pending threads waiting to clear up. If not, they'll just get
        // stuck again, until the next notification.
        //

        switch ( NewState ) {

        case ClusterResourceFailed:
            //
            // Make sure we go through full failure recovery.
            //
            //SS: dont know why the state is being set to online
            //it could be online pending
            //Resource->State = ClusterResourceOnline;
            ClRtlLogPrint(LOG_NOISE,
                "[FM] HandleResourceTransition: Resource failed, post a work item\r\n");
            if (Resource->State != NewState)
                FmpPropagateResourceState( Resource, NewState );

            // since this is the quorum Resource handle locking appropriately
            if (Resource->QuorumResource)
            {

                //
                //  Chittur Subbaraman (chitturs) - 9/20/99
                //
                //  Release and reacquire the gQuoLock to maintain
                //  locking order between group lock and gQuoLock.
                //
                RELEASE_LOCK(gQuoLock);

                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnlinePending);

                ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
            }
            else
            {
                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnlinePending);
            
            }
            break;

        case ClusterResourceOnline:
            if (Resource->Group->OwnerNode == NmLocalNode) {
                //Call FmpPropagateResourceState without holding the group
                //lock for the quorum resource
                FmpPropagateResourceState( Resource, NewState );

                // since this is the quorum Resource fork another thread
                if (Resource->QuorumResource)
                {
                    //
                    //  Chittur Subbaraman (chitturs) - 9/20/99
                    //
                    //  Release and reacquire the gQuoLock to maintain
                    //  locking order between group lock and gQuoLock.
                    //
                    RELEASE_LOCK(gQuoLock);

                    FmpProcessResourceEvents(Resource, ClusterResourceOnline,
                                                ClusterResourceOnlinePending);

                    ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
                } 
                else
                {
                    FmpProcessResourceEvents(Resource, ClusterResourceOnline,
                                                ClusterResourceOnlinePending);
                }
            } else {
                FmpPropagateResourceState( Resource, NewState );
            }
            break;
            
        default:
            if (Resource->State != NewState)
                FmpPropagateResourceState( Resource, NewState );
            break;
        }

        Resource->Flags &= ~RESOURCE_WAITING;
        break;

    case ClusterResourceInitializing:
    default:
        if (Resource->State != NewState)
            FmpPropagateResourceState( Resource, NewState );
        CL_ASSERT(Resource->State == NewState);
    }

FnExit:

    if (Resource->QuorumResource) {
        RELEASE_LOCK(gQuoLock);
    } else {
        FmpReleaseLocalResourceLock(Resource);
    }

    RELEASE_LOCK(gQuoChangeLock);

    return;
}


/****
@func       DWORD | FmpCreateResNotificationHandler| This creates a new
            thread to handle state change notifications for the given resource.

@parm       IN PFM_RESOURCE | pResource | Pointer to the resource.
@parm       IN CLUSTER_RESOURCE_STATE | OldState | The old state of the
            resource from which it transitioned.
@parm       IN CLUSTER_RESOURCE_STATE | NewState | The new state of the
            resource.

@comm       This routine creates a thread to perform all the pending work
            when the resource changes state that cannot be performed within
            FmpHandleResourceTransition to avoid deadlocks and that cannot
            be deffered to the FmpWorkerThread because of serialization issues.
            In particular, it is used to handle state transition work for the
            quorum resource since other resources depend on the quorum resource
            and cannot come online till the state of the quorum becomes online.
            For instance, the quorum resource may be coming offline as a part
            of move while another resource if in FmpWorkerThread() calling
            FmpOffline/OnlineWaitingTree(). For the quorum resource to come
            online again (that happens by signalling the move pending thread) 
            so that FmpWorkerThread can make progress its events will have 
            to be handled separately.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpHandleResStateChangeProc>

****/
DWORD FmpCreateResStateChangeHandler(
    IN PFM_RESOURCE pResource, 
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState)
{

    HANDLE                  hThread = NULL;
    DWORD                   dwThreadId;
    PRESOURCE_STATE_CHANGE  pResStateContext = NULL;
    DWORD                   dwStatus = ERROR_SUCCESS;
    
    //reference the resource
    //the thread will dereference it, if the thread is successfully
    //created
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateResStateChangeHandler: Entry\r\n");

    OmReferenceObject(pResource);

    pResStateContext = LocalAlloc(LMEM_FIXED, sizeof(RESOURCE_STATE_CHANGE));

    if (!pResStateContext)
    {

        dwStatus = GetLastError();
        CL_UNEXPECTED_ERROR(dwStatus);
        goto FnExit;
    }


    pResStateContext->pResource = pResource;
    pResStateContext->OldState = OldState;
    pResStateContext->NewState = NewState;

                    
    hThread = CreateThread( NULL, 0, FmpHandleResStateChangeProc,
                pResStateContext, 0, &dwThreadId );

    if ( hThread == NULL )
    {
        dwStatus = GetLastError();
        CL_UNEXPECTED_ERROR(dwStatus);
        // if the function failed to create the thread, cleanup the 
        // state that the thread would have cleaned
        //deref the object if the thread is  not created successfully
        OmDereferenceObject(pResource);
        LocalFree(pResStateContext);
        goto FnExit;
    }

FnExit:
    //do general cleanup
    if (hThread)
        CloseHandle(hThread);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateResStateChangeHandler: Exit, status %1!u!\r\n",
        dwStatus);
    return(dwStatus);
}

/****
@func       DWORD | FmpHandleResStateChangeProc| This thread procedure
            handles all the post processing for the resource transitions
            for the quorum resource.

@parm       IN LPVOID | pContext | A pointer to PRESOURCE_STATE_CHANGE
            structure.

@comm       This thread handles a resource change notification postprocessing.
            Significantly for quorum resource so that quorum resource
            state change notifications are not handled by the single
            FmpWorkThread() [that causes deadlock - if the quorum 
            notification resource is queued behind a notification whose
            handling requires tha quorum resource be online]..

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpCreateResStateChangeHandler)
****/
DWORD
FmpHandleResStateChangeProc(
    IN LPVOID pContext
    )
{
    PRESOURCE_STATE_CHANGE  pResStateChange = pContext;

    CL_ASSERT( pResStateChange );
    
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpHandleResStateChangeProc: Entry...\r\n");

    FmpHandleResourceTransition( pResStateChange->pResource, 
                                 pResStateChange->NewState );
                                 
    OmDereferenceObject( pResStateChange->pResource );
    
    LocalFree( pResStateChange );

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpHandleResStateChangeProc: Exit...\r\n");

    return( ERROR_SUCCESS );
}


DWORD
FmpDelayedStartRes(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Starts a timer for the resource. FmpDelayedRestartCb function will be 
    invoked at the expiry of timer..

Arguments:

    pResource   - The resource which has transitioned.


Return Value:
    ERROR_SUCCESS if successful, WIN32 errorcode otherwise.

    Note that no delayed restart attempts are made if the resource is a quorum resource.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDelayedRestartRes:Entry for resource %1!ws!\n",
                OmObjectId(pResource));
    
    if( (pResource->RetryPeriodOnFailure != CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE ) &&
        !(pResource->QuorumResource) )
    {
        // Check if there is already a timer running for this resource

        if(pResource->hTimer == NULL)                 
        {
            pResource->hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
            if (!(pResource->hTimer))
            {
                // not a fatal error but log it
                ClRtlLogPrint(LOG_ERROR,
                            "[FM] FmpDelayedRestartRes: failed to create the watchdog timer for resource %1!ws!\n",
                            OmObjectId(pResource));
            }
            else{
                ClRtlLogPrint(LOG_NOISE,
                            "[FM] FmpDelayedRestartRes: Adding watchdog timer for resource  %1!ws!, period=%2!u!\n",
                            OmObjectId(pResource), 
                            pResource->RetryPeriodOnFailure);

                // make sure resource struct won't go away if resource is deleted before the timer fires
                OmReferenceObject(pResource); 

                //register the timer with the periodic activity timer thread
                dwStatus = AddTimerActivity(pResource->hTimer, pResource->RetryPeriodOnFailure, 0, FmpDelayedRestartCb, pResource);

                if (dwStatus != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_ERROR,
                                "[FM] FmpDelayedRestartRes: AddTimerActivity failed with error %1!u!\n",
                                dwStatus);
                    CloseHandle(pResource->hTimer);
                    pResource->hTimer = NULL;
                }
            }
        }
    }
    return dwStatus;
}




VOID 
FmpDelayedRestartCb(
    IN HANDLE hTimer, 
    IN PVOID pContext)

/*++

Routine Description

    This is invoked by timer activity thread to attempt a restart on
    a failed resource.  

Arguments
    pContext - a pointer to PFM_RESOURCE 
   
Return Value
     ERROR_SUCCESS on success, a WIN32 error code otherwise.

--*/
    
{
    PFM_RESOURCE    pResource;

    pResource=(PFM_RESOURCE)pContext;
    ClRtlLogPrint(LOG_NOISE,
           "[FM] FmpDelayedRestartCb: Entry for  resource %1!ws! \n",
           OmObjectId(pResource));

    OmReferenceObject(pResource);
    FmpPostWorkItem(FM_EVENT_RES_RETRY_TIMER,
                        pResource,
                        0);    
    OmDereferenceObject(pResource);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\resource.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Cluster resource management routines.

Author:

    Mike Massa (mikemas) 1-Jan-1996


Notes:

    WARNING: All of the routines in this file assume that the resource
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"

//globals

#define LOG_MODULE RESOURCE


//
// Global Data
//
CRITICAL_SECTION  FmpResourceLock;

//
// Local Data
//

typedef struct PENDING_CONTEXT {
    PFM_RESOURCE Resource;
    BOOL         ForceOnline;
} PENDING_CONTEXT, *PPENDING_CONTEXT;


//
// Local function prototypes
//



/////////////////////////////////////////////////////////////////////////////
//
// Resource List Maintenance Routines
//
/////////////////////////////////////////////////////////////////////////////

BOOL
FmpFindResourceByNotifyKeyWorker(
    IN RM_NOTIFY_KEY NotifyKey,
    IN PFM_RESOURCE *FoundResource,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Enumeration callback routine for finding a resource by notify key

Arguments:

    FoundResource - Returns the found resource.

    Resource - Supplies the current resource.

    Name - Supplies the current resource's name.

Return Value:

    TRUE - to continue searching

    FALSE - to stop the search. The matching resource is returned in
        *FoundResource

--*/

{
    if ((RM_NOTIFY_KEY)Resource == NotifyKey) {
        *FoundResource = Resource;
        return(FALSE);
    }
    return(TRUE);

} // FmpFindResourceByNotifyKeyWorker



PFM_RESOURCE
FmpFindResourceByNotifyKey(
    RM_NOTIFY_KEY   NotifyKey
    )

/*++

Routine Description:

Arguments:

Returns:

--*/

{
    PFM_RESOURCE  resource = NULL;

    OmEnumObjects(ObjectTypeResource,
                  (OM_ENUM_OBJECT_ROUTINE)FmpFindResourceByNotifyKeyWorker,
                  (PVOID)NotifyKey,
                  &resource);
    return(resource);

} // FmpFindResourceByNotifyKey


//////////////////////////////////////////////////////////////
//
// Interfaces for managing resources.
//
/////////////////////////////////////////////////////////////


PFM_RESOURCE
FmpCreateResource(
    IN  PFM_GROUP   Group,
    IN  LPCWSTR     ResourceId,
    IN  LPCWSTR     ResourceName,
    IN  BOOL        Initialize
    )

/*++

Routine Description:

    Create a resource in our list of resources.

Arguments:

    Group - The Group in which this resource belongs.

    ResourceId - The id of the resource being created.

    ResourceName - The name of the resource being created.

    Initialize - TRUE if the resource should be initialized from the registry.
                 FALSE if the resource should be left un-initialized.

Returns:

    A pointer to the resource that was created or NULL.

Notes:

    1) The resource lock must be held when this routine is called.

    2) If the resource was created, then the reference count on the resource
    is 2 when this routine returns. If the resource was not created, then
    the reference count on the resource is not incremented. That way, if
    the caller needs extra references on the resource, then it must place
    them itself. This can be done later, since the resource lock is held.

--*/

{
    DWORD           mszStringIndex;
    PFM_RESOURCE    resource = NULL;
    DWORD           status;
    PDEPENDENCY     dependency = NULL;
    DWORD           resourceNameSize=
                          (wcslen(ResourceId) * sizeof(WCHAR)) +
                          sizeof(UNICODE_NULL);
    BOOL            created;
    LPWSTR          quorumId = NULL;
    DWORD           quorumIdSize = 0;
    DWORD           quorumIdMaxSize = 0;

    //
    // Open an existing resource or create a new one.
    //
    resource = OmCreateObject( ObjectTypeResource,
                               ResourceId,
                               ResourceName,
                               &created);
    if ( resource == NULL ) {
        return(NULL);
    }

    //
    // If we did not create a new resource, then make sure the Groups match.
    //
    if ( !created )
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] CreateResource, Opened existing resource %1!ws!\n",
                   ResourceId);
        OmDereferenceObject( resource );
        //the quorum group may be created again recursively before phase 1
        //in this case we dont want to do the special processing for putting
        //it on the quorum group contains list
        if ( resource->Group == Group )
        {
            return(resource);
        }
        //the quorum group is destroyed at initialization but not the quorum resource
        if (!FmpFMOnline)
        {
            //the quorum group is being recreated for the second time
            //the quorum group state needs to be refigured
            // this is done after all groups are created in FmFormNewClusterPhase2()

            if (resource->QuorumResource)
            {
                ClRtlLogPrint(LOG_NOISE,"[FM] ReCreating quorum resource %1!ws!\n", ResourceId);
                Group->OwnerNode = NmLocalNode;
                InsertTailList( &Group->Contains,
                    &resource->ContainsLinkage );
                //add a referenece to the resource object for being on the contains list
                OmReferenceObject( resource );
                resource->Group = Group;
                OmReferenceObject(Group);
                //SS: for now we dont use resource locks, so dont create it and leak it !
                //InitializeCriticalSection( &resource->Lock );
                FmpSetPreferredEntry( Group, NmLocalNode );
                return(resource);
            }
        }
        else
        {
            SetLastError(ERROR_RESOURCE_NOT_AVAILABLE);
            return(NULL);
        }

    }

    ClRtlLogPrint(LOG_NOISE,"[FM] Creating resource %1!ws!\n", ResourceId);

    resource->dwStructState = FM_RESOURCE_STRUCT_CREATED;

    //
    // Initialize the resource.
    //
    resource->Group = Group;
    resource->State = ClusterResourceOffline;  // Initial value for state.
    // resource->Flags = 0;             // Structure zeroed at creation
    // resource->Id = 0;
    // resource->FailureTime = 0;
    // resource->QuorumResource = FALSE;
    // resource->PossibleList = FALSE;
    //SS: for now we dont use resource locks, so dont create it and leak it !
    //InitializeCriticalSection( &resource->Lock );
    resource->hTimer=NULL;
    InitializeListHead( &(resource->ProvidesFor) );
    InitializeListHead( &(resource->DependsOn) );
    InitializeListHead( &(resource->PossibleOwners) );
    InitializeListHead( &(resource->DmRundownList) );

    //
    // Insert the new resource onto the Group's contains list.
    //
    InsertTailList( &Group->Contains,
                    &resource->ContainsLinkage );
    //SS: there is already a reference to the object for being on the resource
    //list
    //add a referenece to the resource object for being on the contains list
    OmReferenceObject( resource );

    //add a reference to the group because the resource has a pointer to it
    OmReferenceObject(Group);

    //
    // Complete initialization if we were told to do so.
    //
    status = FmpInitializeResource( resource, Initialize );

    //
    // Check for distinguished error code to delete this resource.
    //
    if ( status == ERROR_INVALID_NAME ) {
        goto error_exit;
    }
    //
    // On other failures, we must be sure to come back through init later...
    //
    if ( Initialize &&
         (status != ERROR_SUCCESS) ) {
        CL_ASSERT( resource->Monitor == NULL );
    }

    //
    // Now insert this object into the tree... before the dependency
    // list is processed. That way, if there are circular dependencies
    // this will not loop forever.  If we can be assured that there are
    // no circular dependencies, then we can do the insert after creating
    // the dependency tree.
    //
    // if this is being called during initialization, and the resource is
    // is already created it belonged to the group to which the quorum
    // resource belongs to and doesnt need to be inserted into the resource list
    if (FmpFMOnline  || (created))
    {
        status = OmInsertObject( resource );

        if ( status != ERROR_SUCCESS )
            goto error_exit;
    }

    //
    // Check if this is the Quorum Resource.
    //
    status = DmQuerySz( DmQuorumKey,
                        CLUSREG_NAME_QUORUM_RESOURCE,
                        &quorumId,
                        &quorumIdMaxSize,
                        &quorumIdSize );

    if ( status != ERROR_SUCCESS) {
         ClRtlLogPrint(LOG_ERROR,
                    "[FM] Failed to read quorum resource, error %1!u!.\n",
                    status);
    }

    //
    // If we're creating the quorum resource, then indicate it.
    //
    if ( (quorumId != NULL) &&
         (lstrcmpiW( quorumId, ResourceId ) == 0) ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Found the quorum resource %1!ws!.\n",
                   ResourceId);
        resource->QuorumResource = TRUE;
    }

    LocalFree(quorumId);
    //
    // Create Any Dependencies
    //
    for (mszStringIndex = 0; ; mszStringIndex++) {
        LPCWSTR       nameString;
        PFM_RESOURCE  childResource;


        nameString = ClRtlMultiSzEnum(
                             resource->Dependencies,
                             resource->DependenciesSize/sizeof(WCHAR),
                             mszStringIndex
                             );

        if (nameString == NULL) {
            break;
        }

        //
        // Create the dependency.
        //
        dependency = LocalAlloc(LMEM_FIXED, sizeof(DEPENDENCY));
        if (dependency == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        //
        // Create the child resource recursively. We must also add an
        // additional reference required for the dependency relationship.
        //
        ClRtlLogPrint(LOG_NOISE,"[FM] Resource %1!ws! depends on %2!ws!. Creating...\n",
                  ResourceId,
                  nameString);

        childResource = FmpCreateResource( resource->Group,
                                           nameString,
                                           NULL,
                                           Initialize );
        if (childResource == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,"[FM] Failed to create dep %1!ws! for resource %2!ws!\n",
                      nameString,
                      ResourceId);

            goto error_exit;
        } else {
            //
            // Add a reference to each resource to reflect the
            // dependency.
            //
            OmReferenceObject( childResource );
            OmReferenceObject( resource );
            dependency->DependentResource = resource;
            dependency->ProviderResource = childResource;
            InsertTailList(&childResource->ProvidesFor,
                           &dependency->ProviderLinkage);
            InsertTailList(&resource->DependsOn,
                           &dependency->DependentLinkage);
        }

    }

    resource->dwStructState |= FM_RESOURCE_STRUCT_INITIALIZED;

    ClRtlLogPrint(LOG_NOISE,"[FM] All dependencies for resource %1!ws! created.\n",
                          ResourceId);

    return(resource);

error_exit:

    FmpAcquireLocalResourceLock( resource );

    RemoveEntryList( &resource->ContainsLinkage );
    //dereference the resource object for being removed from the contains linkage
    OmDereferenceObject( resource );

    FmpDestroyResource( resource, FALSE );

    //dereference the resource object, for being removed from the resource list.
    //OmDereferenceObject( resource );
    //delete the extra reference that was added to the group
    //OmDereferenceObject(Group);

    SetLastError(status);
    return(NULL);

} // FmpCreateResource


DWORD
FmpInitializeResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL          Initialize
    )

/*++

Routine Description:

    Initializes a resource from the registry and tells the Resource
    Monitor about the new resource (if the local system can host the
    resource).

Arguments:

    Resource - Supplies the resource to be initialized.

    Initialize - TRUE if the resource should be fully initialized.
                 FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    It is assumed that the resource lock is held.

--*/

{
    DWORD   status;

    if ( Resource->Monitor != NULL ) {
        return(ERROR_ALREADY_INITIALIZED);
    }

    status = FmpQueryResourceInfo( Resource, Initialize );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // If we didn't fully initialize the resource, then leave now.
    //
    if ( !Initialize ) {
        return(ERROR_SUCCESS);
    }

    //
    // This is a newly initialized resource. Tell the Resource Monitor to
    // create it.
    //
    // TODO - we don't want to instantiate resources in the resource
    // monitor that we cannot execute. We must check possible owners list
    // before making this call. We must also make sure the registry
    // parameters are read. We use the Monitor field as a surrogate for
    // determining whether the registry parameters have been read.
    //
    return(FmpRmCreateResource(Resource));

} // FmpInitializeResource



DWORD
FmpOnlineResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL ForceOnline
    )

/*++

Routine Description:

    Brings a resource and all its dependencies online. If ERROR_IO_PENDING is
    returned, then no thread is started to complete the online request.

Arguments:

    Resource - Supplies the resource to be brought online

    ForceOnline - TRUE if the resource should be forced online.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_IO_PENDING if the request is pending.
    Win32 error code otherwise.

--*/
{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;
    BOOL          waitingResource = FALSE;
    DWORD         separateMonitor;
    DWORD         onlinestatus;

    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is not owned by this system, then return error.
    //
    CL_ASSERT( Resource->Group != NULL );
    if (Resource->Group->OwnerNode != NmLocalNode)
    {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }
    //if it is the quorum resource dont check for the node
    //being in the preferred list, we should be able to
    //bring the quorum resource online on any node
    if (!(Resource->QuorumResource) && 
        !FmpInPreferredList( Resource->Group, Resource->Group->OwnerNode, TRUE, Resource ))
    {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_NODE_CANT_HOST_RESOURCE);
    }

    //
    // If the resource is already online, then return immediately.
    //
    if (Resource->State == ClusterResourceOnline) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If the resource is in online pending state, then return immediately.
    //
    if ( Resource->State == ClusterResourceOnlinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_IO_PENDING);
    }

    //
    // If the resource is in offline pending state, then return immediately.
    //
    if ( Resource->State == ClusterResourceOfflinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_INVALID_STATE);
    }

    //
    // If the resource is not initialized, then initialize it now.
    //
    if ( Resource->Monitor == NULL ) {
        status = FmpInitializeResource( Resource, TRUE );
        if ( status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            return(status);
        }
    } else {
        //
        // If the separate monitor flag has changed, then close down old
        // resource in resmon, and re-create it.
        //
        separateMonitor = (Resource->Flags & RESOURCE_SEPARATE_MONITOR) ? 1 : 0;
        status = DmQueryDword( Resource->RegistryKey,
                                        CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                        &separateMonitor,
                                        &separateMonitor );

        if ( (!separateMonitor &&
             (Resource->Flags & RESOURCE_SEPARATE_MONITOR)) ||
             (separateMonitor &&
             ((Resource->Flags & RESOURCE_SEPARATE_MONITOR) == 0)) ) {

            status = FmpChangeResourceMonitor( Resource, separateMonitor );
            if ( status != ERROR_SUCCESS ) {
                FmpReleaseLocalResourceLock( Resource );
                return(status);
            }
        }
    }

    //
    // If this resource is supposed to be left offline, then make it so.
    //
    if ( !ForceOnline && (Resource->PersistentState == ClusterResourceOffline) ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_RESOURCE_NOT_ONLINE);
    }

    //
    // Next, make sure there are no resources down the tree that are waiting.
    // This prevents a deadlock where the top of the tree is trying to go
    // offline, while the bottom of the tree is trying to go online.
    //
    for ( entry = Resource->DependsOn.Flink;
          entry != &(Resource->DependsOn);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, DependentLinkage);

        if ( (dependency->ProviderResource->State == ClusterResourceOfflinePending) &&
             (dependency->ProviderResource->Flags & RESOURCE_WAITING) ) {
            waitingResource= TRUE;
            break;
        }
    }
    if ( waitingResource ) {
        Resource->Flags |= RESOURCE_WAITING;
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // If the PersistentState is Offline, then reset the current state.
    //
    if ( Resource->PersistentState == ClusterResourceOffline ) {
        FmpSetResourcePersistentState( Resource, ClusterResourceOnline );
    }

    //
    // Make sure the Waiting flag is clear.
    //
    Resource->Flags &= ~RESOURCE_WAITING;

    //
    // If this resource has any dependencies, bring them online first.
    //
    for ( entry = Resource->DependsOn.Flink;
          entry != &(Resource->DependsOn);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, DependentLinkage);

        //
        // Recursively bring the provider resource online.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OnlineResource: %1!ws! depends on %2!ws!. Bring online first.\n",
                   OmObjectId(Resource),
                   OmObjectId(dependency->ProviderResource));
        onlinestatus = FmpDoOnlineResource( dependency->ProviderResource,
                                      ForceOnline );

        if ( onlinestatus != ERROR_SUCCESS ) {
            if ( onlinestatus != ERROR_IO_PENDING ) {
                ClRtlLogPrint(LOG_NOISE,
                      "[FM] OnlineResource: dependency %1!ws! failed %2!d!\n",
                      OmObjectId(dependency->ProviderResource),
                      status);
                FmpReleaseLocalResourceLock( Resource );
                status = onlinestatus;
                return(status);
            } else {
                FmpCallResourceNotifyCb(Resource, ClusterResourceOnlinePending);
                FmpPropagateResourceState( Resource,
                                           ClusterResourceOnlinePending );
                Resource->Flags |= RESOURCE_WAITING;
                if (status == ERROR_SUCCESS)
                    status = onlinestatus;
            }
        }
    }


    //
    // Tell the resource monitor to bring this resource online.
    //
    if ( !(Resource->Flags & RESOURCE_WAITING) ) {
        status = FmpRmOnlineResource( Resource );
    }
#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailOnlineResource) {
        FmpRmFailResource( Resource );
    }
#endif

    FmpReleaseLocalResourceLock( Resource );
    return(status);

} // FmpOnlineResource



DWORD
FmpTerminateResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine takes a resource (and all of the resources that it provides
    for) offline - the hard way.

Arguments:

    Resource - A pointer to the resource to take offline the hard way.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    PLIST_ENTRY  entry;
    PDEPENDENCY  dependency;
    DWORD        status;


    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is already offline, then return immediately.
    //
    // We should not have to check if a resource has been initialized,
    // since if it hasn't been initialized we will return because the
    // pre-initialized state of a resource is Offline.
    //
    if ( Resource->State == ClusterResourceOffline ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    Resource->Flags &= ~RESOURCE_WAITING;

    //
    // If this resource has any dependents, terminate them first.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively terminate the dependent resource
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] TerminateResource: %1!ws! depends on %2!ws!. Terminating first\n",
                   OmObjectId(dependency->DependentResource),
                   OmObjectId(Resource));

        //
        // First stop any pending threads.
        //

        if ( dependency->DependentResource->PendingEvent ) {
            SetEvent( dependency->DependentResource->PendingEvent );
        }

        status = FmpTerminateResource(dependency->DependentResource);

        CL_ASSERT( status != ERROR_IO_PENDING );
        if (status != ERROR_SUCCESS) {
            FmpReleaseLocalResourceLock( Resource );
            return(status);
        }
    }

    //
    // Tell the resource monitor to terminate this resource.
    //
    FmpRmTerminateResource(Resource);

    FmpReleaseLocalResourceLock( Resource );

    return(ERROR_SUCCESS);

} // FmpTerminateResource



DWORD
FmpOfflineResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL bForceOffline

    )

/*++

Routine Description:

    This routine takes a resource (and all of the resources that it provides
    for) offline. If ERROR_IO_PENDING is returned, then no thread is started
    to complete the offline request.

Arguments:

    Resource - A pointer to the resource to take offline.

    bForceOffline - Indicates whether the persistent state is to be set.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD         status = ERROR_SUCCESS;
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    BOOL          waitingResource = FALSE;
    DWORD         offlinestatus;
    
    FmpAcquireLocalResourceLock( Resource );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineResource: Offline resource <%1!ws!> <%2!ws!>\n",
               OmObjectName(Resource),
               OmObjectId(Resource) );
    //
    // If we own the Group and we are not a possible owner, then the resource
    // better be offline!
    //
    if ( (Resource->Group->OwnerNode != NmLocalNode) ||
         (!FmpInPreferredList( Resource->Group, Resource->Group->OwnerNode , FALSE, NULL) &&
	 (Resource->Group != gpQuoResource->Group) &&
         (Resource->State != ClusterResourceOffline)) ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_INVALID_STATE);
    }

    //
    // If the resource is already offline, then return immediately.
    //
    // We should not have to check if a resource has been initialized,
    // since if it hasn't, then we will return because the pre-initialized
    // state of a resource is Offline.
    //
    if ( Resource->State == ClusterResourceOffline ) {
        //
        // If this is the quorum resource, make sure any reservation
        // threads are stopped!
        //
        if ( Resource->QuorumResource ) {
            FmpRmTerminateResource( Resource );
        }
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    } else if ( Resource->State == ClusterResourceFailed ) {
        //
        //  Chittur Subbaraman (chitturs) - 4/8/99
        //
        //  If the resource has already failed, then don't do anything.
        //  You could run into some funny cases of a resource switching
        //  between offline pending and failed states for ever if you 
        //  attempt to offline a failed resource.
        //
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If this system is not the owner, then return an error. Forwarding
    // should have been done at a higher layer.
    //
    CL_ASSERT( Resource->Group != NULL );
    if ( (Resource->Group->OwnerNode != NmLocalNode) ||
	 ((Resource->Group != gpQuoResource->Group) &&
         !FmpInPreferredList( Resource->Group, Resource->Group->OwnerNode, FALSE, NULL)) ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    if (Resource->State == ClusterResourceOnlinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResource: Offline resource <%1!ws!> is in online pending state\n",
                   OmObjectName(Resource) );
        if (FmpShutdown)
        {
            FmpRmTerminateResource( Resource );
            return(ERROR_SUCCESS);
        }            
        else            
            return(ERROR_INVALID_STATE);
    }

    //
    // If the resource is in a pending state, then return immediately.
    //
    if (Resource->State == ClusterResourceOfflinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResource: Offline resource <%1!ws!> returned pending\n",
                   OmObjectName(Resource) );
        return(ERROR_IO_PENDING);
    }

    //
    // Next, make sure there are no resources up the tree that are waiting.
    // This prevents a deadlock where the top of the tree is trying to go
    // offline, while the bottom of the tree is trying to go online.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        if ( (dependency->DependentResource->State == ClusterResourceOnlinePending) &&
             (dependency->DependentResource->Flags & RESOURCE_WAITING) ) {
            waitingResource = TRUE;
            break;
        }
    }
    if ( waitingResource ) {
        Resource->Flags |= RESOURCE_WAITING;
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Make sure the Waiting flag is clear.
    //
    Resource->Flags &= ~RESOURCE_WAITING;

    //
    // If this resource has any dependents, shut them down first.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively shutdown the dependent resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResource: %1!ws! depends on %2!ws!. Shut down first.\n",
                   OmObjectName(dependency->DependentResource),
                   OmObjectName(Resource));

        offlinestatus = FmpDoOfflineResource(dependency->DependentResource,
                            bForceOffline);

        if ( offlinestatus != ERROR_SUCCESS ) {
            if ( offlinestatus != ERROR_IO_PENDING ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOfflineResource for %1!ws!, bad status returned %2!u!.\n",
                           OmObjectName(dependency->DependentResource),
                           offlinestatus);
                FmpTerminateResource( dependency->DependentResource );
                FmpReleaseLocalResourceLock( Resource );
                return(offlinestatus);
            } else {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOfflineResource for %1!ws! marked as waiting.\n",
                           OmObjectName(Resource));
                FmpCallResourceNotifyCb(Resource, ClusterResourceOfflinePending);
                FmpPropagateResourceState( Resource,
                                           ClusterResourceOfflinePending );
                Resource->Flags |= RESOURCE_WAITING;
                if (status == ERROR_SUCCESS)
                    status = offlinestatus;
            }
        }
    }


    //
    // Tell the resource monitor to shut this resource down.
    // The state gets updated by the return status in FmpRmOfflineResource.
    //
    if ( !(Resource->Flags & RESOURCE_WAITING) ) {
        status = FmpRmOfflineResource( Resource );
        //
        //  Chittur Subbaraman (chitturs) - 3/2/2000
        //
        //  If the resource could not be made offline since the quorum 
        //  resource online operation failed or for other reasons, then 
        //  make sure the resource is terminated after you declare the 
        //  state of the resource as failed. This is necessary since 
        //  otherwise the FM will consider the resource as having failed 
        //  while the resource itself is actually online. This will 
        //  lead to disastrous cases whereby the FM will allow the online 
        //  entry point of a resource to be called while the resource is 
        //  actually online !
        //
        if( ( status != ERROR_SUCCESS ) &&
            ( status != ERROR_IO_PENDING ) && 
            ( status != ERROR_RETRY ) ) {
            FmpRmTerminateResource( Resource );
        }
    }
    FmpReleaseLocalResourceLock( Resource );

    return(status);

} // FmpOfflineResource



DWORD
FmpDoOnlineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL ForceOnline
    )

/*++

Routine Description:

    This routine brings a resource online. If ERROR_IO_PENDING is returned,
    then a thread is started to complete the Online request.


Arguments:

    Resource - A pointer to the resource to bring online.

    ForceOnline - TRUE if the resource should be forced online.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD   status;

    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is already online, then return immediately.
    //
    if ( Resource->State == ClusterResourceOnline ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If the resource is in a pending state, then return immediately.
    // FmpOnlineResource checks for offlinepending state and returns
    // ERROR_INVALID_STATE if so.
    //
    if ( Resource->State == ClusterResourceOnlinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_IO_PENDING);
    }

    //
    // If this node is paused, return failure.
    //
    if (NmGetNodeState(NmLocalNode) == ClusterNodePaused) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SHARING_PAUSED);
    }

    //
    // Try to bring the resource online.
    //
    status = FmpOnlineResource( Resource, ForceOnline );

    //
    // Write the persistent state if it is forced online.
    //
    if ( ForceOnline &&
         ((status == ERROR_SUCCESS)||
         (status == ERROR_IO_PENDING))) {
        FmpSetResourcePersistentState( Resource, ClusterResourceOnline );
    }

    FmpReleaseLocalResourceLock( Resource );

    return(status);

} // FmpDoOnlineResource



DWORD
FmpDoOfflineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL bForceOffline
    )

/*++

Routine Description:

    This routine takes a resource offline. If ERROR_IO_PENDING is returned,
    then a thread is started to complete the Offline request.


Arguments:

    Resource - A pointer to the resource to take offline.

    bForceOffline - Indicates whether the persistent state must be changed.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD   status;

    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is already offline, then return immediately.
    //
    if (Resource->State == ClusterResourceOffline) {
        //
        // If this is the quorum resource, make sure any reservation
        // threads are stopped!
        //
        if ( Resource->QuorumResource ) {
            FmpRmTerminateResource( Resource );
        }
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If the resource is in a pending state, then return immediately.
    // FmpOffline resource checks to see if it is in OnlinePending state
    // and returns invalid state
    //
    if (Resource->State == ClusterResourceOfflinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_IO_PENDING);
    }

    //
    // Try to take the resource offline.
    //
    status = FmpOfflineResource( Resource, bForceOffline );

    //
    // Write the persistent state if it is forced offline
    //
    if ( bForceOffline &&
         ((status == ERROR_SUCCESS)||
         (status == ERROR_IO_PENDING))) {
        FmpSetResourcePersistentState( Resource, ClusterResourceOffline );
    }

    FmpReleaseLocalResourceLock( Resource );

    return(status);

} // FmpDoOfflineResource



VOID
FmpSetResourcePersistentState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    )

/*++

Routine Description:

    Set the persistent state of a Resource in the registry and set the
    PersistentState for the volatile (in-memory) resource. It is assumed
    that the dynamic state gets changed elsewhere depending on whether
    the resource online request succeeds or fails.

Arguments:

    Resource - The resource to set the state.
    State    - The new state for the Resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.


Notes:

    The LocalResourceLock must be held.

--*/

{
    CLUSTER_RESOURCE_STATE   persistentState;
    LPWSTR  persistentStateName = CLUSREG_NAME_RES_PERSISTENT_STATE;

    if (!gbIsQuoResEnoughSpace)
        return;

    //
    // If the current state has changed, then do the work. Otherwise,
    // skip the effort.
    //
    if ( Resource->PersistentState != State ) {
        Resource->PersistentState = State;
        CL_ASSERT( Resource->RegistryKey != NULL );

        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetResourcePersistentState: Setting persistent state for resource %1!ws!...\r\n",
                OmObjectId(Resource));

        //
        // Set the new value, but only if it is online or offline.
        //
        if ( State == ClusterResourceOffline ) {
            persistentState = 0;
            DmSetValue( Resource->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        } else if ( State == ClusterResourceOnline ) {
            persistentState = 1;
            DmSetValue( Resource->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        }
    }

} // FmpSetResourcePersistentState

void FmpCallResourceNotifyCb( 
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    )
{

    switch ( State ) {
    case ClusterResourceOnline:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_POSTONLINE);
        break;
    case ClusterResourceOffline:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_POSTOFFLINE);
        break;
    case ClusterResourceFailed:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_FAILED);
        break;
    case ClusterResourceOnlinePending:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_ONLINEPENDING);
        break;
    case ClusterResourceOfflinePending:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_OFFLINEPENDING);
        break;
    default:
        break;
    }
    return;

}


DWORD
FmpPropagateResourceState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    )

/*++

Routine Description:

    Propagates the state of the resource to other systems in the cluster.
    Ideally the gQuoCritSec lock should be held when this routine is called.
    This is because this routine checks the quorumresource field of the 
    resource

Arguments:

    Resource - The resource to propagate state.

    State - The new state for the resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    GUM_RESOURCE_STATE resourceState;
    LPCWSTR  resourceId;
    DWORD    resourceStateSize;
    DWORD    status= ERROR_SUCCESS;
    BOOL     bAcquiredQuoLock = FALSE;
    
    //for quorum resource use the quorum lock for state changes
    // for others use the group locks
    if (Resource->QuorumResource)
    {
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
        bAcquiredQuoLock = TRUE;
    }        
    else
        FmpAcquireLocalResourceLock( Resource );
        
    ++Resource->StateSequence;

    if (! FmpFMFormPhaseProcessing )
    {
        //
        // If this is the same state, or we don't own the group
        // then don't bother propagating.
        //

        if ( (State == Resource->State) ||
             (Resource->Group->OwnerNode != NmLocalNode) ) {
            goto ReleaseResourceLock;
        }

        //if the previous state is the online pending and this
        // is called for the quorum resource, wake up all resources
        // make sure that if this is called while the form phase
        //processing is going on(when the quorum group is destroyed 
        //and recreated), that the group is not referenced
        if ((Resource->QuorumResource) && 
            (Resource->State==ClusterResourceOnlinePending) &&
            (Resource->Group->OwnerNode == NmLocalNode) ) 
        {
            //set the state and signal
            Resource->State = State;
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpPropagateResourceState: signalling the ghQuoOnlineEvent\r\n");
            SetEvent(ghQuoOnlineEvent);    
        }


    }

    Resource->State = State;

    //
    // Prepare to notify other systems.
    //
    resourceId = OmObjectId( Resource );
    resourceState.State = State;
    resourceState.PersistentState = Resource->PersistentState;
    resourceState.StateSequence = Resource->StateSequence;

    status = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateResourceState,
                             2,
                             (lstrlenW(resourceId)+1)*sizeof(WCHAR),
                             resourceId,
                             sizeof(resourceState),
                             &resourceState);


    //
    // Signal change notify event.
    //
    switch ( State ) {
    case ClusterResourceOnline:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! online event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_ONLINE, Resource);
        break;
    case ClusterResourceOffline:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! offline event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_OFFLINE, Resource);
        break;
    case ClusterResourceFailed:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! failed event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_FAILED, Resource);
        break;
    case ClusterResourceOnlinePending:
    case ClusterResourceOfflinePending:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! pending event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_CHANGE, Resource);
        break;
    default:
        break;
    }

ReleaseResourceLock:
    if (bAcquiredQuoLock)
        RELEASE_LOCK(gQuoLock);
    else
        FmpReleaseLocalResourceLock( Resource );


    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Propagation of resource %1!ws! state %2!u! failed. Error %3!u!\n",
                   OmObjectId(Resource),
                   State,
                   status);
        goto FnExit;                   
    }
    //if fm is not completely online we dont want to propagate group state
    // This is because the quorum group is destroyed in FmFormNewClusterPhase1
    // and then recreated again in FmFormNewClusterPhase2.
    if (FmpFMOnline)
    {
        OmReferenceObject(Resource->Group);
        //FmpPropagateGroupState( Resource->Group );
        FmpPostWorkItem(FM_EVENT_INTERNAL_PROP_GROUP_STATE, Resource->Group, 0);
    }
FnExit:
    return(status);

} // FmpPropagateResourceState



VOID
FmpDestroyResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL          bDeleteObjOnly
    )

/*++

Routine Description:

    Destroys a resource. This basically snips a resource out of the
    dependency tree.

    First, any resources that depend on the specified
    resource are recursively destroyed. This removes any dependencies
    that other resources may have on the specified resource (i.e. all
    resources "higher" in the dependency tree are destroyed).

    Second, all the dependencies that the specified resource has are
    removed. This entails dereferencing the provider resource (to remove
    the reference that was added when the dependency was created) removing
    the DEPENDENCY structure from its provider and dependent lists, and
    finally freeing the DEPENDENCY storage.

    If the resource is online, it is terminated. The resource monitor is
    signalled to clean up and close the specified resource id.

Arguments:

    FoundResource - Returns the found resource.

    Resource - Supplies the current resource.

    Name - Supplies the current resource's name.

Return Value:

    None.

Notes:

    The LocalResourceLock MUST be held! The lock is released before exit!

--*/
{
    DWORD         status;
    DWORD         i;
    PLIST_ENTRY ListEntry;
    PDEPENDENCY Dependency;
    PPOSSIBLE_ENTRY possibleEntry;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] DestroyResource: destroying %1!ws!\n",
               OmObjectId(Resource));

    //
    // First, unlink this resource from the resource list.
    //
    //
    // if the resource belongs to the quorum group, it is destroyed
    // after the quorum logs are created so that it can be recreated
    // dont remove it from the list then
    if ((!bDeleteObjOnly))
        status = OmRemoveObject( Resource );

    //
    // If anyone depends on this resource, destroy them first.
    //
    while (!IsListEmpty(&Resource->ProvidesFor)) {

        ListEntry = Resource->ProvidesFor.Flink;
        Dependency = CONTAINING_RECORD(ListEntry, DEPENDENCY, ProviderLinkage);
        CL_ASSERT(Dependency->ProviderResource == Resource);

#if 0
        FmpRemoveResourceDependency( Dependency->DependentResource,
                                     Resource );
#endif
        RemoveEntryList(&Dependency->ProviderLinkage);
        RemoveEntryList(&Dependency->DependentLinkage);

        //
        // Dereference provider/dependent resource and free dependency storage
        //
        OmDereferenceObject(Dependency->ProviderResource);
        OmDereferenceObject(Dependency->DependentResource);
        LocalFree(Dependency);
    }

    //
    // Remove our resource dependencies.
    //
    while (!IsListEmpty(&Resource->DependsOn)) {

        ListEntry = RemoveHeadList(&Resource->DependsOn);
        Dependency = CONTAINING_RECORD(ListEntry, DEPENDENCY, DependentLinkage);
        CL_ASSERT(Dependency->DependentResource == Resource);

#if 0
        FmpRemoveResourceDependency( Resource,
                                     Dependency->ProviderResource );
#endif
        RemoveEntryList(&Dependency->ProviderLinkage);
        RemoveEntryList(&Dependency->DependentLinkage);

        //
        // Dereference provider/dependent resource and free dependency storage
        //
        OmDereferenceObject(Dependency->DependentResource);
        OmDereferenceObject(Dependency->ProviderResource);
        LocalFree(Dependency);
    }

    //
    // Remove all entries from the possible owners list.
    //
    while ( !IsListEmpty(&Resource->PossibleOwners) ) {
        ListEntry = RemoveHeadList(&Resource->PossibleOwners);
        possibleEntry = CONTAINING_RECORD( ListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        OmDereferenceObject( possibleEntry->PossibleNode );
        LocalFree(possibleEntry);
    }

    if (!bDeleteObjOnly)
    {
        //
        // Close the resource's registry key.
        //

        DmRundownList( &Resource->DmRundownList );

        if (Resource->RegistryKey != NULL) {
            DmCloseKey( Resource->RegistryKey );
            Resource->RegistryKey = NULL;
        }

        //
        // Decrement resource type reference.
        //
        if ( Resource->Type != NULL ) {
            OmDereferenceObject( Resource->Type );
            Resource->Type = NULL;
        }

        // Let the worker thread peform the 'last' dereference
        FmpPostWorkItem(FM_EVENT_RESOURCE_DELETED, Resource, 0);
        FmpReleaseLocalResourceLock( Resource );

    }
    else
    {
        //the resource being destroyed is from the quorum group
        //This is done at initialization
        FmpReleaseLocalResourceLock( Resource );


        // make sure that all resources except the quorum resource
        // are created completely in the second phase of initialization
        //decrement its ref count here, this is the last ref 
        //SS:: we dont use FM_EVENT_RESOURCE_DELETED here
        //since we want this done synchronously before phase 2 is
        //complete
        OmDereferenceObject(Resource);
        
    }

    //ss: for now we dont use it, so dont delete it
    //DeleteCriticalSection(&Resource->Lock);

    ClRtlLogPrint(LOG_NOISE,
           "[FM] FmpDestroyResource Exit.\n");

    return;

} // FmpDestroyResource



///////////////////////////////////////////////////////////////////////////
//
// Initialization Routines
//
///////////////////////////////////////////////////////////////////////////


BOOL
FmDependentResource(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource,
    IN BOOL ImmediateOnly
    )

/*++

Routine Description:

    Returns indication of whether a resource is a dependent of another
    resource.

Arguments:

    Resource - The resource to scan if it depends on the dependent resource.

    DependentResource - The dependent resource to check on.

    ImmediateOnly - Specifies whether only immediate dependencies should be
        checked. If this is FALSE, this routine recursively checks all
        dependents.

Returns:

    TRUE - The the resource does depend on the dependent resource.

    FALSE - The resource does not depend on the dependent resource.

--*/

{
    PLIST_ENTRY listEntry;
    PDEPENDENCY dependency;
    BOOL    result = FALSE;

    FmpAcquireLocalResourceLock( Resource );

    listEntry = Resource->DependsOn.Flink;
    while ( listEntry != &Resource->DependsOn ) {
        dependency = CONTAINING_RECORD( listEntry,
                                        DEPENDENCY,
                                        DependentLinkage );
        if ( dependency->ProviderResource == DependentResource ) {
            result = TRUE;
            break;
        } else {
            if (!ImmediateOnly) {
                if (FmDependentResource(dependency->ProviderResource,
                                        DependentResource,
                                        FALSE)) {
                    result = TRUE;
                    break;
                }
            }
        }

        listEntry = listEntry->Flink;

    }  // while

    FmpReleaseLocalResourceLock( Resource );

    return(result);

} // FmpDependentResource


DWORD
FmpAddPossibleEntry(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Creates a new possible node entry and adds it to a resource's list.

    If the node is already in the resource's list, it will not be added
    again.

Arguments:

    Resource - Supplies the resource whose node list is to be updated.

    Node - Supplies the node to be added to the resource's list.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    PLIST_ENTRY ListEntry;
    PPOSSIBLE_ENTRY PossibleEntry;

    //
    // First check to see if the node is already in the possible owners list.
    //
    ListEntry = Resource->PossibleOwners.Flink;
    while (ListEntry != &Resource->PossibleOwners) {
        PossibleEntry = CONTAINING_RECORD( ListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        if (PossibleEntry->PossibleNode == Node) {
            //
            // Found a match, it's already here, so return
            // success.
            //
            return(ERROR_SUCCESS);
        }
        ListEntry = ListEntry->Flink;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpAddPossibleEntry: adding node %1!ws! as possible host for resource %2!ws!.\n",
               OmObjectId(Node),
               OmObjectId(Resource));

    PossibleEntry = LocalAlloc(LMEM_FIXED, sizeof(POSSIBLE_ENTRY));
    if (PossibleEntry == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpAddPossibleEntry failed to allocated PossibleEntry\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    OmReferenceObject(Node);
    PossibleEntry->PossibleNode = Node;
    InsertTailList( &Resource->PossibleOwners,
                    &PossibleEntry->PossibleLinkage );

    return(ERROR_SUCCESS);

}


DWORD
FmpAddPossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Adds a node to the resource's list of possible nodes.

    The resource lock must be held.

Arguments:

    Resource - Supplies the resource whose list of nodes is to be updated

    Node - Supplies the node to add to the specified resource's list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    HDMKEY hGroup;
    DWORD Status;

    
    //
    // Allocate the new possible node entry and add it to the list.
    //
    Status = FmpAddPossibleEntry(Resource, Node);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Need to check the group list to see if the specified node
    // can be added to the preferred list now. The easiest way
    // to do that is to simply recreate the entire preferred list,
    // then reprune.
    //
    hGroup = DmOpenKey( DmGroupsKey,
                        OmObjectId(Resource->Group),
                        KEY_READ );
    if (hGroup == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmpAddPossibleNode failed to open group %1!ws! status %2!d!\n",
                    OmObjectId(Resource->Group),
                    Status);

        return(Status);
    }
    Status = FmpQueryGroupNodes(Resource->Group,
                                hGroup);
    CL_ASSERT(Status == ERROR_SUCCESS);
    if (Status == ERROR_SUCCESS) {
        FmpPruneGroupOwners(Resource->Group);
    }
    DmCloseKey(hGroup);


    return(Status);

} // FmpAddPossibleNode


DWORD
FmpRemovePossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL RemoveQuorum
    )
/*++

Routine Description:

    Removes a node from the resource's list of possible nodes.

    The resource lock must be held.

Arguments:

    Resource - Supplies the resource whose list of nodes is to be updated

    Node - Supplies the node to be removed from the specified resource's list.

    RemoveQuorum - TRUE if we can remove node from quorum device.
                   FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PPOSSIBLE_ENTRY PossibleEntry;
    DWORD Status = ERROR_CLUSTER_NODE_NOT_FOUND;

    //
    // If the resource is currently online on the node to be removed,
    // fail the call.
    //
    if ((Resource->Group->OwnerNode == Node) &&
        (Resource->State == ClusterResourceOnline)) {
        return(ERROR_INVALID_STATE);
    }

    //
    // If it is NOT okay to remove this node from the quorum device,
    // and this is the quorum device, then fail the request.
    //
    if ( !RemoveQuorum &&
         Resource->QuorumResource) {
        return(ERROR_INVALID_OPERATION_ON_QUORUM);
    }

    //
    // Find the possible entry on the resource's list.
    //

    ListEntry = Resource->PossibleOwners.Flink;
    while (ListEntry != &Resource->PossibleOwners) {
        PossibleEntry = CONTAINING_RECORD( ListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        ListEntry = ListEntry->Flink;
        if (PossibleEntry->PossibleNode == Node) {
            //
            // Found a match, remove it from the list.
            //
            RemoveEntryList(&PossibleEntry->PossibleLinkage);
            OmDereferenceObject(PossibleEntry->PossibleNode);
            LocalFree(PossibleEntry);

            //
            // Now prune the containing group. This is a little bit
            // of overkill, if we were smarter, we could just
            // remove the node from the preferred list directly.
            //
            FmpPrunePreferredList(Resource);
            Status = ERROR_SUCCESS;
            break;
        }
    }

    return(Status);

} // FmpRemovePossibleNode



DWORD
FmpRemoveResourceDependency(
    HLOCALXSACTION  hXsaction,
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependsOn
    )
/*++

Routine Description:

    Removes a dependency relationship to a given resource. Both
    resources must be in the same group.

Arguments:

    Resource - Supplies the resource which is dependent.

    DependsOn - Supplies the resource that hResource depends on.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD           status;
    HDMKEY          resKey = NULL;
    
    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((Resource->Group != DependsOn->Group) ||
        (Resource == DependsOn)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Remove the dependency from the registry database.
    //
    resKey = DmOpenKey(DmResourcesKey,
                       OmObjectId(Resource),
                       KEY_READ | KEY_SET_VALUE);
    if (resKey == NULL)
    {
        status = GetLastError();
        CL_LOGFAILURE(status);
        goto FnExit;
    }
    else
    {
        status = DmLocalRemoveFromMultiSz(hXsaction,
                                          resKey,
                                          CLUSREG_NAME_RES_DEPENDS_ON,
                                          OmObjectId(DependsOn));
    }

FnExit:
    if ( resKey ) {
        DmCloseKey(resKey);
    }
    return(status);

} // FmpRemoveResourceDependency


DWORD
FmpChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    )
/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    pResource - Supplies the resource to move.

    pNewGroup - Supplies the new group that the resource should be in.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD               dwBufSize;
    LPCWSTR             pszResourceId;
    DWORD               dwResourceLen;
    LPCWSTR             pszGroupId;
    DWORD               dwGroupLen;
    DWORD               dwStatus;
    PGUM_CHANGE_GROUP   pGumChange;

    // we need to validate here as well
    // this is called by the server side
    // this will help avoid a gum call if things have changed
    // since the request started from the originator
    // and got to the server

    //
    // Check if we're moving to same group.
    //
    if (pResource->Group == pNewGroup) {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //
    // For now... both Groups must be owned by the same node.
    //
    if ( pResource->Group->OwnerNode != pNewGroup->OwnerNode ) {
        dwStatus = ERROR_HOST_NODE_NOT_GROUP_OWNER;
        goto FnExit;
    }


    pszResourceId = OmObjectId(pResource);
    dwResourceLen = (lstrlenW(pszResourceId)+1)*sizeof(WCHAR);

    pszGroupId = OmObjectId(pNewGroup);
    dwGroupLen = (lstrlenW(pszGroupId)+1)*sizeof(WCHAR);

    dwBufSize = sizeof(GUM_CHANGE_GROUP) - sizeof(WCHAR) + dwResourceLen + dwGroupLen;
    pGumChange = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pGumChange == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    pGumChange->ResourceIdLen = dwResourceLen;
    CopyMemory(pGumChange->ResourceId, pszResourceId, dwResourceLen);
    CopyMemory((PCHAR)pGumChange->ResourceId + dwResourceLen,
               pszGroupId,
               dwGroupLen);
    dwStatus = GumSendUpdate(GumUpdateFailoverManager,
                           FmUpdateChangeGroup,
                           dwBufSize,
                           pGumChange);
    LocalFree(pGumChange);

FnExit:
    return(dwStatus);
}// FmpChangeResourceGroup


DWORD
FmpClusterEventPropHandler(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Post a worker item to process a cluster name change.

Arguments:

    pResource - pointer to the resouce which is affected by the cluster
                property change.

Return Value:


    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    PFM_RESTYPE pResType;
    DWORD       dwError=ERROR_SUCCESS;

    pResType = pResource->Type;

    if ((pResource->ExFlags & CLUS_FLAG_CORE) &&
       ( !lstrcmpiW(OmObjectId(pResType), CLUS_RESTYPE_NAME_NETNAME)))
    {
        FmResourceControl(pResource, NmLocalNode,
           CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED, NULL, 0, NULL, 0, NULL, NULL);

    }
    return (dwError);

} // FmpClusterEventPropHandler



BOOL
FmpEnumResourceNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource enumeration callback for removing node references when
    a node is evicted.

Arguments:

    Context1 - Supplies the node that is being evicted.

    Context2 - not used

    Object - Supplies a pointer to the resource object

    Name - Supplies the resource's object name.

Return Value:

    TRUE to continue enumeration

--*/

{
    PFM_RESOURCE Resource = (PFM_RESOURCE)Object;
    PNM_NODE Node = (PNM_NODE)Context1;
    PLIST_ENTRY      listEntry;
    PPOSSIBLE_ENTRY possibleEntry;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] EnumResourceNodeEvict: Removing references to node %1!ws! from resource %2!ws!\n",
               OmObjectId(Node),
               OmObjectId(Resource));
               
    FmpAcquireLocalResourceLock(Resource);
    FmpRemovePossibleNode(Resource, Node, TRUE);
    FmpReleaseLocalResourceLock(Resource);
    //
    // Notify the resource of the removal of the node.
    //
    FmpRmResourceControl( Resource,
                          CLUSCTL_RESOURCE_EVICT_NODE,
                          (PUCHAR)OmObjectId(Node),
                          ((lstrlenW(OmObjectId(Node)) + 1) * sizeof(WCHAR)),
                          NULL,
                          0,
                          NULL,
                          NULL );
    // Ignore status return

    ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, Resource );

    return(TRUE);

} // FmpEnumResourceNodeEvict



DWORD
FmpPrepareQuorumResChange(
    IN PFM_RESOURCE pNewQuoRes,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    )

/*++

Routine Description:

    This routine prepares for a quorum resource change operation.

Arguments:

    pNewQuoRes - pointer to the new quorum resource.

    lpszQuoLogPath - pointer to the quorum log path string name.

    dwMaxQuoLogSize - the maximum size of the quorum log path string.

--*/

{

    CL_ASSERT(pNewQuoRes->Group->OwnerNode == NmLocalNode);

    return(DmPrepareQuorumResChange(pNewQuoRes, lpszQuoLogPath, dwMaxQuoLogSize));

} // FmpPrepareQuorumResChange


DWORD
FmpCompleteQuorumResChange(
    IN LPCWSTR      lpszOldQuoResId,
    IN LPCWSTR      lpszQuoLogPath
    )

/*++

Routine Description:

    This routine is called if the new quorum log path is not the same as the old
    quorum log path.  This completes the change of quorum resource by deleting the old
    quorum log files and creating a tompstone for them.  A node that tries to do a form
    with this as the quorum resource is prevented and has to do a join to get the location
    of the new quorum resource and quorum log file.

Arguments:

    pOldQuoRes - pointer to the new quorum resource.

    lpszOldQuoLogPath - pointer to the quorum log path string name.

    dwMaxQuoLogSize - the maximum size of the quorum log path string.

--*/

{

    return(DmCompleteQuorumResChange(lpszOldQuoResId, lpszQuoLogPath));

} // FmpCompleteQuorumResChange



VOID
FmpResourceLastReference(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Last dereference to resource object processing routine.
    All cleanup for a resource should really be done here!

Arguments:

    Resource - pointer the resource being removed.

Return Value:

    None.

--*/

{
    if ( Resource->DebugPrefix != NULL )
        LocalFree(Resource->DebugPrefix);
    if (Resource->Dependencies)
        LocalFree(Resource->Dependencies);
    if ( Resource->Group ) {
        OmDereferenceObject(Resource->Group);
    }
    if (Resource->Type)
        OmDereferenceObject(Resource->Type);
    return;

} // FmpResourceLastReference



BOOL
FmpCheckNetworkDependencyWorker(
    IN LPCWSTR DependentNetwork,
    OUT PBOOL FoundDependency,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Enumeration callback routine for finding an IP Address resource
    and checking its dependency on given network guid.

Arguments:

    DependentNetwork - The GUID of the network to check for a dependency.

    FoundDependency - Returns TRUE if a dependency is found.

    Resource - Supplies the current resource.

    Name - Supplies the current resource's name.

Return Value:

    TRUE - to continue searching

    FALSE - to stop the search. The matching resource is returned in
        *FoundResource

Notes:

    The IP Address resource's parameters are searched directly by this
    routine. Fetching them from the resource itself causes a deadlock.
    This routine is called by the NM from within a global udpate
    handler. The resource would have to call back into the cluster registry
    routines, which would deadlock over the GUM lock.

--*/

{
    BOOL    returnValue = TRUE;


    if ( lstrcmpiW(
             OmObjectId(Resource->Type),
             CLUS_RESTYPE_NAME_IPADDR
             ) == 0
       )
    {
        LPCWSTR resourceId = OmObjectId(Resource);
        DWORD   status;
        HDMKEY  resourceKey = DmOpenKey(DmResourcesKey, resourceId, KEY_READ);

        if (resourceKey != NULL) {
            HDMKEY  paramsKey = DmOpenKey(
                                    resourceKey,
                                    L"Parameters",
                                    KEY_READ
                                    );

            if (paramsKey != NULL) {
                LPWSTR  networkId = NULL;
                DWORD   valueLength = 0, valueSize = 0;

                status = DmQueryString(
                             paramsKey,
                             L"Network",
                             REG_SZ,
                             &networkId,
                             &valueLength,
                             &valueSize
                             );

                if (status == ERROR_SUCCESS) {

                    if ( lstrcmpiW( networkId, DependentNetwork ) == 0 ) {
                        *FoundDependency = TRUE;
                        returnValue = FALSE;
                    }

                    LocalFree(networkId);
                }
                else {
                    ClRtlLogPrint(LOG_WARNING, 
                        "[NM] Query of Network value failed for ip addr resource %1!ws!, status %2!u!.\n",
                        resourceId,
                        status
                        );
                }

                DmCloseKey(paramsKey);
            }
            else {
                status = GetLastError();
                ClRtlLogPrint(LOG_WARNING, 
                    "[FM] Failed to open params key for resource %1!ws!, status %2!u!\n",
                    resourceId,
                    status
                    );
            }

            DmCloseKey(resourceKey);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_WARNING, 
                "[FM] Failed to open key for resource %1!ws!, status %2!u!\n",
                resourceId,
                status
                );
        }
    }

    return(returnValue);

} // FmpCheckNetworkDependencyWorker

//lock must be held when this routine is called
DWORD FmpChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR NodeId,
    IN BOOL Add

    )
{
    PGUM_CHANGE_POSSIBLE_NODE GumChange;
    LPCWSTR ResourceId;
    DWORD   ResourceLen;
    DWORD   NodeLen;
    DWORD   BufSize;
    DWORD   Status;
    PLIST_ENTRY pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    BOOL    bNodeSupportsResType = FALSE;
    BOOL    bRecalc = TRUE;
    PPOSSIBLE_ENTRY PossibleEntry;
    PNM_NODE    pNode = NULL;

    if ( Resource->QuorumResource ) {
        Status = ERROR_INVALID_OPERATION_ON_QUORUM;
        goto FnExit;
    }

    //
    // We can't allow the owner node to be removed if the state
    // of the resource or the group is not offline or failed.
    //
    if ( !Add &&
         (NodeId == OmObjectId(NmLocalNode)) &&
         (((Resource->State != ClusterResourceOffline) &&
            (Resource->State != ClusterResourceFailed)) ||
         (FmpGetGroupState( Resource->Group, TRUE ) != ClusterGroupOffline)) ) {
        Status = ERROR_INVALID_STATE;
        goto FnExit;
    }

    //make sure the node is on the list of possible nodes for this
    // resource type
    if (Add)
    {
        //if it is already on the list, return an error and dont
        //send a gum update call
        
        pNode = OmReferenceObjectById(ObjectTypeNode, NodeId);
        pListEntry = Resource->PossibleOwners.Flink;
        while (pListEntry != &Resource->PossibleOwners) {
            PossibleEntry = CONTAINING_RECORD( pListEntry,
                                               POSSIBLE_ENTRY,
                                               PossibleLinkage );
            if (PossibleEntry->PossibleNode == pNode) {
                //
                // Found a match, fail the duplicate add. Note that
                // we must fail here, not succeed, so that the API
                // layer knows not to add a duplicate to the registry.
                //
                Status = ERROR_OBJECT_ALREADY_EXISTS;
                goto FnExit;
            }
            pListEntry = pListEntry->Flink;
        }
        
ChkResTypeList:
        pListEntry = &(Resource->Type->PossibleNodeList);
        for (pListEntry = pListEntry->Flink; 
            pListEntry != &(Resource->Type->PossibleNodeList);
            pListEntry = pListEntry->Flink)
        {    

            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

            if (!lstrcmpW(OmObjectId(pResTypePosEntry->PossibleNode), NodeId))
            {
                bNodeSupportsResType = TRUE;
                break;
            }            
                    
        }    

        if (!bNodeSupportsResType  && bRecalc)
        {
            //if th node is not found, recalc again and retry..since then the
            //dll might have been copied to this node
            FmpSetPossibleNodeForResType(OmObjectId(Resource->Type), TRUE);
            bRecalc = FALSE;
            goto ChkResTypeList;
        }
        if (!bNodeSupportsResType)
        {
            Status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }
    }
    
    ResourceId = OmObjectId(Resource);
    ResourceLen = (lstrlenW(ResourceId)+1)*sizeof(WCHAR);

    NodeLen = (lstrlenW(NodeId)+1)*sizeof(WCHAR);

    BufSize = sizeof(GUM_CHANGE_POSSIBLE_NODE) - sizeof(WCHAR) + ResourceLen + NodeLen;
    GumChange = LocalAlloc(LMEM_FIXED, BufSize);
    if (GumChange == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    GumChange->ResourceIdLen = ResourceLen;
    CopyMemory(GumChange->ResourceId, ResourceId, ResourceLen);
    CopyMemory((PCHAR)GumChange->ResourceId + ResourceLen,
               NodeId,
               NodeLen);

    Status = GumSendUpdate(GumUpdateFailoverManager,
                       Add ? FmUpdateAddPossibleNode : FmUpdateRemovePossibleNode,
                       BufSize,
                       GumChange);
    LocalFree(GumChange);

FnExit:
    if (pNode) 
        OmDereferenceObject(pNode);
    return(Status);

}



BOOL
FmpCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    )

/*++

Routine Description:

    Checks for an IP Address resource that may be dependent on the given
    Network.

Arguments:

    DependentNetwork - the dependent network to check for.

Returns:

    TRUE - if an IP Address depends on the given network.
    FALSE otherwise.

--*/

{
    BOOL    dependent = FALSE;

    OmEnumObjects(ObjectTypeResource,
                  (OM_ENUM_OBJECT_ROUTINE)FmpCheckNetworkDependencyWorker,
                  (PVOID)DependentNetwork,
                  &dependent);

    return(dependent);

} // FmpCheckNetworkDependency

/****
@func       DWORD | FmpFixupPossibleNodesForResources| This fixes the possible
            node information for a resource based on whether this node
            supports the given resource type.

@parm       IN BOOL| bJoin | If this node is joining, bJoin is set to TRUE.

@comm       This routine iterates thru all the resources in a system and fixes
            their possible node information.  If this node is not on the possible
            node list for the resource type corresponding to the resource, it
            is also removed from the possible node list for the resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpEnumFixupPossibleNodeForResource>
****/
DWORD
FmpFixupPossibleNodesForResources(
    BOOL    bJoin
    )
{
    DWORD       dwStatus=ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupPossibleNodesForResources Entry.\n");

    //
    // Fix up all resources's possible node list information
    //
    OmEnumObjects( ObjectTypeResource,
                   FmpEnumFixupPossibleNodesForResource,
                   NULL,
                   NULL);


    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupPossibleNodesForResources Exit\r\n");

    return(dwStatus);

} // FmpFixupPossibleNodesForResources

/****
@func       DWORD | FmpEnumFixupPossibleNodesForResource | This is the enumeration
            callback for every resource type to fix the possible node
            information related with it.

@parm       IN PVOID | pContext1 | Not used.
@parm       IN PVOID | pContext2 | Not Used.
@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type object.
@parm       IN LPCWSTR | pszResTypeName | The name of the resource type.

@comm       This routine iterates thru all the resources in a system and fixes
            their possible node information.  If this node is not on the possible
            node list for the resource type corresponding to the resource, it
            is also removed from the possible node list for the resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpFixupPossibleNodesForResources>
****/
BOOL
FmpEnumFixupPossibleNodesForResource(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      pszResName
    )
{


    //if we are on the possible node list for the
    //resource but not for the resource type, remove it
    //from the possible node for the resource as well.
    //We do this because the join logic adds all nodes
    //as possible owners for a resource and we have
    //the rolling upgrade requirements - hence the fixups
    //have to be made later on
    if ((FmpInPossibleListForResource(pResource, NmLocalNode)) &&
        !(FmpInPossibleListForResType(pResource->Type, NmLocalNode)))
    {
        //if we dont support this resource type, make sure it is not on the possible node
        //list for a resource of this type
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpEnumFixupPossibleNode:remove local node for  resource %1!ws!\r\n",
                   OmObjectId(pResource));
        //we send a gum update to remove it from all nodes
        FmChangeResourceNode(pResource, NmLocalNode, FALSE);
    }

    //we add ourselves on the list only on a fresh install
    //not on an upgrade
    //csfirst run is also true on an upgrade, hence we need to
    //check that csupgrade is false
    if ((!FmpInPossibleListForResource(pResource, NmLocalNode)) &&
        (FmpInPossibleListForResType(pResource->Type, NmLocalNode))
        && CsFirstRun && !CsUpgrade)
    {
        //if we support a resource of this type, but we are not on the possible 
        //list for this resource, then add the local node to the possible list
        //this may happen because on a setup join the other nodes may not 
        //add us because the possible node list exists.  The possible node list
        //may exist either because the user set it or we internally set it due
        //to non availability of this resource type dll on one of the nodes
        //Note that irrespective of whether the user had set the possible list
        //or we set it internally, we always add a new node that joins 
        //to the possible node list of resources that are supported.
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpEnumFixupPossibleNode:add local node for  resource %1!ws!\r\n",
                   OmObjectId(pResource));
        //we send a gum update to add it from all nodes
        FmChangeResourceNode(pResource, NmLocalNode, TRUE);
    }
    //continue enumeration
    return (TRUE);
}


DWORD FmpCleanupPossibleNodeList(
    IN PFM_RESOURCE pResource)
{

    PLIST_ENTRY     pListEntry;
    PPOSSIBLE_ENTRY pPossibleEntry;
    DWORD           dwStatus = ERROR_SUCCESS;

    //for all possible nodes for this resource, check if the resource type
    //supports it.  If it doesnt, then remove that node from the in memory list
    pListEntry = pResource->PossibleOwners.Flink;
    while (pListEntry != &pResource->PossibleOwners) 
    {
        //get the possible entry at this link
        pPossibleEntry = CONTAINING_RECORD( pListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        //save the pointer to the next link                                           
        pListEntry = pListEntry->Flink;
                                           
        if (!FmpInPossibleListForResType(pResource->Type, 
                        pPossibleEntry->PossibleNode))
        {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpCleanupPossibleNodeList:remove local node %1!u! for  resource %2!ws!\r\n",
                   NmGetNodeId(pPossibleEntry->PossibleNode), OmObjectId(pResource));
            FmChangeResourceNode(pResource, pPossibleEntry->PossibleNode,
                    FALSE);
        }
    }

    return (dwStatus);
}


/****
@func       DWORD | FmpInPossibleListForResource| This checks if a given node 
            is in the possible list of nodes for a resource.

@parm       IN PFM_RESOURCE | pResource | A pointer to the the resource.
@parm       IN PNM_NODE | pNode | A pointer to the node object.

@comm       This routine check if a node is in the list of possible nodes
            for this resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpInPossibleListForResType>
****/
BOOL
FmpInPossibleListForResource(
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode
    )
{
    PLIST_ENTRY         plistEntry;
    PPOSSIBLE_ENTRY     pPossibleEntry;

    //see if this node is on the possible node list for the resource
    for ( plistEntry = pResource->PossibleOwners.Flink;
          plistEntry != &(pResource->PossibleOwners);
          plistEntry = plistEntry->Flink ) {

        pPossibleEntry = CONTAINING_RECORD( plistEntry,
                                            POSSIBLE_ENTRY,
                                            PossibleLinkage );
        if ( pPossibleEntry->PossibleNode == pNode ) {
            return(TRUE);
        }
    }

    return(FALSE);

} // FmpInPossibleListForResource


/****
@func       DWORD | FmpInPossibleListForResType| This checks if a given node 
            is in the possible list of nodes for a resource type.

@parm       IN PFM_RESTYPE| pResType | A pointer to the the resource type.
@parm       IN PNM_NODE | pNode | A pointer to the node object.

@comm       This routine check if a node is in the list of possible nodes
            for this resource type.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpInPossibleListForResource>
****/
BOOL
FmpInPossibleListForResType(
    IN PFM_RESTYPE pResType,
    IN PNM_NODE     pNode
    )
{
    PLIST_ENTRY         pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;

    ACQUIRE_SHARED_LOCK(gResTypeLock);
    
    //see if this node is on the possible node list for the resource
    for ( pListEntry = pResType->PossibleNodeList.Flink;
          pListEntry != &(pResType->PossibleNodeList);
          pListEntry = pListEntry->Flink ) 
    {

        pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

        if ( pResTypePosEntry->PossibleNode == pNode ) 
        {
            RELEASE_LOCK(gResTypeLock);
            return(TRUE);
        }
    }
    RELEASE_LOCK(gResTypeLock);
    return(FALSE);

} // FmpInPossibleListForResType

DWORD
FmpValAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Add a dependency from one resource to another.

Arguments:

    Resource - The resource to add the dependent resource.

    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    //
    // If the resource or dependent resource have been marked for 
    // delete, then dont let a dependency be added.
    //
    if ((!IS_VALID_FM_RESOURCE(pResource)) ||
        (!IS_VALID_FM_RESOURCE(pDependentResource)))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if (pResource->QuorumResource)
    {
        dwStatus = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }
    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((pResource->Group != pDependentResource->Group) ||
        (pResource == pDependentResource)) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // The resource to which the dependency is being added must be offline
    // Otherwise, it looks like the dependency is in effect when the depending
    // resource was not really brought online at the time the dependency 
    // existed
    // must also be offline or failed.
    // SS:  For instance if a network name is dependent on two ip addresesses 
    // and
    // is online and a third ip address resource dependency is added, the
    // network name must be brought offline and online for the dependency
    // to be truly in effect
    //
    if ((pResource->State != ClusterResourceOffline) &&
         (pResource->State != ClusterResourceFailed)) 
    {
        dwStatus = ERROR_RESOURCE_ONLINE;
        goto FnExit;
    }

    //
    // Make sure that we don't have any circular dependencies!
    //
    if ( FmDependentResource( pDependentResource, pResource, FALSE ) ) 
    {
        dwStatus = ERROR_CIRCULAR_DEPENDENCY;
        goto FnExit;
    }

    //
    // Make sure that this dependency does not already exist!
    //
    if ( FmDependentResource(pResource, pDependentResource, TRUE)) 
    {
        dwStatus = ERROR_DEPENDENCY_ALREADY_EXISTS;
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpValAddResourceDependency


DWORD
FmpValRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Validation routine for dependency removal.

Arguments:

    pResource - The resource to remove the dependent resource.

    pDependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 8/3/99
    //   
    //  This function checks whether it is legal to remove the dependency
    //  relationship between 2 resources. Note that this function only
    //  does a partial validation, the rest is done in the GUM handler.
    //
    
    //
    //  If the resource has been marked for delete, then dont 
    //  let any dependency changes be made.
    //
    if ( !IS_VALID_FM_RESOURCE( pResource ) )
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( pResource->QuorumResource )
    {
        dwStatus = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }
    //
    //  If the resources are not in the same group, fail the
    //  call. Also fail if some one tries to make a resource
    //  dependent upon itself.
    //
    if ( ( pResource->Group != pDependentResource->Group ) ||
         ( pResource == pDependentResource ) ) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    //  Ensure that both the resource and the dependent resource are in
    //  a stable state. This is necessary to prevent cases in which the
    //  user gets rid of a dependency link when one of the resources is in
    //  a pending state and later when the notification from resmon comes
    //  in and you try to stablize the rest of the waiting tree, the 
    //  dependency link is already cut and so the rest of the tree is
    //  stuck in pending state for ever !
    //
    if ( ( pResource->State > ClusterResourcePending ) ||
         ( pDependentResource->State > ClusterResourcePending ) ) 
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }

FnExit:
    return( dwStatus );

} // FmpValRemoveResourceDependency
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\resmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resmon.c

Abstract:

    Cluster resource manager interface routines for the resource monitor.

Author:

    Rod Gamache (rodga) 17-Apr-1996


Notes:

    WARNING: All of the routines in this file assume that the resource
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE RESMONF

//
// Global Data
//

//
// Local function prototypes
//



/////////////////////////////////////////////////////////////////////////////
//
// Resource Control Routines (via Resource Monitor)
//
/////////////////////////////////////////////////////////////////////////////

DWORD
FmpRmExceptionFilter(
    DWORD ExceptionCode
    )

/*++

Routine Description:

    Exception filter for calls to the Resource Monitor. These calls will
    often raise an exception if the RPC path to the Resource Monitor fails.

Arguments:

    ExceptionCode - the exception to process.

Returns:

    EXCEPTION_EXECUTE_HANDLE if the exception handler should handle this failure
    EXCEPTION_CONTINUE_SEARCH if the exception is a fatal exception and the handler 
    should not handle it.

--*/

{
    ClRtlLogPrint(LOG_UNUSUAL,
                 "[FM] FmpRmExceptionFilter: Unusual exception %1!u! occurred.\n",
                 ExceptionCode);
    return(I_RpcExceptionFilter(ExceptionCode));
} // FmpRmExceptionFilter



DWORD
FmpRmCreateResource(
    PFM_RESOURCE     Resource
    )

/*++

Routine Description:

    Add a resource to the list of resources managed by the resource monitor.

Arguments:

    Resource - The resource to add.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD       status;
    PRESMON     monitor;
    LPWSTR      debugPrefix;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmCreateResource: creating resource %1!ws! in %2!ws! resource monitor\n",
               OmObjectId(Resource),
               Resource->Flags & RESOURCE_SEPARATE_MONITOR ?
                L"separate" : L"shared");

    if (Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
        if ( Resource->DebugPrefix != NULL ) {
            debugPrefix = Resource->DebugPrefix;
        } else {
            debugPrefix = Resource->Type->DebugPrefix;
        }
        Resource->Monitor = FmpCreateMonitor(debugPrefix, TRUE);
        if (Resource->Monitor == NULL) {
            return(GetLastError());
        }
    } else {
        CL_ASSERT(FmpDefaultMonitor != NULL);
        Resource->Monitor = FmpDefaultMonitor;
    }

    try {
        Resource->Id = RmCreateResource(Resource->Monitor->Binding,
                                        Resource->Type->DllName,
                                        OmObjectId(Resource->Type),
                                        OmObjectId(Resource),
                                        Resource->LooksAlivePollInterval,
                                        Resource->IsAlivePollInterval,
                                        (RM_NOTIFY_KEY)Resource,
                                        Resource->PendingTimeout,
                                        &status);
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD code = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,"[FM] RmCreateResource issued exception %1!u!\n", code);

        //
        // Stop this resource monitor if it is a separate resource monitor.
        //
        if (Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
            monitor = Resource->Monitor;
#if 0
            CL_ASSERT( monitor->NotifyThread != NULL );
            CL_ASSERT( monitor->Process != NULL );

            // Terminate Thread call removed: ( monitor->NotifyThread, 1 );
            CloseHandle( monitor->NotifyThread );

            TerminateProcess( monitor->Process, 1 );
            LocalFree( monitor );
#endif
            FmpShutdownMonitor( monitor );
        }

        Resource->Monitor = NULL;
        return(code);
    }

    if (Resource->Id != 0) {
        Resource->Flags |= RESOURCE_CREATED;
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmCreateResource: created resource %1!ws!, resid %2!u!\n",
                   OmObjectId(Resource),
                   Resource->Id);

        return(ERROR_SUCCESS);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmCreateResource: unable to create resource %1!ws!\n",
               OmObjectId(Resource));
    //
    // Stop this resource monitor if it is a separate resource monitor.
    //
    if (Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
        monitor = Resource->Monitor;
#if 0
        CL_ASSERT( monitor->NotifyThread != NULL );
        CL_ASSERT( monitor->Process != NULL );

        // Terminate Thread call removed: ( monitor->NotifyThread, 1 );
        CloseHandle( monitor->NotifyThread );

        TerminateProcess( monitor->Process, 1 );
        LocalFree( monitor );
#endif
        FmpShutdownMonitor( monitor );
    }

    Resource->Monitor = NULL;
    return(status);

} // FmpRmCreateResource



DWORD
FmpRmOnlineResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine requests the Resource Monitor to bring a resource online.

Arguments:

    Resource - A pointer to the resource to bring online.

Comments :
    If this is the quorum resource, the exclusive quorum lock should be 
    held when this routine is called.  Else the quorum lock should be held
    in shared mode.  This routine release the lock.
    
Returns:

    ERROR_SUCCESS - if the request was successful.
    ERROR_IO_PENDING - if the request is pending.
    A Win32 error if the request failed.

--*/

{
    CLUSTER_RESOURCE_STATE  state;
    DWORD                   Status=ERROR_SUCCESS;
    DWORD                   retry = 200;

#if 0
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );
    ClRtlLogPrint(LOG_NOISE,
               "[FM] RmOnlineResource for <%1!ws!> called from %2!lx! and %3!lx!\n",
               OmObjectId( Resource ),
               callersAddress, callersCaller );
#endif
    if ( Resource->State > ClusterResourcePending ) {
        Status = ERROR_IO_PENDING;
        return(Status);
    }

    if ( Resource->State == ClusterResourceOnline ) {
        Status = ERROR_SUCCESS;
        return(Status);
    }


    CL_ASSERT((Resource->State == ClusterResourceOffline) ||
              (Resource->State == ClusterResourceFailed));

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmOnlineResource: bringing resource %1!ws! (resid %2!u!) online.\n",
               OmObjectId(Resource),
               Resource->Id);

    //if this is the quorum resource acquire the quolock
    // For registry replication to work, the resource should
    // not be brought online while the quorum resource is offline
    // what do we do for fixquorum mode

    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREONLINE);

    //SS:initialize state so that in case of a failure, a failed state is
    // propagated.
    state = ClusterResourceFailed;

CheckQuorumState:    

    //CL_ASSERT( (LONG)gdwQuoBlockingResources >= 0 );


    if (Resource->QuorumResource) {
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);

    } else {
        DWORD     dwOldBlockingFlag;

        ACQUIRE_SHARED_LOCK(gQuoLock);

        // if it is not the quorum resource,
        // check the state of the quorum resource
        
        // check if the quorum resource is failed
        // we must exit from here and let the recovery for the
        // quorum resource to kick in
        if (gpQuoResource->State == ClusterResourceFailed)
        {
            Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //we dont halt, we will try online again at a later time
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            goto FnExit;

        }

        // check if the quorum resource is online,
        // if the quorum resource is marked as waiting and offlinepending,
        // it is actually online
        // if the quorum resource still needs to come online
        // release the lock and wait
        if (((gpQuoResource->State != ClusterResourceOnline) &&
              ((gpQuoResource->State != ClusterResourceOfflinePending) ||
               (!(gpQuoResource->Flags & RESOURCE_WAITING))))
            && !CsNoQuorum) 
        {
            // we release the lock here since the quorum resource
            // state transition from pending needs to acquire the lock
            // In general it is a bad idea to do a wait holding locks
            RELEASE_LOCK(gQuoLock);
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmOnlineResource: release quolock/group lock and wait on ghQuoOnlineEvent\r\n");
            Status = WaitForSingleObject(ghQuoOnlineEvent, 500);
            if ( Status == WAIT_OBJECT_0 ) {
                // If we're going to retry - make sure we wait a little.
                Sleep( 500 );
            }
            if ( retry-- ) {
                goto CheckQuorumState;
            }
#if DBG
            if ( IsDebuggerPresent() ) {
                DbgBreakPoint();
            }
#endif
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //we dont halt, we will try online again at a later time
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            return(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //CsInconsistencyHalt(ERROR_INVALID_STATE);
        }

        //
        // assume that we'll be pending... mark the resource as having
        // bumped the QuoBlockResource count.
        //
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmOnlineResource: called InterlockedIncrement on gdwQuoBlockingResources for resource %1!ws!\n",
                OmObjectId(Resource));

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 1 );
        CL_ASSERT( dwOldBlockingFlag == 0 );
                    
        InterlockedIncrement(&gdwQuoBlockingResources);

        //
        // everything is now fine on the local node... if any other
        // component (CP) needs to synchronize with the quorum resource, then
        // should acquire the shared lock on the quorum node as part of
        // their operation. If that fails, then they should assume the quorum
        // resource moved, and they should retry.
        //
    }

    // By now we have either the shared or the exclusive lock on the
    // quorum resource.
    // If we have the shared lock then the quorum resource is online(somewhere).
    // Unlesss there is a failure, it should not go offline.



    Status = ERROR_SUCCESS;
    if (Resource->QuorumResource) {
        Status = FmpRmArbitrateResource( Resource );
    }
    if (Status == ERROR_SUCCESS) {
        Status = RmOnlineResource( Resource->Id, 
                                   (LPDWORD)&state  // cast to quiet win64 warning
                                 );
        if (Resource->QuorumResource && Status != ERROR_SUCCESS) {
            MMSetQuorumOwner( MM_INVALID_NODE , /* Block = */ FALSE, NULL );
        }
    }
        
    FmpCallResourceNotifyCb(Resource, state);

    //SS: the synchronous state propagation must happen when it goes offline
    FmpPropagateResourceState( Resource, state );

    //
    // Cleanup for the non-quorum resource case.
    //
    if ( !Resource->QuorumResource &&
         Resource->State < ClusterResourcePending ) {
        DWORD     dwOldBlockingFlag;

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );
        if ( dwOldBlockingFlag ) {
            //
            // If the Transition Thread processed the request, then we can't
            // perform the decrement.
            //
            ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpRmOnlineResource: InterlockedDecrement on gdwQuoBlockingResources for resource %1!ws!\n",
                    OmObjectId(Resource));
                    
            InterlockedDecrement(&gdwQuoBlockingResources);
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmOnlineResource: RmOnlineResource Failed. Resource %1!ws!, status %2!u!\n",
            OmObjectId(Resource),
            Status);
    }

    //if RmOnlineResource is successful, do the post processing
    if ( Resource->State == ClusterResourceOnline ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOnlineResource: %1!ws! is now online\n",
                   OmObjectId(Resource));
        //if this is the quorum resource and it goes into online state
        //immediately, wake other threads
        if (Resource->QuorumResource)
            SetEvent(ghQuoOnlineEvent);

    } else if ( Resource->State > ClusterResourcePending ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOnlineResource: Resource %1!ws! pending\n",
                   OmObjectId(Resource));
                //SS: what should we tell the callbacks
                //FmpNotifyResourceCb(Resource,??);
                //will they eventually get called if so how ?
        if (Resource->QuorumResource)
        {
            //the quorum resource is coming online, unsignal the event so that 
            //all threads that need quorum resource to be online will block
            ResetEvent(ghQuoOnlineEvent);
        }
        Status  = ERROR_IO_PENDING;
    } else {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOnlineResource: Failed. Resource %1!ws!, state %2!u!\n",
                   OmObjectId(Resource),
                   Resource->State);
        //
        // rjain: for a synchronous resource we must post RESOURCE_FAILED event 
        // so thatfailback policies are correctly followed
        // Also pretend that the old state to be online to actually force the 
        // restart behaviour. See: FmpProcessResourceEvents.
        //
        OmReferenceObject(Resource);
        FmpPostWorkItem(FM_EVENT_RES_RESOURCE_FAILED,
                        Resource,
                        ClusterResourceOnline);    
        Status = ERROR_RESMON_ONLINE_FAILED;      
    }

FnExit:
    RELEASE_LOCK(gQuoLock);
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmOnlineResource: Returning. Resource %1!ws!, state %2!u!, status %3!u!.\n",
               OmObjectId(Resource),
               Resource->State,
               Status);
    return (Status);

} // FmpRmOnlineResource



VOID
FmpRmTerminateResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Terminates (immediately) a resource.

Arguments:

    Resource - A pointer to the resource to terminate.

Returns:

    None.

--*/

{
    DWORD   dwOldBlockingFlag;


    //notify callbacks that need preprocessing before a resource is
    //brought offline-call this here since all resources may not go
    //thru the offline pending transition
    //SS - what if the resource never even goes to offline
    //pending state - then should we renotify the callbacks that it
    //is still online?
    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREOFFLINE);

    //
    // Try to terminate the resource.
    //
    try {
        if (Resource->QuorumResource) {
            MMSetQuorumOwner( MM_INVALID_NODE, /* Block = */ FALSE, NULL ); 
        }
        RmTerminateResource(Resource->Id);

        // if FmpRmterminate was called for a failed resource, mark  
        // the resource as Failed and not Offline.
        if (Resource->State == ClusterResourceFailed)
        {
            FmpCallResourceNotifyCb(Resource, ClusterResourceFailed);
            FmpPropagateResourceState( Resource, ClusterResourceFailed );
        }

        else
        {
            FmpCallResourceNotifyCb(Resource, ClusterResourceOffline);
            FmpPropagateResourceState( Resource, ClusterResourceOffline );
        }
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD code = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,"[FM] RmTerminateResource issued exception %1!u!\n", code);

        return;
    }

    //if terminate was called during a pending state, this resource may be
    //blocking the quorum resource, decrement the blocking count
    dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );

    if ( dwOldBlockingFlag ) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmTerminateResource: InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                OmObjectId(Resource));
        InterlockedDecrement(&gdwQuoBlockingResources);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] RmTerminateResource: %1!ws! is now offline\n",
               OmObjectId(Resource));

    return;

} // FmpRmTerminateResource



DWORD
FmpRmOfflineResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Calls the Resource Monitor to take a resource offline.

Arguments:

    Resource - A pointer to the resource to terminate.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    Win32 error code on failure.

--*/

{
    CLUSTER_RESOURCE_STATE  state;
    DWORD                   status;
    DWORD                   retry = 200;

#if DBG
    PLIST_ENTRY listEntry;
#endif

    if ( Resource->State > ClusterResourcePending ) {
        ClRtlLogPrint(LOG_NOISE,"[FM] FmpRmOfflineResource: pending condition\n");
        return(ERROR_IO_PENDING);
    }

    CL_ASSERT(Resource->State != ClusterResourceOffline);

#if DBG
    // everything else in the same group must be offline if this is the
    // quorum resource
    if ( Resource->QuorumResource ) {
        PFM_GROUP group = Resource->Group;
        PFM_RESOURCE resource;

        for ( listEntry = group->Contains.Flink;
              listEntry != &(group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry,
                                         FM_RESOURCE,
                                         ContainsLinkage );
            if ( (Resource != resource) &&
                 (resource->State != ClusterResourceOffline) &&
                 (resource->State != ClusterResourceFailed) &&
                 (resource->State != ClusterResourceOfflinePending) ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] RmOfflineResource: resource <%1!ws!> not offline when the quorum resource was shutting down.\n",
                           OmObjectId(resource));
                CsInconsistencyHalt(ERROR_INVALID_STATE);
            }
        }
    } else {
        // this is not the quorum resource... but if the quorum resource is in
        // this group, it must not be offline!
        PFM_GROUP group = Resource->Group;
        PFM_RESOURCE resource;

        for ( listEntry = group->Contains.Flink;
              listEntry != &(group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry,
                                         FM_RESOURCE,
                                         ContainsLinkage );
            if ( (resource->QuorumResource) &&
                 ((resource->State == ClusterResourceOffline) ||
                 (resource->State == ClusterResourceFailed) ||
                 ((resource->State == ClusterResourceOfflinePending) &&
                  (!resource->Flags & RESOURCE_WAITING))) ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] RmOfflineResource: quorum resource <%1!ws!> offline when resource <%2!ws!> was shutting down.\n",
                           OmObjectId(resource),
                           OmObjectId(Resource));
                CsInconsistencyHalt(ERROR_INVALID_STATE);
            }
        }
    }
#endif

    state = ClusterResourceFailed;

CheckQuorumState:

    //if this is the quorum resource acquire the quolock
    // For registry replication to work, the resource should
    // not be brought online while the quorum resource is offline
    // what do we do for fixquorum mode
    if (Resource->QuorumResource) {
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
    } else {
        ACQUIRE_SHARED_LOCK(gQuoLock);
    }

    //if it is not the quorum resource, check the state of the quorum resource
    if (!Resource->QuorumResource)
    {
        DWORD     dwOldBlockingFlag;

        // check if the quorum resource is failed
        // we must exit from here and allow the recovery for the
        // quorum resource to kick in, which can only happen when
        // the group lock is released
        if (gpQuoResource->State == ClusterResourceFailed)
        {
            status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            RELEASE_LOCK(gQuoLock);
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            return(status);

        }

        // check if the quorum resource is online,
        // if the quorum resource is marked as waiting and offlinepending,
        // it is actually online.
        // if the quorum resource still needs to come online,
        // release the lock and wait
        if (((gpQuoResource->State != ClusterResourceOnline) &&
              ((gpQuoResource->State != ClusterResourceOfflinePending) ||
                (!(gpQuoResource->Flags & RESOURCE_WAITING))))
            && !CsNoQuorum) 
        {
            RELEASE_LOCK(gQuoLock);
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmOfflineResource: release quolock/group lock and wait on ghQuoOnlineEvent\r\n");
            WaitForSingleObject(ghQuoOnlineEvent, 500);
            if ( retry-- ) {
                Sleep(500);
                goto CheckQuorumState;
            }
#if DBG
            if ( IsDebuggerPresent() ) {
                DbgBreakPoint();
            }
#endif
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            // Should we halt? What about the pre-online notification above?
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            return(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //CsInconsistencyHalt(ERROR_INVALID_STATE);
            
        }

        //
        // assume that we'll be pending... mark the resource as having
        // bumped the QuoBlockResource count.
        //

        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmOfflineResource: InterlockedIncrement on gdwQuoBlockingResources for resource %1!ws!\n",
            OmObjectId(Resource));

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 1 );
        CL_ASSERT( dwOldBlockingFlag == 0 );
                    
        InterlockedIncrement(&gdwQuoBlockingResources);

    }
    else
    {
        DWORD       dwNumBlockingResources;

        //allow resources about 30 seconds to finish a pending 
        //operation
        retry = 60;
        
        // This is for a quorum resource.

CheckPendingResources:        

        // this is the quorum resource, wait for other resources
        // to get out of their pending states
        // new resources are not allowed to queue since the quorum 
        // lock is held exclusively

        dwNumBlockingResources =
            InterlockedCompareExchange( &gdwQuoBlockingResources, 0, 0 );
                    
        if (dwNumBlockingResources)            
        {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmOfflineResource: Quorum resource waiting to be brought offline-sleep.BlckingRes=%1!u!\r\n",
                       dwNumBlockingResources);
            //sleep for 500 msec
            Sleep(500);
            if ( retry-- ) {
                goto CheckPendingResources;
            }
            //if some resources are still pending, go ahead and offline
            //the quorum, the checkpointing code will simply retry when 
            //it finds that the quorum resource is not available
#if 0            
            if ( IsDebuggerPresent() ) {
                DbgBreakPoint();
            }
#endif
            ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRmOfflineResource: Quorum resource is being brought offline despite %1!u! pending resources...\r\n",
                      dwNumBlockingResources);

        }
    }

    status = ERROR_SUCCESS;
    if (Resource->QuorumResource) {
        state = Resource->State;
        status = MMSetQuorumOwner( MM_INVALID_NODE, /* Block = */ TRUE, NULL ); 
    }

    if (status == ERROR_SUCCESS) {
        //notify callbacks that need preprocessing before a resource is
        //brought offline-call this here since all resources may not go
        //thru the offline pending transition
        //SS - what if the resource never even goes to offline
        //pending state - then should we renotify the callbacks that it
        //is still online?
        state = ClusterResourceOffline;
    
        OmNotifyCb(Resource, NOTIFY_RESOURCE_PREOFFLINE);
        status = RmOfflineResource( Resource->Id, 
                                    (LPDWORD)&state // cast to quiet win64 warning
                                  );
    }

    //
    // Cleanup for the non-quorum resource case
    // if the resource has gone offline, decrement the count
    //
    if ( !Resource->QuorumResource &&
         state < ClusterResourcePending ) {
        DWORD     dwOldBlockingFlag;

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );
        if ( dwOldBlockingFlag ) {
            //
            // If the Transition Thread processed the request, then we can't
            // perform the decrement.
            //
            ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpRmOfflineResource: InterlockedDecrement on gdwQuoBlockingResources for resource %1!ws!\n",
                    OmObjectId(Resource));
                    
            InterlockedDecrement(&gdwQuoBlockingResources);
        }
    }

    if (status == ERROR_SUCCESS)
    {
        //
        // If the new state is pending, then we must wait.
        //
        if ( state == ClusterResourceOffline ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpRmOfflineResource: %1!ws! is now offline\n",
                       OmObjectId(Resource));
        } else if ( state == ClusterResourceOfflinePending ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpRmOfflineResource: %1!ws! offline pending\n",
                       OmObjectId(Resource));
            status = ERROR_IO_PENDING;
        }
    }
    else
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOfflineResource: RmOffline() for %1!ws! returned error %2!u!\r\n",
                   OmObjectId(Resource), status);
    }

    FmpCallResourceNotifyCb(Resource, state);
    FmpPropagateResourceState( Resource, state );
    RELEASE_LOCK(gQuoLock);

    return(status);

} // FmpRmOfflineResource



DWORD
FmpRmCloseResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Removes a resource from those being managed by the resource monitor.

Arguments:

    Resource - The resource to remove.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD status;
    PRESMON monitor;

    if (Resource->Id == 0) {
        //
        // This resource was never fully created.
        //
        return(ERROR_SUCCESS);
    }

    monitor = Resource->Monitor;
    Resource->Monitor = NULL;

    if ( Resource->QuorumResource ) {
        RmReleaseResource( Resource->Id );
        Resource->QuorumResource = FALSE;
    }

    try {
        RmCloseResource(&Resource->Id);
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,"[FM] RmDestroyResource issued exception %1!u!\n", status);

    }

    if ( monitor &&
         Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
        //
        // Shutdown the resource monitor as well.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Shutting down separate resource monitor!\n");
        FmpShutdownMonitor(monitor);
    }

    Resource->Id = 0;

    return(ERROR_SUCCESS);

} // FmpRmCloseResource



DWORD
FmpRmArbitrateResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Arbitrate for the given resource.

Arguments:

    Resource - The resource to arbitrate.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS;

    if (Resource->Id == 0) {
        //
        // This resource was never fully created.
        //
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }
    try {
        if (Resource->QuorumResource) {
            status = MMSetQuorumOwner( NmGetNodeId(NmLocalNode), /* Block = */ TRUE, NULL ); 
        }
        if (status == ERROR_SUCCESS) {
            status = RmArbitrateResource(Resource->Id);
            if (status != ERROR_SUCCESS) {
                if (Resource->QuorumResource) {
                    MMSetQuorumOwner( MM_INVALID_NODE , /* Block = */ FALSE, NULL );
                }
            }
        }
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmArbitrateResource issued exception %1!u!\n",
                   status);

    }

    return(status);

} // FmpRmArbitrateResource



DWORD
FmpRmReleaseResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Release arbitration on a given resource.

Arguments:

    Resource - The resource to release.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS;

    if (Resource->Id == 0) {
        //
        // This resource was never fully created.
        //
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }
    try {
        status = RmReleaseResource(Resource->Id);
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmReleaseResource issued exception %1!u!\n",
                   status);

    }

    return(status);

} // FmpRmReleaseResource



DWORD
FmpRmFailResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Fail a given resource.

Arguments:

    Resource - The resource to fail.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{

    if (Resource->QuorumResource) {
        MMSetQuorumOwner( MM_INVALID_NODE, /* Block = */ FALSE, NULL ); 
    }
    return(RmFailResource(Resource->Id));

} // FmpRmFailResource

DWORD FmpRmLoadResTypeDll(
    IN PFM_RESTYPE  pResType
)
{
    PRESMON     monitor;
    DWORD       dwStatus;
    LPWSTR      pszDebugPrefix;

    
    // Read the DebugControlFunction registry value.
    //

    if ( pResType->Flags & RESTYPE_DEBUG_CONTROL_FUNC ) {
        if ( pResType->DebugPrefix != NULL ) {
            pszDebugPrefix = pResType->DebugPrefix;
        } else {
            pszDebugPrefix = pResType->DebugPrefix;
        }
        monitor = FmpCreateMonitor(pszDebugPrefix, TRUE);
        if (monitor == NULL) {
            dwStatus = GetLastError();
            goto FnExit;
        }
    } else {
        CL_ASSERT(FmpDefaultMonitor != NULL);
        monitor = FmpDefaultMonitor;
    }


    dwStatus = RmLoadResourceTypeDll(monitor->Binding, OmObjectId(pResType), 
                    pResType->DllName);


    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmLoadResourceTypeDll call failed %1!u!\n",
                   dwStatus);
    }

    if ( pResType->Flags & RESTYPE_DEBUG_CONTROL_FUNC )
    {
        //
        // Stop this resource monitor if it is a separate resource monitor.
        //
        CL_ASSERT( monitor->NotifyThread != NULL );
        CL_ASSERT( monitor->Process != NULL );

        FmpShutdownMonitor( monitor );

    }


FnExit:                    
    return(dwStatus);
                    
}



DWORD
FmpRmChangeResourceParams(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Tell the resource monitor to change parameters for the given resource.

Arguments:

    Resource - The resource to change parameters.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmChangeResourceParams for resource <%1!ws!> called...\n",
               OmObjectId(Resource));

    return(RmChangeResourceParams(
                    Resource->Id,
                    Resource->LooksAlivePollInterval,
                    Resource->IsAlivePollInterval,
                    Resource->PendingTimeout ) );

} // FmpRmChangeResourceParams



DWORD
FmpRmResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    Resource - Supplies the resource to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - The number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    DWORD   Dummy;
    DWORD   dwTmpBytesReturned;
    DWORD   dwTmpBytesRequired;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    CL_ASSERT( Resource->Group != NULL );
    //
    // Handle any requests that must be done without locks helds.
    //
    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_GET_NAME:
            if ( (Resource->Monitor == NULL) ||
                 (OmObjectName( Resource ) == NULL) ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Resource ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Resource ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_RESOURCE_GET_ID:
            if ( (Resource->Monitor == NULL) ||
                 (OmObjectId( Resource ) == NULL) ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Resource ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Resource ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_RESOURCE_GET_RESOURCE_TYPE:
            if ( (Resource->Monitor == NULL) ||
                 (OmObjectId( Resource->Type ) == NULL) ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Resource->Type ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Resource->Type ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT:
        case CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT:
            {
                LPWSTR RegistryKey;
                DWORD LastChar;

                //
                // Validate the input buffer
                //
                RegistryKey = (LPWSTR)InBuffer;
                LastChar = (InBufferSize/sizeof(WCHAR)) - 1;
                //
                // If the length of the input buffer is zero, or not a integral
                // number of WCHARs, or the last character is not NULL, the
                // request is invalid.
                //
                if ((InBufferSize < sizeof(WCHAR)) ||
                    ((InBufferSize % sizeof(WCHAR)) != 0) ||
		    (RegistryKey == NULL) ||
                    (RegistryKey[LastChar] != L'\0')) {
                    return(ERROR_INVALID_PARAMETER);
                }

                //
                // If we are not the owner of this resource, don't let the set
                // happen.
                //
                if (Resource->Group->OwnerNode != NmLocalNode) {
                    return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
                }

                //
                // Call the checkpoint manager to perform the change.
                //
                if (ControlCode == CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT) {
                    status = CpAddRegistryCheckpoint(Resource, RegistryKey);
                } else {
                    status = CpDeleteRegistryCheckpoint(Resource, RegistryKey);
                }
            }
            *BytesReturned = 0;
            return(status);

        case CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT:
        case CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT:
            {
                //
                // If we are not the owner of this resource, don't let the set
                // happen.
                //
                if (Resource->Group->OwnerNode != NmLocalNode) {
                    return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
                }

                //
                // Call the checkpoint manager to perform the change.
                //
                if (ControlCode == CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT) {
                    status = CpckAddCryptoCheckpoint(Resource, InBuffer, InBufferSize);
                } else {
                    status = CpckDeleteCryptoCheckpoint(Resource, InBuffer, InBufferSize);
                }
            }
            *BytesReturned = 0;
            return(status);

        case CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS:
            //
            // Call the checkpoint manager to retrieve the list of checkpoints
            //
            status = CpGetRegistryCheckpoints(Resource,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required);
            return(status);

        case CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS:
            //
            // Call the checkpoint manager to retrieve the list of checkpoints
            //
            status = CpckGetCryptoCheckpoints(Resource,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required);
            return(status);

        case CLUSCTL_RESOURCE_UPGRADE_DLL:
            status = FmpUpgradeResourceDLL(Resource,
                                           ( LPWSTR ) InBuffer);
            return(status);

        default:
            break;

    }


    OmReferenceObject( Resource );

    FmpAcquireLocalResourceLock( Resource );

    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        status = ERROR_RESOURCE_NOT_AVAILABLE;
        FmpReleaseLocalResourceLock( Resource );
        goto FnExit;
    }

    if ( Resource->Monitor == NULL ) {
        status = FmpInitializeResource( Resource, TRUE );
        if ( status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            goto FnExit;
        }
    }
    FmpReleaseLocalResourceLock( Resource );

    //to take care of the output reference pointer which cannot be NULL.
    if (!OutBuffer)
    {
       OutBuffer = (PUCHAR)&Dummy;
       OutBufferSize = 0;
    }        
    if (!BytesReturned)
        BytesReturned = &dwTmpBytesReturned;
    if (!Required)
        Required = &dwTmpBytesRequired;
      
    try {
        status = RmResourceControl(Resource->Id,
                                   ControlCode,
                                   InBuffer,
                                   InBufferSize,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required
                                   );
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {
        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmResourceControl issued exception %1!u!\n",
                   status);
    }

    if ( ( status != ERROR_SUCCESS ) && 
         ( status != ERROR_MORE_DATA ) &&
         ( status != ERROR_INVALID_FUNCTION ) )
    {
    	ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmResourceControl: RmResourceControl returned %1!u! for resource %2!ws!, resid=%3!u!...\n",
                   status,
                   OmObjectId(Resource),
                   Resource->Id);
    }
	
    //for core resource we may need special handling
    if ((status == ERROR_SUCCESS) || (status == ERROR_RESOURCE_PROPERTIES_STORED))
    {
        DWORD   dwPostProcessStatus;
        
        dwPostProcessStatus = FmpPostProcessResourceControl( Resource,
                                                             ControlCode,
                                                             InBuffer, 
                                                             InBufferSize,
                                                             OutBuffer,
                                                             OutBufferSize,
                                                             BytesReturned,
                                                             Required );
        if ( dwPostProcessStatus != ERROR_SUCCESS ) status = dwPostProcessStatus;
    }
    
    if ( ((status == ERROR_SUCCESS) ||
          (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {

        //
        // We cannot just broadcast a cluster wide event... which is what
        // we want to do. Unfortunately, this code path can be activated
        // from within a GUM call, and we cannot call GUM back until we
        // have dispatched the current event.
        //

        //
        // Reference the resource object to keep it around while we
        // perform the post notification. The dereference must occur
        // in the post routine after the event posting.
        //
        OmReferenceObject( Resource );

        FmpPostWorkItem( FM_EVENT_RESOURCE_PROPERTY_CHANGE,
                         Resource,
                         0 );
    }

FnExit:
    OmDereferenceObject( Resource );
    //FmpReleaseLocalResourceLock( Resource );
    return(status);

} // FmpRmResourceControl


DWORD
FmpRmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    ResourceTypeName - Supplies the name of the resource type to be
        controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - The number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD       status;
    PRESMON     monitor;
    PFM_RESTYPE type = NULL;
    LPWSTR      debugPrefix;
    DWORD   Dummy;
    DWORD   dwTmpBytesReturned;
    DWORD   dwTmpBytesRequired;

    
    //
    // Find the resource type structure associated with this resource type name
    //
    OmEnumObjects( ObjectTypeResType,
                   FmpReturnResourceType,
                   &type,
                   (PVOID)ResourceTypeName );
    if ( type == NULL ) {
        return(ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND);
    }

    //
    // Read the DebugControlFunction registry value.
    //

    if ( type->Flags & RESTYPE_DEBUG_CONTROL_FUNC ) {
        if ( type->DebugPrefix != NULL ) {
            debugPrefix = type->DebugPrefix;
        } else {
            debugPrefix = type->DebugPrefix;
        }
        monitor = FmpCreateMonitor(debugPrefix, TRUE);
        if (monitor == NULL) {
            return(GetLastError());
        }
    } else {
        CL_ASSERT(FmpDefaultMonitor != NULL);
        monitor = FmpDefaultMonitor;
    }

    //to take care of the output reference pointer which cannot be NULL.
    if (!OutBuffer)
    {
       OutBuffer = (PUCHAR)&Dummy;
       OutBufferSize = 0;
    }        
    if (!BytesReturned)
        BytesReturned = &dwTmpBytesReturned;
    if (!Required)
        Required = &dwTmpBytesRequired;



    try {
        status = RmResourceTypeControl(monitor->Binding,
                                       ResourceTypeName,
                                       type->DllName,
                                       ControlCode,
                                       InBuffer,
                                       InBufferSize,
                                       OutBuffer,
                                       OutBufferSize,
                                       BytesReturned,
                                       Required
                                       );
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {
        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmResourceTypeControl issued exception %1!u!\n",
                   status);
    }

    if ( type->Flags & RESTYPE_DEBUG_CONTROL_FUNC ) {
        //
        // Stop this resource monitor if it is a separate resource monitor.
        //
        CL_ASSERT( monitor->NotifyThread != NULL );
        CL_ASSERT( monitor->Process != NULL );

        FmpShutdownMonitor( monitor );

    }

    //
    // If we successfully processed this request then re-fetch any changed
    // data items.
    //
    if ( (status == ERROR_SUCCESS ||
         (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {
        FmpHandleResourceTypeControl( type,
                                      ControlCode,
                                      InBuffer, 
                                      InBufferSize,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      Required );
        // ignore status
    }
    OmDereferenceObject(type);

    return(status);

} // FmpRmResourceTypeControl




/****
@func       BOOL | FmpPostProcessResourceControl| For core resource, if the control
            code is handled successfully by the resource dll, the fm handles
            any special handling in this function.

@parm       PFM_RESOURCE | Resource | Supplies the resource to be controlled.

@parm       DWORD| ControlCode | Supplies the control code that defines the
            structure and action of the resource control.
            Values of ControlCode between 0 and 0x10000000 are reserved
            for future definition and use by Microsoft. All other values
            are available for use by ISVs

@parm       PUCHAR | InBuffer | Supplies a pointer to the input buffer to be passed
            to the resource.

@parm       DWORD | InBufferSize | Supplies the size, in bytes, of the data pointed
            to by lpInBuffer..

@parm       PUCHAR | OutBuffer | Supplies a pointer to the output buffer to be
            filled in by the resource..

@parm       DWORD | OutBufferSize | Supplies the size, in bytes, of the available
            space pointed to by lpOutBuffer.

@parm       LPDWORD | BytesReturned | Returns the number of bytes of lpOutBuffer
            actually filled in by the resource..

@parm       LPDWORD | Required | The number of bytes required if OutBuffer is not big enough.


@comm       Called only for core resources.

@xref
****/

DWORD
FmpPostProcessResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
{
    DWORD dwStatus=ERROR_SUCCESS;
    
    //handle cluster name change
    switch(ControlCode)
    {
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        {
            LPWSTR      pszClusterName=NULL;
            PFM_RESTYPE pResType;    

            //need to check this only for core resources
            if (Resource->ExFlags & CLUS_FLAG_CORE)
            {
                pResType = Resource->Type;
                //SS: chk follow the name
                if (!lstrcmpiW(OmObjectId(pResType), CLUS_RESTYPE_NAME_NETNAME))
                {
                    dwStatus = FmNetNameParseProperties(InBuffer, InBufferSize,
                        &pszClusterName);
                    if (dwStatus == ERROR_SUCCESS && pszClusterName)
                    {
                        dwStatus = FmpRegUpdateClusterName(pszClusterName);
                        LocalFree(pszClusterName);
                    } else if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                        dwStatus = ERROR_SUCCESS;
                    }
                }
            }
            break;
        }            

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        {
            LPDWORD pdwCharacteristics = ( LPDWORD ) OutBuffer;
            //
            // If the resource has dependencies, remove the quorum capable flag
            //
            if ( ( pdwCharacteristics != NULL ) && 
                 ( ( *BytesReturned ) == sizeof ( DWORD ) ) &&
                 ( ( *pdwCharacteristics ) & ( CLUS_CHAR_QUORUM ) ) )
            {
                FmpAcquireLocalResourceLock( Resource );
                //
                // The resource says it is quorum capable, however it has a dependency so it 
                // cant be a quorum.
                //
                if ( !IsListEmpty( &Resource->DependsOn ) ) 
                {
                    //
                    // We will mask the quorum capable bit
                    //
                    *pdwCharacteristics = ( *pdwCharacteristics ) & ( ~CLUS_CHAR_QUORUM );
                }
                FmpReleaseLocalResourceLock( Resource );
            }
            break;
        }
        
        default:
            break;
    }        
    
    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\rmnotify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rmnotify.c

Abstract:

    Interfaces with the resource monitor to detect notification
    of resource state changes.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE RMNOTIFY

//
// Local Data
//

CL_QUEUE NotifyQueue;

typedef struct {
    LIST_ENTRY Linkage;
    RM_EVENT_TYPE  EventType;
    union {
        struct {
            RM_NOTIFY_KEY           NotifyKey;
            CLUSTER_RESOURCE_STATE  NewState;
        } ResourceTransition;
        struct {
            RM_NOTIFY_KEY   NotifyKey;
        } ResourceResuscitate;
    } Parameters;
} RM_EVENT, *PRM_EVENT;

HANDLE RmNotifyThread;



//
// Local Functions
//
DWORD
FmpRmWorkerThread(
    IN LPVOID lpThreadParameter
    );

VOID
FmpRmWorkItemHandler(
    IN PCLRTL_WORK_ITEM  WorkItem,
    IN DWORD             Ignored1,
    IN DWORD             Ignored2,
    IN ULONG_PTR         Ignored3
    );

DWORD
FmpRmDoHandleCriticalResourceStateChange(
    IN PRM_EVENT pEvent
    );

DWORD
FmpInitializeNotify(
    VOID
    )

/*++

Routine Description:

    Initialization routine for notification engine

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD ThreadId;
    DWORD Status;

    Status = ClRtlInitializeQueue(&NotifyQueue);
    if (Status != ERROR_SUCCESS) {
        CL_LOGFAILURE(Status);
        return(Status);
    }

    RmNotifyThread = CreateThread(NULL,
                                  0,
                                  FmpRmWorkerThread,
                                  NULL,
                                  0,
                                  &ThreadId);
    if (RmNotifyThread == NULL) {
        CsInconsistencyHalt(GetLastError());
    }

    return(ERROR_SUCCESS);
}


DWORD
FmpRmWorkerThread(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread processes deferred Resource Monitor events.

Arguments:

    lpThreadParameter - not used.

Return Value:

    None.

--*/

{
    DWORD        status = ERROR_SUCCESS;
    PRM_EVENT    event;
    PLIST_ENTRY  entry;

    while (TRUE) 
    {
        entry = ClRtlRemoveHeadQueue(&NotifyQueue);
        if ( entry == NULL ) {
            break;
        }

        event = CONTAINING_RECORD(entry,
                                  RM_EVENT,
                                  Linkage);

        if (event->EventType == RmWorkerTerminate) 
        {
            LocalFree(event);
            break;
        }

        status = FmpRmDoHandleCriticalResourceStateChange(event);
        
        if (status != ERROR_SUCCESS)
        {
            break;
        }
    }
    return(status);
}

#if 0
VOID
FmpRmWorkItemHandler(
    IN PCLRTL_WORK_ITEM  WorkItem,
    IN DWORD             Ignored1,
    IN DWORD             Ignored2,
    IN ULONG_PTR         Ignored3
    )
{

    PFM_RESOURCE    resource;
    ULONG_PTR       notifyKey;
    PRM_EVENT       event;
    DWORD           status;
    BOOL            bQuoChangeLockHeld = FALSE;
    
    event = (PRM_EVENT)WorkItem->Context;

// It is assumed that NotifyKey is always the first field of the struct
// within the union in RM_EVENT
    notifyKey = event->Parameters.ResourceResuscitate.NotifyKey;


    resource = FmpFindResourceByNotifyKey(
                   notifyKey
                   );

    if (resource == NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmWorkItemHandler, bad resource NotifyKey %1!u!\n",
            notifyKey
            );
        goto FnExit;
    }        

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmWorkItemHandler, Resource=<%1!ws!>, Event=%2!u!\n",
                OmObjectId(resource),
                event->EventType);

ChkFMState:    
    if (!FmpFMGroupsInited)
    {
        DWORD   dwRetryCount = 50;
        
        ACQUIRE_SHARED_LOCK(gQuoChangeLock);

        //FmFormNewClusterPhaseProcessing is in progress
        if (FmpFMFormPhaseProcessing)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpRmWorkItemHandler, resource notification from quorum resource "
                "during phase processing. Sleep and retry\n");
            RELEASE_LOCK(gQuoChangeLock);
            Sleep(500);
            if (dwRetryCount--)
                goto ChkFMState;
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpRmWorkItemHandler, waited for too long\n");
                //terminate the process                    
                CL_ASSERT(FALSE);
            }
        }
        else
        {
            bQuoChangeLockHeld = TRUE;
        }
        //this can only come from the quorum resource
        CL_ASSERT(resource->QuorumResource);
    }
    
    switch(event->EventType) {

        case ResourceTransition:
        {
            CLUSTER_RESOURCE_STATE  newState =
                             event->Parameters.ResourceTransition.NewState;

            FmpHandleResourceTransition(
                    resource,
                    newState
                    );
            break;
        }

#if 0
//
//  Chittur Subbaraman (chitturs) - 4/19/99
//
//  Commenting out - case ResourceResuscitate is not called from anywhere.
//
        case ResourceResuscitate:
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmWorkItemHandler, processing ResourceResuscitate event\n");
                
            FmpAcquireLocalResourceLock( resource );
            FmpRestartResourceTree( resource );
            FmpReleaseLocalResourceLock( resource );
            break;
//
//  Chittur Subbaraman (chitturs) - 4/19/99
//
//  Commenting out - case RmUpdateResource is now handled by FmpWorkerThread.
//
        case RmUpdateResource:

            //
            // Now tell the resource monitor about the changes.
            //
            FmpAcquireLocalResourceLock( resource );
            status = FmpRmChangeResourceParams( resource );
            FmpReleaseLocalResourceLock( resource );
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] FmpRmWorkerThread, failed to change resource "
                            "parameters for %1!ws!, error %2!u!.\n",
                           OmObjectId(resource),
                           status );
            }
            break;
//
//  Chittur Subbaraman (chitturs) - 4/19/99
//
//  Commenting out - Since the producer of this notification is commented
//  out in fmreg.c.
//
        case RmRestartResource:
            FmpAcquireLocalResourceLock( resource );
            status = FmpRmCloseResource( resource );
            if ( status == ERROR_SUCCESS ) {
                if ( resource->Flags & RESOURCE_SEPARATE_MONITOR ) {
                    resource->Flags &= ~RESOURCE_SEPARATE_MONITOR;
                } else {
                    resource->Flags |= RESOURCE_SEPARATE_MONITOR;
                }
                status = FmpRmCreateResource( resource );
                if ( status != ERROR_SUCCESS ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] FmpRmWorkItemhandler: Separate resource monitor "
                                "changed for '%1!ws!', but failed to re-open the resource, "
                                "error %2!u!.\n",
                               OmObjectId(resource),
                               status );
                }
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] FmpRmWorkItemHandler :Separate resource monitor "
                            "changed for '%1!ws!', but failed to close the resource, "
                            "error %2!u!.\n",
                            OmObjectId(resource),
                            status );
            }
            FmpReleaseLocalResourceLock( resource );
            break;
#endif

        default:
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmWorkerThread, Unknown event type %1!u!\n",
                event->EventType
                );
            break;
    }

FnExit:
    if (bQuoChangeLockHeld) {
        RELEASE_LOCK(gQuoChangeLock);
    }

    LocalFree(event);
    LocalFree(WorkItem);

    ClRtlLogPrint(LOG_NOISE,"[FM] FmpRmWorkItemHandler: Exit\n");

    return;
}

#endif


BOOL
FmpPostNotification(
    IN RM_NOTIFY_KEY NotifyKey,
    IN DWORD NotifyEvent,
    IN CLUSTER_RESOURCE_STATE CurrentState
    )

/*++

Routine Description:

    Callback routine used by resource monitor for resource state
    change notification. This routine queues the notification to
    a worker thread for deferred processing.

Arguments:

    NotifyKey - Supplies the notification key for the resource
                that changed

    NotifyEvent - The event type.

    CurrentState - Supplies the (new) current state of the resource

Return Value:

    TRUE - continue receiving notifications

    FALSE - abort notifications

--*/

{
    PRM_EVENT  event;


    event = LocalAlloc(LMEM_FIXED, sizeof(RM_EVENT));

    if (event != NULL) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] NotifyCallBackRoutine: enqueuing event\n");

        event->EventType = NotifyEvent;
        event->Parameters.ResourceTransition.NotifyKey = NotifyKey;
        event->Parameters.ResourceTransition.NewState = CurrentState;

        //
        // Enqueue the event for the worker thread.
        //
        ClRtlInsertTailQueue(&NotifyQueue, &event->Linkage);
    }

    return(TRUE);
}

DWORD
FmpRmDoHandleCriticalResourceStateChange(
    IN PRM_EVENT pEvent
    )

/*++

Routine Description:

    Does an interlocked decrement of the gdwQuoBlockingResources variable.
    Handle the transition of the quorum resource state via a separate 
    thread.

Arguments:

    pEvent - The Resource Monitor Event

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

Comments:

    DO NOT hold any locks (such as group lock, gQuoChangeLock, etc.) 
    in this function. You could deadlock the system quite easily.

--*/

{
    RM_NOTIFY_KEY       NotifyKey;
    DWORD               dwOldBlockingFlag;
    PFM_RESOURCE        pResource;
    DWORD               status = ERROR_SUCCESS;
    PCLRTL_WORK_ITEM    pWorkItem;
    CLUSTER_RESOURCE_STATE  
                        NewState = pEvent->Parameters.ResourceTransition.NewState;      

    //
    //  Chittur Subbaraman (chitturs) - 4/19/99
    //
    //  This function decrements the blocking resources count when the
    //  resource state has stabilized. It is important to do this
    //  decrement in a non-blocking mode so that the quorum resource
    //  does not get caught forever waiting for this count to go down to 
    //  zero in the offline call, FmpRmOfflineResource. This code was 
    //  originally located in FmpHandleResourceTransition and was moved
    //  here since you could run out of FmpRmWorkItemHandler threads 
    //  (which service the CsDelayedWorkQueue) since all of them could
    //  get blocked on the local resource lock in 
    //  FmpHandleResourceTransition and consequently any new notifications
    //  from resmon which could potentially decrement this count will
    //  not get serviced.
    //
    NotifyKey = pEvent->Parameters.ResourceResuscitate.NotifyKey;

    pResource = FmpFindResourceByNotifyKey(
                   NotifyKey
                );

    if ( pResource == NULL ) {

        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmpRmDoHandleCriticalResourceStateChange, bad resource NotifyKey %1!u!\n",
            NotifyKey

        );
        goto FnExit;
    } 

    if ( pEvent->EventType != ResourceTransition )
    {
        goto FnExit;
    }

    if ( pResource->QuorumResource ) 
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/25/99
        //
        //  If this resource is the quorum resource, then let 
        //  FmpHandleResourceTransition take care of the sync notifications.
        //  Note that this function only does the notifications for the
        //  non-quorum resources as well as does the decrement on the
        //  blocking resources count. The decrement MUST be done
        //  without holding any locks to avoid potential deadlocks with
        //  the quorum resource offline getting stuck in FmpRmOfflineResource
        //  waiting for the blocking resources count to go to 0. 
        //  As far as the quorum resource goes, the sync notifications
        //  must be done with gQuoChangeLock held since we want to 
        //  synchronize with other threads such as the FmCheckQuorumState 
        //  called by the DM node down handler. FmpHandleResourceTransition 
        //  does hold the gQuoChangeLock.
        //
        //  Note also that for the quorum resource a separate thread
        //  handles the resource transition since if we depend on the
        //  worker threads servicing the CsDelayedWorkQueue to do this,
        //  this notification could be starved from being processed since
        //  some thread could hold the group lock and be stuck in the
        //  resource onlining waiting for the quorum resource to go
        //  online and all the worker threads servicing the CsDelayedWorkQueue 
        //  could be blocked on the group lock preventing the propagation
        //  of the quorum resource state.
        //
        FmpCreateResStateChangeHandler( pResource, NewState, pResource->State ); 

        LocalFree( pEvent );
        
        goto FnExit;
    }

    pWorkItem = LocalAlloc( LMEM_FIXED, sizeof( CLRTL_WORK_ITEM ) );
        
    if ( pWorkItem == NULL ) 
    { 
        status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR( status );
        goto FnExit;
    }    

    //
    //  Comments from sunitas: Call the synchronous notifications. 
    //  This is done before the count is decremented as the synchronous 
    //  callbacks like the registry replication must get a chance to 
    //  finish before the quorum resource state is allowed to change.
    //
    //  Note, there is no synchronization here with the resmon's 
    //  online/offline code. They are using the LocalResourceLocks.
    //
    FmpCallResourceNotifyCb( pResource, NewState );

    dwOldBlockingFlag = InterlockedExchange( &pResource->BlockingQuorum, 0 );

    if ( dwOldBlockingFlag ) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmDoHandleCriticalResourceStateChange: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
            OmObjectId(pResource));
        InterlockedDecrement( &gdwQuoBlockingResources );
    }

    //post a work item to the fm worker thread to handle the rest
    OmReferenceObject(pResource);
    FmpPostWorkItem(FM_EVENT_RES_RESOURCE_TRANSITION,
                    pResource,
                    NewState);

#if 0    
    ClRtlInitializeWorkItem( pWorkItem, FmpRmWorkItemHandler, (PVOID) pEvent );

    status = ClRtlPostItemWorkQueue( CsDelayedWorkQueue, pWorkItem, 0, 0 );

    if ( status )
    {
        LocalFree( pWorkItem );
        CL_UNEXPECTED_ERROR( status );
    }

#endif 

FnExit:
    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\rpcbind.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    RPC binding table managment routines

Author:

    John Vert (jvert) 6/10/1996

Revision History:

--*/

#include "fmp.h"

//
// Private RPC binding table
//
RPC_BINDING_HANDLE  FmpRpcBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];
RPC_BINDING_HANDLE  FmpRpcQuorumBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];


DWORD
FmCreateRpcBindings(
    PNM_NODE  Node
    )
/*++

Routine Description:

    Creates FM's private RPC bindings for a joining node.
    Called by the Node Manager.

Arguments:

    Node - A pointer to the node for which to create RPC bindings

Return Value:

    A Win32 status code.

--*/
{
    DWORD               Status;
    RPC_BINDING_HANDLE  BindingHandle;
    CL_NODE_ID          NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[FM] Creating RPC bindings for node %1!u!.\n",
        NodeId
        );

    //
    // Main binding
    //
    if (FmpRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(FmpRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[FM] Failed to verify main RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(FmpRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[FM] Failed to create main RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    //
    // Quorum binding
    //
    if (FmpRpcQuorumBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(FmpRpcQuorumBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[FM] Failed to verify quorum RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            // presumably we will shutdown at this point
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(FmpRpcQuorumBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[FM] Failed to create quorum RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    return(ERROR_SUCCESS);

} // FmpCreateRpcBindings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\timer.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Cluster FM callback routines to be invoked on a timer

Author:

    Sunita shrivastava (sunitas) 24-Sep-1998


Revision History:


--*/

#include "fmp.h"

#include "ntrtl.h"

#define LOG_MODULE TIMER


/****
@func       DWORD | FmpQueueTimerActivity| This is invoked by gum when fm requests
            a vote for a given context.

@parm       IN DWORD | dwInterval| The time in msec to wait.

@parm       IN PFN_TIMER_CALLBACK | pfnTimerCb | The callback funtion
            to be invoked when the given time elapses.

@parm       IN PVOID | pContext| A  pointer to a context structure that is
            passed back to the callback function.
            
@comm       It is assumed that FM wants to use one shot timers.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f AddTimerActivity>
****/

DWORD
FmpQueueTimerActivity(
    IN DWORD dwInterval,
    IN PFN_TIMER_CALLBACK pfnTimerCb, 
    IN PVOID pContext    
)    
{
    HANDLE  hTimer = NULL;
    DWORD   dwStatus;
    
    hTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!hTimer)
    {
        dwStatus = ERROR_SUCCESS;
    	CL_LOGFAILURE(dwStatus);
    	goto FnExit;
    }

    //register the timer for this log with the activity timer thread
    dwStatus = AddTimerActivity(hTimer, dwInterval, 0, pfnTimerCb, pContext);

    if (dwStatus != ERROR_SUCCESS)
    {
        CloseHandle(hTimer);
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpQueueTimerActivity


/****
@func       DWORD | FmpReslistOnlineRetryCb| This is invoked by timer
            activity thread to bring a resource list online again.

@parm       IN VOID | pContext| a pointer to PFM_RESLIST_ONLINE_RETRY_INFO
            structure containing information about the group and
            resources to bring online.
            
@comm       We dont do the work here since the timer lock is held and we
            want to avoid acquiring the group lock while the timer lock 
            is held.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpWorkerThread> <f FmpOnlineResourceList>
****/

void
WINAPI
FmpReslistOnlineRetryCb(
    IN HANDLE hTimer,
    IN PVOID  pContext
)
{
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpResListOnlineRetryCb: Called to retry bringing the  group online\r\n");

    //post a work item, since we dont wont to acquire group locks
    //while the timer lock is acquired
    //pass hTimer as second Context value to be used by RemoveTimerActivity
    FmpPostWorkItem(FM_EVENT_INTERNAL_RETRY_ONLINE, pContext, 
        (ULONG_PTR)hTimer);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\tree.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Cluster resource tree management routines.

Author:

    Rod Gamache (rodga) 17-Apr-1996


Notes:

    WARNING: All of the routines in this file assume that the resource
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"


#define LOG_MODULE TREE
//
// Global Data
//


//
// Local function prototypes
//
BOOL
FmpAddResourceToDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    );

BOOL
FmpIsResourceInDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    );

DWORD
FmpOfflineWaitingResourceTree(
    IN PFM_RESOURCE  Resource,
    IN BOOL BringQuorumOffline
    );




DWORD
FmpRestartResourceTree(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine brings back part of a dependency tree, starting from the
    point of the last failure.

Arguments:

    Resource - A pointer to the resource object that last failed and is
            restarting.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;


    FmpAcquireLocalResourceLock( Resource );

    //
    // Tell the resource monitor to restart this resource if needed.
    //

    //
    // If the current state is not online and we want it to be online, then
    // bring it online.
    //

    if ( (Resource->State != ClusterResourceOnline)  &&
         ((Resource->PersistentState == ClusterResourceOnline)) ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RestartResourceTree, Restart resource %1!ws!\n",
                   OmObjectId(Resource));
        status = FmpOnlineResource(Resource, FALSE);
    }

    //
    // If this resource has any dependents, start them if needed.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively restart the dependent resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RestartResourceTree, %1!ws! depends on %2!ws!. Restart first\n",
                   OmObjectId(dependency->DependentResource),
                   OmObjectId(Resource));

        status = FmpRestartResourceTree(dependency->DependentResource);
    }

    FmpReleaseLocalResourceLock( Resource );

    return(ERROR_SUCCESS);

}  // FmpRestartResourceTree



DWORD
FmpOnlineWaitingTree(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine brings back part of a dependency tree, starting from the
    point of the last waiting resource.

Arguments:

    Resource - A pointer to the resource object that is now online.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

Notes:

    This routine is only called when the given resource is online.

--*/

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;


    FmpAcquireLocalResourceLock( Resource );

    //if shutdown is in progress, dont bring resources online
    if (FmpShutdown)
    {
        //
        // If this resource has any dependents, and they are in online pending state
        // mark them as offline.
        //
        for ( entry = Resource->ProvidesFor.Flink;
              entry != &(Resource->ProvidesFor);
              entry = entry->Flink
            )
        {
            dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

            if ((dependency->DependentResource->State == ClusterResourceOnlinePending) &&
                (dependency->DependentResource->Flags & RESOURCE_WAITING))
            {
                //set the state of the all dependent resources to be offline again
                FmpPropagateResourceState(dependency->DependentResource, ClusterResourceOffline);
                //set the resource to be not waiting                
                dependency->DependentResource->Flags &= ~RESOURCE_WAITING;

                //
                // Recursively set the state of all dependent resources to offline
                //
                ClRtlLogPrint(LOG_NOISE,
                       "[FM] OnlineWaitingTree, %1!ws! (%2!u!) depends on %3!ws! (%4!u!). Shutdown others\n",
                       OmObjectId(dependency->DependentResource),
                       dependency->DependentResource->State,
                       OmObjectId(Resource),
                       Resource->State);

                status = FmpOnlineWaitingTree(dependency->DependentResource);

            }
        }

        //
        //  Chittur Subbaraman (chitturs) - 11/5/1999
        //
        //  Ensure that the resource state itself is made 
        //  ClusterResourceOffline if FM is asked to shutdown. Note that
        //  this function is recursively called from below, not just from 
        //  the FM worker thread. So, if FM happened to be shutdown
        //  while executing this function called from below, then we
        //  offline all the dependent resources above, but not the 
        //  resource itself. This is done here.
        //
        if ( ( Resource->State == ClusterResourceOnlinePending ) &&
             ( Resource->Flags & RESOURCE_WAITING ) )
        {
            FmpPropagateResourceState( Resource, ClusterResourceOffline );

            Resource->Flags &= ~RESOURCE_WAITING;

            ClRtlLogPrint( LOG_NOISE,
                        "[FM] OnlineWaitingTree, Resource <%1!ws!> forcibly brought offline...\n",
                        OmObjectId( Resource ) );
        }                    

        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }
        
    //for normal-non shutdown case
    //
    // Tell the resource monitor to restart this resource if needed.
    //

    //
    // If the current state is not online and it is waiting, then it probably
    // needs to be brought online now.
    //

    if ( (Resource->State == ClusterResourceOnlinePending)  &&
         (Resource->Flags & RESOURCE_WAITING) ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOnlineWaitingTree, Start resource %1!ws!\n",
                   OmObjectId(Resource));
        Resource->State = ClusterResourceOffline;
        status = FmpOnlineResource(Resource, FALSE);
        if ( status == ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineWaitingTree, online for resource %1!ws! succeeded, online the dependents\r\n",
               OmObjectId(Resource));
        } 
        else if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
        {
            PRESOURCE_ENUM  pResourceEnum;
            LPWSTR          pszNewId;
            
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineWaitingTree, online for resource %1!ws!, status = %2!u!.\n",
                       OmObjectId(Resource),
                       status);

            pResourceEnum = (PRESOURCE_ENUM)LocalAlloc(LMEM_FIXED,
                                sizeof(RESOURCE_ENUM));
            if (!pResourceEnum)
            {
                CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
            }
            pResourceEnum->EntryCount = 1;
            pResourceEnum->ContainsQuorum = (Resource == gpQuoResource);
            pszNewId = LocalAlloc(LMEM_FIXED, (lstrlenW(OmObjectId(Resource))+1) * sizeof(WCHAR));
            if ( pszNewId == NULL ) 
            {
                CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
            }

            lstrcpyW(pszNewId, OmObjectId(Resource));
            pResourceEnum->Entry[0].Id = pszNewId;
            pResourceEnum->Entry[0].State = Resource->PersistentState;
            FmpSubmitRetryOnline(pResourceEnum);                       
            FmpReleaseLocalResourceLock(Resource);

            LocalFree(pszNewId);
            LocalFree(pResourceEnum);
            return(status);
        }
        else
        {
            FmpReleaseLocalResourceLock( Resource );
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineWaitingTree, online for resource %1!ws! returned = %2!u!.\n",
                       OmObjectId(Resource),
                       status);
            return(status);                       

        }
    }

    //
    // If this resource has any dependents, start them if needed.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively restart the dependent resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OnlineWaitingTree, %1!ws! (%2!u!) depends on %3!ws! (%4!u!). Start now\n",
                   OmObjectId(dependency->DependentResource),
                   dependency->DependentResource->State,
                   OmObjectId(Resource),
                   Resource->State);

        status = FmpOnlineWaitingTree(dependency->DependentResource);

    }

    FmpReleaseLocalResourceLock( Resource );

    return(ERROR_SUCCESS);

}  // FmpOnlineWaitingTree


DWORD
FmpOfflineWaitingTree(
    IN PFM_RESOURCE  Resource
    )

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;
    
    FmpAcquireLocalResourceLock( Resource );
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineWaitingTree: Entry for <%1!ws!>.\n",
               OmObjectName( Resource ) );

    //
    // Tell the resource monitor to stop this resource if needed.
    // Make sure that the quorum resource is the last one brought offline
    //
    status = FmpOfflineWaitingResourceTree(Resource, FALSE);

    //the quorum resource might still need to come offline, if it is in this group
    if ((status == ERROR_SUCCESS) && (Resource->Group == gpQuoResource->Group))
    {

        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpOfflineWaitingTree: Quorum resource is in the same group,Moving list=0x%1!08lx!\n",
                Resource->Group->MovingList);

        
        //if a move is pending bring the quorum resource offline if all resources
        // in the group are offline
        // else dont bring the quorum resource offline
        // this is because we dont bring the quorum resource offline on group offlines
        if (Resource->Group->MovingList)
        {
            PLIST_ENTRY listEntry;
            DWORD       BringQuorumOffline = TRUE;
            PFM_RESOURCE pGroupResource;

        
            for ( listEntry = Resource->Group->Contains.Flink;
              listEntry != &(Resource->Group->Contains);
              listEntry = listEntry->Flink ) 
            {
                pGroupResource = CONTAINING_RECORD(listEntry,
                                             FM_RESOURCE,
                                             ContainsLinkage );

                // if this is the quorum resource continue
                if (pGroupResource->QuorumResource)
                    continue;
                //if the state is not offline or failed, dont try
                //and bring the quorum resource offline
                if ((pGroupResource->State != ClusterResourceOffline) && 
                   (pGroupResource->State != ClusterResourceFailed)) 
                {                
                    ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpOfflineWaitingTree: Quorum cannot be brought offline now for <%1!ws!>, state=%2!u!\n",
                        OmObjectName(pGroupResource), pGroupResource->State);

                    BringQuorumOffline = FALSE;
                    break;
                }
            }
            if (BringQuorumOffline)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpOfflineWaitingTree: bring quorum resource offline\n");
                status = FmpOfflineResource(gpQuoResource, FALSE);
            }            

        }

    }

    FmpReleaseLocalResourceLock( Resource );
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineWaitingTree: returned status %1!u! for <%2!ws!>.\n",
               status, OmObjectName( Resource ) );
    return(status);

}

DWORD
FmpOfflineWaitingResourceTree(
    IN PFM_RESOURCE  Resource,
    IN BOOL BringQuorumOffline
    )

/*++

Routine Description:

    This routine offlines a dependency tree, starting from the
    point of the last waiting resource.

Arguments:

    Resource - A pointer to the resource object that is now offline.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

Notes:

    This routine is only called when the given resource is offline.

--*/

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status = ERROR_SUCCESS;


    FmpAcquireLocalResourceLock( Resource );

    //
    // Tell the resource monitor to stop this resource if needed.
    //

    //
    // If the current state is not offline and it is waiting, then it probably
    // needs to be brought offline now.
    //

    if ((Resource->State == ClusterResourceOfflinePending) &&
         (Resource->Flags & RESOURCE_WAITING)) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OfflineWaitingResourceTree, Offline resource %1!ws!\n",
                   OmObjectId(Resource));
        Resource->State = ClusterResourceOnline;
        status = FmpOfflineResource(Resource, FALSE);
        if ( status == ERROR_IO_PENDING ) {
            FmpReleaseLocalResourceLock( Resource );
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OfflineWaitingResourceTree, offline for resource %1!ws! returned pending.\n",
                       OmObjectId(Resource));
            return(status);
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OfflineWaitingResourceTree, offline for resource %1!ws!, status = %2!u!.\n",
                       OmObjectId(Resource),
                       status);
        }
    }

    //
    // If this resource has any providers, stop them if needed.
    //
    for ( entry = Resource->DependsOn.Flink;
          entry != &(Resource->DependsOn);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, DependentLinkage);

        if (dependency->ProviderResource->QuorumResource && !BringQuorumOffline)
        {
            continue;
        }
        //
        // Recursively offline the provider resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OfflineWaitingResourceTree, %1!ws! provides for %2!ws!. Offline next.\n",
                   OmObjectId(dependency->ProviderResource),
                   OmObjectId(Resource));

        //dependency->ProviderResource->Flags |= RESOURCE_WAITING;
        status = FmpOfflineWaitingResourceTree(dependency->ProviderResource, BringQuorumOffline);

    }

    FmpReleaseLocalResourceLock( Resource );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] OfflineWaitingResourceTree: Exit, status=%1!u! for <%2!ws!>.\n",
               status, OmObjectName( Resource ) );
    return(status);

}  // FmpOfflineWaitingResourceTree


PFM_DEPENDENCY_TREE
FmCreateFullDependencyTree(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Creates a full dependency tree containing all the resources
    that either depend on or provide for the supplied resource.

Arguments:

    Resource - Supplies the resource

Return Value:

    Pointer to the dependency tree.

    NULL if out of memory.

--*/

{
    PFM_DEPENDENCY_TREE Tree;
    BOOL Success;

    Tree = LocalAlloc(LMEM_FIXED, sizeof(FM_DEPENDENCY_TREE));
    if (Tree == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    InitializeListHead(&Tree->ListHead);

    //
    // Add the resources that the specified resource depends on.
    //
    Success = FmpAddResourceToDependencyTree(Resource, Tree);
    if (!Success) {
        LocalFree(Tree);
        return(NULL);
    } else {
        return(Tree);
    }

}


BOOL
FmpIsResourceInDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    )
/*++

Routine Description:

    Determines whether the specified resource is already in the
    dependency tree.

Arguments:

    Resource - Supplies the resource to check for

    Tree - Supplies the dependency tree.

Return Value:

    TRUE if the resource is in the dependency tree

    FALSE if the resource is not in the dependency tree

--*/

{
    PLIST_ENTRY   ListEntry;
    PFM_DEPENDTREE_ENTRY Node;

    ListEntry = Tree->ListHead.Flink;
    while (ListEntry != &Tree->ListHead) {
        Node = CONTAINING_RECORD(ListEntry,
                                 FM_DEPENDTREE_ENTRY,
                                 ListEntry);
        if (Node->Resource == Resource) {
            return(TRUE);
        }
        ListEntry = ListEntry->Flink;
    }

    return(FALSE);
}


BOOL
FmpAddResourceToDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    )
/*++

Routine Description:

    Recursive worker for adding a resource and all resources that
    it depends on or provides for into the dependency tree.

Arguments:

    Resource - Supplies the resource to add.

    Tree - Supplies the tree the resource should be added to.

Return Value:

    TRUE - Successfully completed

    FALSE - out of memory

--*/

{
    PLIST_ENTRY   ListEntry;
    PDEPENDENCY   Dependency;
    PFM_DEPENDTREE_ENTRY Node;

    //
    // First check to see if we are already in the tree.
    // If so, we are done.
    //
    if (FmpIsResourceInDependencyTree(Resource, Tree)) {
        return(TRUE);
    }


    //
    // Recursively call ourselves for each entry we depend on.
    //
    ListEntry = Resource->DependsOn.Flink;
    while (ListEntry != &Resource->DependsOn) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       DependentLinkage);
        ListEntry = ListEntry->Flink;
        //
        // Recursively add this resource to the tree
        //
        if (!FmpAddResourceToDependencyTree(Dependency->ProviderResource, Tree)) {
            return(FALSE);
        }
    }

    //
    // Add ourselves to the list now if we are not already in it.
    //
    if (!FmpIsResourceInDependencyTree(Resource, Tree)) {
        //
        // Add ourselves to the end of the list.
        //
        Node = LocalAlloc(LMEM_FIXED, sizeof(FM_DEPENDTREE_ENTRY));
        if (Node == NULL) {
            return(FALSE);
        }
        OmReferenceObject(Resource);
        Node->Resource = Resource;
        InsertTailList(&Tree->ListHead, &Node->ListEntry);
    }


    //
    // Now add the resources that this resource provides for to the list.
    //
    ListEntry = Resource->ProvidesFor.Flink;
    while (ListEntry != &Resource->ProvidesFor) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       ProviderLinkage);
        ListEntry = ListEntry->Flink;
        //
        // Recursively add this resource to the tree
        //
        if (!FmpAddResourceToDependencyTree(Dependency->DependentResource, Tree)) {
            return(FALSE);
        }
    }
    return(TRUE);
}

VOID
FmDestroyFullDependencyTree(
    IN PFM_DEPENDENCY_TREE Tree
    )
/*++

Routine Description:

    Destroys a dependency tree

Arguments:

    Tree - Supplies the dependency tree

Return Value:

    None

--*/

{
    PFM_DEPENDTREE_ENTRY Entry;
    PLIST_ENTRY   ListEntry;

    while (!IsListEmpty(&Tree->ListHead)) {
        ListEntry = RemoveHeadList(&Tree->ListHead);
        Entry = CONTAINING_RECORD(ListEntry,
                                  FM_DEPENDTREE_ENTRY,
                                  ListEntry);
        OmDereferenceObject(Entry->Resource);
        LocalFree(Entry);
    }
    LocalFree(Tree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\worker.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    Failover Manager worker thread.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/

#define UNICODE 1

#include "fmp.h"

#define LOG_MODULE WORKER


CL_QUEUE FmpWorkQueue;


//
// Local Data
//
HANDLE             FmpWorkerThreadHandle = NULL;

//
// Forward routines
//
BOOL
FmpAddNodeGroupCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


//
// Local routines
//

DWORD
FmpWorkerThread(
    IN LPVOID Ignored
    )
{
    DWORD        status;
    PLIST_ENTRY  entry;
    PWORK_ITEM   workItem;
    DWORD        running = TRUE;
    PFM_RESOURCE resource;
    PFMP_POSSIBLE_NODE possibleNode;
    DWORD           i;

    ClRtlLogPrint(LOG_NOISE,"[FM] Worker thread running\n");

    while ( running ) {

        //
        // Check the FM work queue for work items
        //
        entry = ClRtlRemoveHeadQueue(&FmpWorkQueue);
        if ( entry == NULL ) {
            return(ERROR_SUCCESS);
        }

        workItem = CONTAINING_RECORD(entry,
                                     WORK_ITEM,
                                     ListEntry);

        //
        // FM no longer cares about node up events, make sure
        // we aren't getting any queued.
        //
        switch ( workItem->Event ) {

            case FM_EVENT_SHUTDOWN:
                ClRtlLogPrint(LOG_NOISE,"[FM] WorkerThread terminating...\n");
                running = FALSE;
                break;

            case FM_EVENT_RESOURCE_ADDED:
                resource = workItem->Context1;
                if ( resource->Monitor == NULL ) {
                    FmpAcquireLocalResourceLock( resource );
                    //
                    //  Chittur Subbaraman (chitturs) - 8/12/99
                    //
                    //  Make sure the resource is not marked for delete.
                    //
                    if ( IS_VALID_FM_RESOURCE( resource ) )
                    {
                        FmpInitializeResource( resource, TRUE );
                    }
                    FmpReleaseLocalResourceLock( resource );
                }
                OmDereferenceObject( resource );
                break;

            case FM_EVENT_RESOURCE_DELETED:
                //
                // Tell the resource monitor to cleanup the resource.
                //
                resource = workItem->Context1;

                FmpAcquireLocalResourceLock( resource );

                // Now that no remaining resource depends on this resource and
                // this resource does not depend on any other resources, we can
                // terminate it in the resource monitor if the resource is not
                // already offline or failed
                //
                if ( (resource->Group->OwnerNode == NmLocalNode) &&
                     ((resource->State != ClusterResourceOffline) &&
                      (resource->State != ClusterResourceFailed))) {
                    FmpRmTerminateResource(resource);
                }


                status = FmpRmCloseResource(resource);
                ClRtlLogPrint( LOG_NOISE,
                            "[FM] WorkItem, delete resource <%1!ws!> status %2!u!\n",
                            OmObjectName(resource),
                            status );
                FmpReleaseLocalResourceLock( resource );
                OmDereferenceObject(resource);
                break;

            case FM_EVENT_GROUP_FAILED:
                FmpHandleGroupFailure( workItem->Context1 );
                break;

            case FM_EVENT_NODE_ADDED:
                //
                // We need to add this node to every resource's possible owners
                // list and to each group's preferred owners list.
                //
                OmEnumObjects( ObjectTypeGroup,
                               FmpAddNodeGroupCallback,
                               workItem->Context1,
                               NULL );
                break;

            case FM_EVENT_NODE_EVICTED:
                //
                // Enumerate all the resources types to remove any PossibleNode references.
                //
                OmEnumObjects(ObjectTypeResType,
                              FmpEnumResTypeNodeEvict,
                              workItem->Context1,
                              NULL);
            
                //
                // Enumerate all the resources to remove any PossibleNode references.
                //
                OmEnumObjects(ObjectTypeResource,
                              FmpEnumResourceNodeEvict,
                              workItem->Context1,
                              NULL);

                //
                // Enumerate all the groups to remove any PreferredNode references
                //
                OmEnumObjects(ObjectTypeGroup,
                              FmpEnumGroupNodeEvict,
                              workItem->Context1,
                              NULL);
                //Now dereference the object
                OmDereferenceObject( workItem->Context1 );
                break;

            case FM_EVENT_CLUSTER_PROPERTY_CHANGE:
                //this is for the cluster name change
                FmpClusterEventPropHandler((PFM_RESOURCE)workItem->Context1);

                //Now dereference the object
                OmDereferenceObject( workItem->Context1 );
                break;

            case FM_EVENT_RESOURCE_CHANGE:
                // this is for a Add/Remove possible node request
                possibleNode = workItem->Context1;
                if ( possibleNode == NULL ) {
                    break;
                }
                FmpRmResourceControl( possibleNode->Resource,
                                      possibleNode->ControlCode,
                                      (PUCHAR)OmObjectName(possibleNode->Node),
                                      ((lstrlenW(OmObjectName(possibleNode->Node)) + 1) * sizeof(WCHAR)),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL );
                    // ignore status                                      
                OmDereferenceObject( possibleNode->Resource );
                OmDereferenceObject( possibleNode->Node );
                LocalFree( possibleNode );
                break;
                
            case FM_EVENT_RESOURCE_PROPERTY_CHANGE:
                //
                // Generate a cluster wide event notification for this event.
                //
                ClusterWideEvent(
                    CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                    workItem->Context1 // Resource
                    );
                OmDereferenceObject( workItem->Context1 );
                break;

            case FM_EVENT_RES_RESOURCE_TRANSITION:
                FmpHandleResourceTransition(workItem->Context1, workItem->Context2);
                OmDereferenceObject(workItem->Context1);
                break;

            case FM_EVENT_RES_RESOURCE_FAILED:
                FmpProcessResourceEvents(workItem->Context1, ClusterResourceFailed,
                        workItem->Context2);
                OmDereferenceObject( workItem->Context1 );
                break;
                
            case FM_EVENT_RES_RETRY_TIMER:

                resource= (PFM_RESOURCE)workItem->Context1;
                //Remove any pending watchdog timer
                if (resource->hTimer)
                {   
                    RemoveTimerActivity(resource->hTimer);
                    resource->hTimer = NULL;
                }    
                
                FmpAcquireLocalResourceLock(resource);

                // Check if this resource was deleted in the meanwhile, 
                // or is not in failed state
                if( ( IS_VALID_FM_RESOURCE( resource ) ) &&
                    ( resource->State == ClusterResourceFailed ) &&
                    ( resource->PersistentState == ClusterResourceOnline ) )
                {        
                    // Check if we are the owner, if not ignore it
                    if ( resource->Group->OwnerNode == NmLocalNode ) 
                    {
                        FmpProcessResourceEvents(resource,
                                        ClusterResourceFailed,
                                        ClusterResourceOnline);                                            
                    }
                }

                FmpReleaseLocalResourceLock(resource);
                OmDereferenceObject( workItem->Context1 );
                break;                                  


            case FM_EVENT_INTERNAL_PROP_GROUP_STATE:
                FmpPropagateGroupState(workItem->Context1);
                OmDereferenceObject( workItem->Context1 );
                break;


            case FM_EVENT_INTERNAL_RETRY_ONLINE:
            {
                PFM_RESLIST_ONLINE_RETRY_INFO   pFmOnlineRetryInfo;  
                            
                RemoveTimerActivity((HANDLE)workItem->Context2);
                pFmOnlineRetryInfo= workItem->Context1;
                CL_ASSERT(pFmOnlineRetryInfo);
                
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpWorkerThread, retrying to online resourcelist\r\n");
                FmpOnlineResourceFromList(&(pFmOnlineRetryInfo->ResourceEnum));
                
                //Free memory 
                for (i =0; i< pFmOnlineRetryInfo->ResourceEnum.EntryCount; i++)
                    LocalFree( pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id ); 
                LocalFree(pFmOnlineRetryInfo);                    
                break;
            }

            case FM_EVENT_INTERNAL_RESOURCE_CHANGE_PARAMS:
            {
                BOOL    bIsValidRes = TRUE;
                
                //
                // Now tell the resource monitor about the changes.
                //
                status = ERROR_SUCCESS;
                resource = (PFM_RESOURCE)workItem->Context1;
                FmpAcquireLocalResourceLock( resource );
                //
                //  Chittur Subbaraman (chitturs) - 8/12/99
                //
                //  Check whether the resource is marked for delete.
                //
                if ( !IS_VALID_FM_RESOURCE( resource ) )
                {
                    bIsValidRes = FALSE;
                } 

                FmpReleaseLocalResourceLock( resource );

                if( bIsValidRes ) 
                {
                    status = FmpRmChangeResourceParams( resource );
                }
                
                if ( status != ERROR_SUCCESS ) 
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] FmpWorkerThread, failed to change resource "
                                "parameters for %1!ws!, error %2!u!.\n",
                               OmObjectId(resource),
                               status );
                }
                OmDereferenceObject(resource);
                break;
            }

            case FM_EVENT_INTERNAL_ONLINE_GROUPLIST:
            {
                PGROUP_ENUM pGroupList = NULL;

                ClRtlLogPrint(LOG_NOISE, 
                    "[FM] FmpWorkerThread : Processing Node Down Group List\n");
                pGroupList = workItem->Context1;
                FmpOnlineGroupList(pGroupList, TRUE);
                FmpDeleteEnum(pGroupList);
                break;

            }

            case FM_EVENT_RESOURCE_NAME_CHANGE:
            {
                //
                //  Chittur Subbaraman (chitturs) - 6/29/99
                //
                //  Added this new event to handle resource name change
                //  notifications to resource DLLs.
                //
                PFM_RES_CHANGE_NAME pResChangeName = NULL;
                DWORD   dwStatus = ERROR_SUCCESS;
                
                pResChangeName = ( PFM_RES_CHANGE_NAME ) workItem->Context1;

                dwStatus = FmpRmResourceControl( pResChangeName->pResource,
                                   CLUSCTL_RESOURCE_SET_NAME,
                                   (PUCHAR) pResChangeName->szNewResourceName,
                                   ((lstrlenW(pResChangeName->szNewResourceName) + 1) * sizeof(WCHAR)),
                                   NULL,
                                   0,
                                   NULL,
                                   NULL );

                ClRtlLogPrint(LOG_NOISE,
                        "[FM] Worker thread handling FM_EVENT_RESOURCE_NAME_CHANGE event - FmpRmResourceControl returns %1!u! for resource %2!ws!\n",
                        dwStatus,
                        OmObjectId(pResChangeName->pResource));

                OmDereferenceObject( pResChangeName->pResource );
                LocalFree( pResChangeName );                      
                break;
            }
            
            default:
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] WorkerThread, unrecognized event %1!u!\n",
                           workItem->Event);
        }

        //
        // Free the work item.
        //

        LocalFree( workItem );

    }

    return(ERROR_SUCCESS);

} // FmpWorkerThread


VOID
FmpProcessResourceEvents(
    IN PFM_RESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState
    )

/*++

Routine Description:

Arguments:

Return Value:

Comments:  This should not call PropagateResourceState().  FmpProcessResourceEvents
acquires the group lock.  The quorum resource state must be propagated without holding
the group lock.  FmpPropagateResourceState() must be called by FmpHandleResourceTransition.
There is a slight window between when the event is received in FmpHandleResourceTransition()
and when the actions corresponding to those are carried out in FmpProcessResourceEvents().
In this window, another opposing action like offline/online might occur.  But we dont
worry about it since if there are waiting resources on this resource, those actions
are not carried out.

--*/

{
    DWORD                   Status;
    BOOL                    bQuoChangeLockHeld = FALSE;
    
    
    CL_ASSERT(pResource != NULL);
    
ChkFMState:
    if (!FmpFMGroupsInited)
    {
        DWORD   dwRetryCount = 50;
        
        ACQUIRE_SHARED_LOCK(gQuoChangeLock);

        //FmFormNewClusterPhaseProcessing is in progress
        if (FmpFMFormPhaseProcessing)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpProcessResourceEvents, resource notification from quorum resource during phase processing,sleep and retry\n");
            RELEASE_LOCK(gQuoChangeLock);
            Sleep(500);
            if (dwRetryCount--)
                goto ChkFMState;
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpProcessResourceEvents, waited for too long\n");
                //terminate the process                    
                CL_ASSERT(FALSE);
            }
        }
        else
        {
            bQuoChangeLockHeld = TRUE;
        }
        //this can only come from the quorum resource
        CL_ASSERT(pResource->QuorumResource);
    }


    FmpAcquireLocalResourceLock( pResource );

    //
    //  Chittur Subbaraman (chitturs) - 8/12/99
    //
    //  First check whether the resource has been marked for deletion. If
    //  so, don't do anything. Note that this function is called from
    //  the worker thread AFTER FmpHandleResourceTransition has propagated
    //  the failed state of the resource. Now, after the propagation has
    //  occurred, a client is free to delete the resource. So, when the
    //  worker thread makes this function call, we need to check whether
    //  the resource is deleted and reject the call. Note that this function
    //  holds the resource lock on the owner node of the resource and so 
    //  is serialized with the FmDeleteResource call which is also executed
    //  on the owner node of the resource with the lock held. So, the 
    //  following check will give us a consistent result.
    //
    if ( !IS_VALID_FM_RESOURCE( pResource ) )
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpProcessResourceEvents: Resource %1!ws! has already been deleted, returning...\n",
            OmObjectId(pResource));
        goto FnExit;
    }

    switch(NewState){
        case ClusterResourceFailed:
            //check the old resource state
            if (OldState == ClusterResourceOnline)
            {
                FmpHandleResourceFailure(pResource);
            }
            else if ((OldState == ClusterResourceOffline) ||
                    (OldState == ClusterResourceOfflinePending))
            {
                FmpTerminateResource(pResource);
                if ( pResource->Group->OwnerNode == NmLocalNode ) 
                {
                    Status = FmpOfflineWaitingTree(pResource);
                    if ( Status != ERROR_IO_PENDING) 
                    {
                        FmpSignalGroupWaiters( pResource->Group );
                    }
                }
            }
            else if (OldState == ClusterResourceOnlinePending)
            {
                FmpHandleResourceFailure(pResource);
                FmpSignalGroupWaiters( pResource->Group );

            }
            break;

        case ClusterResourceOnline:
            if (OldState == ClusterResourceOnlinePending)
            {
                Status = FmpOnlineWaitingTree( pResource );
                if (Status != ERROR_IO_PENDING) {
                    FmpSignalGroupWaiters( pResource->Group );
                }
            }
            break;
            
        case ClusterResourceOffline:
            if ((OldState == ClusterResourceOfflinePending) ||
                (OldState == ClusterResourceOffline))
            {
                Status = FmpOfflineWaitingTree(pResource);
                if ( Status != ERROR_IO_PENDING) 
                {
                    FmpSignalGroupWaiters( pResource->Group );
                }
            }
            break;
    }

FnExit:
    FmpReleaseLocalResourceLock( pResource );
    
    if (bQuoChangeLockHeld)   RELEASE_LOCK(gQuoChangeLock);

    return;

}


VOID
FmpPostWorkItem(
    IN CLUSTER_EVENT Event,
    IN PVOID         Context1,
    IN ULONG_PTR     Context2
    )

/*++

Routine Description:

    Posts a work item event to the FM work queue.

Arguments:

    Event - The event to post.
    Context1 - A pointer to some context.  This context should be permanent
            in memory - i.e. it should not be deallocated when this call
            returns.
    Context2 - A pointer to additional context.  This context should be
            permanent in memory - i.e. it should not be deallocated when this
            call returns.

Returns:

    None.

--*/

{
    PWORK_ITEM workItem;

    workItem = LocalAlloc(LMEM_FIXED, sizeof(WORK_ITEM));

    if ( workItem == NULL ) {
        CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
    } else {
        workItem->Event = Event;
        workItem->Context1 = Context1;
        workItem->Context2 = Context2;

        //
        // Insert work item on queue and wake up the worker thread.
        //
        ClRtlInsertTailQueue(&FmpWorkQueue, &workItem->ListEntry);
    }

} // FmpPostEvent



DWORD
FmpStartWorkerThread(
    VOID
    )
{
    DWORD       threadId;
    DWORD       Status;

    //
    // Start up our worker thread
    //
    ClRtlLogPrint(LOG_NOISE,"[FM] Starting worker thread...\n");

    FmpWorkerThreadHandle = CreateThread(
                                NULL,
                                0,
                                FmpWorkerThread,
                                NULL,
                                0,
                                &threadId
                                );

    if (FmpWorkerThreadHandle == NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] Failed to start worker thread %1!u!\n",
            GetLastError()
            );
        return(GetLastError());
    }

    return(ERROR_SUCCESS);

} // FmpStartWorkerThread



BOOL
FmpAddNodeGroupCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Enumeration callback for each group in the system when a new
    node is added to the cluster.

    The algorithm used here is to enumerate all the resources in
    this group.  For each resource in the group that does not
    have an explicit "PreferredOwners" setting in the registry,
    the node is added as a PossibleNode.  Finally, if the node
    was added as a possiblenode for each resource in the group,
    the node is added to the end of the preferredowners list for
    the group.

Arguments:

    Context1 - Supplies the PNM_NODE of the new node.

    Context2 - Not used.

    Object - Supplies the group object.

    Name - Supplies the name of the group object.

Return Value:

    TRUE

--*/

{
    PFM_RESOURCE Resource;
    PFM_GROUP Group;
    PNM_NODE Node;
    HDMKEY hKey;
    DWORD Status;
    PPREFERRED_ENTRY preferredEntry;
    PRESOURCE_ENUM ResourceEnum;
    DWORD  i;

    Group = (PFM_GROUP)Object;
    Node = (PNM_NODE)Context1;

    FmpAcquireLocalGroupLock( Group );
    Status = FmpGetResourceList( &ResourceEnum,
                                 Group );
    FmpReleaseLocalGroupLock( Group );
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] AddNodeGroup, failed to get resource list for group %1!ws!, status %2!u!.\n",
                   Name,
                   Status );
        return(TRUE);
    }

    //
    // First fix up the resource info.
    //
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        Resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );
        if ( Resource != NULL ) {
            FmpAcquireLocalResourceLock( Resource );
            //ss: we need to hold the resource lock as well
            //since that is the one that the update (FmpUpdateChangeResourceNode)
            // to remove and add nodes obtains and we must synchronize with it
            FmpAcquireResourceLock();
            Status = FmpFixupResourceInfo( Resource );
            FmpReleaseResourceLock();
            FmpReleaseLocalResourceLock( Resource );
            if ( Status == ERROR_SUCCESS ) {
                FmpRmResourceControl( Resource,
                                      CLUSCTL_RESOURCE_INSTALL_NODE,
                                      (PUCHAR)OmObjectName(Node),
                                      ((lstrlenW(OmObjectName(Node)) + 1) * sizeof(WCHAR)),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL );
                // Ignore status return

                ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                              Resource );
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] AddNodeGroup, failed to fixup info for resource %1!ws! when node was added!\n",
                           OmObjectName( Resource ) );
            }
            OmDereferenceObject( Resource );
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] AddNodeGroup, failed to find resource %1!ws! in group %2!ws!.\n",
                       ResourceEnum->Entry[i].Id,
                       Name );
        }
    }

    FmpDeleteResourceEnum( ResourceEnum );

    //
    // Now fix up the group information.
    //
    FmpAcquireLocalGroupLock( Group );
    Status = FmpFixupGroupInfo( Group );
    FmpReleaseLocalGroupLock( Group );
    if ( Status == ERROR_SUCCESS ) {
        ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group );
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] AddNodeGroup, failed to fixup info for group %1!ws! when node was added, status %2!u!.\n",
                   OmObjectName( Group ),
                   Status );
    }

    return(TRUE);

} // FmpAddNodeGroupCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\fm\restype.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    restype.c

Abstract:

    Public interfaces for managing the resource types in a cluster

Author:

    John Vert (jvert) 11-Jan-1996

Revision History:

--*/
#include "fmp.h"


//
// Data local to this module
//




DWORD
FmpInitResourceTypes(
    VOID
    )

/*++

 Routine Description:

    Initializes the resource type database. Process the ResourceType
    key in the registry. Each ResourceType found is added to the
    resource type database.

 Arguments:

    None.

 Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD       status;
    DWORD       keyIndex;
    LPWSTR      resTypeName = NULL;
    DWORD       resTypeNameMaxSize = 0;

    ClRtlLogPrint(LOG_NOISE,"[FM] processing resource types.\n");


    //
    // Enumerate all Resource Types.
    //

    for ( keyIndex = 0; ; keyIndex++ ) {
        status = FmpRegEnumerateKey( DmResourceTypesKey,
                                     keyIndex,
                                     &resTypeName,
                                     &resTypeNameMaxSize
                                    );

        if ( status == ERROR_SUCCESS ) {
            FmpCreateResType( resTypeName);
            continue;
        }

        if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
        } else {
            ClRtlLogPrint(LOG_NOISE,"[FM] FmpInitResourceTypes: FmpRegEnumerateKey error %1!u!\n", status);
        }

        break;
    }
    if (resTypeName) LocalFree(resTypeName);
    return(status);

} // FmpInitResourceTypes



/****
@func       DWORD | FmpFixupResourceTypesPhase1| This fixes up the possible nodes supporting
            a all the resource types.  It is called on join or form.

@parm       IN BOOL | bJoin | Set to TRUE on a join.

@parm       IN BOOL | bLocalNodeVersionChanged | Set to TRUE if the local node
            just upgraded.

@parm       IN PCLUSTERVERSIONINFO | pClusterVersionInfo | A pointer to the 
            cluster version info.

@comm       This routine checks all the resource types in a system and fixes
            their possible node information.  If this node is not on the possible
            node list, but this resource type is supported on the system, the
            node is added to the possible node list for that resource type.
            If this is on an upgrade, the version change control code is sent
            to the dll as well.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD
FmpFixupResourceTypesPhase1(
    IN BOOL    bJoin,
    IN BOOL    bNmLocalNodeVersionChanged,
    IN PCLUSTERVERSIONINFO  pClusterVersionInfo
    )
{
    DWORD       dwStatus=ERROR_SUCCESS;
    BOOL        pbBoolInfo[2];
    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase1 Entry.\n");

    //
    // Fix up all resources's possible node list information
    //
    pbBoolInfo[0]=bNmLocalNodeVersionChanged;
    if(bJoin)
       pbBoolInfo[1]=FALSE;
    else
        pbBoolInfo[1]=TRUE;
    
    
    OmEnumObjects( ObjectTypeResType,
                   FmpFixupPossibleNodesForResTypeCb,
                   pbBoolInfo,
                   pClusterVersionInfo);


    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase1 Exit\r\n");

    return(dwStatus);

} // FmpFixupResourceTypes


/****
@func       DWORD | FmpFixupResourceTypesPhase2| This fixes up the possible nodes supporting
            a all the resource types.  It is called on join or form.

@parm       IN BOOL | bJoin | Set to TRUE on a join.

@parm       IN BOOL | bLocalNodeVersionChanged | Set to TRUE if the local node
            just upgraded.

@parm       IN PCLUSTERVERSIONINFO | pClusterVersionInfo | A pointer to the 
            cluster version info.

@comm       If this is on an upgrade, the version change control code is sent
            to the dll as well.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD
FmpFixupResourceTypesPhase2(
    IN BOOL    bJoin,
    IN BOOL    bLocalNodeVersionChanged,
    IN PCLUSTERVERSIONINFO  pClusterVersionInfo
    )
{
    DWORD       dwStatus=ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase2 Entry.\n");

    //
    // Fix up all resources's possible node list information
    //
    OmEnumObjects( ObjectTypeResType,
                   FmpFixupResTypePhase2Cb,
                   &bJoin,
                   &bLocalNodeVersionChanged);


    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase Exit\r\n");

    return(dwStatus);

} // FmpFixupResourceTypes

/****
@func       BOOL | FmpFixupPossibleNodesForResTypeCb| This is the enumeration
            callback for every resource type to fix the possible node
            information related with it.

@parm       IN PVOID | pContext1 | Whether the local node has just upgraded.
@parm       IN PVOID | pContext2 | A pointer to the cluster version info.
@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type object.
@parm       IN LPCWSTR | pszResTypeName | The name of the resource type.

@comm       This routine checks a given resource types in a system and fixes
            its possible node information.  If this node is not on the possible
            node list, but this resource type is supported on the system, the
            node is added to the possible node list for that resource type.

@rdesc      Returns TRUE to continue enumeration, else returns FALSE.

@xref       <f FmpFixupResourceTypes>
****/
BOOL
FmpFixupPossibleNodesForResTypeCb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      pszResTypeName
    )
{

    PLIST_ENTRY     pListEntry;
    BOOL            bLocalNodeFound = FALSE;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    BOOL            bLocalNodeVersionChanged = FALSE;
    BOOL            bForm;
    PCLUSTERVERSIONINFO pClusterVersionInfo;
    DWORD           dwStatus;
    PCLUS_STARTING_PARAMS pClusStartingParams = NULL;
    eClusterInstallState eState;
    PBOOL            pbBoolInfo;
    
    //get the context parameters
    pbBoolInfo=(PBOOL)pContext1;

    bLocalNodeVersionChanged = pbBoolInfo[0];
    bForm = pbBoolInfo[1];
    
    pClusterVersionInfo = (PCLUSTERVERSIONINFO)pContext2;
    
    // safeguard against the list being modified while we are
    // traversing it
    
    ACQUIRE_SHARED_LOCK(gResTypeLock);

    pListEntry = &pResType->PossibleNodeList;

    for (pListEntry = pListEntry->Flink; pListEntry != &pResType->PossibleNodeList;
        pListEntry = pListEntry->Flink)
    {
        pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

        if (pResTypePosEntry->PossibleNode == NmLocalNode)
        {            
            bLocalNodeFound = TRUE;       
        }

    }

    RELEASE_LOCK(gResTypeLock);

    if (!bLocalNodeFound)
    {

        //check to see if we support this node, if we do make an update
        //to add our node name to the list
        dwStatus = FmpRmLoadResTypeDll(pResType);
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpFixupPossibleNodesForResTypeCb: FmpRmLoadDll returned %1!d! for restype %2!ws! \r\n",
                      dwStatus,
                      OmObjectId(pResType));  
        if (dwStatus == ERROR_SUCCESS)
        {

            HDMKEY  hResTypeKey;
            LPWSTR  pmszPossibleNodes = NULL;
            DWORD   dwlpmszLen;
            DWORD   dwSize;

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpFixupPossibleNodesForRestype: fix up resource type %1!ws!\r\n",
                       OmObjectId(pResType));

            bLocalNodeFound = TRUE;


            // The earlier method of updating possible nodes by first querying 
            // the registry and then appending this node to the list and then 
            // updating the registry by GUM update was not an atomic action
            // and was subject to race condition. Instead we now use 
            // FmpSetPossibleNodeForRestype to achieve this atomically.

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpFixupPossibleNodesForRestype: Calling FmpSetPossibleNodeForRestype resource type %1!ws!\r\n",
                       OmObjectId(pResType));
            
            dwStatus = FmpSetPossibleNodeForResType(OmObjectId(pResType),TRUE);
            if ( dwStatus != ERROR_SUCCESS) 
            {
                ClRtlLogPrint(LOG_CRITICAL,
                            "[FM] FmpFixupPossibleNodesForRestype:FmpSetPossibleNodeForResType  returned error %1!u!\r\n",
                            dwStatus);
                return(TRUE);
            }
        }

    }

    //if the version has changed and the localnode hosts this resource type
    //dll, drop
    if (bLocalNodeFound && bLocalNodeVersionChanged && pClusterVersionInfo)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpFixupPossibleNodeForResType: dropping "
                    "CLUSCTL_RESOURCE_TYPE_CLUSTER_VERSION_CHANGED control code "
                    "to restype '%1!ws!'\n",
                    pszResTypeName);

        FmpRmResourceTypeControl(pszResTypeName,
                    CLUSCTL_RESOURCE_TYPE_CLUSTER_VERSION_CHANGED, 
                    (LPBYTE)pClusterVersionInfo,
                    pClusterVersionInfo->dwVersionInfoSize,
                    NULL,
                    0,
                    NULL,
                    NULL
                    );

    }   

    pClusStartingParams = (PCLUS_STARTING_PARAMS)LocalAlloc(LMEM_FIXED,sizeof(CLUS_STARTING_PARAMS));
    if (pClusStartingParams == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpFixupPossibleNodesForResType: Failed to allocate memory\n");
        CL_UNEXPECTED_ERROR(dwStatus);
        return(TRUE);

    }    
    pClusStartingParams->dwSize = sizeof(CLUS_STARTING_PARAMS);

    // Drop down CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1

    pClusStartingParams->bFirst = CsFirstRun;

    pClusStartingParams->bForm = bForm;    
        
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpFixupPossibleNodesForResType: dropping "
                "CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1 control code to restype '%1!ws!'\n",
                pszResTypeName);

    FmpRmResourceTypeControl(pszResTypeName,
                CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1, 
                (LPBYTE)pClusStartingParams,
                pClusStartingParams->dwSize,
                NULL,
                0,
                NULL,
                NULL
                );

    if(pClusStartingParams)
        LocalFree(pClusStartingParams);
    
    return (TRUE);
}

/****
@func       BOOL | FmpFixupResTypePhase2| This is the enumeration
            callback for every resource type to do post FM online
            fixups.

@parm       IN PVOID | pContext1 | Whether the local node has just upgraded.
@parm       IN PVOID | pContext2 | A pointer to the cluster version info.
@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type object.
@parm       IN LPCWSTR | pszResTypeName | The name of the resource type.

@comm       This routine checks a given resource types in a system and fixes
            its possible node information.  If this node is not on the possible
            node list, but this resource type is supported on the system, the
            node is added to the possible node list for that resource type.

@rdesc      Returns TRUE to continue enumeration, else returns FALSE.

@xref       <f FmpFixupResourceTypes>
****/
BOOL
FmpFixupResTypePhase2Cb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      pszResTypeName
    )
{
    BOOL    bJoin;
    BOOL    bLocalNodeVersionChanged;
    DWORD   dwStatus;
    CLUS_RESOURCE_CLASS_INFO rcClassInfo;
    PCLUS_STARTING_PARAMS pClusStartingParams = NULL;
    eClusterInstallState eState;

    
    bJoin = *((PBOOL)pContext1);
    bLocalNodeVersionChanged = *((PBOOL)pContext2);
    //if the version has changed let the resource type dll
    // do any fixups.
    if (bLocalNodeVersionChanged)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpFixupResTypePhase2Cb: dropping CLUSCTL_RESOURCE_TYPE_FIXUP_ON_UPGRADE "
                    "control code to restype '%1!ws!'\n",
                    pszResTypeName);

        FmpRmResourceTypeControl(pszResTypeName,
                    CLUSCTL_RESOURCE_TYPE_FIXUP_ON_UPGRADE, 
                    (LPBYTE)&bJoin,
                    sizeof(BOOL),
                    NULL,
                    0,
                    NULL,
                    NULL
                    );

    }      

    // Drop down CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2

    pClusStartingParams = (PCLUS_STARTING_PARAMS)LocalAlloc(LMEM_FIXED,sizeof(CLUS_STARTING_PARAMS));
    if (pClusStartingParams == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpFixupResTypePhase2Cb: Failed to allocate memory\n");
        CL_UNEXPECTED_ERROR(dwStatus);
        return(TRUE);

    }    
    pClusStartingParams->dwSize = sizeof(CLUS_STARTING_PARAMS);
    pClusStartingParams->bFirst = CsFirstRun;            

    if(bJoin)
        pClusStartingParams->bForm =  FALSE;
    else
        pClusStartingParams->bForm =  TRUE;
           
        
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpFixupResTypePhase2Cb: dropping CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2 "
                 "control code to restype '%1!ws!', bFirst= %2!u!\n",
                 pszResTypeName,
                 pClusStartingParams->bFirst);

    FmpRmResourceTypeControl(pszResTypeName,
                CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2, 
                (LPBYTE)pClusStartingParams,
                pClusStartingParams->dwSize,
                NULL,
                0,
                NULL,
                NULL
                );

    //
    // Now query for the class information
    //
    rcClassInfo.dw = CLUS_RESCLASS_UNKNOWN;
    dwStatus = FmpRmResourceTypeControl(pszResTypeName,
                CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                NULL,
                0,
                (PUCHAR)&rcClassInfo,
                sizeof(CLUS_RESOURCE_CLASS_INFO),
                NULL,
                NULL );
    if ( dwStatus != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpFixupRestypePhase2Cb: Restype %1!ws!, class = %2!u!, status = %3!u!\n",
               pszResTypeName,
               rcClassInfo.dw,
               dwStatus );
    }

    pResType->Class = rcClassInfo.dw;

    if(pClusStartingParams)
        LocalFree(pClusStartingParams);
    return(TRUE);

}

PFM_RESTYPE
FmpCreateResType(
    IN LPWSTR ResTypeName
    )

/*++

 Routine Description:

    Create a new resource type.

 Arguments:

    ResTypeName - Supplies the resource type name.

 Return Value:

    Do a get last error to get the error. 

 Comments :  If the object already exists, it returns an error.
    If the resource type is created, its reference count is 1.


--*/
{
    DWORD               status = ERROR_SUCCESS;
    PFM_RESTYPE         resType = NULL;
    BOOL                created;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    PLIST_ENTRY         pListEntry;

    resType = OmCreateObject( ObjectTypeResType,
                              ResTypeName,   // This is really the Id
                              NULL,
                              &created);

    if ( resType == NULL ) {
        status = GetLastError();
        goto FnExit;
    }
    // A resource type may be recreated twice, once before the
    //quorum resource is online and once after the database has
    //been uptodated, hence we need to handle the two cases
    if ( created ) {
        resType->State = 0;
        InitializeListHead(&(resType->PossibleNodeList));
    }
    else
    {
        //free the old list, we will recreate it again
        while (!IsListEmpty(&resType->PossibleNodeList))
        {
            pListEntry = RemoveHeadList(&resType->PossibleNodeList);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            OmDereferenceObject(pResTypePosEntry->PossibleNode);
            LocalFree(pResTypePosEntry);
        }
        OmDereferenceObject(resType);

    }
    status = FmpQueryResTypeInfo( resType );

    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //if the object was just created, insert it in the list
    if (created)
    {
        status = OmInsertObject( resType );
    }



FnExit:
    if (status != ERROR_SUCCESS)
    {
        SetLastError(status);
        if (resType) 
        {
            OmDereferenceObject( resType );
            resType = NULL;
        }            
    }        
    return(resType);

} // FmpCreateResType



DWORD
FmpDeleteResType(
    IN PFM_RESTYPE pResType
    )

/*++

Routine Description:

    This routine destroys a Resource Type.

Arguments:

    ResType - The Resource Type to destroy.

Returns:

    None.

--*/

{
    DWORD   status;

    status = OmRemoveObject( pResType );


    CL_ASSERT( status == ERROR_SUCCESS );
    //decrement the ref count to get rid of it
    OmDereferenceObject(pResType);
    return(status);
} // FmpDestroyResType


BOOL
FmpFindResourceType(
    IN PFM_RESTYPE Type,
    IN PBOOL ResourceExists,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Callback routine for enumerating resources to see if a given
    resource type exists or not.

Arguments:

    Type - Supplies the resource type to look for.

    ResourceExists - Returns whether or not a resource of the given
        type was found.

    Resource - Supplies the resource.

    Name - Supplies the resource name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

    FALSE - to indicate that the enumeration should not continue.

--*/

{
    if (Resource->Type == Type) {
        *ResourceExists = TRUE;
        return(FALSE);
    }
    return(TRUE);
} // FmpFindResourceType



DWORD
FmpHandleResourceTypeControl(
    IN PFM_RESTYPE Type,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Handle resource type control requests for the FM.

Arguments:

    Type - Supplies the resource type to look for.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - The number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    DWORD   dataValue;
    LPWSTR  debugPrefix = NULL;

    switch ( ControlCode ) {

    case CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES:
        //
        // Re-fetch the IsAlive value.
        //
        status = ClRtlFindDwordProperty( InBuffer,
                                         InBufferSize,
                                         CLUSREG_NAME_RESTYPE_IS_ALIVE,
                                         &dataValue );
        if ( status == ERROR_SUCCESS ) {
            Type->IsAlivePollInterval = dataValue;
        }

        //
        // Re-fetch the LooksAlive value.
        //
        status = ClRtlFindDwordProperty( InBuffer,
                                         InBufferSize,
                                         CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                                         &dataValue );
        if ( status == ERROR_SUCCESS ) {
            Type->LooksAlivePollInterval = dataValue;
        }

        //
        // Re-fetch the DebugPrefix value.
        //
        status = ClRtlFindSzProperty( InBuffer,
                                      InBufferSize,
                                      CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,
                                      &debugPrefix );
        if ( status == ERROR_SUCCESS ) {
            LocalFree( Type->DebugPrefix );
            Type->DebugPrefix = debugPrefix;
        }

        //
        // Re-fetch the DebugControlFunctions value.
        //
        status = ClRtlFindDwordProperty( InBuffer,
                                         InBufferSize,
                                         CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC,
                                         &dataValue );
        if ( status == ERROR_SUCCESS ) {
            if ( dataValue ) {
                Type->Flags |= RESTYPE_DEBUG_CONTROL_FUNC;
            } else {
                Type->Flags &= ~RESTYPE_DEBUG_CONTROL_FUNC;
            }
        }

        break;

    default:
        break;

    }

    return(ERROR_SUCCESS);

} // FmpHandleResourceTypeControl



VOID
FmpResTypeLastRef(
    IN PFM_RESTYPE pResType
    )

/*++

Routine Description:

    Last dereference to resource object processing routine.
    All cleanup for a resource should really be done here!

Arguments:

    Resource - pointer the resource being removed.

Return Value:

    None.

--*/

{

    if (pResType->DllName)
    {
        LocalFree(pResType->DllName);
    }
    if (pResType->DebugPrefix)
    {
        LocalFree(pResType->DebugPrefix);
    }

    return;

} // FmpResourceLastReference



DWORD
FmpAddPossibleNodeToList(
    IN LPCWSTR      pmszPossibleNodes,
    IN DWORD        dwStringSize,         
    IN PLIST_ENTRY  pPosNodeList
)    
{    

    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    DWORD                   i;
    DWORD                   dwStatus = ERROR_SUCCESS;
    LPCWSTR                 pszNode;

    dwStringSize = dwStringSize/sizeof(WCHAR);

    for (i=0; ; i++)
    {
        PNM_NODE    pNmNode;

        pszNode = ClRtlMultiSzEnum(pmszPossibleNodes, dwStringSize, i);
        
        //last string, break out of the loop
        if ((!pszNode) || (*pszNode == UNICODE_NULL))
            break;

        pNmNode = OmReferenceObjectById(ObjectTypeNode,
            pszNode);
        if (!pNmNode)
        {
            //this can be called when all node structures havent been
            //created
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpAddPossibleNodeToList: Warning, node %1!ws! not found\n",
                       pszNode);
            continue;
        }

        pResTypePosEntry = (PRESTYPE_POSSIBLE_ENTRY)LocalAlloc(LMEM_FIXED, sizeof(RESTYPE_POSSIBLE_ENTRY));

        if (!pResTypePosEntry)
        {
            OmDereferenceObject(pNmNode);
            dwStatus = GetLastError();
            goto FnExit;
        }

        //this can be called when all node structures havent been
        //created
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpAddPossibleNodeToList: adding node %1!ws! to resource "
                    "type's possible node list\n",
                    pszNode);
        pResTypePosEntry->PossibleNode = pNmNode;
        InsertTailList(pPosNodeList, &pResTypePosEntry->PossibleLinkage);

    }

FnExit:
    return(dwStatus);
} // FmpAddPossibleNodeToList



DWORD
FmpSetPossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN BOOL    bAssumeSupported
    )
/*++

Routine Description:

    Issues a GUM update to update the possible node list for a resource
    type on every node. The necessary registry information must already
    be in the cluster registry.

Arguments:

    TypeName - Supplies the name of the cluster resource type to update.

    bAssumeSupported - If the node doesnt answer, we assume that the node
        supports this resource type if it already on the possible node
        list for the resource type, i.e in the past it had supported this
        resource type.
    

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD       dwStatus = ERROR_SUCCESS;
    PFM_RESTYPE pResType = NULL;


    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetPossibleNodeForResType: for type %1!ws!, bAssumeSupported= %2!u!.\n",
                TypeName,
                bAssumeSupported );



    dwStatus = GumSendUpdateOnVote( GumUpdateFailoverManager,
                    FmUpdatePossibleNodeForResType,
                    (lstrlenW(TypeName) + 1) * sizeof(WCHAR),
                    (PVOID) TypeName,
                    sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE),
                    FmpDecidePossibleNodeForResType,
                    (PVOID)&bAssumeSupported);

    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpSetPossibleNodeForResType: Gum update failed for %1!ws!, status = %2!u!.\n",
                   TypeName,
                   dwStatus );
    }

    return(dwStatus);
    
} // FmpSetPossibleNodeForResType


DWORD
FmpRemovePossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN PNM_NODE pNode
    )
/*++

Routine Description:

    Reads the current list of possible nodes for a restype, removes the specified node
    and then issues a GUM update to update the possible node list for a resource
    type on all nodes.

Arguments:

    TypeName - Supplies the name of the cluster resource type to update.

    pNode - The node that is to be removed from the list of possible nodes.
    

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD       dwStatus = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
           "[FM] FmpRemovePossibleNodeForResType: remove node %1!u! from resource "
            "type's %2!ws! possible node list\n",
            NmGetNodeId(pNode),
            TypeName);

    
    dwStatus = FmpSetPossibleNodeForResType(TypeName,TRUE);
    ClRtlLogPrint(LOG_ERROR,
        "[FM] FmpRemovePossibleNodeForRestype: Exit with Status %1!u!\r\n",
        dwStatus);
    return(dwStatus);
    
} // FmpRemovePossibleNodeForResType

BOOL
FmpEnumResTypeNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource type enumeration callback for removing node references when
    a node is evicted.

Arguments:

    Context1 - Supplies the node that is being evicted.

    Context2 - not used

    Object - Supplies a pointer to the resource object

    Name - Supplies the resource's object name.

Return Value:

    TRUE to continue enumeration

--*/

{
    PFM_RESTYPE pResType = (PFM_RESTYPE)Object;
    PNM_NODE pNode = (PNM_NODE)Context1;
    PLIST_ENTRY pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpEnumResTypeNodeEvict: Removing references to node %1!ws! from restype %2!ws!\n",
               OmObjectId(pNode),
               OmObjectId(pResType));
               
    ACQUIRE_SHARED_LOCK(gResTypeLock);

    pListEntry = pResType->PossibleNodeList.Flink;
    while (pListEntry != &pResType->PossibleNodeList) {
        pResTypePosEntry = CONTAINING_RECORD(pListEntry,
                                          RESTYPE_POSSIBLE_ENTRY,
                                          PossibleLinkage);
        pListEntry = pListEntry->Flink;
        if (pResTypePosEntry->PossibleNode == pNode)
        {
            RemoveEntryList(&pResTypePosEntry->PossibleLinkage);
            break;
        }
    }

    ClusterEvent( CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE, pResType);
    RELEASE_LOCK(gResTypeLock);
  
    return(TRUE);

} // FmpEnumResTypeNodeEvict

// The DLL Name field is are hardcoded in here. More 
// appropriately, thse should be read from cluster.inf using setup API's.

DWORD FmpBuildWINSParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName,
   IN OUT LPWSTR * ppResTypeName,
   IN OUT LPWSTR * ppAdminExt,
   IN LPWSTR       lpKeyName, 
   IN HDMKEY       hdmKey,
   IN BOOL         CopyOldData
   )
/**
    Helper routine for FmBuildWINS. It packs parameters for WINS 
    Key into a parameter list.

**/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize,dwTemp1,dwTemp2;
    LPWSTR          lpOldName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;    
    DWORD           dwAdminExtSize;

    dwTotalSize=3* sizeof(DWORD) + 3*(sizeof (LPWSTR)) ;
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    if(CopyOldData)
    {
        dwStatus = DmQueryDword( hdmKey,
                       CLUSREG_NAME_RESTYPE_IS_ALIVE,
                       &dwTemp1,
                       NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp1 = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The IsAlive poll interval for the %1!ws! resource type "
                              "could not be read from the registry. Resources of this type "
                              "will not be monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_WINS,
                              dwStatus);
                goto FnExit;
            }
        }

        dwStatus = DmQueryDword( hdmKey,
               CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
               &dwTemp2,
               NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp2 = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The LooksAlive poll interval for the %1!ws! resource type could "
                              "not be read from the registry. Resources of this type will not be "
                              "monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_WINS,
                              dwStatus);
                goto FnExit;
            }
        }

    }    
    else
    {
        dwTemp1=CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
        dwTemp2=CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    }

    ((PDWORD)*ppInParams)[0]= dwTemp1;
    ((PDWORD)*ppInParams)[1]= dwTemp2; 

    dwNameSize=(lstrlen(L"ClNetRes.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }

    CopyMemory(*ppDllName,L"ClNetRes.dll",dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD),ppDllName,sizeof(LPWSTR));

    //check if the resource type name needs to copied
    if(CopyOldData)
    {
        dwStatus = DmQuerySz( hdmKey,
                        CLUSREG_NAME_RESTYPE_NAME,
                        &lpOldName,
                        &dwSize,
                        &dwStringSize );
        if ( dwStatus != NO_ERROR ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmpBuidlWINSParams: Failed to read from registry, status = %1!u!\n",
                       dwStatus);
            goto FnExit;
        }           
    }
    else
    {
        dwSize=(lstrlen(lpKeyName)+1)*sizeof(WCHAR);
        lpOldName=(LPWSTR ) LocalAlloc(LMEM_FIXED,dwSize);
        if (lpOldName == NULL)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        CopyMemory(lpOldName,lpKeyName,dwSize);
    }
    
    dwNameSize=(lstrlen(lpOldName)+1)*sizeof(WCHAR);
    *ppResTypeName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppResTypeName == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(*ppResTypeName,lpOldName,dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD)+sizeof(LPWSTR),ppResTypeName,sizeof(LPWSTR));

    //copy adminextensions value
    dwAdminExtSize = (lstrlen(L"{AB4B1105-DCD6-11D2-84B7-009027239464}")+1)*sizeof(WCHAR);
    dwNameSize = dwAdminExtSize + sizeof(WCHAR); //size of the terminating NULL
    *ppAdminExt= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppAdminExt == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(*ppAdminExt,L"{AB4B1105-DCD6-11D2-84B7-009027239464}",dwAdminExtSize);
    (*ppAdminExt)[dwAdminExtSize/sizeof(WCHAR)] = L'\0';
    CopyMemory(*ppInParams+2*sizeof(DWORD)+2*sizeof(LPWSTR),ppAdminExt,sizeof(LPWSTR)); 
    CopyMemory(*ppInParams+2*sizeof(DWORD)+3*sizeof(LPWSTR),&dwNameSize,sizeof(DWORD)); 
FnExit:
    if(lpOldName)
        LocalFree(lpOldName);
    return dwStatus;
}//FmBuildWINSParams

/****
@func       DWORD | FmBuildWINS| Builds the property list for 
            WINS Servcie Regisrty entry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the Property Table for WINS Registry

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmpBuildWINSParams> 
****/

DWORD FmBuildWINS(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR    *  pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    LPWSTR          pResTypeName=NULL; 
    LPWSTR          pAdminExt=NULL;
    HDMKEY          hdmKey = NULL;
    BOOL            CopyOldData= TRUE; //whenever we do the fixups, copy old data 
    LPWSTR          pOldDllName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;
    DWORD           dwDisposition;
    
    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    // open the key, if it doesnt exist create it.
    hdmKey = DmCreateKey(DmResourceTypesKey, CLUS_RESTYPE_NAME_WINS, 0,
            KEY_READ | KEY_WRITE, NULL, &dwDisposition );
    if (hdmKey == NULL)
    {
        //should we create the key if the key is missing
        //if there is some other error we should exit
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmBuildWINS: Failed to create or open the wins resource type key, Status=%1!u!\r\n",
             dwStatus);
        goto FnExit;
    }

    if (dwDisposition == REG_CREATED_NEW_KEY)
        CopyOldData = FALSE;
    
    //check to see if the resource dll name is valid
    dwStatus = DmQuerySz( hdmKey,
                    CLUSREG_NAME_RESTYPE_DLL_NAME,
                    &pOldDllName,
                    &dwSize,
                    &dwStringSize );
    if ( dwStatus == ERROR_SUCCESS ) 
    {
        //SS: Always apply the fixup.  There was a bug in the win2K fixup
        //where the administrator extensions was not being treated like a 
        //multi-sz.  To fix the broken administrator extension we must 
        //always appy this fixup.
        //
#if 0
        if (!lstrcmpW(pOldDllName,L"ClNetRes.dll"))
        {                    
            // No need to apply the fixup.
            goto FnExit;    
        }
#endif
    }
    else
    {
        //fixup is needed
        //we assume that CopyOldData is always true
        //dwStatus will be overwritten by the return from next func call
    }


    //specify the key name for this fixup
    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);    


    // Build the parameter list
    dwStatus=FmpBuildWINSParams(&pInParams,&pDllName,&pResTypeName,&pAdminExt,CLUS_RESTYPE_NAME_WINS,hdmKey,CopyOldData);
    if (dwStatus!= ERROR_SUCCESS)
        goto FnExit;
    Required=sizeof(DWORD);
 AllocMem:  

    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmJoinFixupWINSProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
   //     ClRtlLogPrint(LOG_CRITICAL," AllocMem : ERROR_MORE_DATA\n");
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildWINS - error constructing property list. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            


FnExit:
// Cleanup
    if(pInParams)
        LocalFree(pInParams); 
    if(pDllName)
        LocalFree(pDllName);
    if (pResTypeName)
        LocalFree(pResTypeName);
    if (pAdminExt)
        LocalFree(pAdminExt);
    if(pOldDllName)
        LocalFree(pOldDllName);
    if (hdmKey)        
        DmCloseKey(hdmKey);
    return dwStatus;
} //FmBuildWINS


// The DLL Name and AdminExtensions field are hardcoded in here. More 
// appropriately, thse should be read from cluster.inf using setup API's.

DWORD
FmpBuildDHCPParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName,
   IN OUT LPWSTR * ppResTypeName,
   IN OUT LPWSTR * ppAdminExt,
   IN LPWSTR       lpKeyName, 
   IN HDMKEY       hdmKey,
   IN BOOL         CopyOldData 
)
/**
    Helper routine for FmBuildDHCP. It packs parameters for DHCP key into a parameter list.

**/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize,dwTemp1,dwTemp2;
    LPWSTR          lpOldName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize; 
    DWORD           dwAdminExtSize;

    
    dwTotalSize=3* sizeof(DWORD) + 3*(sizeof (LPWSTR))  ;
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }
    
    if(CopyOldData)    
    {
        dwStatus = DmQueryDword( hdmKey,
                       CLUSREG_NAME_RESTYPE_IS_ALIVE,
                       &dwTemp1,
                       NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp1 = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The IsAlive poll interval for the %1!ws! resource type "
                              "could not be read from the registry. Resources of this type "
                              "will not be monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_DHCP,
                              dwStatus);
                goto FnExit;
            }
        }

        dwStatus = DmQueryDword( hdmKey,
               CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
               &dwTemp2,
               NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp2 = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The LooksAlive poll interval for the %1!ws! resource type "
                              "could not be read from the registry. Resources of this type "
                              "will not be monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_DHCP,
                              dwStatus);
                goto FnExit;
            }
        }

    }
    else
    {
        dwTemp1=CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
        dwTemp2=CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    }

    ((PDWORD)*ppInParams)[0]= dwTemp1;
    ((PDWORD)*ppInParams)[1]= dwTemp2; 
    

    dwNameSize=(lstrlen(L"ClNetRes.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }
    CopyMemory(*ppDllName,L"ClNetRes.dll",dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD),ppDllName,sizeof(LPWSTR));

    //check if the resource type name needs to copied
    if(CopyOldData)
    {
        dwStatus = DmQuerySz( hdmKey,
                        CLUSREG_NAME_RESTYPE_NAME,
                        &lpOldName,
                        &dwSize,
                        &dwStringSize );
        if ( dwStatus != NO_ERROR ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmpBuidlDHCPParams: Failed to read from registry, status = %1!u!\n",
                       dwStatus);
            goto FnExit;
        }           
    }
    else
    {
        dwSize=(lstrlen(lpKeyName)+1)*sizeof(WCHAR);
        lpOldName=(LPWSTR ) LocalAlloc(LMEM_FIXED,dwSize);
        if (lpOldName == NULL)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        CopyMemory(lpOldName,lpKeyName,dwSize);
    }

    dwNameSize=(lstrlen(lpOldName)+1)*sizeof(WCHAR);
    *ppResTypeName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppResTypeName == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    CopyMemory(*ppResTypeName,lpOldName,dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD)+sizeof(LPWSTR),ppResTypeName,sizeof(LPWSTR));

    //copy adminextensions value
    dwAdminExtSize=(lstrlen(L"{AB4B1105-DCD6-11D2-84B7-009027239464}")+1)*sizeof(WCHAR);
    dwNameSize = dwAdminExtSize + sizeof(WCHAR);
    *ppAdminExt= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppAdminExt == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(*ppAdminExt,L"{AB4B1105-DCD6-11D2-84B7-009027239464}",dwAdminExtSize);
    (*ppAdminExt)[dwAdminExtSize/sizeof(WCHAR)] = L'\0';
    CopyMemory(*ppInParams+2*sizeof(DWORD)+2*sizeof(LPWSTR),ppAdminExt,sizeof(LPWSTR)); 
    CopyMemory(*ppInParams+2*sizeof(DWORD)+3*sizeof(LPWSTR),&dwNameSize,sizeof(DWORD)); 
FnExit:
    if(lpOldName)
        LocalFree(lpOldName);
    return dwStatus;
} //FmpBuildDHCPParams

/****
@func       DWORD | FmBuildDHCP| Builds the property list for 
            DHCP Servcie Regisrty entry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the Property Table for DHCP Registry

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmBuildDHCPParams> 
****/

DWORD FmBuildDHCP(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    LPWSTR          pResTypeName=NULL; 
    LPWSTR          pAdminExt=NULL;
    HDMKEY          hdmKey = NULL;
    BOOL            CopyOldData= TRUE; //whenever fixup is applied, copy the old data
    LPWSTR          pOldDllName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;
    DWORD           dwDisposition;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;


    // open the key, if it isnt present create it.
    hdmKey = DmCreateKey(DmResourceTypesKey, CLUS_RESTYPE_NAME_DHCP, 0,
            KEY_READ | KEY_WRITE, NULL, &dwDisposition );
    if (hdmKey == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmBuildDHCP: Failed to create or open the dhcp resource type key, Status=%1!u!\r\n",
                      dwStatus);
        goto FnExit;
    }

    if (dwDisposition == REG_CREATED_NEW_KEY)
        CopyOldData = FALSE;

    //check to see if the resource dll name is valid
    dwStatus = DmQuerySz( hdmKey,
                    CLUSREG_NAME_RESTYPE_DLL_NAME,
                    &pOldDllName,
                    &dwSize,
                    &dwStringSize );
    if ( dwStatus == ERROR_SUCCESS ) 
    {
        //SS: for now we will always apply the fixup.  There is a bug in the 
        //win2k fixup which needs to be fixed up..and one way of doing it to
        //always apply the new fixup
#if 0
        if (!lstrcmpW(pOldDllName,L"ClNetRes.dll"))
        {                    
            // No need to apply the fixup.
            goto FnExit;    
        }
#endif        
    }
    else
    {
        //fixup is needed
        //we assume that CopyOldData is always true
        //dwStatus will be overwritten by the return from next func call
    }


    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);    


    dwStatus=FmpBuildDHCPParams(&pInParams,&pDllName,&pResTypeName,&pAdminExt,CLUS_RESTYPE_NAME_DHCP,hdmKey,CopyOldData);
    if (dwStatus!= ERROR_SUCCESS)
        goto FnExit;
    Required=sizeof(DWORD);
 AllocMem:  

    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmJoinFixupDHCPProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
   //     ClRtlLogPrint(LOG_CRITICAL," AllocMem : ERROR_MORE_DATA\n");
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildDHCP: error construct property list. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            


FnExit:
    if(pInParams)
        LocalFree(pInParams); 
    if(pDllName)
        LocalFree(pDllName);
    if (pResTypeName)
        LocalFree(pResTypeName);
    if (pAdminExt)
        LocalFree(pAdminExt);
    if(pOldDllName)
        LocalFree(pOldDllName);
    if (hdmKey)        
        DmCloseKey(hdmKey);
        
    return dwStatus;
} //FmBuildDHCP

// The DLL Name and AdminExtensions field are hardcoded in here. More 
// appropriately, thse should be read from cluster.inf using setup API's.


// The DLL Name field is hardcoded in here. More 
// appropriately, it should be read from cluster.inf using setup API's.

DWORD
FmpBuildNewMSMQParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName,
   IN OUT LPWSTR * ppResTypeName,
   IN LPWSTR       lpResTypeDisplayName 
   )
/**
    Helper routine for FmBuildNewMSMQ. It packs parameters for MSMQ key into a parameter list.

**/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize;

    dwTotalSize=2* sizeof(DWORD) + 2*(sizeof (LPWSTR))  ;
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    ((PDWORD)*ppInParams)[0]= CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
    ((PDWORD)*ppInParams)[1]= CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE; 

    dwNameSize=(lstrlen(L"mqclus.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }

    
    CopyMemory(*ppDllName,L"mqclus.dll",dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD),ppDllName,sizeof(LPWSTR));

    dwNameSize=(lstrlen(lpResTypeDisplayName)+1)*sizeof(WCHAR);
    *ppResTypeName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppResTypeName == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    CopyMemory(*ppResTypeName,lpResTypeDisplayName,dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD)+sizeof(LPWSTR),ppResTypeName,sizeof(LPWSTR));

    return dwStatus;
} //FmpBuildNewMSMQParams

/****
@func       DWORD | FmBuildNewMSMQ| Builds the property list for 
            MSMQ Servcie Registry entry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the Property Table for MSMQ Registry

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmBuildNewMSMQParams> 
****/

DWORD FmBuildNewMSMQ(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    LPWSTR          pResTypeName=NULL; 
    HDMKEY          hdmKey;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    // if this key is already present in registry , skip
    hdmKey=DmOpenKey(DmResourceTypesKey,CLUS_RESTYPE_NAME_NEW_MSMQ,KEY_EXECUTE);
    if (hdmKey!= NULL)
    {
        DmCloseKey(hdmKey);
        goto FnExit;    
    } 

    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }    
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);    


    dwStatus=FmpBuildNewMSMQParams(&pInParams,&pDllName,&pResTypeName,CLUS_RESTYPE_DISPLAY_NAME_NEW_MSMQ);
    if (dwStatus!= ERROR_SUCCESS)
        goto FnExit;
    Required=sizeof(DWORD);
 AllocMem:  

    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmJoinFixupNewMSMQProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildNewMSMQ: error construct property list. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            


FnExit:
    if(pInParams)
        LocalFree(pInParams); 
    if(pDllName)
        LocalFree(pDllName);
    if (pResTypeName)
        LocalFree(pResTypeName);
    return dwStatus;
} //FmBuildNewMSMQ


DWORD
FmpBuildMSDTCParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName
   )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize;
    DWORD           dwSize=0;
    DWORD           dwStringSize;

    dwTotalSize=sizeof (LPWSTR);
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    dwNameSize=(lstrlen(L"mtxclu.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }
    CopyMemory(*ppDllName,L"mtxclu.dll",dwNameSize);
    CopyMemory(*ppInParams,ppDllName,sizeof(LPWSTR));

    return dwStatus;
}//FmpBuildMSDTCParams


DWORD
FmBuildMSDTC(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    HDMKEY          hdmKey = NULL;
    LPWSTR          pOldDllName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    hdmKey=DmOpenKey(DmResourceTypesKey,CLUS_RESTYPE_NAME_MSDTC,KEY_EXECUTE);
    if (hdmKey!= NULL)
    {
        //check to see if the resource dll name is valid
        dwStatus = DmQuerySz( hdmKey,
                        CLUSREG_NAME_RESTYPE_DLL_NAME,
                        &pOldDllName,
                        &dwSize,
                        &dwStringSize );
        if ( dwStatus != NO_ERROR ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The DllName value for the %1!ws! resource type could not be read "
                          "from the registry. Resources of this type will not be monitored. "
                          "The error was %2!d!.\n",
                          CLUS_RESTYPE_NAME_MSDTC,
                          dwStatus);
            goto FnExit;
        }

        if (!lstrcmpW(pOldDllName,L"mtxclu.dll"))
        {
            // No need to apply the fixup.
            goto FnExit;
        }

        *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
        if(*pszKeyName==NULL)
        {
            dwStatus =GetLastError();
            goto FnExit;
        }
        lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);

        dwStatus=FmpBuildMSDTCParams(&pInParams,&pDllName);
        if (dwStatus!= ERROR_SUCCESS)
            goto FnExit;
        Required=sizeof(DWORD);
    AllocMem:

        *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
        if(*ppPropertyList==NULL)
        {
            dwStatus=GetLastError();
            goto FnExit;
        }
        *pdwPropertyListSize=Required;
        dwStatus = ClRtlPropertyListFromParameterBlock(
                                             NmJoinFixupMSDTCProperties,
                                             *ppPropertyList,
                                             pdwPropertyListSize,
                                             (LPBYTE)pInParams,
                                             &Returned,
                                             &Required
                                              );

        *pdwPropertyListSize=Returned;
        if (dwStatus==ERROR_MORE_DATA)
        {
            LocalFree(*ppPropertyList);
            *ppPropertyList=NULL;
            goto AllocMem;
        }
        else
            if (dwStatus != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[FM] FmBuildMSDTC: error constructing property list. status %1!u!\n",
                            dwStatus);
                goto FnExit;
            }
    }


FnExit:
    if(pInParams)
        LocalFree(pInParams);
    if(pDllName)
        LocalFree(pDllName);
    if(pOldDllName)
        LocalFree(pOldDllName);
    if (hdmKey)        
        DmCloseKey(hdmKey);
    return dwStatus;
} //FmBuildMSDTC


/****
@func       DWORD | FmBuildClusterProp| Builds the property list for 
            adding Admin Extension value to Cluster root key. The ClsID, if
            not already present,is appended to the existing value.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the NmFixupClusterProperties 

@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/


DWORD
FmBuildClusterProp(
    IN  DWORD    dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD  pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPBYTE          pInParams = NULL;
    DWORD           Required,Returned;
    LPWSTR          pwszValue = NULL;
    HDMKEY          hdmKey;
    DWORD           dwBufferSize = 0;
    DWORD           dwSize       = 0;
    DWORD           dwNewSize    = 0;   
    BOOL            bAlreadyRegistered = FALSE;
    const WCHAR     pwszClsId[] = L"{4EC90FB0-D0BB-11CF-B5EF-00A0C90AB505}"; 
    LPCWSTR	        pwszValueBuf = NULL;
    LPWSTR		    pwszNewValue = NULL;
    LPWSTR          pwszNewValueBuf = NULL;
    DWORD	        cch;


    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;
    dwStatus = DmQueryString( DmClusterParametersKey,   
                               CLUSREG_NAME_ADMIN_EXT,
                               REG_MULTI_SZ,
                               (LPWSTR *) &pwszValue,
                               &dwBufferSize,
                               &dwSize );
    if ((dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_FILE_NOT_FOUND))
	{	
        ClRtlLogPrint(LOG_CRITICAL,
           "[FM] FmBuildClusterProp: error in DmQueryValue. status %1!u!\n",
            dwStatus);
	    goto FnExit;  
    }
    
    // Check if Admin Extension value is already present  

	if(pwszValue != NULL)
	{
    	pwszValueBuf = pwszValue;

    	while (*pwszValueBuf != L'\0')
    	{
    		if (lstrcmpiW(pwszClsId, pwszValueBuf) == 0)
    			break;
    		pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
    	}  // while:  more strings in the extension list
    	bAlreadyRegistered = (*pwszValueBuf != L'\0');

        if(bAlreadyRegistered)
            goto FnExit;  // value already present, don't do anything
    }    
	
	// Allocate a new buffer.
	dwNewSize = dwSize + (lstrlenW(pwszClsId) + 1) * sizeof(WCHAR);
	if (dwSize == 0) // Add size of final NULL if first entry.
		dwNewSize += sizeof(WCHAR);
	pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, dwNewSize);
	if (pwszNewValue == NULL)
	{
		dwStatus = GetLastError();
		goto FnExit;
    }

	pwszValueBuf	= pwszValue;
    pwszNewValueBuf	= pwszNewValue;

    // Copy the existing extensions to the new buffer.
	if (pwszValue != NULL)
	{
		while (*pwszValueBuf != L'\0')
		{
			lstrcpyW(pwszNewValueBuf, pwszValueBuf);
			cch = lstrlenW(pwszValueBuf);
			pwszValueBuf += cch + 1;
			pwszNewValueBuf += cch + 1;
		}  // while:  more strings in the extension list
	}  // if:  previous value buffer existed

	// Add the new CLSID to the list.
	lstrcpyW(pwszNewValueBuf, pwszClsId);
	pwszNewValueBuf += lstrlenW(pwszClsId) + 1;
	*pwszNewValueBuf = L'\0';
	
    dwSize = sizeof(DWORD) + sizeof(LPWSTR);
    pInParams = (LPBYTE)LocalAlloc(LMEM_FIXED,dwSize);
    if (pInParams == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(pInParams,&pwszNewValue,sizeof(LPWSTR)); 
    CopyMemory(pInParams+sizeof(LPWSTR),&dwNewSize,sizeof(DWORD)); 
    
    Required = sizeof(DWORD);
AllocMem:  

    *ppPropertyList = (LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize = Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmFixupClusterProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize = Returned;
    if (dwStatus == ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildClusterProp - error in ClRtlPropertyListFromParameterBlock. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            

    //specify the key name for this fixup
    *pszKeyName = (LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_CLUSTER)+1)*sizeof(WCHAR));
    if(*pszKeyName == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_CLUSTER);
FnExit:
    // Cleanup
    if (pwszValue)
        LocalFree(pwszValue);
    if(pwszNewValue)
        LocalFree(pwszNewValue);
    if(pInParams)
        LocalFree(pInParams);
    return dwStatus;
}


//call back to update in-memory structures after registry fixup for WINS and DHCP
/**
   The call-back function will update the in-memory ResoucreType list,
   but it will not fix the PossibleOwners list in registry and in memory. 
   This is okay for the joining node as it will invoke FmpFixupResourceTypes
   later on in FmJoinPhase2. The other nodes of the cluster will not be
   able to add themselves to the possible nodes in registry or in in-memory struct.
   This is right for present(NT4-NT5) scenario,but might have to be changed later.

**/

DWORD FmFixupNotifyCb(VOID)
{
	return FmpInitResourceTypes();
}

//RJain - When an NT5 node joins an NT4SPx node, in order to enable 
//the cluadmin on NT5 side to view the security tab for NT4 node
//we need to add the NT5 ClsId to the AdminExtension value under 
//Cluster key on both NT4 and NT5 nodes. This can't done in 
//NmPerformFixups as the GumUpdate handler for this update is not
//present on SP4 and SP5. So we do it before NmPerformFixups is called by 
//by using DmAppendToMultiSz.

DWORD
FmFixupAdminExt(VOID)
{
    DWORD           dwClusterHighestVersion;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           Required,Returned;
    LPWSTR          pwszValue = NULL;
    DWORD           dwBufferSize = 0;
    DWORD           dwSize       = 0;
    DWORD           dwNewSize    = 0;   
    const WCHAR     pwszClsId[] = L"{4EC90FB0-D0BB-11CF-B5EF-00A0C90AB505}"; 
    

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    // Apply this fixup only if there is an NT4 node in the cluster 
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT5_MAJOR_VERSION )
    {   
        dwStatus = DmQueryString( DmClusterParametersKey,   
                                   CLUSREG_NAME_ADMIN_EXT,
                                   REG_MULTI_SZ,
                                   (LPWSTR *) &pwszValue,
                                   &dwBufferSize,
                                   &dwSize );
        if ((dwStatus != ERROR_SUCCESS)
    		&& (dwStatus != ERROR_FILE_NOT_FOUND))
    	{	
            ClRtlLogPrint(LOG_CRITICAL,
               "[FM] FmFixupAdminExt: error in DmQueryString. status %1!u!\n",
                dwStatus);
    	    goto FnExit;  
        }

        //check if ClsId is already present
        if (ClRtlMultiSzScan(pwszValue,pwszClsId) != NULL)
            goto FnExit;    

        //if not, append ClsId to the existing value
        dwNewSize = dwSize/sizeof(WCHAR);
        dwStatus = ClRtlMultiSzAppend((LPWSTR *)&pwszValue,
                                    &dwNewSize,
                                    pwszClsId
                                    );

        if(dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
               "[FM] FmFixupAdminExt:ClRtlMultiSzAppend returned status %1!u!\n",
                dwStatus);
    	    goto FnExit;  
    	}

        dwStatus = DmSetValue(DmClusterParametersKey,   
                        CLUSREG_NAME_ADMIN_EXT,
                        REG_MULTI_SZ,
                        (CONST BYTE *)pwszValue,
                        dwNewSize*sizeof(WCHAR)
                        );

        if (dwStatus != ERROR_SUCCESS)
    	{	
            ClRtlLogPrint(LOG_CRITICAL,
               "[FM] FmFixupAdminExt:Error in DmSetValue. status %1!u!\n",
                dwStatus);
    	    goto FnExit;  
        }
            	    	
    } //if(CLUSTER_GET_MAJOR_VERSION)
FnExit:
    // Cleanup
    if (pwszValue)
        LocalFree(pwszValue);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\config.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Reads cluster configuration from file

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

extern void debug_init();

void
msg_set_mode(int mode);

void
msg_set_uport(int uport);

void
msg_set_mport(int mport);

void
msg_set_subnet(char *addr);

void
msg_set_mipaddr(char *addr);

void
msg_set_bufcount(int count);

void
msg_set_bufsize(int count);


#define stricmp(a,b)	strcmp(a,b)

static char qfile[256];
static char vname[256];
static char crsname[256];
static int crssz = 128*1024;

char *
WINAPI
config_get_volume()
{
    return vname;
}

char *
WINAPI
config_get_crsfile()
{
    return crsname;
}

int
WINAPI
config_get_crssz()
{
    return crssz;
}

char *
WINAPI
config_get_qfile()
{
  return qfile;
}

static void
parse_node(char *buf)
{
    char *s, *p, *q;
    int WINAPI msg_addnode(int id, char *n, char *a);
    int id;

    p = strchr(buf, ':');
    if (p == NULL)
      return;

    *p = '\0'; p++;

    id = atoi(buf);

    s = p;
    p = strchr(s, ':');
    if (p == NULL)
      return;

    p++;
    q = strchr(p, '\n');
    if (q) {
      *q = '\0'; q += 2;
    }
    msg_addnode(id, s, p);
}

static void
parse_vol(char *buf)
{
    char *s, *p, *q;

    s = (char *)buf;
#if 0
    p = strchr(s, ':');
    if (p == NULL)
      return;

    *p = '\0'; p++;
#else
    p = s;
#endif
    q = strchr(p, '\n');
    if (q) {
      *q = '\0'; q += 2;
    }
    // add volume
    strcpy(vname, s);
}
    
static void
parse(char *buf, ULONG len)
{
    char *s, *p, *q;
    void WINAPI debug_log_file(char*);
    void WINAPI debug_level(ULONG);


    s = (char *)buf;
    s[len] = '\0';

    p = strchr(s, ':');
    if (p == NULL)
      return;

    *p = '\0'; p++;
    q = strchr(p, '\n');
    if (q) {
      *q = '\0'; q += 2;
    }

    if (!stricmp(s, "quorm")) {
      strcpy(qfile, p);
    } else if (!stricmp(s, "log_file")) {
      debug_log_file(p);
    } else if (!stricmp(s, "log_level")) {
      ULONG x = (ULONG) atoi(p);
      debug_level(x);
    } else if (!stricmp(s, "crs_file")) {
      strcpy(crsname, p);
    } else if (!stricmp(s, "crs_size")) {
      crssz = atoi(p);
      if (crssz == 0) {
	  crssz = 128;
      }
    } else if (!stricmp(s, "mcast")) {
      msg_set_mode(atoi(p));
    } else if (!stricmp(s, "mcast_ipaddr")) {
      msg_set_mipaddr(p);
    } else if (!stricmp(s, "mcast_port")) {
      int x = atoi(p);
      msg_set_mport(x);
    } else if (!stricmp(s, "subnet")) {
      msg_set_subnet(p);
    } else if (!stricmp(s, "ucast_port")) {
      int x = atoi(p);
      msg_set_uport(x);
    } else if (!stricmp(s, "buffers")) {
      int x = atoi(p);
      msg_set_bufcount(x);
    } else if (!stricmp(s, "bufsize")) {
      int x = atoi(p);
      msg_set_bufsize(x);
    } else if (!stricmp(s, "node")) {
      parse_node(p);
    } else if (!stricmp(s, "volume")) {
      parse_vol(p);
    } else {
      fprintf(stderr,"Unknown tag '%s'\n", s);
    }
}

void
ConfigInit()
{
  char buf[256];
  FILE *fp;
  char *s = getenv("RfsFile");

  if (s == NULL)
    s = "rfs.conf";

  debug_init();

  // Open cluster
  fp = fopen(s, "r");
  if (fp == NULL) {
    fprintf(stderr,"Unable to open configuration file '%s'\n", s);
    exit(0);
  }

  // init stuff
  strcpy(crsname, "c:\\crs.log");

  while (fgets(buf, sizeof(buf), fp)) {
    if (strlen(buf) > 2) {
      parse(buf, strlen(buf));
    }
  }

  fclose(fp);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\cm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cm.c

Abstract:

    Connection Manager

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include "msg.h"

extern BOOLEAN QuormAcquire();
extern void QuormInit();
extern void QuormRelease();

#include <stdio.h>

#define	GS_MAX_NODEID	16
#define	GS_REGROUP_PHASES	3

#define	CmStateJoin	0
#define	CmStateNormal	1
#define	CmStateUp	2
#define	CmStateDown	3

gs_nid_t	GsLocalNodeId;

gs_nid_t	QuormOwnerId;

int		GsMaxNodeId = GS_MAX_NODEID;
int		GsMinNodeId = 1;

long	Regroup;	// number of down nodes

ULONG 	Node_Mask;		// current active node mask
ULONG	JoinNode_Mask;	// current joining node mask
ULONG	Sync_Valid;		// which barrier points are valid

ULONG	Sync_Mask[GS_REGROUP_PHASES];
// Cluster connectivity matrix
ULONG	ClusterNode_Mask[GS_MAX_NODEID+1];

gs_lock_t	MmLock;
gs_event_t	Start_Event, Regroup_Event;

extern void NsSetOwner(gs_nid_t);

void
cm_node_up()
{
    ULONG mask;

    if (Node_Mask == JoinNode_Mask) {
	return;
    }

    // get the difference
    mask = Node_Mask ^ JoinNode_Mask;

    Node_Mask = JoinNode_Mask;

    cm_log(("Node UPUPUP mask %x: upset %x\n", Node_Mask, mask));
	
    // inform new node of resources that it we own
	
    // If we have a registered node up event, call it now
}

void
cm_node_down()
{
    ULONG mask;

    if (Node_Mask == JoinNode_Mask) {
	return;
    }

    // get the difference
    mask = Node_Mask ^ JoinNode_Mask;

    Node_Mask = JoinNode_Mask;

    cm_log(("Node DNDNDN mask %x: dnset %x\n", Node_Mask, mask));

    NsSetOwner(QuormOwnerId);

    GspPhase2NodeDown(mask);
}

static int
cm_full_connectivity()
{
    int i, j;

    for (i = 1; i < GS_MAX_NODEID; i++) {

	// if node is not up, ignore it
	if ((JoinNode_Mask & (1 << i)) == 0)
	    continue;

	// check node's i mask with others
	for (j = i+1; j <= GS_MAX_NODEID; j++) {

	    // if node is not up, ignore it
	    if ((JoinNode_Mask & (1 << j)) == 0)
		continue;

	    if (ClusterNode_Mask[i] ^ ClusterNode_Mask[j]) {
		cm_log(("FC: node %d mask 0x%x node %d mask 0x%x\n",
		       i,
		       ClusterNode_Mask[i],
		       j,
		       ClusterNode_Mask[j]));
		return 0;
	    }
	}
    }
    return 1;
}

void
GspMmMsgHandler(gs_msg_t *msg)
{
    int nodeid = msg->m_hdr.h_sid;
    ULONG old;

    // Update node's up mask
    GsLockEnter(MmLock);

    old = ClusterNode_Mask[GsLocalNodeId];

    ClusterNode_Mask[nodeid] |= msg->m_hdr.h_bnum;
    ClusterNode_Mask[GsLocalNodeId] |= (1 << nodeid);
	
    if (msg->m_hdr.h_flags != 0) {
	QuormOwnerId = msg->m_hdr.h_flags;
	cm_log(("Learn new quorm owner %d\n", QuormOwnerId));
    }

    cm_log(("MM qowner %d mask %x node %d, j %x n %x\n",QuormOwnerId,
	   msg->m_hdr.h_bnum, nodeid,
	   JoinNode_Mask, Node_Mask));

    if (old != ClusterNode_Mask[GsLocalNodeId]) {

	msg->m_hdr.h_type = GS_MSG_TYPE_MM;
	msg->m_hdr.h_len = 0;
	msg->m_hdr.h_flags = QuormOwnerId;
	msg->m_hdr.h_sid = GsLocalNodeId;
	msg->m_hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];

	msg_smcast(JoinNode_Mask, &msg->m_hdr, NULL, 0);
    }

    // If the matrix is full connected, we are done
    if (cm_full_connectivity() != 0) {
	switch(Regroup) {
	case CmStateJoin:
	    cm_node_up();
	    GsEventSignal(Start_Event);
	    break;
	case CmStateUp:
	    cm_node_up();
	    break;
	case CmStateDown:
	    cm_node_down();
	    break;
	default:
	    err_log(("Invalid cm state %d\n", Regroup));
	    exit(1);
	}
	Regroup = CmStateUp;
#if 0
	cm_node_up();
	if (Regroup < 0) {
	    GsEventSignal(Start_Event);
	}
#endif
    } 

    GsLockExit(MmLock);

    msg_free(msg);
}

void
GspInfoMsgHandler(gs_msg_t *msg)
{
    int nodeid = msg->m_hdr.h_sid;

    // make sure we send our info to the sender
//    cm_node_join(nodeid);

    // lock membership state
    GsLockEnter(MmLock);

    if (msg->m_hdr.h_flags != 0) {
	QuormOwnerId = msg->m_hdr.h_flags;
	NsSetOwner(QuormOwnerId);
    }

    cm_log(("Info Node %d mask %x quorm %d\n", nodeid, msg->m_hdr.h_bnum,
	   QuormOwnerId));

    // Foward message to all other members
    cm_log(("Info Mcast %x node %d mask %x\n",
	   ClusterNode_Mask[GsLocalNodeId], nodeid, JoinNode_Mask));

    msg->m_hdr.h_type = GS_MSG_TYPE_MM;
    msg->m_hdr.h_len = 0;
    msg->m_hdr.h_sid = GsLocalNodeId;
    msg->m_hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];

    msg_smcast(JoinNode_Mask, &msg->m_hdr, NULL, 0);

    GsLockExit(MmLock);

    msg_free(msg);
}

void
gs_nodeup_handler(int nodeid)
{
    gs_msg_hdr_t hdr;

    cm_log(("Node up %d\n", nodeid));
    GsLockEnter(MmLock);
    if (JoinNode_Mask & (1 << nodeid)) {
	printf("Node is already up %d 0x%x\n", nodeid, JoinNode_Mask);
	GsLockExit(MmLock);
	return;
    }

    JoinNode_Mask |= (1 << nodeid);

    if (1 || Regroup != CmStateJoin) {
    cm_log(("Node %d is alive, j %x n %x, sending info\n", nodeid,
	       JoinNode_Mask, Node_Mask));


    hdr.h_type = GS_MSG_TYPE_INFO;
    hdr.h_sid = GsLocalNodeId;
    hdr.h_flags = QuormOwnerId;
    hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];
    hdr.h_len = 0;

    msg_send((gs_memberid_t) nodeid, &hdr, NULL, 0);
    }
    GsLockExit(MmLock);
}

void
gs_nodedown_handler(int nodeid)
{
    int i;
    gs_msg_hdr_t hdr;

    GsLockEnter(MmLock);

    if (!(JoinNode_Mask & (1 << nodeid))) {
	err_log(("Node %d is already down\n", nodeid));
	GsLockExit(MmLock);
	return;
    }

    if (Regroup == CmStateJoin) {
	err_log(("Node down during join, aborting...\n"));
	GsLockExit(MmLock);
	exit(1);
    }

    Regroup = CmStateDown;

    // Assume all nodes see this event and no messaging is required
    for (i = 0; i <= GS_MAX_NODEID; i++) {
	ClusterNode_Mask[i] = (1 << GsLocalNodeId);
    }

    JoinNode_Mask &= ~(1 << nodeid);

    if (!(JoinNode_Mask & (1 << QuormOwnerId))) {
	cm_log(("Lost quorm owner %d\n", QuormOwnerId));
	QuormOwnerId = 0;
    }

    // Acquire Quorum file
    if (QuormOwnerId != GsLocalNodeId && QuormAcquire() == TRUE) {
	cm_log(("I own quorm now\n"));
	QuormOwnerId = GsLocalNodeId;
    }
    cm_log(("Node %d down upset %x -> %x mask %x\n", nodeid,
	   Node_Mask, JoinNode_Mask, Node_Mask ^ JoinNode_Mask));

    // Generate phase 1 node down
    GspPhase1NodeDown(Node_Mask ^ JoinNode_Mask);

    // handle case when I am only node in cluster, otherwise enter regroup again
    if (JoinNode_Mask == (ULONG)(1 << GsLocalNodeId)) { //cm_full_connectivity() != 0) {
	while (QuormOwnerId != GsLocalNodeId) {
	    if (QuormAcquire() == TRUE) {
		QuormOwnerId = GsLocalNodeId;
		break;
	    }
	    Sleep(100);
	}
	cm_node_down();
	Regroup = CmStateUp;
    } else {
	hdr.h_type = GS_MSG_TYPE_MM;
	hdr.h_sid = GsLocalNodeId;
	hdr.h_flags = QuormOwnerId;
	hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];
	hdr.h_len = 0;

	msg_smcast(JoinNode_Mask, &hdr, NULL, 0);
    }

    GsLockExit(MmLock);
}


void
gs_nodejoin_handler(int nodeid)
{
    cm_log(("Node is alive %d\n", nodeid));
}

void
gs_nodeid_handler(int nodeid)
{
    GsLocalNodeId = (gs_nid_t) nodeid;
//    cm_log(("Node id %d\n", nodeid));
}
	
gs_node_handler_t gs_node_handler[] = {
    gs_nodeid_handler,
    gs_nodejoin_handler,
    gs_nodeup_handler,
    gs_nodedown_handler
};

void
cm_init()
{
    GsLocalNodeId = 0;
    QuormOwnerId = 0;
    Regroup = CmStateJoin;
    Node_Mask = 0;
    JoinNode_Mask = 0;
    Sync_Valid = 0;
    memset(Sync_Mask, 0, sizeof(Sync_Mask));
    memset(ClusterNode_Mask, 0, sizeof(ClusterNode_Mask));
 
    GsLockInit(MmLock);
    GsEventInit(Start_Event);
    GsEventInit(Regroup_Event);

    QuormInit();
    msg_init();
}

cm_start()
{
	int i;
	static int started = 0;

	i = InterlockedIncrement(&started);
	if (i != 1)
	    return 0;

	for (i = 0; i <= GS_MAX_NODEID; i++) {
	    ClusterNode_Mask[i] = (1 << GsLocalNodeId);
	}
	Node_Mask = 1 << GsLocalNodeId;
	JoinNode_Mask = 1 << GsLocalNodeId;

	// wait for join, 
	do {
	    LARGE_INTEGER delta;

	    GsLockEnter(MmLock);

	    if (QuormAcquire() == TRUE) {
		QuormOwnerId = GsLocalNodeId;
		NsSetOwner(QuormOwnerId);
		Regroup = CmStateUp;
		GsLockExit(MmLock);
		break;
	    }

	    GsLockExit(MmLock);

	    msg_start(JoinNode_Mask);
	    cm_log(("Waiting to join %x %x\n", JoinNode_Mask, Node_Mask));

	    delta.QuadPart = 0;
	    delta.LowPart = 5 * 1000; // retry every 5 second
	    if (GsEventWaitTimeout(Start_Event, &delta)) { 
		cm_log(("j %x n %x\n", JoinNode_Mask, Node_Mask));
	    }
	} while (JoinNode_Mask == (ULONG)(1 << GsLocalNodeId) || JoinNode_Mask != Node_Mask);

//	InterlockedIncrement(&Regroup);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug routines

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#ifndef _DEBUG_H
#define _DEBUG_H

void 
WINAPI 
debug_log(char*format, ...);

void
WINAPI
debug_init();

void
WINAPI
debug_log_file(char *logfile);

extern ULONG debugLevel;

#define GS_DEBUG_ERR	0x1
#define	GS_DEBUG_CM	0x2
#define	GS_DEBUG_MM	0x4
#define	GS_DEBUG_FAIL	0x8

#define	GS_DEBUG_NS	0x10
#define	GS_DEBUG_MSG	0x20
#define	GS_DEBUG_DATA	0x40
#define	GS_DEBUG_STATE	0x80
#define GS_DEBUG_CRS	0x100

#define	gsprint(_x_)	debug_log _x_


#define	print_log(LEVEL, STRING) { \
            if (debugLevel & LEVEL) { \
                gsprint(STRING); \
            } \
}

#define msg_log(_x_)	print_log(GS_DEBUG_MSG, _x_)
#define err_log(_x_)	print_log(GS_DEBUG_ERR, _x_)
#define cm_log(_x_)	print_log(GS_DEBUG_CM, _x_)
#define recovery_log(_x_)	print_log(GS_DEBUG_FAIL, _x_)
#define ns_log(_x_)	print_log(GS_DEBUG_NS, _x_)
#define gs_log(_x_)	print_log(GS_DEBUG_DATA, _x_)
#define state_log(_x_)	print_log(GS_DEBUG_STATE, _x_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\gs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gs.h

Abstract:

    Public gs definitions

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/


#ifndef	_GS_H
#define	_GS_H

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <assert.h>

#define	GS_MAX_GROUPS		64
#define	GS_MAX_GROUP_SZ		8
#define	GS_MAX_NAME_SZ		28

typedef enum {
    GsEventData,
    GsEventSingleData,
    GsEventMemberJoin,
    GsEventMemberUp,
    GsEventMemberDown,
    GsEventMemberEvicted,
    GsEventAbort,
    GsEventInvalid
}gs_eventid_t;

typedef struct {
    int	lid;
    int mid;
    int	group_size;
    int cluster_size;
    UINT32 mset;
}gs_info_t;

typedef  char    gs_tag_t[64];

typedef NTSTATUS (WINAPI *gs_callback_t)(HANDLE cookie, gs_tag_t tag, PVOID buf, 
				  IO_STATUS_BLOCK *ios);

char *
WINAPI
config_get_volume();

char *
WINAPI
config_get_crsfile();

int
WINAPI
config_get_crssz();

void
WINAPI
GsInit();

void
WINAPI
GsExit();

NTSTATUS
WINAPI
GsSendDeliveredRequest(HANDLE group, HANDLE event OPTIONAL,
		       gs_tag_t tag, PVOID buf, UINT32 len,
		       PVOID rbuf[], UINT32 elmsz,
		       IO_STATUS_BLOCK iostatus[],
		       HANDLE *context);

NTSTATUS
WINAPI
GsSendContinuedRequest(HANDLE context, HANDLE event OPTIONAL,
		       gs_tag_t tag, PVOID bruf, UINT32 len,
		       PVOID rbuf[], UINT32 elmsz,
		       IO_STATUS_BLOCK iostatus[],
		       BOOLEAN close);

NTSTATUS
WINAPI
GsSendQueuedRequest(HANDLE group, HANDLE event OPTIONAL,
		    gs_tag_t tag, PVOID buf, UINT32 len,
		    PVOID rbuf[], UINT32 elmsz,
		    IO_STATUS_BLOCK iostatus[]);

NTSTATUS		    
WINAPI
GsSendDirectedRequest(HANDLE group, HANDLE event OPTIONAL,
		      int memberid,
		      gs_tag_t tag, PVOID buf, UINT32 len,
		      PVOID rbuf, UINT32 elmsz,
		      IO_STATUS_BLOCK *iostatus,
		      HANDLE *context);

NTSTATUS
WINAPI
GsSendReply(HANDLE gd, PVOID buf, int len, NTSTATUS status);

NTSTATUS
WINAPI
GsReceiveRequest(HANDLE gd, PVOID buf, int len);

void
WINAPI
GsRegisterHandler(HANDLE gd, gs_callback_t func);

HANDLE
WINAPI
GsCreateGroup(gs_callback_t func, char *name, int len, int windowsz,
     int disposition, HANDLE *ctx);

NTSTATUS
WINAPI
GsEvictMember(HANDLE gd, int memberid);

NTSTATUS
WINAPI
GsQueryGroup(HANDLE gd, gs_info_t *info);

NTSTATUS
WINAPI
GsCloseGroup(HANDLE gd);


HANDLE
WINAPI
GsGetGroupHandle(HANDLE msgd);

int
WINAPI
GsGetSourceMemberid(HANDLE msgd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Log messages

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "type.h"

gs_lock_t prlock;

ULONG debugLevel = 0xff;

FILE *debugfp = NULL;


void
halt(int status)
{
    char *p = NULL;

    *p = 1;
}

void
WINAPI
debug_log_file(char *logfile)
{
  FILE *fp;

    if (logfile != NULL) {
      fp = fopen(logfile, "w");
      if (fp == NULL) {
	printf("Unable to open log file %s\n", logfile);
      } else {
	debugfp = fp;
      }
    }
}

void
WINAPI
debug_level(ULONG level)
{
    debugLevel = level;
}

void
WINAPI
debug_log(char *format, ...)
{
    static int cnt = 0;
    va_list marker;

    va_start(marker, format);

    GsLockEnter(prlock);


    if (debugfp != NULL) {
	fprintf(debugfp, "%d:%x:",GetTickCount(), GetCurrentThreadId());
	vfprintf(debugfp, format, marker);
	fflush(debugfp);
    } else {
	fprintf(stderr, "%d:%x:",GetTickCount(), GetCurrentThreadId());
	vfprintf(stderr, format, marker);
	fflush(stderr);
    }
#if 0
    cnt++;
    if (cnt > 100000) {
	cnt = 0;
	fseek(debugfp, 0, SEEK_SET);
    }
#endif
    GsLockExit(prlock);

    va_end(marker);
}

void
WINAPI
debug_init()
{
    char	*s = getenv("GsDebugLevel");

    debugfp = stdout;
    GsLockInit(prlock);
    if (s != NULL) {
	debugLevel = atoi(s);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\gs.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gs.c

Abstract:

    Creation and deletion of groups

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include <stdio.h>

extern void ConfigInit();

extern gs_nid_t	GsLocalNodeId;
extern int	GsMaxNodeId;
extern int	GsMinNodeId;

void cm_init();
void cm_start();

gs_group_t	GsGroupTable[GsGroupTableSize];

HANDLE ns_gd;

HANDLE
WINAPI
GsGetGroupHandle(HANDLE msgd)
{
    gs_msg_t *msg = (gs_msg_t *)msgd;

    return (HANDLE) &GsGroupTable[msg->m_hdr.h_gid];
}

int
WINAPI
GsGetSourceMemberid(HANDLE msgd)
{
    gs_msg_t *msg = (gs_msg_t *)msgd;

    return (int) msg->m_hdr.h_sid;
}

void
GspInitGroup(gs_group_t *gd, int wsz);


// Internal routines

gs_group_t *
GspLookupGroup(gs_gid_t gid)
{
    gs_group_t	*gd;

    if (gid >= GsGroupTableSize) {
	return NULL;
    }
    gd = &GsGroupTable[gid];
    assert(gd->g_id == gid);
    if (gd->g_state == GS_GROUP_STATE_FREE ||
	gd->g_state == GS_GROUP_STATE_NEW) {
	return NULL;
    }

    assert(gd->g_state != GS_GROUP_STATE_FREE);
    return gd;
}

gs_group_t *
GspLookupGroupByName(char *name, int len)
{
    gs_group_t	*gd;
    int i;

    for (i = 0; i < GsGroupTableSize; i++) {
	gd = &GsGroupTable[i];
	if (gd->g_state != GS_GROUP_STATE_FREE && 
	    len == gd->g_namelen && !strcmp(gd->g_name, name)) {
	    return gd;
	}
    }

    return NULL;
}

gs_group_t *
GspAllocateGroup(char *name, int len)
{
    int i;

    for (i = 0; i < GsGroupTableSize; i++) {
	gs_group_t	*gd;

	gd = &GsGroupTable[i];
	if (gd->g_state == GS_GROUP_STATE_FREE) {
	    // set everything to zero
	    memset(gd, 0, sizeof(*gd));

	    gd->g_id = i;
	    gd->g_nid = GsLocalNodeId;

	    GsLockInit(gd->g_lock);

	    gd->g_name = name;
	    gd->g_namelen = len;
	    gd->g_state = GS_GROUP_STATE_NEW;

	    return gd;
	}
    }

    return NULL;
}

void
GspDeleteGroup(gs_group_t *gd)
{

    // xxx: grab lock in write mode
    assert(gd->g_state != GS_GROUP_STATE_FREE);

    if (gd->g_name) {
	free(gd->g_name);
    }
    gd->g_name = NULL;
    gd->g_namelen = 0;

    gd->g_mset = 0;
    gd->g_state = GS_GROUP_STATE_FREE;

    if (gd->g_mlist) {
	free((char *) gd->g_mlist);
    }
    if (gd->g_send.s_ctxpool) {
	free((char *) gd->g_send.s_ctxpool);
    }
    // xxx: drop lock
}

void
GspAddMember(gs_group_t *gd, gs_memberid_t mid, int wsz)
{
    gs_member_t *p;

    ns_log(("Add member gid %d sz %d mid %d\n",
	      gd->g_id, gd->g_sz, mid));

    p = (gs_member_t *) malloc(sizeof(gs_member_t) * (gd->g_sz+1));
    if (p == NULL) {
	err_log(("Unable to extend member table\n"));
	exit(1);
    }

    if (gd->g_mlist) {
	memcpy(p, gd->g_mlist, sizeof(gs_member_t) * (gd->g_sz));
	free((char *)gd->g_mlist);
    }
    gd->g_mlist = p;
    gd->g_mset |= (1 << mid);
    p += gd->g_sz;
    gd->g_sz++;
    gd->g_curview++;

    // init member state
    p->m_id = gd->g_sz;
    p->m_expected_seq = 0;
    p->m_wsz = (UINT16) wsz;
    p->m_msz = (UINT16) GS_DEFAULT_MAX_MSG_SZ;

}

void
GspSetMaster(gs_group_t *gd, gs_memberid_t mid)
{
    gd->g_mid = mid;
}

void
GspInitGroup(gs_group_t *gd, int wsz)
{
    int i;

    // init send state

    GsSemaInit(gd->g_send.s_sema, wsz);
    gd->g_send.s_wsz = (UINT16) wsz;

    // allocate window size contexts
    gd->g_send.s_ctxpool = (gs_context_t *) malloc(sizeof(gs_context_t) * wsz);
    if (gd->g_send.s_ctxpool == NULL) {
	assert(0);
    }

    for (i = 0; i < wsz; i++) {
	gs_context_t *p = &gd->g_send.s_ctxpool[i];

	p->ctx_id = GS_CONTEXT_INVALID_ID;
	p->ctx_gid = gd->g_id;
	p->ctx_buf = 0;
	p->ctx_rbuf = 0;
	p->ctx_msg = 0;
	p->ctx_event = 0;
	GsEventInit(p->ctx_syncevent);
    }
    
    // init receive state
    gd->g_recv.r_next = &gd->g_recv.r_head;
}


void
WINAPI
GsInit()
{
    int i;
    void NsForm();
    void NsJoin();

    timeBeginPeriod(50);

    ConfigInit();

    // Initialize global data structure
    for (i = 0; i < GsGroupTableSize; i++) {
	gs_group_t *gd;

	gd = &GsGroupTable[i];
	gd->g_state = GS_GROUP_STATE_FREE;
	gd->g_mset = 0;
    }

    // init and start connection manager
    cm_init();

    NsForm();

    cm_start();

    NsJoin();
}

void
WINAPI
GsExit()
{
    int i;

    // stop messaging
    msg_exit();

    // free context pool and membership list for each group in group table
    for (i = 0; i < GsGroupTableSize; i++) {
	gs_group_t	*gd;

	gd = &GsGroupTable[i];
	GspDeleteGroup(gd);
    }

    timeEndPeriod(50);
}

#define NS_TABLE_READ	0
#define	NS_TABLE_ADD	1

HANDLE
WINAPI
GsCreateGroup(gs_callback_t func, char *name, int len, int wsz,
    int disposition, HANDLE *join_ctx)

{
    gs_group_t	*gd;
    PVOID	io[GS_MAX_GROUP_SZ];
    int		result[GS_MAX_GROUP_SZ];
    int		i;
    NTSTATUS	err;
    IO_STATUS_BLOCK status[GS_MAX_GROUP_SZ];
    gs_ns_info_t info;
    int GspJoin(HANDLE group, gs_event_t event, PVOID io[], IO_STATUS_BLOCK status[],
		 int wsz, HANDLE *context);
    gs_event_t event;
    union {
	int	cmd;
	gs_tag_t	tag;
    }tag;

    if (name == NULL || len > GS_MAX_NAME_SZ) {
	return NULL;
    }

    ns_log(("Create group %s\n", name));

    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	status[i].Information = 0;	
	io[i] = (PVOID)&result[i];
	result[i] = TRUE;
    }

    // Based on disposition we either form or join
    info.owner = (USHORT) ((gs_group_t *)ns_gd)->g_nid;
    info.wsz = (UINT16) wsz;
    strcpy(info.name, name);
    GsEventInit(event);

 retry:
    tag.cmd = NS_TABLE_ADD;
    err = GsSendDeliveredRequest(ns_gd, event,
				 tag.tag, (PVOID) &info, sizeof(info),
				 io, sizeof(result[0]), 
				 status,
				 NULL);

    if (err != ERROR_SUCCESS) {
	GsEventFree(event);
	err_log(("Create group failed %d\n", err));
	return NULL;
    }
    // xxx: make sure result is true
    gd = GspLookupGroupByName(name, len);
    if (gd != NULL) {
	int err;

	ns_log(("Init group %x\n", gd));
	GspInitGroup(gd, wsz);
	GsRegisterHandler((HANDLE)gd, func);
	err = GspJoin((HANDLE) gd, event, io, status, wsz, join_ctx);
	if (err) {
	    ns_log(("Init group gspjoin failed, need to retry\n"));
	    goto retry;
	}
    }
    ns_log(("Created group %x\n", gd));
    GsEventFree(event);
    return (HANDLE) gd;
}

NTSTATUS
GsCloseGroup(HANDLE group)
{
    gs_group_t	*gd = (gs_group_t *)group;

    GspDeleteGroup(gd);
    return ERROR_SUCCESS;
}

void
GsRegisterHandler(HANDLE group, gs_callback_t func)
{
    gs_group_t *gd = (gs_group_t *) group;

    gd->g_callback = func;
}

NTSTATUS
GsQueryGroup(HANDLE group, gs_info_t *info)
{
    gs_group_t *gd;
    
    if (group == NULL) {
	group = ns_gd;
    }

    gd = (gs_group_t *) group;
    if (!gd || !info) {
	return ERROR_INVALID_PARAMETER;
    }
    
    info->lid = gd->g_nid;
    info->mid = gd->g_mid;
    info->group_size = gd->g_sz;
    info->cluster_size = msg_getsize();
    info->mset = gd->g_mset;

    return ERROR_SUCCESS;
}


// Name server

NTSTATUS
ns_callback(HANDLE group, gs_tag_t mtag, PVOID buf, IO_STATUS_BLOCK *ios)
{

    gs_ns_info_t table[GS_MAX_GROUPS];
    int i, j, result;
    gs_group_t *gd = (gs_group_t *) group;
    NTSTATUS err;
    gs_ns_info_t *info;
    int tag = *((int *)mtag);

    switch(ios->Status) {
    case GsEventData:
	ns_log(("NsCallback Disposition %d\n", tag));
	switch(tag) {
	case NS_TABLE_READ:

	    // only group table master reponse to reads
	    if (GsGroupTable[0].g_mid == GsGroupTable[0].g_nid) {
		j = 0;
		for (i = 1; i < GsGroupTableSize; i++) {
		    gd = &GsGroupTable[i];
		    if (gd->g_state != GS_GROUP_STATE_FREE) {
			table[j].owner = gd->g_mid;
			table[j].id = (USHORT) i;
			strcpy(table[j].name, gd->g_name);
			j++;
		    }
		}

		ns_log(("Sending table size %d\n", j));
		err = GsSendReply(group, (PVOID) table, sizeof(table[0]) * j, STATUS_SUCCESS);
		if (err != ERROR_SUCCESS) {
		    printf("Failed to respond to table read ns\n");
		}
	    }

	    break;

	case NS_TABLE_ADD:

	    info = (gs_ns_info_t *)buf;
	    assert(ios->Information == sizeof(*info));
	    // xxx: lock table
	    gd = GspLookupGroupByName(info->name, strlen(info->name));
	    if (gd == NULL) {
		char * strsave(char *s);

		gd = GspAllocateGroup(strsave(info->name), strlen(info->name)); 

		if (gd != NULL) {
		    GspSetMaster(gd, info->owner);
		}
		ns_log(("Ns Created group %s id %d owner %d\n",
			  info->name, gd->g_id, gd->g_mid));
	    }
	    // xxx: unlock table
	    if (gd != NULL) {
		result = TRUE;
	    } else {
		result = FALSE;
	    }
	    err = GsSendReply(group, (PVOID) &result, sizeof(result), STATUS_SUCCESS);
	    if (err != ERROR_SUCCESS) {
		err_log(("Failed to respond to add ns\n"));
	    }
	    break;

	default:
	    err_log(("Invalid ns opcode, %d\n", tag));
	    exit(1);
	}
	break;

    case GsEventMemberJoin:
	ns_log(("NsCallback member join %d\n", tag));
	break;
    case GsEventMemberUp:
	ns_log(("NsCallback member up %d\n",  tag));
	break;
    case GsEventMemberDown:
	ns_log(("NsCallback member down %d\n",  tag));
	break;
    default:
	ns_log(("Ns invalid event %d\n",  ios->Status));
    }

    return ERROR_SUCCESS;
}



void
NsForm()
{
    char *name = "Name server";

    ns_gd = (HANDLE) GspAllocateGroup(name, strlen(name));
    if (ns_gd == NULL) {
	err_log(("Unable to create name server group!\n"));
	exit(1);
    }
    GspInitGroup((gs_group_t *)ns_gd, 1);
    GsRegisterHandler(ns_gd, ns_callback);
}

void
NsSetOwner(gs_nid_t nid)
{
    gs_group_t *gd = (gs_group_t *) ns_gd;

    ns_log(("Name server: master %d\n", nid));

    GsLockEnter(gd->g_lock);

    GspSetMaster(gd, (gs_memberid_t)nid);
    if (gd->g_rs != NULL && gd->g_mid != gd->g_nid) {
	gd->g_rs->rs_mset = (1 << gd->g_nid) | (1 << gd->g_mid);
    }

    GsLockExit(gd->g_lock);
}

int
GspJoin(HANDLE group, gs_event_t event, PVOID io[], IO_STATUS_BLOCK status[],
	int wsz, HANDLE *context)
{

    // if we don't master the name server, we simply send a
    // join request to this group and receive a table of
    // group names and owners
    gs_join_info_t	info;
    int table[GS_MAX_GROUP_SZ];
    gs_group_t *gd = (gs_group_t *) group;
    gs_context_t	*ctx;
    gs_memberid_t	mid;
    union {
	int	mid;
	gs_tag_t	tag;
    }tag;

    if (context) *context = NULL;

    while (TRUE) {
	int err, i;
	UINT32 sz, flags;
	gs_msg_hdr_t hdr;

	GsLockEnter(gd->g_lock);
	ns_log(("join group %s mid %d\n", gd->g_name, gd->g_mid));
	if ((mid = gd->g_mid) == gd->g_nid) {
	    gs_msg_t msg;

	    memset(&msg, 0, sizeof(msg));
	    msg.m_hdr.h_type = GS_MSG_TYPE_UP;
	    msg.m_buf = (char *) &wsz;
	    *((gs_memberid_t *)msg.m_hdr.h_tag) = mid;
	    msg.m_hdr.h_len = sizeof(wsz);
	    msg.m_hdr.h_flags = GS_FLAGS_REPLY;
	    msg.m_hdr.h_gid = gd->g_id;
	    GspDeliverMsg(gd, &msg);
	    gd->g_state = GS_GROUP_STATE_FORM;
	    GsLockExit(gd->g_lock);
	    break;
	}

	gd->g_state = GS_GROUP_STATE_JOIN;

	GsLockExit(gd->g_lock);

	GspOpenContext(gd, &ctx);

	io[0] = (PVOID) &info;
	status[0].Information = 0;
	tag.mid = gd->g_nid,
	err = GspSendDirectedRequest(gd, ctx, event, mid,
				     tag.tag, NULL, 0, 
				     &io[0], sizeof(info),
				     &status[0],
				     GS_FLAGS_DELIVERED, 
				     GS_MSG_TYPE_JOIN_REQUEST);


	GsLockEnter(gd->g_lock);
	if (gd->g_mid != mid) {
	    GsLockExit(gd->g_lock);
	    GspCloseContext(gd, ctx);
	    continue;
	}

	if (err != ERROR_SUCCESS) {
	    err_log(("Join failed %d\n", err));
	    return 1;
	}
	
	if (status[0].Information != sizeof(info)) {
	    err_log(("GspJoin: invalid returned size %d\n",
		     status[0].Information));
	    halt(1);
	}

	ns_log(("GspJoin: group %s mastered by %d curset %x\n",
		  gd->g_name, mid, info.mset));

	ns_log(("GspJoin: Mseq %d Curview %d Gsz %d mset %x\n",
	       info.mseq, info.viewnum, info.sz, info.mset));

	// init some state
	gd->g_curview = info.viewnum;
	gd->g_startview = info.viewnum;
	gd->g_mset = info.mset;
	gd->g_recv.r_mseq = info.mseq;
	gd->g_recv.r_bnum = 1; // set starting point
	gd->g_send.s_lseq = info.mseq;
	gd->g_sz = info.sz;

	GsLockExit(gd->g_lock);
	sz = sizeof(table);
	for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	    status[i].Information = 0;
	    io[i] = (PVOID) &table[i];
	    table[i] = TRUE;
	}
	tag.mid = gd->g_nid;
	err = GspSendRequest(gd, ctx, event, GS_MSG_TYPE_JOIN, mid,
			     tag.tag,
			     (PVOID)&wsz, sizeof(wsz), 
			     io, sizeof(table[0]),
			     status,
			     GS_FLAGS_DELIVERED | GS_FLAGS_CONTINUED | GS_FLAGS_LAST,
			     &info);

	if (err != ERROR_SUCCESS) {
	    err_log(("Join failed %d\n", err));
	    halt(1);
	}
	{
	    int i;

	    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
		if (table[i] != TRUE) {
		    err_log(("GsJoin: Failed was rejected by member %d\n", i));
		    halt(1);
		}
	    }
	}

	if (context == NULL) {
	    flags = GS_FLAGS_DELIVERED | GS_FLAGS_CLOSE | GS_FLAGS_LAST;
	} else {
	    flags = GS_FLAGS_DELIVERED | GS_FLAGS_CONTINUED | GS_FLAGS_LAST;
	}

	// add ourself to membership set
	info.sz++;
	info.mset |= (1 << gd->g_nid);
	sz = 0;
	tag.mid = gd->g_nid;
	err = GspSendRequest(gd, ctx, event, GS_MSG_TYPE_UP, mid, 
			     tag.tag,
			     (PVOID) &wsz, sizeof(wsz), NULL, 0, status, flags, &info);


	// advance our startview
	gd->g_startview++;
	gd->g_state = GS_GROUP_STATE_FORM;

	if (context != NULL) {
	    *context = (HANDLE) ctx;
	} else {
	    GspCloseContext(gd, ctx);
	}
	return 0;
    }

    return 0;
}


void
NsJoin()

{
    HANDLE ctx;
    gs_ns_info_t	table[GS_MAX_GROUPS];
    UINT32 i, sz;
    PVOID io[GS_MAX_GROUP_SZ];
    IO_STATUS_BLOCK status[GS_MAX_GROUP_SZ];
    NTSTATUS err;
    gs_event_t event;
    union {
	int	cmd;
	gs_tag_t	tag;
    }tag;

    GsEventInit(event);

    GspJoin(ns_gd, event, io, status, 1, &ctx);
    if (ctx == NULL) {
	GsEventFree(event);
	return;
    }

    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	status[i].Information = 0;
	io[i] = (PVOID)table;
    }
    tag.cmd = NS_TABLE_READ;
    err = GsSendContinuedRequest(ctx, event, 
				 tag.tag, NULL, 0, 
				 io, sizeof(table),
				 status,
				 TRUE);

    if (err != ERROR_SUCCESS) {
	err_log(("Table read failed %x\n", err));
	halt(1);
    }

    sz = 0;
    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	if (status[i].Information != 0) {
	    sz = ((UINT32)status[i].Information) / sizeof(table[0]);
	    break;
	}
    }
    assert(i != GS_MAX_GROUP_SZ);
    ns_log(("NsJoin: Got table %x from master %d sz %d\n", table, i,
	    status[i].Information));

    for (i = 0; i < sz; i++) {
	gs_group_t *gd;
		
	ns_log(("NsJoin: Table%d: %s owner %d\n",
		  table[i].id,
		  table[i].name, table[i].owner));

	gd = GspLookupGroupByName(table[i].name, strlen(table[i].name));
	if (gd == NULL) {
	    gd = GspAllocateGroup(strsave(table[i].name), strlen(table[i].name));
	    if (gd == NULL) {
		err_log(("unable to alloc group %s, exiting..\n",
			  table[i].name));
		halt(1);
	    }
	    GspSetMaster(gd, table[i].owner);
	} else {
	    err_log(("found group %s already, exiting..\n", table[i].name));
	    halt(1);
	}
    }

    GsEventFree(event);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\msg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msg.h

Abstract:

    msg definition

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/


#ifndef GS_MSG_H
#define GS_MSG_H

#include "type.h"

#define	GS_MSG_TYPE_SEQALLOC	0
#define	GS_MSG_TYPE_SEQREPLY	1
#define	GS_MSG_TYPE_MCAST	2
#define	GS_MSG_TYPE_REPLY	3
#define	GS_MSG_TYPE_UCAST	4
#define	GS_MSG_TYPE_ACK		5

#define	GS_MSG_TYPE_INFO	6
#define	GS_MSG_TYPE_MM		7
	
#define	GS_MSG_TYPE_JOIN_REQUEST	8
#define	GS_MSG_TYPE_JOIN	9
#define	GS_MSG_TYPE_UP		10
#define	GS_MSG_TYPE_EVICT_REQUEST	11
#define	GS_MSG_TYPE_EVICT	12

#define	GS_MSG_TYPE_RECOVERY	13
#define	GS_MSG_TYPE_SYNC	14

#define	GS_MSG_TYPE_ABORT      	244
#define	GS_MSG_TYPE_SKIP	255

#define GS_MSG_STATE_FREE	0
#define GS_MSG_STATE_NEW	1
#define GS_MSG_STATE_READY	2
#define GS_MSG_STATE_DELIVERED	3
#define GS_MSG_STATE_DONE	4


typedef struct gs_msg_hdr {
    UINT16	h_len;		// payload size
    UINT16	h_type;		// msg type
    UINT16	h_flags;	// msg flags
    UINT16	h_viewnum;	// generation number, drop this msg if no match
    UINT16	h_rlen;		// for delivered msgs, how big can sender accept reply
    gs_cookie_t		h_cid;	// sender cookie for reply packets
    gs_gid_t		h_gid;	// group id
    gs_sequence_t	h_mseq;	// global sequence
    gs_sequence_t	h_bnum;	// this msg batch number
    gs_sequence_t	h_lseq;	// sender sequence number
    gs_memberid_t	h_mid;	// master member id
    gs_memberid_t	h_sid;	// sender member id
    char		h_tag[64];
}gs_msg_hdr_t;
    
#define MSG_TYPE_HDR	1
#define	MSG_TYPE_DATA	2

typedef struct gs_msg {
    struct gs_msg	*m_next;	// next msg in queue
    UINT8		m_type;		// type
    UINT8		m_refcnt;	// refcnt
    UINT16		m_buflen;	// length of buffer
    gs_msg_hdr_t	m_hdr;		// msg header
    char		*m_buf;
}gs_msg_t;

int
WINAPI
msg_addnode(int id, char *n, char *a);

gs_msg_t * msg_alloc(const char *buf, int len);

int msg_send(gs_memberid_t, gs_msg_hdr_t *, const char *, int);

void msg_mcast(ULONG, gs_msg_hdr_t *, const char *, int);

void msg_smcast(ULONG, gs_msg_hdr_t *, const char *, int);

void msg_free(gs_msg_t *);

int msg_init();

void msg_exit();

int msg_getsize();

typedef void(*gs_msg_handler_t)(gs_msg_t *);

typedef enum {
    MSG_NODE_ID,
    MSG_NODE_JOIN,
    MSG_NODE_UP,
    MSG_NODE_DOWN
}gs_node_event_t;

typedef void(*gs_node_handler_t)(int);

void
msg_set_uport(int uport);


void
msg_set_mport(int mport);


void
msg_set_uipaddr(char *addr);


void
msg_set_mipaddr(char *addr);


void
msg_set_bufcount(int count);

void
msg_set_bufsize(int size);

void
msg_start(ULONG mask);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\msg.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msg.c

Abstract:

    Point to point tcp and ip-multicast

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include <stdio.h>
#include "msg.h"


#include <stdlib.h>
#include <winsock2.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#define MSG_ATOMIC 1

int GS_MAX_MSG_SZ = (64 * 1024);

#define PROTOCOL_TYPE	SOCK_STREAM

extern gs_node_handler_t gs_node_handler[];

static int max_mcmsg = 0;

static char cl_subnet[16];

#define MAX_NODEID	16

int NodesSize = 0;

static char *nodes[MAX_NODEID] = {0};
static char *ipaddr[MAX_NODEID] = {0};

static int DEFAULT_PORT=6009;

static int mcast_enabled = 0;
static int MSG_POOL_SZ=32;

int MY_NODEID;

static SOCKET	prf_handles[MAX_NODEID];
static SOCKET	rcv_handles[MAX_NODEID];
static SOCKET	send_handles[MAX_NODEID];
static SOCKET	tmp_socks[MAX_NODEID];

static CRITICAL_SECTION msglock;
static HANDLE Msg_Event[MAX_NODEID];

void mcast_init();
DWORD WINAPI srv(LPVOID arg);
DWORD WINAPI mcast_srv(LPVOID arg);
DWORD WINAPI srv_io(LPVOID arg);
DWORD WINAPI cmgr(LPVOID arg);

static gs_msg_t *msg_pool = NULL;
static gs_msg_t *msg_hdrpool = NULL;


void
Msg_AllocPool()
{
    char *p;
    gs_msg_t *prev;
    int sz, elmsz;

    // allocate msg header pool
    sz = sizeof(gs_msg_t) * MSG_POOL_SZ;
    prev = (gs_msg_t *) malloc(sz);
    if (prev == NULL) {
	printf("Unable to allocate message hdr pool\n");
	halt(1);
    }
    msg_hdrpool = NULL;
    for (sz = 0; sz < MSG_POOL_SZ; sz++) {
	prev->m_refcnt = 0;
	prev->m_buflen = 0;
	prev->m_buf = NULL;
	prev->m_next = msg_hdrpool;
	msg_hdrpool = prev;
	prev++;
    }

    // allocate msg pool
    sz = sizeof(gs_msg_t) * MSG_POOL_SZ;
//    prev = (gs_msg_t *) malloc(sz);
    prev = (gs_msg_t *) VirtualAlloc(NULL, sz, MEM_RESERVE|MEM_COMMIT,
		     PAGE_READWRITE);
    if (prev == NULL) {
	printf("Unable to allocate message pool\n");
	halt(1);
    }

    // lock region now
    if (!VirtualLock(prev, sz)) {
	printf("Unable to lock down hdr pages %d\n", GetLastError());
    }

    sz = MSG_POOL_SZ * GS_MAX_MSG_SZ;
    p = VirtualAlloc(NULL, sz, MEM_RESERVE|MEM_COMMIT,
		     PAGE_READWRITE);
    if (p == NULL) {
	printf("Unable to allocate message memory pool\n");
	halt(1);
    }

    if (!VirtualLock(p, sz)) {
	printf("Unable to lock down pages %d err %d\n", sz, GetLastError());
    }

    msg_pool = NULL;
    for (sz = 0; sz < MSG_POOL_SZ; sz++) {
	prev->m_refcnt = 0;
	prev->m_buflen = GS_MAX_MSG_SZ - 1;
	prev->m_buf = p;
	prev->m_next = msg_pool;
	msg_pool = prev;
	prev++;
	*p = 0;	// touch it
	p += GS_MAX_MSG_SZ;
    }

}


gs_msg_t *
msg_hdralloc(const char *buf, int len)
{
    PVOID t;
    gs_msg_t * p;

#ifdef MSG_ATOMIC
    do {
	p = msg_hdrpool;
	if (p == NULL) {
	    break;
	}
	t = InterlockedCompareExchangePointer((PVOID *)&msg_hdrpool, 
					      (PVOID)p->m_next, (PVOID) p);
    } while (t != (PVOID) p);
#else
    GsLockEnter(msglock);
    if (p = msg_hdrpool) {
	msg_hdrpool = p->m_next;
	p->m_next = NULL;
    }
    GsLockExit(msglock);
#endif    

    if (p == NULL) {
	printf("Out of message headers!!!\n");
	halt(1);
    }
    
//    p->m_buflen = 0;
    p->m_refcnt = 1;
    p->m_buf = (char *)buf;
    p->m_type = MSG_TYPE_HDR;

    msg_log(("Alloc hdr msg %x len %d pool %x\n", p, p->m_buflen, msg_hdrpool));
    return p;

}

gs_msg_t *
msg_alloc(const char *buf, int len)
{
    PVOID t;
    gs_msg_t * p;

    if (len > GS_MAX_MSG_SZ) {
	printf("Large msg, can't handle %d\n", len);
	halt(1);
    }

    if (buf != NULL) {
	return msg_hdralloc(buf, len);
    }

#ifdef MSG_ATOMIC
    do {
	p = msg_pool;
	if (p == NULL) {
	    break;
	}
	t = InterlockedCompareExchangePointer((PVOID *)&msg_pool, 
					      (PVOID)p->m_next, (PVOID) p);
    } while (t != (PVOID) p);
#else
    GsLockEnter(msglock);
    if (p = msg_pool) {
	msg_pool = p->m_next;
	p->m_next = NULL;
	msg_log(("Alloc msg %x pool %x\n", p, msg_pool));
    }
    GsLockExit(msglock);
#endif    

    if (p == NULL) {
	printf("Out of messages!!!\n");
	halt(1);
    }
    
//    p->m_buflen = len;
    p->m_refcnt = 1;
    p->m_type = MSG_TYPE_DATA;

    if (buf) {
	memcpy(p->m_buf, buf, len);
    }

    msg_log(("Alloc msg %x buf %x len %d\n", p, p->m_buf, p->m_buflen));

    return p;

}


void
msg_hdrfree(gs_msg_t *msg)
{
    PVOID t, p;
    
    msg_log(("Free hdr msg %x len %d pool %x\n", msg, msg->m_buflen,msg_pool));
#ifdef MSG_ATOMIC
    do {
	msg->m_next = msg_hdrpool;
	t = InterlockedCompareExchangePointer((PVOID *)&msg_hdrpool, (PVOID)msg, 
					      (PVOID)msg->m_next);
    } while (t != (PVOID) msg->m_next);
#else
    GsLockEnter(msglock);
    msg->m_next = msg_hdrpool;
    msg_hdrpool = msg;
    GsLockExit(msglock);
#endif
}

void
msg_free(gs_msg_t *msg)
{
    PVOID t, p;
    
    msg->m_refcnt--;
    if (msg->m_refcnt > 0) {
	msg_log(("msg %x not freed %d flags %x\n", msg, msg->m_refcnt, 
		 msg->m_hdr.h_flags));
	if (msg->m_refcnt > 10) {
	    halt(0);
	}
	return;
    }
    if (msg->m_type == MSG_TYPE_HDR) {
	msg_hdrfree(msg);
	return;
    }
    msg_log(("Free msg %x buf %x pool %x\n", msg, msg->m_buf, msg_pool));
#ifdef MSG_ATOMIC
    do {
	msg->m_next = msg_pool;
	t = InterlockedCompareExchangePointer((PVOID *)&msg_pool, (PVOID)msg, 
					      (PVOID)msg->m_next);
    } while (t != (PVOID) msg->m_next);
#else
    GsLockEnter(msglock);
    msg->m_next = msg_pool;
    msg_pool = msg;
    GsLockExit(msglock);
#endif
}


char *
strsave(char *s)
{
  char *p;

  p = (char*)malloc(strlen(s) + 1);
  assert(p != NULL);
  return strcpy(p, s);
}

int 
Strncasecmp(char *s, char *p, int len)
{
  while (len-- > 0) {
    if (tolower(s[len]) != tolower(p[len]))
      return 1;
  }
  return 0;
}

/********************************************************************/

int
msg_buildaddr(struct sockaddr_in *sin, char *hostname, char *ipaddr)
{
    
    struct hostent *h;
    int i;
    char *p;
    char *tmp;

    h = gethostbyname(hostname);
    if (h == NULL) {
	fprintf(stderr,"cannot get info for host %s\n", hostname);
	return 1;
    }

    p = (char *) h->h_addr_list[0];
    for (i = 0; h->h_addr_list[i]; i++) {
	struct in_addr x;

	memcpy(&x, p, h->h_length);
	tmp = inet_ntoa(x);
	if (!strncmp(cl_subnet, tmp, strlen(cl_subnet))) {
	    break;
	}
	p += h->h_length;
    }
    if (h->h_addr_list[i] == NULL) {
	printf("Unable to find proper subnet %s host %s\n", cl_subnet, hostname);
	if (ipaddr != NULL) {
	    // use this address
	    sin->sin_addr.s_addr = inet_addr(ipaddr);
	    printf("host %s addr %s\n", hostname, ipaddr);
	} else {
	    sin->sin_addr.s_addr = INADDR_ANY;
	    printf("host %s addr %s\n", hostname, "any");
	}
    } else {
	memcpy(&sin->sin_addr.s_addr, h->h_addr_list[i], h->h_length);
	printf("host %s addr %s\n", hostname, tmp);
    }
    return 0;
    
}


#ifndef TEST
int
WINAPI
msg_addnode(int id, char *n, char *a)
{
    char *s;

    s = strchr(n, '.');	
    if (s) {
	*s = '\0';
    }

    printf("nodeid %d node %s ip %s\n", id, n, a);


    nodes[id-1] = strsave(n);
    ipaddr[id-1] = strsave(a);

    if (id > NodesSize)
	NodesSize = id;

    return NodesSize;

}
#endif
/********************************************************************/

int
msg_getsize()
{
    return NodesSize;
}

void
msg_closenode(int nodeid)
{

    GsLockEnter(msglock);
    if (rcv_handles[nodeid]) {
	closesocket(rcv_handles[nodeid]);
	rcv_handles[nodeid] = 0;
    }
    if (send_handles[nodeid]) {
	closesocket(send_handles[nodeid]);
	send_handles[nodeid] = 0;
    }
    prf_handles[nodeid] = 0;
    GsLockExit(msglock);
    return;
}

int
msg_send(gs_memberid_t nodeid, gs_msg_hdr_t *hdr, const char *buf, int len)
{
	int i;
	SOCKET s;
	WSABUF	io[2];
	LPWSAOVERLAPPED ov;

	ov = NULL;

	nodeid--;
	if (nodeid >= NodesSize) {
	    err_log(("send bad node %d\n", nodeid));
	    return 1;
	}

	s = prf_handles[nodeid];
	if (!s) {
	    s = send_handles[nodeid];
	    if (!s) {
		s = rcv_handles[nodeid];
		if (!s) {
		    err_log(("Node %d is dead\n", nodeid+1));
		    return 1;
		}
	    }
	}

	msg_log(("Send msg nid %d type %d seq %d bnum %d view %d\n",
		 nodeid+1, hdr->h_type, hdr->h_mseq,
		 hdr->h_bnum, hdr->h_viewnum));
	io[0].len = sizeof(*hdr);
	io[0].buf = (char *) hdr;
	io[1].len = len;
	io[1].buf = (char *) buf;

	if (WSASend(s, io, 2, &i, 0, ov, 0)) {
	    int err = WSAGetLastError();
	    if (err == WSA_IO_PENDING) {
		printf("Async send\n");
		return 1;
	    }
	    printf("Send nid %d failed %d\n", nodeid+1, err);
	    msg_closenode(nodeid);
	    return 1;
	}
	i -= sizeof(*hdr);
	if (i != len) {
	    printf("Send failed: node %d len %d, %d\n", nodeid+1, len, i);
	    halt(1);
	}
	return 0;
}


void
msg_mcast(ULONG mset, gs_msg_hdr_t *hdr, const char *buf, int len)
{
    gs_memberid_t i;
    void mcast_send(gs_msg_hdr_t *hdr, const char *buf, int len);

    mset = mset & ~(1 << MY_NODEID);
    if (mset == 0)
	return;
//    if (mcast_enabled == 0 || len > max_mcmsg) {
    if (len > max_mcmsg) {
	
	for (i = 1; i <= NodesSize; i++) {
	    if (mset & (1 << i)) {
		msg_send(i, hdr, buf, len);
	    }
	}
    }
    else {
	mcast_send(hdr, buf, len);
    }
}

void
msg_smcast(ULONG mset, gs_msg_hdr_t *hdr, const char *buf, int len)
{
    gs_memberid_t i;

    mset = mset & ~(1 << MY_NODEID);
    if (mset == 0)
	return;
    for (i = 1; i <= NodesSize; i++) {
	if (mset & (1 << i)) {
	    msg_send(i, hdr, buf, len);
	}
    }
}

msg_init()
{
	int i;
	WSADATA wsaData;
	char h_name[64];

	// set our priority to high class
	if (!SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS)) {
	    printf("Unable to set high priority %d\n", GetLastError());
	}

	if (WSAStartup(0x202,&wsaData) == SOCKET_ERROR) {
		fprintf(stderr,"WSAStartup failed with error %d\n",
			WSAGetLastError());
		WSACleanup();
		return -1;
	}

	i = gethostname(h_name, 64);


	// increase our working set
	if (!SetProcessWorkingSetSize(GetCurrentProcess(),
				      32*1024*1024, 64*1024*1024)) {
	    printf("Unable to set working size %d\n", GetLastError());
	}

	InitializeCriticalSection(&msglock);

	Msg_AllocPool();


	for (i = 0; i < NodesSize; i++) {
	    Msg_Event[i] = CreateEvent(NULL, TRUE, FALSE, NULL);
	    prf_handles[i] = 0;
	    send_handles[i] = 0;
	    rcv_handles[i] = 0;
	    if (!Strncasecmp(h_name, nodes[i], strlen(h_name))) {
		MY_NODEID = i+1;
		gs_node_handler[MSG_NODE_ID](MY_NODEID);
	    } else {
		LPVOID arg = (LPVOID) ((ULONGLONG) i);
		CreateThread(NULL, 2*64*1024, cmgr, arg, 0, NULL);
	    }
	}
	cm_log(("Local host %d %s\n", MY_NODEID, h_name));

	if (mcast_enabled) {
	    mcast_init();
	}

	if (NodesSize > 1) {
	    LPVOID arg = (LPVOID) ((ULONGLONG) DEFAULT_PORT);
	    // create srv thread
	    CreateThread(NULL, 4*1024, srv, arg, 0,NULL);
	    // create mcast thread
	    if (mcast_enabled) {
		for (i = 0; i < 8; i++)
		    CreateThread(NULL, 2*64*1024, mcast_srv, 0, 0,NULL);
	    }
	}

	return 0;
}

void
msg_exit()
{
    // xxx: Stop all threads before during this
    WSACleanup();
}

void
msg_start(ULONG mask)
{
    int i;

    mask = mask >> 1;
    for (i = 0; i < NodesSize; i++) {
	GsLockEnter(msglock);
	if (!(mask & (1 << i)) && !send_handles[i]) {
	    SetEvent(Msg_Event[i]);
	}
	GsLockExit(msglock);
    }
}
    
DWORD
srv_msg(SOCKET msgsock, int nodeid)
{
  gs_msg_t *msg;
  int retval;
  char *buf;
  int len;

  while (1) {
      extern gs_msg_handler_t gs_msg_handler[];
      int type;

      msg = msg_alloc(NULL, GS_MAX_MSG_SZ);

      // read hdr info first
      buf = (char *) &msg->m_hdr;
      len = sizeof(msg->m_hdr);

      do {
	  retval = recv(msgsock, buf, len, 0);
	  if (retval < 0) {
	      err_log(("recv failed %d, %d\n",
		       retval,
		       WSAGetLastError()));
	      msg_free(msg);
	      return 0;
	  }

	  len -= retval;
	  buf += retval;
      } while (len > 0);

      // read rest of message
      buf = msg->m_buf;
      len = msg->m_hdr.h_len;

      while (len > 0) {

	  retval = recv(msgsock, buf, len, 0);
	  if (retval < 0) {
	      err_log(("recv failed %d, %d\n",retval,
		       WSAGetLastError()));	
	      msg_free(msg);
	      return 0;
	  }
	  len -= retval;
	  buf += retval;
      }

      // set preferred socket to use
      prf_handles[nodeid] = msgsock;

      msg_log(("rec nid %d gid %d type %d seq %d view %d len %d\n",
	       msg->m_hdr.h_sid,msg->m_hdr.h_gid, type = msg->m_hdr.h_type,
	       msg->m_hdr.h_mseq, msg->m_hdr.h_viewnum, msg->m_hdr.h_len));

      gs_msg_handler[msg->m_hdr.h_type](msg);

      msg_log(("Done Type %d\n", type));
  }

  return 0;
}
    
DWORD WINAPI
srv_io(LPVOID arg)
{
  int retval;
  char *buf;
  int len;
  ULONGLONG tmp = (ULONGLONG) arg;
  int nodeid = (int) tmp;
  SOCKET msgsock = tmp_socks[nodeid];


  GsLockEnter(msglock);

  gs_node_handler[MSG_NODE_JOIN](nodeid+1);
  rcv_handles[nodeid] = msgsock;

  // issue join callback
  if (!send_handles[nodeid]) {
      gs_node_handler[MSG_NODE_UP](nodeid+1);
      SetEvent(Msg_Event[nodeid]);
  }
  GsLockExit(msglock);

  srv_msg(msgsock, nodeid);

  cm_log(("Terminating connection with node %d\n", nodeid));

  msg_closenode(nodeid);
  gs_node_handler[MSG_NODE_DOWN](nodeid+1);
  return (0);
}

void
msg_setopt(SOCKET s)
{
    // set option keepalive
    BOOLEAN val = TRUE;
    if (setsockopt(s, IPPROTO_TCP, SO_KEEPALIVE, (char *)&val,
		   sizeof(val)) == SOCKET_ERROR) {
	fprintf(stderr,"Keepalive %d\n", WSAGetLastError());
    }

    // set option nodelay
    val = TRUE;
    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&val,
		   sizeof(val)) == SOCKET_ERROR) {
	fprintf(stderr,"No delay %d\n", WSAGetLastError());
    }

    // set option nolinger
    val = TRUE;
    if (setsockopt(s, SOL_SOCKET, SO_DONTLINGER, (char *)&val,
		   sizeof(val)) == SOCKET_ERROR) {
	fprintf(stderr,"No delay %d\n", WSAGetLastError());
    }
}


DWORD WINAPI
srv(LPVOID arg)
{
	char *nic= NULL;
	int fromlen;
	int i;
	struct sockaddr_in local, from;
	SOCKET listen_socket, msgsock;
	ULONGLONG tmp = (ULONGLONG) arg;
	short port = (short) tmp;
#if 0
	nic = ipaddr[MY_NODEID-1];

	local.sin_addr.s_addr = (!nic)?INADDR_ANY:inet_addr(nic); 
#else
	if (msg_buildaddr(&local, nodes[MY_NODEID-1], ipaddr[MY_NODEID-1])) {
	    fprintf(stderr,"Unable to get my own address\n");
	    return -1;
	}
#endif
	local.sin_family = AF_INET;

	/* 
	 * Port MUST be in Network Byte Order
	 */
	local.sin_port = htons(port);

	// TCP socket
	listen_socket = WSASocket(AF_INET, PROTOCOL_TYPE, 0, NULL, 0,
				  WSA_FLAG_OVERLAPPED);
	
	if (listen_socket == INVALID_SOCKET){
		fprintf(stderr,"socket() failed with error %d\n",WSAGetLastError());
		return -1;
	}

	//
	// bind() associates a local address and port combination with the
	// socket just created. This is most useful when the application is a 
	// server that has a well-known port that clients know about in advance.
	//

	if (bind(listen_socket,(struct sockaddr*)&local,sizeof(local) ) 
		== SOCKET_ERROR) {
		fprintf(stderr,"bind() failed with error %d\n",WSAGetLastError());
		return -1;
	}

	msg_setopt(listen_socket);

	if (listen(listen_socket,5) == SOCKET_ERROR) {
	  fprintf(stderr,"listen() failed with error %d\n",WSAGetLastError());
	  return -1;
	}

	while(1) {
		char *name;
		struct hostent *p;

		cm_log(("Accepting connections\n"));

		fromlen =sizeof(from);
		msgsock = accept(listen_socket,(struct sockaddr*)&from, &fromlen);
		if (msgsock == INVALID_SOCKET) {
		  fprintf(stderr,"accept() error %d\n",WSAGetLastError());
		  return -1;
		}

		name = inet_ntoa(from.sin_addr);
		p = gethostbyaddr((char *)&from.sin_addr, 4, AF_INET);
		if (p == NULL) {
			printf("can't find host name %s %d\n", name, GetLastError());
			closesocket(msgsock);
			continue;
		}
		name = p->h_name;
		if (strchr(name, '~')) {
		    name = strchr(name, '~') + 1;
		}
		// find node id
		for (i = 0; i < NodesSize; i++) {
			int j;
			j = Strncasecmp(nodes[i], name, strlen(name));
			if (j == 0)
				break;
		}

		if (i < NodesSize) {
		    cm_log(("Accepted node : %d\n", i));

		    msg_setopt(msgsock);

		    tmp_socks[i] = msgsock;
		    CreateThread(NULL, 2*64*1024, srv_io,
				 (LPVOID) ((ULONGLONG)i), 0, NULL);
		} else {
			printf("bad node name: %d %s\n", i, name);
			closesocket(msgsock);
		}
	}
	return (0);
}

DWORD WINAPI
cmgr(LPVOID arg)
{
	int retval;
	struct sockaddr_in server;
	SOCKET  conn_socket;
	unsigned short port = (unsigned short) DEFAULT_PORT;
	int nodeid = (int) ((ULONGLONG)arg);
	char *server_name = nodes[nodeid];

	if (send_handles[nodeid] != 0 || (nodeid+1 == MY_NODEID))
	    return 0;

	memset(&server,0,sizeof(server));
	if (msg_buildaddr(&server, server_name, ipaddr[nodeid])) {
	    fprintf(stderr,"Client: cann't resolve name %s\n", server_name);
	    return 0;
	}

	//
	// Copy the resolved information into the sockaddr_in structure
	//
	server.sin_family = AF_INET; //hp->h_addrtype;
	server.sin_port = htons(port);

 again:	

	ResetEvent(Msg_Event[nodeid]);

	/* Open a socket */
	conn_socket = WSASocket(AF_INET, PROTOCOL_TYPE, 0, NULL, 0,
				WSA_FLAG_OVERLAPPED);
	if (conn_socket  != 0 ) {
		cm_log(("Client connecting to: %s\n", nodes[nodeid]));

		msg_setopt(conn_socket);

		if (connect(conn_socket,(struct sockaddr*)&server,sizeof(server))
		    != SOCKET_ERROR) {

		    cm_log(("Client connected to: %s\n", nodes[nodeid]));
		    GsLockEnter(msglock);
		    gs_node_handler[MSG_NODE_JOIN](nodeid+1);
		    send_handles[nodeid] = conn_socket;
		    if (!rcv_handles[nodeid]) {
			gs_node_handler[MSG_NODE_UP](nodeid+1);
		    }
		    GsLockExit(msglock);
		    srv_msg(conn_socket, nodeid);
		    msg_closenode(nodeid);
		    gs_node_handler[MSG_NODE_DOWN](nodeid+1);
		} else {
		    int err = WSAGetLastError();
		    cm_log(("connect() failed: %d\n", err));
		    closesocket(conn_socket);
		}
	} else {
	    int err = WSAGetLastError();
	    printf("Client: Error Opening socket: Error %d\n", err);
	}

	cm_log(("Cmgr %d sleeping\n", nodeid));
	WaitForSingleObject(Msg_Event[nodeid], INFINITE); //5 * 1000);
	cm_log(("Cmgr %d wokeup\n", nodeid));


	goto again;

    return (0);

}



static char *MCAST_IPADDR="224.0.20.65";
static int MPORT_NUM=9100;

int
OpenSocket(SOCKET *rs, struct sockaddr_in *sin, ULONG mipaddr, u_short port)
{
	struct hostent *h;
	int size, msgsize, len, n;
	struct sockaddr_in mysin;
	SOCKET s;
	char hostname[128];
	BOOLEAN bFlag = TRUE;

	s = WSASocket(AF_INET, SOCK_DGRAM, 0, (LPWSAPROTOCOL_INFO)NULL, 0, 
		  WSA_FLAG_OVERLAPPED | WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF);

	if (s == INVALID_SOCKET) {
	  fprintf(stderr, "Unable to create socket %d\n", GetLastError());
	  return 1;
	}
#if 1	
	if (msg_buildaddr(&mysin, nodes[MY_NODEID-1], ipaddr[MY_NODEID-1])) {
	    fprintf(stderr, "Unable to get my own address\n");
	    return 1;
	}
#if 0
	gethostname(hostname, sizeof(hostname));
	h = gethostbyname(hostname);
	if (h == NULL) {
		fprintf(stderr,"cannot get my own address\n");
		return 1;
	}
	printf("host %s addr cnt = %d\n", hostname, h->h_length);
	{
	    int i;
	    char *p;
	    p = (char *) h->h_addr_list[0];
	    for (i = 0; h->h_addr_list[i]; i++) {
		struct in_addr x;
		char *tmp;

		memcpy(&x, p, h->h_length);
		tmp = inet_ntoa(x);
		printf("Slot %d ip %s\n", i, tmp);
		p += h->h_length;
	    }
	}
	memcpy(&mysin.sin_addr.s_addr, h->h_addr_list[0], 4);
#endif
#else
	if (ipaddr[MY_NODEID-1] != NULL) {
	    mysin.sin_addr.s_addr = inet_addr(ipaddr[MY_NODEID-1]);
	} else {
	    mysin.sin_addr.s_addr = INADDR_ANY;
	}
#endif
	mysin.sin_family = PF_INET;
	port = htons (port);
	mysin.sin_port = (u_short) port;

	if (bind (s, (struct sockaddr *)&mysin, sizeof(mysin)) <0) {
	  fprintf(stderr, "Bind failed %d\n", GetLastError());
	  return 1;
	}

	len = sizeof(max_mcmsg);
	/* get max. message size */
	if (getsockopt(s, SOL_SOCKET, SO_MAX_MSG_SIZE, (PVOID) &max_mcmsg,
		       &len)) {
	    fprintf(stderr,"getsockopt SO_MAX_MSG_SIZE failed %d\n",
		    WSAGetLastError());
	    closesocket(s);
	    return 1;
	}
	max_mcmsg -= sizeof(gs_msg_hdr_t);
	printf("Max mcast message %d\n", max_mcmsg);

	/* make sure we can run multiple copies */
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &bFlag, sizeof(bFlag))< 0) {
	  fprintf(stderr, "setsockopt SO_REUSEADDR failed %d\n", GetLastError());
	  closesocket(s);
	  return 1;
	}

	/* disable loopback on send */
	bFlag = FALSE;
	if (WSAIoctl(s, SIO_MULTIPOINT_LOOPBACK, (char *) &bFlag, sizeof(bFlag), NULL, 0, &n, NULL, NULL)< 0) {
	  fprintf(stderr, "ioctl loopback failed %d\n", GetLastError());
	  closesocket(s);
	  return 1;
	}

	sin->sin_family      = PF_INET;
	sin->sin_port        = (u_short) (ntohs(port));
	sin->sin_addr.s_addr = mipaddr; //inet_addr(MCAST_IPADDR);

	/* join the multicast address */
	s = WSAJoinLeaf (s, (struct sockaddr *)sin, sizeof (*sin),
		NULL, NULL, NULL, NULL,  JL_BOTH); 

	/* dead in the water */
	if (s == INVALID_SOCKET) {
		fprintf(stderr, "Join failed %d\n", GetLastError());
		return 1;
	}

	*rs = s;
	return 0;
}


SOCKET msock;
struct sockaddr_in msin;

void
mcast_send(gs_msg_hdr_t *hdr, const char *buf, int len)
{
	int i;
	WSABUF	io[2];

	msg_log(("Send msg mcast type %d seq %d len %d\n",
		 hdr->h_type, hdr->h_mseq, len));

	io[0].buf = (char *) hdr;
	io[0].len = sizeof(*hdr);
	io[1].buf = (char *) buf;
	io[1].len = len;

	if (WSASendTo(msock, io, 2, &i, 0, 
		    (struct sockaddr *)&msin, sizeof(msin), 0, 0)) {
	    int err = WSAGetLastError();
	    if (err == WSA_IO_PENDING) {
		printf("Async send\n");
		return;
	    }
	    printf("Send failed %d\n", WSAGetLastError());
	    halt(1);
	}
	i -= sizeof(*hdr);
	if (i != len) {
	    printf("Send failed: mcast len %d, %d\n", len, i);
	    halt(1);
	}
	msg_log(("Send done mcast type %d seq %d\n",
		 hdr->h_type, hdr->h_mseq));
	return;
}

void
mcast_init()
{
  u_short port = (u_short) MPORT_NUM;
  ULONG	ipaddr = inet_addr(MCAST_IPADDR);

  if (OpenSocket(&msock, &msin, ipaddr, port) == 1) {
      err_log(("Unable to create mcast socket\n"));
      mcast_enabled = 0;
      max_mcmsg = 0;
  }

  printf("Mcast %d\n", mcast_enabled);



}

DWORD WINAPI
mcast_srv(LPVOID arg)
{
  SOCKET msgsock;
  gs_msg_t *msg;
  int retval;
  char *buf;
  int len, flags;

  msgsock = msock;
  while (1) {
      extern gs_msg_handler_t gs_msg_handler[];
      int type;
      WSABUF	io[2];

      msg = msg_alloc(NULL, GS_MAX_MSG_SZ);
      assert(msg);
      assert(msg->m_buflen != 0);

      io[0].buf = (char *)&msg->m_hdr;
      io[0].len = sizeof(msg->m_hdr);
      io[1].buf = msg->m_buf;
      io[1].len = msg->m_buflen;

      flags = 0;
      retval = WSARecv(msgsock, io, 2, &len, &flags, 0, 0);
      if (retval == SOCKET_ERROR) {
	  err_log(("mcast recv failed %d, %d, len %d\n",
		   retval,
		   WSAGetLastError(), msg->m_buflen));
	  msg_free(msg);
	  halt(1);
	  return 0;
      }

      if (len != (int)(msg->m_hdr.h_len + sizeof(msg->m_hdr))) {
	  err_log(("Bad mcast recv got %d, expected %d\n", len, msg->m_hdr.h_len));
	  halt(1);
      }
      msg_log(("rec mcast nid %d gid %d type %d seq %d view %d len %d\n",
	       msg->m_hdr.h_sid,msg->m_hdr.h_gid, type = msg->m_hdr.h_type,
	       msg->m_hdr.h_mseq, msg->m_hdr.h_viewnum, msg->m_hdr.h_len));

      gs_msg_handler[msg->m_hdr.h_type](msg);

      msg_log(("Done Type %d\n", type));
  }
}

void
msg_set_uport(int uport)
{
    DEFAULT_PORT = uport;
}

void
msg_set_mport(int mport)
{
    MPORT_NUM = mport;
}

void
msg_set_subnet(char *addr)
{
    strcpy(cl_subnet, addr);
}

void
msg_set_mipaddr(char *addr)
{
}

void
msg_set_bufcount(int count)
{
    MSG_POOL_SZ = count;
}

void
msg_set_bufsize(int size)
{
    if (size > GS_MAX_MSG_SZ) {
	fprintf(stderr,"You are exceeding the 64K msg size limit\n");
    } else {
	GS_MAX_MSG_SZ = size;
    }
}

void
msg_set_mode(int mode)
{
    mcast_enabled = mode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\quorm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    quorum.c

Abstract:

    Implements quorum for cm, uses UNC file for now

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
//#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


// Quorum stuff
static HANDLE DlmQhd = 0;
static char *default_qfile="\\DosDevices\\UNC\\ahmedm\\tmp\\gs.qrm";

extern char *WINAPI config_get_qfile();

BOOLEAN
QuormAcquire()
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;
    WCHAR	buf[128];
    int		n;
    char    *qfile;

    if (DlmQhd)
	return TRUE;

    qfile = config_get_qfile();
    if (!qfile) {
        qfile = default_qfile;
    }
    // no-quorum is specified
    if (qfile[0] == '\0')
	return TRUE;

    // convert to unicode
    n = MultiByteToWideChar(CP_ACP, 0, qfile, strlen(qfile), buf, sizeof(buf));
    buf[n] = buf[n+1] = '\0';
    RtlInitUnicodeString(&cwspath, buf);

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);

    status = NtCreateFile(&DlmQhd,
			  SYNCHRONIZE | DELETE,
			  &objattrs,
			  &iostatus,
			  0,
			  FILE_ATTRIBUTE_NORMAL,
			  0,
			  FILE_CREATE,
			  FILE_DELETE_ON_CLOSE |  FILE_NON_DIRECTORY_FILE,
			  NULL,
			  0);

    if (status != STATUS_SUCCESS) {
	if (status != STATUS_OBJECT_NAME_COLLISION) {
	    printf("Quorm '%s' failed %x\n", qfile, status);
	}
        return FALSE;
    }

    return TRUE;
}

void
QuormInit()
{
    DlmQhd = 0;
}

void
QuormRelease()
{
    if (DlmQhd) {
	NtClose(DlmQhd);
	DlmQhd = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\gsp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gsp.h

Abstract:

    Private gs definitions

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#ifndef _GS_P_H
#define _GS_P_H

#include "type.h"
#include "msg.h"

#include <Mmsystem.h>

#define	GS_DEFAULT_WINDOW_SZ		8
#define	GS_DEFAULT_MAX_MSG_SZ		GS_MAX_MSG_SZ

extern int GS_MAX_MSG_SZ;

#define	GsGroupTableSize		16

#define GS_FLAGS_CLOSE		0x01
#define GS_FLAGS_CONTINUED	0x02
#define GS_FLAGS_DELIVERED	0x04
#define GS_FLAGS_QUEUED		0x08	// in receive queue

#define GS_FLAGS_LAST		0x10
#define GS_FLAGS_REPLAY		0x20
#define GS_FLAGS_REPLY		0x40
#define GS_FLAGS_PTP		0x80
#define	GS_FLAGS_MASK		0x07

#define	GS_GROUP_STATE_FREE	0x0
#define	GS_GROUP_STATE_NEW	0x01
#define	GS_GROUP_STATE_FORM	0x02
#define	GS_GROUP_STATE_JOIN	0x04
#define	GS_GROUP_STATE_EVICT	0x08

#define	GS_GROUP_FLAGS_RECOVERY	0x10
#define	GS_GROUP_FLAGS_NEWMASTER 0x20

#define	GS_CONTEXT_INVALID_ID	((gs_cookie_t) -1)

typedef struct gs_member {
    gs_memberid_t 	m_id;
    gs_sequence_t	m_expected_seq;	// next expected 1-to-1 sequence
    gs_msg_t		*m_queue;	// list of queued 1-to-1 msgs
//    gs_addr_t		m_uaddr;	// ip addr
    UINT16		m_wsz;		// max. window sz
    UINT16		m_msz;		// max. msg sz
}gs_member_t;

typedef struct gs_ctx {
    gs_gid_t		ctx_gid;
    gs_cookie_t		ctx_id;
    PVOID		ctx_buf;
    gs_sequence_t	ctx_mseq;
    gs_sequence_t	ctx_bnum;
    UINT16		ctx_flags;
    gs_msg_t		*ctx_msg;
    PVOID		*ctx_rbuf;
    IO_STATUS_BLOCK	*ctx_ios;
    ULONG		ctx_mask;
    gs_event_t		ctx_syncevent;
    gs_event_t		ctx_event;
    MMRESULT		ctx_timer;
}gs_context_t;

typedef struct {
    gs_semaphore_t	s_sema;		// how many concurrent sends are allowed
    gs_context_t	*s_ctxpool;	// send contexts pool
    UINT16		s_wsz;		// max. window sz
    gs_msg_t		*s_waitqueue;	// list of msgs waiting for global sequence
    gs_sequence_t	s_lseq;	// last completed mseq
    gs_sequence_t	s_mseq;	// last allocated global sequence
    gs_sequence_t	s_bnum;	// next 1-to-1 sequence for a given mseq
}gs_send_state_t;

typedef struct {
    gs_sequence_t	r_mseq;		// next expected global sequence
    gs_sequence_t	r_bnum; 	// next expected batch sequence

    gs_msg_t		**r_next;	// next message to deliver to app
    gs_msg_t		*r_head;	// head of receive queue
}gs_recv_state_t;    

typedef struct gs_rblk {
    struct gs_rblk	*next;
    gs_sequence_t	mseq;
    ULONG		have;
}gs_rblk_t;

typedef struct {
    gs_event_t		rs_event;
    ULONG		rs_dset;	// down member set
    ULONG		rs_mset;	// member set to hear from
    UINT16		rs_epoch;
    UINT16		rs_sz;
    gs_rblk_t		*rs_list;
}gs_recovery_state_t;

typedef struct gs_group {
    gs_lock_t	g_lock;

    gs_gid_t	g_id;	// cluster wide group id
    gs_nid_t	g_nid;	// local cluster node id

//    int	g_port;	// group port number
//    gs_addr_t	g_maddr;	// multicast ip addr

    UINT8	g_state;
    UINT8	g_pending;

    UINT16	g_curview;	// increment on every member down/up
    UINT16	g_startview;	// set to curview on member down

    // member information
    UINT16	g_sz;
    gs_member_t *g_mlist;
    gs_memberid_t g_mid;	// master id
    gs_mset_t	g_mset;		// current member set
    
    // master/send/receive states
    gs_sequence_t	g_global_seq;	// next global sequence number

    gs_send_state_t		g_send;
    gs_recv_state_t		g_recv;

    // event handler
    gs_callback_t		g_callback;

    // recovery state
    gs_recovery_state_t		*g_rs;

    int		g_namelen;
    char	*g_name;
}gs_group_t;

#define GspLookupContext(gd, cid)	&gd->g_send.s_ctxpool[cid]

gs_group_t *
GspLookupGroup(gs_gid_t gid);

void
GspProcessReply(gs_group_t *gd, gs_context_t *ctx, 
		int sid, char *buf, int rlen,
		NTSTATUS status);

void
GspDispatch(gs_group_t *gd);

void
GspOpenContext(gs_group_t *gd, gs_context_t **context);

void
GspCloseContext(gs_group_t *gd, gs_context_t *ctx);

void
GspOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t bnum);

void
GspUOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t lseq);

void
GspDeliverMsg(gs_group_t *gd, gs_msg_t *msg);

void
GspSendAck(gs_group_t *gd, gs_msg_t *msg, NTSTATUS status);

void
GspRemoveMsg(gs_group_t *gd, gs_msg_t *msg);

NTSTATUS
GspSendDirectedRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t ev,
		       int memberid, gs_tag_t tag,
		       PVOID buf, UINT32 len, 
		       PVOID rbuf, UINT32 rlen, 
		       IO_STATUS_BLOCK *status,
		       UINT32 flags, UINT32 type);

// Response of name server during phase 1 of join
typedef struct {
    union {
	USHORT	id;
	USHORT	wsz;
    };
    USHORT	owner;
    char	name[GS_MAX_NAME_SZ];
}gs_ns_info_t;

// Response of current master to a join request
typedef struct {
    UINT16		sz;
    UINT16		viewnum;
    gs_sequence_t	mseq;
    gs_mset_t		mset;	// current member set
}gs_join_info_t;

// Response of current master to a sequence allocation request
typedef struct {
    gs_sequence_t	mseq;
    UINT16		viewnum;
}gs_seq_info_t;

typedef struct {
    gs_sequence_t	cur_mseq, last_mseq;
    UINT16		have_sz;
    gs_sequence_t	have_set[];
}gs_recovery_info_t;

typedef struct {
    gs_sequence_t	down_mseq;
    UINT16		view;
    UINT16		sz;
    struct {
	gs_sequence_t	mseq;
    }skip_set[];
}gs_sync_info_t;

#ifndef min
#define min(a, b)	((a) < (b) ? (a) : (b))
#endif

#define GspValidateView(gd, vn)	((vn) >= (gd)->g_startview && (vn) <= (gd)->g_curview)

NTSTATUS
GspSendRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t ev,
	       int type, gs_sequence_t mid, gs_tag_t tag,
	       PVOID buf, UINT32 len, 
	       PVOID rbuf[], UINT32 rlen,
	       IO_STATUS_BLOCK status[],
	       UINT32 flags, gs_join_info_t *);

void
GspProcessWaitQueue(gs_group_t *gd, gs_seq_info_t *);

void
GspAllocateSequence(gs_group_t *gd);

void
GspCleanQueue(gs_group_t *gd, gs_sequence_t mseq);

void
GspAddMember(gs_group_t *, gs_memberid_t, int);

void
GspPhase1NodeDown(ULONG mask);

void
GspPhase2NodeDown(ULONG mask);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\type.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    type.h

Abstract:

    GS types

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#ifndef GS_TYPE_H
#define GS_TYPE_H

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <Windows.h>
#include <stdlib.h>

typedef UINT32		gs_sequence_t;
typedef CRITICAL_SECTION	gs_lock_t;
typedef HANDLE		gs_semaphore_t;
typedef	ULONG		gs_addr_t;
typedef UINT16		gs_nid_t;
typedef UINT32		gs_gid_t;
typedef HANDLE		gs_event_t;
typedef ULONG		gs_mset_t;
typedef unsigned short UINT16;
typedef UINT16		gs_cookie_t;
typedef UINT16		gs_memberid_t;
typedef unsigned char	UINT8;

#define GsLockInit(x)	InitializeCriticalSection(&x)
#define	GsLockEnter(x)	EnterCriticalSection(&x)
#define	GsLockExit(x)	LeaveCriticalSection(&x)

#define	GsSemaInit(x, cnt)	((x) = CreateSemaphore(NULL, cnt,cnt, NULL))
#define	GsSemaAcquire(x)	WaitForSingleObject(x, INFINITE)
#define	GsSemaRelease(x)	ReleaseSemaphore(x, 1, NULL);
#define	GsSemaFree(x)		CloseHandle(x)

#define	GsManualEventInit(x)	((x) = CreateEvent(NULL, TRUE, FALSE, NULL))
#define	GsEventInit(x)		((x) = CreateEvent(NULL, FALSE, FALSE, NULL))
#define	GsEventWait(x)		WaitForSingleObject(x, INFINITE)
//#define	GsEventWait(x)		WaitForSingleObject(x, 1000*60) != WAIT_OBJECT_0 ? printf("Timed out\n"), halt(0) : 0
#define	GsEventSignal(x)	SetEvent(x)
#define	GsEventClear(x)		ResetEvent(x)
#define	GsEventFree(x)		CloseHandle(x)

#define	GsEventWaitTimeout(a,t) \
(WaitForSingleObject(a, (t)->LowPart) == WAIT_OBJECT_0)

#define	GspAtomicDecrement(x)	InterlockedDecrement((PLONG) &x)

#define	GspAtomicRemoveHead(head, x)	for(x=head; InterlockedCompareExchange((LONG *)&head, (LONG)x, (LONG)x->ctx_next) == (LONG) x;);

#define	GspAtomicInsertHead(head, x)	for(x->ctx_next = head; InterlockedCompareExchange((LONG *)&head, (LONG) x->ctx_next, (LONG)x) != (LONG) x; );

extern void halt(int);

#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\receive.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    Receive handler and sends reply packets

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include "gs.h"
#include "gsp.h"
#include <stdio.h>
#include <assert.h>

void
GspDumpQueue(gs_group_t *gd)
{

	gs_msg_t *q;
	int i = 0;

	for (q = gd->g_recv.r_head; q != NULL; q = q->m_next) {
	    state_log(("Msg %x: nid %d gid %d type %d mseq %d bnum %d flags %x cnt %d\n",
		      q, q->m_hdr.h_sid, q->m_hdr.h_gid, q->m_hdr.h_type,
		      q->m_hdr.h_mseq, q->m_hdr.h_bnum, q->m_hdr.h_flags, q->m_refcnt));
	    
	    i++;
	    if (i > 100) {
		err_log(("Infinite loop\n"));
		halt(1);
	    }
	}
	state_log(("Head %x Next %x expecting <%d, %d.\n",
		  gd->g_recv.r_head,
		  gd->g_recv.r_next,
		  gd->g_recv.r_mseq,
		  gd->g_recv.r_bnum));


}

void
GspRemoveMsg(gs_group_t *gd, gs_msg_t *msg)
{

    gs_msg_t **p;
    gs_msg_t *q;

    gs_log(("Remove gid %d seq %d msg %x\n", gd->g_id,
	      msg->m_hdr.h_mseq, msg));

    GspDumpQueue(gd);

    if (msg->m_hdr.h_flags & GS_FLAGS_QUEUED) {
	while ((q = gd->g_recv.r_head) != msg) {
	    if (q == NULL) {
		err_log(("Internal error: null head during remove %x\n", msg));
		GspDumpQueue(gd);
		halt(1);
		break;
	    }
	    q->m_hdr.h_flags &= ~GS_FLAGS_QUEUED;
	    gd->g_recv.r_head = q->m_next;
	    msg_free(q);
	}
	// delay the freeing of continued messages to simplify recovery
	if (!(msg->m_hdr.h_flags & GS_FLAGS_CONTINUED)) {
	    msg->m_refcnt--;
	    msg->m_hdr.h_flags &= ~GS_FLAGS_QUEUED;
	    gd->g_recv.r_head = msg->m_next;
	    if (&msg->m_next == gd->g_recv.r_next)
		gd->g_recv.r_next = &gd->g_recv.r_head;
	}
    }

    msg_free(msg);

    GspDumpQueue(gd);
}

void
GspCleanQueue(gs_group_t *gd, gs_sequence_t mseq)
{
    gs_msg_t *q, *msg;

    gs_log(("Clean gid %d seq %d\n",  gd->g_id, mseq));

    GspDumpQueue(gd);

    while ((q = gd->g_recv.r_head) != NULL && q->m_hdr.h_mseq < mseq) {
	if (&q->m_next == gd->g_recv.r_next) {
	    gd->g_recv.r_next = &gd->g_recv.r_head;
	}
	q->m_hdr.h_flags &= ~GS_FLAGS_QUEUED;
	gd->g_recv.r_head = q->m_next;
	msg_free(q);
    }

    GspDumpQueue(gd);
}

void
GspUOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t bnum)
{
    gs_msg_t **p;

    // insert msg into proper order in receive queue
    // this routine needs to check for duplicates

    gs_log(("Add ucast gid %d mseq %d,%d head %x tail %x @ next %x\n", 
	      gd->g_id, mseq, bnum,
	      head, tail, gd->g_recv.r_next));

    p = gd->g_recv.r_next;
    while (*p) {
	if ((*p)->m_hdr.h_mseq > mseq) {
	    tail->m_next = *p;
	    *p = head;
	    return;
	}

	p = &(*p)->m_next;
    }

    // add at tail of history queue
    tail->m_next = *p;
    *p = head;

    GspDumpQueue(gd);
}

void
GspOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t bnum)
{
    gs_msg_t **p;

    // check if we have already processed this sequence
    if (mseq < gd->g_recv.r_mseq || (mseq == gd->g_recv.r_mseq && 
	bnum < gd->g_recv.r_bnum)) {
	gs_log(("Droping msg %d,%d @ %d,%d\n", mseq, bnum, 
		gd->g_recv.r_mseq, gd->g_recv.r_bnum));
	msg_free(head);
	return;
    }

    if (head->m_hdr.h_flags & GS_FLAGS_REPLAY) {
	p = &gd->g_recv.r_head;
	while (p != gd->g_recv.r_next && *p != NULL) {
	    if ((*p)->m_hdr.h_mseq == mseq && (*p)->m_hdr.h_bnum == bnum) {
		gs_log(("duplicate pending type %d mseq %d bnum %d\n", 
			head->m_hdr.h_type, mseq, bnum));
		msg_free(head);
		return;
	    }
	}
    }

    // insert msg into proper order in receive queue
    // this routine needs to check for duplicates

    gs_log(("Add gid %d mseq %d,%d head %x tail %x @ next %x\n", 
	      gd->g_id, mseq, bnum,
	      head, tail, gd->g_recv.r_next));

    p = gd->g_recv.r_next;
    while (*p) {
	if ((*p)->m_hdr.h_mseq > mseq ||
	    ((*p)->m_hdr.h_mseq == mseq && (*p)->m_hdr.h_bnum > bnum)) {
	    tail->m_next = *p;
	    *p = head;
	    return;
	} else if ((*p)->m_hdr.h_mseq == mseq && (*p)->m_hdr.h_bnum == bnum) {
	    assert(head->m_hdr.h_flags & GS_FLAGS_REPLAY);
	    assert(head == tail);
	    gs_log(("duplicate type %d mseq %d bnum %d\n", head->m_hdr.h_type,mseq, bnum));
	    msg_free(head);
	    return;
	}

	p = &(*p)->m_next;
    }

    // add at tail of history queue
    tail->m_next = *p;
    *p = head;

    GspDumpQueue(gd);
}

void
GspReplyMsgHandler(gs_msg_t *msg)
{   
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    gs_context_t *ctx;

    hdr = &msg->m_hdr;

   // find group using group internal identifier
    gd = GspLookupGroup(hdr->h_gid);

    GsLockEnter(gd->g_lock);
   // find context in waiting queue
   ctx = GspLookupContext(gd, hdr->h_cid);
   assert(ctx != NULL);
   if (ctx->ctx_msg == NULL) {
       err_log(("Internal error gid %d ctx %d mseq %d bnum %d flags %x mask %x\n",
		ctx->ctx_gid, ctx->ctx_id, ctx->ctx_mseq, ctx->ctx_bnum,
		ctx->ctx_flags, ctx->ctx_mask));
       err_log(("Internal error msg sid %d mid %d gid %d ctx %d mseq %d bnum %d flags %x\n",
		hdr->h_sid, hdr->h_mid,
		hdr->h_gid, hdr->h_cid, hdr->h_mseq, hdr->h_bnum, hdr->h_flags));
       halt(1);
   }
   assert(ctx->ctx_msg != NULL);
   if (ctx->ctx_msg->m_hdr.h_mseq != hdr->h_mseq) {
       err_log(("Internal error ctx %d %d reply %d mismatch %d\n", 
		ctx->ctx_id, hdr->h_cid,
		hdr->h_mseq,
		ctx->ctx_msg->m_hdr.h_mseq));
       halt(1);
   }
   GspProcessReply(gd, ctx, msg->m_hdr.h_sid, msg->m_buf, msg->m_hdr.h_len,
		   *((NTSTATUS *)msg->m_hdr.h_tag));

   GsLockExit(gd->g_lock);

   msg_free(msg);
}

void
GspSendAck(gs_group_t *gd, gs_msg_t *msg, NTSTATUS status)
{
    gs_msg_hdr_t *hdr;

    hdr = &msg->m_hdr;
    if (hdr->h_cid == (gs_cookie_t) -1)
	return;

    gs_log(("Ack nid %d msg %x flags %x\n",hdr->h_sid, msg,
	    msg->m_hdr.h_flags));
    if (hdr->h_sid != gd->g_nid) {
	gs_msg_hdr_t	rhdr;

	memcpy(&rhdr, hdr, sizeof(rhdr));
	rhdr.h_sid = (gs_memberid_t) gd->g_nid;
	rhdr.h_mid = hdr->h_sid;
	rhdr.h_type = GS_MSG_TYPE_ACK;
	rhdr.h_len = 0;
	*((NTSTATUS *)rhdr.h_tag) = status;
	msg_send(hdr->h_sid, &rhdr, NULL, 0);
    } else {
	gs_context_t	*ctx;

	ctx = GspLookupContext(gd, hdr->h_cid);
	GspProcessReply(gd, ctx, gd->g_nid, NULL, 0, status);
    }
}

NTSTATUS
WINAPI
GsSendReply(HANDLE cookie, PVOID buf, int len, NTSTATUS status)
{
    gs_group_t	*gd;
    gs_msg_t *msg = (gs_msg_t *)cookie;
    NTSTATUS err = ERROR_SUCCESS;

    if (msg == NULL || msg->m_hdr.h_rlen < len) 
	return ERROR_INVALID_PARAMETER;

    // find group
    gd = GspLookupGroup(msg->m_hdr.h_gid);

    GsLockEnter(gd->g_lock);
    if (!(msg->m_hdr.h_flags & GS_FLAGS_REPLY) && 
	msg->m_hdr.h_rlen >= len) {
	// mark msg state
	msg->m_hdr.h_flags |= GS_FLAGS_REPLY;
	gs_log(("Reply msg %x flags %x len %x ubuf %x ulen %x\n",msg,
		msg->m_hdr.h_flags, msg->m_hdr.h_rlen, buf, len));
	// local reply
	if (msg->m_hdr.h_sid == gd->g_nid) {
	    gs_context_t *ctx;
	    // find context in waiting queue
	    ctx = GspLookupContext(gd, msg->m_hdr.h_cid);
	    assert(ctx != NULL);
	    assert(ctx->ctx_msg->m_hdr.h_mseq == hdr->h_mseq);

	    GspProcessReply(gd, ctx, msg->m_hdr.h_sid, (char *)buf, len, status);
	} else {
	    gs_msg_hdr_t	rhdr;

	    memcpy(&rhdr, &msg->m_hdr, sizeof(rhdr));
	    rhdr.h_sid = gd->g_nid;
	    rhdr.h_mid = msg->m_hdr.h_sid;
	    rhdr.h_type = GS_MSG_TYPE_REPLY;
	    rhdr.h_len = (UINT16) len;
	    *((NTSTATUS *)rhdr.h_tag) = status;
	    msg_send(rhdr.h_mid, &rhdr, (const char *)buf, len);
	}
	// release msg
	msg_free(msg);
    } else {
	gs_log(("Reply failed %x: flags %x len %x ubuf %x ulen %x\n",msg,
		msg->m_hdr.h_flags, msg->m_hdr.h_rlen, buf, len));
		
	err = ERROR_INVALID_OPERATION;
    }
    GsLockExit(gd->g_lock);
    return err;
}

static gs_eventid_t GsTypeToEventId[] = {
    GsEventInvalid,
    GsEventInvalid,
    GsEventData,
    GsEventInvalid,
    GsEventSingleData,
    GsEventInvalid,
    GsEventInvalid,
    GsEventInvalid,
    GsEventInvalid,
    GsEventMemberJoin,
    GsEventMemberUp,
    GsEventInvalid,
    GsEventMemberEvicted,
    GsEventInvalid,
    GsEventMemberDown
};

#define GsMsgTypeToEventId(x)	(x != GS_MSG_TYPE_ABORT ? GsTypeToEventId[x] : GsEventAbort)

void
GspSyncMember(gs_group_t *gd, gs_memberid_t mid, gs_sequence_t mseq)
{
    gs_msg_t *p;

    // forward all messages that we have sent with higher sequence number
    for (p = gd->g_recv.r_head; p != NULL; p = p->m_next) {
	if (p->m_hdr.h_sid == gd->g_nid && p->m_hdr.h_mseq > mseq &&
	    p->m_hdr.h_type != GS_MSG_TYPE_UCAST) {
	    gs_context_t *ctx = &gd->g_send.s_ctxpool[p->m_hdr.h_cid];

	    assert(ctx->ctx_msg == p);
	    if (!(ctx->ctx_mask & (1 << mid))) {
		recovery_log(("sync node %d mseq %d\n", mid, p->m_hdr.h_mseq));
		ctx->ctx_mask |= (1 << mid);
		msg_send(mid, &p->m_hdr, p->m_buf, p->m_hdr.h_len);
	    }
	}
    }
}
    
void
GspDeliverMsg(gs_group_t *gd, gs_msg_t *msg)
{
    IO_STATUS_BLOCK ios;
    NTSTATUS status;
    gs_memberid_t mid;

    switch(msg->m_hdr.h_type) {
    case GS_MSG_TYPE_UP:
	mid = *((gs_memberid_t *)msg->m_hdr.h_tag);
	GspAddMember(gd, mid, *(int *)msg->m_buf);
	GspSyncMember(gd, mid, msg->m_hdr.h_mseq);
	recovery_log(("New membership gid %d view %d,%d sz %d set %x\n", 
		  gd->g_id,
		  gd->g_startview, gd->g_curview, gd->g_sz, gd->g_mset));
	break;
    default:
	break;
    }

    // hold msg
    msg->m_refcnt++;

    GsLockExit(gd->g_lock);

    ios.Status = GsMsgTypeToEventId(msg->m_hdr.h_type);
    ios.Information = msg->m_hdr.h_len;

    status = gd->g_callback((HANDLE)msg, msg->m_hdr.h_tag, msg->m_buf, &ios);

    GsLockEnter(gd->g_lock);

    if (status == STATUS_PENDING) {
	gs_log(("Reply msg pending %x\n", msg));
	return;
    }

    if (!(msg->m_hdr.h_flags & GS_FLAGS_REPLY)) {
	msg->m_hdr.h_flags |= GS_FLAGS_REPLY;
//	*((NTSTATUS *)msg->m_hdr.h_tag) = status;
	// release msg
	msg->m_refcnt--;
	GspSendAck(gd, msg, status);
    }

    if (msg->m_hdr.h_type == GS_MSG_TYPE_UCAST) {
	msg->m_refcnt++;
	msg->m_hdr.h_flags &= ~GS_FLAGS_CONTINUED;
	GspRemoveMsg(gd, msg);
    }

}

void
GspDispatch(gs_group_t *gd)
{
    gs_msg_t	*msg;

    assert(gd->g_recv.r_next != NULL);
    while (gd->g_pending == 0 && (msg = *(gd->g_recv.r_next)) != NULL) {
	int hit = FALSE;
	int flags;

	if (msg->m_hdr.h_type != GS_MSG_TYPE_UCAST) {
	    // compare sequence numbers
	    if (gd->g_recv.r_mseq == msg->m_hdr.h_mseq &&
		gd->g_recv.r_bnum == msg->m_hdr.h_bnum) {
		// got it
		hit = TRUE;
	    }
	} else {
	    // compare sequence numbers
	    if (gd->g_recv.r_mseq >= msg->m_hdr.h_mseq) {
		// got it
		hit = TRUE;
	    }
	}	    

	if (hit == FALSE) {
	    break;
	}
	gd->g_pending = 1;

	msg->m_hdr.h_flags &= ~GS_FLAGS_REPLY;
	flags = msg->m_hdr.h_flags;

	gs_log(("dispatch seq <%d, %d> flags %x msg %x @ next %x\n", 
		msg->m_hdr.h_mseq,
		msg->m_hdr.h_bnum,
		flags, msg, gd->g_recv.r_next));

	// advance next msg to deliver
	gd->g_recv.r_next = &msg->m_next;

	// don't touch msg beyond this point, it may get freed as part of delivery
	if (msg->m_hdr.h_type != GS_MSG_TYPE_SKIP) {
	    GspDeliverMsg(gd, msg);
	}

	// if a continued msg don't advance mseq/bnum
	if (!(flags & GS_FLAGS_CONTINUED)) {
	    if (flags & GS_FLAGS_LAST) {
		gd->g_recv.r_bnum = 0;
		gd->g_recv.r_mseq++;
	    } else if (!(flags & GS_FLAGS_PTP)) {
		gd->g_recv.r_bnum += (1 << 16);
	    }
	} else if (!(flags & GS_FLAGS_PTP)) {
		gd->g_recv.r_bnum++;
	}

	gd->g_pending = 0;
    }
    
    gs_log(("waiting gid %d expect <%d, %d>\n", 
	      gd->g_id, gd->g_recv.r_mseq, gd->g_recv.r_bnum));

    GspDumpQueue(gd);
}

#if 0

WINAPI
GsReceiveRequest(gd, buf, len, ios)
{   
    GsLockEnter(gd->recv_lock);   
    m = gd->recv_last;
    // advance receive window    
    if (m && m->state == MSG_STATE_DELIVERED) {
        if (m->flags & GS_FLAGS_DELIVERED) {
	    msg_send_reply(m->srcid, m->mseq, m->cseq..);
	    m->reply = 1;
	}
	m->state = MSG_STATE_DONE;
	// check if this msg can be freed before moving to next one
	m = m->next;
    }    
    if (m && m->state == MSG_STATE_READY) {
	m->state = MSG_STATE_DELIVERED;
	GsLockExit(gd->recv_lock);
	memcpy(buf, m->data, m->len);
	Ios->status = m->srcid;
	Ios->information = m->len;
	Return SUCCESS;
    }
    // queue request 
    irp->next = gd->recv_pending_queue;
    gd->recv_pending_queue = irp;
    GsLockExit(gd->recv_lock); 
    Return PENDING;
}

#endif


void
GspMcastMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && GspValidateView(gd, msg->m_hdr.h_viewnum)) {
	gs_sequence_t lseq = msg->m_hdr.h_lseq;

	GsLockEnter(gd->g_lock);
	hdr->h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspOrderInsert(gd, msg, msg, hdr->h_mseq, hdr->h_bnum);  
	GspDispatch(gd);
	GspCleanQueue(gd, lseq);
	GsLockExit(gd->g_lock);
    } else {
	msg_free(msg);
    }
}

void
GspUcastMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    if (gd && GspValidateView(gd, msg->m_hdr.h_viewnum)) {
	gs_sequence_t lseq = msg->m_hdr.h_lseq;

	GsLockEnter(gd->g_lock);

	hdr->h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspUOrderInsert(gd, msg, msg, hdr->h_mseq, hdr->h_bnum);  
	GspDispatch(gd);  
	GspCleanQueue(gd, lseq);
	GsLockExit(gd->g_lock);
    } else {
	gs_log(("Dropping ucast: gid %d nid %d mseq %d view %d\n", hdr->h_gid,
		hdr->h_mid, hdr->h_mseq, hdr->h_viewnum));
	msg_free(msg);
    }
}

void
GspSeqAllocMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_seq_info_t info;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    if (gd) {

	GsLockEnter(gd->g_lock);
	info.mseq = gd->g_global_seq++;
	info.viewnum = gd->g_curview;
	GsLockExit(gd->g_lock);


	hdr->h_mid = hdr->h_sid;
	hdr->h_sid = gd->g_nid;
	hdr->h_type = GS_MSG_TYPE_SEQREPLY;
	hdr->h_len = sizeof(info);

	gs_log(("SeqAlloc: nid %d mseq %d view %d\n",
		hdr->h_mid, info.mseq, info.viewnum));

	msg_send(hdr->h_mid, hdr, (char *) &info, sizeof(info));
    }

    msg_free(msg);

}

void
GspSeqReplyMsgHandler(gs_msg_t *msg)
{   
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    gs_context_t *ctx;

    hdr = &msg->m_hdr;

    assert(hdr->h_len == sizeof(gs_seq_info_t));

   // find group using group internal identifier
    gd = GspLookupGroup(hdr->h_gid);
    if (gd != NULL && GspValidateView(gd, hdr->h_viewnum)) {
	gs_seq_info_t *info = (gs_seq_info_t *)msg->m_buf;
	GsLockEnter(gd->g_lock);
	if (GspValidateView(gd, info->viewnum) && hdr->h_sid == gd->g_mid) {
	    GspProcessWaitQueue(gd, info);
	}
	GsLockExit(gd->g_lock);
    }

   msg_free(msg);
}

void
GspJoinRequestMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_join_info_t info;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    if (gd) {

	GsLockEnter(gd->g_lock);
	info.mseq = gd->g_global_seq++;
	info.viewnum = gd->g_curview;
	info.mset = gd->g_mset;
	info.sz = gd->g_sz;
	GsLockExit(gd->g_lock);


	hdr->h_mid = hdr->h_sid;
	hdr->h_sid = gd->g_nid;
	hdr->h_type = GS_MSG_TYPE_REPLY;
	hdr->h_len = sizeof(info);

	msg_send(hdr->h_mid, hdr, (char *) &info, sizeof(info));
    }

    msg_free(msg);

}

void
GspJoinUpMsgHandler(gs_msg_t *msg)
{
    gs_group_t	*gd;
    gs_msg_hdr_t *hdr;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && GspValidateView(gd, msg->m_hdr.h_viewnum)) {
	GsLockEnter(gd->g_lock);
	hdr->h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspOrderInsert(gd, msg, msg, hdr->h_mseq, hdr->h_bnum);  
	GspDispatch(gd);
	GsLockExit(gd->g_lock);
    } else {
	msg_free(msg);
    }
}

void GspInfoMsgHandler(gs_msg_t *);
void GspMmMsgHandler(gs_msg_t *);
void GspRecoveryMsgHandler(gs_msg_t *);
void GspSyncMsgHandler(gs_msg_t *);

gs_msg_handler_t gs_msg_handler[] = {
    GspSeqAllocMsgHandler,
    GspSeqReplyMsgHandler,
    GspMcastMsgHandler,
    GspReplyMsgHandler,
    GspUcastMsgHandler,
    GspReplyMsgHandler,
    GspInfoMsgHandler,
    GspMmMsgHandler,
    GspJoinRequestMsgHandler,
    GspJoinUpMsgHandler, // join
    GspJoinUpMsgHandler, // up
    NULL, // evict request
    NULL, // evict
    GspRecoveryMsgHandler,
    GspSyncMsgHandler
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\gumevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gumevent.c

Abstract:

    Cluster event handling routines for the Global Update Manager

Author:

    John Vert (jvert) 22-Apr-1996

Revision History:

--*/
#include "gump.h"
#include <bitset.h>

//
// Event handling is divided into two parts, sync and async. The sync
// part is executed by all nodes during phase 4 cleanup of the regroup.
// The sync handler must be very fast, since we run in the context of
// of the regroup thread.
//
// The async part is executed as a work thread and we finish handling
// nodes down event.

//
// Flag to denote if we need to replay the last update in the async.
// event handler.
static BOOL GumReplay = FALSE;
//
// Flag to denote if we are in the middle of a dispatch
// 
static BOOL GumUpdatePending = FALSE;

//
// Node generation number stuff
//
static DWORD GumNodeGeneration[ClusterMinNodeId + ClusterDefaultMaxNodes] = {0};

DWORD
GumpGetNodeGenNum(PGUM_INFO GumInfo, DWORD NodeId)
/*++

Routine Description:

    
    Return current generation number for specified node. If node is already dead,
    we return the previous generation number so that furture calls to
    gumwaitnodedown, gumdispatchstart, gumdispatchend fail without checking if
    the node is alive or dead.

Arguments:

    NodeId - Node number

Return Value:

    Node's current generation number

--*/
{
    DWORD dwCur;

    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    dwCur = GumNodeGeneration[NodeId];
    if (GumInfo->ActiveNode[NodeId] == FALSE) {
        //
        // Node is already dead, return previous sequence number
        //
        dwCur--;
    }
    LeaveCriticalSection(&GumpLock);

    return (dwCur);
}

void
GumpWaitNodeDown(DWORD NodeId, DWORD Gennum)
/*++

Routine Description:

    Wait till specified node has transitioned into down event.
    

Arguments:

    NodeId - node id 

    Gennum - node's generation number before down event

Return Value:

    ERROR_SUCCESS

--*/
{
    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    if (Gennum != GumNodeGeneration[NodeId]) {
        LeaveCriticalSection(&GumpLock);
        return;
    }

    //
    // Increment the waiter count, then go wait on the semaphore.
    //
    ++GumNodeWait[NodeId].WaiterCount;
    LeaveCriticalSection(&GumpLock);
    WaitForSingleObject(GumNodeWait[NodeId].hSemaphore, INFINITE);
}

BOOL
GumpDispatchStart(DWORD NodeId, DWORD Gennum)
/*++

Routine Description:

    Mark start of a dispatch. If the generation number supplied is
    old, we fail the dispatch since the node has transitioned.
    

Arguments:

    NodeId - node id 

    Gennum - node's generation number before down event

Return Value:

    TRUE - node state is fine, go ahead with dispatch

    FLASE - node has transitioned, abort dispatch

--*/
{
    //
    // If the sequence number has changed return False, else
    // return true.

    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    if (Gennum != GumNodeGeneration[NodeId]) {
        LeaveCriticalSection(&GumpLock);
        return (FALSE);
    }
    
    //
    // Signal that we are in the middle of an update
    //
    GumUpdatePending = TRUE;
    LeaveCriticalSection(&GumpLock);

    return (TRUE);
}

void
GumpDispatchAbort()
/*++

Routine Description:

    Abort and mark end of current dispatch. Just reset the pending flag.
    This is used when the dispatch routine failed, and we don't need to
    replay it for other nodes.

Arguments:

    none

Return Value:

    none

--*/
{
    EnterCriticalSection(&GumpLock);
    GumUpdatePending = FALSE;
    LeaveCriticalSection(&GumpLock);
}
  
void
GumpDispatchEnd(DWORD NodeId, DWORD Gennum)
/*++

Routine Description:

    Mark end of a dispatch. If the generation number supplied is
    old and we need to reapply update, we replay update for
    other nodes.
    

Arguments:

    NodeId - node id 

    Gennum - node's generation number before down event

Return Value:

    none

--*/
{
    //
    // If the sequence number has changed while the
    // update was happening, we need to replay it

    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    GumUpdatePending = FALSE;
    if (Gennum != GumNodeGeneration[NodeId] && GumReplay) {
        GumReplay = FALSE;
	LeaveCriticalSection(&GumpLock);
        GumpReUpdate(GumpLastUpdateType, NmLocalNodeId);
    } else {
        LeaveCriticalSection(&GumpLock);
    }
}

DWORD
WINAPI
GumpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes nodes down cluster events. Replay last update and wake up
    any pending threads.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/

{
    BITSET DownedNodes = (BITSET)((ULONG_PTR)Context);
    DWORD NodeId;


    if (Event != CLUSTER_EVENT_NODE_DOWN_EX) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(BitsetIsNotMember(NmLocalNodeId, DownedNodes));

    EnterCriticalSection(&GumpLock);

    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Nodes down: %1!04X!. Locker=%2!u!, Locking=%3!d!\n",
        DownedNodes,
        GumpLockerNode,
        GumpLockingNode
        );

    //
    //since all gum updates are synchronized and the last buffer
    //and last update type are shared across all updates, we dont have
    //to reissue the update for all types, only for the last update type.
    //SS: note we we use the last GumInfo structure for now since GumInfo
    //structures are still maintained for everygum update type

    if ( GumReplay && GumUpdatePending == FALSE)
    {
        // XXX: These should be if statements and panic this node instead.
        CL_ASSERT(GumpLockerNode == NmLocalNodeId);
        CL_ASSERT(GumpLockingNode == NmLocalNodeId);
	  
        GumReplay = FALSE;
    	LeaveCriticalSection(&GumpLock);
        GumpReUpdate(GumpLastUpdateType, NmLocalNodeId);
    } else {
        LeaveCriticalSection(&GumpLock);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Node down processing completed: %1!04X!.\n",
        DownedNodes
        );

    return(ERROR_SUCCESS);
}

DWORD
WINAPI
GumpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes nodes down cluster events. Update locker/locking nodes
    state and decide if we need to replay last update in async handler.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/

{
    BITSET DownedNodes = (BITSET)((ULONG_PTR)Context);
    DWORD NodeId;


    if (Event != CLUSTER_EVENT_NODE_DOWN_EX) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(BitsetIsNotMember(NmLocalNodeId, DownedNodes));

    EnterCriticalSection(&GumpLock);

    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Sync Nodes down: %1!04X!. Locker=%2!u!, Locking=%3!d!\n",
        DownedNodes,
        GumpLockerNode,
        GumpLockingNode
        );

    //
    // remove downed nodes from any further GUM updates
    //
    for(NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) {
       if (BitsetIsMember(NodeId, DownedNodes))
       {
           GUM_UPDATE_TYPE UpdateType;

           for (UpdateType = 0; UpdateType < GumUpdateMaximum; UpdateType++)
           {
               GumTable[UpdateType].ActiveNode[NodeId] = FALSE;
           }

	   //
	   // Advance node generation number
	   //
	   GumNodeGeneration[NodeId]++;
       }
    }

    //
    // Update LockerNode/LockingNode if necessary
    //
    //since all gum updates are synchronized and the last buffer
    //and last update type are shared across all updates, we dont have
    //to reissue the update for all types, only for the last update type.
    //SS: note we we use the last GumInfo structure for now since GumInfo
    //structures are still maintained for everygum update type

    if ( (GumpLockerNode == NmLocalNodeId) &&
         (BitsetIsMember(GumpLockingNode, DownedNodes)) )
    {

        //
        // This node is the locker and the lock is currently held
        // by one of the failed nodes. Take ownership of the lock and
        // reissue the update to all remaining nodes.
        //
        EnterCriticalSection(&GumpUpdateLock);
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpEventHandler taking ownership of the lock from the node %1!d!.\n",
                   GumpLockingNode
                   );
        GumpLockingNode = NmLocalNodeId;
        LeaveCriticalSection(&GumpUpdateLock);
	//
	// Reissue update in async phase.
	//
        GumReplay = TRUE;
    }
    else if ( BitsetIsMember(GumpLockerNode, DownedNodes) )
    {

        //
        // One of the failed nodes was the locker node, so select a new
        // locker node now.
        //
        // Find the node with the next ID after the previous locker node.
        //
        DWORD j;
        for (j=GumpLockerNode+1; j != GumpLockerNode; j++) {
            if (j==(NmMaxNodeId+1)) {
                j = ClusterMinNodeId;
                CL_ASSERT(j != GumpLockerNode);
            }
            if (GumTable[0].ActiveNode[j]) {
                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumpEventHandler New Locker node is node %1!d!\n",
                           j);
                GumpLockerNode = j;
                break;
            }
        }

        //
        // If this node has been promoted to be the new locker node,
        // reissue the last update we saw.
        //
        if (GumpLockerNode == NmLocalNodeId)
        {
            //
            // Manually acquire the lock here. The update has already
            // been issued on this node.
            //
            EnterCriticalSection(&GumpUpdateLock);

            CL_ASSERT(GumpLockingNode == (DWORD)-1);
            GumpLockingNode = NmLocalNodeId;
            LeaveCriticalSection(&GumpUpdateLock);

            //
            // Reissue update in async phase.
            //
            GumReplay = TRUE;
        }
    }

    //
    // Wake any threads waiting for the nodes to transition to down.
    //
    for(NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) {
       if (BitsetIsMember(NodeId, DownedNodes))
       {
           if (GumNodeWait[NodeId].WaiterCount != 0) {
               ReleaseSemaphore(GumNodeWait[NodeId].hSemaphore,
                                GumNodeWait[NodeId].WaiterCount,
                                NULL);
               GumNodeWait[NodeId].WaiterCount = 0;
           }
       }
    }


    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Sync Nodes down processing completed: %1!04X!.\n",
        DownedNodes
        );

    LeaveCriticalSection(&GumpLock);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\gump.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gump.h

Abstract:

    Private header file for the Global Update Manager (GUM) component
    of the NT Cluster Service

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_GUM

//
//
// Structures and type definitions local to the GUM
//
typedef struct _GUM_RECEIVER {
    struct _GUM_RECEIVER *Next;
    PGUM_UPDATE_ROUTINE UpdateRoutine;
    PGUM_LOG_ROUTINE    LogRoutine;
    DWORD               DispatchCount;
    PGUM_DISPATCH_ENTRY DispatchTable;
    PGUM_VOTE_ROUTINE   VoteRoutine;
} GUM_RECEIVER, *PGUM_RECEIVER;

typedef struct _GUM_INFO {
    PGUM_RECEIVER Receivers;
    BOOL Joined;
    BOOL ActiveNode[ClusterMinNodeId + ClusterDefaultMaxNodes];
} GUM_INFO, *PGUM_INFO;

extern GUM_INFO GumTable[GumUpdateMaximum];
extern CRITICAL_SECTION GumpLock;

extern DWORD GumpSequence;
extern CRITICAL_SECTION GumpUpdateLock;
extern CRITICAL_SECTION GumpSendUpdateLock;
extern CRITICAL_SECTION GumpRpcLock;
extern PVOID GumpLastBuffer;
extern DWORD GumpLastContext;
extern DWORD GumpLastBufferLength;
extern DWORD GumpLastUpdateType;
extern LIST_ENTRY GumpLockQueue;
extern DWORD GumpLockingNode;
extern DWORD GumpLockerNode;
extern BOOL  GumpLastBufferValid;
extern RPC_BINDING_HANDLE GumpRpcBindings[
                              ClusterMinNodeId + ClusterDefaultMaxNodes
                              ];
extern RPC_BINDING_HANDLE GumpReplayRpcBindings[
                              ClusterMinNodeId + ClusterDefaultMaxNodes
                              ];

//
// structure used to allow GUM clients to wait for
// a node to transition from active to inactive.
// Waited on by GumpCommFailure.
// Set by GumpEventHandler.
// All access to WaiterCount should be serialized by
// GumpLock
//
typedef struct _GUM_NODE_WAIT {
    DWORD WaiterCount;
    HANDLE hSemaphore;
} GUM_NODE_WAIT, *PGUM_NODE_WAIT;

extern GUM_NODE_WAIT GumNodeWait[ClusterMinNodeId + ClusterDefaultMaxNodes];

//
// Define structure used for enqueuing waiters for the GUM lock.
//
#define GUM_WAIT_SYNC   0
#define GUM_WAIT_ASYNC  1

typedef struct _GUM_WAITER {
    LIST_ENTRY ListEntry;
    DWORD WaitType;
    DWORD NodeId;
    union {
        struct {
            HANDLE WakeEvent;
        } Sync;
        struct {
            DWORD Context;
            DWORD BufferLength;
            DWORD BufferPtr;
            PUCHAR Buffer;
        } Async;
    };
} GUM_WAITER, *PGUM_WAITER;

//
// Private GUM routines
//
DWORD
WINAPI
GumpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
WINAPI
GumpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
WINAPI
GumpDispatchUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Context,
    IN BOOL IsLocker,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PUCHAR Buffer
    );

//
// Node Generation Numbers
//
DWORD
GumpGetNodeGenNum(PGUM_INFO GumInfo, DWORD NodeId);

void
GumpWaitNodeDown(DWORD NodeId, DWORD gennum);

BOOL
GumpDispatchStart(DWORD NodeId, DWORD gennum);

void
GumpDispatchEnd(DWORD NodeId, DWORD gennum);

void
GumpDispatchAbort();

//
// Macros to serialize usage of RPC handles. We don't use one lock per node
// because a new sender might grap the RPC to new locker and previous sender
// wants handle to send update. But previous sender owns updatelock and we
// will deadlock. So, we just keep things simple for now and use one lock
// to serialize all RPC calls.
//
#define GumpStartRpc(nodeid)	EnterCriticalSection(&GumpRpcLock)
#define	GumpEndRpc(nodeid)	LeaveCriticalSection(&GumpRpcLock)

//
// Locker interface
//

VOID
GumpPromoteToLocker(
    VOID
    );

DWORD
GumpDoLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    OUT LPDWORD Sequence
    );

DWORD
GumpDoLockingPost(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    OUT LPDWORD Sequence,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN DWORD BufferPtr,
    IN UCHAR Buffer[]
    );

VOID
GumpDeliverPosts(
    IN DWORD FirstNodeId,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Sequence,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer                 // THIS WILL BE FREED
    );

VOID
GumpDoUnlockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Sequence
    );

BOOL
GumpTryLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    IN DWORD Sequence
    );

VOID
GumpReUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD EndId
    );

VOID
GumpCommFailure(
    IN PGUM_INFO GumInfo,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    );

//internal routines for dispatching collection of votes
DWORD GumpCollectVotes(
    IN PGUM_VOTE_DECISION_CONTEXT   pVoteContext,
    IN  DWORD                       dwVoteBufSize,
    OUT PBYTE                       pVoteBuffer,
    OUT LPDWORD                     pdwNumVotes,
    OUT BOOL                        *pbDidAllActiveNodesVote
);


DWORD
WINAPI
GumpDispatchVote(
    IN  GUM_UPDATE_TYPE  Type,
    IN  DWORD            Context,
    IN  DWORD            dwInputBufLength,
    IN  PUCHAR           pInputBuf,
    IN  DWORD            dwVoteLength,
    OUT PUCHAR           pVoteBuf
);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\send.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Send packets

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include <stdio.h>


void
GspOpenContext(gs_group_t *gd, gs_context_t **context)
{    
    gs_context_t *ctx;
    int i;

    gs_log(("wait on free ctx gid %d\n", gd->g_id));

    GsSemaAcquire(gd->g_send.s_sema);    
    //xxx: this can be done using atomic instruction
    GsLockEnter(gd->g_lock);
    for (i = 0; i < gd->g_send.s_wsz; i++) {
	ctx = &gd->g_send.s_ctxpool[i];
	if (ctx->ctx_id == GS_CONTEXT_INVALID_ID) {
	    break;
	}
    }
    assert(i != gd->g_send.s_wsz);
    
    ctx->ctx_id = (gs_cookie_t) i;
    ctx->ctx_bnum = 0;

    GsLockExit(gd->g_lock);

    gs_log(("got free ctx %d gid %d\n", i, gd->g_id));
    *context = ctx;
}

void
GspCloseContext(gs_group_t *gd, gs_context_t *ctx)
{

    gs_msg_t *msg;

    assert(gd->g_id == ctx->ctx_gid);

    gs_log(("release ctx %d gid %d\n", ctx->ctx_id, gd->g_id));

    // free/invalidate context
    ctx->ctx_id = GS_CONTEXT_INVALID_ID;

    GsSemaRelease(gd->g_send.s_sema);
}

void CALLBACK timercallback(UINT id, UINT xxmsg, DWORD_PTR data, DWORD dw1, DWORD dw2)
{
    gs_context_t *ctx = (gs_context_t *) data;
    gs_group_t *gd;
    gs_msg_t *msg;

    msg = ctx->ctx_msg;
    if (msg == NULL) {
	return;
    }
    gd = GspLookupGroup(ctx->ctx_gid);
    assert(gd != NULL);
    // resend msg
    GsLockEnter(gd->g_lock);
    msg = ctx->ctx_msg;
    if (msg != NULL) {
	ULONG mask = ctx->ctx_mask;
	gs_memberid_t id;

	// send a reliable point-to-point to non-response nodes
	gs_log(("Timercallback mset %x\n", mask));
	msg->m_hdr.h_flags |= GS_FLAGS_REPLAY;
	for (id = 1; mask; id++, mask = mask >> 1) {
	    if (mask & 0x2) {
		msg_mcast(id, &msg->m_hdr, ctx->ctx_buf, msg->m_hdr.h_len);
	    }
	}
    }
    GsLockExit(gd->g_lock);

}

void
GspProcessReply(gs_group_t *gd, gs_context_t *ctx, int sid, char *buf, int rlen,
		NTSTATUS status)
{
    gs_msg_t	*msg;
    int		ctx_rlen;
    IO_STATUS_BLOCK *ios = ctx->ctx_ios;

    msg = ctx->ctx_msg;
    if (msg == NULL) {
	err_log(("Error invalid msg in ctx %d, gid %d\n", ctx->ctx_id, gd->g_id));
	GsEventSignal(ctx->ctx_event);
	//xxx: for debugging
	halt(0);
	return;
    }

   if (rlen > 0) {
       PVOID *p = ctx->ctx_rbuf;
 
       rlen = min(rlen , msg->m_hdr.h_rlen);
       if (p != NULL) {
	   if (msg->m_hdr.h_type == GS_MSG_TYPE_MCAST) {
	       p += (sid - 1);
	       ios += (sid - 1);
	   }

	   memcpy(*p, buf, rlen);
       }

   } else if (msg->m_hdr.h_type == GS_MSG_TYPE_MCAST) {
       ios += (sid - 1);
   }
   ios->Status = status;
   ios->Information = rlen;

   ctx->ctx_mask &= ~(1 << sid);

   gs_log(("process reply len %d gid %d cid %d nid %d mseq %d sz %d mask %x ios %x\n", 
	     rlen, gd->g_id, ctx->ctx_id,
	     sid, msg->m_hdr.h_mseq, msg->m_hdr.h_rlen, ctx->ctx_mask, ios));

   if (ctx->ctx_mask == 0) {
       gs_event_t ev = ctx->ctx_event;

       if (ctx->ctx_timer) {
	   timeKillEvent(ctx->ctx_timer);
	   ctx->ctx_timer = 0;
       }

       ctx->ctx_msg = NULL;
       gd->g_send.s_lseq = msg->m_hdr.h_mseq;
       // free msg and signal waiter
       GspRemoveMsg(gd, msg);
#if 0
       if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	   GspCloseContext(gd, ctx);
       }
#endif
       if (ev) {
	   gs_log(("Signal ctx %d\n", ctx->ctx_id));
	   GsEventSignal(ev);
       }
   } else {
       gs_log(("Waiting for more replies %x\n", ctx->ctx_mask));
       // place ctx into timer queue if we haven't already done so
       if (sid == (int)gd->g_nid) {
	   ctx->ctx_timer = timeSetEvent(500, 0, (LPTIMECALLBACK)timercallback,
					 (DWORD_PTR)ctx, TIME_ONESHOT);
	   if (ctx->ctx_timer == 0) {
	       printf("Unable to create timer %d\n", GetLastError());
	   }
       }
   }
}

void
GspProcessWaitQueue(gs_group_t *gd, gs_seq_info_t *info)
{
    int i;
    gs_msg_t	*last, *cur;
    gs_send_state_t *ss;

    gs_log(("Process wait queue mid %d mseq %d view %d\n", 
	    gd->g_mid, info->mseq, info->viewnum));

    ss = &gd->g_send;
    
    // sequence all ready requests
    cur = ss->s_waitqueue;
    if (cur == NULL) {
	err_log(("Gid %d Empty wait queue!\n", gd->g_id));
	halt(1);
    }

    for (i = 0;  cur != NULL; i++) {
	cur->m_hdr.h_mseq = info->mseq;
	cur->m_hdr.h_bnum = i * (1 << 16);
	cur->m_hdr.h_mid = gd->g_mid;
	cur->m_hdr.h_viewnum = info->viewnum;
	// piggyback our receive state
	cur->m_hdr.h_lseq = gd->g_send.s_lseq;
	if (cur->m_next == NULL) {
	    cur->m_hdr.h_flags |= GS_FLAGS_LAST;
	}
	msg_mcast(gd->g_mset, &cur->m_hdr, cur->m_buf, cur->m_hdr.h_len);

	{
	    gs_context_t *sc;

	    sc = &ss->s_ctxpool[cur->m_hdr.h_cid];
	    sc->ctx_mseq = cur->m_hdr.h_mseq;
	    sc->ctx_bnum = cur->m_hdr.h_bnum + 1;
	    sc->ctx_flags = cur->m_hdr.h_flags;
	}


	last = cur;
	cur = cur->m_next;
    }
    // Insert waitqueue into receive side queue
    cur = ss->s_waitqueue;
    ss->s_waitqueue = NULL;  
    ss->s_mseq = info->mseq+1;
    ss->s_bnum = 0;

    GspOrderInsert(gd, cur, last, info->mseq, 0);

    GspDispatch(gd);

}

void
GspAllocateSequence(gs_group_t *gd)
{

    gs_seq_info_t info;
    gs_msg_t msg;

    assert(gd->g_send.s_waitqueue != NULL);

    if (gd->g_mid == gd->g_nid) {
	info.mseq = gd->g_global_seq++;
	info.viewnum = gd->g_curview;
	GspProcessWaitQueue(gd, &info);
    } else {
	// remote case

	gs_log(("Allocate a seq from mid %x view %d,%d\n", gd->g_mid,
		gd->g_startview, gd->g_curview));

	msg.m_hdr.h_len = 0;
	msg.m_hdr.h_type = GS_MSG_TYPE_SEQALLOC;
	msg.m_hdr.h_flags = GS_FLAGS_PTP;
	msg.m_hdr.h_viewnum = gd->g_curview;
	msg.m_hdr.h_rlen = sizeof(info);
	msg.m_hdr.h_cid = 0;
	msg.m_hdr.h_gid = gd->g_id;
	msg.m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
	msg.m_hdr.h_mid = gd->g_mid;

	msg.m_hdr.h_mseq = gd->g_send.s_mseq;
	msg.m_hdr.h_lseq = gd->g_send.s_lseq;
	msg.m_hdr.h_bnum = 0;
	memset(msg.m_hdr.h_tag, 0, sizeof(msg.m_hdr.h_tag));

	msg_send(gd->g_mid, &msg.m_hdr, NULL, 0);
    }

}
	
NTSTATUS
WINAPI
GsSendDeliveredRequest(HANDLE group, gs_event_t event OPTIONAL,
		       gs_tag_t tag, PVOID buf, UINT32 len, 
		       PVOID rbuf[], UINT32 rlen,
		       IO_STATUS_BLOCK ios[],
		       HANDLE *context)
{
    gs_context_t *ctx;
    gs_group_t *gd = (gs_group_t *)group;
    gs_send_state_t *ss;
    BOOLEAN flag;
    gs_msg_t *msg;

    if (gd == NULL || ios == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    GspOpenContext(gd, &ctx);
    ctx->ctx_flags = GS_FLAGS_DELIVERED;
    if (context != NULL) {
	ctx->ctx_flags |= GS_FLAGS_CONTINUED;
	*context = ctx;
    } else {
	ctx->ctx_flags |= GS_FLAGS_CLOSE;
    }
    ctx->ctx_buf = buf; 
    ctx->ctx_rbuf = rbuf; 
    ctx->ctx_ios = ios;
    if (event == NULL)
	event = ctx->ctx_syncevent;
    ctx->ctx_event = event;
    
    msg = msg_alloc(buf, len);

    assert(msg != NULL);

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = GS_MSG_TYPE_MCAST;
    msg->m_hdr.h_flags = ctx->ctx_flags | GS_FLAGS_QUEUED;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));

    ss = &gd->g_send;

    // place context into readylist
    GsLockEnter(gd->g_lock);
    flag = ss->s_waitqueue == NULL ? TRUE : FALSE; 
    msg->m_next = ss->s_waitqueue;
    ss->s_waitqueue = msg;

    ctx->ctx_mask = gd->g_mset;
    ctx->ctx_msg = msg;
    msg->m_refcnt++;

    // check if we have already asked for a global sequence number
    if (flag == TRUE)  {
	GspAllocateSequence(gd);
    }
    
    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (event) {
	gs_log(("Wait on event %x\n", event));
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }

    return ERROR_SUCCESS;
}

NTSTATUS
GsSendContinuedRequest(HANDLE context, gs_event_t event OPTIONAL,
		       gs_tag_t tag, PVOID buf, UINT32 len, 
		       PVOID rbuf[], UINT32 rlen,
		       IO_STATUS_BLOCK ios[],
		       BOOLEAN close)
{
    gs_context_t *ctx = (gs_context_t *) context;
    gs_group_t *gd;
    gs_send_state_t *ss;
    BOOLEAN flag;
    gs_msg_t *msg;

    if (ctx == NULL || ios == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    if (rbuf == NULL && rlen > 0) {
	return ERROR_INVALID_PARAMETER;
    }
    if (buf == NULL && len > 0) {
	return ERROR_INVALID_PARAMETER;
    }

    gd = GspLookupGroup(ctx->ctx_gid);
    assert(gd != NULL);

    msg = msg_alloc(buf, len);
    assert(msg != NULL);

    if (close == TRUE) {
	ctx->ctx_flags &= ~GS_FLAGS_CONTINUED;
	ctx->ctx_flags |= GS_FLAGS_CLOSE;
    }
    if (event == NULL)
	event = ctx->ctx_syncevent;
    ctx->ctx_event = event;

    ctx->ctx_buf = buf; 
    ctx->ctx_rbuf = rbuf; 
    ctx->ctx_ios = ios;
    ctx->ctx_msg = msg;

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = GS_MSG_TYPE_MCAST;
    msg->m_hdr.h_flags = ctx->ctx_flags | GS_FLAGS_QUEUED;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = gd->g_nid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));
    msg->m_hdr.h_mseq = ctx->ctx_mseq;
    msg->m_hdr.h_bnum = ctx->ctx_bnum++;

    GsLockEnter(gd->g_lock);

    msg->m_hdr.h_lseq = gd->g_send.s_lseq;

    msg->m_hdr.h_mid = gd->g_mid;
    msg->m_hdr.h_viewnum = gd->g_curview;

    ctx->ctx_mask = gd->g_mset;
    msg->m_refcnt++;

    msg_mcast(gd->g_mset, &msg->m_hdr, buf, len);

    GspOrderInsert(gd, msg, msg, ctx->ctx_mseq, ctx->ctx_bnum);

    GspDispatch(gd);

    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (event != NULL) {
	gs_log(("Wait on event %x\n", event));
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }

    return ERROR_SUCCESS;
}

NTSTATUS
GspSendDirectedRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t event,
		       int memberid, gs_tag_t tag,
		       PVOID buf, UINT32 len, 
		       PVOID rbuf, UINT32 rlen,
		       IO_STATUS_BLOCK *ios,
		       UINT32 flags, UINT32 type)
{
    gs_send_state_t *ss;
    gs_nid_t mid;
    gs_msg_t *msg;
    int err = ERROR_SUCCESS;

    if (rlen > (UINT32)GS_DEFAULT_MAX_MSG_SZ) {
	return ERROR_INVALID_PARAMETER;
    }

    assert(gd != NULL);
    msg = msg_alloc(buf, len);

    assert(msg != NULL);

    if (event == NULL)
	event = ctx->ctx_syncevent;

    ctx->ctx_flags = (UINT16) flags;
    ctx->ctx_event = event;
    ctx->ctx_buf = buf;
    ctx->ctx_rbuf = rbuf;
    ctx->ctx_ios = ios;

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = (UINT16) type;
    msg->m_hdr.h_flags = ctx->ctx_flags | GS_FLAGS_PTP;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = gd->g_nid;
    msg->m_hdr.h_mid = (gs_memberid_t) memberid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));

    GsLockEnter(gd->g_lock);

    ctx->ctx_msg = msg;
    ctx->ctx_mask = 1 << memberid;

    ss = &gd->g_send;

    msg->m_hdr.h_lseq = ss->s_lseq;
    msg->m_hdr.h_mseq = ss->s_mseq;
    msg->m_hdr.h_bnum = ss->s_bnum++;
    msg->m_hdr.h_viewnum = gd->g_curview;

    if (gd->g_nid == (gs_memberid_t )memberid) {
	// insert into receive queue
	msg->m_refcnt++;
	msg->m_hdr.h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspUOrderInsert(gd, msg, msg, msg->m_hdr.h_mseq, msg->m_hdr.h_bnum);
	GspDispatch(gd);  
    } else {
	err = msg_send((gs_memberid_t) memberid, &msg->m_hdr, buf, len);
    }

    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (!err && event != NULL) {
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }

    return err;
}


NTSTATUS
WINAPI
GsSendDirectedRequest(HANDLE group, gs_event_t event OPTIONAL,
		      int memberid, gs_tag_t tag,
		      PVOID buf, UINT32 len, 
		      PVOID rbuf, UINT32 rlen,
		      IO_STATUS_BLOCK *ios,
		      HANDLE *context)
{
    gs_group_t *gd = (gs_group_t *)group;
    gs_context_t *ctx;
    NTSTATUS err;

    if (gd == NULL) { 
	return ERROR_INVALID_HANDLE;
    }

    GspOpenContext(gd, &ctx);

    ctx->ctx_flags = GS_FLAGS_DELIVERED | GS_FLAGS_CONTINUED;
    if (context != NULL) {
	ctx->ctx_flags |= GS_FLAGS_CONTINUED;
	*context = ctx;
    } else {
	ctx->ctx_flags |= GS_FLAGS_CLOSE;
    }

    err = GspSendDirectedRequest(gd, ctx, event, 
				 memberid, tag, buf, len, rbuf, rlen, 
				 ios,
				 ctx->ctx_flags, GS_MSG_TYPE_UCAST);

    if (err != ERROR_SUCCESS) {
	GspCloseContext(gd, ctx);
    }

    return err;
}


NTSTATUS
GspSendRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t event,
	       int type, gs_sequence_t mid, gs_tag_t tag, 
	       PVOID buf, UINT32 len, 
	       PVOID rbuf[], UINT32 rlen,
	       IO_STATUS_BLOCK ios[],
	       UINT32 flags, gs_join_info_t *info)
{
    gs_send_state_t *ss;
    BOOLEAN flag;
    gs_msg_t *msg;

    assert(gd != NULL);
    msg = msg_alloc(buf, len);

    assert(msg != NULL);

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = (UINT16) type;
    msg->m_hdr.h_flags = (UINT16) flags;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));
    msg->m_hdr.h_mseq = info->mseq;
    msg->m_hdr.h_lseq = info->mseq;
    msg->m_hdr.h_bnum = ctx->ctx_bnum++;
    msg->m_hdr.h_mid = (gs_memberid_t) mid;
    msg->m_hdr.h_viewnum = info->viewnum;

    if (event == NULL)
	event = ctx->ctx_syncevent;
    ctx->ctx_buf = buf; 
    ctx->ctx_rbuf = rbuf; 
    ctx->ctx_ios = ios;
    ctx->ctx_event = event;
    ctx->ctx_msg = msg;
    ctx->ctx_mask = info->mset;
    ctx->ctx_mseq = info->mseq;
    ctx->ctx_flags = (UINT16) flags;

    GsLockEnter(gd->g_lock);

    gd->g_send.s_mseq = info->mseq+1;
    gd->g_send.s_bnum = 0;

    msg_mcast(info->mset, &msg->m_hdr, buf, len);

    if (info->mset & (1 << gd->g_nid)) {
	msg->m_hdr.h_flags |= GS_FLAGS_QUEUED;
	msg->m_refcnt++;
	GspOrderInsert(gd, msg, msg, info->mseq, msg->m_hdr.h_bnum);
	GspDispatch(gd);
    } else {
	msg->m_hdr.h_flags |= GS_FLAGS_PTP;
	ctx->ctx_timer = timeSetEvent(500, 0, (LPTIMECALLBACK)timercallback,
				      (DWORD_PTR)ctx, TIME_PERIODIC);
	if (ctx->ctx_timer == 0) {
	    printf("Unable to create timer %d\n", GetLastError());
	}
    }

    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (event != NULL) {
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }


    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\join.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    join.c

Abstract:

    GUM routines to implement the special join updates.

Author:

    John Vert (jvert) 6/10/1996

Revision History:

--*/
#include "gump.h"

//
// Define structure used to pass arguments to node enumeration callback
//
typedef struct _GUMP_JOIN_INFO {
    GUM_UPDATE_TYPE UpdateType;
    DWORD Status;
    DWORD Sequence;
    DWORD LockerNode;
} GUMP_JOIN_INFO, *PGUMP_JOIN_INFO;

//
// Local function prototypes
//
BOOL
GumpNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


DWORD
GumBeginJoinUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    OUT DWORD *Sequence
    )
/*++

Routine Description:

    Begins the special join update for a joining node. This
    function gets the current GUM sequence number for the
    specified update type from another node in the cluster.
    It also gets the list of nodes currently participating
    in the updates.

Arguments:

    UpdateType - Supplies the GUM_UPDATE_TYPE.

    Sequence - Returns the sequence number that should be
        passed to GumEndJoinUpdate.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    GUMP_JOIN_INFO JoinInfo;

    //
    // Enumerate the list of nodes. The callback routine will attempt
    // to obtain the required information from each node that is online.
    //
    JoinInfo.Status = ERROR_GEN_FAILURE;
    JoinInfo.UpdateType = UpdateType;
    OmEnumObjects(ObjectTypeNode,
                  GumpNodeCallback,
                  &JoinInfo,
                  NULL);
    if (JoinInfo.Status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                      "[GUM] GumBeginJoinUpdate succeeded with sequence %1!d!\n",
                      JoinInfo.Sequence);
        *Sequence = JoinInfo.Sequence;
    }

    return(JoinInfo.Status);
}


BOOL
GumpNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback routine for GumBeginJoinUpdate. For each
    node that is currently online, it attempts to connect and obtain
    the current GUM information (sequence and nodelist) for the specified
    update type.

Arguments:

    Context1 - Supplies a pointer to the GUMP_JOIN_INFO structure.

    Context2 - not used

    Object - Supplies a pointer to the NM_NODE object

    Name - Supplies the node's name.

Return Value:

    FALSE - if the information was successfully obtained and enumeration
            should stop.

    TRUE - If enumeration should continue.

--*/

{
    DWORD Status;
    DWORD Sequence;
    PGUMP_JOIN_INFO JoinInfo = (PGUMP_JOIN_INFO)Context1;
    PGUM_NODE_LIST NodeList = NULL;
    PNM_NODE Node = (PNM_NODE)Object;
    GUM_UPDATE_TYPE UpdateType;
    DWORD i;
    DWORD LockerNodeId;
    DWORD nodeId;

    if (NmGetNodeState(Node) != ClusterNodeUp &&
        NmGetNodeState(Node) != ClusterNodePaused){
        //
        // This node is not up, so don't try and get any
        // information from it.
        //
        return(TRUE);
    }

    //
    // Get the sequence and nodelist information from this node.
    //
    UpdateType = JoinInfo->UpdateType;
    if (UpdateType != GumUpdateTesting) {
        //
        // Our node should not be marked as ClusterNodeUp yet.
        //
        CL_ASSERT(Node != NmLocalNode);
    }

    nodeId = NmGetNodeId(Node);
    NmStartRpc(nodeId);
    Status = GumGetNodeSequence(GumpRpcBindings[NmGetNodeId(Node)],
                                UpdateType,
                                &Sequence,
                                &LockerNodeId,
                                &NodeList);
    NmEndRpc(nodeId);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumGetNodeSequence from %1!ws! failed %2!d!\n",
                   OmObjectId(Node),
                   Status);
        NmDumpRpcExtErrorInfo(Status);
        return(TRUE);
    }

    JoinInfo->Status = ERROR_SUCCESS;
    JoinInfo->Sequence = Sequence;
    JoinInfo->LockerNode = LockerNodeId;

    //
    // Zero out all the nodes in the active node array.
    //
    ZeroMemory(&GumTable[UpdateType].ActiveNode,
               sizeof(GumTable[UpdateType].ActiveNode));

    //
    // Set all the nodes that are currently active in the
    // active node array.
    //
    for (i=0; i < NodeList->NodeCount; i++) {
        CL_ASSERT(NmIsValidNodeId(NodeList->NodeId[i]));
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpNodeCallback setting node %1!d! active.\n",
                   NodeList->NodeId[i]);
        GumTable[UpdateType].ActiveNode[NodeList->NodeId[i]] = TRUE;;
    }
    MIDL_user_free(NodeList);

    //
    // Add in our own node.
    //
    GumTable[UpdateType].ActiveNode[NmGetNodeId(NmLocalNode)] = TRUE;

    //
    // Set the current locker node
    //
    GumpLockerNode = LockerNodeId;
    return(FALSE);

}


DWORD
GumCreateRpcBindings(
    PNM_NODE  Node
    )
/*++

Routine Description:

    Creates GUM's private RPC bindings for a joining node.
    Called by the Node Manager.

Arguments:

    Node - A pointer to the node for which to create RPC bindings

Return Value:

    A Win32 status code.

--*/
{
    DWORD               Status;
    RPC_BINDING_HANDLE  BindingHandle;
    CL_NODE_ID          NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Creating RPC bindings for node %1!u!.\n",
        NodeId
        );

    //
    // Main binding
    //
    if (GumpRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(GumpRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to verify 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(GumpRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to create 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    //
    // Replay binding
    //
    if (GumpReplayRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(GumpReplayRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to verify 2nd RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(GumpReplayRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to create 2nd RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    return(ERROR_SUCCESS);

} // GumCreateRpcBindings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gs\recovery.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    recovery.c

Abstract:

    Handles node down events

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include <stdio.h>

extern gs_nid_t	GsLocalNodeId;
extern int	GsMaxNodeId;
extern int	GsMinNodeId;
extern gs_group_t	GsGroupTable[];

// Node down event
void
GspRsFree(gs_recovery_state_t *rs)
{
    // free recovery state
    gs_rblk_t	*p;

    while (p = rs->rs_list) {
	rs->rs_list = p->next;
	free((char *)p);
    }

    GsEventFree(rs->rs_event);
    free((char *)rs);
}

void
GspPhase1NodeDown(ULONG	set)
{
    gs_group_t	*gd;
    int i, j;

    for (i = 0; i < GsGroupTableSize; i++) {
	gd = &GsGroupTable[i];
	if (gd->g_state == GS_GROUP_STATE_FREE) {
	    continue;
	}
	GsLockEnter(gd->g_lock);
	if (gd->g_mset & set) {
	    gd->g_mset &= ~set;
	    gd->g_curview++;
	    gd->g_state |= GS_GROUP_FLAGS_RECOVERY;
	    gd->g_sz = 0;
	    for (j = gd->g_mset; j > 0; j = j >> 1) {
		if (j & 0x1)
		    gd->g_sz++;
	    }
	    if (set & (1 << gd->g_mid)) {

		for (j = GsMinNodeId; j != GsMaxNodeId; j++) {
		    if (gd->g_mset & (1 << j)) {
			break;
		    }
		}
		// elect a new master
		gd->g_mid = (gs_memberid_t) j;
		gd->g_state |= GS_GROUP_FLAGS_NEWMASTER;
	    }

	    recovery_log(("Phase1 mask %x gid %d mid %d mset %x sz %d\n",
		      set, gd->g_id, gd->g_mid, gd->g_mset,
		      gd->g_sz));

	    if (gd->g_rs != NULL) {
		set |= gd->g_rs->rs_dset;
		GsEventSignal(gd->g_rs->rs_event);
		GspRsFree(gd->g_rs);
	    }
	    gd->g_rs = (gs_recovery_state_t *) malloc(sizeof(*gd->g_rs));
	    assert(gd->g_rs != NULL);
	    GsManualEventInit(gd->g_rs->rs_event);
	    gd->g_rs->rs_sz = 0;
	    gd->g_rs->rs_list = NULL;
	    gd->g_rs->rs_epoch = gd->g_curview;
	    gd->g_rs->rs_dset = set;
	    gd->g_rs->rs_mset = gd->g_mset;
	    if (gd->g_mid != gd->g_nid) {
		// we are not master, reset our mset to self and master only
		gd->g_rs->rs_mset = (1 << gd->g_nid) | (1 << gd->g_mid);
	    }
	} else if (gd->g_mset == 0 && (set & (1 << gd->g_mid))) {
	    // no one is participating in this group and the sole owner dead
	    // remove the group and free it
	    GsCloseGroup(gd);
	}

	GsLockExit(gd->g_lock);
    }

}

void
GspRsAddSequence(gs_recovery_state_t *rs, gs_sequence_t mseq, int delta)
{
    gs_rblk_t *p, **q;

    for (p = rs->rs_list; p != NULL; p = p->next) {
	if (p->mseq == mseq) {
	    p->have += delta;
	    recovery_log(("Found seq %d cnt %d\n", mseq, p->have));
	    return;
	}
    }
    // if we get here that means the sequence is missing
    p = (gs_rblk_t *) malloc(sizeof(*p));
    if (p == NULL) {
	err_log(("GspRsAddSeq: unable to allocate memory!\n"));
	exit(1);
    }

    p->mseq = mseq;
    p->have = delta;

    recovery_log(("Add seq %d cnt %d\n", mseq, p->have));

    rs->rs_sz++;
    q = &rs->rs_list;
    while (*q != NULL) {
	if ((*q)->mseq > mseq) {
	    p->next = *q;
	    *q = p;
	    return;
	}
	q = &(*q)->next;
    }

    p->next = *q;
    *q = p;
}

void
GspPhase2NodeDown(ULONG set)
{

    gs_group_t	*gd;
    int i, j;

    for (i = 0; i < GsGroupTableSize; i++) {
	gd = &GsGroupTable[i];
	if (!(gd->g_state & GS_GROUP_FLAGS_RECOVERY)) {
	    continue;
	}
	GsLockEnter(gd->g_lock);
	if (gd->g_state & GS_GROUP_FLAGS_RECOVERY) {
	    gs_msg_t *p;
	    extern void GspDumpQueue(gs_group_t*);

	    recovery_log(("Phase2 queue\n"));
	    GspDumpQueue(gd);
	    recovery_log(("Expect gid %d <%d, %d>\n", 
			  gd->g_id, gd->g_recv.r_mseq, gd->g_recv.r_bnum));

	    // walk recv queue and replay messages from dead members
	    for (p = gd->g_recv.r_head; p != NULL; p = p->m_next) {
		if (set & (1 << p->m_hdr.h_sid)) { 
		    // tag message as if we got a reply
		    p->m_hdr.h_flags |= GS_FLAGS_REPLY;
		    if (p->m_hdr.h_type != GS_MSG_TYPE_UCAST){
			p->m_hdr.h_flags |= GS_FLAGS_REPLAY;
			msg_mcast(gd->g_mset, &p->m_hdr, 
				  p->m_buf, p->m_hdr.h_len);
		    }
		    // check of unclosed continued sends
		    if (p->m_hdr.h_flags & GS_FLAGS_CONTINUED) {
			gs_msg_t *q;
			
			q = p->m_next;
			if (q == NULL || 
			    q->m_hdr.h_mseq != p->m_hdr.h_mseq ||
			    q->m_hdr.h_bnum != p->m_hdr.h_bnum+1) {

			    q = msg_alloc(NULL, 0);
			    if (q == NULL) {
				err_log(("Unable to allocate memory!\n"));
				halt(1);
			    }
			    memcpy(&q->m_hdr, &p->m_hdr, sizeof(p->m_hdr));
			    q->m_hdr.h_type = GS_MSG_TYPE_ABORT;
			    q->m_hdr.h_len = 0;
			    q->m_hdr.h_bnum++;
			    q->m_hdr.h_flags = GS_FLAGS_LAST;

			    // insert abort msg
			    q->m_next = p->m_next;
			    p->m_next = q;
			}
		    }
		}
	    }
			    
	    // walk recv queue and build msg of sequences we have
	    for (p = gd->g_recv.r_head; p != NULL; p = p->m_next) {
		if (p->m_hdr.h_mseq != GS_MSG_TYPE_UCAST)
		    GspRsAddSequence(gd->g_rs, p->m_hdr.h_mseq, 1);
	    }

	    // send msg of sequences to master
	    if (gd->g_mid != gd->g_nid) {
		gs_rblk_t *p;
		gs_sequence_t *list;
		int k;
		gs_msg_hdr_t hdr;

		recovery_log(("Sending sequence state to master %d\n", gd->g_mid));

		list = (gs_sequence_t *) malloc(sizeof(*list) * gd->g_rs->rs_sz);
		if (list == NULL) {
		    err_log(("Unable to allocate memory during recovery\n"));
		    exit(1);
		}
		k = 0;
		for (p = gd->g_rs->rs_list; p != NULL; p = p->next) {
		    list[k] = p->mseq;
		    k++;
		}
		assert(k == gd->g_rs->rs_sz);
		k = k * sizeof(*list);

		hdr.h_len = (UINT16) k;
		hdr.h_type = GS_MSG_TYPE_RECOVERY;
		hdr.h_sid = (gs_memberid_t)gd->g_nid;
		hdr.h_mid = (gs_memberid_t) gd->g_mid;
		hdr.h_gid = gd->g_id;
		hdr.h_viewnum = gd->g_curview;
		hdr.h_mseq = gd->g_recv.r_mseq;
		hdr.h_lseq = gd->g_send.s_mseq;
		
		msg_send(gd->g_mid, &hdr, (const char *) list, k);
		free((char *)list);
	    } else {
		// add current sequence to dispatch
		GspRsAddSequence(gd->g_rs, gd->g_recv.r_mseq, 0);
	    }

	    // handle send path
	    for (j = 0; j < gd->g_send.s_wsz; j++) {
		gs_context_t *ctx = &gd->g_send.s_ctxpool[j];
		
		if (ctx->ctx_id != GS_CONTEXT_INVALID_ID && ctx->ctx_msg != NULL){
		    recovery_log(("phase2 gid %d ctx %d mask %x\n",
			      gd->g_id, ctx->ctx_id, ctx->ctx_mask));
		    if (set & ctx->ctx_mask) {
			int k, n;

			recovery_log(("phase2 complete gid %d ctx %d\n",
				  gd->g_id, ctx->ctx_id));
			for (n = 0, k = set; k != 0; k = k >> 1, n++) {
			    if (k & 0x1) {
				GspProcessReply(gd, ctx, n, NULL, 0, 
						STATUS_HOST_UNREACHABLE);
			    }
			}
		    }
		}
	    }
	    
	    // clear this node bit
	    gd->g_rs->rs_mset &= ~(1 << gd->g_nid);
	    if (gd->g_rs->rs_mset == 0) {
		void GspComputeState(gs_group_t *gd);

		GspComputeState(gd);
	    }
		
	}
	GsLockExit(gd->g_lock);
    }
    
}

void GspSyncState(gs_group_t *gd, gs_msg_t *msg, gs_sequence_t *list, int sz);

void
GspComputeState(gs_group_t *gd)
{

    int k;
    gs_sequence_t *list;
    gs_rblk_t *p, *last = NULL;
    gs_msg_t *msg;


    recovery_log(("Compute missing sequences gid %d\n", gd->g_id));

		// compute missing sequences
    list = (gs_sequence_t *) malloc(sizeof(*list) * gd->g_rs->rs_sz);
    if (list == NULL) {
	err_log(("Unable to allocate memory during computestate\n"));
	exit(1);
    }
    k = 0;
    for (p = gd->g_rs->rs_list; p != NULL; p = p->next) {
	recovery_log(("rs list sequence %d\n", p->mseq));
	if (p->have == 0) {
	    recovery_log(("Skip sequence %d\n", p->mseq));
	    list[k] = p->mseq;
	    k++;
	}
	last = p;
    }
    // compute next starting mseq
    gd->g_global_seq = last != NULL ? last->mseq+1 : gd->g_recv.r_mseq;

    k = k * sizeof(*list);

    msg = msg_alloc((char *)list, k);
    assert(msg != NULL);

    msg->m_hdr.h_len = (UINT16) k;
    msg->m_hdr.h_type = GS_MSG_TYPE_SYNC;
    msg->m_hdr.h_flags = GS_FLAGS_LAST;
    msg->m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
    msg->m_hdr.h_mid = (gs_memberid_t) gd->g_mid;
    msg->m_hdr.h_cid = (gs_cookie_t) -1;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_viewnum = gd->g_curview;
    msg->m_hdr.h_mseq = gd->g_global_seq++;
    msg->m_hdr.h_lseq = gd->g_send.s_lseq;
    msg->m_hdr.h_bnum = 0;
    *((ULONG *)msg->m_hdr.h_tag) = gd->g_rs->rs_dset;

		// send missing sequence list to other nodes
    msg_mcast(gd->g_mset, &msg->m_hdr, (const char *) list, k);

    recovery_log(("Next starting sequence is %d\n", gd->g_global_seq));

		// handle self
    GspSyncState(gd, msg, list, k / sizeof(*list));

    free((char *)list);

}

void
GspRecoveryMsgHandler(gs_msg_t *rmsg)

{
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    
    hdr = &rmsg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && rmsg->m_hdr.h_viewnum == gd->g_curview) {
	gs_sequence_t *list;
	int sz, k;

	list = (gs_sequence_t *) rmsg->m_buf;
	sz = rmsg->m_hdr.h_len / sizeof(*list);

	GsLockEnter(gd->g_lock);

	// make sure group is in recovery mode
	assert(gd->g_state & GS_GROUP_FLAGS_RECOVERY);
	assert(gd->g_mid == gd->g_nid);

	// add current sequence to dispatch
	GspRsAddSequence(gd->g_rs, hdr->h_mseq, 0);
	// insert sequences into have list
	for (k = 0; k < sz; k++) {
	    GspRsAddSequence(gd->g_rs, list[k], 1);
	}

	// clear this node bit
	gd->g_rs->rs_mset &= ~(1 << hdr->h_sid);
	if (gd->g_rs->rs_mset == 0) {
	    GspComputeState(gd);
	}	

	GsLockExit(gd->g_lock);
    }

    msg_free(rmsg);

}

void
GspSyncState(gs_group_t *gd, gs_msg_t *msg, gs_sequence_t *list, int sz)

{
    int  k;

    // make sure group is in recovery mode
    assert(gd->g_state & GS_GROUP_FLAGS_RECOVERY);
    assert(gd->g_mid != gd->g_nid);
    assert(gd->g_mid == hdr->h_sid);

    // mark missing sequences
    for (k = 0; k < sz; k++) {
	gs_msg_t *p;

	recovery_log(("Missing sequence %d\n", list[k]));

	p = msg_alloc(NULL, 0);
	if (p == NULL) {
	    err_log(("Unable to allocate memory during syncstate!\n"));
	    halt(1);
	}

	p->m_hdr.h_sid = gd->g_nid;
	p->m_hdr.h_gid = gd->g_id;
	p->m_hdr.h_cid = (gs_cookie_t) -1;
	p->m_hdr.h_type = GS_MSG_TYPE_SKIP;
	p->m_hdr.h_mseq = list[k];
	p->m_hdr.h_lseq = gd->g_send.s_lseq;
	p->m_hdr.h_bnum = 0;
	p->m_hdr.h_flags = GS_FLAGS_LAST;

	GspOrderInsert(gd, p, p, p->m_hdr.h_mseq, 0);
    }

    // set startview to curview
    gd->g_startview = gd->g_curview;
    // clear recovery state
    gd->g_state &= ~GS_GROUP_FLAGS_RECOVERY;
    // free recovery state
    GsEventSignal(gd->g_rs->rs_event);
    GspRsFree(gd->g_rs);
    gd->g_rs = NULL;

    // insert msg into dispatch queue at proper order  
    GspOrderInsert(gd, msg, msg, msg->m_hdr.h_mseq, 0);
    GspDispatch(gd);
#if 0
    // xxx: need to understand this again
    if (gd->g_recv.r_last != NULL) {
	GspCleanQueue(gd, last_mseq);
    }
#endif
    // restart any pending sends
    if (gd->g_send.s_waitqueue != NULL && (gd->g_state & GS_GROUP_FLAGS_NEWMASTER)) {
	recovery_log(("resend: gs %x s %x\n", gd, gd->g_send.s_waitqueue));
	GspAllocateSequence(gd);
    }
    gd->g_state &= ~GS_GROUP_FLAGS_NEWMASTER;
}


void
GspSyncMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    
    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && msg->m_hdr.h_viewnum == gd->g_curview) {
	gs_sequence_t *list;
	int sz;

	list = (gs_sequence_t *) msg->m_buf;
	sz = msg->m_hdr.h_len / sizeof(*list);

	GsLockEnter(gd->g_lock);

	// clear this node bit
	gd->g_rs->rs_mset &= ~(1 << hdr->h_sid);
	assert(gd->g_rs->rs_mset == 0);

	GspSyncState(gd, msg, list, sz);

	GsLockExit(gd->g_lock);
    } else {
	msg_free(msg);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\idl\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\guminit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Initialization and shutdown routines for the GUM component
    of the NT Cluster Service

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"

//
// Global information (used to be per-update)
//
DWORD GumpSequence;
CRITICAL_SECTION GumpUpdateLock;
CRITICAL_SECTION GumpSendUpdateLock;
CRITICAL_SECTION GumpRpcLock;
PVOID GumpLastBuffer;
DWORD GumpLastContext;
DWORD GumpLastBufferLength;
DWORD GumpLastUpdateType;
LIST_ENTRY GumpLockQueue;
DWORD GumpLockingNode;
DWORD GumpLockerNode;
BOOL GumpLastBufferValid;

//
// Table of per-update information
//
GUM_INFO GumTable[GumUpdateMaximum];
CRITICAL_SECTION GumpLock;

//
// Per-node information
//
GUM_NODE_WAIT GumNodeWait[ClusterMinNodeId + ClusterDefaultMaxNodes];
RPC_BINDING_HANDLE GumpRpcBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];
RPC_BINDING_HANDLE GumpReplayRpcBindings[
                              ClusterMinNodeId + ClusterDefaultMaxNodes
                              ];


DWORD
GumInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the Global Update Manager.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD i;
    DWORD Status;

    //
    // Initialize global data
    //
    InitializeCriticalSection(&GumpLock);
    InitializeCriticalSection(&GumpUpdateLock);
    InitializeCriticalSection(&GumpSendUpdateLock);
    InitializeCriticalSection(&GumpRpcLock);
    GumpSequence = 0;
    InitializeListHead(&GumpLockQueue);
    GumpLockingNode = (DWORD)-1;
    GumpLastBuffer = NULL;
    GumpLastBufferValid = FALSE;
    GumpLastContext = 0;
    GumpLastBufferLength = 0;
    //set it to illegal value;
    GumpLastUpdateType = GumUpdateMaximum;
    //
    // Assume we are the locker node.
    //
    GumpLockerNode = NmGetNodeId(NmLocalNode);

    //
    // Initialize GumTable
    //
    for (i=0; i < GumUpdateMaximum; i++) {
        GumTable[i].Receivers = NULL;
        GumTable[i].Joined = FALSE;
        ZeroMemory(&GumTable[i].ActiveNode,
                   sizeof(GumTable[i].ActiveNode));
        GumTable[i].ActiveNode[NmGetNodeId(NmLocalNode)] = TRUE;
    }

    //
    // Initialize per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        GumpRpcBindings[i] = NULL;
        GumpReplayRpcBindings[i] = NULL;

        GumNodeWait[i].WaiterCount = 0;
        GumNodeWait[i].hSemaphore = CreateSemaphore(NULL,0,100,NULL);
        if (GumNodeWait[i].hSemaphore == NULL) {
            CL_UNEXPECTED_ERROR( GetLastError() );
        }
    }

    Status = EpRegisterEventHandler(CLUSTER_EVENT_NODE_DOWN_EX,
                                    GumpEventHandler);

    if (Status == ERROR_SUCCESS) {
        Status = EpRegisterSyncEventHandler(CLUSTER_EVENT_NODE_DOWN_EX,
                                    GumpSyncEventHandler);
    }

    return(Status);
}


VOID
GumShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the Global Update Manager.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD i;
    PGUM_RECEIVER Receiver;
    PGUM_RECEIVER Next;

    //
    // Tear down GumTable
    //
    for (i=0; i < GumUpdateMaximum; i++) {
        Receiver = GumTable[i].Receivers;
        while (Receiver != NULL) {
            Next = Receiver->Next;
            LocalFree(Receiver);
            Receiver = Next;
        }
    }

    //
    // Free per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumpRpcBindings[i] != NULL) {
            ClMsgDeleteRpcBinding(GumpRpcBindings[i]);
        }

        if (GumpReplayRpcBindings[i] != NULL) {
            ClMsgDeleteRpcBinding(GumpReplayRpcBindings[i]);
        }

        if (GumNodeWait[i].hSemaphore != NULL) {
            CloseHandle(GumNodeWait[i].hSemaphore);
        }
    }

    DeleteCriticalSection(&GumpLock);
    DeleteCriticalSection(&GumpUpdateLock);
    DeleteCriticalSection(&GumpSendUpdateLock);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\send.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Routines for sending global updates to the cluster

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"


DWORD
GumSendUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Sends an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/

{
    DWORD Sequence;
    DWORD Status=RPC_S_OK;
    DWORD i;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;
    DWORD LockerNode;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    // Grab an RPC handle
    GumpStartRpc(MyNodeId);

retryLock:
    LockerNode = GumpLockerNode;

    //
    // Send locking update to the locker node.
    //
    if (LockerNode == MyNodeId) {
        //
        // This node is the locker.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumSendUpdate:  Locker waiting\t\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        Status = GumpDoLockingUpdate(UpdateType, MyNodeId, &Sequence);
        if (Status == ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumSendUpdate: Locker dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
                       Sequence,
                       UpdateType,
                       Context);
            Status = GumpDispatchUpdate(UpdateType,
                                        Context,
                                        TRUE,
                                        TRUE,
                                        BufferLength,
                                        Buffer);
            if (Status != ERROR_SUCCESS) {
                //
                // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
                // failed and did not increment the sequence number.
                //
                GumpDoUnlockingUpdate(UpdateType, Sequence-1);
            }
        }
    } else {
//        CL_ASSERT(GumpRpcBindings[i] != NULL);
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumSendUpdate: queuing update\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        try {
            NmStartRpc(LockerNode);
            Status = GumQueueLockingUpdate(GumpRpcBindings[LockerNode],
                                           MyNodeId,
                                           UpdateType,
                                           Context,
                                           &Sequence,
                                           BufferLength,
                                           Buffer);
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // An exception from RPC indicates that the other node is either dead
            // or insane. Kill it and retry with a new locker.
            //

            NmEndRpc(LockerNode);
            GumpCommFailure(GumInfo,
                            LockerNode,
                            GetExceptionCode(),
                            TRUE);

            //
            // The GUM update handler must have been called to select a new locker
            // node.
            //
            CL_ASSERT(LockerNode != GumpLockerNode);

            //
            // Retry the locking update with the new locker node.
            //
            goto retryLock;
        }
        if (Status == ERROR_SUCCESS) {
            CL_ASSERT(Sequence == GumpSequence);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }

        //because there is no synchronization between join and regroups/gumprocessing
        //the old locker node may die and may come up again and not be the locker
        //anymore. We have to take care of this case.
        if (Status == ERROR_CLUSTER_GUM_NOT_LOCKER)
        {
            goto retryLock;
        }
    }
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] Queued lock attempt for send type %1!d! failed %2!d!\n",
                   UpdateType,
                   Status);
    	// signal end of RPC handle
    	GumpEndRpc(MyNodeId);
        return(Status);
    }

    //
    // Grap the sendupdate lock to serialize with any replays
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    if (LockerNode != GumpLockerNode) {
        //
        // Locker node changed, we need to restart again.
        //
        LeaveCriticalSection(&GumpSendUpdateLock);
    	goto retryLock;
    }

    //
    // The update is now committed on the locker node. All remaining nodes
    // must be updated successfully, or they will be killed.
    //
    for (i=LockerNode+1; i != LockerNode; i++) {
        if (i == (NmMaxNodeId + 1)) {
            i=ClusterMinNodeId;
            if (i==LockerNode) {
                break;
            }
        }

        if (GumInfo->ActiveNode[i]) {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumSendUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);
            if (i == MyNodeId) {
                Status = GumpDispatchUpdate(UpdateType,
                                   Context,
                                   FALSE,
                                   TRUE,
                                   BufferLength,
                                   Buffer);
                if (Status != ERROR_SUCCESS){
                    ClRtlLogPrint(LOG_CRITICAL,
                            "[GUM] GumSendUpdate: Update on non-locker node(self) failed with %1!d! when it must succeed\n",
                            Status);
                    //Commit Suicide
                    CsInconsistencyHalt(Status);
                }

            } else {
                DWORD Status;

                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumSendUpdate: Locker updating seq %1!u!\ttype %2!u! context %3!u!\n",
                           Sequence,
                           UpdateType,
                           Context);
                try {
                    NmStartRpc(i);
                    Status = GumUpdateNode(GumpRpcBindings[i],
                                           UpdateType,
                                           Context,
                                           Sequence,
                                           BufferLength,
                                           Buffer);
                    NmEndRpc(i);
                } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                    NmEndRpc(i);
                    Status = GetExceptionCode();
                }
                //
                // If the update on the other node failed, then the
                // other node must now be out of the cluster since the
                // update has already completed on the locker node.
                //
                if (Status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[GUM] GumSendUpdate: Update on node %1!d! failed with %2!d! when it must succeed\n",
                                i,
                                Status);

                    NmDumpRpcExtErrorInfo(Status);

                    GumpCommFailure(GumInfo,
                                    i,
                                    Status,
                                    TRUE);
                }
            }
        }
    }

    //
    // Our update is over
    //
    LeaveCriticalSection(&GumpSendUpdateLock);

    //
    // All nodes have been updated. Send unlocking update.
    //
    if (LockerNode == MyNodeId) {
        GumpDoUnlockingUpdate(UpdateType, Sequence);
    } else {
        try {
            NmStartRpc(LockerNode);
            GumUnlockUpdate(
                GumpRpcBindings[LockerNode],
                UpdateType,
                Sequence
                );
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // The locker node has crashed. Notify the NM, it will call our
            // notification routine to select a new locker node. Then retry
            // the unlock on the new locker node.
            // SS: changed to not retry unlocks..the new locker node will
            // unlock after propagating this change in any case.
            //
            NmEndRpc(LockerNode);
            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[GUM] GumSendUpdate: Unlocking update to node %1!d! failed with %2!d!\n",
                       LockerNode,
                       Status);
            GumpCommFailure(GumInfo,
                            LockerNode,
                            Status,
                            TRUE);
            CL_ASSERT(LockerNode != GumpLockerNode);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               UpdateType,
               Context);

    // signal end of RPC handle
    GumpEndRpc(MyNodeId);
    return(ERROR_SUCCESS);
}

#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.
    N.B. The below code does not handle locker node failures


DWORD
WINAPI
GumPostUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer                 // THIS WILL BE FREED
    )

/*++

Routine Description:

    Posts an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. The update will not be reported
    on the current node. The update will not necessarily have
    completed when this function returns, but will complete
    eventually if the current node does not fail.

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers. THIS BUFFER WILL BE FREED ONCE THE
        POST HAS COMPLETED.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/
{
    DWORD Sequence;
    DWORD Status;
    DWORD i;
    BOOL IsLocker = TRUE;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;
    DWORD LockerNode=(DWORD)-1;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    //
    // Find the lowest active node in the cluster. This is the
    // locker.
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i]) {
            LockerNode = i;
            break;
        }
    }

    CL_ASSERT(i <= NmMaxNodeId);

    //
    // Post a locking update to the locker node. If this succeeds
    // immediately, we can go do the work directly. If it pends,
    // the locker node will call us back when it is our turn to
    // make the updates.
    //
    if (i == MyNodeId) {
        //
        // This node is the locker.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: Locker waiting\t\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        Status = GumpDoLockingPost(UpdateType,
                                   MyNodeId,
                                   &Sequence,
                                   Context,
                                   BufferLength,
                                   (DWORD)Buffer,
                                   Buffer);
        if (Status == ERROR_SUCCESS) {
            //
            // Update our sequence number so we stay in sync, even though
            // we aren't dispatching the update.
            //
            GumpSequence += 1;
        }
    } else {
        CL_ASSERT(GumpRpcBindings[i] != NULL);
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: queuing update\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        Status = GumQueueLockingPost(GumpRpcBindings[i],
                                     MyNodeId,
                                     UpdateType,
                                     Context,
                                     &Sequence,
                                     BufferLength,
                                     Buffer,
                                     (DWORD)Buffer);
        if (Status == ERROR_SUCCESS) {
            CL_ASSERT(Sequence == GumpSequence);
        }
    }

    if (Status == ERROR_SUCCESS) {
        //
        // The lock was immediately acquired, go ahead and post directly
        // here.
        //
        GumpDeliverPosts(LockerNode+1,
                         UpdateType,
                         Sequence,
                         Context,
                         BufferLength,
                         Buffer);

        //
        // All nodes have been updated. Send unlocking update.
        //
        if (LockerNode == MyNodeId) {
            GumpDoUnlockingUpdate(UpdateType, Sequence);
        } else {
            GumUnlockUpdate(
                GumpRpcBindings[LockerNode],
                UpdateType,
                Sequence
                );
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
                   Sequence,
                   UpdateType,
                   Context);

        return(ERROR_SUCCESS);
    } else {
        //
        // The lock is currently held. We will get called back when it is released
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: pending update type %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        return(ERROR_IO_PENDING);
    }

}


VOID
GumpDeliverPosts(
    IN DWORD FirstNodeId,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Sequence,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer                 // THIS WILL BE FREED
    )
/*++

Routine Description:

    Actually delivers the update post to the specified nodes.
    The GUM lock is assumed to be held.

Arguments:

    FirstNodeId - Supplies the node ID where the posts should start.
        This is generally the LockerNode+1.

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers. THIS BUFFER WILL BE FREED ONCE THE
        POST HAS COMPLETED.

Return Value:

    None.

--*/

{
    DWORD i;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;


    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    for (i=FirstNodeId; i<=NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i]) {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumpDeliverPosts: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);
            if (i == MyNodeId) {
                //
                // Update our sequence number so we stay in sync, even though
                // we aren't dispatching the update.
                //
                GumpSequence += 1;
            } else {
                CL_ASSERT(GumpRpcBindings[i] != NULL);
                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumpDeliverPosts: Locker updating seq %1!u!\ttype %2!u! context %3!u!\n",
                           Sequence,
                           UpdateType,
                           Context);
                GumUpdateNode(GumpRpcBindings[i],
                              UpdateType,
                              Context,
                              Sequence,
                              BufferLength,
                              Buffer);
            }
        }
    }

    LocalFree(Buffer);
}

#endif


DWORD
WINAPI
GumAttemptUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Conditionally sends an update to all active nodes in the
    cluster. If the clusterwise sequence number matches the supplied
    sequence number, all registered update handlers for the specified
    UpdateType are called on each node. Any registered update handlers
    for the current node will be called on the same thread. This is
    useful for correct synchronization of the data structures to be updated.

    The normal usage of this routine is as follows:
         obtain current sequence number from GumGetCurrentSequence
         make modification to cluster state
         conditionally update cluster state with GumAttemptUpdate
         If update fails, undo modification, release any locks, try again later

Arguments:

    Sequence - Supplies the sequence number obtained from GumGetCurrentSequence.

    UpdateType - Supplies the type of update. This determines which update handlers
        will be called

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to be passed to the
        update handlers

    Buffer - Supplies a pointer to the update buffer to be passed to the update
        handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/
{
    DWORD Status=RPC_S_OK;
    DWORD i;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;
    DWORD LockerNode=(DWORD)-1;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

retryLock:
    LockerNode = GumpLockerNode;

    //
    // Send locking update to the locker node.
    //
    if (LockerNode == MyNodeId)
    {
        //
        // This node is the locker.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumAttemptUpdate: Locker waiting\t\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);

        if (GumpTryLockingUpdate(UpdateType, MyNodeId, Sequence))
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumAttemptUpdate: Locker dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
                       Sequence,
                       UpdateType,
                       Context);
            Status = GumpDispatchUpdate(UpdateType,
                                        Context,
                                        TRUE,
                                        TRUE,
                                        BufferLength,
                                        Buffer);
            if (Status != ERROR_SUCCESS) {
                //
                // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
                // failed and did not increment the sequence number.
                //
                GumpDoUnlockingUpdate(UpdateType, Sequence-1);
            }
         }
         else
         {
            Status = ERROR_CLUSTER_DATABASE_SEQMISMATCH;
         }
    }
    else
    {
        //
        //send the locking update to the locker node
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumAttemptUpdate: queuing update\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        try {
            NmStartRpc(LockerNode);
            Status = GumAttemptLockingUpdate(GumpRpcBindings[LockerNode],
                                             MyNodeId,
                                             UpdateType,
                                             Context,
                                             Sequence,
                                             BufferLength,
                                             Buffer);
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // An exception from RPC indicates that the other node is either dead
            // or insane. Kill it and retry with a new locker.
            //
            NmEndRpc(LockerNode);
            GumpCommFailure(GumInfo,
                            LockerNode,
                            GetExceptionCode(),
                            TRUE);

            //
            // The GUM update handler must have been called to select a new locker
            // node.
            //
            CL_ASSERT(LockerNode != GumpLockerNode);

            //
            // Retry the locking update with the new locker node.
            //
            goto retryLock;
        }
        if (Status == ERROR_SUCCESS)
        {
            CL_ASSERT(Sequence == GumpSequence);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }

    }

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumAttemptUpdate: Queued lock attempt for send type %1!d! failed %2!d!\n",
                   UpdateType,
                   Status);
        return(Status);
    }

    //
    // Grap the sendupdate lock to serialize with any replays
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    if (LockerNode != GumpLockerNode) {
        //
        // Locker node changed, we need to restart again.
        //
        LeaveCriticalSection(&GumpSendUpdateLock);
	goto retryLock;
    }


    // The update is now committed on the locker node. All remaining nodes
    // must be updated successfully, or they will be killed.
    //
    for (i=LockerNode+1; i != LockerNode; i++)
    {
        if (i == (NmMaxNodeId + 1))
        {
            i=ClusterMinNodeId;
            if (i==LockerNode)
            {
                break;
            }
        }

        if (GumInfo->ActiveNode[i])
        {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumAttemptUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);
            if (i == MyNodeId) {
                Status = GumpDispatchUpdate(UpdateType,
                                   Context,
                                   FALSE,
                                   TRUE,
                                   BufferLength,
                                   Buffer);
                if (Status != ERROR_SUCCESS){
                    ClRtlLogPrint(LOG_CRITICAL,
                            "[GUM] GumAttemptUpdate: Update on non-locker node(self) failed with %1!d! when it must succeed\n",
                            Status);
                    //Commit Suicide
                    CsInconsistencyHalt(Status);
                }

            } else {
                DWORD Status;

                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumAttemptUpdate: Locker updating seq %1!u!\ttype %2!u! context %3!u!\n",
                           Sequence,
                           UpdateType,
                           Context);
                try {
                    NmStartRpc(i);
                    Status = GumUpdateNode(GumpRpcBindings[i],
                                           UpdateType,
                                           Context,
                                           Sequence,
                                           BufferLength,
                                           Buffer);
                    NmEndRpc(i);
                } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                    NmEndRpc(i);
                    Status = GetExceptionCode();
                }
                //
                // If the update on the other node failed, then the
                // other node must now be out of the cluster since the
                // update has already completed on the locker node.
                //
                if (Status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[GUM] GumAttemptUpdate: Update on node %1!d! failed with %2!d! when it must succeed\n",
                                i,
                                Status);

                    NmDumpRpcExtErrorInfo(Status);

                    GumpCommFailure(GumInfo,
                                    i,
                                    Status,
                                    TRUE);
                }
            }
        }
    }
    //
    // Our update is over
    //
    LeaveCriticalSection(&GumpSendUpdateLock);

    //
    // All nodes have been updated. Send unlocking update.
    //
    if (LockerNode == MyNodeId) {
        GumpDoUnlockingUpdate(UpdateType, Sequence);
    } else {
        try {
            NmStartRpc(LockerNode);
            Status = GumUnlockUpdate(
                GumpRpcBindings[LockerNode],
                UpdateType,
                Sequence
                );
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // The locker node has crashed. Notify the NM, it will call our
            // notification routine to select a new locker node. The new
            // locker node will release the gum lock after propagating
            // the current update.
            //
            NmEndRpc(LockerNode);
            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[GUM] GumAttemptUpdate: Unlocking update to node %1!d! failed with %2!d!\n",
                       LockerNode,
                       Status);
            GumpCommFailure(GumInfo,
                            LockerNode,
                            Status,
                            TRUE);
            CL_ASSERT(LockerNode != GumpLockerNode);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumAttemptUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               UpdateType,
               Context);

    return(ERROR_SUCCESS);
}





DWORD
WINAPI
GumGetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType
    )

/*++

Routine Description:

    Obtains the current clusterwise global update sequence number

Arguments:

    UpdateType - Supplies the type of update. Each update type may
        have an independent sequence number.

Return Value:

    Current global update sequence number for the specified update type.

--*/

{
    CL_ASSERT(UpdateType < GumUpdateMaximum);

    return(GumpSequence);
}


VOID
GumSetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType,
    DWORD Sequence
    )
/*++

Routine Description:

    Sets the current sequence for the specified global update.

Arguments:

    UpdateType - Supplies the update type whose sequence is to be updated.

    Sequence - Supplies the new sequence number.

Return Value:

    None.

--*/

{
    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumpSequence = Sequence;

}


VOID
GumCommFailure(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    )
/*++

Routine Description:

    Informs the NM that a fatal communication error has occurred trying
    to talk to another node.

Arguments:

    GumInfo - Supplies the update type where the communication failure occurred.

    NodeId - Supplies the node id of the other node.

    ErrorCode - Supplies the error that was returned from RPC

    Wait - if TRUE, this function blocks until the GUM event handler has
           processed the NodeDown notification for the specified node.

           if FALSE, this function returns immediately after notifying NM

Return Value:

    None.

--*/

{
    PGUM_INFO   GumInfo = &GumTable[UpdateType];

    ClRtlLogPrint(LOG_CRITICAL,
               "[GUM] GumCommFailure %1!d! communicating with node %2!d!\n",
               ErrorCode,
               NodeId);


    GumpCommFailure(GumInfo, NodeId, ErrorCode, Wait);
}



DWORD
WINAPI
GumEndJoinUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Conditionally sends a join update to all active nodes in the
    cluster. If the clusterwise sequence number matches the supplied
    sequence number, all registered update handlers for the specified
    UpdateType are called on each node. Any registered update handlers
    for the current node will be called on the same thread. This is
    useful for correct synchronization of the data structures to be updated.

    As each node receives the join update, the sending node will be
    added to the list of nodes registered to receive any future updates
    of this type.

    The normal usage of this routine is as follows:
         joining node gets current sequence number from GumBeginJoinUpdate
         joining node gets current cluster state from another cluster node
         joining node issues GumEndJoinUpdate to add itself to every node's
          update list.
         If GumEndJoinUpdate fails, try again

Arguments:

    Sequence - Supplies the sequence number obtained from GumGetCurrentSequence.

    UpdateType - Supplies the type of update. This determines which update handlers
        will be called

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to be passed to the
        update handlers

    Buffer - Supplies a pointer to the update buffer to be passed to the update
        handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/
{
    DWORD       Status=RPC_S_OK;
    DWORD       i;
    PGUM_INFO   GumInfo;
    DWORD       MyNodeId;
    DWORD       LockerNode=(DWORD)-1;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    LockerNode = GumpLockerNode;

    //SS: bug can we be the locker node at this point in time?
    //CL_ASSERT(LockerNode != MyNodeId);
    //
    // Verify that the locker node allows us to finish the join update
    //
    if (LockerNode != MyNodeId)
    {

        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumEndJoinUpdate: attempting update\ttype %1!u! context %2!u! sequence %3!u!\n",
                   UpdateType,
                   Context,
                   Sequence);
        //SS: what if the joiner node acquires the lock but dies after
        //will the remaining cluster continue to function ??
        //We need to make sure that node down events are generated
        //for this node as soon as the first gumbeginjoinupdate call
        //is made
        NmStartRpc(LockerNode);
        Status = GumAttemptJoinUpdate(GumpRpcBindings[LockerNode],
                                      NmGetNodeId(NmLocalNode),
                                      UpdateType,
                                      Context,
                                      Sequence,
                                      BufferLength,
                                      Buffer);
        NmEndRpc(LockerNode);
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] Join attempt for type %1!d! failed %2!d!\n",
                       UpdateType,
                       Status);
            NmDumpRpcExtErrorInfo(Status);
            return(Status);
        }
        //if the locker node dies, should we retry with the locker node?
        //In this case, the locker node may be different
        //now from when GumBeginJoinUpdate() is called.
        //SS: we fail the join instead and just retry the whole process
        //instead of calling GumpCommFailure() to kill the locker here.
        // This way the existing cluster continues and the joining node
        // takes a hit which is probably a good thing
    }
    else
    {
        //SS: can we select ourselves as the locker while
        //we havent finished the join completely
        //SS: can others?
        //Is that valid
        Status = ERROR_REQUEST_ABORTED;
        return(Status);
    }
    //  If the joining node dies after having acquired the lock,
    //  then a node down event MUST be generated so that the GUM
    //  lock can be released and the rest of the cluster can continue.
    //
    // Now Dispatch the update to all other nodes, except ourself.
    //
    for (i=LockerNode+1; i != LockerNode; i++)
    {
        if (i == (NmMaxNodeId + 1))
        {
            i=ClusterMinNodeId;
            if (i==LockerNode)
            {
                break;
            }
        }

        if (GumInfo->ActiveNode[i])
        {

            //skip yourself
            if (i != MyNodeId)
            {
                CL_ASSERT(GumpRpcBindings[i] != NULL);
                ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumEndJoinUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);

                NmStartRpc(i);
                Status = GumJoinUpdateNode(GumpRpcBindings[i],
                                           NmGetNodeId(NmLocalNode),
                                           UpdateType,
                                           Context,
                                           Sequence,
                                           BufferLength,
                                           Buffer);
                NmEndRpc(i);
                if (Status != ERROR_SUCCESS)
                {
                    //we dont shoot that node, since we are the ones who is joining
                    //However now its tables differ from the locker node's tables
                    //Instead we will release the gum lock and abort
                    // the join process.  This joining node should then
                    // be removed from the locker node's tables for update.
                    //
                    ClRtlLogPrint(LOG_NOISE,
                        "[GUM] GumEndJoinUpdate: GumJoinUpdateNode failed \ttype %1!u! context %2!u! sequence %3!u!\n",
                        UpdateType,
                        Context,
                        Sequence);
                    NmDumpRpcExtErrorInfo(Status);
                    break;
                }
            }
        }
    }

    CL_ASSERT(LockerNode != (DWORD)-1);

    if (Status != ERROR_SUCCESS)
    {
        goto EndJoinUnlock;
    }

    //
    // All nodes have been updated. Update our sequence and send the unlocking update.
    //
    GumTable[UpdateType].Joined = TRUE;
    GumpSequence = Sequence+1;

EndJoinUnlock:
    //SS  what if the locker node has died since then
    //we should make sure somebody unlocks and keeps the cluster going
    try {
        NmStartRpc(LockerNode);
        GumUnlockUpdate(GumpRpcBindings[LockerNode], UpdateType, Sequence);
        NmEndRpc(LockerNode);
    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        //
        // The locker node has crashed. Notify the NM, it will call our
        // notification routine to select a new locker node. Then retry
        // the unlock on the new locker node.
        // SS: changed to not retry unlocks..the new locker node will
        // unlock after propagating this change in any case.
        //
        NmEndRpc(LockerNode);
        Status = GetExceptionCode();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] GumEndJoinUpdate: Unlocking update to node %1!d! failed with %2!d!\n",
                   LockerNode,
                   Status);
        //instead of killing the locker node in the existing cluster which
        //we are trying to join, return a failure code which will abort the join
        //process. Since this is the locking node, when this node goes down the
        //new locker node should release the lock

        NmDumpRpcExtErrorInfo(Status);
    }


    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumEndJoinUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               UpdateType,
               Context);

    return(Status);
}


VOID
GumpReUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD EndId
    )
/*++

Routine Description:

    Reissues a GUM update to all nodes. This is used in the event of
    a failure.

Arguments:

    UpdateType - Supplies the update type that should be reissued.

    EndId - Supplies the last node ID to be updated. This is usually the node
            ID of the failed node.

Return Value:

    None

--*/

{
    PGUM_INFO GumInfo = &GumTable[UpdateType];
    DWORD MyId = NmGetNodeId(NmLocalNode);
    DWORD i, seq;
    DWORD Status;

    // This node must be the locker.
    // The lock must be held, and it must be held by this node
    //
    CL_ASSERT(GumpLockerNode == MyId);
    CL_ASSERT(GumpLockingNode == MyId);

    //if there is no valid update to be propagated
    //SS: The gum lock still needs to be freed since it is always acquired
    //before this function is called
    if (UpdateType == GumUpdateMaximum)
        goto ReleaseLock;

    //
    // Grap the sendupdate lock to serialize with a concurrent update on
    // on this node
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    seq = GumpSequence - 1;
    LeaveCriticalSection(&GumpSendUpdateLock);

 again:
    ClRtlLogPrint(LOG_UNUSUAL,
	       "[GUM] GumpReUpdate reissuing last update for send type %1!d!\n",
		UpdateType);

    for (i=MyId+1; i != EndId; i++) {
    	if (i == (NmMaxNodeId +1)) {
    	    i=ClusterMinNodeId;
    	    if (i==EndId) {
    		break;
    	    }
    	}

    	if (GumInfo->ActiveNode[i]) {
    	    //
    	    // Dispatch the update to the specified node.
    	    //
    	    ClRtlLogPrint(LOG_NOISE,
    		       "[GUM] GumpReUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
    			seq,
    			UpdateType,
    			GumpLastContext,
    			i);

    	    try {

                NmStartRpc(i);
                if (GumpLastBufferValid != FALSE) {
                    Status = GumUpdateNode(GumpReplayRpcBindings[i],
                                UpdateType,
                                GumpLastContext,
                                seq,
                                GumpLastBufferLength,
                                GumpLastBuffer);
                } else {
                    // replay end join
                    // since we also ignore other updates, we should
                    // be calling gumupdatenode for those..however
                    // calling gumjoinupdatenode seems to do the job
                    // for signalling the other nodes to bump up 
                    // their sequence number without processing the update
                    Status = GumJoinUpdateNode(GumpReplayRpcBindings[i],
                    	       -1, // signal replay
                    	       UpdateType,
                    	       GumpLastContext,
                    	       seq,
                    	       GumpLastBufferLength,
                    	       GumpLastBuffer);
        		}
                NmEndRpc(i);
    	    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                NmEndRpc(i);
                Status = GetExceptionCode();
    	    }
    	    //
    	    // If the update on the other node failed, then the
    	    // other node must now be out of the cluster since the
    	    // update has already completed on the locker node.
    	    //
    	    if (Status != ERROR_SUCCESS && Status != ERROR_CLUSTER_DATABASE_SEQMISMATCH) {
                ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] GumpReUpdate: Update on node %1!d! failed with %2!d! when it must succeed\n",
                    i,
                    Status);
                        
                NmDumpRpcExtErrorInfo(Status);

                GumpCommFailure(GumInfo,
                	i,
                	Status,
                	TRUE);
    	    }
        }
    }


    //
    // At this point we know that all nodes don't have received our replay
    // and no outstanding sends are in progress. However, a send could have
    // arrived in this node and the sender died after that we are the only
    // node that has it. Since we are the locker and lockingnode we
    // have to replay again if that happened.
    EnterCriticalSection(&GumpSendUpdateLock);
    if (seq != (GumpSequence - 1)) {
	    seq = GumpSequence - 1;
	    LeaveCriticalSection(&GumpSendUpdateLock);
	    goto again;
    }
    LeaveCriticalSection(&GumpSendUpdateLock);

ReleaseLock:
    //
    // The update has been delivered to all nodes. Unlock now.
    //
    GumpDoUnlockingUpdate(UpdateType, GumpSequence-1);

}


VOID
GumpCommFailure(
    IN PGUM_INFO GumInfo,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    )
/*++

Routine Description:

    Informs the NM that a fatal communication error has occurred trying
    to talk to another node.

Arguments:

    GumInfo - Supplies the update type where the communication failure occurred.

    NodeId - Supplies the node id of the other node.

    ErrorCode - Supplies the error that was returned from RPC

    Wait - if TRUE, this function blocks until the GUM event handler has
           processed the NodeDown notification for the specified node.

           if FALSE, this function returns immediately after notifying NM

Return Value:

    None.

--*/

{
    DWORD     dwCur;

    ClRtlLogPrint(LOG_CRITICAL,
               "[GUM] GumpCommFailure %1!d! communicating with node %2!d!\n",
               ErrorCode,
               NodeId);

    // This is a hack to check if we are shutting down. See bug 88411
    if (ErrorCode == ERROR_SHUTDOWN_IN_PROGRESS) {
	    // if we are shutting down, just kill self
	    // set to our node id
	    NodeId = NmGetNodeId(NmLocalNode);
    }

	    
    //
    // Get current generation number
    //
    if (Wait) {
        dwCur = GumpGetNodeGenNum(GumInfo, NodeId);
    }

    NmAdviseNodeFailure(NodeId, ErrorCode);

    if (Wait) {
            //
            // Wait for this node to be declared down and
            // GumpEventHandler to mark it as inactive.
            //

            GumpWaitNodeDown(NodeId, dwCur);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    Routines for registering for global updates and dispensing
    received global updates to the routines that have registered
    for them.

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"



VOID
GumReceiveUpdates(
    IN BOOL                         IsJoining,
    IN GUM_UPDATE_TYPE              UpdateType,
    IN PGUM_UPDATE_ROUTINE          UpdateRoutine,
    IN PGUM_LOG_ROUTINE             LogRoutine,
    IN DWORD                        DispatchCount,
    IN OPTIONAL PGUM_DISPATCH_ENTRY DispatchTable,
    IN OPTIONAL PGUM_VOTE_ROUTINE   VoteRoutine
    )

/*++

Routine Description:

    Registers a handler for a particular global update type.

Arguments:

    IsJoining - TRUE if the current node is joining. If this is true,
        updates will not be delivered until GumEndJoinUpdate has
        completed successfully. If this is FALSE, updates will be
        delivered immediately.

    UpdateType - Supplies the update type to register for.

    UpdateRoutine - Supplies the routine to be called when a global update
        of the specified type occurs.

    LogRoutine - If supplied, it specifies the logging routine that must be called to
        log transaction to the quorum logs.

    DispatchCount - Supplies the number of entries in the dispatch table.
        This can be zero.

    DispatchTable - Supplies a pointer to the dispatch table. If this is
        NULL, no updates of this type will be automatically dispatched.

    VoteRoutine - If supplied, this specifies the routine to be called when
        a vote for this update type is requested.

Return Value:

    None.

--*/

{
    PGUM_RECEIVER Receiver;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    Receiver = LocalAlloc(LMEM_FIXED, sizeof(GUM_RECEIVER));
    if (Receiver == NULL) {
        CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    Receiver->UpdateRoutine = UpdateRoutine;
    Receiver->LogRoutine = LogRoutine;
    Receiver->DispatchCount = DispatchCount;
    Receiver->DispatchTable = DispatchTable;
    Receiver->VoteRoutine = VoteRoutine;
    //
    //    John Vert (jvert) 8/2/1996
    //    remove below debug print if we ever want to support
    //    multiple GUM handlers.
    //
    if (GumTable[UpdateType].Receivers != NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] Multiple GUM handlers registered for UpdateType %1!d!\n",
                   UpdateType);
    }

    EnterCriticalSection(&GumpLock);
    Receiver->Next = GumTable[UpdateType].Receivers;
    GumTable[UpdateType].Receivers = Receiver;
    if (IsJoining) {
        GumTable[UpdateType].Joined = FALSE;
    } else {
        GumTable[UpdateType].Joined = TRUE;
    }
    LeaveCriticalSection(&GumpLock);
}


VOID
GumIgnoreUpdates(
    IN GUM_UPDATE_TYPE UpdateType,
    IN PGUM_UPDATE_ROUTINE UpdateRoutine
    )
/*++

Routine Description:

    Removes an update handler from the GUM table. This is the opposite
    of GumReceiveUpdates

Arguments:

    UpdateType - Supplies the update type to register for.

    UpdateRoutine - Supplies the routine to be called when a global update
        of the specified type occurs.

Return Value:

    None

--*/

{
    PGUM_RECEIVER Receiver;
    PGUM_RECEIVER *Last;

    //
    // We cannot safely de-registr from Gum... ASSERT if anyone calls this
    // function.
    //
    CL_ASSERT(FALSE);

    //
    // Walk the list of receivers until we find the specified UpdateRoutine
    //
    Last = &GumTable[UpdateType].Receivers;
    EnterCriticalSection(&GumpLock);
    while ((Receiver = *Last) != NULL) {
        if (Receiver->UpdateRoutine == UpdateRoutine) {
            *Last = Receiver->Next;
            break;
        }
        Last = &Receiver->Next;
    }
    LeaveCriticalSection(&GumpLock);
    if (Receiver != NULL) {
        LocalFree(Receiver);
    }

}


DWORD
WINAPI
GumpDispatchUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Context,
    IN BOOL IsLocker,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PUCHAR Buffer
    )

/*++

Routine Description:

    Dispatches a GUM update to all the registered handlers on this node

Arguments:

    Sequence - Supplies the GUM sequence number for the update

    Type - Supplies the GUM_UPDATE_TYPE for the update

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

        IsLocker - Specifies if this is a locker node.

    SourceNode - Specifies whether the update originated on this node or not.

    BufferLength - Supplies the length of the update data

    Buffer - Supplies a pointer to the update data

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    PGUM_INFO GumInfo;
    PGUM_RECEIVER Receiver;
    DWORD Status = ERROR_SUCCESS;
    PGUM_DISPATCH_ENTRY Dispatch;

    GumInfo = &GumTable[Type];

    if (GumInfo->Joined) {
        Receiver = GumInfo->Receivers;
        while (Receiver != NULL) {
            if (Receiver->LogRoutine) {
                Status = (*(Receiver->LogRoutine))(PRE_GUM_DISPATCH, GumpSequence,
                    Context, Buffer, BufferLength);
                if (Status != ERROR_SUCCESS)
                {
                    return(Status);
                }
            }

            try {
                if ((Receiver->DispatchTable == NULL) ||
                    (Receiver->DispatchCount < Context) ||
                    (Receiver->DispatchTable[Context].Dispatch1 == NULL)) {
                    Status = (Receiver->UpdateRoutine)(Context,
                                                       SourceNode,
                                                       BufferLength,
                                                       Buffer);
                } else {
                    Dispatch = &Receiver->DispatchTable[Context];
                    //
                    // This update should be unmarshalled and dispatched to the
                    // appropriate dispatch routine. The format generated by
                    // GumpMarshallArgs is an array of offsets into the buffer,
                    // followed by the actual args. The dispatch table is
                    // responsible for recording the number of arguments.
                    //
                    CL_ASSERT(Dispatch->ArgCount <= GUM_MAX_DISPATCH_ARGS);
                    CL_ASSERT(Dispatch->ArgCount != 0);
                    switch (Dispatch->ArgCount) {
                        case 1:
                            Status = (Dispatch->Dispatch1)(SourceNode,
                                                           GET_ARG(Buffer,0));
                            break;
                        case 2:
                            Status = (Dispatch->Dispatch2)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1));
                            break;
                        case 3:
                            Status = (Dispatch->Dispatch3)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1),
                                                           GET_ARG(Buffer,2));
                            break;
                        case 4:
                            Status = (Dispatch->Dispatch4)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1),
                                                           GET_ARG(Buffer,2),
                                                           GET_ARG(Buffer,3));
                            break;
                        case 5:
                            Status = (Dispatch->Dispatch5)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1),
                                                           GET_ARG(Buffer,2),
                                                           GET_ARG(Buffer,3),
                                                           GET_ARG(Buffer,4));
                            break;
                        default:
                            CL_ASSERT(FALSE);
                    }
                }
            } except (CL_UNEXPECTED_ERROR(GetExceptionCode()),
                      EXCEPTION_EXECUTE_HANDLER
                     )
            {
                Status = GetExceptionCode();
            }
            if (Status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[GUM] Update routine %1!d! failed with status %2!d!\n",
                           Receiver->UpdateRoutine,
                           Status);
                break;
            }

            if (Receiver->LogRoutine) {
                if (IsLocker && (Status == ERROR_SUCCESS))
                    (*(Receiver->LogRoutine))(POST_GUM_DISPATCH, GumpSequence,
                        Context, Buffer, BufferLength);
                if (!IsLocker)
                    (*(Receiver->LogRoutine))(POST_GUM_DISPATCH, GumpSequence,
                        Context, Buffer, BufferLength);
            }
            Receiver = Receiver->Next;

        }
    }

    if (Status == ERROR_SUCCESS) {
        GumpSequence += 1;
    }
    return(Status);
}

//rod wants to call this a mandatory update instead of H...word
//some times reupdates get delivered in different views on different
//nodes causing a problem
//For instance, a locker node might see an update and complete it 
//successfully in one view but when it replays it in another view
//other nodes may not be able to complete it successfully and may be 
//banished.
//in one particular case, the locker node approved of a node join
//because it had finished the node down processing for that node.
//subsequently another node and hence the joiner went down.
//the locker node tried to replay the approval update and banished
//other nodes that were seeing this update after the joiner the joiner
//went down for the second time.
//The correct solution would involve GUM delivering the node down
//message as a gum update and delivering it in the same order with
//respect to other messages on all nodes
//However this will require some restructuring of code which
//cant be done in this time frame(for dtc) hence we are using
//this workaround
//this workaround is safe for gums initiated by the joiner  node during
//the join process
void GumpIgnoreSomeUpdatesOnReupdate(
    IN DWORD Type, 
    IN DWORD Context)
{
    if ((Type == GumUpdateFailoverManager) && 
        (Context == FmUpdateApproveJoin))
        GumpLastBufferValid = FALSE;
}


error_status_t
s_GumUpdateNode(
    IN handle_t IDL_handle,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Server side routine for GumUpdateNode. This is the side that
    receives the update and dispatches it to the appropriate
    handlers.

Arguments:

    IDL_handle - RPC binding handle, not used

    Type - Supplies the GUM_UPDATE_TYPE

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    Sequence - Supplies the GUM sequence number for the specified update type

    BufferLength - Supplies the length of the update data

    Buffer - Supplies a pointer to the update data.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    ERROR_CLUSTER_DATABASE_SEQMISMATCH if the GUM sequence number is invalid

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;

    //
    // We need to grap the gumsendupdate lock to serialize send/replay
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    GumInfo = &GumTable[Type];
    if (Sequence != GumpSequence) {

        MIDL_user_free(Buffer);
        if (Sequence+1 == GumpSequence) {
            //
            // This is a duplicate of a previously seen update, probably due to
            // a node failure during GUM. Return success since we have already done
            // this.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] s_GumUpdateNode: Sequence %1!u! is a duplicate of last sequence for Type %2!u!\n",
                       Sequence,
                       Type);

	        LeaveCriticalSection(&GumpSendUpdateLock);
            return(ERROR_SUCCESS);
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] s_GumUpdateNode: Sequence %1!u! does not match current %2!u! for Type %3!u!\n",
                       Sequence,
                       GumpSequence,
                       Type);
	        LeaveCriticalSection(&GumpSendUpdateLock);
            //
            // [GorN] 10/07/1999. The following code will allow the test program
            // to recognize this sitiation and to restart clustering service
            //
            if( NmGetExtendedNodeState( NmLocalNode ) != ClusterNodeUp){
                CsInconsistencyHalt(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
            }
            return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
        }
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumUpdateNode: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);
        //SS: set IsLocker to FALSE,
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] Cluster state inconsistency check\n");
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] s_GumUpdateNode update routine type %1!u! context %2!d! failed with error %3!d! on non-locker node\n",
                   Type,
                   Context,
                   Status);
        CL_UNEXPECTED_ERROR( Status );
        MIDL_user_free(Buffer);
	    LeaveCriticalSection(&GumpSendUpdateLock);
        return(Status);

    }
    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumUpdateNode: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);
    if (GumpLastBuffer != NULL) {
        MIDL_user_free(GumpLastBuffer);
    }
    GumpLastBuffer = Buffer;
    GumpLastContext = Context;
    GumpLastBufferLength = BufferLength;
    GumpLastUpdateType = Type;
    GumpLastBufferValid = TRUE;
    
    GumpIgnoreSomeUpdatesOnReupdate(GumpLastUpdateType, GumpLastContext);
        
    LeaveCriticalSection(&GumpSendUpdateLock);
    return(Status);
}


error_status_t
s_GumGetNodeSequence(
    IN handle_t IDL_handle,
    IN DWORD Type,
    OUT LPDWORD Sequence,
    OUT LPDWORD LockerNodeId,
    OUT PGUM_NODE_LIST *ReturnNodeList
    )

/*++

Routine Description:

    Returns the node's current GUM sequence number for the specified type

Arguments:

    IDL_handle - Supplies the RPC binding handle, not used

    Type - Supplies the GUM_UPDATE_TYPE

    Sequence - Returns the sequence number for the specified GUM_UPDATE_TYPE

    LockerNodeId - Returns the current locker node

    ReturnNodeList - Returns the list of active nodes

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD i;
    DWORD NodeCount;
    PGUM_INFO GumInfo;
    PGUM_NODE_LIST NodeList;

    CL_ASSERT(Type < GumUpdateMaximum);
    GumInfo = &GumTable[Type];

    NodeCount = 0;
    *Sequence = 0;          // In case of failure set sequence to 0

    EnterCriticalSection(&GumpUpdateLock);

    //
    // Count up the number of nodes in the list.
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i] == TRUE) {
            ++NodeCount;
        }
    }
    CL_ASSERT(NodeCount > 0);       // must be at least us in the list.

    //
    // Allocate node list
    //
    NodeList = MIDL_user_allocate(sizeof(GUM_NODE_LIST) + (NodeCount-1)*sizeof(DWORD));
    if (NodeList == NULL) {
        LeaveCriticalSection(&GumpUpdateLock);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    NodeList->NodeCount = NodeCount;
    NodeCount = 0;

    //
    // Fill in the node id array to be returned.
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i] == TRUE) {
            NodeList->NodeId[NodeCount] = i;
            ++NodeCount;
        }
    }

    *ReturnNodeList = NodeList;
    *Sequence = GumpSequence;
    *LockerNodeId = GumpLockerNode;

    LeaveCriticalSection(&GumpUpdateLock);

    return(ERROR_SUCCESS);
}


error_status_t
s_GumQueueLockingUpdate(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    OUT LPDWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Queues a locking update. When the lock can be acquired, the update will
    be issued and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    IsLocker - is this is the locker node

    Sequence - Returns the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;
    DWORD dwGennum;

    GumInfo = &GumTable[Type];

    //
    // Get current node generation number
    //
    dwGennum = GumpGetNodeGenNum(GumInfo, NodeId);


    Status = GumpDoLockingUpdate(Type, NodeId, Sequence);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] s_GumQueueLockingUpdate: GumpDoLockingUpdate failed %1!u!\n",
                   Status);
        MIDL_user_free(Buffer);
        return(Status);
    }

    //
    // If the node that is granted ownership is no longer a member of the
    // cluster or the remote node went down and came back up again, give it up.
    //
    if (GumpDispatchStart(NodeId, dwGennum) != TRUE)
    {
        //skip the dispatch and unlock the lock
        ClRtlLogPrint(LOG_CRITICAL,
               "[GUM] s_GumQueueLockingUpdate: The new locker %1!u! no longer belongs to the cluster\n",
               NodeId);
        Status = ERROR_CLUSTER_NODE_NOT_READY;

        //
        // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
        // failed and did not increment the sequence number.
        //
        GumpDoUnlockingUpdate(Type, *Sequence - 1);
        MIDL_user_free(Buffer);
        return(Status);

    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingUpdate: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               *Sequence,
               Type,
               Context);
        //SS: Set IsLocker to TRUE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                TRUE,
                                FALSE,
                                BufferLength,
                                Buffer);

    if (Status != ERROR_SUCCESS) {
        //
        // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
        // failed and did not increment the sequence number.
        //
        GumpDispatchAbort();
        GumpDoUnlockingUpdate(Type, *Sequence - 1);
	if (Buffer != NULL)
	    MIDL_user_free(Buffer);
    } else {
        if (GumpLastBuffer != NULL) {
            MIDL_user_free(GumpLastBuffer);
        }
        GumpLastBuffer = Buffer;
        GumpLastContext = Context;
        GumpLastBufferLength = BufferLength;
        GumpLastUpdateType = Type;
        GumpLastBufferValid = TRUE;
        GumpIgnoreSomeUpdatesOnReupdate(GumpLastUpdateType, GumpLastContext);
    	//
    	// Just in case our client dies
    	//
    	GumpDispatchEnd(NodeId, dwGennum);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingUpdate: completed update seq %1!u!\ttype %2!u! context %3!u! result %4!u!\n",
               *Sequence,
               Type,
               Context,
               Status);

    return(Status);

}


#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.
    N.B. The below code does not handle locker node failures

error_status_t
s_GumQueueLockingPost(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    OUT LPDWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    IN DWORD ActualBuffer
    )

/*++

Routine Description:

    Queues a post update.

    If the GUM lock can be immediately acquired, this routine
    behaves exactly like GumQueueLockingUpdate and returns
    ERROR_SUCCESS.

    If the GUM lock is held, this routine queues an asynchronous
    wait block onto the GUM queue and returns ERROR_IO_PENDING.
    When the wait block is removed from the GUM queue, the unlocking
    thread will call GumpDeliverPostUpdate on the specified node
    and supply the passed in context. The calling node can then
    deliver the update.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Returns the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

    ActualBuffer - Supplies the value of the pointer to the GUM data on the
        client side. This will be returned to the callback if this update
        is completed asynchronously.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    Status = GumpDoLockingPost(Type, NodeId, Sequence, Context, BufferLength,
        ActualBuffer, Buffer);
    if (Status != ERROR_SUCCESS) {
        if (Status != ERROR_IO_PENDING) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] s_GumQueueLockingPost: GumpDoLockingPost failed %1!u!\n",
                       Status);
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] s_GumQueueLockingPost: GumpDoLockingPost pended update type %1!u! context %2!u!\n",
                       Type,
                       Context);
        }
        return(Status);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingPost: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               *Sequence,
               Type,
               Context);
        //SS: setting IsLocker to FALSE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);
    CL_ASSERT(Status == ERROR_SUCCESS);     // posts must never fail

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingPost: completed update seq %1!u!\ttype %2!u! context %3!u! result %4!u!\n",
               *Sequence,
               Type,
               Context,
               Status);
    MIDL_user_free(Buffer);

    return(Status);

}
#endif


error_status_t
s_GumAttemptLockingUpdate(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Attempts a locking update. If the supplied sequence number
    matches and the update lock is not already held, the update
    will be issued and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    if (!GumpTryLockingUpdate(Type, NodeId, Sequence)) {
        MIDL_user_free(Buffer);
        return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
    }

        //SS: setting Islocker false
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);
    if (Status != ERROR_SUCCESS) {
        //
        // The update has failed on this node, unlock here
        // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
        // failed and did not increment the sequence number.
        //
        GumpDoUnlockingUpdate(Type, Sequence-1);
    }

    MIDL_user_free(Buffer);
    return(Status);

}


error_status_t
s_GumUnlockUpdate(
    IN handle_t IDL_handle,
    IN DWORD Type,
    IN DWORD Sequence
    )

/*++

Routine Description:

    Unlocks a locked update.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Sequence - Supplies the sequence that the GUM update was issued with

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    GumpDoUnlockingUpdate(Type, Sequence);

    return(ERROR_SUCCESS);
}


error_status_t
s_GumJoinUpdateNode(
    IN handle_t IDL_handle,
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Server side routine for GumJoinUpdateNode. This is the side that
    receives the update, adds the node to the update list, and dispatches
    it to the appropriate handlers.

Arguments:

    IDL_handle - RPC binding handle, not used

    JoiningId - Supplies the nodeid of the joining node.

    Type - Supplies the GUM_UPDATE_TYPE

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    Sequence - Supplies the GUM sequence number for the specified update type

    BufferLength - Supplies the length of the update data

    Buffer - Supplies a pointer to the update data.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    ERROR_INVALID_HANDLE if the GUM sequence number is invalid

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;

    GumInfo = &GumTable[Type];

    // sync with replay/updates
    EnterCriticalSection(&GumpSendUpdateLock);
    // [ahm] This is an aborted endjoin, we just resync our seq. with master.
    // This should be its own GumUpdateSequence RPC, but for now it ok to
    // to this.
    if (JoiningId == (DWORD) -1) 
    {
    	// we must be off by one at the most
    	if (Sequence+1 != GumpSequence) 
    	{
    	    CL_ASSERT(Sequence == GumpSequence);
    	    GumpSequence = Sequence+1;
    	    ClRtlLogPrint(LOG_UNUSUAL,
                "[GUM] s_GumJoinUpdateNode: pretend we have seen Sequence %1!u!\n",
                Sequence);
        }
	    Status = 0;
	    goto done;
    }
	
    if (Sequence != GumpSequence) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] s_GumJoinUpdateNode: Sequence %1!u! does not match current %2!u! for Type %3!u!\n",
                   Sequence,
                   GumpSequence,
                   Type);
	    LeaveCriticalSection(&GumpSendUpdateLock);
        MIDL_user_free(Buffer);
        return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumJoinUpdateNode: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);

    CL_ASSERT(NmIsValidNodeId(JoiningId));
    CL_ASSERT(GumpRpcBindings[JoiningId] != NULL);
    CL_ASSERT(GumpReplayRpcBindings[JoiningId] != NULL);

    ClRtlLogPrint(LOG_UNUSUAL,
               "[GUM] s_GumJoinUpdateNode Adding node %1!d! to update list for GUM type %2!d!\n",
               JoiningId,
               Type);

        //SS: setting IsLocker to FALSE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);

    // [ahm]: We need to make sure the node is still up, otherwise ignore
    EnterCriticalSection(&GumpLock);
    if (MMIsNodeUp(JoiningId) == TRUE) {
	    GumTable[Type].ActiveNode[JoiningId] = TRUE;
    }
    LeaveCriticalSection(&GumpLock);

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumJoinUpdateNode: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);

 done:
    if (GumpLastBuffer != NULL) {
	    MIDL_user_free(GumpLastBuffer);
    }

    GumpLastBuffer = NULL;
    GumpLastContext = Context;
    GumpLastBufferLength = 0;
    GumpLastUpdateType = Type;
    GumpLastBufferValid = FALSE;

    LeaveCriticalSection(&GumpSendUpdateLock);

    MIDL_user_free(Buffer);
    return(Status);
}


error_status_t
s_GumAttemptJoinUpdate(
    IN handle_t IDL_handle,
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Attempts a locking join update. If the supplied sequence number
    matches and the update lock is not already held, the join update
    will be issued, the joining node will be added to the update list,
    and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    JoiningId - Supplies the nodeid of the joining node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;

    GumInfo = &GumTable[Type];

    if (!GumpTryLockingUpdate(Type, JoiningId, Sequence)) {
        MIDL_user_free(Buffer);
        return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
    }

    // sync with replay/updates
    EnterCriticalSection(&GumpSendUpdateLock);

        //SS: set IsLocker to TRUE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                TRUE,
                                FALSE,
                                BufferLength,
                                Buffer);
    if (Status != ERROR_SUCCESS) {
        //
        // The update has failed on this node, unlock here
        // Note we have to use Sequence-1 for the unlock because
        // GumpDispatchUpdate failed and did not increment the
        // sequence number.
        //
        GumpDoUnlockingUpdate(Type, Sequence-1);
    } else {
        CL_ASSERT(NmIsValidNodeId(JoiningId));
        CL_ASSERT(GumpRpcBindings[JoiningId] != NULL);
        CL_ASSERT(GumpReplayRpcBindings[JoiningId] != NULL);

        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] s_GumAttemptJoinUpdate Adding node %1!d! to update list for GUM type %2!d!\n",
                   JoiningId,
                   Type);

    	// [ahm]: We need to make sure the node is still up, otherwise ignore
    	EnterCriticalSection(&GumpLock);
    	if (MMIsNodeUp(JoiningId) == TRUE) {
    	    GumTable[Type].ActiveNode[JoiningId] = TRUE;
    	}
    	LeaveCriticalSection(&GumpLock);
        if (GumpLastBuffer != NULL) {
            MIDL_user_free(GumpLastBuffer);
        }
        GumpLastBuffer = NULL;
        GumpLastContext = Context;
        GumpLastBufferLength = 0;
        GumpLastUpdateType = Type;
	    GumpLastBufferValid = FALSE;
    }
    LeaveCriticalSection(&GumpSendUpdateLock);
    MIDL_user_free(Buffer);

    return(Status);

}


/****
@func       DWORD | s_GumCollectVoteFromNode| The is the server side
            routine for GumCollectVoteFromNode.

@parm       IN IDL_handle | RPC binding handle, not used.

@parm       IN GUM_UPDATE_TYPE | Type |  The update type for which this
            vote is requested.

@parn       IN DWORD | dwContext | This specifies the context related to the
            Updatetype for which a vote is being seeked.

@parm       IN DWORD | dwInputBufLength | The length of the input buffer
            passed in via pInputBuffer.

@parm       IN PVOID | pInputBuffer | A pointer to the input buffer via
            which the input data for the vote is supplied.

@parm       IN DWORD | dwVoteLength | The length of the vote.  This is
            also the size of the buffer to which pBuf points to.

@parm       OUT PUCHAR | pVoteBuf|  A pointer to a buffer in which
            this node may cast its vote.  The length of the vote must
            not exceed dwVoteLength.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       A node collecting votes invokes this routine to collect a vote
            from the remote node.  This routine simply invokes GumpDispatchVote().

@xref       <f GumpCollectVote> <f GumpDispatchVote>
****/
DWORD
WINAPI
s_GumCollectVoteFromNode(
    IN handle_t IDL_handle,
    IN  DWORD            UpdateType,
    IN  DWORD            dwContext,
    IN  DWORD            dwInputBufLength,
    IN  PUCHAR           pInputBuf,
    IN  DWORD            dwVoteLength,
    OUT PUCHAR           pVoteBuf
    )
{
    DWORD   dwStatus;

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumCollectVote: collecting vote for type %1!u!\tcontext %2!u!\n",
               UpdateType,
               dwContext);

    dwStatus = GumpDispatchVote(UpdateType,
                   dwContext,
                   dwInputBufLength,
                   pInputBuf,
                   dwVoteLength,
                   pVoteBuf);

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumCollectVote: completed, VoteStatus=%1!u!\n",
               dwStatus);

    return(dwStatus);
}



#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.


error_status_t
s_GumDeliverPostCallback(
    IN handle_t IDL_handle,
    IN DWORD FirstNode,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN DWORD Buffer
    )
/*++

Routine Description:

    Callback function used to deliver a posted update that was
    queued.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    FirstNode - Supplies the node ID where the posts should start.
        This is generally the LockerNode+1.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.


Return Value:

    ERROR_SUCCESS

--*/

{

    GumpDeliverPosts(FirstNode,
                     Type,
                     Sequence,
                     Context,
                     BufferLength,
                     (PVOID)Buffer);
    return(ERROR_SUCCESS);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\locker.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    locker.c

Abstract:

    Routines for managing the locker node of the GUM component.

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"


DWORD
GumpDoLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    OUT LPDWORD Sequence
    )

/*++

Routine Description:

    Waits for the GUM lock, captures the sequence number, and issues
    the update on the current node.

Arguments:

    Type - Supplies the type of update

    NodeId - Supplies the node id of the locking node.

    Sequence - Returns the sequence number the update will be issued with

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PGUM_INFO GumInfo;

    CL_ASSERT(Type < GumUpdateMaximum);

    GumInfo = &GumTable[Type];
    ClRtlLogPrint(LOG_NOISE,"[GUM] Thread 0x%1!x! UpdateLock wait on Type %2!u!\n", GetCurrentThreadId(), Type);

    //
    // Acquire the critical section and see if a GUM update is in progress.
    //
    EnterCriticalSection(&GumpUpdateLock);

    //because the session cleanup is not synchronized with regroup
    //and there is no hold-io and release-io
    if (GumpLockerNode != NmLocalNodeId)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[GUM] GumpDoLockingUpdate : I, node id %1!d!, am not the locker any more\r\n",
                NmLocalNodeId);
        LeaveCriticalSection(&GumpUpdateLock);
        return(ERROR_CLUSTER_GUM_NOT_LOCKER);
    }
    if (GumpLockingNode == -1) {

        //
        // Nobody owns the lock, therefore we can acquire it and continue immediately.
        // There should also be no waiters.
        //
        CL_ASSERT(IsListEmpty(&GumpLockQueue));
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] DoLockingUpdate successful, lock granted to %1!d!\n",
                   NodeId);
        GumpLockingNode = NodeId;
        LeaveCriticalSection(&GumpUpdateLock);
    } else {
        GUM_WAITER WaitBlock;

        //
        // Another node owns the lock. Put ourselves onto the GUM lock queue and
        // release the critical section.
        //
        ClRtlLogPrint(LOG_NOISE,"[GUM] DoLockingUpdate waiting.\n");
        WaitBlock.WaitType = GUM_WAIT_SYNC;
        WaitBlock.NodeId = NodeId;
        WaitBlock.Sync.WakeEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
        CL_ASSERT(WaitBlock.Sync.WakeEvent != NULL);
        InsertTailList(&GumpLockQueue, &WaitBlock.ListEntry);

        LeaveCriticalSection(&GumpUpdateLock);

        //
        // We are on the GUM queue, so just wait for the unlocker to wake
        // us up. When we are woken up, we will have ownership of the GUM
        // lock.
        //
        WaitForSingleObject(WaitBlock.Sync.WakeEvent,INFINITE);
        CloseHandle(WaitBlock.Sync.WakeEvent);
        CL_ASSERT(GumpLockingNode == NodeId);


        ClRtlLogPrint(LOG_NOISE,"[GUM] DoLockingUpdate awakened, Sequence is %1!u!\n", GumpSequence);

    }
    *Sequence = GumpSequence;

    return(ERROR_SUCCESS);
}





#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.

DWORD
GumpDoLockingPost(
    IN GUM_UPDATE_TYPE Type,
    IN LONG NodeId,
    OUT LPDWORD Sequence,
    IN DWORD Context,
    IN DWORD LockerNodeId,
    IN DWORD BufferLength,
    IN DWORD BufferPtr,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Posts an update.

    If the GUM lock can be immediately acquired, this routine
    behaves exactly like GumpDoLockingUpdate and returns
    ERROR_SUCCESS.

    If the GUM lock is held, this routine queues an asynchronous
    wait block onto the GUM queue and returns ERROR_IO_PENDING.
    When the wait block is removed from the GUM queue, the unlocking
    thread will call GumpDeliverPostUpdate on the specified node
    and supply the passed in context. The calling node can then
    deliver the update.

Arguments:

    Type - Supplies the type of update

    NodeId - Supplies the node id of the locking node.

    Context - Supplies a DWORD context to be used by the post callback.

    Sequence - Returns the sequence number the update will be issued with.
        This is only valid if ERROR_SUCCESS is returned.

    Context - Supplies a DWORD context to be used by the post callback.

    BufferLength - Supplies the length of the buffer to be used by the post callback

    BufferPtr - Supplies the pointer to the actual data on the originating node.

    Buffer - Supplies a pointer to the buffer to be used by the post callback.

Return Value:

    ERROR_SUCCESS if the lock was immediately acquired.

    ERROR_IO_PENDING if the request was queued and the caller will be called back.

--*/

{
    PGUM_INFO GumInfo;
    PGUM_WAITER WaitBlock;

    CL_ASSERT(Type < GumUpdateMaximum);

    GumInfo = &GumTable[Type];
    ClRtlLogPrint(LOG_NOISE,"[GUM] Thread 0x%1!x! UpdateLock post on Type %2!u!\n", GetCurrentThreadId(), Type);

    //
    // Acquire the critical section and see if a GUM update is in progress.
    //
    EnterCriticalSection(&GumpUpdateLock);
    if (GumpLockingNode == -1) {

        //
        // Nobody owns the lock, therefore we can acquire it and continue immediately.
        // There should also be no waiters.
        //
        CL_ASSERT(IsListEmpty(&GumpLockQueue));
        ClRtlLogPrint(LOG_NOISE,"[GUM] PostLockingUpdate successful.\n");
        GumpLockingNode = NodeId;
        LeaveCriticalSection(&GumpUpdateLock);
        *Sequence = GumpSequence;
        return(ERROR_SUCCESS);
    }

    //
    // Another node owns the lock. Put ourselves onto the GUM lock queue and
    // release the critical section.
    //
    ClRtlLogPrint(LOG_NOISE,"[GUM] PostLockingUpdate posting.\n");
    WaitBlock = LocalAlloc(LMEM_FIXED, sizeof(GUM_WAITER));
    CL_ASSERT(WaitBlock != NULL);
    if (WaitBlock ! = NULL)
    {
        ClRtlLogPrint(LOG_UNUSUAL,"[GUM] GumpDoLockingPost : LocalAlloc failed\r\n");
        CL_UNEXPECTED_ERROR(GetLastError());
    }

    WaitBlock->WaitType = GUM_WAIT_ASYNC;
    WaitBlock->NodeId = NodeId;
    WaitBlock->Async.Context = Context;
    WaitBlock->Async.LockerNodeId = LockerNodeId;
    WaitBlock->Async.BufferLength = BufferLength;
    WaitBlock->Async.BufferPtr = BufferPtr;
    WaitBlock->Async.Buffer = Buffer;

    InsertTailList(&GumpLockQueue, &WaitBlock->ListEntry);

    LeaveCriticalSection(&GumpUpdateLock);

    //
    // We are on the GUM queue, so just return ERROR_IO_PENDING. When the
    // unlocking thread pulls us off the GUM queue, it will call our callback
    // and the update can proceed.
    //
    return(ERROR_IO_PENDING);
}

#endif


BOOL
GumpTryLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    IN DWORD Sequence
    )

/*++

Routine Description:

    Trys to acquire the GUM lock (does not wait). If successful, compares the
    passed in sequence number to the current sequence number. If they match,
    the locking update is performed.

Arguments:

    Type - Supplies the type of update

    NodeId - Supplies the node id of the locking node.

    Sequence - Supplies the sequence number the update must be issued with

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    PGUM_INFO GumInfo;
    BOOL Success;

    CL_ASSERT(Type < GumUpdateMaximum);

    GumInfo = &GumTable[Type];

    ClRtlLogPrint(LOG_NOISE,"[GUM] GumpTryLockingUpdate Thread 0x%1!x! UpdateLock wait on Type %2!u!\n", GetCurrentThreadId(), Type);

    //
    // Acquire the critical section and see if a GUM update is in progress.
    //
    EnterCriticalSection(&GumpUpdateLock);

    CL_ASSERT(GumpLockerNode == NmLocalNodeId);
    if (GumpSequence != Sequence)
    {

        //
        // The supplied sequence number does not match.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumpTryLockingUpdate supplied sequence %1!d! doesn't match %2!d!\n",
                   Sequence,
                   GumpSequence);
        Success = FALSE;
        goto FnExit;
    }
    if (GumpLockingNode == -1) {

        //
        // Nobody owns the lock, therefore we can acquire it and continue immediately.
        // There should also be no waiters.
        //
        CL_ASSERT(IsListEmpty(&GumpLockQueue));
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpTryLockingUpdate successful. Lock granted to node %1!d!\n",
                   NodeId);
        GumpLockingNode = NodeId;
        Success = TRUE;;
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumpTryLockingUpdate update lock held\n");
        Success = FALSE;
    }

    //release the critical section and return
FnExit:
    LeaveCriticalSection(&GumpUpdateLock);
    return(Success);
}


VOID
GumpDoUnlockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Sequence
    )

/*++

Routine Description:

    Unlocks an earlier locking update

Arguments:

    Type - Supplies the type of update to unlock

    Sequence - Supplies the sequence number to unlock

Return Value:

    None.

--*/

{
    PGUM_INFO GumInfo;
    PGUM_WAITER Waiter;
    PLIST_ENTRY ListEntry;

    //Dont use the gumupdate type in this function, otherwise
    //know that it may be set to gumupdatemaximum in case the
    //forming node fails immediately after a join and the joiner
    //node becomes the locker node.  The new locker might then
    //call reupdate/unlock with type=gumupdatemaximum
    CL_ASSERT(Type <= GumUpdateMaximum);

    GumInfo = &GumTable[Type];

    //SS: should we remove this assert
    //CL_ASSERT(Sequence == GumpSequence - 1);

    if (Sequence != GumpSequence - 1) {
        ClRtlLogPrint(LOG_UNUSUAL,"[GUM] UnlockUpdate Failed Thread 0x%1!x!, Type %2!u!, Sequence %3!u!, Type Sequence %4!u!\n", GetCurrentThreadId(), Type, Sequence, GumpSequence);
        return;
    }

    //
    // Acquire the critical section and see if there are any waiters.
    //
    EnterCriticalSection(&GumpUpdateLock);

    //
    // Pull the next waiter off the queue. If it is an async waiter,
    // issue that update now. If it is a sync waiter, grant ownership
    // of the GUM lock and wake the waiting thread.
    //
    while (!IsListEmpty(&GumpLockQueue)) {
        ListEntry = RemoveHeadList(&GumpLockQueue);
        Waiter = CONTAINING_RECORD(ListEntry,
                                   GUM_WAITER,
                                   ListEntry);

        //
        // Set the new locking node, then process the update
        //

        // The new locker node may not be a part of the cluster any more.
        // We check if the Waiter node has rebooted when we wake up.

        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpDoUnlockingUpdate granting lock ownership to node %1!d!\n",
                   Waiter->NodeId);
        GumpLockingNode = Waiter->NodeId;

#ifndef GUM_POST_SUPPORT
        CL_ASSERT(Waiter->WaitType == GUM_WAIT_SYNC);
        SetEvent(Waiter->Sync.WakeEvent);
        //
        // The waiting thread now has ownership and is responsible
        // for any other items on the queue. Drop the lock and
        // return now.
        //
        LeaveCriticalSection(&GumpUpdateLock);
        return;

#else
        if (Waiter->WaitType == GUM_WAIT_SYNC) {
            SetEvent(Waiter->Sync.WakeEvent);

            //
            // The waiting thread now has ownership and is responsible
            // for any other items on the queue. Drop the lock and
            // return now.
            //
            LeaveCriticalSection(&GumpUpdateLock);
            return;
        } else {

            CL_ASSERT(Waiter->WaitType == GUM_WAIT_ASYNC);
            //
            // If the update originated on this node, go ahead and do the work
            // right here. Otherwise, issue the GUM callback to the originating
            // node to let them complete the post.
            //
            LeaveCriticalSection(&GumpUpdateLock);
            if (Waiter->NodeId == NmGetNodeId(NmLocalNode)) {

                //
                // Deliver the updates to the other nodes.
                //
                //SS:BUG BUG sort the locker details
                GumpDeliverPosts(NmGetNodeId(NmLocalNode)+1,
                                 Type,
                                 GumpSequence,
                                 Waiter->Async.Context,
                                 FALSE,
                                 Waiter->Async.BufferLength,
                                 Waiter->Async.Buffer);
                GumpSequence += 1;     // update ourself to stay in sync.

            } else {

                //
                // Call back to the originating node to deliver the posts.
                // First dispatch the update locally to save a round-trip.
                //
                //SS: sort thelocker details
                GumpDispatchUpdate(Type,
                                   Waiter->Async.Context,
                                   FALSE,
                                   FALSE,
                                   Waiter->Async.BufferLength,
                                   Waiter->Async.Buffer);

                CL_ASSERT(GumpRpcBindings[Waiter->NodeId] != NULL);
                GumDeliverPostCallback(GumpRpcBindings[Waiter->NodeId],
                                       NmGetNodeId(NmLocalNode)+1,
                                       Type,
                                       GumpSequence-1,
                                       Waiter->Async.Context,
                                       Waiter->Async.BufferLength,
                                       Waiter->Async.BufferPtr);
                MIDL_user_free(Waiter->Async.Buffer);
            }

            //
            // Free the wait block and process the next entry on the queue.
            //
            LocalFree(Waiter);

            EnterCriticalSection(&GumpUpdateLock);

        }
#endif
    }
    //
    // No more waiters, just unlock and we are done.
    //
    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumpDoUnlockingUpdate releasing lock ownership\n");
    GumpLockingNode = (DWORD)-1;
    LeaveCriticalSection(&GumpUpdateLock);
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\vote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    vote.c

Abstract:

    Routines for sending global updates to the cluster

Author:

    Sunita Shrivastava(sunitas) 17-Mar-1998

Revision History:

--*/
#include "gump.h"

/****
@doc    EXTERNAL INTERFACES CLUSSVC GUM
****/

/****
@func       DWORD | GumSendUpdateOnVote| Allows a the caller to collect votes
            from all active nodes in the cluster before sending an update.

@parm       IN GUM_UPDATE_TYPE | UpdateType |  The update type that will
            be sent if the decision call back function returns true.

@parn       IN DWORD | dwContext | This specifies the context related to the
            Updatetype that will be sent.

@parm       IN DWORD | dwInputBufLength | The length of the input buffer
            passed in via pInputBuffer.

@parm       IN PVOID | pInputBuffer | A pointer to the input buffer that is
            passed to all the active nodes based on which they can vote.

@parm       IN DWORD | dwVoteLength | The length of the vote.  Depending
            on this, an appropriately large buffer is allocated to collect
            all the votes.

@parm       IN GUM_VOTE_DECISION_CB | pfnGumDecisionCb |  The decision call
            back function that is invoked once all the votes have been collected.


@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm
@xref       <f GumpCollectVotes>
****/
DWORD
GumSendUpdateOnVote(
    IN GUM_UPDATE_TYPE  UpdateType,
    IN DWORD            dwContext,   //vote type
    IN DWORD            dwInputBufLength,  //input data to make judgement upon
    IN PVOID            pInputBuffer,  //size of the input data
    IN DWORD            dwVoteLength,
    IN PGUM_VOTE_DECISION_CB pfnGumDecisionCb,
    IN PVOID            pContext
    )
{
    DWORD                       dwVoteBufSize;
    BOOL                        bDidAllActiveNodesVote;
    DWORD                       dwNumVotes;
    DWORD                       dwStatus;
    GUM_VOTE_DECISION_CONTEXT   GumDecisionContext;
    PBYTE                       pVoteBuffer=NULL;
    DWORD                       dwSequence;
    DWORD                       dwDecisionStatus;
    DWORD                       dwUpdateBufLength;
    PBYTE                       pUpdateBuf=NULL;

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdateOnVote: Type=%1!u! Context=%2!u!\n",
               UpdateType, dwContext);


    if (dwVoteLength == 0)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //SS: We dont have to deal with a join happening between
    // the time we allocate the buffer to the time we collect votes
    // this is because the buffer we allocate is big enough to
    // collect all votes from the maximum number of allowed nodes
    // of a cluster.

    dwVoteBufSize = (DWORD)(NmMaxNodes * (sizeof(GUM_VOTE_ENTRY) + dwVoteLength));
    //allocate a buffer big enough to collect every bodies
    pVoteBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, dwVoteBufSize);
    if (!pVoteBuffer)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    ZeroMemory(pVoteBuffer, dwVoteBufSize);


    //setup the decision context structure
    GumDecisionContext.UpdateType = UpdateType;
    GumDecisionContext.dwContext = dwContext;
    GumDecisionContext.dwInputBufLength = dwInputBufLength;
    GumDecisionContext.pInputBuf = pInputBuffer;
    GumDecisionContext.dwVoteLength = dwVoteLength;
    GumDecisionContext.pContext = pContext;

Retry:
    //gum get sequence
    dwSequence = GumpSequence;

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdateOnVote: Collect Vote at Sequence=%1!u!\n",
               dwSequence);

    //gets the information from all nodes
    //this is done without acquiring the gum lock
    //could have been done in parallel if we had the appropriate
    //networking constructs
    dwStatus = GumpCollectVotes(&GumDecisionContext, dwVoteBufSize,
        pVoteBuffer, &dwNumVotes, &bDidAllActiveNodesVote);

    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }



    //Call the callback
    dwDecisionStatus = (*pfnGumDecisionCb)(&GumDecisionContext, dwVoteBufSize,
            pVoteBuffer,  dwNumVotes, bDidAllActiveNodesVote,
            &dwUpdateBufLength, &pUpdateBuf);


    ClRtlLogPrint(LOG_NOISE,
           "[GUM] GumSendUpdateOnVote: Decision Routine returns=%1!u!\n",
           dwDecisionStatus);

    if (dwDecisionStatus == ERROR_SUCCESS)
    {


        //send the update to the locker node
        dwStatus = GumAttemptUpdate(dwSequence, UpdateType, dwContext,
            dwUpdateBufLength, pUpdateBuf);

        if (dwStatus == ERROR_CLUSTER_DATABASE_SEQMISMATCH || 
            dwStatus == ERROR_REVISION_MISMATCH )  // for mixed mode
        {
            //free the update buffer
            if (pUpdateBuf)
            {
                LocalFree(pUpdateBuf);
                pUpdateBuf = NULL;
            }
            goto Retry;

        }

    }


FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdateOnVote: Returning status=%1!u!\n",
               dwStatus);

    //free the buffer allocated for vote collection
    if (pVoteBuffer)
    {
        LocalFree(pVoteBuffer);
    }
    //free the buffer for update allocated by the decision callback function
    if (pUpdateBuf)
    {
        LocalFree(pUpdateBuf);
    }

    return(dwStatus);
}

/****
@func       DWORD | GumCollectVotes| Calls all the nodes in the node
            to collect their votes.

@parm       IN PGUM_VOTE_DECISION_CONTEXT | pVoteContext|  A pointer to
            the vote context structure.  This describes the type/context/input
            data for the vote.

@parn       IN DWORD | dwVoteBufSize| The size of the buffer pointed to
            by pVoteBuf.

@parm       OUT PVOID | pVoteBuffer | A pointer to the buffer allocated to
            collect the votes/data from all the nodes of the cluster.

@parm       OUT LPDWORD| pdwNumVotes| The number of nodes whose votes
            were collected.

@parm       IN BOOL| *pbDidAllActiveNodesVote | A pointer to a BOOL.  This
            is set to true if all active nodes at the time the vote
            was collected vote.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This is called by GumSendUpdateOnVote() to collect votes from
            all the nodes of the cluster.

@xref       <f GumSendUpdateOnVote> <f GumpDispatchVote>
****/
DWORD GumpCollectVotes(
    IN  PGUM_VOTE_DECISION_CONTEXT  pVoteContext,
    IN  DWORD                       dwVoteBufSize,
    OUT PBYTE                       pVoteBuffer,
    OUT LPDWORD                     pdwNumVotes,
    OUT BOOL                        *pbDidAllActiveNodesVote
)
{
    DWORD               dwStatus = ERROR_SUCCESS;
    DWORD               dwVoteStatus = ERROR_SUCCESS;
    DWORD               dwCount = 0;
    DWORD               i;
    PGUM_VOTE_ENTRY     pGumVoteEntry;
    PGUM_INFO           GumInfo;
    DWORD               MyNodeId;



    *pbDidAllActiveNodesVote = TRUE;
    GumInfo = &GumTable[pVoteContext->UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
    {
        if (GumInfo->ActiveNode[i])
        {

            pGumVoteEntry = (PGUM_VOTE_ENTRY)(pVoteBuffer +
                (dwCount * (sizeof(GUM_VOTE_ENTRY) + pVoteContext->dwVoteLength)));

            CL_ASSERT((PBYTE)pGumVoteEntry <= (pVoteBuffer + dwVoteBufSize - sizeof(GUM_VOTE_ENTRY)));
            //
            // Dispatch the vote to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumVoteUpdate: Dispatching vote type %1!u!\tcontext %2!u! to node %3!d!\n",
                       pVoteContext->UpdateType,
                       pVoteContext->dwContext,
                       i);
            if (i == MyNodeId)
            {
                dwVoteStatus = GumpDispatchVote(pVoteContext->UpdateType,
                                   pVoteContext->dwContext,
                                   pVoteContext->dwInputBufLength,
                                   pVoteContext->pInputBuf,
                                   pVoteContext->dwVoteLength,
                                   (PBYTE)pGumVoteEntry + sizeof(GUM_VOTE_ENTRY));
            }
            else
            {
	            GumpStartRpc(i);
                dwVoteStatus = GumCollectVoteFromNode(GumpRpcBindings[i],
                                   pVoteContext->UpdateType,
                                   pVoteContext->dwContext,
                                   pVoteContext->dwInputBufLength,
                                   pVoteContext->pInputBuf,
                                   pVoteContext->dwVoteLength,
                                   (PBYTE)pGumVoteEntry + sizeof(GUM_VOTE_ENTRY));
	            GumpEndRpc(i);
            }
            if (dwVoteStatus == ERROR_SUCCESS)
            {
                pGumVoteEntry->dwFlags = GUM_VOTE_VALID;
                pGumVoteEntry->dwNodeId = i;
                pGumVoteEntry->dwNumBytes = pVoteContext->dwVoteLength;

                dwCount++;
            }
            else
                pbDidAllActiveNodesVote = FALSE;
        }
    }
    *pdwNumVotes = dwCount;
    return(dwStatus);
}



/****
@func       DWORD | GumpDispatchVote| The routine calls the vote routine
            registered for a given update type to collect vote for the
            supplied context and the input data.

@parm       IN GUM_UPDATE_TYPE | Type |  The update type for which this
            vote is requested.

@parn       IN DWORD | dwContext | This specifies the context related to the
            Updatetype for which a vote is being seeked.

@parm       IN DWORD | dwInputBufLength | The length of the input buffer
            passed in via pInputBuffer.

@parm       IN PVOID | pInputBuffer | A pointer to the input buffer via
            which the input data for the vote is supplied.

@parm       IN DWORD | dwVoteLength | The length of the vote.  This is
            also the size of the buffer to which pBuf points to.

@parm       OUT PUCHAR | pVoteBuf|  A pointer to a buffer in which
            this node may cast its vote.  The length of the vote must
            not exceed dwVoteLength.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm
@xref       <f GumpCollectVote> <f s_GumCollectVoteFromNode>
****/
DWORD
WINAPI
GumpDispatchVote(
    IN  GUM_UPDATE_TYPE  Type,
    IN  DWORD            dwContext,
    IN  DWORD            dwInputBufLength,
    IN  PUCHAR           pInputBuf,
    IN  DWORD            dwVoteLength,
    OUT PUCHAR           pVoteBuf
    )
{
    PGUM_INFO           GumInfo;
    PGUM_RECEIVER       Receiver;
    DWORD               Status = ERROR_REQUEST_ABORTED;

    GumInfo = &GumTable[Type];

    if (GumInfo->Joined)
    {
        Receiver = GumInfo->Receivers;
        if (Receiver != NULL)
        {

            try
            {
                if (Receiver->VoteRoutine)
                {
                    Status =(*(Receiver->VoteRoutine))(dwContext,
                                                       dwInputBufLength,
                                                       pInputBuf,
                                                       dwVoteLength,
                                                       pVoteBuf);
                }
            } except (CL_UNEXPECTED_ERROR(GetExceptionCode()),
                      EXCEPTION_EXECUTE_HANDLER
                     )
            {
                Status = GetExceptionCode();
            }
            if (Status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[GUM] Vote routine %1!d! failed with status %2!d!\n",
                           Receiver->VoteRoutine,
                           Status);
            }
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\bitset.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bitset.h

Abstract:

    Macro definitions that implement operations on a BITSET type.

Author:

    Gor Nishanov Aug-1998


Revision History:

--*/

#ifndef __BITSET_H
#define __BITSET_H

/************************************************************************
 * BitsetInit,
 * BitsetUnion,
 * BitsetIntersection,
 * BitsetDifference,
 * BitsetCompare,
 * BitsetSubsetOf,
 * BitsetComplement,
 * BitsetMember,
 * BitsetInsert,
 * BitsetDelete,
 * BitsetCopy,
 * BitsetEmpty
 * =================
 *
 * Description:
 *
 *    Macro definitions that implement operations on a BITSET type.
 *    Be very careful with argument order.
 *
 ************************************************************************/
typedef DWORD BITSET;

#define BITSET_BIT_COUNT       (sizeof(BITSET) * 8)

#ifndef BITSET_SKEW
# define BITSET_SKEW ClusterMinNodeId
#endif

/* Operations */
#define BitsetUnion(a,b)             ((a)|(b))
#define BitsetIntersection(a,b)      ((a)&(b))
#define BitsetDifference(a,b)        ((a)&~(b))
#define BitsetEquals(a,b)            ((a)==(b))
#define BitsetIsSubsetOf(small,big)  BitsetDifference(small,big)
#define BitsetIsEmpty(b)             ((b) == 0)
#define BitsetFromUnit(unit)         ( (1 << (unit - BITSET_SKEW)) )
#define BitsetIsMember(unit,set)     ( BitsetFromUnit(unit) & (set) )
#define BitsetIsNotMember(unit,set)  ( !BitsetIsMember(unit,set) )

/* Statements */
#define BitsetInit(set) \
            do { (set) = 0; } while(0)

#define BitsetRemove(set, unit) \
            do { (set) &= ~BitsetFromUnit(unit); } while(0)

#define BitsetAdd(set, unit) \
            do { (set) |=  BitsetFromUnit(unit); } while(0)

#define BitsetAssign(dest,src) \
            do { (dest) = (src); } while(0)

#define BitsetMergeWith(dest,src) \
            do { (dest) |= (src); } while(0)

#define BitsetSubtract(dest,src) \
            do { (dest) &= ~(src); } while(0)

#define BitsetIntersectWith(dest,src) \
            do { (dest) &= (src); } while(0)


#endif // __BITSET_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\gum\marshal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    marshal.c

Abstract:

    Implements some common GUM apis for marshalling and unmarshalling
    arguments to GUM update procedures.

Author:

    John Vert (jvert) 8/27/1996

Revision History:

--*/
#include "gump.h"


PVOID
GumpMarshallArgs(
    IN DWORD ArgCount,
    IN va_list ArgList,
    OUT DWORD *pBufferSize
    )
/*++

Routine Description:

    Helper routine for marshalling up a bunch of arguments into
    a single buffer.

Arguments:

    ArgCount - Supplies the number of arguments.

    ArgList - Supplies the variable length arguments. These must come
        in pairs, so there must be 2*ArgCount additional arguments.

    pBufferSize - Returns the length of the allocated buffer.

Return Value:

    A pointer to the allocated buffer. The caller must free this.

    NULL on failure.

--*/

{
    DWORD i;
    DWORD BufSize;
    DWORD Length;
    LPDWORD Buffer;
    PUCHAR Pointer;
    PUCHAR Source;
    va_list OriginalList;


    OriginalList = ArgList;

    //
    // round ArgCount to an even number. This causes the first data area to be
    // quadword aligned
    //
    BufSize = (( ArgCount + 1 ) & ~1 ) * sizeof(DWORD);

    //
    // the va_list is a set of (length, pointer) tuples.
    //
    for (i=0; i < ArgCount; i++) {
        Length = va_arg(ArgList, DWORD);

        //
        // Round up to architecture appropriate boundary.
        //
        Length = (Length + (sizeof(DWORD_PTR) - 1 )) & ~( sizeof(DWORD_PTR) - 1 );
        BufSize += Length;

        va_arg(ArgList, PUCHAR);
    }

    Buffer = LocalAlloc(LMEM_FIXED, BufSize);
    if (Buffer == NULL) {
        return(NULL);
    }
    *pBufferSize = BufSize;

    //
    // Now copy in all the arguments
    //
    // Set Pointer to point after the array of offsets.
    //

    Pointer = (PUCHAR)(Buffer + (( ArgCount + 1 ) & ~1 ));
    for (i=0; i < ArgCount; i++) {

        //
        // Set offset of argument in array
        //
        // Since this is an offset in a buffer where BufSize < 2^32 then it 
        // is reasonable that Pointer - Buffer should be < 2^32
        //

        Buffer[i] = (DWORD)(Pointer - (PUCHAR)Buffer);
        Length = va_arg(OriginalList, DWORD);
        Source = va_arg(OriginalList, PUCHAR);
        CopyMemory(Pointer, Source, Length);

        //
        // Round up to architecture appropriate boundary.
        //
        Length = (Length + (sizeof(DWORD_PTR) - 1 )) & ~( sizeof(DWORD_PTR) - 1 );

        //
        // Adjust pointer for next argument.
        //
        Pointer += Length;
    }

    return(Buffer);

}


DWORD
GumSendUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    )

/*++

Routine Description:

    Sends an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

    This is different than GumSendUpdate in that it takes a
    variable number of arguments. The number of variable
    arguments is specified by the ArgCount argument. The format
    is pairs of length/pointer arguments. For example:
    GumSendUpdateEx(UpdateType,
                    MyContext,
                    3,
                    Length1, Pointer1,
                    Length2, Pointer2,
                    Length3, Pointer3);

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    DispatchIndex - Supplies an index into the dispatch table
        for the specified update type. The receiving side will
        unmarshall the arguments and call the update routine
        for this dispatch index.

    ArgCount - Supplies the number of arguments.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/

{
    PVOID Buffer;
    DWORD BufLength;
    DWORD Status;
    va_list arglist;

    //
    // Make sure there is really a handler for this dispatch routine.
    //
    if (GumTable[UpdateType].Receivers != NULL) {
        CL_ASSERT(DispatchIndex < GumTable[UpdateType].Receivers->DispatchCount);
    }

    //
    // Format the arguments into a common buffer.
    //
    va_start(arglist, ArgCount);
    Buffer = GumpMarshallArgs(ArgCount, arglist, &BufLength);
    va_end(arglist);
    if (Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = GumSendUpdate(UpdateType,
                           DispatchIndex,
                           BufLength,
                           Buffer);
    LocalFree(Buffer);

    return(Status);

}

PVOID GumMarshallArgs(
    OUT LPDWORD lpdwBufLength,
    IN  DWORD   dwArgCount, 
    ...)
{
    PVOID   Buffer=NULL;
    va_list arglist;

    va_start(arglist, dwArgCount);
    Buffer = GumpMarshallArgs(dwArgCount, arglist, lpdwBufLength);
    va_end(arglist);
    return (Buffer);
}
    
#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.

DWORD
GumPostUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    )

/*++

Routine Description:

    Posts an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

    This is different than GumPostUpdate in that it takes a
    variable number of arguments. The number of variable
    arguments is specified by the ArgCount argument. The format
    is pairs of length/pointer arguments. For example:
    GumPostUpdateEx(UpdateType,
                    MyContext,
                    3,
                    Length1, Pointer1,
                    Length2, Pointer2,
                    Length3, Pointer3);

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    DispatchIndex - Supplies an index into the dispatch table
        for the specified update type. The receiving side will
        unmarshall the arguments and call the update routine
        for this dispatch index.

    ArgCount - Supplies the number of arguments.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/

{
    PVOID Buffer;
    DWORD BufLength;
    DWORD Status;

    va_list arglist;

    //
    // Format the arguments into a common buffer.
    //
    va_start(arglist, ArgCount);
    Buffer = GumpMarshallArgs(ArgCount, arglist, &BufLength);
    va_end(arglist);
    if (Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = GumPostUpdate(UpdateType,
                           DispatchIndex,
                           BufLength,
                           Buffer);
    return(Status);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\api.h ===
//depot/Lab01_N/Base/cluster/service/inc/api.h#1 - branch change 3 (text)
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    api.h

Abstract:

    Public data structures and procedure prototypes for
    the API subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

#ifndef __API_H_
#define __API_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
ApiInitialize(
    VOID
    );

DWORD
ApiOnlineReadOnly(
    VOID
    );

DWORD
ApiOnline(
    VOID
    );

VOID
ApiOffline(
    VOID
    );

VOID
ApiShutdown(
    VOID
    );


DWORD ApiFixupNotifyCb(
    IN DWORD    dwFixupType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR  *lpszKeyName
    );

#ifdef __cplusplus
}
#endif

#endif // ifndef __API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\clmsg.h ===
#ifndef  _CLMSG_H_
#define  _CLMSG_H_
/*  ----------------------- ClMsg.h ----------------------- */

/* Cluster messaging */

/* This file contains the specifications of the low-level messaging
   functions required by the Cluster Manager's module. Primary input
   to this is the node#; see the MM module for details. It is assumed
   that this module is configured (by mechanisms not described here)
   to know the various paths to the target node (IP address, netbios
   address, async line, Snet address, ...).

   It is also assumed that *all* CM->CM communication uses this
   module.  The various CM components must be able to do this without
   conflict.

   The model is this:  There are a set of apis for sending messages
   from one CM module to another CM.  All messages are sent either to
   existing cluster members or to a node attempting to join the
   cluster.  A message being sent is directed to one or more nodes,
   and its characteristics are defined (reliable, unreliable, etc).

   This module is entirely responsible for finding out the best way to
   get the message to the target node(s). It chooses the transport; it
   chooses the protocol; it chooses which of the n possible paths to
   use.  No module outside this one cares about such details.

   On the receiving side, messages must be delivered to the
   appropriate CM module.  For this, each message is tagged with a
   type. There is one type per independent module of the CM (to a
   total of a few, say less than 10). Types are statically assigned by
   values in this header file. When a message of type t arrives in a
   destination CM process, a function (msgproc) associated with that
   type t is called. Calls to msgprocs are single-threaded (by the CM
   caller).  After calling a msgproc, this module no longer cares
   about the details of the message.  Messages of one type must be
   delivered promptly, without interference from messages of different
   types; this probably requires there to be a thread per message
   type.  The characteristics of the msgproc (whether it can block,
   take a long time, etc) are not defined; if a msgproc takes too
   long, then the effect will be that other messages destined for it
   will be deferred; if it is important to avoid this, msgprocs can
   pass work off to further threads.

/* ------------ */

/* NOTE: only the important semantics of the messaging api are shown
   below. This module also needs open/close, handles, error
   returns and so on. */

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */

#include <windows.h>
#if defined (TDM_DEBUG)
#include <jrgpos.h>
#endif // TDM_DEBUG
/*------------------------- */

/* the set of messages understood by this module */

typedef enum {
      MM_MSGTYPE = 1, /* for Membership Mgr */
                      /* others to be added */
     } CLMSGTYPE;


#define CLMSGMAXBUFFERLENGTH 1024 /* random number; no reason */
/* the biggest buffer which can be sent/received by the CM */

typedef DWORD (*CLMSGPROC) (LPCSTR buffer, DWORD length);

void ClProcRegister (CLMSGTYPE msgtype, CLMSGPROC msgproc);

/* registers that function <msgproc> should be called whenever an
   incoming message of type <msgtype> is seen. The type field is always
   the first DWORD of the incoming buffer. The length passed to
   <ptype> is the length received. The worst-case length of all users
   of this api is known, so there are never cases where the
   receive-buffer isn't big enough.

   This must be called by all CM modules in all nodes on CM startup.

   The msgproc should be called immediately an incoming msg arrives;
   such msgs should not be delayed by an long blocking events in the
   thread which delivers these messages. (This may imply that clMsg
   have a special thread dedicated to handling incoming msgs).

   Every msgproc will return quickly to its caller.

  Errors: none possible.

*/


DWORD ClMsgSendUnack(DWORD   targetnode,
               LPCSTR  buffer,
               DWORD   length);

/*
   Sends an unacknowledged packet to a destination up node. This is
   used mostly for heartbeats.

   The target node may not be Up at the time.

   The paths to that node are unknown to MM.  (For safety, all paths
   should be used periodically). The packet should arrive with low
   latency (bypassing other traffic, if required; going at high
   priority if possible), and with a high probability of delivery.
   Although the message can be lost, the contents must be correct.
   This function should never fail unless zero connectivity exists.
   This function should return asap; it is preferred that the
   buffer simply be queued to some driver for later delivery.

   [It must be the case that, when this routine is used for
   heartbeats, it is possible to deliver a packet to all other
   nodes within the <polltime> established in the MM. This places
   constraints on this module to work fast, and/or on the minimum
   polltime value... tbd]

   It is undefined whether this function should always send all
   packets on all available paths, cycle through all available paths,
   or send on some preferred path till a failure occurs, or whether
   the choice of the above should be user-configurable. [Note that the
   decision eventually affects the user settings of polltime].

   [<length> is typically short and can be restricted to be so (eg,
   256 bytes) is necessary].

Errors:

xxx No path to designated node.

xxx Success; message was queued for delivery.


*/


DWORD ClSend     (DWORD      targetnode,
            LPCSTR     buffer,
            DWORD      length,
            DWORD      timeout);

/* This sends the given message to the designated node, eg to download
   configuration data to it.  The message should be reliable.  The
   function should block until the msg is delivered to the target CM.
   The target node may not be Up at the time.

   The function must fail if the target node becomes unreachable
   or is declared down during the operation.

   The function should fail if the message cannot be delivered to the
   target CM within <timeout> ms.


Errors:

xxx   No path to node; node went down.

xxx   Timeout
*/

/* ------------------------------------------------------ */

DWORD ClMsgInit (DWORD mynode);

/* Input -      my node number
   Errors :
                WSAsocket errors.
*/


#if defined (TDM_DEBUG)
/* The following templates are for simulation purposes and temporary */

DWORD ClMsgGet  (LPCSTR         buffer,
            DWORD                maxlen,
            LPDWORD              actuallen);
/* Input -  pointer to buffer data.
                        buffer length in bytes.
                        pointer to actual buffer length in bytes.
   Modifies - buffer data
                  actual byte length
   Errors :

                WSAsocket errors.
*/

DWORD ClWriteRead(
        IN              DWORD   targetnode,             // node to send to
        IN OUT  LPCSTR  buffer,                 // buffer to send and to receive in
        IN              DWORD   writelen,               // number of bytes to write
        IN              DWORD   readlen,                // number of bytes to read
        OUT             LPDWORD actuallen,              // number of bytes actually read
        IN              DWORD   timeout                 // timeout value in milliseconds
        );

DWORD ClReadUpdate(
        IN              LPCSTR  buffer,                 // buffer to receive data into
        IN              DWORD   readlen,                // number of bytes to read
        OUT             LPDWORD actuallen               // number of bytes actually read
        );

DWORD ClReply(
        IN              LPCSTR  buffer,                 // buffer to send
        IN              DWORD   writelen                // number of bytes to send
        );

//
// This structure is used for request reply messages so that we know
// who sent the message.
//
#define MAX_REQUEST_REPLY_SIZE 256
typedef struct _request_reply_message
{
        DWORD           sending_node;
        DWORD           sending_IPaddr;         // only used for CLI (sending_node is -1)
        CHAR            message[MAX_REQUEST_REPLY_SIZE];
        DWORD           messagelen;
} REQUEST_REPLY_MESSAGE, *PREQUEST_REPLY_MESSAGE;

typedef struct _reply_message_header
{
        DWORD           status;
        cluster_t       UpMask;
} REPLY_MESSAGE_HEADER, *PREPLY_MESSAGE_HEADER;

typedef struct _reply_message
{
        REPLY_MESSAGE_HEADER reply_hdr;
        DWORD           reply_data_len;
        CHAR            reply_data[];
} REPLY_MESSAGE, *PREPLY_MESSAGE;

#else  //TDM_DEBUG


DWORD
ClMsgCreateRpcBinding(
    IN  PNM_NODE              Node,
    OUT RPC_BINDING_HANDLE *  BindingHandle,
    IN  DWORD                 RpcBindingOptions
    );

DWORD
ClMsgVerifyRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    );

VOID
ClMsgDeleteRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    );

DWORD
ClMsgCreateDefaultRpcBinding(
    IN  PNM_NODE  Node,
    OUT PDWORD    Generation
    );

VOID
ClMsgDeleteDefaultRpcBinding(
    IN PNM_NODE   Node,
    IN DWORD      Generation
    );

DWORD
ClMsgCreateActiveNodeSecurityContext(
    IN DWORD     JoinSequence,
    IN PNM_NODE  Node
    );

DWORD
ClMsgInit(
    IN DWORD    MyNode
    );

VOID
ClMsgCleanup(
    VOID
    );

VOID
ClMsgBanishNode(
    IN CL_NODE_ID NodeId
    );

extern RPC_BINDING_HANDLE * Session;

#endif //TDM_DEBUG

#ifdef __cplusplus
}
#endif /* __cplusplus */


/* ------------------------ end ------------------------- */
#endif /* _CLMSG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\config.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Public data structures and procedure prototypes for
    the Config subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\cvsscluster.h ===
#pragma once

//++
//
// Copyright (c) 2001 Microsoft Corporation
//
// FACILITY:
//
//      Cluster Service
//
// MODULE DESCRIPTION:
//
//      Header for Vss support within cluster service.
//
// ENVIRONMENT:
//
//      User mode NT Service.
//
// AUTHOR:
//
//      Conor Morrison
//
// CREATION DATE:
//
//      18-Apr-2001
//
// Revision History:
//
// X-1	CM		Conor Morrison        				18-Apr-2001
//      Initial version.
//--

#include "vss.h"
#include "vswriter.h"

// Derive a class from CVssWriter so that we can override some of the default
// methods with our own funky cluster variants
//
// For more info search MSDN for CVssWriter.
//
class CVssWriterCluster : public CVssWriter
{
private:
	// callback when request for metadata comes in

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// callback for prepare backup event

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(
	    IN IVssWriterComponents *pComponent
	    );

	// callback for prepare snapsot event
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	// callback for freeze event
	virtual bool STDMETHODCALLTYPE OnFreeze();

	// callback for thaw event
	virtual bool STDMETHODCALLTYPE OnThaw();

	// callback if current sequence is aborted
	virtual bool STDMETHODCALLTYPE OnAbort();
};
typedef CVssWriterCluster* PCVssWriterCluster;

extern class CVssWriterCluster* g_pCVssWriterCluster;
extern const VSS_ID g_VssIdCluster;
extern bool g_bCVssWriterClusterSubscribed;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\ep.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ep.h

Abstract:

    Header file for definitions and structure for the Event Processor
    component of the Cluster Service portion of the Windows NT Cluster project.

Author:

    Rod Gamache (rodga) 28-Feb-1996

Revision History:

--*/

#ifndef _EVENT_PROCESSOR_
#define _EVENT_PROCESSOR_


//***********************************
//
// Global Cluster Service definitions
//
//***********************************


typedef DWORDLONG CLUSTER_EVENT;
typedef CLUSTER_EVENT *PCLUSTER_EVENT;

//
// Event flags. These indicate what should be done with the Context once
// the event has been dispatched.
//
//
#define EP_DEREF_CONTEXT    0x00000001       // OmDereferenceObject(Context)
#define EP_FREE_CONTEXT     0x00000002       // LocalFree(Context)
#define EP_CONTEXT_VALID    0x00000004

typedef
DWORD
(WINAPI *PEVENT_ROUTINE) (
    IN  CLUSTER_EVENT Event,
    IN  PVOID Context
    );

DWORD
WINAPI
EpInitialize(
    VOID
    );

DWORD EpInitPhase1();
DWORD EpIfnitPhase1();

VOID
EpShutdown(
    VOID
    );

DWORD
WINAPI
EpPostEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    );

DWORD
WINAPI
EpPostSyncEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    );

DWORD
WINAPI
EpRegisterSyncEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    );

DWORD
WINAPI
EpRegisterEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    );

DWORD
WINAPI
EpClusterWidePostEvent(
    IN CLUSTER_EVENT    Event,
    IN DWORD            dwFlags,
    IN PVOID            Context,
    IN DWORD            ContextSize
    );

#define ClusterEvent(Event, pObject) EpPostEvent(Event, 0, pObject)

#define ClusterEventEx(Event, Flags, Context) \
            EpPostEvent(Event, Flags, Context)

#define ClusterSyncEventEx(Event, Flags, Context) \
            EpPostSyncEvent(Event, Flags, Context)

#define ClusterWideEvent(Event, pObject) \
            EpClusterWidePostEvent(Event, 0, pObject, 0)

#define ClusterWideEventEx(Event, Flags, Context, ContextSize) \
            EpClusterWidePostEvent(Event, Flags, Context, ContextSize)
//
// Define Cluster Service states
//

typedef enum _CLUSTER_SERVICE_STATE {
    ClusterOffline,
    ClusterOnline,
    ClusterPaused
} CLUSTER_SERVICE_STATE;

//
// Definitions for Cluster Events.  These events are used both as masks and as
// event identifiers within the Cluster Service. Cluster Service components
// register to receive multiple events, but can deliver notification of only
// one event at a time. This mask should be a CLUSTER_EVENT type.