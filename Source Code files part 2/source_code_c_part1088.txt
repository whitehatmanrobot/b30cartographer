ed

        ; Let us compare the ASCII vaues
        ; If the asciis are equal, then weights are equal
        cmp     al, dl
        je      ss_loop         ; Goto next character

        ; Now, the asciis differ. So, let us find the weights

        ; Let us get the weights for the character of lpStr1 (in ax )

        call    GetWeightValues

        ; ax contains the primary weight of char of lpStr1
        ; bl contains the secondary weight of ditto
        mov     LocSecWeight, bl
        xchg    ax, dx
        call    GetWeightValues

        ; compare primary weights
        ; Primary weight of Str1 in DX and Str2 in AX
        cmp     ax, dx
        jb      CompareRetGT
        ja      CompareRetLT

        ; Check if it is Case-Insensitive compare
        mov     bh, fCaseSensitive
        or      bh, bh
        jz      ss_loop    ; It is case-insensitive; So, no need to consider
                           ; the secondary weightages. Goto next character.

        ; Control comes here only if it is a case sensitive compare.
        ; Now, primaries are equal. Compare secondaries
        mov     bh, LocSecWeight
        cmp     bh, bl
        je      ss_loop         ; Secondaries are equal, Continue

        ; Secondaries are not equal. Check if they are stored already
        mov     cl, SecWeight1
        or      cl, SecWeight2
        jnz     ss_loop         ; Secondaries already exist, continue

        ; Secondaries haven't been saved sofar.Save the secondaries
        mov     SecWeight1, bh
        mov     SecWeight2, bl
        jmps    ss_loop         ; Process the next character

ss_chkprimary:
        ; al, dl contain the primary weights and at least one of them is
        ; zero.
        cmp     al, 0
        ja      CompareRetGT
        cmp     dl, 0
        ja      CompareRetLT

        ; both are zero; they are equal; So, check the secondary values
        mov     bl, SecWeight1
        cmp     bl, SecWeight2
        ja      CompareRetGT
        jb      CompareRetLT

        ; They are identical with equal weightages
        xor     ax, ax
        jmps    CompareRet

CompareRetGT:
        mov     ax, 1
        jmps    CompareRet

CompareRetLT:
        mov     ax, -1

CompareRet:
        pop     ds
        ret

US_lstrcmp      ENDP


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  lstrcmpi(String1, String2) -                                            *
;*    (Case Insensitive compare)                                            *
;*    String1 and String2 are LPSTR's to null terminated strings.           *
;*                                                                          *
;*    This function returns -1 if String1 sorts before String2, 0 if String1*
;*    and String2 have the same sorting and 1 if String2 sorts before       *
;*    String1.                                                              *
;*                                                                          *
;*   Outside the U.S. English locale, this function is patched to be a      *
;*   near jump to Win32lstrcmpi, aka WU32lstrcmpi.                          *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc Ilstrcmpi, <FAR, PUBLIC>, <SI, DI>
;                               ^^^^^^^^ US_lstrcmp assumes SI, DI saved!

ParmD  lpStr1
ParmD  lpStr2
LocalB SecWeight1       ; Locals used by US_lstrcmp
LocalB SecWeight2
LocalB LocSecWeight
LocalB fCaseSensitive   ; Flag indicating whether it is case sensitive or not.

cBegin
        mov     byte ptr fCaseSensitive, 0 ; FALSE => Case-Insensitive.
        call    US_lstrcmp
cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*  AnsiUpper implementation is from Win3.1 US_AnsiUpper()              *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiUpper, aka WU32AnsiUpper.                     *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc    IAnsiUpper, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr

cBegin

        les     di,lpStr
        mov     cx,es
        mov     ax,di
        call    MyUpper         ; if passed a char, just upper case it.
        jcxz    au1
        inc     cx              ; take care of the case of sign propagation
        jz      au1
        dec     cx
        call    MyAnsiUpper     ; otherwise upper case the whole string
        mov     ax, word ptr lpStr ; Now, dx:ax points at original string
au1:    mov     dx,es

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*  AnsiLower implementation is from Win3.1 US_AnsiLower()              *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiLower, aka WU32AnsiLower.                     *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc    IAnsiLower, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr

cBegin
        les     di,lpStr
        mov     cx,es
        mov     ax,di
        call    MyLower         ; if passed a char, just lower case it.
        jcxz    al1
        inc     cx              ; take care of the case of sign propagation
        jz      al1
        dec     cx
        call    MyAnsiLower     ; otherwise lower case the whole string
        mov     ax, word ptr lpStr ; dx:ax points at original string
al1:    mov     dx,es

cEnd



;*----------------------------------------------------------------------*
;*                                                                      *
;*   AnsiUpperBuff implemented from Win3.1 US_AnsiUpperBuff             *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiUpperBuff, aka WU32AnsiUpperBuff.             *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IAnsiUpperBuff, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr
ParmW   iCount

cBegin

        cld
        les     di, lpStr
        mov     si, di
        mov     cx, iCount      ; if iCount=0, the Buff size is 64K.
        mov     dx, iCount      ; Preserve the length of Buffer
su_begin:
        lods    byte ptr es:[si]
        call    MyUpper
        stosb
        loop    su_begin
su_over:
        mov     ax, dx  ; Move the result to ax

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   AnsiLowerBuff implemented from Win3.1 US_AnsiLowerBuff             *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiLowerBuff, aka WU32AnsiLowerBuff.             *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IAnsiLowerBuff, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr
ParmW   iCount

cBegin

        cld
        les     di, lpStr
        mov     si, di
        mov     cx, iCount      ; If cx=0, the buff size is 64K
        mov     dx, cx          ; Preserve the length in DX
sl_begin:
        lods    byte ptr es:[si]
        call    MyLower
        stosb
        loop    sl_begin
sl_over:
        mov     ax, dx  ; Move the result to ax

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharLower implemented with Win3.1 US_IsCharLower                 *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharLower, aka WU32IsCharLower.                 *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharLower, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
        call    Loc_Lower
        jc      icl_end

        xor     ax, ax          ; Not lower. So, false
icl_end:

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharUpper implemented with Win3.1 US_IsCharUpper                 *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharUpper, aka WU32IsCharUpper.                 *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharUpper, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
        call    Loc_Upper
        jc      icu_end

        xor     ax, ax
icu_end:

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharAlphaNumeric implemented with Win3.1 US_IsCharAlphaNumeric   *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharAlphaNumeric, aka WU32IsCharAlphaNumeric.   *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharAlphaNumeric, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
        call    Loc_Numeric
        jc      ica_end

        jmps    ica_begin

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharAlpha implemented with Win3.1 US_IsCharAlpha                 *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharAlpha, aka WU32IsCharAlpha.                 *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharAlpha, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
ica_begin:
        call    Loc_Lower
        jc      ica_end

        call    Loc_Upper
        jc      ica_end

        xor     ax, ax
ica_end:

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   Loc_Upper, LocLower, Loc_Numeric                                   *
;*                                                                      *
;*   Used by IsCharXxx US implementations                               *
;*                                                                      *
;*      Input:                                                          *
;*         AL = character being tested                                  *
;*      Output:                                                         *
;*         Carry flag set if TRUE                                       *
;*         Carry flag cleared if FALSE                                  *
;*----------------------------------------------------------------------*

public  Loc_Upper
LabelNP    <Loc_Upper>

        cmp     al, 'A'
        jb      Loc_False

        cmp     al, 'Z'
        jbe     Loc_True

        cmp     al, 0C0h
        jb      Loc_False

        cmp     al, 0D7h        ; This is multiply sign in Microsoft fonts, So, ignore;
        je      Loc_False       ; Fix for Bug #1356; SANKAR --08-28-89--;

        cmp     al, 0DEh
        jbe     Loc_True
        jmps    Loc_False

public  Loc_Lower
LabelNP    <Loc_Lower>
        ; 0xDF and 0xFF are Lower case. But they don't have an equivalent
        ; upper case letters;
        ; So, they are treated as special case chars here
        ; Fix for  Bug # 9799 --SANKAR-- 02-21-90 --
        cmp     al, 0DFh
        je      Loc_True

        cmp     al, 0FFh
        je      Loc_True

        ; Fall thro to the next function
        errnz   ($-Loc_IsConvertibleToUpperCase)
public  Loc_IsConvertibleToUpperCase
LabelNP    <Loc_IsConvertibleToUpperCase>

        cmp     al, 'a'
        jb      Loc_False

        cmp     al, 'z'
        jbe     Loc_True

        cmp     al, 0E0h
        jb      Loc_False

        cmp     al, 0F7h        ; This is divide sign in Microsoft fonts; So, ignore
        je      Loc_False;      ; Fix for Bug #1356; SANKAR --08-28-89--;

        cmp     al, 0FEh
        jbe     Loc_True
        jmps    Loc_False

LabelNP    <Loc_Numeric>

        cmp     al, '0'
        jb      Loc_False

        cmp     al, '9'
        ja      Loc_False

Loc_True:
        stc             ; Set carry to indicate true
        jmps    Loc_End

Loc_False:
        clc             ; Clear carry to indicate false

Loc_End:
        ret

;*----------------------------------------------------------------------*
;*                                                                      *
;*   PatchUserStrRtnsToThunk --     *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   PatchUserStrRtnsToThunk, <PUBLIC, FAR, PASCAL>, <SI,DI>

cBegin
        cCall   AllocSelector, <0>
        cCall   PrestoChangoSelector, <cs, ax>
        push    ax
        pop     es

        mov     si, dataOffset StrRtnsPatchTable ; ds:si = StrRtnsPatchTable
PatchLoop:
        lodsw
        mov     di, ax                           ; di = offset of code to be patched
        mov     ax, 0E9h                         ; opcode for near jump w/2 byte diff.
        stosb                                    ; store jmp opcode
        lodsw
        sub     ax, di                           ; difference between src and target
        sub     ax, 2                            ; encoded difference is based on
                                                 ; address of next instruction
        stosw                                    ; store difference
        cmp     si, dataOffset StrRtnsPatchTableEnd
        jb      PatchLoop

        xor     ax, ax
        push    es                               ; for FreeSelector
        push    ax
        pop     es

        call    FreeSelector
cEnd

sEnd CODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winmisc2.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINMISC2.ASM
;   Win16 misc. user services
;
;   History:
;
;   Created 28-May-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--

;****************************************************************************
;*									    *
;*  WINMISC2.ASM -							    *
;*									    *
;*      Random stuff                                                        *
;*									    *
;****************************************************************************

ifdef WOW
SEGNAME equ <TEXT>
endif

.xlist
include user.inc
include vint.inc
.list

ExternFP <GlobalHandleNorip>
ExternFP <MessageBox>
ExternFP <SysErrorBox>


ifndef WOW
ExternFP <DoBeep>
ExternFP <XCSTODS>
ExternNP <rgbKeyState>
ExternW  <hwndCapture>
ExternW  <fBeep>
ExternW  <fMessageBox>
ExternW  <hwndDragIcon>

ExternA <__WinFlags>

ATOMTABLE   STRUC
at_prime        DW  ?
at_hashTable    DW  ?
ATOMTABLE   ENDS

ATOM    STRUC
a_chain DW  ?
a_usage DW  ?
a_len   DB  ?
a_name  DB  ?
ATOM    ENDS

LocalArena  STRUC
la_prev		DW  ?	; previous arena entry (first entry points to self)
la_next		DW  ?	; next arena entry	(last entry points to self)
la_handle	DW  ?	; back link to handle table entry
LocalArena  ENDS

sBegin DATA

;
; For GetSysMetrics - don't move this stuff. DS positioning is assumed.
;
SM_CMETRICS1 equ 24
SM_CMETRICS2 equ 16

public rgwSysMet
rgwSysMet      dw (SM_CMETRICS1) DUP(0)

; These are 'variable metrics', conviently located the system metrics array.
GlobalW hwndFullScrn, 0
GlobalW iLevelCursor, 0

; These are additions since 2.0
	dw SM_CMETRICS2 DUP(0)


sEnd DATA
endif ;WOW

createSeg _%SEGNAME, %SEGNAME, WORD, PUBLIC, CODE

assumes cs,%SEGNAME
assumes ds,DATA

sBegin %SEGNAME

ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  GetSystemMetrics() -						    *
;*									    *
;*--------------------------------------------------------------------------*

; int far GetSystemMetrics(iMetric)
; int iMetric;

LabelFP <PUBLIC, GetSystemMetrics>
	    
	    pop     ax			    ; Pop the FAR return
	    pop     dx
	    pop     bx			    ; BX = iMetric
	    push    dx			    ; Restore the FAR return
	    push    ax

	    xor     ax,ax
	    cmp     bx,SM_CMETRICSMAX	    ; Bigger than max?
	    jge	    gsmExit		    ; Yes, exit
	    shl     bx,1		    ; Convert to a byte index

ifndef userhimem
            mov     es,WORD PTR cs:[cstods]
else
            push    ax
            push    ds
            call    XCSTODS
            mov     es,ax
            pop     ds
            pop     ax
endif

assumes es,DATA
	    mov     ax,es:[rgwSysMet+bx]    ; Return the SysMetric value
assumes es,NOTHING
gsmExit:
	    retf


;*--------------------------------------------------------------------------*
;*									    *
;*  MessageBeep() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc MessageBeep, <FAR, PUBLIC>

ParmW beep

cBegin
	    cmp     fBeep,0
	    je	    mbout		; No beeps today....
            mov     ax,beep
            cmp     fMessageBox,0       ; if we are in an INT24 box, let
            je      noint24             ; the sound driver know not to load
            mov     ax,-1               ; anything by passing -1.
noint24:
            push    ax
	    call    DoBeep		; Just call the sound driver guy
mbout:

cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  IsChild() - 							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelFP <PUBLIC, IsChild>
;
;ParmW hwnd
;ParmW hwndChild
;
	    pop     ax			; pop return address
	    pop     dx
	    pop     bx			; bx = hwndChild
	    pop     cx			; cx = hwnd
	    push    dx			; push return address
	    push    ax

	    push    ds
	    UserDStoDS			; es = USER's DS

	    CheckHwnd cx		; checkhwnd will zero ax if failure
	    jz	    icexit
ifdef DEBUG
	    CheckHwndNull bx 		; only do check if debug since 
	    jz	    icexit              ; we never access anything off this
                                        ; pointer
endif
	    xor     ax,ax		; Assume FALSE
icloop:
	    or	    bx,bx		; while (hwndChild == NULL &&
	    jz	    icexit
	    mov     dl,byte ptr [bx+WSTATE+WFTYPEMASK/256]
	    and     dl,LOW(WFTYPEMASK)	; TestwndChild(hwndChild))
	    cmp     dl,LOW(WFCHILD)
	    jne     icexit
	    mov     bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
	    cmp     bx,cx		; if (hwnd == hwndChild)
	    jne     icloop
	    inc     al			; return(TRUE);
icexit:
	    pop     ds
	    retf

; BOOL IsDescendant(hwndParent, hwndChild);
;
; Internal version of IsChild that is a bit faster and ignores the
; WFCHILD business.  MUST be called with DS == USER DS.
;
; Returns TRUE if hwndChild == hwndParent (IsChild doesn't)
;
;   while (hwndChild != NULL)
;   {
;	if (hwndParent == hwndChild)
;	    return TRUE;
;	hwndChild = hwndChild->hwndParent;
;   }
;
LabelFP     <PUBLIC, IsDescendant>
	    pop     ax			; pop off return address
	    pop     dx
	    pop     bx			; bx = hwndChild
	    pop     cx			; cx = hwndParent
	    push    dx			; replace return address
	    push    ax

	    xor     ax,ax		; assume FALSE
idloop:
	    or	    bx,bx		; if at end, return FALSE
	    jz	    idexit
	    cmp     bx,cx		; hwndChild == hwndParent?
	    mov     bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
	    jnz     idloop		; keep looping if we didn't find it...

	    inc     al			; ax = TRUE
idexit:
	    retf

;--------------------------------------------------------------------------
;
; IsWindowVisible() -
;
;--------------------------------------------------------------------------
;
; BOOL FAR PASCAL IsWindowVisible(register HWND hwnd)
; {
;     if (!CheckHwnd(hwnd))
;	  return(FALSE);
;
;     if (hwnd == hwndDragIcon)
;	  return(TRUE);
;
;     for ( ; hwnd != NULL; hwnd = hwnd->hwndParent)
;     {
;	  if (!TestWF(hwnd, WFVISIBLE))
;	      return FALSE;
;     }
;     return TRUE;
; }
;
LabelFP <PUBLIC, IsWindowVisible>
;ParmW hwnd
	    pop     ax			; pop return address
	    pop     dx
	    pop     bx			; bx = hwnd
	    push    dx			; push return address
	    push    ax

	    push    ds
	    UserDStoDS			; es = USER's DS

	    CheckHwnd bx		; checkhwnd will zero ax if failure
	    jz	    ivwexit

	    mov     ax,TRUE		; assume TRUE

; Check if this is the iconic window being moved around with a mouse */
; If so, return a TRUE, though, strictly speaking, it is hidden.     */
; This helps the Tracer guys from going crazy!			     */
; Fix for Bug #57 -- SANKAR -- 08-08-89 --			     */
;
	    cmp     bx,hwndDragIcon	; hwnd == hwndDragIcon?
	    jz	    ivwexit		; yes: return TRUE.
ivwloop:
	    or	    bx,bx		; while (hwndChild == NULL &&
	    jz	    ivwexit
	    TSTWF   bx,WFVISIBLE
	    mov     bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
	    jnz     ivwloop		; if visible bit set, keep looping

	    xor     ax,ax		; visible bit clear: return FALSE
ivwexit:
	    pop     ds
	    retf


;=======================================================================
;
; Return whether or not a given window can be drawn in or not.
;
; BOOL FAR IsVisible(HWND hwnd, BOOL fClient)
; {
;     HWND hwndT;
;
;     for (hwndT = hwnd; hwndT != NULL; hwndT = hwndT->hwndParent)
;     {
;	  // Invisible windows are always invisible
;	  //
;	  if (!TestWF(hwndT, WFVISIBLE))
;	      return FALSE;
;
;	  if (TestWF(hwndT, WFICONIC))
;	  {
;	      // Children of icons are always invisible.
;	      //
;	      if (hwndT != hwnd)
;		  return FALSE;
;
;	      // Client areas with class icons are always invisible.
;	      //
;	      if (fClient && hwndT->pcls->hIcon)
;		  return FALSE;
;	  }
;     }
;     return TRUE;
; }
;
LabelFP <PUBLIC, IsVisible>
	pop	ax
	pop	dx
	pop	cx	    ; cx = fClient
	pop	bx	    ; bx = hwnd
	push	dx
	push	ax

	mov	dx,bx	    ; hwnd = dx, bx = hwndT
	xor	ax,ax	    ; assume FALSE return
	jmps	iv100	    ; fall into loop...
ivloop:
	mov	bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
iv100:
	or	bx,bx
	jz	ivtrue	    ; Reached the top: return TRUE

	TSTWF	bx,WFVISIBLE ; if not visible, get out of here.
	jz	ivfalse

	TSTWF	bx,WFMINIMIZED ; if not minimized, keep looping
	jz	ivloop

	cmp	bx,dx	    ; if (hwnd != hwndT)
	jnz	ivfalse     ;	return FALSE

	jcxz	ivloop	    ; if fClient == FALSE, keep going.

	mov	bx,[bx].wndPcls
	mov	bx,[bx].uclshIcon
	or	bx,bx
	jnz	ivfalse
	mov	bx,dx	    ; resume enumeration at bx
	jmps	ivloop	    ; keep looping...
ivtrue:
	inc	al	    ; ax = TRUE
ivfalse:
	retf

;*--------------------------------------------------------------------------*
;*									    *
;*  GetMenu() - 							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetMenu, <FAR, PUBLIC>,<si>

ParmW hwnd

cBegin
	    mov     si,hwnd
	    CheckHwnd si
	    jz	    gmexit
	    mov     ax,[si].wndhMenu
gmexit:

cEnd
endif ;WOW

;*--------------------------------------------------------------------------*
;*									    *
;*  SwapHandle() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Takes a far pointer to a word on the stack and converts it from a handle
; into a segment address or vice-versa.  Note that this function is a NO OP 
; in protect mode.

ifndef PMODE
cProc SwapHandle, <PUBLIC, FAR, NODATA, ATOMIC>

ParmD lpHandle

cBegin
ifndef WOW
            mov     ax,__WinFlags
            test    ax,1
            jnz     sh200            ; SwapHandle is a no op in pmode.
endif
	    ; Save the parameter.
	    mov     bx,off_lpHandle
	    push    bx

	    ; Get the handle/segment
	    mov     ax,word ptr ss:[bx]+2
	    push    ax			    ; Save it

	    ; Call GlobalHandleNorip which puts the proper handle in AX
	    ;  and the corresponding segment address in DX.
	    push    ax
	    call    GlobalHandleNorip

	    ; Restore the original word.
	    pop     bx

	    ; If DX==CS then we know we've converted a handle into a segment.
	    ;	This prevents problems with the FFFE segment.
	    mov     cx,cs
	    cmp     dx,cx
	    je	    sh50

	    ; Was the original word a segment address?
	    test    bl,1
	    jnz     sh100		    ; Yes, AX = handle, DX = segment

sh50:	    xchg    ax,dx		    ; Nope, AX = segment, DX = handle

	    ; Restore the pointer to the original word.
sh100:	    pop     bx

	    ; Skip if zero.
	    or	    ax,ax
	    jz	    sh200

	    ; Move the result into the original word pointed to.
	    mov     word ptr ss:[bx]+2,ax
sh200:
cEnd
endif ;PMODE

ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  SwapMouseButton() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

; BOOL SwapMouseButton(fSwap)
; BOOL fSwap;

LabelFP <PUBLIC, SwapMouseButton>
            mov     ax,_INTDS
            mov     es,ax
assumes es,INTDS
	    mov     ax,es:fSwapButtons	; Return fSwapButtons' old value
	    pop     cx			; Pop off the FAR return
	    pop     dx
	    pop     es:[fSwapButtons]	; fSwapButtons = fSwap

            mov     bx,es:[fSwapButtons]
assumes es,NOTHING

            mov     es,WORD PTR cs:[cstods] ; Get user's ds
assumes es,DATA
            mov     es:[rgwSysMet+SM_SWAPBUTTON*2],bx
assumes es,NOTHING

	    push    dx			; Restore the FAR return
	    push    cx
	    retf
assumes es,NOTHING

endif; Not WOW


;*--------------------------------------------------------------------------*
;*									    *
;*  SetDivZero() -							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelFP <PUBLIC, SetDivZero>
	    push    ds
	    push    cs			; Set DS == CS
	    pop     ds
ifndef userhimem
            mov     dx,Offset DivideByZero
else
            push    ds
            mov	    ax, _INTDS
            mov     ds,ax
assumes ds,INTDS
            mov     ax,fffedelta
            pop     ds
assumes ds,DATA
            add     ax,Offset DivideByZero
            mov     dx,ax
endif
sdzvector:
	    mov     ax,2500h		; Use DOS to set interrupt zero
	    int     21h
	    pop     ds
	    retf



;*--------------------------------------------------------------------------*
;*									    *
;*  DivideByZero() -							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelFP <PUBLIC, DivideByZero>
            FSTI
ifdef DEBUG
            pusha
            push    es
endif

	    ; Put up the system modal message box.
            mov     cx,_INTDS
ifdef WOW
            ; Put up the SysErrorBox Directly
            push    cx
            lea     ax,szDivZero
            push    ax

            push    cx
            lea     ax,szSysError
            push    ax

ifdef DEBUGlater

            push    SEB_CLOSE
            push    0
            push    SEB_CANCEL
            call    SysErrorBox
            cmp     ax,SEB_BTN1
            jz      DBZ_Terminate

            pop     es
            popa
            DebugErr DBF_FATAL, "Divide by zero or divide overflow error: break and trace till IRET"
            iret

DBZ_Terminate:
            pop     es
            popa
else ; FREE Build
            push    0                       ; no button 1
            push    SEB_CLOSE               ; only allow close
            push    0                       ; no button 3
            call    SysErrorBox
endif; FREE Build
	    mov     ax,4C00h		    ; Abort the task with a 0
            int     21h

else; Not WOW
	    xor     ax,ax
	    push    ax			    ; NULL hwnd
	    lea     ax,szDivZero
	    push    cx
	    push    ax			    ; Message Text
	    lea     ax,szSysError
	    push    cx
	    push    ax			    ; Caption Text
ifdef DEBUG
	    mov     ax,MB_SYSTEMMODAL OR MB_ICONHAND OR MB_OKCANCEL
else
	    mov     ax,MB_SYSTEMMODAL OR MB_ICONHAND
endif
	    push    ax
            call    MessageBox
ifdef DEBUG
            cmp     ax,1                 ; If OK Button clicked, terminate app
            jz      DBZ_Terminate

            pop     es
            popa
            DebugErr DBF_FATAL, "Divide by zero or divide overflow error: break and trace till IRET"
            iret

DBZ_Terminate:
            pop     es
            popa
endif
endif; Not WOW
	    mov     ax,4C00h		    ; Abort the task with a 0
            int     21h

ifndef WOW

;-------------------------------------------------------------------------
;
;   word FAR PASCAL GetUserLocalObjType(pObj)
;     Given a near pointer to an object in USER's local heap, this function
;     determines the type of the object and returns it;
;   It finds out if the given object is a non-tagged belonging to the atom
;   table; If not, it looks at the tag and returns the object type.
;
;   WARNING:  Because this function determines the type of the object by
;   the process of elimination, the results will be unpredictable if the 
;   input in incorrect. i.e., no validation is done on the input value;
;   To validate if the input value is indeed an object in USER's heap would
;   warant a walk down the heap; This will be very costly, if done for
;   every call; Apps like HeapWalker are expected to walk down the USER's
;   local heap and make calls to this function for every object thay come
;   accross; So, a validation done here is duplication of effort and affect
;   the performance unnecessarily
;
;
;-------------------------------------------------------------------------

ifndef DEBUG
; The following is in the RETAIL version of USER
LabelFP	<PUBLIC, GetUserLocalObjType>
	xor   ax, ax	; Return Unknown struct type
	retf  2		; Compensate for the WORD parameter
else
; The following is in the DEBUG version of USER

cProc	GetUserLocalObjType, <PUBLIC, FAR>, <si, di>

ParmW	pObj	; Near pointer to an OBJ in USER's heap

cBegin
	; Now DS register is pointing to USER's DS
	;
	; Check if the object is a moveable object
	mov	bx, pObj
	mov	ax, [bx].la_prev
	test	ax, 01   ; is it a free object
	jz	FoundFreeObj
	test	ax, 02	 ; Is it a moveable object
	jz      FoundFixedObj
	; Now, it is a moveable obj; So, we have the tags
	mov	al, byte ptr [bx + SIZE LocalArena]
	xor     ah, ah
	jmps	FoundObjType

FoundFreeObj:
	mov	ax, ST_FREE
	jmps	FoundObjType

FoundFixedObj:
	; Assume that the object belongs to atom table
	mov	ax, ST_ATOMS

	; Check if this object is the atom table itself
	add	bx, SIZE LocalArena - 2
	cmp	bx, ds:[8]	; pAtomTable  is at this offset.
	je	FoundObjType

	; Check if this is possibly an atom string. If so, the first word
	; stored in this object is a ptr to the next string or NULL;
	; Check if the last two bits are zero; If they are not zero, then
	; this can not be an atom; If they are zero, this may or may not be
	; an atom;

	mov	cx, [bx]
	and	cx, 03h
	jnz	NotAnAtom

	; Now walk down the atom table and check each entry against the 
	; given object

	mov	dx, bx	; save the near pointer to the object
	mov	bx, ds:[8]	; Get the pointer to the atom table pAtomTable
	mov	cx, [bx].at_prime	; Get the number of entries
	; Skip to the first entry in the atom table
	errnz   <at_hashtable - 2>
AtomLoop2:
	errnz	<SIZE at_hashtable - 2>
	add	bx, 2			; 
	errnz   <a_chain>
	mov	si, [bx]	; Pointer to the next string
AtomLoop:
	or	si, si
	jz	NextBucket	; Goto NextBucket

	;Check the new atom matches the given object
	cmp	si, dx
	jz	FoundObjType	; AX already has ST_ATOMS in it
	mov	si, [si].a_chain
	jmps	AtomLoop

NextBucket:
	loop	AtomLoop2
	mov	bx, dx 	       ; Make bx point to the first byte of the object

NotAnAtom:
	; bx points to the tag byte of the object
	xor	ah, ah
	mov	al, byte ptr [bx]
FoundObjType:
	; ax already contains the proper return value 
cEnd
endif

endif ;WOW


;*--------------------------------------------------------------------------*
;*									    *
;*  mouse_event() -                                                         *
;*									    *
;*--------------------------------------------------------------------------*

;       Mouse interrupt event routine
;
;       Entry:  (ax) = flags:
;                 01h = mouse move
;                 02h = left button down
;                 04h = left button up
;                 08h = right button down
;                 10h = right button up
;		  20h = middle button down
;		  40h = middle button up
;               8000h = absolute move
;               (bx) = dX
;               (cx) = dY
;               (dx) = # of buttons, which is assumed to be 2.
;               (si) = extra info loword (should be null if none)
;		(di) = extra info hiword (should be null if none)
;
;       Exit:   None
;
;       Uses:   All registers
;

ExternFP <MouseEvent> ; Thunk in user4.asm

LabelFP <PUBLIC, mouse_event>
        push    si                          ; Preserve the same regs as Win3.1
        regptr  disi,di,si
        cCall   <FAR PTR MouseEvent>, <ax,bx,cx,dx,disi>
        pop     si
        retf

LabelFP <PUBLIC, GetMouseEventProc>
        mov     dx,cs
        mov     ax,offset mouse_event
        retf


;*--------------------------------------------------------------------------*
;*									    *
;*  keybd_event() -                                                         *
;*									    *
;*--------------------------------------------------------------------------*

; Keyboard interrupt handler.
;
; ENTRY: AL = Virtual Key Code, AH = 80 (up), 00 (down)
;	 BL = Scan Code
;	 BH = 0th bit is set if it is an enhanced key(Additional return etc.,).
;        SI = LOWORD of ExtraInfo for the message
;	 DI = HIWORD of ExtraInfo for the message
;
; NOTES: This routine must preserve all registers.

ExternFP <KeybdEvent> ; Thunk in user4.asm

LabelFP <PUBLIC, keybd_event>
	    push    es			    ; Preserve the registers
	    push    dx
	    push    cx
	    push    bx
            push    ax
            regptr  disi,di,si
            cCall   <FAR PTR KeybdEvent>, <ax,bx,disi>
            pop     ax
            pop     bx
            pop     cx
            pop     dx
            pop     es
            retf

sEnd %SEGNAME

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winnet.asm ===
;
;   WINNET.ASM
;
;   Access to WINNET calls via user
;
;

memS=1
?WIN=1
?PLM=1

.xlist
include cmacros.inc
.list

WN_SUCCESS      equ 0
WN_NOT_SUPPORTED    equ 1       ; returned if no function exported

;
;   Network information structure, containing the
;   list of driver entrypoints
;
netinfo struc

    lpfnOpenJob     dd  ?       ; @1
    lpfnCloseJob    dd  ?       ; @2
    lpfnAbortJob    dd  ?       ; @3
    lpfnHoldJob     dd  ?       ; @4
    lpfnReleaseJob  dd  ?       ; @5
    lpfnCancelJob   dd  ?       ; @6
    lpfnSetJobCopies    dd  ?       ; @7
    lpfnWatchQueue  dd  ?       ; @8
    lpfnUnwatchQueue    dd  ?       ; @9
    lpfnLockQueueData   dd  ?       ; @10
    lpfnUnlockQueueData dd  ?       ; @11
    lpfnGetConnection   dd  ?       ; @12
    lpfnGetCaps     dd  ?       ; @13
    lpfnDeviceMode  dd  ?       ; @14
    lpfnBrowseDialog    dd  ?       ; @15
    lpfnGetUser     dd  ?       ; @16
    lpfnAddConnection   dd  ?       ; @17
    lpfnCancelConnection dd ?       ; @18
    lpfnGetError    dd  ?       ; @19
    lpfnGetErrorText    dd  ?       ; @20
    lpfnEnable      dd  ?       ; @21
    lpfnDisable     dd  ?       ; @22
    lpfnRestoreConnection dd ?      ; @23
    lpfnWriteJob    dd  ?       ; @24
    lpfnConnectDialog   dd  ?       ; @25
    lpfnDisconnectDialog dd ?       ; @26
    lpfnConnectionDialog dd ?       ; @27
    lpfnViewQueueDialog dd  ?       ; @28
    lpfnPropertyDialog  dd  ?       ; @29
    lpfnGetDirectoryType dd ?       ; @30
    lpfnDirectoryNotify dd  ?       ; @31
    lpfnGetPropertyText dd  ?       ; @32

netinfo  ends

createSeg   _%SEGNAME,cd,word,public,CODE

sBegin data

pNetInfo    dw     0       ; near pointer to network information
public pNetInfo

hWinnetDriver  dw  0       ; handle to driver module
public hWinnetDriver

sEnd data


sBegin cd
assumes cs,cd
assumes es,data

;-----------------------
;   NetCall
;
;   Move the offset of the function pointer in the net info structure, and
;   call the function which does the bulk of the work (near call).  If the
;   call runs into an error, it will return, otherwise, it will not return,
;   it will pop the return address and jump to the net driver.  No prologue
;   or epilogue needs to be generated.  If CallNetDriver returns, though,
;   we need to pop the parameters off the stack.  In cMacros, the size of
;   these parameters is stored in the ?po variable.
;
;   ?po gets set to zero in order to avoid a WHOLE LOT of "possible invalid
;   use of nogen" warning messages.
;
;   Realize that this is, after all, a hack, the purpose of which is to
;   reduce code.
;
NetCall macro   lpfn

__pop   =   ?po
?po =   0

&cBegin <nogen>

    mov     bx,lpfn
    call    CallNetDriver
    ret     __pop

&cEnd <nogen>

endm

;--------------------------------------------------------------------------
;   CallNetDriver
;
;   This function does all the work.  For each entry point there is a small
;   piece of code which loads the offset of the function pointer in the net
;   info structure into SI and calls this function.  This function verifies
;   that the net driver is loaded and calls the appropriate function
;

LabelFP <PUBLIC, FarCallNetDriver>
CallNetDriver   proc    near

    mov     ax,_DATA
    mov     es,ax

    cmp     es:pNetInfo,0      ; net driver loaded?
    jz      cnd_error           ; return error code

    add     bx,es:pNetInfo     ; add the base of the table
    cmp     word ptr es:[bx+2],0    ; is there a segment there?
    jz      cnd_error           ; NULL, return error code

    pop     ax              ; remove near return address

    jmp     dword ptr es:[bx]       ; jump into net driver

cnd_error:
    mov     ax,WN_NOT_SUPPORTED     ; return error code
    ret                 ; return to entry point code

CallNetDriver   endp

;--------------
;   WNetGetCaps
;
;   This function returns a bitfield of supported functions rather than an
;   error code, so we return 0 (no functions supported) instead of an error
;   code if there is no driver GetCaps function to call.  Also, hack to get
;   handle for index -1.
;

cProc WNetGetCaps2, <FAR,PUBLIC>

    parmW   nIndex

cBegin  <nogen>

    mov     bx,lpfnGetCaps
    call    CallNetDriver
    xor     ax,ax
    ret     ?po

cEnd    <nogen>

if 0
; this is now in C (net.c)
assumes ds,data

cProc IWNetGetCaps, <FAR,PUBLIC, NODATA>

    parmW   nIndex

cBegin
    cmp     nIndex, 0FFFFh
    jz      gc_gethandle
    cCall   WNetGetCaps2, <nIndex>
    jmp     short gc_exit

gc_gethandle:
    mov     ax, _DATA
    mov     es, ax
assumes es, DATA
    mov     ax, es:hWinnetDriver
assumes es, NOTHING

gc_exit:
cEnd

assumes ds,nothing
endif


;--------------
;   IWNetGetUser
;
cProc IWNetGetUser, <FAR,PUBLIC, NODATA>

    parmD   szUser
    parmD   lpBufferSize

NetCall lpfnGetUser


;--------------------
;   IWNetAddConnection
;
cProc IWNetAddConnection , <FAR, PUBLIC, NODATA>

    parmD szNetPath
    parmD szPassword
    parmD szLocalName

NetCall lpfnAddConnection

;-----------------------
;   IWNetCancelConnection
;
cProc IWNetCancelConnection , <FAR, PUBLIC, NODATA>

    parmD szName
    parmW fForce

NetCall lpfnCancelConnection

;---------------------
;   IWNetGetConnection
;
cProc IWNetGetConnection , <FAR, PUBLIC, NODATA>

    parmD lpszLocalName
    parmD lpszRemoteName
    parmD lpcbBuffer

NetCall lpfnGetConnection


;--------------------
;   IWNetOpenJob
;
cProc IWNetOpenJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmD szJobTitle
    parmW nCopies
    parmD lpfh

NetCall lpfnOpenJob

;--------------------
;   IWNetCloseJob
;
cProc IWNetCloseJob , <FAR, PUBLIC, NODATA>

    parmW fh
    parmD lpidJob
    parmD szQueue

NetCall lpfnCloseJob

;-----------------
;   IWNetHoldJob
;
cProc IWNetHoldJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob

NetCall lpfnHoldJob

;--------------------
;   IWNetReleaseJob
;
cProc IWNetReleaseJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob

NetCall lpfnReleaseJob

;---------------------
;   IWNetCancelJob
;
cProc IWNetCancelJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob

NetCall lpfnCancelJob

;--------------------
;   IWNetSetJobCopies
;
cProc IWNetSetJobCopies , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob
    parmW nCopies

NetCall lpfnSetJobCopies

;--------------------
;   IWNetDeviceMode
;
cProc IWNetDeviceMode , <FAR, PUBLIC, NODATA>

    parmW   hwnd

NetCall lpfnDeviceMode

;--------------------
;   IWNetBrowseDialog
;
cProc IWNetBrowseDialog , <FAR, PUBLIC, NODATA>

    parmW   hwnd
    parmW   nFunction
    parmD   szPath
    parmD   lpnSize

NetCall lpfnBrowseDialog

;--------------------
;   IWNetWatchQueue
;
cProc IWNetWatchQueue , <FAR, PUBLIC, NODATA>

    parmW   hwnd
    parmD   szLocal
    parmD   szUsername
    parmW   wIndex

NetCall lpfnWatchQueue

;--------------------
;   IWNetUnwatchQueue
;
cProc IWNetUnwatchQueue , <FAR,PUBLIC, NODATA>

    parmD   szQueue

NetCall lpfnUnwatchQueue

;---------------------
;   IWNetLockQueueData
;
cProc IWNetLockQueueData , <FAR, PUBLIC, NODATA>

    parmD   szQueue
    parmD   szUsername
    parmD   lplpQueue

NetCall lpfnLockQueueData

;------------------------
;   IWNetUnlockQueueData
;
cProc IWNetUnlockQueueData , <FAR, PUBLIC, NODATA>

    parmD   szQueue

NetCall lpfnUnlockQueueData

;------------------------
;   IWNetGetError
;
cProc IWNetGetError , <FAR, PUBLIC, NODATA>

    parmD   lpnError

NetCall lpfnGetError

;------------------------
;   IWNetGetErrorText
;
cProc IWNetGetErrorText , <FAR, PUBLIC, NODATA>

    parmW   nError
    parmD   lpBuffer
    parmD   lpnSize

NetCall lpfnGetErrorText

;----------------------
;   IWNetAbortJob
;
cProc IWNetAbortJob , <FAR, PUBLIC, NODATA>

    parmD   lpszQueue
    parmW   fh

NetCall lpfnAbortJob

;-----------------------
;   WNetEnable
;
cProc   WNetEnable, <FAR, PUBLIC, EXPORTED>

NetCall lpfnEnable

;------------------------
;   WNetDisable
;
cProc   WNetDisable, <FAR, PUBLIC, EXPORTED>

NetCall lpfnDisable

;-----------------------
;   WNetWriteJob
;
cProc   WNetWriteJob , <FAR, PUBLIC, EXPORTED>

    parmW   hJob
    parmD   lpData
    parmD   lpcb

NetCall lpfnWriteJob

;-----------------------
;   WNetConnectDialog
;
cProc   WNetConnectDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iType

NetCall lpfnConnectDialog

;-----------------------
;   WNetDisconnectDialog
;
cProc   WNetDisconnectDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iType

NetCall lpfnDisconnectDialog

;-------------------------
;   WNetConnectionDialog
;
cProc   WNetConnectionDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iType

NetCall lpfnConnectionDialog

;---------------------------
;   WNetViewQueueDialog
;
cProc   WNetViewQueueDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmD   lpdev

NetCall lpfnViewQueueDialog

;--------------------------
;   WNetGetPropertyText
;
cProc   WNetGetPropertyText, <FAR, PUBLIC, EXPORTED>

    parmW   iDlg
    parmD   lpName
    parmW   cb

NetCall lpfnGetPropertyText

;--------------------------
;   WNetPropertyDialog
;
cProc   WNetPropertyDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iDlg
    parmD   lpfile

NetCall lpfnPropertyDialog

;---------------------------
;   WNetGetDirectoryType
;
cProc   WNetGetDirectoryType, <FAR, PUBLIC, EXPORTED>

    parmD   lpdir
    parmD   lptype

NetCall lpfnGetDirectoryType

;--------------------------
;   WNetDirectoryNotify
;
cProc   WNetDirectoryNotify, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmD   lpdir
    parmW   wOper

NetCall lpfnDirectoryNotify

sEnd cd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winstack.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINSTACK.ASM
;   Win16 stack munging routines
;
;   History:
;
;   Created 18-Jun-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--

;****************************************************************************
;*                                                                          *
;*  WINSTACK.ASM -                                                          *
;*                                                                          *
;*      Stack Frame setup routines                                          *
;*                                                                          *
;****************************************************************************

ifdef WOW
NOEXTERNS equ 1
endif
.xlist
include user.inc
.list

;
; Short jump macro
;
jmps    macro   adr
        jmp     short (adr)
	endm

;
; XMOV macro
;
;   Use instead of MOV ax,reg.	Saves a byte.
;
xmov	macro	a,b
	xchg	a,b
	endm

ifdef WOWDEBUG
sBegin DATA

externW <pStackTop>
externW <pStackMin>
externW <pStackBot>

sEnd

ifdef DEBUG

sBegin TEXT
ExternFP    <DivideByZero>
sEnd

endif
endif ;WOWDEBUG

createSeg _TEXT, TEXT, WORD, PUBLIC, CODE

assumes CS,TEXT
assumes SS,DATA

sBegin TEXT

	    org     0			; MUST be at the start of each segment
                                        ;  so that WinFarFrame can jump back
                                        ;  to the proper location.

;*--------------------------------------------------------------------------*
;*									    *
;*  _TEXT_NEARFRAME() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

; Call to _segname_NEARFRAME should be in following format:
;
;	    call    _segname_NEARFRAME
;	    db	    cbLocals	 (count of local words to be allocated)
;	    db	    cbParams	 (count of argument words)

LabelNP     <PUBLIC, _TEXT_NEARFRAME>
	    push    cs			; Save the current segment
            jmps    WinNearFrame        ; Jump to the (only) NEARFRAME routine
	    nop
	    nop
	    nop

nf2:	    push    cs			; Save the CS (it may have changed!)
            jmps    WinNearFrame2       ; Jump to the second half of NEARFRAME
	    nop
	    nop
	    nop


;*--------------------------------------------------------------------------*
;*									    *
;*  _TEXT_FARFRAME() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Call to _segname_FARFRAME should be in following format:
;
;	    call    _segname_FARFRAME
;	    db	    cbLocals	 (count of local words to be allocated)
;	    db	    cbParams	 (count of argument words)

LabelNP <PUBLIC, _TEXT_FARFRAME>
	    push    cs			; Save the current segment
            jmps    WinFarFrame         ; Jump to the (only) FARFRAME routine
	    nop
	    nop
	    nop

ifdef WOWDEBUG
ff2:	    jmp     near ptr WinFarFrame2   ; Jump to the second half of FARFRAME
else
ff2:	    jmp     short near ptr WinFarFrame2
endif


ifdef WOWDEBUG
;*--------------------------------------------------------------------------*
;*									    *
;*  __astkovr1() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Stack Overflow checking routine

;externFP <__astkovr>

;__astkovr1: jmp     __astkovr

endif


;*--------------------------------------------------------------------------*
;*									    *
;*  WinNearFrame() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Sets up and dismantles the frame for a NEAR routine.	This routine
; is FAR JMPed to by _segname_NEARFRAME.  It munges the stack so that a
; NEAR RET returns to a JMP to WinNearFrame2 which dismantles the frame.
;
; CX must be is preserved in the first portion.

LabelFP <PUBLIC, WinNearFrame>
	    pop     es			; Get the caller's Code Segment
	    pop     bx			; Get pointer to sizes of args and locals

	    push    bp			; Update the BP chain
	    mov     bp,sp

	    mov     dx,word ptr es:[bx] ; Move the 2 parms in DX

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
	    sub     ax,sp
;	    jae     __astkovr1		; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __astkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     nf100
	    mov     ss:[pStackMin],ax
nf100:	    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

	    mov     ax,offset nf2	; Push the offset of the JMP to
	    push    ax			;  WinNearFrame2 for function's RET

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    es			; Jump back to the function via RETF
	    push    bx

            xor     bx,bx               ; insure ES is 0
            mov     es,bx

	    retf

LabelFP <PUBLIC,WinNearFrame2>
	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value.
	    pop     es			; Get the caller's CS
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

	    mov     sp,bp		; Free the local variables
	    pop     bp			; Restore BP

	    pop     bx			; Get the caller's return address

	    add     sp,cx		; Remove paramters from stack

	    push    es			; Return to caller via RETF
	    push    bx

            xor     bx,bx               ; insure ES is 0
            mov     es,bx

	    retf


;*--------------------------------------------------------------------------*
;*									    *
;*  WinFarFrame() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Sets up and dismantles the frame for a FAR routine.  This routine
; is FAR JMPed to by _segname_NEARFRAME.  It munges the stack so that a
; NEAR RET returns to a JMP to WinFarFrame2 which dismantles the frame.
;
; CX must be is preserved in the first portion.

LabelFP <PUBLIC, WinFarFrame>
	    mov     ax,ds		; This is patched by the loader to become
	    nop 			;   mov ax,DSVAL

	    pop     es			; Get the caller's CS

	    pop     bx			; Get pointer to sizes of args and locals

	    inc     bp			; Make BP odd to mark far frame
	    push    bp			; Update the BP chain
	    mov     bp,sp

	    push    ds			; Save DS
	    mov     dx,word ptr es:[bx] ; Move the 2 parms into DX

	    mov     ds,ax		; Get the new DS from the loader patch

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
           sub     ax,sp
;	    jae     __astkovr1		; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __astkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     ff100
	    mov     ss:[pStackMin],ax
ff100:	    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

	    mov     ax,offset ff2	; Push the offset of the JMP to
	    push    ax			;  WinFarFrame2 for function's RET

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    es			; Jump back to the function via RETF
	    push    bx

            xor     bx,bx		; Ensure es is 0
            mov     es,bx
	    retf

LabelFP <PUBLIC,WinFarFrame2>
	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value.
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

if 0
	    sub     bp,2		; Point BP at the DS value
	    mov     sp,bp		; Free the local variables
	    pop     ds			; Restore DS
	    pop     bp			; Restore BP
	    dec     bp			; Make BP even again

	    pop     bx			; Get the caller's return address
	    pop     es

	    add     sp,cx		; Remove paramters from stack

	    push    es			; Return to caller via RETF
	    push    bx

            xor     bx,bx		; Ensure es is 0
            mov     es,bx
endif

            mov     ds,[bp-2]           ; Restore DS
            lea     bx,[bp+2]           ; get caller's return address
            add     bx,cx               ; Where we want to put the old CS:IP
            mov     cx,[bp+4]           ; get old CS
            mov     ss:[bx+2],cx        ; move it up
            mov     cx,[bp+2]           ; Get old IP
            mov     ss:[bx],cx          ; move it up
            mov     bp,[bp]             ; restore the old BP
            dec     bp                  ; make it even again
            mov     sp,bx               ; point to the moved CS:IP
            retf                        ; later dude

ifdef WOWDEBUG

            ORG     0cch
            jmp     far ptr DivideByZero
endif

sEnd TEXT

ifndef WOW
;==============================================================================
;   FFFE SEGMENT
;==============================================================================

createSeg _FFFE, FFFE, BYTE, PUBLIC, CODE

assumes CS,_FFFE
assumes SS,DATA

sBegin FFFE

	    ORG     0			; This segment must have a magic header
					;  so that we know to move it up into
					;  segment FFFE:0000 if possible
;	    db	    16 DUP ("AC")
;	    db	    16 DUP (0)		; Tony's sleazy zeros


ifdef WOWDEBUG
;*--------------------------------------------------------------------------*
;*									    *
;*  __ffastkovr1() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Stack Overflow checking routine

;__ffastkovr1: jmp   __astkovr

endif


;*--------------------------------------------------------------------------*
;*									    *
;*  _FFFE_NEARFRAME() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

LabelNP <PUBLIC, _FFFE_NEARFRAME>
	    pop     bx			; Get pointer to sizes of args and locals

	    push    bp			; Update the BP chain
	    mov     bp,sp

	    mov     dx,word ptr cs:[bx] ; Move the 2 parms in DX

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
	    sub     ax,sp
;	    jae     __ffastkovr1	; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __ffastkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     ffnf100
	    mov     ss:[pStackMin],ax
ffnf100:    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

ifndef userhimem
	    mov     ax,offset FFFE_nf2	; Munge the stack so the function
else
            push    ds
            mov     ax, _INTDS
            mov     ds,ax
assumes ds,INTDS
            mov     ax,fffedelta
            pop     ds
assumes ds,DATA
            add     ax, OFFSET FFFE_nf2
endif
	    push    ax			;  "returns" to FFFE_nf2

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    bx			; Jump back to the function
	    ret

LabelFP <PUBLIC,FFFE_nf2>
	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

	    mov     sp,bp		; Free the local variables
	    pop     bp			; Restore BP

	    pop     bx			; Get the caller's return address

	    add     sp,cx		; Remove paramters from stack

	    push    bx			; Return to caller
	    ret


;*--------------------------------------------------------------------------*
;*									    *
;*  _FFFE_FARFRAME() -							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelNP <PUBLIC, _FFFE_FARFRAME>
	    mov     ax,ds		; This is patched by the loader to become
	    nop 			;   mov ax,DSVAL

	    pop     bx			; Get pointer to sizes of args and locals

	    inc     bp			; Make BP odd to mark far frame
	    push    bp			; Update the BP chain
	    mov     bp,sp

	    push    ds			; Save DS
	    mov     ds,ax		; Get the new DS from the loader patch

	    mov     dx,word ptr cs:[bx] ; Move the 2 parms into DX

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
	    sub     ax,sp
;	    jae     __ffastkovr1	; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __ffastkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     ffff100
	    mov     ss:[pStackMin],ax
ffff100:    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

ifndef userhimem
	    mov     ax,offset FFFE_ff2	; Munge the stack so the function
else
            push    ds
            mov	    ax, _INTDS
            mov     ds,ax
assumes ds,INTDS
            mov     ax,fffedelta
            pop     ds
assumes ds,DATA
	    add     ax,offset FFFE_ff2	; Munge the stack so the function
endif
	    push    ax			;  "returns" to FFFE_nf2

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    bx			; Jump back to the function
	    ret

	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value

LabelFP     <PUBLIC,FFFE_ff2>
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

	    sub     bp,2		; Point BP at the DS value
	    mov     sp,bp		; Free the local variables
	    pop     ds			; Restore DS
	    pop     bp			; Restore BP
	    dec     bp			; Make BP even again

	    pop     bx			; Get the caller's return address
	    pop     es

	    add     sp,cx		; Remove paramters from stack

	    push    es			; Return to caller via RETF
	    push    bx

            xor     bx,bx		; Ensure es is 0
            mov     es,bx
	    retf

sEnd FFFE


;*--------------------------------------------------------------------------*
;*									    *
;*  CreateFrame Macro - 						    *
;*									    *
;*--------------------------------------------------------------------------*

CreateFrame macro SegName

createSeg _&SegName, SegName, BYTE, PUBLIC, CODE

assumes CS,_&SegName
assumes SS,DATA

sBegin SegName

	    org     0			; MUST be at the start of each segment
                                        ;  so that WinFarFrame can jump back
                                        ;  to the proper location.

LabelNP <PUBLIC, _&SegName&_NEARFRAME>
	    push    cs			; Save the current segment
	    jmp     WinNearFrame	; Jump to the (only) NEARFRAME routine
	    push    cs			; Save the CS (it may have changed!)
	    jmp     WinNearFrame2	; Jump to the second half of NEARFRAME

LabelNP <PUBLIC, _&SegName&_FARFRAME>
	    push    cs			; Save the current segment
	    jmp     WinFarFrame 	; Jump to the (only) FARFRAME routine
	    jmp     WinFarFrame2	; Jump to the second half of FARFRAME

sEnd SegName

	    endm


;==============================================================================
;   SEGMENT FRAMES
;==============================================================================

;CreateFrame INIT
;CreateFrame MDKEY
;CreateFrame MENUCORE
;CreateFrame MENUAPI
;CreateFrame MENUSTART
;CreateFrame RUNAPP
;CreateFrame DLGBEGIN
;CreateFrame DLGCORE
;CreateFrame SCRLBAR
CreateFrame WMGR
CreateFrame WMGR2
;CreateFrame RARE
;CreateFrame LBOX
;CreateFrame LBOXAPI
;CreateFrame LBOXDIR
;CreateFrame LBOXMULTI
;CreateFrame LBOXRARE
;CreateFrame CLPBRD
;CreateFrame COMDEV
;CreateFrame ICON
;CreateFrame SWITCH
;CreateFrame MSGBOX
;CreateFrame MDIWIN
;CreateFrame MDIMENU
;CreateFrame EDECRARE
;CreateFrame EDSLRARE
;CreateFrame EDMLONCE
;CreateFrame EDMLRARE
;CreateFrame WINCRTDST
;CreateFrame WINUTIL
;CreateFrame RESOURCE
;CreateFrame WALLPAPER
;CreateFrame WINSWP
CreateFrame LANG

endif ;WOW

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\wmsyserr.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WMSYSERR.C
 *  WOW16 system error box handling services
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
 *  At this time, all we want is DrawFrame(), which the edit controls use.
--*/

/****************************************************************************/
/*									    */
/*  WMSYSERR.C                                                              */
/*									    */
/*      System error box handling routine                                   */
/*									    */
/****************************************************************************/

#include "user.h"

#ifndef WOW
VOID  FAR  PASCAL  GetbackFocusFromWinOldAp(void);

/* Private export from GDI for user. */
HFONT FAR PASCAL GetCurLogFont(HDC);


/* This array contins the state information for the three possible buttons in
 * a SysErrorBox.  
 */

SEBBTN rgbtn[3];

/* The following arrays are used to map SEB_values to their respective
 * accelerator keys and text strings.  
 */

#define BTNTYPECOUNT	7

static int rgStyles[BTNTYPECOUNT] = 
			  { SEB_OK, SEB_CANCEL, SEB_YES, SEB_NO, SEB_RETRY,
                           SEB_ABORT, SEB_IGNORE };

/* The following array is properly initialised by reading STR_ACCELERATORS
 * string at LoadWindows time, which contains the accelerator keys 
 * corresponding to each button in the message box; Localizers must modify 
 * this string also. Because, this array will be filled by loading a 
 * string we must have one more space for the null terminator.
 */
char rgAccel[BTNTYPECOUNT+1];

extern WORD wDefButton;

int FAR PASCAL SoftModalMessageBox(HWND, LPSTR, LPSTR, WORD);

/*--------------------------------------------------------------------------*/
/*									    */
/*  BltColor() -							    */
/*   									    */
/*   Modification done by SANKAR  on 08-03-89:				    */
/*     The parameter hbm was used as a boolean only to determine whether to */
/*	use hdcBits or hdcGrey; Now hbm is replaced with hdcSrce, the source*/
/*	device context because, now hdcBits contains color bitmaps and      */
/*	hdcMonoBits contains monochrome bitmaps; If hdcSrce is NULL, then   */
/*	hdcGrey will be used, else whatever is passed thro hdcSrce will be  */
/*	used as the source device context;				    */
/*									    */
/*--------------------------------------------------------------------------*/

void FAR PASCAL BltColor(hdc, hbr, hdcSrce, xO, yO, cx, cy, xO1, yO1, fInvert)

register HDC	hdc;
register HBRUSH hbr;
HDC		hdcSrce;
int		xO, yO;
int		cx, cy;
int		xO1, yO1;
BOOL		fInvert;

{
  HBRUSH hbrSave;
  DWORD  textColorSave;
  DWORD  bkColorSave;

#ifdef DEBUG
  if (!hdcGray && !hdcSrce)       /* Only test hdcGray if it will be used */
       FatalExit(RIP_BADDCGRAY);
#endif

  if (hbr == (HBRUSH)NULL)
      hbr = sysClrObjects.hbrWindowText;
  
  /*
   * Set the Text and Background colors so that bltColor handles the
   * background of buttons (and other bitmaps) properly.
   * Save the HDC's old Text and Background colors. This causes problems with
   * Omega (and probably other apps) when calling GrayString which uses this
   * routine...	   
   */
  textColorSave = SetTextColor(hdc, 0x00000000L);
  bkColorSave   = SetBkColor(hdc, 0x00FFFFFFL);

  hbrSave = SelectObject(hdc, hbr);

  BitBlt(hdc, xO, yO, cx, cy, hdcSrce ? hdcSrce : hdcGray, xO1, yO1, 
	 (fInvert ? 0x00B8074AL : 0x00E20746L));

  SelectObject(hdc, hbrSave);

  /* Restore saved colors */
  SetTextColor(hdc, textColorSave);
  SetBkColor(hdc, bkColorSave);
}
#endif // WOW

/*--------------------------------------------------------------------------*/
/*									    */
/*  DrawFrame() -							    */
/*									    */
/*--------------------------------------------------------------------------*/
#define DF_SHIFTMASK (DF_SHIFT0 | DF_SHIFT1 | DF_SHIFT2 | DF_SHIFT3)
#define DF_ROPMASK   (DF_PATCOPY | DF_PATINVERT)
#define DF_HBRMASK   ~(DF_SHIFTMASK | DF_ROPMASK)

/* Command bits:
 *    0000 0011 - (0-3): Shift count for cxBorder and cyBorder
 *    0000 0100 - 0: PATCOPY, 1: PATINVERT
 *    1111 1000 - (0-x): Brushes as they correspond to the COLOR_*
 *			 indexes, with hbrGray thrown on last.
 */

void USERENTRY DrawFrame(hdc, lprc, clFrame, cmd)
HDC    hdc;
LPRECT lprc;
int    clFrame;
int    cmd;
{
    register int x;
    register int y;
    int 	 cx;
    int 	 cy;
    int 	 cxWidth;
    int 	 cyWidth;
    int 	 ibr;
    HBRUSH	 hbrSave;
    LONG	 rop;
#ifdef WOW
    DWORD	 rgbTemp;
    static DWORD rgbPrev;
    static HBRUSH hbrPrev;
#endif

    x = lprc->left;
    y = lprc->top;

    cxWidth = GetSystemMetrics(SM_CXBORDER) * clFrame;
    cyWidth = GetSystemMetrics(SM_CYBORDER) * clFrame;

    if (cmd == DF_ACTIVEBORDER || cmd == DF_INACTIVEBORDER)
    {
	/* We are drawing the inside colored part of a sizing border. We
	 * subtract 1 from the width and height because we come back and draw
	 * another frame around the inside. This avoids a lot of flicker when
	 * redrawing a frame that already exists.
	 */
	cxWidth--;
	cyWidth--;
    }

    cx = lprc->right - x - cxWidth;
    cy = lprc->bottom - y - cyWidth;

    rop = ((cmd & DF_ROPMASK) ? PATINVERT : PATCOPY);

    ibr = (cmd & DF_HBRMASK) >> 3;
#ifndef WOW
    if (ibr == (DF_GRAY >> 3))
    {
	hbrSave = hbrGray;
    }
    else
    {
	hbrSave = ((HBRUSH *)&sysClrObjects)[ibr];
    }
#else
	rgbTemp = GetSysColor(ibr);
	if (!(hbrSave = hbrPrev) || rgbTemp != rgbPrev) {
	    /* Save time and space with black and white objects. */
	    if (rgbTemp == 0L)
		hbrSave = GetStockObject(BLACK_BRUSH);
	    else if (rgbTemp == 0xFFFFFFL)
		hbrSave = GetStockObject(WHITE_BRUSH);
	    else
		hbrSave = CreateSolidBrush(rgbTemp);
	    if (hbrPrev)
		DeleteObject(hbrPrev);
	    hbrPrev = hbrSave;
	    rgbPrev = rgbTemp;
	}
#endif

    // We need to unrealize the object in order to ensure it gets realigned.
    //
    UnrealizeObject(hbrSave);
    hbrSave = SelectObject(hdc, hbrSave);

    /* Time to call the new driver supported fast draw frame stuff. */
    if (lprc->top >= lprc->bottom ||
	!FastWindowFrame(hdc, lprc, cxWidth, cyWidth, rop))
    {
	/* The driver can't do it so we have to. */
	PatBlt(hdc, x, y, cxWidth, cy, rop);		      /* Left	*/
	PatBlt(hdc, x + cxWidth, y, cx, cyWidth, rop);	      /* Top	*/
	PatBlt(hdc, x, y + cy, cx, cyWidth, rop);	      /* Bottom */
	PatBlt(hdc, x + cx, y + cyWidth, cxWidth, cy, rop);   /* Right	*/
    }

    if (hbrSave)
	SelectObject(hdc, hbrSave);
}


#ifndef WOW
/*--------------------------------------------------------------------------*/
/*  DrawPushButton() -							    */
/*									    */
/*    lprc    : The rectangle of the button				    */
/*    style   : Style of the push button				    */
/*    fInvert : FALSE  if pushbutton is in NORMAL state			    */
/*              TRUE   if it is to be drawn in the "down" or inverse state  */
/*    hbrBtn  : The brush with which the background is to be wiped out.	    */
/*    hwnd    : NULL   if no text is to be drawn in the button;		    */
/*		Contains window handle, if text and focus is to be drawn;   */
/*									    */
/*--------------------------------------------------------------------------*/

void FAR PASCAL DrawPushButton(hdc, lprc, style, fInvert, hbrBtn, hwnd)

register HDC hdc;
RECT FAR     *lprc;
WORD	     style;
BOOL	     fInvert;
HBRUSH	     hbrBtn;
HWND	     hwnd;

{
    RECT	rcInside;
    HBRUSH	hbrSave;
    HBRUSH      hbrShade = 0;
    HBRUSH      hbrFace = 0;
    int		iBorderWidth;
    int		i;
    int         dxShadow;
    int         cxShadow;
    int         cyShadow;


    if (style == LOWORD(BS_DEFPUSHBUTTON))
        iBorderWidth = 2;
    else
        iBorderWidth = 1;

    hbrSave = SelectObject(hdc, hbrBtn);

    CopyRect((LPRECT)&rcInside, lprc);
    InflateRect((LPRECT)&rcInside, -iBorderWidth*cxBorder, 
		  		   -iBorderWidth*cyBorder);

    /* Draw a frame */
    DrawFrame(hdc, lprc, iBorderWidth, (COLOR_WINDOWFRAME << 3));

    /* Notch the corners (except don't do this for scroll bar thumb (-1) or 
       for combo box buttons (-2)) */
    if (style != -1 && style != -2)
      {
        /* Cut four notches at the four corners */
        /* Top left corner */
        PatBlt(hdc, lprc->left, lprc->top, cxBorder, cyBorder, PATCOPY);
        /* Top right corner */
        PatBlt(hdc, lprc->right - cxBorder, lprc->top, cxBorder, cyBorder, 
	       PATCOPY);
        /* bottom left corner */
        PatBlt(hdc, lprc->left, lprc->bottom - cyBorder, cxBorder, cyBorder, 
               PATCOPY);
        /* bottom right corner */
        PatBlt(hdc, lprc->right - cxBorder, lprc->bottom - cyBorder, cxBorder,
               cyBorder, PATCOPY);
      }

    /* Draw the shades */
    if (sysColors.clrBtnShadow != 0x00ffffff)
      {
        hbrShade = sysClrObjects.hbrBtnShadow;
        if (fInvert)
          {
            /* Use shadow color */
            SelectObject(hdc, hbrShade);
            dxShadow = 1;
          }
        else
          {
            /* Use white */
            SelectObject(hdc, GetStockObject(WHITE_BRUSH));
            dxShadow = (style == -1 ? 1 : 2);
          }

        cxShadow = cxBorder * dxShadow;
        cyShadow = cyBorder * dxShadow;

        /* Draw the shadow/highlight in the left and top edges */
        PatBlt(hdc, rcInside.left, rcInside.top, cxShadow,
                                (rcInside.bottom - rcInside.top), PATCOPY);
        PatBlt(hdc, rcInside.left, rcInside.top,
                        (rcInside.right - rcInside.left), cyShadow, PATCOPY);

        if (!fInvert)
          {
            /* Use shadow color */
            SelectObject(hdc, hbrShade);

            /* Draw the shade in the bottom and right edges */
            rcInside.bottom -= cyBorder;
            rcInside.right -= cxBorder;

            for(i = 0; i <= dxShadow; i++)
              {
                PatBlt(hdc, rcInside.left, rcInside.bottom,
                       rcInside.right - rcInside.left + cxBorder, cyBorder, 
                       PATCOPY);
                PatBlt(hdc, rcInside.right, rcInside.top, cxBorder,
                            rcInside.bottom - rcInside.top, PATCOPY);
                if (i == 0)
                    InflateRect((LPRECT)&rcInside, -cxBorder, -cyBorder);
              }
          }
      }
    else
      {
        /* Don't move text down if no shadows */
        fInvert = FALSE;
	/* The following are added as a fix for Bug #2784; Without these 
	 * two lines, cxShadow and cyShadow will be un-initialised when
	 * running under a CGA resulting in this bug;
	 *  Bug #2784 -- 07-24-89 -- SANKAR
	 */
	cxShadow = cxBorder;
	cyShadow = cyBorder;
      }

    /* Draw the button face color pad. If no clrBtnFace, use white to clear
       it. */
    /* if fInvert we don't subtract 1 otherwise we do because up above we
       do an inflate rect if not inverting for the shadow along the bottom*/
    rcInside.left += cxShadow - (fInvert ? 0 : cxBorder);
    rcInside.top  += cyShadow - (fInvert ? 0 : cyBorder);
    if (sysColors.clrBtnFace != 0x00ffffff)
        hbrFace = sysClrObjects.hbrBtnFace;		
    else
        hbrFace = GetStockObject(WHITE_BRUSH);

    SelectObject(hdc, hbrFace);
    PatBlt(hdc, rcInside.left, rcInside.top, rcInside.right - rcInside.left,
                rcInside.bottom - rcInside.top, PATCOPY);

    if (hbrSave)
        SelectObject(hdc, hbrSave);
}
    

/*
 *---------------------------------------------------------------------------
 * SEB_InitBtnInfo() -
 *  This function fills in the button info structure (SEBBTN) for the
 *  specified button.
 *---------------------------------------------------------------------------
 */
void NEAR PASCAL SEB_InitBtnInfo(
   HDC           hdc,            /* DC to be used in dispplaying the button */
   unsigned int  style,          /* one of the SEB_* styles */
   int           xBtn, 
   int           yBtn,           /* center the button on this (x, y) pixel */
   int           cxBtn, 
   int           cyBtn,          /* make the button this size */
   int           index)          /* index of the rgbtn entry to initialize */

{
    long    Extent;
    int     i;
    int     temp1, temp2;
#ifdef DEBUG
    BOOL    fFound = FALSE;
#endif

    rgbtn[index].finvert = FALSE;
    if ((rgbtn[index].style = style) == NULL)
        return;

    /* Calc the button text and accelerator */
    for (i = 0; i < MAX_MB_STRINGS; i++)
      {
        if (rgStyles[i] == (style & ~SEB_DEFBUTTON))
          {
            rgbtn[index].psztext = AllMBbtnStrings[i];
            rgbtn[index].chaccel = rgAccel[i];
#ifdef DEBUG
            fFound = TRUE;
#endif
            break;
          }
      }
#ifdef DEBUG
    if (!fFound)
      {
        /* RIP city */
        return;
      }
#endif

    /* Calc the button rectangle */
    SetRect((LPRECT)&rgbtn[index].rcbtn,
                (temp1 = xBtn - (cxBtn >> 1)),
                (temp2 = yBtn - (cyBtn >> 1)),
                temp1 + cxBtn,
                temp2 + cyBtn);

    /* Calc the text position */
    Extent = PSMGetTextExtent(hdc, 
	                      (LPSTR)rgbtn[index].psztext, 
			      lstrlen((LPSTR)rgbtn[index].psztext));
    rgbtn[index].pttext.x = xBtn - (LOWORD(Extent) >> 1);
    rgbtn[index].pttext.y = yBtn - (HIWORD(Extent) >> 1);
/*    rgbtn[index].pttext.y = yBtn - (cySysFontAscent >> 1);*/
}

/*
 *---------------------------------------------------------------------------
 * SEB_DrawFocusRect() -
 *  This function draws the Focus frame.
 *---------------------------------------------------------------------------
 */

 void NEAR PASCAL SEB_DrawFocusRect(HDC	   hdc,
                                    LPRECT lprcBtn,
                                    LPSTR  lpszBtnStr,
                                    int	   iLen,
                                    BOOL   fPressed)

 {
     DWORD	dwExtents;
     RECT	rc;

     dwExtents = PSMGetTextExtent(hdc, (LPSTR)lpszBtnStr, iLen);

     rc.left = lprcBtn->left + ((lprcBtn->right - lprcBtn->left - LOWORD(dwExtents)) >> 1) - (cxBorder << 1);
     rc.right = rc.left + (cxBorder << 2) + LOWORD(dwExtents);
     rc.top = lprcBtn->top + ((lprcBtn->bottom - lprcBtn->top - HIWORD(dwExtents)) >> 1) - cyBorder;
     rc.bottom = rc.top + (cyBorder << 1) + HIWORD(dwExtents) + cyBorder;

     if(fPressed)
         OffsetRect(&rc, 1, 1);

     /* NOTE: I know you will be tempted to use DrawFocusRect(); But this
      * uses PatBlt() with PATINVERT! This causes instant death in int24
      * SysErrBoxes! So, I am calling FrameRect() which calls PatBlt() with
      * PATCOPY. This works fine in int24 cases also!
      * --SANKAR--
      */
     FrameRect(hdc, (LPRECT)&rc, hbrGray);
}



/*
 *---------------------------------------------------------------------------
 * SEB_DrawButton() -
 *  This function draws the button specified.  The pbtninfo parameter is
 *  a pointer to a structure of type SEBBTN.
 *---------------------------------------------------------------------------
 */
void NEAR PASCAL SEB_DrawButton(HDC hdc,  /* HDC to use for drawing */
                                int i)    /* index of the rgbtn to draw */

  {
    DWORD colorSave;
    int	  iLen;

    if (rgbtn[i].style == NULL)
        return;

    /* DrawPushButton() wipes out the background also */
    DrawPushButton(hdc,
                   (LPRECT)&rgbtn[i].rcbtn,
                   (WORD)((rgbtn[i].style & SEB_DEFBUTTON) ? BS_DEFPUSHBUTTON:
                                                             BS_PUSHBUTTON),
                   rgbtn[i].finvert, 
                   GetStockObject(WHITE_BRUSH), 
                   (HWND)NULL);
    colorSave = SetTextColor(hdc, sysColors.clrBtnText);
    SetBkMode(hdc, TRANSPARENT);
    /* Preserve the button color for vga systems */
    PSMTextOut(hdc,
               rgbtn[i].pttext.x + (rgbtn[i].finvert ? 1 : 0),
               rgbtn[i].pttext.y + (rgbtn[i].finvert ? 1 : 0),
               (LPSTR)rgbtn[i].psztext,
               (iLen = lstrlen((LPSTR)rgbtn[i].psztext)));
    /* Only the default button can have the focus frame */
    if(rgbtn[i].style & SEB_DEFBUTTON)
        SEB_DrawFocusRect(hdc, 
    			(LPRECT)&rgbtn[i].rcbtn,
			(LPSTR)rgbtn[i].psztext,
			iLen, 
			rgbtn[i].finvert);
    SetTextColor(hdc, colorSave);
    SetBkMode(hdc, OPAQUE);    
  }


/*
 *---------------------------------------------------------------------------
 * SEB_BtnHit(pt)
 *  Return the index of the rgbtn that the point is in.  If not in any button
 *  then return -1.
 *---------------------------------------------------------------------------
 */


int NEAR SEB_BtnHit(int x, int y)
{
    POINT pt;
    register int i;

    pt.x = x;
    pt.y = y;

    for (i = 0; i <= 2; i++)
      {
        if (rgbtn[i].style != NULL)
            if (PtInRect((LPRECT)&rgbtn[i].rcbtn, pt))
                return(i);
      }
    return(-1);
}



/*
 *---------------------------------------------------------------------------
 *  SysErrorBox()
 *
 * This function is used to display a system error type message box.  No
 * system resources (other than the stack) is used to display this box.
 * Also, it is guarenteed that all code needed to complete this function
 * will be memory at all times.  This will allow the calling of this
 * funtion by the INT24 handler.
 *
 * Paramerers:
 *      lpszText    Text string of the message itself.  This message is
 *                  assumed to be only one line in length and short enough
 *                  to fit in the box.  The box will size itself horizontally
 *                  to center the string, but will not be sized beyond the
 *                  size of the physical screen.
 *
 *      lpszCaption Text of the caption of the box.  This caption will be
 *                  displayed at the top of the box, centered.  The same
 *                  restrictions apply.
 *
 *      Btn1
 *      Btn2
 *      Btn3        One of the following:
 *                      NULL        No button in this position.
 *                      SEB_OK      Button with "OK".
 *                      SEB_CANCEL  Button with "Cancel"
 *                      SEB_YES     Button with "Yes"
 *                      SEB_NO      Button with "No"
 *                      SEB_RETRY   Button with "Retry"
 *                      SEB_ABORT   Button with "Abort"
 *                      SEB_IGNORE  Button with "Ignore"
 *
 *                  Also, one of the parameters may have the value
 *                      SEB_DEFBUTTON
 *                  OR'ed with any of the SEB_* valued above.  This draws
 *                  this button as the default button and sets the initial
 *                  "focus" to this button.  Only one button should have
 *                  this style.  If no buttons have this style, the first
 *                  button whose value is not NULL will be the default button.
 *
 * Return Value:
 *      This funtion returns one of the following values:
 *
 *              SEB_BTN1        Button 1 was selected
 *              SEB_BTN2        Button 2 was selected
 *              SEB_BTN3        Button 3 was selected
 *
 *---------------------------------------------------------------------------
 */



/* Maximum number of lines allowed in a system error box. 
 */
#define MAXSYSERRLINES 3
/* Struct allocated on stack for max lines. 
 */
typedef struct tagSysErr
{
  int iStart;
  int cch;
  int cxText;
} SYSERRSTRUCT;

int USERENTRY SysErrorBox(lpszText, lpszCaption, btn1, btn2, btn3)

LPSTR lpszText;
LPSTR lpszCaption;
unsigned int   btn1, btn2, btn3;

{
  register int cx, cy;
  SYSERRSTRUCT sysErr[MAXSYSERRLINES];
  int   temp;
  int   cchCaption;
  int   cxText, cxCaption, cxButtons;
  int   cxCenter, cxQuarter;
  int   cxBtn, cyBtn;
  int   xBtn, yBtn;
  int   iTextLines;
  HDC   hdc;
  RECT  rcBox, rcTemp;
  HRGN  hrgn;
  int   far *pbtn;
  int   i;
  MSG   msg;
  BOOL  fBtnDown;
  BOOL  fKeyBtnDown = FALSE;
  int   BtnReturn;
  int   btnhit;
  int   defbtn;
  HWND  hwndFocusSave;
  BOOL  fMessageBoxGlobalOld = fMessageBox;
  BOOL  fOldHWInput;
  HWND  hwndSysModalBoxOld;
  LPSTR lptemp;
  RECT  rcInvalidDesktop;   /* Keep union of invalid desktop rects */



  /* We have to determine if we are running Win386 in PMODE 
   * at the time of bringing up this SysErrBox. In this case we
   * have to call Win386 to Set the screen focus to us so that 
   * the user can see the SYSMODAL error message that we display;
   * Fix for Bug #5272  --SANKAR--  10-12-89
   */
  if ((WinFlags & WF_WIN386) && (WinFlags & WF_PMODE))
      GetbackFocusFromWinOldAp();



  /* Set this global so that we don't over write our globals when kernel calls
   * this routine directly. We need to save and restore the state of the
   * fMessageBox flag. If SysErrorBox is called via HardSysModal, then this
   * flag is set and we do proper processing in the message loop. However, if
   * Kernel calls syserrorbox directly, then this flag wasn't being set and we
   * could break...
   */
  fMessageBox = TRUE;

  /* Save off the guy who was the old sys modal dialog box in case the int24
   * box is put up when a sys modal box is up. 
   */
  hwndSysModalBoxOld = hwndSysModal;


  /* Clear this global so that if the mouse is down on an NC area we don't
   * drop into the move/size code when we return.  If we do, it thinks the
   * mouse is down when it really isn't
   */
  fInt24 = TRUE;

  /* Initialise the Global structure */
  LFillStruct((LPSTR)rgbtn, 3*sizeof(SEBBTN), '\0');

  /* Change the hq for the desktop to be the current task hq */
  if (NEEDSPAINT(hwndDesktop))
      DecPaintCount(hwndDesktop);

  hwndDesktop->hq = HqCurrent();

  if (NEEDSPAINT(hwndDesktop))
      IncPaintCount(hwndDesktop);


  hdc = GetScreenDC();

  /*
   * Calculate the extents of the error box.  Then set the rectangle that
   * we will use for drawing.
   *
   * The x extent of the box is the maximin of the the folowing items:
   *    - The text for the box (padded with 3 chars on each end).
   *    - The caption for the box (also padded).
   *    - 3 maximum sized buttons (szCANCEL).
   *
   * The y extent is 10 times the height of the system font.
   *
   */

  cy = cySysFontChar * 10;

  /* How many lines in the box text and their extents etc?
   */
  iTextLines = 0;
  sysErr[0].iStart = 0;
  sysErr[0].cch    = 0;
  sysErr[0].cxText = 0;
  lptemp=lpszText;
  cxText = 0;  /* Max text length 
		*/
  while (lptemp)
    {
      if (*lptemp == '\n' || *lptemp==0)
        {
          sysErr[iTextLines].cxText = LOWORD(GetTextExtent(hdc,
                              (LPSTR)(lpszText+sysErr[iTextLines].iStart),
                              sysErr[iTextLines].cch));

          /* Keep track of length of longest line 
	   */
          cxText = max(sysErr[iTextLines].cxText,cxText);
          if (*lptemp && *(lptemp+1)!=0 && iTextLines < MAXSYSERRLINES)
            {
              /* Another line exists
	       */
              iTextLines++;
              sysErr[iTextLines].iStart = sysErr[iTextLines-1].iStart + 
                                          sysErr[iTextLines-1].cch+1;
              sysErr[iTextLines].cch = 0;
              sysErr[iTextLines].cxText = 0;

              lptemp++;
            }
          else
              break;
        }
      else
        {
          sysErr[iTextLines].cch++;
          lptemp++;
        }
    }
  cx = cxText + (6 * cxSysFontChar);

  /* Get the extent of the box caption 
   */
  cxCaption = LOWORD(GetTextExtent(hdc, 
                                   (LPSTR)lpszCaption, 
                                   (cchCaption = lstrlen(lpszCaption))));
  temp = cxCaption + (6 * cxSysFontChar);

  if (cx < temp)
      cx = temp;

  /* Get the extent of 3 maximum sized buttons */
  cxBtn = wMaxBtnSize + (cySysFontChar << 1);
  cxButtons = (cxBtn + (cySysFontChar << 2)) * 3;

  if (cx < cxButtons)
    cx = cxButtons;

  /* Center the box on the screen.  Bound to left edge if too big. */
  rcBox.top = (cyScreen >> 1) - (cy >> 1);
  rcBox.bottom = rcBox.top + cy;
  rcBox.left = (cxScreen >> 1) - (cx >> 1);
  if (rcBox.left < 0)
    rcBox.left = 0;
  rcBox.right = rcBox.left + cx;
  cxCenter = (rcBox.left + rcBox.right) >> 1;

  PatBlt(hdc, rcBox.left, rcBox.top, cx, cy, WHITENESS);

  rcTemp = rcBox;

  DrawFrame(hdc, &rcTemp, 1, DF_WINDOWFRAME);
  InflateRect(&rcTemp, -(cxBorder * (CLDLGFRAMEWHITE + 1)),
		       -(cyBorder * (CLDLGFRAMEWHITE + 1)));
  DrawFrame(hdc, &rcTemp, CLDLGFRAME, DF_ACTIVECAPTION);

  TextOut(hdc,
          cxCenter - (cxCaption >> 1),
          rcBox.top + cySysFontChar,
          (LPSTR)lpszCaption,
          cchCaption);

  i=0;
  /* First line of text starts at what y offset ?
   */
  if (iTextLines == 0)
      temp = (cySysFontChar << 2);
  else
      temp = (cySysFontChar << 1)+(cySysFontChar * (MAXSYSERRLINES-iTextLines));

  while (i<=iTextLines)
    {
       TextOut(hdc,
/*          cxCenter - (cxText >> 1),*/
               cxCenter - (sysErr[i].cxText >> 1),
               rcBox.top + temp+(i*cySysFontChar),
               (LPSTR)lpszText+sysErr[i].iStart,
               sysErr[i].cch);

      i++;
    }

  pbtn = &btn1;
  xBtn = (cxQuarter = cx >> 2) + rcBox.left;
  yBtn = rcBox.bottom - (cySysFontChar << 1);
  cyBtn = cySysFontChar << 1;

  for (i=0; i <= 2; i++, pbtn--)
    {
      SEB_InitBtnInfo(hdc, *pbtn, xBtn, yBtn, cxBtn, cyBtn, i);
      SEB_DrawButton(hdc, i);
      xBtn += cxQuarter;
    }


  Capture(hwndDesktop, CLIENT_CAPTURE);
  SetSysModalWindow(hwndDesktop);

  /*hCursOld =*/ SetCursor(hCursNormal);
  /* Why are we doing this???? This is causing us to hit the disk to load some
   * cursor resource during interrupt time... davidds 
   */
  /*  CallOEMCursor();*/
  hwndFocusSave = hwndFocus;
  hwndFocus = hwndDesktop;

  fBtnDown = FALSE;
  BtnReturn = 0;
  btnhit = -1;  /* -1 if not on a button, else index into rgbtn[] */
  defbtn = -1;
  for (i = 0; i <= 2; i++)
      if (rgbtn[i].style & SEB_DEFBUTTON)
        {
          defbtn = i;
          break;
        }

  /* Prevent other tasks from running because this is SysModal */
  if (!fEndSession)
      LockMyTask(TRUE);

  /* Insure that hardware input is enabled */
  fOldHWInput = EnableHardwareInput(TRUE);

  /* Initially, only invalidate desktop where the sys error box was.
   */
  rcInvalidDesktop = rcBox;

  while (BtnReturn == 0)
    {
      if (!PeekMessage((LPMSG)&msg, hwndDesktop, 0, 0, PM_REMOVE | PM_NOYIELD))
          continue;

#ifdef NEVER
*********   TranslateMessage() calls ToAscii() which refers to some tables
	    in a LoadOnCall segment; So, this is commented out here; We can not
	    look for WM_CHAR messages, but we still get WM_KEYDOWN messages!
			--Sankar, April 17, 1989--

      TranslateMessage((LPMSG)&msg);
*********
#endif

      if (msg.hwnd == hwndDesktop)
        {
          switch (msg.message)
            {
              case WM_LBUTTONDOWN:
                  fBtnDown = TRUE;
                  if ((btnhit = SEB_BtnHit(LOWORD(msg.lParam), 
                                           HIWORD(msg.lParam))) != -1)
                    {
                      /* Move the default button to the next button.
                       */
                      if ((defbtn != -1) && (btnhit != defbtn))
                        {
                          /* Draw the current def button as not default.
                           */
                          rgbtn[defbtn].style &= ~SEB_DEFBUTTON;
                          SEB_DrawButton(hdc, defbtn);
                          /* Draw the new button as default.
                           */
			  defbtn = btnhit;
                          rgbtn[btnhit].style |= SEB_DEFBUTTON;
			}
                      rgbtn[btnhit].finvert = TRUE;
                      SEB_DrawButton(hdc, btnhit);
                    }
                  break;

              case WM_LBUTTONUP:
                  fBtnDown = FALSE;
                  /* Was the mouse hitting on a button?  If so, terminate the
                   * loop and return the button index.
                   */
                  if (btnhit != -1)
                    BtnReturn = btnhit + 1;
                  break;

              case WM_MOUSEMOVE:
                  /* Only look at mouse moves if the button is down.
                   */
                  if (fBtnDown)
                    {
                      /* Hitting on a button?
                       */
                      if ((i = SEB_BtnHit(LOWORD(msg.lParam), HIWORD(msg.lParam))) != -1)
                        {
                          /* Mouse moved and we are on a button.  First test
                           * to see if we are on the same button as before.
                           */
                          if ((i != btnhit) && (btnhit != -1))
                            {
                              rgbtn[btnhit].finvert = FALSE;
                              SEB_DrawButton(hdc, btnhit);
                            }
                          /* Verify that the new button is
                           * inverted and that btnhit is current.
                           */
                          btnhit = i;
                          if (rgbtn[btnhit].finvert == FALSE)
                            {
                              rgbtn[btnhit].finvert = TRUE;
                              SEB_DrawButton(hdc, btnhit);
                            }
                        } else {
                          /* button down, but not hitting on a button. Check
                           * for drag off a button.
                           */
                          if (btnhit != -1)
                            {
                              rgbtn[btnhit].finvert = FALSE;
                              SEB_DrawButton(hdc, btnhit);
                              btnhit = -1;
                            }
                        }
                    }
                  break;
	      case WM_KEYUP:
	          if(fKeyBtnDown)
		    {
	              switch(msg.wParam)
		        {
			  case VERYBIGINTEGER:
		     	    /* Because this code gets moved into himem, we can't use jump 
		      	     * tables; This VERYBIGINTEGER prevents C6.0 from using a jump
		      	     * table in the translation of Switch Statements;
		      	     */
		     	    break;

		          case VK_SPACE:
		          case VK_RETURN:
                              /* Select the current default button and return.
                               */
                              if (defbtn != -1)
                                  BtnReturn = defbtn + 1;
                              break;
		        }
		    }
		  break;

              case WM_PAINT:
                   GetUpdateRect(msg.hwnd, &rcTemp, FALSE);
                   ValidateRect(msg.hwnd, NULL);
                   UnionRect(&rcInvalidDesktop, &rcInvalidDesktop, &rcTemp);
                   break;

              case WM_SYSKEYDOWN:
		   /* Look for accelerator keys
		    */
		   for (i = 0; i <= 2; i++)
		   {
		      /* Convert to lower case and test for a match */
		      if (((BYTE)msg.wParam | 0x20) == rgbtn[i].chaccel)
			{
			   BtnReturn = i + 1;
			   break;
			} 
		   }
                  break;

              case WM_KEYDOWN:
                  switch (msg.wParam)
                    {
		      case VK_SPACE:
                      case VK_RETURN:
		          /* Just keep the button pressed */
			  /* If already pressed, ignore the rest sothat we
			   * won't flicker horribly
			   */
			  if((defbtn != -1) && (!fKeyBtnDown))
			    {
			      fKeyBtnDown = TRUE;
			      rgbtn[defbtn].finvert = TRUE;
			      SEB_DrawButton(hdc, defbtn);
			    }
			  break;

                      case VK_TAB:
                          /* Move the default button to the next button.
                           */
                          if (defbtn != -1)
                            {
                              /* Draw the current def button as not default.
                               */
                              rgbtn[defbtn].style &= ~SEB_DEFBUTTON;
                              SEB_DrawButton(hdc, defbtn);
                              /* Calc the next def button.  Inc defbtn, but
                               * wrap from btn 3 to btn 1.  Also, don't stop
                               * on a button that isn't defined.
                               */
                              if (defbtn == 2)
                                  defbtn = 0;
                              else
                                  ++defbtn;
                              while (rgbtn[defbtn].style == NULL)
                                {
                                  if (++defbtn > 2)
                                    defbtn = 0;
                                 }

                              /* Draw the new default button as default.
                               */
                              rgbtn[defbtn].style |= SEB_DEFBUTTON;
                              SEB_DrawButton(hdc, defbtn);
                            }
                          break;

                      case VK_ESCAPE:
                        /* See if there is a button with SEB_CANCEL.  If there
                         * is, return it's id.
                         */
                          for (i = 0; i <= 2; i++)
                            {
                              if ((rgbtn[i].style & ~SEB_DEFBUTTON) 
							        == SEB_CANCEL)
                                {
                                  BtnReturn = ++i;
                                  break;
                                }
                            }
                          break;
                    }
                  break;

            }
        }
    }

  fMessageBox=fMessageBoxGlobalOld;

  /* Insure that hardware input is put back the way it was */
  EnableHardwareInput(fOldHWInput);

  /* Allow other tasks to run. */
  LockMyTask(FALSE);

  /* Set sys modal box back to the guy who was up */
  SetSysModalWindow(hwndSysModalBoxOld);

  Capture(NULL, NO_CAP_CLIENT);

#if 0
  The old cursor may have been paged out. We can't do this.
  SetCursor(hCursOld);
#endif
#if causetrouble  
  if (iLevelCursor < 0)
      OEMSetCursor((LPSTR)NULL);
#endif
  hwndFocus = hwndFocusSave;

  /* Set this flag indicating that another window was activate so that if we
   * were in menu mode when the sys error box came up, we know we should get
   * out because the actual mouse button/keyboard state may be different than
   * what the menu state thinks it is.
   */
  fActivatedWindow = TRUE;

  InternalReleaseDC(hdc);

  /* Invalidate the invalid portions of the desktop. 
   */
  InvalidateRect(hwndDesktop, &rcInvalidDesktop, FALSE);
  hrgn = CreateRectRgn(rcInvalidDesktop.left, rcInvalidDesktop.top, 
                       rcInvalidDesktop.right,rcInvalidDesktop.bottom);
  InternalInvalidate(hwndDesktop, (hrgn ? hrgn : (HRGN) 1),
	             RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
  if (hrgn)
      DeleteObject(hrgn);
//  RedrawScreen();
  return(BtnReturn);
}



int NEAR PASCAL HardSysModalMessageBox(LPSTR  lpszText,
                                       LPSTR  lpszCaption,
                                       WORD   wBtnCnt,
                                       WORD   wType)
{
    WORD        wBegBtn;
    int		iCurIndex;
    int		iCurButton;
    WORD	iButtonNo;
    int		iRetVal;
    WORD	wTemp;
    struct	
    {
	unsigned int InVal;
	char	     RetVal;
    }Param[3];

    /* If we're trying to bring up a hard sys modal message box
     * while another one is up, wait till the first one is through.
     * This protects our static save globals.  I'm not actually
     * sure this can ever happen (at least under DOS 3).
     */
    if (fMessageBox)
       Yield();

    fMessageBox = TRUE;

    wBegBtn = mpTypeIich[wType];   /* Index of Begining button */
    
    Param[0].InVal = Param[1].InVal = Param[2].InVal = 0;

    iCurIndex = 0;
    for(iButtonNo = 0; iButtonNo < wBtnCnt; iButtonNo++)
    {
	iCurButton = iCurIndex;
	switch(wBtnCnt)
	{
	    case 1:	/* One button; Put it in Param[1] */
		Param[1].InVal = SEBbuttons[wBegBtn];
		Param[1].RetVal = rgReturn[wBegBtn];
		iCurButton = 1;
		break;
	
	    case 2:	/* 2 Buttons; Put them in Param[0] and Param[2] */
		Param[iCurIndex].InVal = SEBbuttons[wTemp = wBegBtn + iButtonNo];
		Param[iCurIndex].RetVal = rgReturn[wTemp];
		iCurIndex += 2;
		break;

	    case 3:	/* 3 Buttons; Put them in Param[0], [1] and [2] */
		Param[iCurIndex].InVal = SEBbuttons[wTemp = wBegBtn + iButtonNo];
		Param[iCurIndex].RetVal = rgReturn[wTemp];
		iCurIndex++;
		break;
	}

	/* Check for the default button */
	if(wDefButton == iButtonNo)
	    Param[iCurButton].InVal |= SEB_DEFBUTTON;
    }

    iRetVal = SysErrorBox(lpszText, lpszCaption, Param[0].InVal, 
				Param[1].InVal, Param[2].InVal);

    fMessageBox = FALSE;

    return((int)Param[iRetVal - SEB_BTN1].RetVal);
}

/*--------------------------------------------------------------------------*/
/*									    */
/*  MessageBox() -					 		    */
/*									    */
/*--------------------------------------------------------------------------*/

int USERENTRY MessageBox(hwndOwner, lpszText, lpszCaption, wStyle)

HWND  hwndOwner;
LPSTR lpszText;
LPSTR lpszCaption;
WORD  wStyle;

{
    WORD    wBtnCnt;
    WORD    wType;
    WORD    wIcon;

#ifdef DEBUG
  if (!GetTaskQueue(GetCurrentTask()))
    {
      /* There is no task queue. Not put up message boxes. 
       */
      UserFatalExitSz(RIP_MESSAGEBOXWITHNOQUEUE,
                      "\n\rMessageBox failed - no message queue has been initialized yet. MessageBox not allowed.",
                      0);
    }
#endif

    /* If lpszCaption is NULL, then use "Error!" string as the caption 
       string */
    if(!lpszCaption)
	lpszCaption = (LPSTR)szERROR;

    wBtnCnt = mpTypeCcmd[(wType = wStyle & MB_TYPEMASK)];
    
    /* Set the default button value */
    wDefButton = (wStyle & MB_DEFMASK) / (MB_DEFMASK & (MB_DEFMASK >> 3));
    
    if(wDefButton >= wBtnCnt)   /* Check if valid */
	wDefButton = 0;		 /* Set the first button if error */

    /* Check if this is a hard sys modal message box */
    wIcon = wStyle & MB_ICONMASK;

    if(((wStyle & MB_MODEMASK) == MB_SYSTEMMODAL) &&
       ((wIcon == NULL) || (wIcon == MB_ICONHAND)))
    {
	/* It is a hard sys modal message box */
	return(HardSysModalMessageBox(lpszText, lpszCaption, wBtnCnt, wType));
    }
    else
	return(SoftModalMessageBox(hwndOwner, lpszText, lpszCaption, wStyle));
}


BOOL FAR PASCAL IsSystemFont(hdc)
register HDC hdc;
/* effects: Returns TRUE if font selected into DC is the system font else
   returns false. This is called by interrupt time code so it needs to be
   in the fixed code segment. */
{
  return(GetCurLogFont(hdc) == GetStockObject(SYSTEM_FONT));
}

BOOL FAR PASCAL IsSysFontAndDefaultMode(hdc)
register HDC hdc;
/* effects: Returns TRUE if font selected into DC is the system font AND
   the current mapping mode of the DC is MM_TEXT (Default mode); else
   returns false. This is called by interrupt time code so it needs to be
   in the fixed code segment. */
/* This function is the fix for Bug #8717 --02-01-90-- SANKAR  */
{
  return(IsSystemFont(hdc) && (GetMapMode(hdc) == MM_TEXT));
}


int USERENTRY WEP(int i)
{
  return(1);
}
#endif	// WOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winrect.asm ===
TITLE -  Converted Winrect.c to Assembler

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1     ; to suppress including most of the stuff in user.inc
    include user.inc
    .list

sBegin	CODE

assumes cs, CODE
assumes ds, DATA

;******************************************************************************
;                  ORIGINAL C SOURCE
;
;*void FAR SetRect(pRect,left,top,right,bottom)
;*LPRECT  pRect;
;*int     top,left,bottom,right;
;*{
;*        pRect->top    = top;
;*        pRect->left   = left;
;*        pRect->bottom = bottom;
;*        pRect->right  = right;
;*}
;******************************************************************************

cProcVDO   SetRect,<FAR, PUBLIC, NODATA>
;ParmD	lprc
;ParmW	left
;ParmW	top
;ParmW	right
;ParmW	bottom
cBegin	nogen

	mov	bx,sp
	mov	cx,di
beg_fault_trap  sr_trap
        cld
	les	di,ss:[bx]+4+2+2+2+2
	mov	ax,ss:[bx]+4+2+2+2
	stosw
	mov	ax,ss:[bx]+4+2+2
        stosw
	mov	ax,ss:[bx]+4+2
        stosw
	mov	ax,ss:[bx]+4
        stosw
end_fault_trap
sr_cont:
	mov	di,cx
	retf	4+2+2+2+2

cEnd	nogen

sr_trap:
        fault_fix_stack
        jmp     short sr_cont

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*int FAR SetRectEmpty(pRect)
;*LPRECT pRect;
;*{
;*        LFillStruct(pRect,sizeof(RECT),0);
;*}
;*
;******************************************************************************

LabelVDO SetRectEmpty
	pop	ax
	pop	dx

	pop	bx
        pop     cx

	push	dx
	push	ax

	xchg	di,bx

beg_fault_trap  sre_trap
        mov     es,cx

        xor     ax,ax
        cld
        stosw
        stosw
        stosw
        stosw
end_fault_trap

sre_cont:
	mov	di,bx
	retf

sre_trap:
        fault_fix_stack
        jmp     short sre_cont

;******************************************************************************
;*                        ORIGINAL C SOURCE
;*
;*int FAR CopyRect(pDstRect,pSrcRect)
;*LPRECT   pSrcRect;                 /*ptr to source rect                    */
;*LPRECT   pDstRect;                 /*Ptr to dest rect                      */
;*{
;*        LCopyStruct(pSrcRect,pDstRect,sizeof(RECT));
;*                                /*copy from source to dest              */
;*}
;*
;******************************************************************************

cProcVDO CopyRect, <FAR, PUBLIC, NODATA>, <ds, si, di>
        parmD   lpDstRect               ;long pointer to DstRect
        parmD   lpSrcRect               ;long pointer to SrcRect
cBegin
beg_fault_trap  cr_trap
        lds     si, lpSrcRect           ;mov into ds:si a far pointer to SrcRect
        les     di, lpDstRect           ;mov into es:di far pointer to DstRect
        cld                             ;clear direction flag for increment stuff
        movsw
        movsw
        movsw
        movsw
end_fault_trap
cr_cont:
cEnd

cr_trap:
        fault_fix_stack
        jmp     short   cr_cont

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*BOOL FAR IsRectEmpty(pRect)
;*LPRECT pRect;
;*{
;*        return(((pRect->right-pRect->left<=0)||(pRect->bottom-pRect->top<=0)) ? TRUE : FALSE);
;*}
;*
;******************************************************************************

LabelVDO IsRectEmpty
        pop     ax
        pop     dx

        pop     bx                  ; get lprc
        pop     cx

        push    dx
        push    ax

beg_fault_trap  ire_trap
        mov     es,cx
	mov	ax,TRUE
        mov     cx,es:[bx].rcRight
        cmp     cx,es:[bx].rcLeft
	jle	empty0
        mov     cx,es:[bx].rcBottom
        cmp     cx,es:[bx].rcTop
	jle	empty0
	xor	ax,ax
end_fault_trap
empty0:
        retf

ire_trap:
        fault_fix_stack
        jmp     short empty0

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*BOOL FAR PtInRect(lprc, pt)
;*LPRECT lprc;
;*POINT pt;
;*{
;*    return(pt.x >= lprc->left && pt.x < lprc->right &&
;*           pt.y >= lprc->top && pt.y < lprc->bottom);
;*}
;*
;******************************************************************************

cProcVDO PtInRect,<PUBLIC,FAR,NODATA>,<DS,SI>
;   parmD   lpRect
;   parmD   lpPoint
cBegin  nogen

        mov     bx,sp
        push    ds
        push    si

        mov     cx,ss:[bx+4]    ; cx = pt.x
        mov     dx,ss:[bx+6]    ; dx = pt.y

beg_fault_trap  pir_trap
        lds     si,ss:[bx+8]    ; lpRect
        cld
        xor     bx,bx           ; Result = FALSE

        lodsw                   ; AX = lpRect->left
        cmp     cx,ax           ; xcoord < left?
        jl      PtNotInRect     ; Yes, not in rectangle

        lodsw                   ; AX = lpRect->top
        cmp     dx,ax           ; ycoord < top?
        jl      PtNotInRect     ; Yes, not in rectangle

        lodsw                   ; AX = lpRect->right
        cmp     cx,ax           ; xcoord >= right?
        jge     PtNotInRect     ; Yes, not in rectangle

        lodsw                   ; AX = lpRect->bottom
        cmp     dx,ax           ; ycoord >= bottom?
        jge     PtNotInRect     ; Yes, not in rectangle

        inc     bx              ; Point in rectangle, result = TRUE
end_fault_trap
PtNotInRect:
        mov     ax,bx
        pop     si
        pop     ds
        retf    8

cEnd    nogen

pir_trap:
        fault_fix_stack
        jmp     short PtNotInRect

;******************************************************************************
;*                         ORIGINAL C SOURCE
;*
;*int FAR OffsetRect(pRect, x, y)
;*LPRECT  pRect;
;*int     x;
;*int     y;
;*{
;*        pRect->left   += x;
;*        pRect->right  += x;
;*        pRect->top    += y;
;*        pRect->bottom += y;
;*}
;*
;******************************************************************************

cProcVDO   OffsetRect,<FAR, PUBLIC, NODATA>,<DS>
;       parmD   lpRect                  ;far pointer to struct type rect
;       parmW   xDelta                  ;X delta
;       parmW   yDelta                  ;Y Delta
cBegin nogen
        mov     bx,sp
        push    ds
beg_fault_trap  or_trap
        mov     dx,ss:[bx+6]            ; dx = dx
        mov     cx,ss:[bx+4]            ; CX = dy
        lds     bx,ss:[bx+8]            ; ds:bx = lprc
        add     [bx].rcLeft,dx
        add     [bx].rcTop,cx
        add     [bx].rcRight,dx
        add     [bx].rcBottom,cx
end_fault_trap
or_cont:
        pop     ds
        retf    8
cEnd
or_trap:
        fault_fix_stack
        jmp     short or_cont

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*int FAR InflateRect(pRect, x, y)
;*LPRECT  pRect;
;*int     x;
;*int     y;
;*{
;*        pRect->left   -= x;
;*        pRect->right  += x;
;*        pRect->top    -= y;
;*        pRect->bottom += y;
;*}
;*
;******************************************************************************

cProcVDO InflateRect,<FAR, PUBLIC, NODATA>,<DS>
;       parmD   lpRect                  ;far pointer to struct type rect
;       parmW   xOffset
;       parmW   yOffset
cBegin nogen
        mov     bx,sp
        push    ds

beg_fault_trap  ir_trap
        mov     dx,ss:[bx+6]            ; dx = dx
        mov     cx,ss:[bx+4]            ; CX = dy
        lds     bx,ss:[bx+8]            ; ds:bx = lprc
        sub     [bx].rcLeft,dx
        sub     [bx].rcTop,cx
        add     [bx].rcRight,dx
        add     [bx].rcBottom,cx

end_fault_trap
ir_cont:
        pop     ds
        retf    8
cEnd

ir_trap:
        fault_fix_stack
        jmp     short ir_cont

;-----------------------------------------------------------------
;
; IntersectRect(lprcDst, lprcSrc1, lprcSrc2);
;
cProcVDO IntersectRect,<PUBLIC, FAR, NODATA>,<SI, DI, DS>
ParmD   lprcDst
ParmD   lprcSrc1
ParmD   lprcSrc2
cBegin
beg_fault_trap  irc_trap
        lds     si,lprcSrc1       ; point at source rects
        les     di,lprcSrc2

        mov     ax,[si].rcLeft    ; new left = cx = max(rc1.left, rc2.left)
        mov     cx,es:[di].rcLeft
        cmp     ax,cx
        jl      ir100
        xchg    ax,cx
ir100:
        mov     ax,[si].rcRight   ; new right = dx = min(rc1.right, rc2.right)
        mov     dx,es:[di].rcRight
        cmp     ax,dx
        jg      ir200
        xchg    ax,dx
ir200:
        cmp     cx,dx           ; is left >= right?
        jge     irempty         ; yes - return empty rect

        mov     ax,[si].rcTop     ; new top = cx = max(rc1.top, rc2.top)
        mov     bx,es:[di].rcTop
        cmp     ax,bx
        jl      ir300
        xchg    ax,bx
ir300:
        mov     ax,[si].rcBottom  ; new bottom = dx = min(rc1.bottom, rc2.bottom)
        mov     di,es:[di].rcBottom
        cmp     ax,di
        jg      ir400
        xchg    ax,di
ir400:
        cmp     bx,di           ; is top >= bottom?
        jge     irempty         ; no: store result

        lds     si,lprcDst      ; store away new right & left
        mov     [si].rcLeft,cx
        mov     [si].rcTop,bx
        mov     [si].rcRight,dx
        mov     [si].rcBottom,di

        mov     al,TRUE         ; return TRUE
end_fault_trap
irexit:

cEnd

irc_trap:
        fault_fix_stack
irempty:
        les     di,lprcDst      ; point at dst rect
        xor     ax,ax           ; set to (0, 0, 0, 0)
        cld
        stosw
        stosw
        stosw
        stosw                   ; return FALSE
        jmps    irexit

;=============================================================================
;
; BOOL UnionRect(lprcDest, lprcSrc1, lprcSrc2)
; LPRECT lprcDest;
; LPRECT lprcSrc1;
; LPRECT lprcSrc2;
;
; Calculates *lprcDest as the minimum rectangle that bounds both
; *lprcSrc1 and *lprcSrc2.  If either rectangle is empty, lprcDest
; is set to the other rectangle. Returns TRUE if the result is a non-empty
; rectangle, FALSE otherwise.
;
;
cProcVDO UnionRect,<FAR, PUBLIC, NODATA>,<SI, DI, DS>
ParmD   lprcDest
ParmD   lprcSrc1
ParmD   lprcSrc2
LocalW  wTemp
cBegin
beg_fault_trap  ur_trap
        lds     si,lprcSrc1
        les     di,lprcSrc2

        push    es
        push    di
        wcall   IIsRectEmpty
        push    ax                  ; save result

        ; IsRectEmpty trashes es....
        push    es

        push    ds
        push    si
        wcall   IIsRectEmpty

        pop     es                  ; restore it
        pop     cx

    ;ax = IsRectEmpty(1), cx = IsRectEmpty(2)

        or      ax,ax
        jnz     URrc1empty
        mov     ax,TRUE             ; return true, not both empty
        or      cx,cx
        jz      URnormalcase
        jmps    URrc2empty

URrc1empty:
        lds     si,lprcSrc2
        jcxz    URrc2empty          ; rc2 not empty, ax has true for return
        xor     ax,ax               ; return false, both empty

URrc2empty:
        les     di,lprcDest
        cld
        movsw
        movsw
        movsw
        movsw
        jmps    URexit

    ; src1 and src2 not empty

URnormalcase:
        mov     ax,[si].rcLeft      ; bx = min(Src1.left, Src2.left)
        mov     cx,es:[di].rcLeft
        cmp     ax,cx
        jl      URleft
        xchg    ax,cx
URleft:
        mov     bx,ax

        mov     ax,[si].rcTop       ; dx = min(Src1.top, Src2.top)
        mov     cx,es:[di].rcTop
        cmp     ax,cx
        jl      URtop
        xchg    ax,cx
URtop:
        mov     dx,ax

        mov     ax,[si].rcRight     ; wTemp = max(Src1.right, Src2.right)
        mov     cx,es:[di].rcRight
        cmp     ax,cx
        jg      URright
        xchg    ax,cx
URright:
        mov     wTemp,ax

        mov     ax,[si].rcBottom    ; ax = max(Src1.bottom, Src2.bottom)
        mov     cx,es:[di].rcBottom
        cmp     ax,cx
        jg      URbottom
        xchg    ax,cx
URbottom:

        les     di,lprcDest         ; fill into lprcDest
        mov     es:[di].rcLeft,bx
        mov     es:[di].rcTop,dx
        mov     es:[di].rcBottom,ax
        mov     ax,wTemp
        mov     es:[di].rcRight,ax
end_fault_trap

ur_true:
        mov     ax,TRUE             ; return true, not both empty
URexit:
cEnd

ur_trap:
        fault_fix_stack
        jmp     ur_true


;******************************************************************************
;*                        ORIGINAL C SOURCE
;*
;*BOOL FAR EqualRect(lpRect1, lpRect2)
;*LPRECT  lpRect1;
;*LPRECT  lpRect2;
;*{
;*        return lpRect1->left == lpRect2->left && lpRect1->top == lpRect2->top
;*          && lpRect1->right == lpRect1->right && lpRect1->bottom ==
;*          lpRect2->bottom;
;*}
;*
;******************************************************************************

cProcVDO EqualRect, <FAR, PUBLIC, NODATA>, <SI, DI, DS>
        parmD   lpRect1
        parmD   lpRect2
cBegin
        xor     ax,ax           ; assume FALSE
beg_fault_trap  er_trap
        lds     si,lpRect1
        les     di,lpRect2
        mov     cx,4
        cld
        repz    cmpsw
        jnz     er10
        inc     al
end_fault_trap
er10:
cEnd

er_trap:
        fault_fix_stack
        jmp     er10

;****************************************************************************
;  The following Routine to subtract one rectangle from another is lifted
; from PM and Modified by Sankar.
;
;****************************************************************************

;** Public Routine ****************************************************-;
; BOOL far SubtractRect(lprcDest, lprc1, lprc2)
; LPRECT lprcDest;
; LPRECT lprcSrc1;
; LPRECT lprcSrc2;
;
; This function subtracts *lprc2 from *lprc1, returning the result
; in *lprcDest.  Returns TRUE if *lprcDest is non-empty, FALSE otherwise.
;
; Warning:  Subtracting one rectangle from another may not
;           always result in a rectangular area; in this case
;           WinSubtractRect will return *lprc1 in *lprcDest.
;           For this reason, WinSubtractRect provides only an
;           approximation of subtraction.  However, the area
;           described by *lprcDest will always be greater
;           than or equal to the "true" result of the
;           subtraction.
;
; History :
;  	  Added by Sankar on July 27, 1988
;**********************************************************************-;

cProcVDO SubtractRect, <PUBLIC, FAR, NODATA>, <SI, DI, DS>
	ParmD lprcDest
	ParmD lprc1
	ParmD lprc2
	LocalV rc,%size RECT
cBegin
;
; First copy lprc1 into lprcDest.
;
beg_fault_trap  sbr_trap
	lds	si,lprc1
	les	di,lprcDest
        cld
        movsw
        movsw
        movsw
        movsw

        lds     si,lprcDest             ; ds:[si] = lprcDest.
	lea	di,rc			; ss:[di] = &rc
;
; We're subtracting lprc2 from lprc1. Make sure they at least
; intersect each other. If not, return TRUE.
;
	push	ss			; pushd &rc
        push    di
        push    ds                      ; pushd lprcDest
        push    si
        push    seg_lprc2               ; pushd lprc2
        push    off_lprc2
        wcall   IIntersectRect

        or      ax,ax                   ; Did we intersect?
        jz      sr700                   ; If no, skip to check empty rect
;
; Now make sure that we can subtract lprc2 from lprc1 and get a rect.
;
        errnz   <rcLeft   - 0>
        errnz   <rcTop    - 2>
        errnz   <rcRight  - 4>
        errnz   <rcBottom - 6>
;
; We make a loop that iterates twice - once for the x's and once for the
; y's. We want at least 3 sides of lprc2 to be outside of 3 sides of lprc1.
;
        xor     cx,cx
        xor     dx,dx
        dec     cx
;
; ds:si points to lprc1 (actually lprcDest)
; ss:di points to rc on stack
;
sr100:
        inc     cx

        mov     bx,cx
        shl     bx,1                    ; bx is a Word pointer

        mov     ax,ss:[di+bx].rcLeft ; if lprc2 left/top is > lprc1 l/t,
        cmp     ax,ds:[si+bx].rcLeft
        jg      sr200                   ; then inside the rect.
        inc     dx
sr200:
        mov     ax,ss:[di+bx].rcRight ; if lprc2 right/bottom is > lprc1 r/b,
        cmp     ax,ds:[si+bx].rcRight
        jl      sr300                   ; then inside the rect.
        inc     dx
sr300:
        jcxz    sr100                   ; loop one more time...

        cmp     dx,3                    ; Are 3 sides outside? If not,
        jb      sr700                   ; skip to check empty rect code

	cmp	dx,4			; Is rc1 completely inside rc2? If so,
        jne     sr350                   ; empty lprcDest and return TRUE
        
	pushd	lprcDest		; empty that puppy
        wcall   ISetRectEmpty

	xor	ax,ax			; Go return FALSE.
	jmps	srExit
        
sr350:
;
; Now we know that we can take lprc2 from lprc1 and leave a rect, so
; now we perform the 'subtract rect'. Interate twice, again once for the
; x's and once for the y's.
;
        xor     cx,cx
        dec     cx

sr400:
        inc     cx
        mov     bx,cx
        shl     bx,1    ; Make bx a Word pointer

        mov     dx,ss:[di+bx].rcLeft      ; New right/Bottom border?
        cmp     dx,ds:[si+bx].rcLeft
        jle     sr500

        mov     ds:[si+bx].rcRight,dx
        jmps    sr600

sr500:
        mov     dx,ss:[di+bx].rcRight     ; New left/top border?
        cmp     dx,ds:[si+bx].rcRight
        jge     sr600

        mov     ds:[si+bx].rcLeft,dx

sr600:
        jcxz    sr400

sr700:
	xor	ax,ax			; Assume it is empty: FALSE

        mov     cx,ds:[si].rcRight
        cmp     cx,ds:[si].rcLeft
        jle     SrExit

        mov     cx,ds:[si].rcBottom
        cmp     cx,ds:[si].rcTop
        jle     SrExit

	inc	al			; Non-empty: return TRUE.
end_fault_trap
srExit:
cEnd

sbr_trap:
        fault_fix_stack
        xor     ax,ax                   ; return FALSE
        jmp     srExit

;****************************************************************************
;
;  void  FAR  SplitRectangle(lprcRect, lprcRectArray, wcx, wcy)
;  LPRECT  lprcRect
;  RECT    lprcRectArray[4]
;
;  This splits the given rectangular frame into four segments and stores
;  them in the given array
;
;  Pseudo code:
;  -----------
;
;  cxWidth = lprcRect -> rcRight - lprcRect -> rcLeft - wcx;
;  cyWidth = lprcRect -> rcBottom - lprcRect -> rcTop - wcy;
;
;  A = -cyWidth;
;  B = -cxWidth;
;
;  for (i = 0; i < 4; i++)
;  {
;	lprcRectArray[i][i]       = lprcRect[i];
;	lprcRectArray[i][(i+1)&3] = lprcRect[(i+3)&3] + A;
;	lprcRectArray[i][(i+2)&3] = lprcRect[(i+2)&3] + B;
;	lprcRectArray[i][(i+3)&3] = lprcRect[(i+3)];
;	
;	TMP = A;
;	A   = -B;
;	B   = TMP;
;  }
; 
;  Note:
;		Value of i	Value of A	Value of B
;		----------	----------	----------
;		    0		  -cyWidth	-cxWidth
;		    1		  +cxWidth	-cyWidth
;		    2		  +cyWidth      +cxWidth
;		    3             -cxWidth      +cyWidth
;
;			  
;***************************************************************************



cProc SplitRectangle, <FAR, PUBLIC, NODATA>, <SI, DI, DS>
	
	ParmD	<lprcRect, lprcRectArray>	; Rect and Array
	Parmw	<wcx, wcy>			; Border widths

cBegin

	les	di, lprcRectArray		; es:di => lprcRectArray
	lds	si, lprcRect			; ds:si => given rectangle

; Calculate the value of -cxWidth

	mov	ax, [si].rcLeft
	sub	ax, [si].rcRight
	add	ax, wcx

	push	ax			; Save B on stack.

; Calculate the value of -cyWidth

	mov	ax, [si].rcTop
	sub	ax, [si].rcBottom
	add	ax, wcy

	push	ax			; Save A on stack

; Initialise the loop related variables

	xor	cx, cx			; Loop count
	xor	bx, bx			; Index into Rect Structure.

LoopSt:
;	lprcRectArray[i][i]       = lprcRect[i];

	mov	ax, [si+bx]
	mov	es:[di+bx], ax

;	lprcRectArray[i][(i+1)&3] = lprcRect[(i+3)&3] + A;

	inc	bx
	inc	bx	; Make it a word pointer
	and	bx, 6
	push	bx	; Save (i+1) tempoarily
	add	bx, 4   ; Calculate (i+3)
	and	bx, 6
	
	mov	ax, [si+bx]  ;  lprcRect[(i+3)] is taken
	pop	bx	     ;  (i+1) is returned to bx

	pop	dx	     ;  Value "A" is taken from stack
	add	ax, dx
	mov	es:[di+bx], ax  

	; Swap A and B on stack. A is in DX

	pop	ax		; Value B from Stack.
	push	dx		; B = A;
	Push	ax		; A = B;
	
	; Now B is on top of stack and A is below it.


	; lprcRectArray[i][(i+2)&3] = lprcRect[(i+2)&3] + B;
	
	inc	bx
	inc	bx		; (i+2) is calculated
	and	bx, 6
	
	mov	ax, [si+bx]
	pop	dx		; pop B
	add	ax, dx

	mov	es:[di+bx], ax
	neg	dx		; make -B
	push	dx		

	; lprcRectArray[i][(i+3)&3] = lprcRect[(i+3)];
	
	inc	bx
	inc	bx
	and	bx, 6		; make [(i+3)&3]
	
	mov	ax, [si+bx]
	mov	es:[di+bx], ax

	inc	cx
	cmp	cx, 4
	jge	exit

	mov	bx, cx
	shl	bx, 1		; Make it a word pointer
	add	di, size RECT	; Make it point to next rect in the array
	jmp	LoopSt
exit:
	; A and B exist on stack. So,Pop them
	add 	sp, 4

cEnd

	 
sEnd	TEXT
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winutil.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINUTIL.ASM
;   Win16 general utility routines
;
;   History:
;
;   Created 28-May-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16.
;   At this time, all we want is MultDiv() and LCopyStruct(), which the
;   edit controls use.
;--

;****************************************************************************
;*									    *
;*  WINUTIL.ASM -							    *
;*									    *
;*	General Utility Routines					    *
;*									    *
;****************************************************************************

	title WINUTIL.ASM - General Utility routines

ifdef WOW
NOEXTERNS equ 1
SEGNAME equ <TEXT>
endif
.xlist
include user.inc
.list


;*==========================================================================*
;*									    *
;*  FFFE Segment Definition -						    *
;*									    *
;*==========================================================================*

createSeg _%SEGNAME, %SEGNAME, WORD, PUBLIC, CODE

assumes cs,%SEGNAME
assumes ds,DATA

ExternFP <GetStockObject>
ExternFP <GetTextExtent>
ExternFP <TextOut>

ExternA <__WinFlags>

ifdef FE_SB			; **** April,26,1990 by KenjiK ****
ExternFP	IsDBCSLeadByte
endif

sBegin DATA
sEnd DATA

sBegin %SEGNAME


;*--------------------------------------------------------------------------*
;*									    *
;*  MultDiv() - 							    *
;*									    *
;*--------------------------------------------------------------------------*

; Calc a * b / c, with 32-bit intermediate result

cProc MultDiv, <PUBLIC, FAR>

;ParmW a
;ParmW b
;ParmW c

cBegin nogen
        mov     bx,sp
                                ; calc (a * b + c/2) / c
        mov     ax,ss:[bx+8]    ; ax = a
        mov     cx,ss:[bx+4]    ; cx = c
        or      cx,cx
	jz	mdexit		; just return A if we'll get divide by 0
        mov     dx,ss:[bx+6]    ; dx=b
        imul    dx

        mov     bx,cx           ; save a copy of c in bx for later
        shr     cx,1            ; add in cx/2 for rounding
        add     ax,cx
        adc     dx,0            ; add in carry if needed
                        	; get c from bx register since idev mem
        idiv    bx              ; doesn't work on tandy 2000's
mdexit:
        retf    6
cEnd nogen


ifdef DISABLE

;*--------------------------------------------------------------------------*
;*									    *
;*  min() -								    *
;*									    *
;*--------------------------------------------------------------------------*

cProc min, <FAR, PUBLIC>

;ParmW a
;ParmW b

cBegin nogen
        mov     bx,sp
	mov	ax,ss:[bx+6]    ;ax = a
        mov     cx,ss:[bx+4]    ;cx = b
	cmp	ax,cx
	jl	min10
	mov	ax,cx
min10:
        retf    4
cEnd nogen


;*--------------------------------------------------------------------------*
;*									    *
;*  max() -								    *
;*									    *
;*--------------------------------------------------------------------------*

cProc max, <FAR, PUBLIC>

;ParmW a
;ParmW b

cBegin nogen
        mov     bx,sp
	mov	ax,ss:[bx+6]   ;ax = a
        mov     cx,ss:[bx+4]   ;cx = b
	cmp	ax,cx
	jg	max10
	mov	ax,cx
max10:
        retf    4
cEnd nogen


;*--------------------------------------------------------------------------*
;*									    *
;*  umin() -								    *
;*									    *
;*--------------------------------------------------------------------------*

cProc umin, <FAR, PUBLIC>

;ParmW a
;ParmW b

cBegin nogen
        mov     bx,sp
	mov	ax,ss:[bx+6]    ;ax = a
        mov     cx,ss:[bx+4]    ;cx = b
	cmp	ax,cx
	jb	umin10
	mov	ax,cx
umin10:
        retf    4
cEnd nogen


;*--------------------------------------------------------------------------*
;*									    *
;*  umax() -								    *
;*									    *
;*--------------------------------------------------------------------------*

cProc umax, <FAR, PUBLIC>

;ParmW a
;ParmW b

cBegin nogen
        mov     bx,sp
	mov	ax,ss:[bx+6]   ;ax = a
        mov     cx,ss:[bx+4]   ;cx = b
	cmp	ax,cx
	ja	umax10
	mov	ax,cx
umax10:
        retf    4
cEnd nogen

endif	; DISABLE

;*--------------------------------------------------------------------------*
;*									    *
;*  LFillStruct() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc LFillStruct, <PUBLIC, FAR, NODATA, ATOMIC>, <di>

parmD lpStruct
parmW cb
parmW fillChar

cBegin
        les     di,lpStruct
        mov     cx,cb
        mov     ax,fillChar
        cld
	rep	stosb

cEnd LFillStruct


;*--------------------------------------------------------------------------*
;*									    *
;*  LCopyStruct() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; LCopyStruct(pbSrc, pbDst, cb)

cProc LCopyStruct, <FAR, PUBLIC>
;ParmD pSrc
;ParmD pDest
;ParmW cb
cBegin nogen
        mov     bx,sp

	mov	cx,ss:[bx+4]        ; cx = cb
	jcxz	lcopynone	    ; Nothing to do if count == 0

        push    si
        push    di
        mov     dx,ds               ; save ds

	lds	si,ss:[bx+4+2+4]    ; ds:si = pSrc
	les	di,ss:[bx+4+2]	    ; es:di = pDst

	cmp	si,di		    ; Could they overlap?
        jae     lcopyok

	mov	ax,cx		    ; Yes: copy from the top down
        dec     ax
	dec	ax
        add     si,ax
        add     di,ax

        std
	shr	cx,1
	rep	movsw
	jnc	@F		    ; an odd byte to blt?
	inc	si		    ; went one too far: back up.
	inc	di
	movsb
@@:
	cld
	jmps	lcopydone

lcopyok:
	cld
	shr	cx,1
	rep	movsw
	jnc	@F		    ; an odd byte to blt?
	movsb
@@:

lcopydone:
        mov     ds,dx
        pop     di
        pop     si
lcopynone:
	retf	4+4+2
cEnd nogen


ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  The following routines are "Movable DS" equivalents of their normal     *
;*  counterparts.  The PS stands for "Pointer Safe."  They prevent problems *
;*  which occur when an app passes in a pointer to an object in its DS	    *
;*  which we somehow cause to move.  To prevent this problem, we copy what  *
;*  the pointer points to into USER's DS and use a pointer to our copy	    *
;*  instead.								    *
;*									    *
;*--------------------------------------------------------------------------*


;*--------------------------------------------------------------------------*
;*									    *
;*  PSGetTextExtent() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

ifndef PMODE


cProc PSGetTextExtent, <PUBLIC, FAR, NODATA>, <si,di>

ParmW hdc
ParmD lpch
ParmW cch

LocalV rgch, 128		; max 128 chars

cBegin
        mov     ax,__WinFlags
        test    al,WF_PMODE
        errnz   high(WF_PMODE)
        jz      PSGTE_RealMode

        push    hdc
        pushd   lpch
        push    cch
        jmp     short PSGTE_GetExtent

PSGTE_RealMode:
        lea     di,rgch         ; es:di = dest
        push    ss
        pop     es
        lds     si,lpch         ; ds:si = src
        mov     cx,cch          ; count = min(cch, 128)
        mov     ax,128
        cmp     cx,ax
        jbe     gte100
	xchg	ax,cx

gte100: push	hdc		; Push args before rep movsb destroys
	push	ss		; cx and di
	push	di
	push	cx

	cld
	rep movsb		; Copy string to local storage

PSGTE_GetExtent:
	call	GetTextExtent

cEnd PSGetTextExtent


;*--------------------------------------------------------------------------*
;*									    *
;*  PSTextOut() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; void PSTextOut(hdc, lpch, cch)

cProc PSTextOut,<PUBLIC, FAR, NODATA>, <si, di>

ParmW hdc
ParmW x
ParmW y
ParmD lpch
ParmW cch

LocalV rgch, 255		; max 255 chars

cBegin
        mov     ax,__WinFlags
        test    al,WF_PMODE
        errnz   high(WF_PMODE)
        jz      PSTO_RealMode

        push    hdc
        push    x
        push    y
        pushd   lpch
        push    cch
        jmp     short PSTO_TextOut

PSTO_RealMode:
        lea     di,rgch         ; es:di = dest
        push    ss
        pop     es
        lds     si,lpch         ; ds:si = src
        mov     cx,cch          ; count = min(cch, 255)
        mov     ax,255
        cmp     cx,ax
        jbe     to100
        xchg    ax,cx

to100:	push	hdc		; Push args before rep movsb destroys
	push	x		; cx and di
        push    y
	push	ss		; Push &rgch[0]
        push    di
	push	cx

	cld
	rep movsb		; copy string before we go

PSTO_TextOut:
	call	TextOut

cEnd PSTextOut

endif ; ifndef PMODE


;*--------------------------------------------------------------------------*
;*									    *
;*  FindCharPosition() -						    *
;*									    *
;*--------------------------------------------------------------------------*

; Finds position of char ch in string psz. If none, returns the length of
; the string.

cProc FindCharPosition, <FAR, PUBLIC, NODATA>, <si, ds>

ParmD psz
ParmB char

cBegin
        lds     si,psz
fcp100: lodsb                           ; get a byte
        or      al,al
        jz      fcp200
ifdef   FE_SB				; **** April,26,1990 by KenjiK ****
	sub	ah,ah
        push	ax
        cCall   IsDBCSLeadByte,<ax>     ; first byte of double byte?
        test    ax,ax
        pop     ax
        jz      fcp150                  ; no just do normal stuff
        lodsb                           ; skip second byte of double byte
        jmps    fcp100                  ; and do again
fcp150:
endif
        cmp     al,char
        jnz     fcp100
fcp200: xchg	ax,si	    ; calc char index: pch - 1 - psz
        dec     ax
	sub	ax,off_psz

cEnd FindCharPosition

endif ;WOW

sEnd %SEGNAME

ifndef WOW
;*==========================================================================*
;*									    *
;*  RUNAPP Segment Definition - 					    *
;*									    *
;*==========================================================================*

createSeg _RUNAPP, RUNAPP, BYTE, PUBLIC, CODE

sBegin RUNAPP

assumes cs,RUNAPP
assumes ds,DATA


;*--------------------------------------------------------------------------*
;*									    *
;*  CrunchX2() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; This routine copies the pile of bits from the source pointer
; to the dest pointer doing the integer crunch as it goes
; it will favor black (0) to white (1) and will keep the destinations
; widthbytes even.
;
; Assumptions: Neither source nor destination are greater than 64K
;	       Either the two bitmaps, lpSrc and lpDst are disjoint
;		   or lpDst <= lpSrc (i.e. we fill from the front)
;	       WidthBytes is even

cProc CrunchX2, <FAR, PUBLIC, NODATA>, <ds, si, di>

parmD	lpSrc
parmD	lpDst
parmW	WidthBytes
parmW	Height

LocalW	dwb		; destination width if not corrected
LocalW	destinc 	; used to force dest width even each scan

cBegin
        cld
        lds     si,lpSrc
        les     di,lpDst
        mov     bx,Height

	; Compute destination widthbytes
        mov     ax,WidthBytes           ; must be even
        shr     ax,1                    ; widthbytes for the destination
        mov     dwb,ax
        and     ax,1                    ; iff odd must inc dest pointer
        mov     destinc,ax              ; at the end of each scan
        sub     di,ax

NextSX: dec	bx
        jl      exitX
        mov     cx,dwb
        add     di,destinc

CrunchBX:
        lodsw
        mov     dx,ax
        rol     ax,1
        and     dx,ax               ; this and selects 0 in favor of 1
        mov     al,dl
        shl     ax,1
        shl     al,1
        shl     ax,1
        shl     al,1
        shl     ax,1
        shl     al,1
        shl     ax,1
        mov     al,dh
        shl     ax,1
        shl     al,1
        shl     ax,1
        shl     al,1
        shl     ax,1
        shl     al,1
        shl     ax,1
        mov     al,ah
        stosb
        loop    CrunchBX
        jmp     NextSX
exitX:

cEnd CrunchX2


;*--------------------------------------------------------------------------*
;*									    *
;*  CrunchY() - 							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc CrunchY, <FAR, PUBLIC, NODATA>, <ds, si, di>

parmD	lpSrc
parmD	lpDst
parmW	WidthBytes
parmW	Height
parmW	scale

LocalW	groupcount	;Height/scale
LocalW	groupinc	;WidthBytes * Height/Scale
LocalW	scancount	;counter of bytes in scan reset each group
LocalW	bytecount	;number of bytes joined = scale - 1

cBegin
        cld
        lds     si,lpSrc
        les     di,lpDst

	; Compute group count
        mov     bx,scale                ; only scale positive
        cmp     bx,1
        jle     CopyBitmap
        mov     ax,Height
        xor     dx,dx
        div     bx
	mov	groupcount,ax		; Height/scale
        mov     cx,WidthBytes           ; must be even
        dec     bx
        mov     bytecount,bx
        mov     ax,bx
        mul     cx
	mov	groupinc,ax		; WidthBytes * (scale - 1)
        mov     dx,cx
        mov     bx,si
        sub     bx,groupinc
        dec     bx
        dec     bx

NextGroup:
        dec     groupcount
        jl      exitY
        add     bx,groupinc
        mov     ax,dx
        shr     ax,1
        mov     scancount,ax

NextByte:
        dec     scancount
        jl      NextGroup
        inc     bx
        inc     bx
        mov     si,bx
        mov     ax,[si]
        mov     cx,bytecount

CrunchBY:
        add     si,dx
        and     ax,[si]
        loop    CrunchBY
        stosw
        jmp     NextByte

CopyBitmap:
        mov     ax,Height
        mul     WidthBytes
        shr     ax,1
        mov     cx,ax
        rep movsw

exitY:
cEnd CrunchY

sEnd RUNAPP

endif ;WOW

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winq.asm ===
;;;;;;;;;;;;;;;;;;;;;; START OF SOURCE FILE SPECIFICATION ;;;;;;;;;;;;;;;;;;;;
COMMENT $  HEADER

SOURCE FILE NAME:   winq

DESCRIPTIVE NAME:   queue management module

FUNCTION:       This module contains routines for creating and
                deleting queues and reading and writing messages
                to queues.  The circular queue data structure (struct Q
                defined in user.h) consists of a header followed by a
                sequence of messages

ENTRY POINTS:   InitSysQ, CreateQueue, DeleteQueue, WriteMessage, ReadMessage,
		FQueueNotFull, DelQEntry, UnlinkQ
$
;;;;;;;;;;;;;;;;;;;;;; END OF SOURCE FILE SPECIFICATION ;;;;;;;;;;;;;;;;;;;;


;% MOVEDS - NK (no change)

norasterops     =       1
notext          =       1
        .xlist
        include user.inc
        .list

ExternFP	<LocalAlloc, LocalFree>

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

assumes cs,CODE
assumes ds,DATA

;============================================================================

sBegin  DATA

ifndef WOW
ExternW         idSysPeek       ; id in sys queue of message being looked at.
endif

sEnd    DATA

;============================================================================

ExternFP	<GetSystemMsecCount>
ExternFP        <GetCurrentTask>
ExternFP        <SetTaskQueue>
ExternFP        <GlobalAlloc, GlobalFree>
ExternFP        <PostEvent>
ExternFP        <PostMessage>
ExternFP        <GetExeVersion>

sBegin  CODE

; CS variables:
ifndef WOW      ; WOW doesn't use these
ExternNP        <CheckMsgFilter2>
ExternNP        <CheckHwndFilter2>
ExternNP        <SetWakeBit>
ExternNP        <WakeSomeone>
ExternNP        <SetWakeBit2>
ExternNP        <SkipSysMsg>
ExternNP        <PostMove>
ExternNP        <HqCur2ES, HqCur2DS>
ExternFP        <HqCurrent>
else
ExternFP        <GetTaskQueueES>
endif           ; WOW doesn't use these

ifdef WOW       ; These functions stolen from winloop3.asm

;*--------------------------------------------------------------------------*
;*									    *
;*  HqCur2ES() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Get hqCurrent in ES.

LabelNP <PUBLIC, HqCur2ES>
	    call    GetTaskQueueES	; Another wonderful KERNEL routine
	    ret

;*--------------------------------------------------------------------------*
;*									    *
;*  HqCurrent() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Get handle of current queue and return in AX.

LabelFP <PUBLIC, HqCurrent>
	    call    HqCur2ES		; Code depends on both ES and AX
	    mov     ax,es
	    or	    ax,ax		; Set flags
            retf

endif           ; WOW These functions stolen from winloop3.asm


ifndef WOW      ; No InitSysQueue for WOW
;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
InitSysQueue () - Create and initialize the system queue.

LINKAGE:    FAR PLM

ENTRY:      WORD cQEntries - number of entries in system queue

EXIT:       hSysQueue contains handle for system queue (Shared global object.)

EFFECTS:    all registers modified.

INTERNAL:   CreateQueue2

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Set up register linkage for CreateQueue2 and let it do the work.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	InitSysQueue,<PUBLIC,FAR>,<DS>
cBegin
        mov     ax,_INTDS
        mov     ds,ax
assumes ds,INTDS
        mov     ax,ds:[cQEntries]       ; number of entries
        push    ax
        mov     ax,size INTERNALSYSMSG          ; size of entry
        push    ax
        call    CreateQueue2            ; create system queue
        mov     ds:[hqSysQueue],ax
assumes ds,NOTHING
cEnd
endif           ; No InitSysQueue for WOW

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
CreateQueue (cMsgs) - Create a queue.

Create a queue for the currently executing task and stick its handle
in the task header and the queue list.

LINKAGE:    FAR PLM

ENTRY:      WORD cMsgs(parm1) - count of messages that can be stored in
                                queue

EXIT:       ax - handle to queue (shared global object.)

            Newly created queue is linked to list of queues pointed
            to by hqList.

EXIT - ERROR: ax hqCurrent, hqCurrentShadow contain 0.

EFFECTS:    all registers modified.

INTERNAL:   CreateQueue2

EXTERNAL:   SetTaskQueue

WARNINGS:   Running out of memory when trying to CreateQueue will
            init current queue to 0.

REVISION HISTORY:

IMPLEMENTATION:
    Set up register linkage for CreateQueue2 and let it create the queue.
    Then add to linked list and then SetTaskQueue(NULL, hqCreated).
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	CreateQueue,<PUBLIC, FAR>,<DS>
        ParmW   cMsgs
cBegin
        push    cMsgs
        mov     ax,size INTERNALMSG
        push    ax
        call    CreateQueue2
	or	ax,ax
	jz	errexit 		; CreateQueue2 failed

        EnterCrit

        mov     es,ax
        push    ax
        mov     ax,_INTDS
        mov     ds,ax
        pop     ax
assumes ds,INTDS
        xchg    ds:[hqList],ax          ; Link us in and get old head of list
        mov     es:[qHqNext],ax         ; store ptr to next queue
        push    es                      ; save hq for return

        xor     ax,ax                   ; SetTaskQueue(NULL, es)
        push    ax
        push    es                      ; push queue handle
        call    SetTaskQueue            ; and ram it in there
        pop     ax                      ; return queue handle

        LeaveCrit
assumes ds,DATA
errexit:
cEnd


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ PRIVATE
CreateQueue2 (cMsgs, cbEntry) - Create a queue.

Allocate a shared global object and initialize the header for the Q
Data structure.

LINKAGE:    NEAR PLM

ENTRY:      WORD cMsgs(parm1) - count of messages that can be stored in
                                queue

            WORD cbEntry(parm2) - count of bytes in single message entry.

EXIT:       ax - handle to queue (shared global object.)


EXIT - ERROR: ax contains 0

EFFECTS:    all registers except DI modified.
            wAppVersion gets current exe version.

INTERNAL:

EXTERNAL:   GlobalAlloc

WARNINGS:   cbEntry better not be less than 5.

REVISION HISTORY:

IMPLEMENTATION:
    Allocate a shared global object, initialize header with following
    fields: Current Task, cbEntry, cMsgs,pmsgRead, pmsgWrite,
            pmsgRead = pmsgWrite = rgMsg,
            pmsgMax = queue size
            wVersion = GetExeVersion
	    WakeBits = QS_SMPARAMSFREE | (SYSQ empty ? QS_INPUT : 0).
            lpfnMsgFilter = cs:OldMsgFilter
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	CreateQueue2,<PUBLIC, NEAR>,<DI>
        ParmW   cMsgs
        ParmW   cbEntry

cBegin
        call    GetCurrentTask          ; get current task
        push    ax                      ; and save it

        mov     ax,cMsgs
        mov     cx,cbEntry
        mul     cx
        add     ax,size Q - size INTERNALMSG
        push    ax                      ; save size of queue

        ; Alloc(GPTR, cMsgs * size INTERNALMSG + size Q)
	push    GPTR+GMEM_SHAREALL 
        push    0                       ; hi word == 0
        push    ax
        call    GlobalAlloc
        mov     es,ax                   ; stick hq in es

        pop     cx                      ; pop queue size
        pop     bx                      ; and task handle

        or      ax,ax                   ; error on alloc?
        jz      cqexit                  ; yes, quit
        xchg    bx,ax                   ; get task handle into ax

        cld
        mov     di,qHTask               ; point at hTask
        stosw                           ; store task handle
        errnz   qHTask-2
        mov     ax,cbEntry              ; store size of entry
        stosw
        errnz   qCbEntry-4
        inc     di                      ; cMsgs = 0 (cleared by alloc)
        inc     di
        errnz   qCMsgs-6
        mov     ax,qRgmsg
        stosw                           ; init read/write pointers
        errnz   qPmsgRead-8
        stosw
        errnz   qPmsgWrite-10
        mov     ax,cx                   ; get size of queue (ptr to end)
        stosw                           ; and store it
        errnz   qPmsgMax-12

        push    es                      ; save hq
        call    GetExeVersion           ; returns sys version in dx, app in ax
        pop     es

        mov     es:[qWVersion],ax       ; set up app version number
        mov     es:[qWakeBits],QS_SMPARAMSFREE ; default ON flags.
        mov     es:[qFlags],QF_INIT     ; indicate initialization is in progress

        mov     ax,es                   ; Save hq in ax.
        push    ax
        mov     ax,_INTDS
        mov     es,ax
        pop     ax
assumes es,INTDS
        cmp     es:[hqList],0           ; If we are the first queue and
        jnz     cq100                   ; there is input waiting for us,

        mov     es:[hqCursor],ax        ; Initialize this guy for WakeSomeone.
        cmp     es:[hqSysQueue],0       ; System queue set yet???
        jz      cq100                   ; Nope, don't touch it
	mov	bx,es:[hqSysQueue]      ; set the input flag.
	or	bx,bx
	jz	cq100
        mov     es,bx
        cmp     es:[qCMsgs],0           ; Any messages in the system queue?
        mov     es,ax
        jz      cq100                   ; No messages.
	or	es:[qWakeBits],QS_INPUT ; Yes - tell the guy he has input.

cq100:
;
; Return queue handle in ax.
;
cqexit:
cEnd

;============================================================================


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
DeleteQueue() - Remove current queue from queue list

Unlink Queue from all lists, Delete the Q global object, then wake
someone else.

LINKAGE:    NEAR PLM

ENTRY:

EFFECTS:    current queue is removed from queue list and object is deleted.
            New task wakes up.

            hqSysLock = 0

            all registers modified.

INTERNAL:   UnlinkQ, SetWakeBit, WakeSomeone

EXTERNAL:   GlobalFree,

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Unlink the queue from list of queues then unlink from all send lists.
    Then set the result bit for every queue with sendmessage waiting on
    this guy.  Then free queue global object, and wakesomeone.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc   DeleteQueue,<PUBLIC, NEAR>, <SI>
cBegin
        call    HqCurrent
        mov     si,ax                   ; si = hqCurrent.

        mov     dx,_INTDS
        push    dx                      ; Save for later
        mov     ax,OFFSET hqList
        push    dx
        push    ax
        push    si
        mov     ax,qHqNext
        push    ax
        call    UnlinkQ                 ; UnlinkQ(lphqStart, hqCurrent, cbHqNext)
        pop     es                      ; get INTDS
        jz      dqexit                  ; if bad unlink, exit.
ifndef WOW      ; WOW doesn't have most USER16 structures to worry about.
assumes es,INTDS
        EnterCrit
        xor     bx,bx                   ; zero hqSysLock.
        mov     es:[hqSysLock],bx
        mov     es:[hqMouse],bx         ; zero hqMouse.
        mov     es:[hqKeyboard],bx      ; zero hqKeyboard.
        mov     bx,es:[hqList]          ; Get the first guy in the list for
        mov     es:[hqCursor],bx        ; hqCursor.
        LeaveCrit
;
; Unlink this guy from everyone's hqSendList.
;
        mov     cx,es:[hqList]
assumes es,NOTHING
dq100:
        mov     es,cx
        jcxz    dq200

        push    es:[qHqNext]
        push    cx                      ; Unlink this queue from all send
        mov     ax,qHqSendList          ; lists.
        push    ax
        push    si
        mov     ax,qHqSendNext
        push    ax                      ; UnlinkQ(lphqStart, hqUnlink, cbLink)
        call    UnlinkQ

        pop     cx                      ; Get the next hq.
        jmps    dq100

dq200:
;
; Now set the result bit of everyone waiting on a SendMsg response from
; this guy.
;
        mov     es,si                   ; es = hqCurrent.
        mov     cx,es:[qHqSendList]
dq300:
        mov     es,cx
        jcxz    dq400                   ; Are we at the end of the list?

        push    es:[qHqSendNext]

        xor     bx,bx
        mov     word ptr es:[qResult],bx ; Zero out the result.
        mov     word ptr es:[qResult+2],bx

	mov	ax,QS_SMRESULT		; Tell this guy to wake up and
        call    SetWakeBit2             ; get the result.

        pop     cx
        jmps    dq300

endif           ; WOW doesn't have most USER16 structures to worry about.

dq400:
        xor     ax,ax
        push    ax
        push    ax			; Set NULL queue
        call    SetTaskQueue		; SetTaskQueue(NULL, NULL)

        push    si
        call    GlobalFree              ; throw away the queue

        xor     cx,cx
ifndef WOW      ; No need - user32 takes care of this for WOW
        call    WakeSomeone             ; wake someone up to process events
endif ;WOW
; if anyone jumps here, he better do it with ints enabled!
dqexit:
cEnd


ifndef WOW      ; WOW doesn't ever put anything in the 16-bit Queue

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
WriteMessage (hq, lParam, wParam, message, hwnd, dwExtra) - Write a message
                                                   to hq.

If queue not full, Write message record at pmsgWrite, then advance pmsgWrite.
SetWakeBit(hq) to tell him he has input.

LINKAGE:    NEAR PLM

ENTRY:      WORD    hq          handle to queue that gets message
            DWORD   lParam      lParam of message
            WORD    wParam      wParam of message
            WORD    message     message
            WORD    hwnd        associated window
	    DWORD   dwExtra     dwExtraMsgInfo of the message


EXIT:       zero flag not set
            AX = pmsgWrite

EXIT ERROR: zero flag set

EFFECTS:    Write pointer (pmsgWrite) to hq advanced to next message.
	    QS_POSTMESSAGE set for hq.

            All registers changed

INTERNAL:   FQueueNotFull, SetWakeBit2

EXTERNAL:   none

WARNINGS:   the order of params on stack is assumed so we can do
            a rep movsb

REVISION HISTORY:

IMPLEMENTATION:
    Call FQueueNotFull which sets di = pmsgwrite if queue not full.
    Blt message bytes to queue at di, advance the write pointer,
    then SetWakeBit(hq, QS_POSTMESSAGE).
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	WriteMessage,<PUBLIC, NEAR>, <SI,DI,DS>
ParmW   hq
ParmD   lParam
ParmW   wParam
ParmW   message
ParmW   hwnd
ParmD   dwExtraInfo
cBegin  WriteMessage

        NewEnterCrit    ax		; This trashes ax register

        push    ds                      ; See if queue is full.
        mov     ax,hq
        mov     ds,ax
        mov     es,ax
assumes ds,NOTHING
assumes es,NOTHING
        call    FQueueNotFull           ; Z flag set if FULL.
        jz      pmexit
        push    di                      ; Save Message pointer.

pm30:
        mov     cx,ds:[qCbEntry]        ; Copy message into queue.
        shr     cx,1

        push    ds

        lea     si,dwExtraInfo
        push    ss
        pop     ds
        cld
	errnz	<size INTERNALSYSMSG - 7*2>
	errnz   msgTime-10
	errnz   imMsg-4
        movsw
        movsw
        movsw
        movsw
        movsw                           ; Store away the message.
	movsw
	movsw

	errnz	<size INTERNALSYSMSG - 7*2>
	errnz   msgTime-10
	errnz   imMsg-4
        sub     cx,7
        jcxz    pm40                    ; If have room, store time.

        push    es
	call	GetSystemMsecCount	; Tick count in dx:ax.
        pop     es

        push    ax
        mov     ax,_INTDS
        mov     ds,ax
        pop     ax
assumes ds,INTDS
        stosw
        mov     ax,dx
        stosw

        sub     cx,2
        jcxz    pm40

        mov     ax,word ptr ds:[ptCursor] ; If have room, store pt.
        stosw
        mov     ax,word ptr ds:[ptCursor+2]
        stosw

pm40:
        pop     ds
assumes ds,DATA

        pop     bx                      ; reget ptr to msg
        push    bx
        call    rtestwrap               ; advance pointer

        mov     ds:[qPmsgWrite],bx
        inc     ds:[qCMsgs]             ; advance count

	mov	ax,QS_POSTMESSAGE
        call    SetWakeBit2             ; Tell this guy he has input.
pm75:
        pop     ax                      ; get back message ID
pmexit:
        pop     ds

	NewLeaveCrit   dx, cx  ; This trashes dx and cx registers

cEnd    WriteMessage


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
FQueueNotFull - IsQueueFull?

If queue not full, get pmsgWrite and return TRUE.
otherwise return FALSE.

LINKAGE:    register

ENTRY:      WORD ax - hq

EXIT:       ax - non zero.  zero flag clear
            di - pmsgWrite (pointer to next write record.)

EXIT ERROR: ax - 0; zero flag set

EFFECTS:    no other registers

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Advance write pointer.  Error condition occurs only if
    pmsgWrite == pmsgRead && cMsg != 0.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; FQueueNotFull - zero in ax and Z flag if FULL, else cMsgLeft in ax, NZ
;                 flag set. Returns write pointer in di.
;                 AX has DS on entry.
;
LabelNP <PUBLIC, FQueueNotFull>
        push    ds
assumes ds,NOTHING
        mov     ds,ax
        mov     di,ds:[qPmsgWrite]      ; get write pointer and advance
        cmp     di,ds:[qPmsgRead]       ; if read == write, then we're either
        jnz     qfNotFull
        xor     ax,ax
        cmp     ax,ds:[qCMsgs]          ; cMsgs != 0 if empty
        jnz     qfexit                  ; Jump if Full.
qfNotFull:
        push    es
        mov     ax,_INTDS
        mov     es,ax
assumes es,INTDS
        mov     ax,es:[cQEntries]       ; See how many messages are left.
assumes es,NOTHING
        pop     es
        sub     ax,ds:[qCMsgs]          ; number of messages left
qfexit:
        or      ax,ax
        pop     ds
assumes ds,DATA
        ret


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
ReadMessage (hq, lpMsg, hwndFilter, msgMinFilter, msgMaxFilter, fRemoveMsg)
            Read a message from hq.

If queue not empty, read message satisfying filter conditions from hq to *lpMsg.

LINKAGE:    FAR PLM

ENTRY:      WORD    hq          handle to queue to read from
            MSG     *lpMsg      far pointer to message buffer
	    	           NOTE: This points to  MSG struct and not INTERNALMSG.
            WORD    hwndFilter  Window filter
            WORD    msgMinFilter    min filter spec for message number
            WORD    msgMaxFilter    max filter spec for message number
            WORD    fRemoveMsg  Remove message if non-zero

EXIT:       zero flag not set
            ax = Non-Zero - we have a message.
            ax = 0 - we don't have a message.

EXIT ERROR: zero flag set

EFFECTS:    All registers trashed
	    QS_POSTMESSAGE wakebit cleared if no msgs left in app queue.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:

REVISION HISTORY:
    SRL - 4/12 Fixed bug where if system queue was locked by someone else,
               it was being unlocked.
    SRL - 4/18 Fixed journalling.
    SRL - 5/4  Changed system queue journalling to call ScanSysQueue.
               (which used to be called FindMsgHq. It now does all the
               message enumeration).

IMPLEMENTATION:
    If not quitting, look through the specified queue starting at pmsgRead
    for message that matches filters.  Blt message to lpmsg, advance the read
    pointer.  If out of queue messages, clear the input bit.
    Message matches hwndFilter if hwndFilter == 0 or hwndFilter == msgHwnd.
    Message matches msgMinFilter, msgMaxFilter if both are zero or
    msgMinFilter <= msg <= msgMaxFilter.

$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ReadMessage(hq, lpMsg, hwndFilter, msgMinFilter, msgMaxFilter, fRemoveMsg)
;
;  NOTE: lpMsg points to MSG structure and not INTERNALMSG.
;
cProc	ReadMessage, <PUBLIC, FAR>, <SI, DI,DS>
ParmW   hq
ParmD   lpMsg
ParmW   hwndFilter
ParmW   msgMinFilter
ParmW   msgMaxFilter
ParmW   fRemoveMsg
cBegin
        push    hq                      ; set ds to queue pointer
        pop     ds
assumes ds,NOTHING

	mov	bx,fRemoveMsg		; pass this to rmquit
        call    rmquit                  ; Must we quit?
        jnz     rmexit                  ; Exit and be sure to leave the
					; QS_POSTMESSAGE bit still set.
;
; Run through the queue and find a message that matches the filters.
;
rm150:
        xor     ax,ax
        cmp     ds:[qCMsgs],ax
        jz      rm500                   ; nothing in queue: exit

        mov     si,ds:[qPmsgRead]       ; Get current read pointer.

rm200:
        call    rmcheckappqueue         ; Check the app queue for a message
        jnz     rm500                   ; fitting the filters.

rm400:
        call    rtestwrap               ; increment pointer in bx and copy to si
        mov     si,bx
        jnz     rm200                   ; at end of queue if Z set
        xor     ax,ax                   ; return FALSE
rm500:
        EnterCrit
        cmp     ds:[qCMsgs],0           ; If no messages left, and out the
        jnz     rm600                   ; input bit.
	cmp	ds:[qCQuit],0		; But only if not quitting
	jnz	rm600
	and	ds:[qWakeBits],NOT QS_POSTMESSAGE
rm600:
        LeaveCrit
rmexit:
assumes es,NOTHING
assumes ds,DATA
cEnd

assumes ds,NOTHING

    ; bx = fRemoveMsg
rmquit:
	mov	ax,ds:[qCQuit]		; Are we in the middle of quiting?
	or	ax,ax			; if cQuit == 0, then continue
        jz      rmq200                  ; return Z.

;	dec	al			; if al == 2, then send quit msg
;	jnz	rmq100
	cmp	ds:[qCMsgs],0		; if queue not empty, don't send quit
        jnz     rmq200
;	inc	ds:[qCQuit]		; set sticky quit & send quit msg
	or	bx,bx
	jz	rmq100			; if PM_NOREMOVE, multiple WM_QUIT's
	mov	ds:[qCQuit],0		; give only one WM_QUIT(raor)
rmq100:
        les     bx,lpMsg
        mov     es:[bx].msgMessage,WM_QUIT ; send a WM_QUIT
        mov     es:[bx].msgHwnd,NULL       ; null window handle
        mov     ax,ds:[qExitCode]       ; stick the exit code in wParam
        mov     es:[bx].msgWParam,ax
        or      al,TRUE
        ret
rmq200:
        xor     ax,ax
        ret
;
; If the hq is an app queue, we can filter immediately.
;
rmcheckappqueue:
        mov     bx,ds:[si].ismMsg.msgHwnd      ; see if hwnd satisfies hwndFilter
        mov     cx,hwndFilter
        call    CheckHwndFilter2
        mov     bx,si                   ; copy read ptr into bx
        jz      rmc200                  ; bad luck - try next one
        mov     ax,ds:[si].ismMsg.msgMessage   ; see if msgMinFilter <= msg <= msgMaxFilter
        mov     cx,msgMinFilter         ; cx = msgMinFilter
        mov     dx,msgMaxFilter         ; dx = msgMaxFilter
        call    CheckMsgFilter2         ; Z if no message.
        jz      rmc200
;
; We've found a message -- read it into lpMsg
;
        les     di,lpMsg                ; get pointer to event block
        mov     cx,ds:[qCbEntry]
	sub	cx, size INTERNALMSG - size MSG
	push    si			; preserve ptr to ExtraMsgInfo
	add     si, size INTERNALMSG - size MSG
        cld
        rep movsb                       ; copy message structure & advance rd ptr
;
; save away time, id, and position of this event in queue header
;
; NOTE: this code doesn't work for the system queue, but that's ok since we
; don't use the queue's time anyway.
;
        sub     si,size MSG - msgTime   ; point at saved time
        mov     di,qTimeLast            ;
        push    ds                      ; copy into ES too
        pop     es
        movsw                           ; copy time and position
        movsw
        errnz   qPtLast-qTimeLast-4
        movsw
        movsw
        mov     ax,bx                   ; store position of msg in q header
        stosw
        errnz   qIdLast-qPtLast-4
	pop	si			; Restore ptr to ExtraMsgInfo
	errnz   qdwExtraInfoLast-qIdLast-2
	errnz   <size INTERNALMSG - size MSG - 4>
	movsw
	movsw
      
        cmp     fRemoveMsg,0            ; are we supposed to yank the message?
        jnz     rmc100                  ; yes: take it out
        mov     ds:[qIdLast],1          ; stick something random in qidLast
        jmps    rmc150                  ; so we don't reply until it's yanked
rmc100:
        call    DelQEntry               ; delete queue entry & update ptrs
rmc150:
        mov     ax,bx                   ; return ID value, TRUE, NZ.
        or      ax,ax
rmc200:
        ret

assumes ds,DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ PRIVATE
DelQEntry - Delete a queue message entry.

Delete message entry from queue.  Adjust pmsgRead, pmsgWrite
and cMsgs.

LINKAGE:    register

ENTRY:      WORD    bx - pointer to entry to delete
            WORD    ds - hq

EXIT:       void

EFFECTS:    pmsgRead and pmsgWrite are adjusted, and part of rgMsg
            is blt'ed to fill hole left by deleted message.

            Trashes es, si, di

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    disable interrupts, change cMsgs, pmsgRead, pmsgWrite, then
    rep movsb from bottom up.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LabelNP <PUBLIC, DelQEntry>

assumes DS,NOTHING

        EnterCrit
        push    ds
        pop     es
        dec     ds:[qCMsgs]             ; decrement count
        mov     ax,ds:[qCbEntry]
        mov     si,ds:[qPmsgRead]
        mov     di,ds:[qPmsgWrite]
        cmp     si,bx                   ; compare sptr to dptr
        ja      de500
;
; rptr < dptr: blt stuff below up
;       move(rptr, rptr+1, dptr-rptr)
;       rptr++;
;
        std                             ; blt backwards
        mov     cx,bx                   ; cb = dptr-rptr
        sub     cx,si
        mov     si,bx                   ; src = dptr
        dec     si                      ; point at first byte to copy
        mov     di,si                   ; dest = src + size(entry)
        add     di,ax
        rep movsb                       ; copy those bytes
        inc     di                      ; readjust DI
        cmp     di,ds:[qPmsgMax]        ; update read pointer
        jb      de200                   ; checking for wraparound
        mov     di,qRgmsg
de200:
        mov     ds:[qPmsgRead],di
        cld
        LeaveCrit
        ret
;
; rptr > dptr: blt stuff above down
;       wptr--;
;       move(dptr + 1, dptr, wptr - dptr)
;
de500:
        cld
        mov     si,bx                   ; src = dptr + size(entry)
        add     si,ax
        mov     cx,di                   ; cb = (wptr - (dptr + size(entry)))
        sub     cx,si
        mov     di,bx                   ; dest = dptr
        rep movsb                       ; copy those bytes
        mov     ds:[qPmsgWrite],di      ; update write pointer
        LeaveCrit
        ret
;
; increment read ptr in bx, testing for wraparound
;
LabelNP <PUBLIC, rtestwrap>
        add     bx,ds:[qCbEntry]        ; advance pointer
        cmp     bx,ds:[qPmsgMax]        ; wrap around if needed
        jb      tw50
        mov     bx,qRgmsg
tw50:
        cmp     bx,ds:[qPmsgWrite]      ; set CC's if end of queue
        ret

assumes ds,DATA

endif           ; WOW doesn't ever put anything in the 16-bit Queue

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
LinkQ (lphqStart, hqLink, ibLink) - Add Q to linked list.

Add new queue entry to END of linked list starting at lphqStart and
linked by ibLink.  ibLink can be qHqNext or qHqSendNext.

LINKAGE:    NEAR PLM

ENTRY:      DWORD lphqStart (parm1) - far pointer to start of queue list
            WORD  hqLink (parm2)    - handle of queue to be linked
            WORD  ibLink (parm3)    - byte index to link to be used in
                                      Q structure.

EXIT:       ax contains hqLink

EFFECTS:    all registers modified.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Walk the linked list starting at lphqStart till hqNext is NULL indicating
    end of list. Add new entry to list there.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LabelNP <PUBLIC, LinkQ>
; ret = 0+2 (saved si)
; ibLink = 2+2
; hqLink = 4+2
; lpHqStart = 6+2
;
        push    si
        mov     si,sp

        EnterCrit

        les     bx,ss:[si+8]            ; Get lpHqStart

lnk100:
        mov     cx,word ptr es:[bx]     ; Check for end of the list.
        jcxz    lnk200

        mov     es,cx                   ; Get Next Link.
        mov     bx,ss:[si+4]            ; BX = ibLink.
        jmps    lnk100

lnk200:
        mov     ax,ss:[si+6]            ; Store hqLink at end of list.
        mov     word ptr es:[bx],ax

        mov     es,ax                   ; AX = hqLink.
        mov     bx,ss:[si+4]
        mov     word ptr es:[bx],cx     ; CX = 0. Zero out pNext.

        LeaveCrit
        pop     si
        ret     8

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
UnlinkQ (lphqStart, hqLink, ibLink) - Unlink Q from list.

Unlink queue specified by hqLink from linked list starting at lphqStart and
linked by ibLink.  ibLink can be qHqNext or qHqSendNext.

LINKAGE:    NEAR PLM


ENTRY:      DWORD lphqStart (parm1) - far pointer to start of queue list
            WORD  hqLink (parm2)    - handle of queue to be unlinked
            WORD  ibLink (parm3)    - byte index to link to be used in
                                      Q structure.

EXIT:       ax contains handle of unlinked queue, zero flag clear

EXIT ERROR - zero flag is set

EFFECTS:    all registers modified.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Walk the linked list starting at lphqStart till hqLink is found and
    unlink.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LabelNP <PUBLIC, UnlinkQ>
;
;
; ret = 0+2+ (pushed si)
; cbLink = 2+2
; hq = 4+2
; lpHqStart = 6+2
;
assumes ds,NOTHING
        push    si
        mov     si,sp
        push    di
        push    ds

        EnterCrit

        les     di,ss:[si+8]            ; Get lpHqStart.
        mov     bx,ss:[si+6]            ; Get hqUnlink.

ulq100:
        mov     cx,es:[di]              ; Exit with zero if at end of list.
        jcxz    ulqExit

        cmp     cx,bx                   ; Have we found the guy that points
        jz      ulq200                  ; to hqUnlink?

        mov     es,cx                   ; Point to the next guy and continue.
        mov     di,ss:[si+4]
        jmps    ulq100

ulq200:
        mov     ds,bx                   ; Get the hq that hqUnlink points to.
        mov     bx,ss:[si+4]
        mov     bx,ds:[bx]

        mov     es:[di],bx              ; Store in hqLinkNext of the guy
                                        ; previous to hqUnlink.
ulqExit:
        LeaveCrit

        or      cx,cx
        pop     ds
        pop     di
        pop     si
        ret     8
assumes DS,DATA

ifndef WOW      ; WOW thunks SetMessageQueue
;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
BOOL SetMessageQueue(cMsg)

 This function is available to the task that desires a larger message
 queue than the default.  This routine must be called from the
 applications' WinMain routine as soon as possible.  It must not be
 called after any operation that could generate messages (such as
 a CreateWindow).  Any messages currently in the queue will be
 destroyed.  By default, the system creates a default queue with room
 for 8 messages.

LINKAGE:    FAR PLM


ENTRY:	    WORD  cMsg - The size of the new queue in messages.

EXIT:	    ax contains:
	TRUE:	If new queue is sucessfully created.
	FALSE:	If there was an error creating the new queue.  In this case,
		the application has no queue associated with it (since the
		origional queue is deleted first).  The application MUST
		call SetMessageQueue with a smaller size until a TRUE is
		returned (or the application may terminate itself).

EFFECTS:    SI, DI preserved.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Call DeleteQueue()
    Call CreateQueue(cMsg)
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


cProc	SetMessageQueue, <PUBLIC, FAR, EXPORTED>, <SI, DI>
ParmW	cMsg
cBegin
    call    DeleteQueue
    mov     ax,cMsg
    push    ax
    call    CreateQueue
cEnd

endif           ; WOW thunks SetMessageQueue

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\wowcomm.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCOMM.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 28-Apr-1993 by Craig Jones (v-cjones)
 *
 *  This file provides support for the Win 3.1 SetCommEventMask() API.
 *  SetCommEventMask() returns a 16:16 ptr to the app so it can monitor
 *  the event word & shadow MSR.
 *
--*/

#include <windows.h>
#include <wowcomm.h>

int WINAPI WOWCloseComm(int idComDev, LPDWORD lpdwEvts);
int WINAPI WOWOpenComm(LPCSTR lpszPort, UINT cbInQ, UINT cbOutQ, DWORD dwEvts);


int WINAPI ICloseComm(int idComDev)
{
    int    ret;
    DWORD  dwEvts = 0;

    // we're really calling wu32CloseComm() here
    ret = WOWCloseComm(idComDev, (LPDWORD)&dwEvts);

    // free this 16:16 memory if it was alloc'd in IOpenComm()
    if(dwEvts) {
        GlobalDosFree((UINT)LOWORD(dwEvts));
    }

    return(ret);
}


int WINAPI IOpenComm(LPCSTR lpszPort, UINT cbInQ, UINT cbOutQ)
{
    int    ret;
    DWORD  dwEvts;

    dwEvts = GlobalDosAlloc((DWORD)sizeof(COMDEB16));

    // we're really calling wu32OpenComm() here
    ret = WOWOpenComm(lpszPort, cbInQ, cbOutQ, dwEvts);

    // if OpenComm() failed - free the 16:16 memory
    if((ret < 0) && (dwEvts)) {
        GlobalDosFree((UINT)LOWORD(dwEvts));
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\winstr.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINSTR.ASM
;   Win16 string services
;
;   History:
;
;   Created 18-Jun-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--


;****************************************************************************
;*									    *
;*  WinStr.ASM -							    *
;*									    *
;*	String related API calls to support different lanuages	 	    *
;*									    *
;****************************************************************************

        TITLE   WinStr.ASM

ifdef WOW
NOEXTERNS equ 1
endif
NOTEXT = 1
.xlist
include user.inc
.list

sBegin	DATA
sEnd

createSeg _TEXT, CODE, WORD, PUBLIC, CODE

sBegin	CODE

assumes CS,CODE
assumes DS,DATA

ExternNP	Loc_IsConvertibleToUpperCase
ExternNP	Loc_Upper
ExternFP	IAnsiUpper
ExternFP	IAnsiLower
ExternFP	Ilstrcmpi
ifdef FE_SB
ExternFP	IsDBCSLeadByte
endif

; Function codes for all the string functions in USER
;
ANSINEXT_ID	equ	1
ANSIPREV_ID	equ	2
ANSIUPPER_ID	equ	3
ANSILOWER_ID	equ	4

;--------------------------------------------------------------------------
;    The order of entries in the following table can not be changed 
;    unless the *_ID codes are also changed in KERNEL also.
;    ((FunctionCode - 1) << 1) is used as the index into this table
;
;	Function Codes:
;
;    NOTE: If you change the entries in this table, kindly update the
;    *_ID statements above and also lString.asm of KERNEL.
;
;--------------------------------------------------------------------------
LabelW	StringFuncTable
	dw	codeOFFSET	IAnsiNext
	dw	codeOFFSET	IAnsiPrev
	dw	codeOFFSET	IAnsiUpper
	dw	codeOFFSET	IAnsiLower

;*----------------------------------------------------------------------*
;*    StringFunc()							*
;*	The string manipulation functions in kernel have been moved 	*
;*	into USER.							*
;*	This is the common entry point in USER for all the string 	*
;*	manipulation functions Kernel wants to call. Kernel jumps to 	*
;*      this function with the function code in CX                      *
;*									*
;*    Input Parameters:							*
;*      [CX] contains the Function code.                                *
;*      [sp] contains the FAR return address of the original caller of  *
;*		the string manipulation functions in Kernel		*
;*----------------------------------------------------------------------*

cProc	StringFunc, <FAR, PUBLIC>
cBegin	nogen
        xchg    bx,cx   ; move function code to BX
	dec	bx
	shl	bx, 1
	jmp	StringFuncTable[bx]
			; Control does not comeback here. It returns directly
			; to the caller
cEnd	nogen

;*----------------------------------------------------------------------*
;*									*
;*  AnsiPrev()								*
;*									*
;*----------------------------------------------------------------------*

ifdef	FE_SB

cProc	IAnsiPrev,<PUBLIC,FAR>
;       parmD   pFirst                  ; [bx+10] es:di
;       parmD   pStr                    ; [bx+6] ds:si

cBegin  nogen
	push	bp
	mov	bp,sp

	push    ds
        push    si
        push    di

        lds     si,[bp+6]
        les     di,[bp+10]
        regptr  dssi,ds,si
        regptr  esdi,es,di
        cld

        cmp     si,di           ; pointer to first char?
        jz      ap5             ; yes, just quit

	dec	si		; backup once
	cmp	si,di		; pointer to first char?
	jz	ap5		; yse, just quit

ap1:
	dec	si		; backup once
	mov	al, [si]	; fetch a character
        cCall   IsDBCSLeadByte,<ax>  ; DBCS lead byte candidate?
	test	ax,ax		;
	jz	ap2		; jump if not.
	cmp	si,di		; backword exhausted?
	jz	ap3		; jump if so
	jmp	ap1		; repeat if not
ap2:
	inc	si		; adjust pointer correctly
ap3:
	mov	bx, [bp+6]	;
	mov	di, bx		; result in DI
	dec	di		;
	sub	bx, si		; how many characters backworded
	test	bx, 1		; see even or odd...
	jnz	ap4		; odd - previous char is SBCS
	dec	di		; make DI for DBCS
ap4:
	mov	si, di		; final result in SI
ap5:
	mov	ax,si
	mov	dx,ds

	pop     di
        pop     si
        pop     ds

	pop	bp
        ret     8
cEnd    nogen

else

cProc	IAnsiPrev,<PUBLIC,FAR>
;       parmD   pFirst                  ; [bx+8] es:di
;       parmD   pStr                    ; [bx+4] ds:si

cBegin  nogen
        mov     bx,sp

	push    ds
        push    si
        push    di

        lds     si,ss:[bx+4]
        les     di,ss:[bx+8]
        regptr  dssi,ds,si
        regptr  esdi,es,di
        cld

        cmp     si,di           ; pointer to first char?
        jz      ap3             ; yes, just quit
;;ifdef FE_SB
;;	xchg	si,di
;;ap1:    mov     dx,si
;;        lodsb                   ; get a char
;;        cCall   IsDBCSLeadByte,<ax>  ; is it kanji?
;;	cmp	al,0
;;        je      ap2             ; no, get next char
;;        inc     si              ; yes, inc past second part
;;ap2:    cmp     si,di           ; have we at or past end?
;;        jb      ap1             ; no, keep going
;;        mov     si,dx           ; return previous pointer
;;else
        dec     si              ; assume easy case...
;;endif ; FE_SB
ap3:    mov     ax,si
        mov     dx,ds

	pop     di
        pop     si
        pop     ds
        ret     8
cEnd    nogen

endif

;*----------------------------------------------------------------------*
;*									*
;*   AnsiNext()								*
;*									*
;*----------------------------------------------------------------------*

cProc	IAnsiNext,<PUBLIC,FAR>
;       parmD   pStr
cBegin  nogen
        mov     bx,sp
        push    di
        les     di,ss:[bx+4]
        mov     al,es:[di]
        or      al,al
        jz      an1
        inc     di
ifdef FE_SB
        cCall	IsDBCSLeadByte,<ax>
        cmp	al,0
        je      an1
        inc     di
endif ; FE_SB
an1:    mov     ax,di
        mov     dx,es
        pop     di
        ret     4
cEnd    nogen

;-----------------------------------------------------------------------
;   MyAnsiUpper()
; 	convert string at es:di to upper case
;-----------------------------------------------------------------------
        public  MyAnsiUpper
MyAnsiUpper:
        cld
        mov     si,di
mau1:   lods    byte ptr es:[si]

ifdef FE_SB
	push	ax
        cCall   IsDBCSLeadByte,<ax>
	cmp	ax,0
	pop	ax
	je	mau2
        inc     si
        inc     di
        inc     di
        jmp     short mau1
endif

mau2:   call    MyUpper
        stosb
        or      al,al
        jnz     mau1
        ret

;-----------------------------------------------------------------------
;    MyAnsiLower()
; 	convert string at es:di to lower case
;-----------------------------------------------------------------------
        public  MyAnsiLower
MyAnsiLower:
        cld
        mov     si,di
mal1:   lods    byte ptr es:[si]

ifdef FE_SB
	push	ax
        cCall   IsDBCSLeadByte,<ax>     ; first byte of double byte?
	cmp	ax,0
	pop	ax
        je      mal2                    ; no just do normal stuff
        inc     si                      ; skip the two bytes
        inc     di
        inc     di
        jmp     short mal1
endif

mal2:   call    MyLower
        stosb
        or      al,al
        jnz     mal1
        ret

;-------------------------------------------------------------------------
;   MyUpper()
; 	convert lower case to upper, must preserve es,di,cx
;-------------------------------------------------------------------------
        public  MyUpper
MyUpper:
	call	Loc_IsConvertibleToUpperCase ; Check if it is a lower case char
				           ; that has an uppercase equivalent
	jnc	myu1		; 
	sub     al,'a'-'A'
myu1:   ret

ifdef KANJI
####################  KANJI  ###############################################
        ; convert upper case to lower, must preserve es,di,cx
        public  MyLower
MyLower:
        cmp     al,'A'
        jb      myl2
        cmp     al,'Z'
        jbe     myl1

	push	ds
	SetKernelDS
	cmp	[fFarEast],1	; this is a far east kbd 1/12/87 linsh
	pop	ds
	UnSetKernelDS
	jge	myl2		; yes do nothing to the 0C0H - 0DEH range

        cmp     al,0C0H         ; this is lower case a with a back slash
        jb      myl2
        cmp     al,0DEH
        ja      myl2
myl1:   add     al,'a'-'A'
myl2:   ret
####################  KANJI  ###############################################
endif

;--------------------------------------------------------------------------
;   MyLower()
; 	convert upper case to lower, must preserve es,di,cx
;--------------------------------------------------------------------------
        public  MyLower
MyLower:
	call	Loc_Upper
	jnc	myl1
	add	al, 'a'-'A'
myl1:	
	ret

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\wsphelp.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WSPHELP.ASM
;   Win16 wsprintf/wvsprintf helper services
;
;   History:
;
;   Created 28-May-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--

;
;   WSPHELP.ASM
;
;   Assembly language helper functions for wvsprintf(), primarily for
;   space optimization.
;
;   History:
;	2/15/89     craigc	    Initial
;

memS=1
?PLM=1
?WIN=1
ifdef WOW
SEGNAME equ <TEXT>
endif

.xlist
include cmacros.inc
.list

createSeg   _%SEGNAME,%SEGNAME,WORD,public,CODE

sBegin %SEGNAME

assumes cs,%SEGNAME

;
;   SP_PutNumber
;
;   Takes an unsigned long integer and places it into a buffer, respecting
;   a buffer limit, a radix, and a case select (upper or lower, for hex).
;

cProc	SP_PutNumber, <NEAR,PUBLIC>, <si,di>

    parmD   lpb
    parmD   n
    parmW   limit
    parmW   radix
    parmW   case

cBegin
    mov     al,'a'-'0'-10	    ; figure out conversion offset
    cmp     case,0
    jz	    pn_lower
    mov     al,'A'-'0'-10
pn_lower:
    mov     byte ptr case,al

    mov     bx,word ptr n[0]	    ; bx:dx=number
    mov     dx,word ptr n[2]
    mov     cx,radix		    ; cx=radix
    les     di,lpb		    ; es:di->string
    mov     si,limit		    ; cchLimit
;
;   following adapted from fultoa.asm
;
;   dx:bx = unsigned number, cx = radix, es:di->output
;

divdown:
    xchg    ax,dx		    ; divide hi
    xor     dx,dx
    or	    ax,ax
    jz	    nohigh		    ; save a divide
    div     cx			    ; dx = rem, ax = hi div

nohigh:
    xchg    ax,bx		    ; ax = lo, bx = hi div
    div     cx			    ; dx = rem, bx:ax = div
    xchg    ax,dx		    ; ax = rem, bx:dx = div
    xchg    dx,bx		    ; ax = rem, dx:bx = div (tight!!!!)
    add     al,'0'
    cmp     al,'9'
    jbe     isadig		    ; is a digit already
    add     al,byte ptr case	    ; convert to letter

isadig:
    dec     si			    ; decrement cchLimit
    jz	    pn_exit		    ; go away if end of string
    stosb			    ; stick it in
    mov     ax,dx
    or	    ax,bx
    jnz     divdown		    ; crack out next digit

pn_exit:
    mov     ax,di
    sub     ax,word ptr lpb[0]	    ; find number of chars output

cEnd

;
;   SP_Reverse
;
;   Reverses a string in place
;
cProc  SP_Reverse,<NEAR,PUBLIC>,<si,di>
    parmD   lpFirst
    parmD   lpLast
cBegin
    push    ds
    lds     si,lpFirst
    les     di,lpLast
    mov     cx,di	    ; number of character difference
    sub     cx,si
    inc     cx
    shr     cx,1	    ; number of swaps required
    jcxz    spr_boring	    ; nuthin' to do
spr100:
    mov     ah,es:[di]
    mov     al,[si]	    ; load the two characters
    mov     [si],ah
    mov     es:[di],al	    ; swap them
    inc     si
    dec     di		    ; adjust the pointers
    loop    spr100	    ; ...until we've done 'em all
spr_boring:
    pop     ds
cEnd


sEnd %SEGNAME

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\wsprintf.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WSPRINTF.C
 *  Win16 wsprintf/wvsprintf code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/*
 *
 *  sprintf.c
 *
 *  Implements Windows friendly versions of sprintf and vsprintf
 *
 *  History:
 *  2/15/89     craigc  Initial
 */

#include "windows.h"
#include "winexp.h"

#define WSPRINTF_LIMIT 1024

extern int near pascal SP_PutNumber(LPSTR, long, int, int, int);
extern void near pascal SP_Reverse(LPSTR lp1, LPSTR lp2);

#define out(c) if (--cchLimit) *lpOut++=(c); else goto errorout

/*
 *  GetFmtValue
 *
 *  reads a width or precision value from the format string
 */

LPCSTR near pascal SP_GetFmtValue(LPCSTR lpch,int FAR *lpw)
{
    register int i=0;

    while (*lpch>='0' && *lpch<='9')
    {
    i *= 10;
    i += (WORD)(*lpch-'0');
    lpch++;
    }

    *lpw=i;

    /* return the address of the first non-digit character */
    return lpch;
}

/*
 *  wvsprintf()
 *
 *  Windows version of vsprintf().  Does not support floating point or
 *  pointer types, and all strings are assumed to be FAR.  Supports only
 *  the left alignment flag.
 *
 *  Takes pointers to an output buffer, where the string is built, a
 *  pointer to an input buffer, and a pointer to a list of parameters.
 *
 *  The cdecl function wsprintf() calls this function.
 */

int API Iwvsprintf(LPSTR lpOut, LPCSTR lpFmt, LPSTR lpParms)
{
    int left;
    char prefix;
    register int width;
    register int prec;
    char fillch;
    int size;
    int sign;
    int radix;
    int upper;
    int cchLimit=WSPRINTF_LIMIT;
    int cch;
    LPSTR lpT;
    union {
    long l;
    unsigned long ul;
    char sz[sizeof(long)];
    } val;

    while (*lpFmt)
    {
    if (*lpFmt=='%')
        {

        /* read the flags.  These can be in any order */
        left=0;
        prefix=0;
        while (*++lpFmt)
        {
        if (*lpFmt=='-')
            left++;
        else if (*lpFmt=='#')
            prefix++;
        else
            break;
        }

        /* find fill character */
        if (*lpFmt=='0')
        {
        fillch='0';
        lpFmt++;
        }
        else
        fillch=' ';

        /* read the width specification */
        lpFmt=SP_GetFmtValue(lpFmt,&cch);
        width=cch;

        /* read the precision */
        if (*lpFmt=='.')
        {
        lpFmt=SP_GetFmtValue(++lpFmt,&cch);
        prec=cch;
        }
        else
        prec=-1;

        /* get the operand size */
        if (*lpFmt=='l')
        {
        size=1;
        lpFmt++;
        }
        else
        {
        size=0;
        if (*lpFmt=='h')
            lpFmt++;
        }

        upper=0;
        sign=0;
        radix=10;
        switch (*lpFmt)
        {
        case 0:
        goto errorout;

        case 'i':
        case 'd':
        sign++;

        case 'u':
        /* turn off prefix if decimal */
        prefix=0;
donumeric:
        /* special cases to act like MSC v5.10 */
        if (left || prec>=0)
            fillch=' ';

        if (size)
            val.l=*((long far *)lpParms)++;
        else
            if (sign)
            val.l=(long)*((short far *)lpParms)++;
            else
            val.ul=(unsigned long)*((unsigned far *)lpParms)++;

        if (sign && val.l<0L)
            val.l=-val.l;
        else
            sign=0;

        lpT=lpOut;

        /* blast the number backwards into the user buffer */
        cch=SP_PutNumber(lpOut,val.l,cchLimit,radix,upper);
        if (!(cchLimit-=cch))
            goto errorout;

        lpOut+=cch;
        width-=cch;
        prec-=cch;
        if (prec>0)
            width-=prec;

        /* fill to the field precision */
        while (prec-->0)
            out('0');

        if (width>0 && !left)
            {
            /* if we're filling with spaces, put sign first */
            if (fillch!='0')
            {
            if (sign)
                {
                sign=0;
                out('-');
                width--;
                }

            if (prefix)
                {
                out(prefix);
                out('0');
                prefix=0;
                }
            }

            if (sign)
            width--;

            /* fill to the field width */
            while (width-->0)
            out(fillch);

            /* still have a sign? */
            if (sign)
            out('-');

            if (prefix)
            {
            out(prefix);
            out('0');
            }

            /* now reverse the string in place */
            SP_Reverse(lpT,lpOut-1);
            }
        else
            {
            /* add the sign character */
            if (sign)
            {
            out('-');
            width--;
            }

            if (prefix)
            {
            out(prefix);
            out('0');
            }

            /* reverse the string in place */
            SP_Reverse(lpT,lpOut-1);

            /* pad to the right of the string in case left aligned */
            while (width-->0)
            out(fillch);
            }
        break;

        case 'X':
        upper++;
        case 'x':
        radix=16;
        if (prefix)
            if (upper)
            prefix='X';
            else
            prefix='x';
        goto donumeric;

        case 'c':
        val.sz[0]=*lpParms;
        val.sz[1]=0;
        lpT=val.sz;
        cch = 1;  // Length is one character.
              // Fix for Bug #1862 --01/10/91-- SANKAR --
        /* stack aligned to larger size */
        lpParms+=sizeof(int);

        goto putstring;

        case 's':
        lpT=*((LPSTR FAR *)lpParms)++;
        cch=lstrlen(lpT);
putstring:
        if (prec>=0 && cch>prec)
            cch=prec;
        width -= cch;
        if (left)
            {
            while (cch--)
            out(*lpT++);
            while (width-->0)
            out(fillch);
            }
        else
            {
            while (width-->0)
            out(fillch);
            while (cch--)
            out(*lpT++);
            }
        break;

        default:
normalch:
#ifdef FE_SB             /* masas : 90-4-26 */
        // If last char is a high ansi char, that may cause infinite loop
        // In case of Taiwan version(PRC and Korea), this char is treated
        // as DBCS lead byte. So we expect trail byte by default. But this
        // is not correct.

        // if( IsDBCSLeadByte(*lpFmt) )  This is original code
        //    out(*lpFmt++);

        if( IsDBCSLeadByte(*lpFmt) ) {
            if( *(lpFmt+1) == '\0' ) {
                out('?');
                lpFmt++;
                continue;
            }
            else
                out(*lpFmt++);
        }
#endif
        out(*lpFmt);
        break;

        }           /* END OF SWITCH(*lpFmt) */
        }           /* END OF IF(%) */
    else
        goto normalch;  /* character not a '%', just do it */

    /* advance to next format string character */
    lpFmt++;
    }       /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut=0;

    return WSPRINTF_LIMIT-cchLimit;
}


/*
 *  wsprintf
 *
 *  Windows version of sprintf
 *
 */

int FAR cdecl wsprintf(LPSTR lpOut, LPCSTR lpFmt, LPSTR lpParms, ...)
{
    return wvsprintf(lpOut,lpFmt,(LPSTR)&lpParms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"      
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\wsubcls.c ===
//****************************************************************************
// SubClassing Support -
//
// Each standard window proc calls 'callwindowproc' withits own address.
//
//
// History:
//
// 15-JAN-92 Nandurir Created.
//
//****************************************************************************

#include "user.h"


//****************************************************************************
// Thunk for ButtonWndProc -
//
//****************************************************************************

LONG FAR PASCAL ButtonWndProc(HWND hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)ButtonWndProc, hwnd, message, wParam, lParam);
}



//****************************************************************************
// Thunk for ComboBoxCtlWndProc -
//
//****************************************************************************

LONG FAR PASCAL ComboBoxCtlWndProc(HWND hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)ComboBoxCtlWndProc, hwnd, message, wParam, lParam);
}



//****************************************************************************
// Thunk for EditWndProc -
//
//****************************************************************************

LONG FAR PASCAL EditWndProc(HWND hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)EditWndProc, hwnd, message, wParam, lParam);
}



//****************************************************************************
// Thunk for LBoxCtlWndProc -
//
//****************************************************************************

LONG FAR PASCAL LBoxCtlWndProc(HWND hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)LBoxCtlWndProc, hwnd, message, wParam, lParam);
}



//****************************************************************************
// Thunk for SBWndProc -
//
//****************************************************************************

LONG FAR PASCAL SBWndProc(PSB hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)SBWndProc, (HWND)hwnd, message, wParam, lParam);
}



//****************************************************************************
// Thunk for StaticWndProc -
//
//****************************************************************************

LONG FAR PASCAL StaticWndProc(HWND hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)StaticWndProc, hwnd, message, wParam, lParam);
}



//****************************************************************************
// Thunk for MDIClientWndProc -
//
//****************************************************************************

LONG FAR PASCAL MDIClientWndProc(HWND hwnd, WORD message, WORD wParam,
                                                                 LONG lParam)
{
    return CallWindowProc((FARPROC)MDIClientWndProc, hwnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\user\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\libentry.asm ===
PAGE,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           DWORD  ignore);     /* Always NULL - ignore */
;        
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;   Note - The last parameter to LibMain is included for compatibility
;   reasons.  Applications that wish to modify this file and remove the
;   parameter from LibMain may do so by simply removing the two
;   "push" instructions below marked with "****".
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include cmacros.inc

externFP <LibMain>               ; the C routine to be called

createSeg INIT_TEXT, INIT_TEXT, BYTE, PUBLIC, CODE
sBegin	INIT_TEXT
assumes CS,INIT_TEXT

?PLM=0                           ; 'C'naming
;externA  <_acrtused>             ; ensures that Win DLL startup code is linked

?PLM=1                           ; 'PASCAL' naming
externFP <LocalInit>             ; Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ; entry point into DLL

include CONVDLL.INC

cBegin
        push    di               ; handle of the module instance
        push    ds               ; library data segment
        push    cx               ; heap size
        push    es               ; Always NULL  ****  May remove (see above)
        push    si               ; Always NULL  ****  May remove (see above)

        ; if we have some heap then initialize it
        jcxz    callc            ; jump if no heap specified

        ; call the Windows function LocalInit() to set up the heap
        ; LocalInit((LPSTR)start, WORD cbHeap);
        
        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ; did it do it ok ?
        jz      error            ; quit if it failed

        ; invoke the C routine to do any special initialization

callc:
        call    LibMain          ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

error:
	pop	si		 ; clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di

exit:

cEnd

sEnd	INIT_TEXT

end LibEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\ints.asm ===
include isvbop.inc

.286
.model medium,pascal

_DATA segment word public 'DATA'

Old2fHandler    dd      ?
Old73Handler    dd      ?
VddHandle       dw      -1

DllName         db      "VWIPXSPX.DLL",0
InitFunc        db      "VwInitialize",0
DispFunc        db      "VwDispatcher",0

_DATA ends

INIT_TEXT segment byte public 'CODE'

        assume  cs:INIT_TEXT

GrabInterrupts proc far
        pusha
        push    ds
        push    es
        push    _DATA
        pop     ds
        assume  ds:_DATA
        push    ds
        pop     es
        mov     si,offset DllName       ; ds:si = library name
        mov     di,offset InitFunc      ; es:di = init function name
        mov     bx,offset DispFunc      ; ds:bx = dispatcher function name
        RegisterModule                  ; returns carry if problem
        jc      @f
        mov     VddHandle,ax
        mov     ax,352fh
        int     21h
        mov     word ptr Old2fHandler,bx
        mov     word ptr Old2fHandler+2,es
ifdef   NEC_98
        mov     ax,3513h
else    ; NEC_98
        mov     ax,3573h
endif   ; NEC_98
        int     21h
        mov     word ptr Old73Handler,bx
        mov     word ptr Old73Handler+2,es
        push    seg PmIpx2fHandler
        pop     ds
        assume  ds:nothing
        mov     dx,offset PmIpx2fHandler
        mov     ax,252fh
        int     21h
        mov     dx,offset PmIpx73Handler
ifdef   NEC_98
        mov     ax,2513h
else    ; NEC_98
        mov     ax,2573h
endif   ; NEC_98
        int     21h
@@:     pop     es
        pop     ds
        popa
        ret
GrabInterrupts endp

INIT_TEXT ends

_TEXT segment byte public 'CODE'

        assume  cs:_TEXT

        public  PmIpx2fHandler
PmIpx2fHandler proc
        cmp     ax,1684h
        jne     @f
        cmp     bx,200h
        jne     @f
        push    cs
        pop     es
        mov     di,offset PmIpxEntryPoint
        iret
@@:     push    bp
        mov     bp,sp
        push    ax
        push    ds
        mov     ax,_DATA
        mov     ds,ax
        assume  ds:_DATA
        push    word ptr Old2fHandler+2
        push    word ptr Old2fHandler
        mov     ds,[bp-4]
        mov     ax,[bp-2]
        mov     bp,[bp]
        retf    6
PmIpx2fHandler endp

        public  PmIpx73Handler
PmIpx73Handler proc
        push    ds
        push    es
        pusha
        mov     bx,_DATA
        mov     ds,bx
        assume  ds:_DATA
        mov     ax,VddHandle
        mov     bx,-2
        DispatchCall                    ; get ECB
        jc      @f
        call    dword ptr es:[si][4]    ; branch to the ESR
        mov     al,20h
ifdef   NEC_98
        out     08h,al                  ; clear slave pic
        out     00h,al                  ;   "   master "
else    ; NEC_98
        out     0a0h,al                 ; clear slave pic
        out     20h,al                  ;   "   master "
endif   ; NEC_98
        popa
        pop     es
        pop     ds
        assume  ds:nothing
        iret
@@:     popa
        pop     es
        push    bp
        mov     bp,sp
        push    _DATA
        pop     ds
        assume  ds:_DATA
        push    word ptr Old73Handler+2
        push    word ptr Old73Handler
        mov     ds,[bp+2]
        assume  ds:nothing
        mov     bp,[bp]
        retf    4
PmIpx73Handler endp

        public PmIpxEntryPoint
PmIpxEntryPoint proc
        push    bp
        push    ds
        push    _DATA
        pop     ds
        assume  ds:_DATA
        mov     bp,ax
        mov     ax,VddHandle
        pop     ds
        assume  ds:nothing
        DispatchCall
        pop     bp
        ret
PmIpxEntryPoint endp

_TEXT ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\locals.h ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    locals.h

Abstract:

    Provides the common definitions for this project.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:

    

--*/

#define LFN 1
#include <winnet.h>
#include <wfwnet.h>
#include <spl_wnt.h>
#include <bseerr.h>

/*
 * global manifests 
 */

//
// used to figure out how to get the last error.
//
#define LAST_CALL_IS_LOCAL        (0)
#define LAST_CALL_IS_LANMAN_DRV   (1)
#define LAST_CALL_IS_WIN32        (2)

//
// the various DLLs we rely on to do the real work.
//
#define LANMAN_DRV       "LANMAN.DRV" 
#define MPR_DLL          "MPR.DLL"
#define MPRUI_DLL        "MPRUI.DLL"
#define NTLANMAN_DLL     "NTLANMAN.DLL"
#define KERNEL32_DLL     "KERNEL32.DLL"
#define WINSPOOL_DRV     "WINSPOOL.DRV"

//
// some convenient manifests for above so we dont need to
// do strcmp()s all the time.
//
#define USE_MPR_DLL      (0)
#define USE_MPRUI_DLL    (1)
#define USE_NTLANMAN_DLL (2)
#define USE_KERNEL32_DLL (3)
#define USE_WINSPOOL_DRV (4)

//
// resource type expected by Win32 APIs
//
#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#define RESOURCETYPE_ERROR      0xFFFFFFFF

//
// errors unknown in 16bit world.
//
#define WIN32_EXTENDED_ERROR    1208L
#define WIN32_WN_CANCEL         1223L

//
// misc convenient macros
//
#define UNREFERENCED(x)  (void)x
#define TO_HWND32(x)     (0xFFFF0000 | (DWORD)x)


/*
 * various typedefs for the 16 bit functions we dynamically load
 */
typedef void (API *LPFN)();
typedef WORD (API *LPWNETOPENJOB)(LPSTR,LPSTR,WORD,LPINT);
typedef WORD (API *LPWNETCLOSEJOB)(WORD,LPINT,LPSTR);
typedef WORD (API *LPWNETWRITEJOB)(HANDLE,LPSTR,LPINT);
typedef WORD (API *LPWNETABORTJOB)(WORD,LPSTR);
typedef WORD (API *LPWNETHOLDJOB)(LPSTR,WORD);
typedef WORD (API *LPWNETRELEASEJOB)(LPSTR,WORD);
typedef WORD (API *LPWNETCANCELJOB)(LPSTR,WORD);
typedef WORD (API *LPWNETSETJOBCOPIES)(LPSTR,WORD,WORD);
typedef WORD (API *LPWNETWATCHQUEUE)(HWND,LPSTR,LPSTR,WORD);
typedef WORD (API *LPWNETUNWATCHQUEUE)(LPSTR);
typedef WORD (API *LPWNETLOCKQUEUEDATA)(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
typedef WORD (API *LPWNETUNLOCKQUEUEDATA)(LPSTR);
typedef WORD (API *LPWNETQPOLL)(HWND,WORD,WORD,LONG);
typedef WORD (API *LPWNETDEVICEMODE)(HWND);
typedef WORD (API *LPWNETVIEWQUEUEDIALOG)(HWND,LPSTR);
typedef WORD (API *LPWNETGETCAPS)(WORD);
typedef WORD (API *LPWNETGETERROR)(LPINT);
typedef WORD (API *LPWNETGETERRORTEXT)(WORD,LPSTR,LPINT);

typedef WORD (API *LPLFNFINDFIRST)(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
typedef WORD (API *LPLFNFINDNEXT)(HANDLE,LPINT,WORD,PFILEFINDBUF2);
typedef WORD (API *LPLFNFINDCLOSE)(HANDLE);
typedef WORD (API *LPLFNGETATTRIBUTES)(LPSTR,LPINT);
typedef WORD (API *LPLFNSETATTRIBUTES)(LPSTR,WORD);
typedef WORD (API *LPLFNCOPY)(LPSTR,LPSTR,PQUERYPROC);
typedef WORD (API *LPLFNMOVE)(LPSTR,LPSTR);
typedef WORD (API *LPLFNDELETE)(LPSTR);
typedef WORD (API *LPLFNMKDIR)(LPSTR);
typedef WORD (API *LPLFNRMDIR)(LPSTR);
typedef WORD (API *LPLFNGETVOLUMELABEL)(WORD,LPSTR);
typedef WORD (API *LPLFNSETVOLUMELABEL)(WORD,LPSTR);
typedef WORD (API *LPLFNPARSE)(LPSTR,LPSTR,LPSTR);
typedef WORD (API *LPLFNVOLUMETYPE)(WORD,LPINT);

/*
 * other misc global data/functions
 */
extern WORD    vLastCall ;
extern WORD    vLastError ;
extern WORD    wNetTypeCaps ;           
extern WORD    wUserCaps ;
extern WORD    wConnectionCaps ;
extern WORD    wErrorCaps ;
extern WORD    wDialogCaps ;
extern WORD    wAdminCaps ;
extern WORD    wSpecVersion;
extern WORD    wDriverVersion;

WORD API WNetGetCaps16(WORD p1) ;
WORD API WNetGetError16(LPINT p1) ;
WORD API WNetGetErrorText16(WORD p1, LPSTR p2, LPINT p3) ;

DWORD API GetLastError32(VOID) ;

WORD SetLastError(WORD err) ;

DWORD MapWNType16To32(WORD nType) ;
WORD MapWin32ErrorToWN16(DWORD err) ;
WORD GetLanmanDrvEntryPoints(LPFN *lplpfn,
                             LPSTR lpName) ;
//
// we define this because the compiler chokes if we add yet
// more to the include path to get to lmerr.h. 
//
// this is not that bad since the value below will never change.
//

#define NERR_BASE               2100
#define NERR_UseNotFound        (NERR_BASE+150)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\bseerr.h ===
/****************************** Module Header ******************************\
*
* Module Name: BSEERR.H
*       
*      Copy of the Lanman BSEERR.H used for their base error codes.
*      Not used by anyone else.
*
\***************************************************************************/

#ifndef BSEERR_INCLUDED
#define BSEERR_INCLUDED

#define NO_ERROR			0
#define ERROR_INVALID_FUNCTION		1
#define ERROR_FILE_NOT_FOUND		2
#define ERROR_PATH_NOT_FOUND		3
#define ERROR_TOO_MANY_OPEN_FILES	4
#define ERROR_ACCESS_DENIED		5
#define ERROR_INVALID_HANDLE		6
#define ERROR_ARENA_TRASHED		7
#define ERROR_NOT_ENOUGH_MEMORY 	8
#define ERROR_INVALID_BLOCK		9
#define ERROR_BAD_ENVIRONMENT		10
#define ERROR_BAD_FORMAT		11
#define ERROR_INVALID_ACCESS		12
#define ERROR_INVALID_DATA		13
/* 14 is reserved			 */
#define ERROR_INVALID_DRIVE		15
#define ERROR_CURRENT_DIRECTORY 	16
#define ERROR_NOT_SAME_DEVICE		17
#define ERROR_NO_MORE_FILES		18
#define ERROR_WRITE_PROTECT		19
#define ERROR_BAD_UNIT			20
#define ERROR_NOT_READY 		21
#define ERROR_BAD_COMMAND		22
#define ERROR_CRC			23
#define ERROR_BAD_LENGTH		24
#define ERROR_SEEK			25
#define ERROR_NOT_DOS_DISK		26
#define ERROR_SECTOR_NOT_FOUND		27
#define ERROR_OUT_OF_PAPER		28
#define ERROR_WRITE_FAULT		29
#define ERROR_READ_FAULT		30
#define ERROR_GEN_FAILURE		31
#define ERROR_SHARING_VIOLATION 	32
#define ERROR_LOCK_VIOLATION		33
#define ERROR_WRONG_DISK		34
#define ERROR_FCB_UNAVAILABLE		35
#define ERROR_SHARING_BUFFER_EXCEEDED	36
#define ERROR_NOT_SUPPORTED		50
#define ERROR_REM_NOT_LIST		51 /* Remote computer not listening   */
#define ERROR_DUP_NAME			52 /* Duplicate name on network       */
#define ERROR_BAD_NETPATH		53 /* Network path not found	      */
#define ERROR_NETWORK_BUSY		54 /* Network busy		      */
#define ERROR_DEV_NOT_EXIST		55 /* Network device no longer exists */
#define ERROR_TOO_MANY_CMDS		56 /* Net BIOS command limit exceeded */
#define ERROR_ADAP_HDW_ERR		57 /* Network adapter hardware error  */
#define ERROR_BAD_NET_RESP		58 /* Incorrect response from network */
#define ERROR_UNEXP_NET_ERR		59 /* Unexpected network error	      */
#define ERROR_BAD_REM_ADAP		60 /* Incompatible remote adapter     */
#define ERROR_PRINTQ_FULL		61 /* Print queue full		      */
#define ERROR_NO_SPOOL_SPACE		62 /* Not enough space for print file */
#define ERROR_PRINT_CANCELLED		63 /* Print file was cancelled	      */
#define ERROR_NETNAME_DELETED		64 /* Network name was deleted	      */
#define ERROR_NETWORK_ACCESS_DENIED	65 /* Access denied		      */
#define ERROR_BAD_DEV_TYPE		66 /* Network device type incorrect   */
#define ERROR_BAD_NET_NAME		67 /* Network name not found	      */
#define ERROR_TOO_MANY_NAMES		68 /* Network name limit exceeded     */
#define ERROR_TOO_MANY_SESS		69 /* Net BIOS session limit exceeded */
#define ERROR_SHARING_PAUSED		70 /* Sharing temporarily paused      */
#define ERROR_REQ_NOT_ACCEP		71 /* Network request not accepted    */
#define ERROR_REDIR_PAUSED		72 /* Print|disk redirection is paused*/
#define ERROR_FILE_EXISTS		80
#define ERROR_DUP_FCB			81
#define ERROR_CANNOT_MAKE		82
#define ERROR_FAIL_I24			83
#define ERROR_OUT_OF_STRUCTURES 	84
#define ERROR_ALREADY_ASSIGNED		85
#define ERROR_INVALID_PASSWORD		86
#define ERROR_INVALID_PARAMETER 	87
#define ERROR_NET_WRITE_FAULT		88
#define ERROR_NO_PROC_SLOTS		89 /* no process slots available      */
#define ERROR_NOT_FROZEN		90
#define ERR_TSTOVFL			91 /* timer service table overflow    */
#define ERR_TSTDUP			92 /* timer service table duplicate   */
#define ERROR_NO_ITEMS			93 /* no items to operate upon	      */
#define ERROR_INTERRUPT 		95 /* interrupted system call	      */
#define ERROR_DEVICE_IN_USE		99 /* Device in use by another thread */
#define ERROR_TOO_MANY_SEMAPHORES	100
#define ERROR_EXCL_SEM_ALREADY_OWNED	101
#define ERROR_SEM_IS_SET		102
#define ERROR_TOO_MANY_SEM_REQUESTS	103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED		105 /* waitsem found owner died       */
#define ERROR_SEM_USER_LIMIT		106 /* too many procs have this sem   */
#define ERROR_DISK_CHANGE		107
#define ERROR_DRIVE_LOCKED		108 /* drive locked by another process*/
#define ERROR_BROKEN_PIPE		109 /* write on pipe with no reader   */
#define ERROR_OPEN_FAILED		110 /* open/created failed due to     */
                                            /* explicit fail command          */
#define ERROR_BUFFER_OVERFLOW		111 /* buffer passed to system call   */
                                            /* is too small to hold return    */
                                            /* data.                          */
#define ERROR_DISK_FULL 		112 /* not enough space on the disk   */
                                            /* (DOSNEWSIZE/w_NewSize)         */
#define ERROR_NO_MORE_SEARCH_HANDLES	113 /* can't allocate another search  */
                                            /* structure and handle.          */
                                            /* (DOSFINDFIRST/w_FindFirst)     */
#define ERROR_INVALID_TARGET_HANDLE	114 /* Target handle in DOSDUPHANDLE  */
                                            /* is invalid                     */
#define ERROR_PROTECTION_VIOLATION	115 /* Bad user virtual address       */
#define ERROR_VIOKBD_REQUEST		116
#define ERROR_INVALID_CATEGORY		117 /* Category for DEVIOCTL in not   */
                                            /* defined                        */
#define ERROR_INVALID_VERIFY_SWITCH	118 /* invalid value passed for       */
                                            /* verify flag                    */
#define ERROR_BAD_DRIVER_LEVEL		119 /* DosDevIOCTL looks for a level  */
                                            /* four driver. If the driver     */
                                            /* is not level four we return    */
                                            /* this code                      */
#define ERROR_CALL_NOT_IMPLEMENTED	120 /* returned from stub api calls.  */
                                            /* This call will disappear when  */
                                            /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT		121 /* Time out happened from the     */
                                            /* semaphore api functions.       */
#define ERROR_INSUFFICIENT_BUFFER	122 /* Some calls require the	      */
                                       /* application to pass in a buffer     */
                                       /* filled with data.  This error is    */
                                       /* returned if the data buffer is too  */
                                       /* small.  For example: DosSetFileInfo */
                                       /* requires 4 bytes of data.  If a     */
                                       /* two byte buffer is passed in then   */
                                       /* this error is returned.             */
                                       /* error_buffer_overflow is used when  */
                                       /* the output buffer in not big enough.*/
#define ERROR_INVALID_NAME		123 /* illegal character or malformed */
                                            /* file system name               */
#define ERROR_INVALID_LEVEL		124 /* unimplemented level for info   */
                                            /* retrieval or setting           */
#define ERROR_NO_VOLUME_LABEL		125 /* no volume label found with     */
                                            /* DosQFSInfo command             */
#define ERROR_MOD_NOT_FOUND		126 /* w_getprocaddr,w_getmodhandle   */
#define ERROR_PROC_NOT_FOUND		127 /* w_getprocaddr		      */
#define ERROR_WAIT_NO_CHILDREN		128 /* CWait finds to children	      */
#define ERROR_CHILD_NOT_COMPLETE	129 /* CWait children not dead yet    */
#define ERROR_DIRECT_ACCESS_HANDLE	130 /* handle operation is invalid    */
                                            /* for direct disk access         */
                                            /* handles                        */
#define ERROR_NEGATIVE_SEEK		131 /* application tried to seek      */
                                            /* with negitive offset           */
#define ERROR_SEEK_ON_DEVICE		132 /* application tried to seek      */
                                            /* on device or pipe              */
#define ERROR_IS_JOIN_TARGET		133
#define ERROR_IS_JOINED 		134
#define ERROR_IS_SUBSTED		135
#define ERROR_NOT_JOINED		136
#define ERROR_NOT_SUBSTED		137
#define ERROR_JOIN_TO_JOIN		138
#define ERROR_SUBST_TO_SUBST		139
#define ERROR_JOIN_TO_SUBST		140
#define ERROR_SUBST_TO_JOIN		141
#define ERROR_BUSY_DRIVE		142
#define ERROR_SAME_DRIVE		143
#define ERROR_DIR_NOT_ROOT		144
#define ERROR_DIR_NOT_EMPTY		145
#define ERROR_IS_SUBST_PATH		146
#define ERROR_IS_JOIN_PATH		147
#define ERROR_PATH_BUSY 		148
#define ERROR_IS_SUBST_TARGET		149
#define ERROR_SYSTEM_TRACE		150 /* system trace error	      */
#define ERROR_INVALID_EVENT_COUNT	151 /* DosMuxSemWait errors	      */
#define ERROR_TOO_MANY_MUXWAITERS	152
#define ERROR_INVALID_LIST_FORMAT	153
#define ERROR_LABEL_TOO_LONG		154
#define ERROR_TOO_MANY_TCBS		155
#define ERROR_SIGNAL_REFUSED		156
#define ERROR_DISCARDED 		157
#define ERROR_NOT_LOCKED		158
#define ERROR_BAD_THREADID_ADDR 	159
#define ERROR_BAD_ARGUMENTS		160
#define ERROR_BAD_PATHNAME		161
#define ERROR_SIGNAL_PENDING		162
#define ERROR_UNCERTAIN_MEDIA		163
#define ERROR_MAX_THRDS_REACHED 	164
#define ERROR_MONITORS_NOT_SUPPORTED	165
#define ERROR_UNC_DRIVER_NOT_INSTALLED	166

/*	The following error codes refer to demand loading segments     */
#define ERROR_LOCK_FAILED		167
#define ERROR_SWAPIO_FAILED		168
#define ERROR_SWAPIN_FAILED		169
#define ERROR_BUSY			170

#define ERROR_INVALID_SEGMENT_NUMBER	180
#define ERROR_INVALID_CALLGATE		181
#define ERROR_INVALID_ORDINAL		182
#define ERROR_ALREADY_EXISTS		183
#define ERROR_NO_CHILD_PROCESS		184
#define ERROR_CHILD_ALIVE_NOWAIT	185
#define ERROR_INVALID_FLAG_NUMBER	186
#define ERROR_SEM_NOT_FOUND		187

/* following error codes make loader error messages distinct  */
#define ERROR_INVALID_STARTING_CODESEG	188
#define ERROR_INVALID_STACKSEG		189
#define ERROR_INVALID_MODULETYPE	190
#define ERROR_INVALID_EXE_SIGNATURE	191
#define ERROR_EXE_MARKED_INVALID	192
#define ERROR_BAD_EXE_FORMAT		193
#define ERROR_ITERATED_DATA_EXCEEDS_64K 194
#define ERROR_INVALID_MINALLOCSIZE	195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED		197
#define ERROR_INVALID_SEGDPL		198
#define ERROR_AUTODATASEG_EXCEEDS_64k	199
#define ERROR_RING2SEG_MUST_BE_MOVABLE	200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM	201
#define ERROR_INFLOOP_IN_RELOC_CHAIN	202
#define ERROR_ENVVAR_NOT_FOUND		203
#define ERROR_NOT_CURRENT_CTRY		204
#define ERROR_NO_SIGNAL_SENT		205
#define ERROR_FILENAME_EXCED_RANGE	206 /* if filename > 8.3 */
#define ERROR_RING2_STACK_IN_USE	207 /* for FAPI 	 */
#define ERROR_META_EXPANSION_TOO_LONG	208 /* if "*a" > 8.3	 */
#define ERROR_INVALID_SIGNAL_NUMBER	209
#define ERROR_THREAD_1_INACTIVE 	210
#define ERROR_INFO_NOT_AVAIL		211
#define ERROR_LOCKED			212
#define ERROR_BAD_DYNALINK		213
#define ERROR_TOO_MANY_MODULES		214
#define ERROR_NESTING_NOT_ALLOWED	215
#define ERROR_CANNOT_SHRINK		216 /* attempt to shrink ring 2 stack */
#define ERROR_ZOMBIE_PROCESS		217
#define ERROR_STACK_IN_HIGH_MEMORY	218
#define ERROR_INVALID_EXITROUTINE_RING	219
#define ERROR_GETBUF_FAILED		220
#define ERROR_FLUSHBUF_FAILED		221
#define ERROR_TRANSFER_TOO_LONG 	222
#define ERROR_NO_CHILDREN		228
#define ERROR_INVALID_SCREEN_GROUP	229
/*
 * Error codes 230 - 249 are reserved
 */
#define ERROR_BAD_PIPE			230 /* Non-existant pipe or bad operation */
#define ERROR_PIPE_BUSY 		231 /* Pipe is busy		      */
#define ERROR_NO_DATA			232 /* No data on non-blocking read   */
#define ERROR_PIPE_NOT_CONNECTED	233 /* Pipe was disconnected by server*/
#define ERROR_MORE_DATA 		234 /* More data is available	      */

#define ERROR_VC_DISCONNECTED		240
#define ERROR_CIRCULARITY_REQUESTED	250 /* When renaming a dir which      */
                                            /* would cause a circularity      */
#define ERROR_DIRECTORY_IN_CDS		251 /* When renaming a dir	      */
                                            /* which is "in use"              */
#define ERROR_INVALID_FSD_NAME		252 /* when trying to access	      */
                                            /* nonexistent FSD                */
#define ERROR_INVALID_PATH		253 /* bad pseudo device	      */
#define ERROR_INVALID_EA_NAME		254 /* Illegal chars in name	      */
#define ERROR_EA_LIST_INCONSISTENT	255 /* Size or some field bad	      */
#define ERROR_EA_LIST_TOO_LONG		256 /* FEAlist > 64K-1 bytes	      */
#define ERROR_NO_META_MATCH		257 /* string doesn't match expression*/
#define ERROR_FINDNOTIFY_TIMEOUT	258 /* FindNotify request timeout     */
#define ERROR_NO_MORE_ITEMS		259 /* QFSAttach ordinal query	      */
#define ERROR_SEARCH_STRUC_REUSED	260 /* 3xbox findfirst/next
                                               search structure reused        */
#define ERROR_CHAR_NOT_FOUND		261 /* can not find character	      */
#define ERROR_TOO_MUCH_STACK		262 /* Stack request exceeds sys limit*/
#define ERROR_INVALID_ATTR		263 /* invalid FS_ATTRIBUTE	      */
#define ERROR_INVALID_STARTING_RING	264
#define ERROR_INVALID_DLL_INIT_RING	265
#define ERROR_CANNOT_COPY		266 /* doscopy */
#define ERROR_DIRECTORY 		267 /* doscopy */
#define ERROR_OPLOCKED_FILE		268
#define ERROR_OPLOCK_THREAD_EXISTS	269

/* error codes for DosFindNotify */
#define ERROR_VOLUME_CHANGED		270
#define ERROR_FINDNOTIFY_HANDLE_IN_USE	271
#define ERROR_FINDNOTIFY_HANDLE_CLOSED	272
#define ERROR_NOTIFY_OBJECT_REMOVED	273

/* Error to indicate that ShutDown already done */
#define ERROR_ALREADY_SHUTDOWN		274

/* error code for DOSFINDFIRST2/NEXT */
#define ERROR_EAS_DIDNT_FIT		275

/* error codes for EA file format change */
#define ERROR_EA_FILE_CORRUPT		276
#define ERROR_EA_TABLE_FULL		277
#define ERROR_INVALID_EA_HANDLE 	278
#define ERROR_NO_CLUSTER		279
#define ERROR_CREATE_EA_FILE		280
#define ERROR_CANNOT_OPEN_EA_FILE	281

#define ERROR_INVALID_PROCID		303
#define ERROR_INVALID_PDELTA		304
#define ERROR_NOT_DESCENDANT		305
#define ERROR_NOT_SESSION_MANAGER	306
#define ERROR_INVALID_PCLASS		307
#define ERROR_INVALID_SCOPE		308
#define ERROR_INVALID_THREADID		309
#define ERROR_DOSSUB_SHRINK		310
#define ERROR_DOSSUB_NOMEM		311
#define ERROR_DOSSUB_OVERLAP		312
#define ERROR_DOSSUB_BADSIZE		313
#define ERROR_DOSSUB_BADFLAG		314
#define ERROR_DOSSUB_BADSELECTOR	315
#define ERROR_MR_MSG_TOO_LONG		316
#define ERROR_MR_MID_NOT_FOUND		317
#define ERROR_MR_UN_ACC_MSGF		318
#define ERROR_MR_INV_MSGF_FORMAT	319
#define ERROR_MR_INV_IVCOUNT		320
#define ERROR_MR_UN_PERFORM		321
#define ERROR_TS_WAKEUP 		322
#define ERROR_TS_SEMHANDLE		323
#define ERROR_TS_NOTIMER		324
#define ERROR_TS_HANDLE 		326
#define ERROR_TS_DATETIME		327
#define ERROR_SYS_INTERNAL		328
#define ERROR_QUE_CURRENT_NAME		329
#define ERROR_QUE_PROC_NOT_OWNED	330
#define ERROR_QUE_PROC_OWNED		331
#define ERROR_QUE_DUPLICATE		332
#define ERROR_QUE_ELEMENT_NOT_EXIST	333
#define ERROR_QUE_NO_MEMORY		334
#define ERROR_QUE_INVALID_NAME		335
#define ERROR_QUE_INVALID_PRIORITY	336
#define ERROR_QUE_INVALID_HANDLE	337
#define ERROR_QUE_LINK_NOT_FOUND	338
#define ERROR_QUE_MEMORY_ERROR		339
#define ERROR_QUE_PREV_AT_END		340
#define ERROR_QUE_PROC_NO_ACCESS	341
#define ERROR_QUE_EMPTY 		342
#define ERROR_QUE_NAME_NOT_EXIST	343
#define ERROR_QUE_NOT_INITIALIZED	344
#define ERROR_QUE_UNABLE_TO_ACCESS	345
#define ERROR_QUE_UNABLE_TO_ADD 	346
#define ERROR_QUE_UNABLE_TO_INIT	347
#define ERROR_VIO_INVALID_MASK		349
#define ERROR_VIO_PTR			350
#define ERROR_VIO_APTR			351
#define ERROR_VIO_RPTR			352
#define ERROR_VIO_CPTR			353
#define ERROR_VIO_LPTR			354
#define ERROR_VIO_MODE			355
#define ERROR_VIO_WIDTH 		356
#define ERROR_VIO_ATTR			357
#define ERROR_VIO_ROW			358
#define ERROR_VIO_COL			359
#define ERROR_VIO_TOPROW		360
#define ERROR_VIO_BOTROW		361
#define ERROR_VIO_RIGHTCOL		362
#define ERROR_VIO_LEFTCOL		363
#define ERROR_SCS_CALL			364
#define ERROR_SCS_VALUE 		365
#define ERROR_VIO_WAIT_FLAG		366
#define ERROR_VIO_UNLOCK		367
#define ERROR_SGS_NOT_SESSION_MGR	368
#define ERROR_SMG_INVALID_SGID		369
#define ERROR_SMG_INVALID_SESSION_ID	369
#define ERROR_SMG_NOSG			370
#define ERROR_SMG_NO_SESSIONS		370
#define ERROR_SMG_GRP_NOT_FOUND 	371
#define ERROR_SMG_SESSION_NOT_FOUND	371
#define ERROR_SMG_SET_TITLE		372
#define ERROR_KBD_PARAMETER		373
#define ERROR_KBD_NO_DEVICE		374
#define ERROR_KBD_INVALID_IOWAIT	375
#define ERROR_KBD_INVALID_LENGTH	376
#define ERROR_KBD_INVALID_ECHO_MASK	377
#define ERROR_KBD_INVALID_INPUT_MASK	378
#define ERROR_MON_INVALID_PARMS 	379
#define ERROR_MON_INVALID_DEVNAME	380
#define ERROR_MON_INVALID_HANDLE	381
#define ERROR_MON_BUFFER_TOO_SMALL	382
#define ERROR_MON_BUFFER_EMPTY		383
#define ERROR_MON_DATA_TOO_LARGE	384
#define ERROR_MOUSE_NO_DEVICE		385
#define ERROR_MOUSE_INV_HANDLE		386
#define ERROR_MOUSE_INV_PARMS		387
#define ERROR_MOUSE_CANT_RESET		388
#define ERROR_MOUSE_DISPLAY_PARMS	389
#define ERROR_MOUSE_INV_MODULE		390
#define ERROR_MOUSE_INV_ENTRY_PT	391
#define ERROR_MOUSE_INV_MASK		392
#define NO_ERROR_MOUSE_NO_DATA		393
#define NO_ERROR_MOUSE_PTR_DRAWN	394
#define ERROR_INVALID_FREQUENCY 	395
#define ERROR_NLS_NO_COUNTRY_FILE	396
#define ERROR_NLS_OPEN_FAILED		397
#define ERROR_NLS_NO_CTRY_CODE		398
#define ERROR_NO_COUNTRY_OR_CODEPAGE	398
#define ERROR_NLS_TABLE_TRUNCATED	399
#define ERROR_NLS_BAD_TYPE		400
#define ERROR_NLS_TYPE_NOT_FOUND	401
#define ERROR_VIO_SMG_ONLY		402
#define ERROR_VIO_INVALID_ASCIIZ	403
#define ERROR_VIO_DEREGISTER		404
#define ERROR_VIO_NO_POPUP		405
#define ERROR_VIO_EXISTING_POPUP	406
#define ERROR_KBD_SMG_ONLY		407
#define ERROR_KBD_INVALID_ASCIIZ	408
#define ERROR_KBD_INVALID_MASK		409
#define ERROR_KBD_REGISTER		410
#define ERROR_KBD_DEREGISTER		411
#define ERROR_MOUSE_SMG_ONLY		412
#define ERROR_MOUSE_INVALID_ASCIIZ	413
#define ERROR_MOUSE_INVALID_MASK	414
#define ERROR_MOUSE_REGISTER		415
#define ERROR_MOUSE_DEREGISTER		416
#define ERROR_SMG_BAD_ACTION		417
#define ERROR_SMG_INVALID_CALL		418
#define ERROR_SCS_SG_NOTFOUND		419
#define ERROR_SCS_NOT_SHELL		420
#define ERROR_VIO_INVALID_PARMS 	421
#define ERROR_VIO_FUNCTION_OWNED	422
#define ERROR_VIO_RETURN		423
#define ERROR_SCS_INVALID_FUNCTION	424
#define ERROR_SCS_NOT_SESSION_MGR	425
#define ERROR_VIO_REGISTER		426
#define ERROR_VIO_NO_MODE_THREAD	427
#define ERROR_VIO_NO_SAVE_RESTORE_THD	428
#define ERROR_VIO_IN_BG 		429
#define ERROR_VIO_ILLEGAL_DURING_POPUP	430
#define ERROR_SMG_NOT_BASESHELL 	431
#define ERROR_SMG_BAD_STATUSREQ 	432
#define ERROR_QUE_INVALID_WAIT		433
#define ERROR_VIO_LOCK			434
#define ERROR_MOUSE_INVALID_IOWAIT	435
#define ERROR_VIO_INVALID_HANDLE	436
#define ERROR_VIO_ILLEGAL_DURING_LOCK	437
#define ERROR_VIO_INVALID_LENGTH	438
#define ERROR_KBD_INVALID_HANDLE	439
#define ERROR_KBD_NO_MORE_HANDLE	440
#define ERROR_KBD_CANNOT_CREATE_KCB	441
#define ERROR_KBD_CODEPAGE_LOAD_INCOMPL 442
#define ERROR_KBD_INVALID_CODEPAGE_ID	443
#define ERROR_KBD_NO_CODEPAGE_SUPPORT	444
#define ERROR_KBD_FOCUS_REQUIRED	445
#define ERROR_KBD_FOCUS_ALREADY_ACTIVE	446
#define ERROR_KBD_KEYBOARD_BUSY 	447
#define ERROR_KBD_INVALID_CODEPAGE	448
#define ERROR_KBD_UNABLE_TO_FOCUS	449
#define ERROR_SMG_SESSION_NON_SELECT	450
#define ERROR_SMG_SESSION_NOT_FOREGRND	451
#define ERROR_SMG_SESSION_NOT_PARENT	452
#define ERROR_SMG_INVALID_START_MODE	453
#define ERROR_SMG_INVALID_RELATED_OPT	454
#define ERROR_SMG_INVALID_BOND_OPTION	455
#define ERROR_SMG_INVALID_SELECT_OPT	456
#define ERROR_SMG_START_IN_BACKGROUND	457
#define ERROR_SMG_INVALID_STOP_OPTION	458
#define ERROR_SMG_BAD_RESERVE		459
#define ERROR_SMG_PROCESS_NOT_PARENT	460
#define ERROR_SMG_INVALID_DATA_LENGTH	461
#define ERROR_SMG_NOT_BOUND		462
#define ERROR_SMG_RETRY_SUB_ALLOC	463
#define ERROR_KBD_DETACHED		464
#define ERROR_VIO_DETACHED		465
#define ERROR_MOU_DETACHED		466
#define ERROR_VIO_FONT			467
#define ERROR_VIO_USER_FONT		468
#define ERROR_VIO_BAD_CP		469
#define ERROR_VIO_NO_CP 		470
#define ERROR_VIO_NA_CP 		471
#define ERROR_INVALID_CODE_PAGE 	472
#define ERROR_CPLIST_TOO_SMALL		473
#define ERROR_CP_NOT_MOVED		474
#define ERROR_MODE_SWITCH_INIT		475
#define ERROR_CODE_PAGE_NOT_FOUND	476
#define ERROR_UNEXPECTED_SLOT_RETURNED	477
#define ERROR_SMG_INVALID_TRACE_OPTION	478
#define ERROR_VIO_INTERNAL_RESOURCE	479
#define ERROR_VIO_SHELL_INIT		480
#define ERROR_SMG_NO_HARD_ERRORS	481
#define ERROR_CP_SWITCH_INCOMPLETE	482
#define ERROR_VIO_TRANSPARENT_POPUP	483
#define ERROR_CRITSEC_OVERFLOW		484
#define ERROR_CRITSEC_UNDERFLOW 	485
#define ERROR_VIO_BAD_RESERVE		486
#define ERROR_INVALID_ADDRESS		487
#define ERROR_ZERO_SELECTORS_REQUESTED	488
#define ERROR_NOT_ENOUGH_SELECTORS_AVA	489
#define ERROR_INVALID_SELECTOR		490
#define ERROR_SMG_INVALID_PROGRAM_TYPE	491
#define ERROR_SMG_INVALID_PGM_CONTROL	492
#define ERROR_SMG_INVALID_INHERIT_OPT	493
#define ERROR_VIO_EXTENDED_SG		494
#define ERROR_VIO_NOT_PRES_MGR_SG	495
#define ERROR_VIO_SHIELD_OWNED		496
#define ERROR_VIO_NO_MORE_HANDLES	497
#define ERROR_VIO_SEE_ERROR_LOG 	498
#define ERROR_VIO_ASSOCIATED_DC 	499
#define ERROR_KBD_NO_CONSOLE		500
#define ERROR_MOUSE_NO_CONSOLE		501
#define ERROR_MOUSE_INVALID_HANDLE	502
#define ERROR_SMG_INVALID_DEBUG_PARMS	503
#define ERROR_KBD_EXTENDED_SG		504
#define ERROR_MOU_EXTENDED_SG		505
#define ERROR_SMG_INVALID_ICON_FILE	506


#define ERROR_USER_DEFINED_BASE 	0xFF00

#define ERROR_I24_WRITE_PROTECT 	0
#define ERROR_I24_BAD_UNIT		1
#define ERROR_I24_NOT_READY		2
#define ERROR_I24_BAD_COMMAND		3
#define ERROR_I24_CRC			4
#define ERROR_I24_BAD_LENGTH		5
#define ERROR_I24_SEEK			6
#define ERROR_I24_NOT_DOS_DISK		7
#define ERROR_I24_SECTOR_NOT_FOUND	8
#define ERROR_I24_OUT_OF_PAPER		9
#define ERROR_I24_WRITE_FAULT		10
#define ERROR_I24_READ_FAULT		11
#define ERROR_I24_GEN_FAILURE		12
#define ERROR_I24_DISK_CHANGE		13
#define ERROR_I24_WRONG_DISK		15
#define ERROR_I24_UNCERTAIN_MEDIA	16
#define ERROR_I24_CHAR_CALL_INTERRUPTED 17
#define ERROR_I24_NO_MONITOR_SUPPORT	18
#define ERROR_I24_INVALID_PARAMETER	19
#define ERROR_I24_DEVICE_IN_USE 	20

#define ALLOWED_FAIL			0x0001
#define ALLOWED_ABORT			0x0002
#define ALLOWED_RETRY			0x0004
#define ALLOWED_IGNORE			0x0008
#define ALLOWED_ACKNOWLEDGE		0x0010
#define ALLOWED_DISPATCH		0x8000

#define I24_OPERATION			0x01
#define I24_AREA			0x06
#define I24_CLASS			0x80

/* Values for error CLASS */
#define ERRCLASS_OUTRES 		1   /* Out of Resource		      */
#define ERRCLASS_TEMPSIT		2   /* Temporary Situation	      */
#define ERRCLASS_AUTH			3   /* Permission problem	      */
#define ERRCLASS_INTRN			4   /* Internal System Error	      */
#define ERRCLASS_HRDFAIL		5   /* Hardware Failure 	      */
#define ERRCLASS_SYSFAIL		6   /* System Failure		      */
#define ERRCLASS_APPERR 		7   /* Application Error	      */
#define ERRCLASS_NOTFND 		8   /* Not Found		      */
#define ERRCLASS_BADFMT 		9   /* Bad Format		      */
#define ERRCLASS_LOCKED 		10  /* Locked			      */
#define ERRCLASS_MEDIA			11  /* Media Failure		      */
#define ERRCLASS_ALREADY		12  /* Collision with Existing Item   */
#define ERRCLASS_UNK			13  /* Unknown/other		      */
#define ERRCLASS_CANT			14
#define ERRCLASS_TIME			15

/* Values for error ACTION */
#define ERRACT_RETRY			1   /* Retry			      */
#define ERRACT_DLYRET			2   /* Delay Retry, retry after pause */
#define ERRACT_USER			3   /* Ask user to regive information */
#define ERRACT_ABORT			4   /* abort with clean up	      */
#define ERRACT_PANIC			5   /* abort immediately	      */
#define ERRACT_IGNORE			6   /* ignore			      */
#define ERRACT_INTRET			7   /* Retry after User Intervention  */

/* Values for error LOCUS */
#define ERRLOC_UNK			1   /* No appropriate value	      */
#define ERRLOC_DISK			2   /* Random Access Mass Storage     */
#define ERRLOC_NET			3   /* Network			      */
#define ERRLOC_SERDEV			4   /* Serial Device		      */
#define ERRLOC_MEM			5   /* Memory			      */

/* Abnormal termination codes */
#define TC_NORMAL		0
#define TC_HARDERR		1
#define TC_GP_TRAP		2
#define TC_SIGNAL		3

#define ERROR_SWAPPER_NOT_ACTIVE	32768
#define ERROR_INVALID_SWAPID		32769
#define ERROR_IOERR_SWAP_FILE		32770
#define ERROR_SWAP_TABLE_FULL		32771
#define ERROR_SWAP_FILE_FULL		32772
#define ERROR_CANT_INIT_SWAPPER 	32773
#define ERROR_SWAPPER_ALREADY_INIT	32774
#define ERROR_PMM_INSUFFICIENT_MEMORY	32775
#define ERROR_PMM_INVALID_FLAGS 	32776
#define ERROR_PMM_INVALID_ADDRESS	32777
#define ERROR_PMM_LOCK_FAILED		32778
#define ERROR_PMM_UNLOCK_FAILED 	32779
#define ERROR_PMM_MOVE_INCOMPLETE	32780
#define ERROR_UCOM_DRIVE_RENAMED	32781
#define ERROR_UCOM_FILENAME_TRUNCATED	32782
#define ERROR_UCOM_BUFFER_LENGTH	32783
#define ERROR_MON_CHAIN_HANDLE		32784
#define ERROR_MON_NOT_REGISTERED	32785
#define ERROR_SMG_ALREADY_TOP		32786
#define ERROR_PMM_ARENA_MODIFIED	32787
#define ERROR_SMG_PRINTER_OPEN		32788
#define ERROR_PMM_SET_FLAGS_FAILED	32789
#define ERROR_INVALID_DOS_DD		32790
#define ERROR_CPSIO_CODE_PAGE_INVALID	65026
#define ERROR_CPSIO_NO_SPOOLER		65027
#define ERROR_CPSIO_FONT_ID_INVALID	65028
#define ERROR_CPSIO_INTERNAL_ERROR	65033
#define ERROR_CPSIO_INVALID_PTR_NAME	65034
#define ERROR_CPSIO_NOT_ACTIVE		65037
#define ERROR_CPSIO_PID_FULL		65039
#define ERROR_CPSIO_PID_NOT_FOUND	65040
#define ERROR_CPSIO_READ_CTL_SEQ	65043
#define ERROR_CPSIO_READ_FNT_DEF	65045
#define ERROR_CPSIO_WRITE_ERROR 	65047
#define ERROR_CPSIO_WRITE_FULL_ERROR	65048
#define ERROR_CPSIO_WRITE_HANDLE_BAD	65049
#define ERROR_CPSIO_SWIT_LOAD		65074
#define ERROR_CPSIO_INV_COMMAND 	65077
#define ERROR_CPSIO_NO_FONT_SWIT	65078

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\lfn.c ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    lfn.c

Abstract:

    Provides entry points for the Long Name Functions from Win3.1
    Network provider design. 

    All functions return WN_NOT_SUPPORTED

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/

#include <windows.h>
#include <locals.h>


WORD API LFNFindFirst(LPSTR p1,
                      WORD p2,
                      LPINT p3,
                      LPINT p4,
                      WORD p5,
                      PFILEFINDBUF2 p6)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    UNREFERENCED(p5) ;
    UNREFERENCED(p6) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNFindNext(HANDLE p1,
                     LPINT p2,
                     WORD p3,
                     PFILEFINDBUF2 p4)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNFindClose(HANDLE p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNGetAttributes(LPSTR p1,
                          LPINT p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNSetAttributes(LPSTR p1,
                          WORD p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNCopy(LPSTR p1,
                 LPSTR p2,
                 PQUERYPROC p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNMove(LPSTR p1,
                 LPSTR p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNDelete(LPSTR p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNMKDir(LPSTR p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNRMDir(LPSTR p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNGetVolumeLabel(WORD p1,
                           LPSTR p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNSetVolumeLabel(WORD p1,
                           LPSTR p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNParse(LPSTR p1,
                  LPSTR p2,
                  LPSTR p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNVolumeType(WORD p1,
                       LPINT p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\print.c ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Provides entry points for the Print Functions from Win3.1
    Network provider design. 

    All functions are obsolete. They either return WN_NOT_SUPPORTED
    or FALSE.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>


void API WNetPrintMgrSelNotify (BYTE p1,
                                LPQS2 p2,
                                LPQS2 p3,
	                        LPJOBSTRUCT2 p4,
                                LPJOBSTRUCT2 p5,
                                LPWORD p6,
                                LPSTR p7,
                                WORD p8)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    UNREFERENCED(p5) ;
    UNREFERENCED(p6) ;
    UNREFERENCED(p7) ;
    UNREFERENCED(p8) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return ;
}

WNETERR API WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	                             LPSTR lpBuffer, 
                                     LPWORD pcbBuffer, 
                                     LPWORD cAvail, 
                                     WORD usLevel)
{
    UNREFERENCED(lpszQueueName) ;
    UNREFERENCED(lpBuffer) ;
    UNREFERENCED(pcbBuffer) ;
    UNREFERENCED(cAvail) ;
    UNREFERENCED(usLevel) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WNETERR API WNetPrintMgrChangeMenus(HWND p1,
                                    HANDLE FAR *p2,
                                    BOOL FAR *p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WNETERR API WNetPrintMgrCommand (HWND p1,
                                 WORD p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

void API WNetPrintMgrExiting (void)
{
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return ;
}

BOOL API WNetPrintMgrExtHelp (DWORD p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return FALSE ;
}

WORD API WNetPrintMgrMoveJob (HWND p1,
                              LPSTR p2,
                              WORD p3, 
                              int p4)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return 0 ;
}

void API WNetPrintMgrStatusChange (LPSTR lpszQueueName,
	                           LPSTR lpszPortName, 
                                   WORD wQueueStatus, 
                                   WORD cJobsLeft, 
                                   HANDLE hJCB,
	                           BOOL fDeleted)
{
    UNREFERENCED(lpszQueueName) ;
    UNREFERENCED(lpszPortName) ;
    UNREFERENCED(wQueueStatus) ;
    UNREFERENCED(cJobsLeft) ; 
    UNREFERENCED(hJCB) ;
    UNREFERENCED(fDeleted) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\misc.c ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    Provides entry points for miscellaneous functions to match the WFW3.1
    Network provider, 

    The majority of the functions are either no longer supported, or
    call thru to other functions. 

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>


WORD API WNetExitConfirm(HWND hwndOwner, 
                         WORD iExitType)
{
    UNREFERENCED(hwndOwner) ;
    UNREFERENCED(hwndOwner) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

BOOL API I_AutoLogon(HWND hwndOwner, 
                     LPSTR lpszReserved,
                     BOOL fPrompt,  
                     BOOL FAR *lpfLoggedOn)
{
    UNREFERENCED(hwndOwner) ;
    UNREFERENCED(lpszReserved) ;
    UNREFERENCED(fPrompt) ;
    UNREFERENCED(lpfLoggedOn) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return FALSE ;
}

BOOL API I_Logoff(HWND hwndOwner, 
                  LPSTR lpszReserved)
{
    UNREFERENCED(hwndOwner) ;
    UNREFERENCED(lpszReserved) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return FALSE ;
}

VOID API I_ChangePassword(HWND hwndOwner)
{
    UNREFERENCED(hwndOwner) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
}

VOID API I_ChangeCachePassword(HWND hwndOwner)
{
    UNREFERENCED(hwndOwner) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
}

WORD API I_ConnectDialog(HWND hwndParent, 
                         WORD iType)
{
    return WNetConnectDialog(hwndParent, iType) ;
}

WORD API I_ConnectionDialog(HWND hwndParent,
                            WORD iType)
{
    return WNetConnectDialog(hwndParent, iType) ;
}

WORD API WNetCachePassword(LPSTR pbResource, 
                           WORD cbResource,
                           LPSTR pbPassword,  
                           WORD cbPassword,
                           BYTE nType)
{
    UNREFERENCED(pbResource) ;
    UNREFERENCED(cbResource) ;
    UNREFERENCED(pbPassword) ;
    UNREFERENCED(cbPassword) ;
    UNREFERENCED(nType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetCachedPassword(LPSTR pbResource, 
                               WORD cbResource,
                               LPSTR pbPassword, 
                               LPWORD pcbPassword,
                               BYTE nType)
{
    UNREFERENCED(pbResource) ;
    UNREFERENCED(cbResource) ;
    UNREFERENCED(pbPassword) ;
    UNREFERENCED(pcbPassword) ;
    UNREFERENCED(nType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}


WORD API WNetRemoveCachedPassword(LPSTR pbResource,
                                  WORD cbResource,
                                  BYTE nType)
{
    UNREFERENCED(pbResource) ;
    UNREFERENCED(cbResource) ;
    UNREFERENCED(nType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetEnumCachedPasswords(LPSTR pbPrefix, 
                                 WORD cbPrefix,
                                 BYTE nType,
                                 CACHECALLBACK pfnCallback)
{
    UNREFERENCED(pbPrefix) ;
    UNREFERENCED(cbPrefix) ;
    UNREFERENCED(nType) ;
    UNREFERENCED(pfnCallback) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetSharesDialog(HWND hwndParent, 
                          WORD iType)
{
    UNREFERENCED(hwndParent) ;
    UNREFERENCED(iType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetSetDefaultDrive(WORD idriveDefault)
{
    UNREFERENCED(idriveDefault) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetShareCount(WORD iType)
{
    UNREFERENCED(iType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetShareName(LPSTR lpszPath, 
                          LPSTR lpszBuf,
                          WORD cbBuf)
{
    UNREFERENCED(lpszPath) ;
    UNREFERENCED(lpszBuf) ;
    UNREFERENCED(cbBuf) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetSharePath(LPSTR lpszName, 
                          LPSTR lpszBuf,
                          WORD cbBuf)
{
    UNREFERENCED(lpszName) ;
    UNREFERENCED(lpszBuf) ;
    UNREFERENCED(cbBuf) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetLastConnection(WORD iType, 
                               LPWORD lpwConnIndex)
{
    UNREFERENCED(iType) ;
    UNREFERENCED(lpwConnIndex) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetError(LPINT p1)
{
    WORD err ;
    WORD wLastErr ;

    /*
     * fake the last error capabilty. if last thing we talked to was Win32,
     * the get the information from 32 bit system. ditto if it was a Win16
     * call.
     */
    if (vLastCall == LAST_CALL_IS_WIN32)
    {
        err = (WORD) GetLastError32() ; 
        return err ;
    }
    else if (vLastCall == LAST_CALL_IS_LANMAN_DRV)
    {
        err = WNetGetError16(&wLastErr) ;
        if (err != WN_SUCCESS)
            return err ;
        else
            return wLastErr ;
    }
    else  
    {
        return(vLastError) ;
    }
}

WORD API WNetGetErrorText(WORD p1,LPSTR p2,LPINT p3)
{
    if (vLastCall == LAST_CALL_IS_WIN32)
    {
        *p2 = 0 ;
        *p3 = 0 ;
        return WN_NOT_SUPPORTED ;
    }
    else  // use whatever lanman.drv gives us
    {
        return (WNetGetErrorText16(p1, p2, p3)) ;
    }
}

WORD API WNetErrorText(WORD p1,LPSTR p2,WORD p3)
{
    WORD cbBuffer = p3 ;

    return (WNetGetErrorText(p1, p2, &cbBuffer) == 0) ;
}

/*
 * misc startup/shutdown routines. nothing interesting
 */

VOID FAR PASCAL Enable(VOID) 
{
    return ;
}

VOID FAR PASCAL Disable(VOID) 
{
    return ;
}

int far pascal WEP()
{
    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\libentry.asm ===
; LIBENTRY.ASM -- Entry point for library modules (small model)
; -------------------------------------------------------------

        Extrn   LibMain:Near

_TEXT   SEGMENT BYTE PUBLIC 'CODE'
        ASSUME  CS:_TEXT
        PUBLIC  LibEntry

LibEntry        proc    far
        push    di
        push    ds
        push    cx
        push    es
        push    si

        call    LibMain

        ret
LibEntry        endp

_TEXT   ENDS

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\wfwnet.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    wfwnet.c

Abstract:

    Provides entry points for the functions that will be mapped
    to LANMAN.DRV.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>

WORD vLastCall = LAST_CALL_IS_LOCAL ;
WORD vLastError = 0 ;

WORD    wNetTypeCaps ;           /* Current capabilities */
WORD    wUserCaps ;
WORD    wConnectionCaps ;
WORD    wErrorCaps ;
WORD    wDialogCaps ;
WORD    wAdminCaps ;
WORD    wSpecVersion = 0x0310 ;
WORD    wDriverVersion = 0x0300 ;
WORD _acrtused=0;

void I_SetCapBits(void) ;

//
// global pointers to functions
//
LPWNETOPENJOB                lpfnWNetOpenJob = NULL ;
LPWNETCLOSEJOB               lpfnWNetCloseJob = NULL ;
LPWNETWRITEJOB               lpfnWNetWriteJob = NULL ;
LPWNETABORTJOB               lpfnWNetAbortJob = NULL ;
LPWNETHOLDJOB                lpfnWNetHoldJob = NULL ;
LPWNETRELEASEJOB             lpfnWNetReleaseJob = NULL ;
LPWNETCANCELJOB              lpfnWNetCancelJob = NULL ;
LPWNETSETJOBCOPIES           lpfnWNetSetJobCopies = NULL ;
LPWNETWATCHQUEUE             lpfnWNetWatchQueue = NULL ;
LPWNETUNWATCHQUEUE           lpfnWNetUnwatchQueue = NULL ;
LPWNETLOCKQUEUEDATA          lpfnWNetLockQueueData = NULL ;
LPWNETUNLOCKQUEUEDATA        lpfnWNetUnlockQueueData = NULL ;
LPWNETQPOLL                  lpfnWNetQPoll = NULL ;
LPWNETDEVICEMODE             lpfnWNetDeviceMode = NULL ;
LPWNETVIEWQUEUEDIALOG        lpfnWNetViewQueueDialog = NULL ;
LPWNETGETCAPS                lpfnWNetGetCaps16 = NULL ;
LPWNETGETERROR               lpfnWNetGetError16 = NULL ;
LPWNETGETERRORTEXT           lpfnWNetGetErrorText16 = NULL ;

extern VOID FAR PASCAL GrabInterrupts(void);

int FAR PASCAL LibMain(HINSTANCE hInstance,
                       WORD      wDataSeg,
                       WORD      cbHeapSize,
                       LPSTR     lpszCmdLine) ;

/*
 * functions passed to LANMAN.DRV
 */

WORD API WNetOpenJob(LPSTR p1,LPSTR p2,WORD p3,LPINT p4)
{
    WORD err ;

    if (!lpfnWNetOpenJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetOpenJob,
                                       "WNETOPENJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetOpenJob)(p1,p2,p3,p4) ) ;
}

WORD API WNetCloseJob(WORD p1,LPINT p2,LPSTR p3)
{
    WORD err ;

    if (!lpfnWNetCloseJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetCloseJob,
                                       "WNETCLOSEJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetCloseJob)(p1,p2,p3) ) ;
}

WORD API WNetWriteJob(HANDLE p1,LPSTR p2,LPINT p3)
{
    WORD err ;

    if (!lpfnWNetWriteJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetWriteJob,
                                       "WNETWRITEJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetWriteJob)(p1,p2,p3) ) ;
}

WORD API WNetAbortJob(WORD p1,LPSTR p2)
{
    WORD err ;

    if (!lpfnWNetAbortJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetAbortJob,
                                       "WNETABORTJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetAbortJob)(p1,p2) ) ;
}

WORD API WNetHoldJob(LPSTR p1,WORD p2)
{
    WORD err ;

    if (!lpfnWNetHoldJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetHoldJob,
                                       "WNETHOLDJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetHoldJob)(p1,p2) ) ;
}

WORD API WNetReleaseJob(LPSTR p1,WORD p2)
{
    WORD err ;

    if (!lpfnWNetReleaseJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetReleaseJob,
                                       "WNETRELEASEJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetReleaseJob)(p1,p2) ) ;
}

WORD API WNetCancelJob(LPSTR p1,WORD p2)
{
    WORD err ;

    if (!lpfnWNetCancelJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetCancelJob,
                                       "WNETCANCELJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetCancelJob)(p1,p2) ) ;
}

WORD API WNetSetJobCopies(LPSTR p1,WORD p2,WORD p3)
{
    WORD err ;

    if (!lpfnWNetSetJobCopies)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetSetJobCopies,
                                       "WNETSETJOBCOPIES" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetSetJobCopies)(p1,p2,p3) ) ;
}

WORD API WNetWatchQueue(HWND p1,LPSTR p2,LPSTR p3,WORD p4)
{
    WORD err ;

    if (!lpfnWNetWatchQueue)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetWatchQueue,
                                       "WNETWATCHQUEUE" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetWatchQueue)(p1,p2,p3,p4) ) ;
}

WORD API WNetUnwatchQueue(LPSTR p1)
{
    WORD err ;

    if (!lpfnWNetUnwatchQueue)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetUnwatchQueue,
                                       "WNETUNWATCHQUEUE" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetUnwatchQueue)(p1) ) ;
}

WORD API WNetLockQueueData(LPSTR p1,LPSTR p2,LPQUEUESTRUCT FAR *p3)
{
    WORD err ;

    if (!lpfnWNetLockQueueData)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetLockQueueData,
                                       "WNETLOCKQUEUEDATA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetLockQueueData)(p1,p2,p3) ) ;
}

WORD API WNetUnlockQueueData(LPSTR p1)
{
    WORD err ;

    if (!lpfnWNetUnlockQueueData)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetUnlockQueueData,
                                       "WNETUNLOCKQUEUEDATA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetUnlockQueueData)(p1) ) ;
}

void API WNetQPoll(HWND hWnd, unsigned iMessage, WORD wParam, LONG lParam)
{
    WORD err ;

    if (!lpfnWNetQPoll)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetQPoll,
                                       "WNETQPOLL" ) ;
        if (err)
        {
            SetLastError(err) ;
            return ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    (*lpfnWNetQPoll)(hWnd, iMessage, wParam, lParam) ;
}

WORD API WNetDeviceMode(HWND p1)
{
    WORD err ;

    if (!lpfnWNetDeviceMode)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetDeviceMode,
                                       "WNETDEVICEMODE" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetDeviceMode)(p1) ) ;
}

WORD API WNetViewQueueDialog(HWND p1,LPSTR p2)
{
    WORD err ;

    if (!lpfnWNetViewQueueDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetViewQueueDialog,
                                       "WNETVIEWQUEUEDIALOG" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetViewQueueDialog)(p1,p2) ) ;
}

WORD API WNetGetCaps16(WORD p1)
{
    WORD err ;

    if (!lpfnWNetGetCaps16)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetGetCaps16,
                                       "WNETGETCAPS" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetGetCaps16)(p1) ) ;
}

WORD API WNetGetError16(LPINT p1)
{
    WORD err ;

    if (!lpfnWNetGetError16)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetGetError16,
                                       "WNETGETERROR" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetGetError16)(p1) ) ;
}

WORD API WNetGetErrorText16(WORD p1, LPSTR p2, LPINT p3)
{
    WORD err ;

    if (!lpfnWNetGetErrorText16)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetGetErrorText16,
                                       "WNETGETERRORTEXT" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetGetErrorText16)(p1,p2,p3) ) ;
}

WORD API WNetGetCaps(WORD nIndex)
{
    switch (nIndex)
    {
    case WNNC_SPEC_VERSION:
	return  wSpecVersion;

    case WNNC_NET_TYPE:
	return  wNetTypeCaps;

    case WNNC_DRIVER_VERSION:
	return  wDriverVersion;

    case WNNC_USER:
	return  wUserCaps;

    case WNNC_CONNECTION:
	return  wConnectionCaps;

    case WNNC_PRINTING:
	return  (WNetGetCaps16(nIndex)) ;

    case WNNC_DIALOG:
	return  wDialogCaps;

    case WNNC_ADMIN:
	return  wAdminCaps;

    case WNNC_ERROR:
	return  wErrorCaps;

    default:
	return  0;
    }
}

/*
 * misc support functions
 */

/*******************************************************************

    NAME:	GetLanmanDrvEntryPoints

    SYNOPSIS:   gets the address of the named procedure
                from LANMAN.DRV, will load library if first time.

    ENTRY:      lplpfn - used to receive the address
                lpName - name of the procedure

    EXIT:

    RETURNS:    0 if success, error code otherwise.

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD GetLanmanDrvEntryPoints(LPFN *lplpfn, LPSTR lpName)
{
    static HINSTANCE hModule = NULL ;

    //
    // if we havent loaded it, load it now
    //
    if (hModule == NULL)
    {
        hModule = LoadLibrary(LANMAN_DRV) ;
        if (hModule == NULL)
            return WN_NOT_SUPPORTED ;
    }

    //
    // get the procedure
    //
    *lplpfn = (LPFN) GetProcAddress(hModule, lpName) ;
    if (! *lplpfn )
            return WN_NOT_SUPPORTED ;

    return NO_ERROR ;
}

/*******************************************************************

    NAME:	SetLastError

    SYNOPSIS:   makes note of last error

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD SetLastError(WORD err)
{
    vLastError = err ;
    return err ;
}

/*******************************************************************

    NAME:	LibMain

    SYNOPSIS:   dll init entry point. only thing we do here is init
                the capability bits.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/

#define NETWARE_DLL    "NETWARE.DRV"

int FAR PASCAL LibMain(HINSTANCE hInstance,
                       WORD      wDataSeg,
                       WORD      cbHeapSize,
                       LPSTR     lpszCmdLine)
{
    OFSTRUCT ofStruct ;
    int fh ;
    BOOL fLoadNetware = FALSE ;
    char IsInstalledString[16] ;

    UNREFERENCED(hInstance) ;
    UNREFERENCED(wDataSeg) ;
    UNREFERENCED(cbHeapSize) ;
    UNREFERENCED(lpszCmdLine) ;

    I_SetCapBits() ;

    if (GetProfileString("NWCS",
                         "NwcsInstalled",
                         "0",
                         IsInstalledString,
                         sizeof(IsInstalledString)))
    {
        fLoadNetware = (lstrcmp("1",IsInstalledString)==0) ;
    }

    //
    // if enhanced mode, grab the interrupt for NWIPXSPX
    //
    if ((GetWinFlags() & WF_ENHANCED) && fLoadNetware) {
        GrabInterrupts();
    }

    //
    // if the file NETWARE.DRV exists, we load it. we dont really
    // use it, but some Netware aware apps require that it is loaded.
    //
    if (fLoadNetware &&
        ((fh = OpenFile(NETWARE_DLL, &ofStruct, OF_READ)) != -1))
    {
        _lclose(fh) ;

        (void)WriteProfileString("Windows",
                                 "NetWarn",
                                 "0") ;

        (void)LoadLibrary(NETWARE_DLL) ;
    }

    return 1 ;
}


/*******************************************************************

    NAME:	I_SetCapBits

    SYNOPSIS:   initernal routine to set the capability bits

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
void I_SetCapBits(void)
{
    wNetTypeCaps    = WNNC_NET_MultiNet |
                      WNNC_SUBNET_WinWorkgroups;

    wUserCaps       = WNNC_USR_GetUser;

    wConnectionCaps =  (WNNC_CON_AddConnection    |
			WNNC_CON_CancelConnection |
			WNNC_CON_GetConnections   |
			WNNC_CON_AutoConnect      |
			WNNC_CON_BrowseDialog     |
			WNNC_CON_RestoreConnection ) ;

    wErrorCaps      = WNNC_ERR_GetError         |
		      WNNC_ERR_GetErrorText;

    wDialogCaps  = (WNNC_DLG_DeviceMode |
                    WNNC_DLG_ShareAsDialog    |
		    WNNC_DLG_PropertyDialog   |
                    WNNC_DLG_ConnectionDialog |
	            WNNC_DLG_ConnectDialog    |
		    WNNC_DLG_DisconnectDialog |
		    WNNC_DLG_BrowseDialog     );

    wAdminCaps      =     ( WNNC_ADM_GetDirectoryType   |
			    WNNC_ADM_DirectoryNotify    ) ;
/* disable LFN for now
                          | WNNC_ADM_LongNames ) ;
 */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wfwnet\to32.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    to32.c

Abstract:

    Provides entry points for the Functions from WFW3.1
    Network provider design which are niw thunked to some
    32 bit equivalent.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>

//
// addresses to 32 bit entry points. note these cannot be
// called directly. CallProc32W must be used,
//
LPVOID lpfnWNetAddConnection = NULL ;
LPVOID lpfnWNetCancelConnection = NULL ;
LPVOID lpfnWNetGetConnection = NULL ;
LPVOID lpfnWNetRestoreConnection = NULL ;
LPVOID lpfnWNetGetUser = NULL ;
LPVOID lpfnWNetBrowseDialog = NULL ;
LPVOID lpfnWNetConnectDialog = NULL ;
LPVOID lpfnWNetDisconnectDialog = NULL ;
LPVOID lpfnWNetConnectionDialog = NULL ;
LPVOID lpfnWNetPropertyDialog = NULL ;
LPVOID lpfnWNetGetPropertyText = NULL ;
LPVOID lpfnWNetShareAsDialog = NULL ;
LPVOID lpfnWNetStopShareDialog = NULL ;
LPVOID lpfnWNetServerBrowseDialog = NULL ;
LPVOID lpfnWNetGetDirectoryType = NULL ;
LPVOID lpfnWNetDirectoryNotify = NULL ;
LPVOID lpfnGetLastError32 = NULL ;
LPVOID lpfnClosePrinter = NULL ;
LPVOID lpfnConnectToPrinter = NULL ;

//
// forward declare
//
WORD Get32BitEntryPoints( LPVOID *lplpfn, DWORD dwDll, LPSTR lpProcName ) ;
WORD API PrintConnectDialog(HWND p1) ;
WORD GetAlignedMemory(LPVOID FAR *pAligned, HANDLE FAR *pHandle, WORD wSize) ;
void FreeAlignedMemory(HANDLE handle) ;

//
// WNetAddConnection thunk to Win32
//
UINT API WNetAddConnection(LPSTR p1,LPSTR p2,LPSTR p3)
{
    WORD err ;
    LPSTR  aligned_p1 = NULL, aligned_p2 = NULL, aligned_p3 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL, handle_p3 = NULL;

    if (p1 == NULL || p3 == NULL)
        return WN_BAD_POINTER ;

    if (p2 && (*p2 == '\0'))
        p2 = NULL ;

    if (!lpfnWNetAddConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetAddConnection,
                                   USE_MPR_DLL,
                                   "WNetAddConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // make copy of parameters so that we are aligned (p1 & p3 wont be NULL)
    //
    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    if (err = GetAlignedMemory(&aligned_p3, &handle_p3, lstrlen(p3)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p3, p3) ;

    if (p2)
    {
        if (err = GetAlignedMemory(&aligned_p2, &handle_p2, lstrlen(p2)+1))
            goto ExitPoint ;
        lstrcpy(aligned_p2, p2) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)aligned_p2,
                                              (DWORD)aligned_p3,
                                              lpfnWNetAddConnection,
                                              (DWORD)7,
                                              (DWORD)3) ) ;
ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    FreeAlignedMemory(handle_p3) ;
    return err ;
}


//
// WNetCancelConnection thunk to Win32
//
UINT API WNetCancelConnection(LPSTR p1,BOOL p2)
{
    WORD err ;
    LPSTR  aligned_p1 = NULL ;
    HANDLE  handle_p1 = NULL ;

    if (p1 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetCancelConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetCancelConnection,
                                   USE_MPR_DLL,
                                   "WNetCancelConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // make copy of parameters so that we are aligned
    //
    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)p2,
                                              (DWORD)lpfnWNetCancelConnection,
                                              (DWORD)2,
                                              (DWORD)2) )  ;
ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    return err ;
}

//
// WNetGetConnection thunk to Win32
//
UINT API WNetGetConnection(LPSTR p1,LPSTR p2, UINT FAR *p3)
{
    WORD err ;
    LPSTR  aligned_p1 = NULL, aligned_p2 = NULL ;
    LPDWORD  aligned_p3 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL, handle_p3 = NULL;

    if (p1 == NULL || p2 == NULL || p3 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetConnection,
                                   USE_MPR_DLL,
                                   "WNetGetConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // make copy of parameters so that we are aligned
    //
    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    if (err = GetAlignedMemory(&aligned_p2, &handle_p2, *p3 ? *p3 : 1))
        goto ExitPoint ;

    if (err = GetAlignedMemory(&aligned_p3, &handle_p3, sizeof(DWORD)))
        goto ExitPoint ;
    *aligned_p3 = *p3 ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)aligned_p2,
                                              (DWORD)aligned_p3,
                                              lpfnWNetGetConnection,
                                              (DWORD)7,
                                              (DWORD)3) ) ;
    lstrcpy(p2, aligned_p2) ;

    if (err == WN_SUCCESS)
        *p3 = lstrlen(p2) + 1;
    else
        *p3 = (UINT)*aligned_p3 ;

ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    FreeAlignedMemory(handle_p3) ;
    return err ;
}

UINT API WNetRestoreConnection(HWND p1,LPSTR p2)
{
    WORD err ;
    LPSTR  aligned_p2 = NULL ;
    HANDLE  handle_p2 = NULL ;

    if (p2 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetRestoreConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetRestoreConnection,
                                   USE_MPRUI_DLL,
                                   "WNetRestoreConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // guard against this weird case from Win3.0 days where -1
    // means something special. NULL is close approximation -> ie all.
    //
    if (p2 == (LPSTR)-1)
        p2 = NULL ;

    if (p2)
    {
        if (err = GetAlignedMemory(&aligned_p2, &handle_p2, lstrlen(p2)+1))
            goto ExitPoint ;
        lstrcpy(aligned_p2, p2) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W((LPVOID)TO_HWND32(p1),
                                              (DWORD)aligned_p2,
                                              (DWORD)lpfnWNetRestoreConnection,
                                              (DWORD)1,
                                              (DWORD)2) ) ;

ExitPoint:

    FreeAlignedMemory(handle_p2) ;
    return err ;
}

WORD API WNetGetUser(LPSTR p1,LPINT p2)
{
    WORD err ;
    LONG lTmp = *p2 ;
    LPSTR  aligned_p1 = NULL ;
    LPINT  aligned_p2 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL ;

    if (p1 == NULL || p2 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetUser)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetUser,
                                   USE_MPR_DLL,
                                   "WNetGetUserA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, *p2))
        goto ExitPoint ;

    if (err = GetAlignedMemory(&aligned_p2, &handle_p2, sizeof(DWORD)))
        goto ExitPoint ;
    *aligned_p2 = *p2 ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(NULL,
                                              (DWORD)aligned_p1,
                                              (DWORD)aligned_p2,
                                              lpfnWNetGetUser,
                                              (DWORD)7,
                                              (DWORD)3) );
    *p2 = (int) *aligned_p2 ;
    lstrcpy(p1, aligned_p1) ;

ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    return err ;
}

WORD API WNetBrowseDialog(HWND p1,WORD p2,LPSTR p3)
{
    WORD err ;
    DWORD dwErr ;
    LPSTR  aligned_p3 = NULL ;
    HANDLE  handle_p3 = NULL ;

    if (p3 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetBrowseDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetBrowseDialog,
                                   USE_MPRUI_DLL,
                                   "BrowseDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note that the WFW API does not let user specify buffer size.
    // we have a tmp buffer, and then copy over. this takes care
    // data alignment, also make sure we dont fault on 32 bit side.
    //
    // the 128 is consistent with what their docs specs the buffer
    // size should be.
    //
    if (err = GetAlignedMemory(&aligned_p3, &handle_p3, 128))
        goto ExitPoint ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = CallProc32W((LPVOID)TO_HWND32(p1),
                        (DWORD)MapWNType16To32(p2),
                        (DWORD)aligned_p3,
                        (DWORD)128,
                        lpfnWNetBrowseDialog,
                        (DWORD)2,
                        (DWORD)4)  ;
    if (dwErr == 0xFFFFFFFF)
        err = WN_CANCEL ;
    else
        err =  MapWin32ErrorToWN16( dwErr ) ;

    if (!err)
        lstrcpy(p3,aligned_p3) ;

ExitPoint:

    FreeAlignedMemory(handle_p3) ;
    return err ;
}

WORD API WNetConnectDialog(HWND p1,WORD p2)
{
    WORD err ;
    DWORD dwErr ;

    if (p2 == WNTYPE_PRINTER)
    {
        err = PrintConnectDialog(p1) ;
        return err ;
    }

    if (!lpfnWNetConnectDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetConnectDialog,
                                   USE_MPR_DLL,
                                   "WNetConnectionDialog" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = CallProc32W( (LPVOID)TO_HWND32(p1),
                         (DWORD)MapWNType16To32(p2),
                         (DWORD)lpfnWNetConnectDialog,
                         (DWORD) 0,
                         (DWORD) 2 )  ;
    if (dwErr == 0xFFFFFFFF)
        err = WN_CANCEL ;
    else
        err =  MapWin32ErrorToWN16( dwErr ) ;
    return err ;
}


WORD API WNetDisconnectDialog(HWND p1,WORD p2)
{
    WORD err ;
    DWORD dwErr ;

    if (!lpfnWNetDisconnectDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetDisconnectDialog,
                                   USE_MPR_DLL,
                                   "WNetDisconnectDialog" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = CallProc32W( (LPVOID)TO_HWND32(p1),
                         (DWORD)MapWNType16To32(p2),
                         (DWORD)lpfnWNetDisconnectDialog,
                         (DWORD) 0,
                         (DWORD) 2 ) ;
    if (dwErr == 0xFFFFFFFF)
        err = WN_CANCEL ;
    else
        err =  MapWin32ErrorToWN16( dwErr ) ;
    return err ;
}

WORD API WNetConnectionDialog(HWND p1,WORD p2)
{
    return (WNetConnectDialog(p1,p2)) ;
}

WORD API PrintConnectDialog(HWND p1)
{
    WORD err ;
    DWORD dwErr ;
    DWORD handle ;

    if (!lpfnClosePrinter)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnClosePrinter,
                                   USE_WINSPOOL_DRV,
                                   "ClosePrinter" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (!lpfnConnectToPrinter)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnConnectToPrinter,
                                   USE_WINSPOOL_DRV,
                                   "ConnectToPrinterDlg" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    err = WN_SUCCESS ;
    vLastCall = LAST_CALL_IS_WIN32 ;
    handle = CallProc32W( (LPVOID)TO_HWND32(p1),
                          (DWORD) 0,
                          (DWORD)lpfnConnectToPrinter,
                          (DWORD) 0,
                          (DWORD) 2 )  ;
    if (handle == 0)
        err = WN_CANCEL ;  // most likely reason
    else
    {
        dwErr = MapWin32ErrorToWN16( CallProc32W((LPVOID)handle,
                                                 (DWORD)lpfnClosePrinter,
                                                 (DWORD)0,
                                                 (DWORD)1) );
        // but ignore the error
    }
    return err ;
}

WORD API WNetPropertyDialog(HWND hwndParent,
                            WORD iButton,
                            WORD nPropSel,
                            LPSTR lpszName,
                            WORD nType)
{
    WORD err ;
    LPSTR  aligned_name = NULL ;
    HANDLE  handle_name = NULL ;

    if (!lpfnWNetPropertyDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetPropertyDialog,
                                   USE_MPR_DLL,
                                   "WNetPropertyDialogA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszName)
    {
        if (err = GetAlignedMemory(&aligned_name,
                                   &handle_name,
                                   lstrlen(lpszName)+1))
            goto ExitPoint ;
        lstrcpy(aligned_name, lpszName) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) iButton,
                                               (DWORD) nPropSel,
                                               (DWORD) aligned_name,
                                               (DWORD) nType,
                                               lpfnWNetPropertyDialog,
                                               (DWORD)2,
                                               (DWORD)5) ) ;
ExitPoint:

    FreeAlignedMemory(handle_name) ;
    return err ;
}

WORD API WNetGetPropertyText(WORD iButton,
                             WORD nPropSel,
                             LPSTR lpszName,
                             LPSTR lpszButtonName,
                             WORD cbButtonName,
                             WORD nType)
{
    WORD err ;
    LPSTR  aligned_name = NULL, aligned_button_name = NULL ;
    HANDLE  handle_name = NULL, handle_button_name = NULL ;

    if (lpszButtonName == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetPropertyText)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetPropertyText,
                                   USE_MPR_DLL,
                                   "WNetGetPropertyTextA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszName)
    {
        if (err = GetAlignedMemory(&aligned_name,
                                   &handle_name,
                                   lstrlen(lpszName)+1))
            goto ExitPoint ;
        lstrcpy(aligned_name, lpszName) ;
    }

    if (err = GetAlignedMemory(&aligned_button_name,
                               &handle_button_name,
                               cbButtonName))
        goto ExitPoint ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)iButton,
                                               (DWORD) nPropSel,
                                               (DWORD) aligned_name,
                                               (DWORD) aligned_button_name,
                                               (DWORD) cbButtonName,
                                               (DWORD) nType,
                                               lpfnWNetGetPropertyText,
                                               (DWORD)12,
                                               (DWORD)6) ) ;
    if (err == WN_SUCCESS)
        lstrcpy(lpszButtonName, aligned_button_name) ;

ExitPoint:

    FreeAlignedMemory(handle_name) ;
    FreeAlignedMemory(handle_button_name) ;
    return err ;
}

WORD API WNetShareAsDialog(HWND hwndParent,
                           WORD iType,
                           LPSTR lpszPath)
{
    WORD err ;
    LPSTR  aligned_path = NULL ;
    HANDLE  handle_path = NULL ;

    if (!lpfnWNetShareAsDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetShareAsDialog,
                                   USE_NTLANMAN_DLL,
                                   "ShareAsDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszPath)
    {
        if (err = GetAlignedMemory(&aligned_path,
                                   &handle_path,
                                   lstrlen(lpszPath)+1))
            goto ExitPoint ;
        lstrcpy(aligned_path, lpszPath) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) MapWNType16To32(iType),
                                               (DWORD) aligned_path,
                                               lpfnWNetShareAsDialog,
                                               (DWORD)1,
                                               (DWORD)3) ) ;
ExitPoint:

    FreeAlignedMemory(handle_path) ;
    return err ;
}

WORD API WNetStopShareDialog(HWND hwndParent,
                             WORD iType,
                             LPSTR lpszPath)
{
    WORD err ;
    LPSTR  aligned_path = NULL ;
    HANDLE  handle_path = NULL ;

    if (!lpfnWNetStopShareDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetStopShareDialog,
                                   USE_NTLANMAN_DLL,
                                   "StopShareDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszPath)
    {
        if (err = GetAlignedMemory(&aligned_path,
                                   &handle_path,
                                   lstrlen(lpszPath)+1))
            goto ExitPoint ;
        lstrcpy(aligned_path, lpszPath) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) MapWNType16To32(iType),
                                               (DWORD) aligned_path,
                                               lpfnWNetStopShareDialog,
                                               (DWORD)1,
                                               (DWORD)3) ) ;
ExitPoint:

    FreeAlignedMemory(handle_path) ;
    return err ;
}

WORD API WNetServerBrowseDialog(HWND hwndParent,
                                LPSTR lpszSectionName,
                                LPSTR lpszBuffer,
                                WORD cbBuffer,
                                DWORD flFlags)
{
    WORD err ;
    LPSTR  aligned_buffer = NULL ;
    HANDLE  handle_buffer = NULL ;

    UNREFERENCED(lpszSectionName) ;
    UNREFERENCED(flFlags) ;

    if (!lpfnWNetServerBrowseDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetServerBrowseDialog,
                                   USE_NTLANMAN_DLL,
                                   "ServerBrowseDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszBuffer)
    {
        if (err = GetAlignedMemory(&aligned_buffer, &handle_buffer, cbBuffer))
            goto ExitPoint ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) aligned_buffer,
                                               (DWORD) cbBuffer,
                                               lpfnWNetServerBrowseDialog,
                                               (DWORD)2,
                                               (DWORD)3) ) ;
    if (err == WN_SUCCESS)
        lstrcpy(lpszBuffer, aligned_buffer) ;

ExitPoint:

    FreeAlignedMemory(handle_buffer) ;
    return err ;
}

WORD API WNetGetDirectoryType(LPSTR p1,LPINT p2)
{
    WORD err ;
    LPSTR   aligned_p1 = NULL ;
    LPDWORD aligned_p2 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL ;

    if (p1 == NULL || p2 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetDirectoryType)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetDirectoryType,
                                   USE_MPR_DLL,
                                   "WNetGetDirectoryTypeA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    if (err = GetAlignedMemory(&aligned_p2, &handle_p2, sizeof(DWORD)))
        goto ExitPoint ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)aligned_p2,
                                              (DWORD)TRUE,
                                              lpfnWNetGetDirectoryType,
                                              (DWORD)6,
                                              (DWORD)3) ) ;
    *p2 = (int) *aligned_p2 ;

ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    return err ;
}

WORD API WNetDirectoryNotify(HWND p1,LPSTR p2,WORD p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    return WN_SUCCESS ;
}

DWORD API GetLastError32(VOID)
{
    WORD err ;
    DWORD dwErr ;

    if (!lpfnGetLastError32)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnGetLastError32,
                                   USE_KERNEL32_DLL,
                                   "GetLastError" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = (UINT) CallProc32W((LPVOID)lpfnGetLastError32,
                               (DWORD)0,
                               (DWORD)0) ;
    return (MapWin32ErrorToWN16(dwErr)) ;
}

/*
 * Misc support routines
 */

/*******************************************************************

    NAME:       Get32BitEntryPoints

    SYNOPSIS:   Get the address of a 32 bit entry point that can
                then be passed to CallProv32W. Will load the library
                if it has not already been loaded.

    ENTRY:      lplpfn     - used to return the address
                dwDll      - which dll to use (see locals.h defintions)
                lpProcName - proc to load

    EXIT:

    RETURNS:    error code

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD Get32BitEntryPoints( LPVOID *lplpfn, DWORD dwDll, LPSTR lpProcName )
{
    static DWORD hmodKernel32 = NULL ;
    static DWORD hmodNTLanman = NULL ;
    static DWORD hmodMpr = NULL ;
    static DWORD hmodMprUI = NULL ;
    static DWORD hmodWinSpool = NULL ;
    DWORD hmod = NULL ;

    //
    // if we havent loaded it appropriate DLL, load it now
    //
    switch (dwDll)
    {
        case USE_MPR_DLL:
            if (hmodMpr == NULL)
            {
                hmodMpr = LoadLibraryEx32W(MPR_DLL, NULL, 0) ;
                if (hmodMpr == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodMpr ;
            break ;

        case USE_MPRUI_DLL:
            if (hmodMprUI == NULL)
            {
                hmodMprUI = LoadLibraryEx32W(MPRUI_DLL, NULL, 0) ;
                if (hmodMprUI == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodMprUI ;
            break ;

        case USE_NTLANMAN_DLL:
            if (hmodNTLanman == NULL)
            {
                hmodNTLanman = LoadLibraryEx32W(NTLANMAN_DLL, NULL, 0) ;
                if (hmodNTLanman == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodNTLanman ;
            break ;

        case USE_KERNEL32_DLL:
            if (hmodKernel32 == NULL)
            {
                hmodKernel32 = LoadLibraryEx32W(KERNEL32_DLL, NULL, 0) ;
                if (hmodKernel32 == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodKernel32 ;
            break ;

        case USE_WINSPOOL_DRV:
            if (hmodWinSpool == NULL)
            {
                hmodWinSpool = LoadLibraryEx32W(WINSPOOL_DRV, NULL, 0) ;
                if (hmodWinSpool == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodWinSpool ;
            break ;

        default:
            return ERROR_GEN_FAILURE ;
    }

    //
    // get the procedure
    //
    *lplpfn = (LPVOID) GetProcAddress32W(hmod, lpProcName) ;
    if (! *lplpfn )
            return WN_NOT_SUPPORTED ;

    return WN_SUCCESS ;
}

/*******************************************************************

    NAME:       MapWNType16To32

    SYNOPSIS:   map the 16 WNet types for DISK/PRINT, etc
                to their 32 bit equivalents

    ENTRY:      nType - 16 bit type

    EXIT:

    RETURNS:    the 32 bit type

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
DWORD MapWNType16To32(WORD nType)
{
    switch (nType)
    {
        case WNTYPE_DRIVE :
        case WNTYPE_FILE :
            return RESOURCETYPE_DISK ;
        case WNTYPE_PRINTER :
            return RESOURCETYPE_PRINT ;
        case WNTYPE_COMM :
        default :
            return RESOURCETYPE_ERROR ;
    }
}

/*******************************************************************

    NAME:       MapWin32ErrorToWN16

    SYNOPSIS:   maps a Win 32 error the old style WN_ 16 bit error.

    ENTRY:      err - Win32 error

    EXIT:

    RETURNS:    Win 16 error

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD MapWin32ErrorToWN16(DWORD err)
{
    switch (err)
    {
        case ERROR_NOT_SUPPORTED:
            return WN_NOT_SUPPORTED ;

        case WIN32_WN_CANCEL:
            return WN_CANCEL ;

        case WIN32_EXTENDED_ERROR :
        case ERROR_UNEXP_NET_ERR:
            return WN_NET_ERROR ;

        case ERROR_MORE_DATA:
            return WN_MORE_DATA ;

        case ERROR_INVALID_PARAMETER:
            return WN_BAD_VALUE ;

        case ERROR_INVALID_PASSWORD:
            return WN_BAD_PASSWORD ;

        case ERROR_ACCESS_DENIED:
            return WN_ACCESS_DENIED ;

        case ERROR_NETWORK_BUSY:
            return WN_FUNCTION_BUSY ;

        case ERROR_NOT_ENOUGH_MEMORY:
            return WN_OUT_OF_MEMORY ;

        case ERROR_BAD_NET_NAME:
        case ERROR_BAD_NETPATH:
            return WN_BAD_NETNAME ;

        case ERROR_INVALID_DRIVE:
            return WN_BAD_LOCALNAME ;

        case ERROR_ALREADY_ASSIGNED:
            return WN_ALREADY_CONNECTED ;

        case ERROR_GEN_FAILURE:
            return WN_DEVICE_ERROR ;

        case NERR_UseNotFound:
            return WN_NOT_CONNECTED ;

        default:
            return ( (WORD) err ) ;
    }
}

/*******************************************************************

    NAME:       GetAlignedMemory

    SYNOPSIS:   global alloc some mem to make sure we have DWORD
                aligned data. non x86 platforms may need this.

    ENTRY:      pAligned : used to return pointer to aligned memory allocated
                pHandle  : used to return handle of aligned memory allocated
                wSize    : bytes required

    EXIT:

    RETURNS:    WN_SUCCESS or WN_OUT_OF_MEMORY

    NOTES:

    HISTORY:
        ChuckC          27-Feb-94   Created

********************************************************************/
WORD GetAlignedMemory(LPVOID FAR *pAligned, HANDLE FAR *pHandle, WORD wSize)
{
    *pAligned = NULL ;
    *pHandle = NULL ;

    if (!(*pHandle = GlobalAlloc(GMEM_ZEROINIT|GMEM_FIXED,wSize)))
    {
        return WN_OUT_OF_MEMORY ;
    }

    if (!(*pAligned = (LPVOID)GlobalLock(*pHandle)))
    {
        (void) GlobalFree(*pHandle) ;
        *pHandle = NULL ;
        return WN_OUT_OF_MEMORY ;
    }

    return WN_SUCCESS ;
}

/*******************************************************************

    NAME:       FreeAlignedMemory

    SYNOPSIS:   free global memory allocated by GetAlignedMemory.

    ENTRY:      Handle  : handle of aligned memory to be freed

    EXIT:

    RETURNS:    none

    NOTES:

    HISTORY:
        ChuckC          27-Feb-94   Created

********************************************************************/
void FreeAlignedMemory(HANDLE handle)
{
    if (handle)
    {
        (void) GlobalUnlock(handle) ;
        (void) GlobalFree(handle) ;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\fakewife.c ===
/**************************************************************************
*
*  - fakewife.c -  Dummy functions
*
* Windows Intelligent Font Environment Maneger for Win32 and NT
*
*  Author : kazuyuki Kato [ V-kazuyK ]
*
* History :
*
*  11.Nov.1993 -By- kazuyuki Kato [ V-kazuyK ]
* Create it.
*
*************************************************************************/

#include <windows.h>
#include "wife.h"

extern HINSTANCE hInst;

typedef int (FAR PASCAL * LPLOADSTRING)(HANDLE, USHORT, LPSTR, int);
typedef int (FAR PASCAL * LPMESSAGEBOX)(HWND, LPSTR, LPSTR, USHORT);
typedef int (FAR cdecl * LPWSPRINTF)(LPSTR,LPSTR,...);

#define IDCANCEL            2

SHORT FAR PASCAL InternalWarningMessageByString(
        HWND hParentWindow,
        LPSTR szMsg,
        LPSTR szTitle,
        USHORT mode
)
{
        HANDLE hUser;
        LPMESSAGEBOX lpMessageBox;
        SHORT result;

        /* get instance of user.exe */
        hUser = GetModuleHandle("USER.EXE");
        if( hUser == NULL ) return(IDCANCEL);

        /* get procedure instance of MessageBox */
        lpMessageBox = (LPMESSAGEBOX)GetProcAddress( hUser, MAKEINTRESOURCE(1) );
        if( lpMessageBox == NULL ) return(IDCANCEL);

        result = (*lpMessageBox)(
                NULL,   /* no current window handle */
                szMsg,
                szTitle,
                mode
        );

        return( result );
}



VOID NotifyNoSuport( VOID )
{

    if ( IDNO == MiscWarningMessage( hInst, IDS_NOTSUPORTFUNCTION, IDS_WIFETITLE, MB_YESNO ))
        FatalAppExit( 0, NULL );

//    MessageBox( NULL, sz, sz2, MB_OK );
//    OutputDebugString( sz );


}



LONG FAR PASCAL  FdiClaimFontFile( HFD hFD, LPSTR lpszFileName )
{NotifyNoSuport();return 0;}
LONG FAR PASCAL FdiConvertFontFile( HFD hFD, LPSTR lpszSrcFileName, LPSTR lpszDestDirName, LPSTR lpszResultPackName )
{NotifyNoSuport();return -1L;}
HFF FAR PASCAL FdiLoadFontFile( HFD hFD, LPSTR lpszPackName )
{NotifyNoSuport();return -1L;}
LONG FAR PASCAL FdiUnloadFontFile( HFD hFD, HFF hFF )
{NotifyNoSuport();return -1L;}

LONG FAR PASCAL FdiQueryFaces( HFD hFD, HFF hFF, LPIFIMETRICS lpIfiMetrics, ULONG cMetricLen, ULONG cFontCount, ULONG cStart )
{NotifyNoSuport();return 0;}
HFC FAR PASCAL FdiOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiCloseFontContext( HFD hFD, HFC hFC )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiSetFontContext( HFD hFD, HFC hFC, LPCONTEXTINFO lpContextInfo )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiQueryFaceAttr( HFD hFD, HFC hFC, ULONG iQuery, LPVOID lpBuffer, ULONG cb, LPVOID lpIndex, SHORT Start )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiQueryCharAttr( HFD hFD, HFC hFC, LPCHARATTR lpCharAttr, LPBITMAPMETRICS lpbmm )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FdiControl( HFD hFD, HFC hFC, LPCONTROLTAG lpControlTag, LPVOID lpOutData )
{NotifyNoSuport();return 0;}



HFD FAR PASCAL MimAddFontDriver( LPSTR lpszFileName )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MimRemoveFontDriver( HFD hFD )
{NotifyNoSuport();return 0;}

BOOL NEAR PASCAL RealRemoveFontDriver( HFD hFD )
{NotifyNoSuport();return 0;}

HFF FAR PASCAL MimAddFontPack( HFD hFD, LPSTR lpszPackName )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MimRemoveFontPack( HFD hFD, HFF hFontPack )
{NotifyNoSuport();return 0;}

HFD FAR PASCAL MimEnumFontDrivers( HFD hLastDriver )
{NotifyNoSuport();return 0;}

HFF FAR PASCAL MimEnumFontPacks( HFD hFD, HFF hLastPack )
{NotifyNoSuport();return 0;}

HFC FAR PASCAL MimOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL MimCloseFontContext( HFD hFD, HFF hFF, HFC hFC )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL MimGetInformations( MIMGETINFO_ORDER order, HFD hFD, HFF hFF, LPVOID AnswerBuffer, USHORT SizeOfBuffer )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL MiscSetErroInfo( ULONG ErrorCode )
{NotifyNoSuport();return ;}

ULONG FAR PASCAL MiscGetErroInfo( VOID )
{
        return( 0L );
}






/**************************Public*Routine*******************************\
* SHORT FAR PASCAL MiscWarningMessage(
*       HANDLE hInst,
*       USHORT idsMsg,
*       USHORT idsTitle,
*       USHORT mode
* )
*
* read string from resource and show it by message box
*
* Effects:
*
* Warnings:
*  This function is available after delayed init.
*
* History:
*     04-Sep-1990 12:00:00  -by-    Akira Kawamata [akirak]
* Creation
\***********************************************************************/

char szTitle[256];
char szMsg[256];
char szNewMsg[256];

SHORT FAR PASCAL MiscWarningMessage(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        USHORT mode
)
{
        HANDLE hUser;
        LPLOADSTRING lpLoadString;
        SHORT result;
        SHORT nLength;

        /* get instance of user.exe */
        hUser = GetModuleHandle("USER.EXE");
        if( hUser == NULL ) return(IDCANCEL);

        /* get procedure instance of LoadString */
        lpLoadString = (LPLOADSTRING)GetProcAddress( hUser, MAKEINTRESOURCE(176) );
        if( lpLoadString == NULL ) return(IDCANCEL);

        /* load message string */
        nLength = (*lpLoadString)( hInst, idsMsg, szMsg, sizeof(szMsg) );
        if( nLength == sizeof(szMsg) ){
                szMsg[sizeof(szMsg)-1] = '\0';
        }

        /* load title string */
        nLength = (*lpLoadString)( hInst, idsTitle, szTitle, sizeof(szTitle) );
        if( nLength == sizeof(szTitle) ){
                szMsg[sizeof(szTitle)-1] = '\0';
        }

        result = InternalWarningMessageByString(
                NULL,   /* no current window handle */
                szMsg,
                szTitle,
                mode
        );

        return( result );
}


/**************************Public*Routine*******************************\
* SHORT FAR PASCAL MiscWarningMessageWithArgument(
*       HANDLE hInst,
*       USHORT idsMsg,
*       USHORT idsTitle,
*       LPSTR lpszArgument
*       USHORT mode
* )
*
* read string from resource and conbine argument,
* then show it by message box
*
* Effects:
*
* Warnings:
*  This function is available after delayed init.
*  idsMsg must include only one "%s". if it's not "%s" or many % is appear,
* this function wouldn't work right.
*
* History:
*     04-Sep-1990 12:00:00  -by-    Akira Kawamata [akirak]
* Creation
\***********************************************************************/

SHORT FAR PASCAL MiscWarningMessageWithArgument(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        LPSTR lpszArgument,
        USHORT mode
)
{
        HANDLE hUser;
        LPLOADSTRING lpLoadString;
        LPWSPRINTF lpwsprintf;
        SHORT result;
        SHORT nLength;

        /* get instance of user.exe */
        hUser = GetModuleHandle("USER.EXE");
        if( hUser == NULL ) return(IDCANCEL);

        /* get procedure instance of LoadString */
        lpLoadString = (LPLOADSTRING)GetProcAddress( hUser, MAKEINTRESOURCE(176) );
        if( lpLoadString == NULL ) return(IDCANCEL);

        /* get procedure instance of wsprintf */
        lpwsprintf = (LPWSPRINTF)GetProcAddress( hUser, MAKEINTRESOURCE(420) );
        if( lpwsprintf == NULL ) return(IDCANCEL);

        /* load message string */
        nLength = (*lpLoadString)( hInst, idsMsg, szMsg, sizeof(szMsg) );
        if( nLength == sizeof(szMsg) ){
                szMsg[sizeof(szMsg)-1] = '\0';
        }

        /* load title string */
        nLength = (*lpLoadString)( hInst, idsTitle, szTitle, sizeof(szTitle) );
        if( nLength == sizeof(szTitle) ){
                szMsg[sizeof(szTitle)-1] = '\0';
        }

        (*lpwsprintf)(szNewMsg, szMsg, lpszArgument );

        result = InternalWarningMessageByString(
                NULL,   /* no current window handle */
                szNewMsg,
                szTitle,
                mode
        );

        return( result );
}






VOID FAR PASCAL MiscTrancateString(
        LPSTR lpszStr,
        SHORT length,
        SHORT CharSet
)
{NotifyNoSuport();return ;}

USHORT FAR PASCAL ubstrlen( LPUBCHAR cp )
{NotifyNoSuport();return 0;}

LPUBCHAR FAR PASCAL ubstrcpy( LPUBCHAR dst, LPUBCHAR src )
{NotifyNoSuport();return 0;}

LPUBCHAR FAR PASCAL ubstrncpy( LPUBCHAR dst, LPUBCHAR src, USHORT limit )
{NotifyNoSuport();return 0;}

LPUBCHAR FAR PASCAL ubstrcat( LPUBCHAR dst, LPUBCHAR src )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL ubstrcmp( LPUBCHAR str1, LPUBCHAR str2 )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL AscizToUz(
        LPUBCHAR dst,
        LPSTR src,
        USHORT limit,
        CHAR_SET CharSet
)
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL UzToAsciz(
        LPSTR dst,
        LPUBCHAR src,
        USHORT limit
)
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmCalcByteWidth( SHORT nBitWidth )
{NotifyNoSuport();return 0;}


HFB FAR PASCAL FcmEnumFontBuffers( HFB hLastBuffer )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmValidateFC( HFB hFB )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmUnvalidateFC( HFB hFB )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmCreateCacheBuffer(
        HFD hFD,
        HFF hFF,
        ULONG ulFont,
        LPVOID lpXform,
        USHORT usMinorCharSet,
        USHORT usAttribute
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmDeleteCacheBuffer( HFB hFB )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmForceCacheIn( HFB hFB, LPUBCHAR lpubStr )
{NotifyNoSuport();return 0;}

HFC FAR PASCAL FcmGetFontContext( HFB hFB )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL FcmGetEUDCLeadByteRange( HFB hFB )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmGetEUDCFB( HFB hFB )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL MapWifeFont(
LPLOGFONT lpLogFont,
LPVOID lpMapResult)
{NotifyNoSuport();return ;}

WORD FAR PASCAL MiscRealizeWifeFont(
LPLOGFONT lpLogFont,
LPVOID lpExtFont,
LPVOID lpTextXform)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscDeleteWifeFont( LPVOID lpExtFont)
{NotifyNoSuport();return 0;}

VOID FAR PASCAL FillFontInfo(
        LPVOID lpExtFont,
        LPIFIMETRICS lpIFIMetrics,
        HFD hFD,
        HFF hFF,
        LONG MetricsOrder
)
{NotifyNoSuport();return ;}

SHORT FAR PASCAL FcmRequestImages(
       HFB hFB,
       LPVOID AnswerBuffer,
       short length

)
{NotifyNoSuport();return 0;}



BOOL FAR PASCAL FcmReleaseImages(
       HFB hFB,
       LPVOID AnswerBuffer,
       short length
)
{NotifyNoSuport();return 0;}

LPVOID FAR PASCAL MiscAddHugePtr( LPVOID src, ULONG offset )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL MiscGetSegmentIncrement( VOID )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmRequestDefaultFB(
        LPVOID lpFont,
        LPVOID lpTextXform
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmReleaseDefaultFB( HFB hFB )
{NotifyNoSuport();return 0;}

DWORD FAR PASCAL FcmCalculateTextExtent(
        HFB         hFB,
        LPSTR       lpString,
        short       count,
        LPVOID      lpFont,
        LPVOID      lpvoid,
        LPVOID      lpXform,
        LPSHORT     lpCharWidths,
        USHORT      usMode
)
{NotifyNoSuport();return 0;}


SHORT FAR PASCAL FcmCalculateOutputPositions(
        HFB             hFB,
        LPVOID lpFcmCharacteristics,
        SHORT           nArrayLength,
        LPSHORT         lpx,
        LPSHORT         lpy,
        LPRECT          lpClipRect,
        LPSTR           FAR * lplpString,
        LPSHORT         lpcount,
        LPVOID      lpFont,
        LPVOID      lpDrawMode,
        LPVOID     lpXform,
        LPSHORT         FAR * lplpCharWidths,
        USHORT          usMode
)
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmCleanUp( VOID )
{NotifyNoSuport();return 0;}

BYTE FAR PASCAL MiscConvertFontFamily( LPSTR szFamilyName )
{NotifyNoSuport();return 0;}

BYTE FAR PASCAL MiscConvertCharSet( LPSTR CharSetString )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL MiscIfiMetricsToLogFont(
        LPLOGFONT lpLogFont,
        LPIFIMETRICS lpIFIMetrics,
        USHORT usLogicalMapFlag
)
{NotifyNoSuport();return ;}

VOID FAR PASCAL MiscIfiMetricsToTextMetrics(
        LPTEXTMETRIC lpTextMetrics,
        LPIFIMETRICS lpIFIMetrics
)
{NotifyNoSuport();return ;}

VOID FAR PASCAL MiscMakeTextXform(
        LPVOID lpTXF,
        LPIFIMETRICS lpIM,
        LPLOGFONT lpLF
)
{NotifyNoSuport();return ;}

LONG FAR PASCAL FcmQueryFaceAttr(
        HFB         hFB,
        ULONG       iQuery,
        LPABC_TRIPLETS  lpBuffer,
        ULONG       cb,
        LPUBCHAR    lpIndex,
        UBCHAR      Start
)
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmProcessDeviceControl(
        HFB hFB,
        SHORT nFunction,
        LPVOID lpGI,
        LPVOID lpOutData
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL
MiscIsWifeControl( SHORT function )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscIsGaijiControl( SHORT function )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL FcmGetCharWidth(
        WORD   hFB_,
        DWORD   lpBuffer_,
        WORD   wFirstChar_,
        WORD   wLastChar_,
        DWORD   lpFont_,
        DWORD   lpDrawMode_,
        DWORD   lpFontTrans_,
        WORD   usExpandPixels_,
        WORD   usMode_
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscStretchMonoFontImage(
        LPVOID  lpDestImage,
        USHORT  usSizeOfDestX,
        USHORT  usSizeOfDestY,
        LPVOID  lpSrcImage,
        USHORT  usSizeOfSrcX,
        USHORT  usSizeOfSrcY
)
{NotifyNoSuport();return 0;}

LP_QUICK_SEARCH_TABLE FAR PASCAL MiscValidateQuickSearchTable(
        USHORT usLogicalMapFlag
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscUnvalidateQuickSearchTable(
        USHORT usLogicalMapFlag
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscRegisterNotifyFunction(
        LPVOID lpfnCallBack
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscUnregisterNotifyFunction( LPVOID lpfnCallBack )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmRequestDefaultFBEx( LPVOID lpFont, LPVOID lpTextXform, WORD wControlFlag )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL SetCloseOldestFCFunc(LPVOID lpfnCallbackFunc)
{NotifyNoSuport();return ;}


HFC FAR PASCAL CachedOpenFontContext(
HFD hFD,
HFF hFF,
ULONG ulFont,
LPCONTEXTINFO lpContextInfo,
SHORT sMinorCharSet,
SHORT sAttribute
)
{NotifyNoSuport();return 0;}



SHORT FAR PASCAL FillContextInfo(
unsigned short ftHeight,
unsigned short ftWidth,
LPIFIMETRICS lpIfiMetrics,
HFD hFD,
LPCONTEXTINFO lpContextInfo,
LPCONTEXTINFO lpContextInfoEUDC,
LPVOID lpEUDCContext,
BOOL FAR *lpbSelfMode
)
{NotifyNoSuport();return 0;}

VOID FAR PASCAL GetEUDCFD( HFD FAR *lphFD, HFF FAR *lphFF )
{NotifyNoSuport();return ;}

VOID FAR PASCAL GetDefaultFontInfo( LPVOID lpInfo )
{NotifyNoSuport();return ;}

LPVOID FAR PASCAL DiagLocalLockAnything( LOCALHANDLE hAny )
{NotifyNoSuport();return 0;}

LPVOID FAR PASCAL DiagLocalUnlockAnything( LOCALHANDLE hAny )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL DiagGetConfirmString( LPSTR buffer, SHORT length )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL DiagSelfCheck( VOID )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL DiagSelfCheckAndWarning( VOID )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL DebugAssertion( VOID )
{NotifyNoSuport();return ;}

BOOL FAR PASCAL DelayedInit( VOID )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FirstInit( VOID )
{NotifyNoSuport();return 0;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\wifeman.c ===
/**************************************************************************
*
*  - WIFEMAN.DLL -
*
* Windows Intelligent Font Environment Maneger for Win32 and NT 
*
*  Author : Hideyuki Nagase [hideyukn]
*
* History :
*
*  11.Aug.1993 -By- Hideyuki Nagase [hideyukn]
* Create it.
*
*************************************************************************/

#include <windows.h>

#define  WIFEMAN_VERSION     0x0109  //  Version 1.09

#define  EUDC_RANGE_SECTION  "System EUDC"
#define  EUDC_RANGE_KEY      "SysEUDCRange"

HINSTANCE hInst;


/************************************************************************
*
* MiscGetVersion()
*
*  Return WIFE driver version
*
************************************************************************/

unsigned long FAR PASCAL
MiscGetVersion
(
    VOID
)
{
    return( (long)WIFEMAN_VERSION );
}


/************************************************************************
*
* MiscIsDbcsLeadByte()
*
*  Return SBCS/DBCS status
*
************************************************************************/

unsigned char FAR PASCAL 
MiscIsDbcsLeadByte
(
    unsigned short usCharSet ,
    unsigned short usChar
)
{
    unsigned char ch;
    unsigned short LangID;

    LangID = GetSystemDefaultLangID();

    if (LangID == 0x404 && usCharSet != CHINESEBIG5_CHARSET)
        return( 0 );
    else if (LangID == 0x804 && usCharSet != GB2312_CHARSET)
        return( 0 );
    else if (LangID == 0x411 && usCharSet != SHIFTJIS_CHARSET)
        return( 0 );
    else if (LangID == 0x412 && usCharSet != HANGEUL_CHARSET)
        return( 0 );
    // CHP
    else if (LangID == 0xC04 && (usCharSet != GB2312_CHARSET) && (usCharSet != CHINESEBIG5_CHARSET))
        return( 0 );
    else
        return( 0 );

    if (usChar == 0xffff)
        return( 1 );

    ch = (unsigned char)((unsigned short)(usChar >> 8) & 0xff);

    if (ch == 0) {
        ch = (unsigned char)((unsigned short)(usChar) & 0xff);
    }

    return((unsigned char)(IsDBCSLeadByte( ch )));
}

/**********************************************************************
*
* WEP()
*
*  Called by Windows when this DLL in unloaded
*
**********************************************************************/

int FAR PASCAL
WEP
(
    int nParam
)
{
    int iRet;

    switch( nParam )
    {
        case WEP_SYSTEM_EXIT :
        case WEP_FREE_DLL :
        default :
            iRet = 1;
    }

    return( iRet );
}

int NEAR PASCAL LibMain(
        HANDLE hInstance,
        WORD wDataSeg,
        WORD wHeapSize,
        LPSTR lpCmdLine
)
{
    hInst = hInstance;

    return 1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\wifethk.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1994, Microsoft Corporation
;
;   USER.ASM
;   Win16 WINNLS thunks
;
;   History:
;
;   Created 17-May-1994 by hiroh
;--

	TITLE	WIFEMAN.ASM
	PAGE	,132

	.286p

	.xlist
	include wow.inc
	include wowwife.inc
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.

externFP    WOW16Call
externA  __MOD_WIFEMAN

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA


sBegin	DATA
Reserved    db	16 dup (0)	;reserved for Windows

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

	WifeManThunk  MISCGETEUDCLEADBYTERANGE

sEnd	CODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\wife.h ===
/****************************************************************************\
*
* WIFE.H : East Asia Windows Intelligent Font Environment definitions
*
******************************************************************************
*
* History:
* 21-Oct-1991   bent
*               initial merge of East Asia 3.0 versions
*               Should be updated to resolve local inconsistencies.
*
* Copyright (c) 1990  Microsoft Corporation
*
* Brief instruction
* -----------------
*
*   This header file is a common single header for WIFE drivers.                                                                                    *
*   If you are a developer of FontDriver, please write coding as follow                                                                             *
*
*   #define WIFE_CREATE_FONTDRIVER                                                                                                                    *
*   #include <wife.h>                                                                                                                                 *
*
*   If you are a developer of DeviceDriver which are display or printer
*   drivers, please write coding as follow.                                                                                                                   *
*
*   #define WIFE_CREATE_DEVICEDRIVER                                                                                                                  *
*   #include <wife.h>                                                                                                                                 *
*
*   If you don't define both of symbols, only common defenitions are
*   available.
*
*   Aug.17,1990 Akira Kawamata [AkiraK]                                                                              *
*
\****************************************************************************/

/****** OS/2-like common data type definitions ******************************/

#ifndef WIFEH_NODATATYPES
typedef unsigned short int USHORT;
typedef short int          SHORT;
typedef unsigned long      ULONG;
typedef LONG FAR *         LPLONG;
typedef LONG NEAR *        NPLONG;
typedef ULONG FAR *        LPULONG;
typedef ULONG NEAR *       NPULONG;
typedef SHORT FAR *        LPSHORT;
typedef SHORT NEAR *       NPSHORT;
typedef USHORT FAR *       LPUSHORT;
typedef USHORT NEAR *      NPUSHORT;
typedef char               CHAR;
typedef unsigned char      UCHAR;

typedef VOID NEAR *        NPVOID;

#endif //WIFEH_NODATATYPES

/****** Graphics handling support definitions *******************************/

#ifndef WIFEH_NOGRAPHSUPPORT
/* rotation angle by 90degree */
typedef enum {
        ANGLE000 = 0,
        ANGLE090 = 1,
        ANGLE180 = 2,
        ANGLE270 = 3
} QUOTER_ANGLE;
#define FixedToQuoterAngle(f) ((f.Integer/90)%4)
#define RotationToQuoterAngle(r) ((r/900)%4)

typedef DWORD PACKEDPOINT;
typedef DWORD PACKEDLOGICALPOINT;
typedef DWORD PACKEDPHYSICALPOINT;
typedef struct {
        short x,y;
} XYPOINT;
typedef union {
        PACKEDPOINT packed;
        XYPOINT point;
} UNIONPOINT, NEAR * NPUNIONPOINT, FAR * LPUNIONPOINT;

#define PartOfX(xy)     ((SHORT)(xy))
#define PartOfY(xy)     ((SHORT)(((DWORD)(xy) >> 16) & 0xFFFF))
#define MAKELONG_LO_HI MAKELONG
#define PackXY(x,y)     ((DWORD)MAKELONG_LO_HI((WORD)x,(WORD)y))
#endif //WIFEH_NOGRAPHSUPPORT

/****** UBCS : Unified Byte Character Set, data types defenition  **********/

#ifndef WIFEH_NOUBCS
typedef USHORT UBCHAR;
typedef UBCHAR NEAR * NPUBCHAR;
typedef UBCHAR FAR * LPUBCHAR;

#define UBEOS (0)               /* End Of String */
#define UBNEWLINE (0x0a0d)      /* New Line (CR/LF) */

#define IsSbcsUBChar(uc) ((uc & 0xff00) == 0x2000)
#define IsDbcsUBChar(uc) ((uc & 0xff00) != 0x2000)
#endif //WIFEH_NOUBCS

/****** Utility macros *****************************************************/

#ifndef WIFEH_NOUTILITYMACROS
/* return type of GlobalLock is LPSTR, but it's to be LPVOID */
#define AnyGlobalLock(h) ((LPVOID)GlobalLock(h))
#define AnyLocalLock(h) ((NPVOID)LocalLock(h))
#define TypedLocalLock(h,t) ((t NEAR *)LocalLock(h))
#define TypedGlobalLock(h,t) ((t FAR *)GlobalLock(h))

/* utility macro which is not included windows.h */
#define MAKEWORD(l,h) ((WORD)((BYTE)l+(((BYTE)h) << 8)))
#endif //WIFEH_NOUTILITYMACROS

/****** GDIDEFS.H support definitions **************************************/

#ifdef WIFE_ENABLE_GDIDEFS_SUPPORT
typedef FONTINFO FAR * LPFONTINFO;
typedef DRAWMODE FAR * LPDRAWMODE;
typedef TEXTXFORM FAR * LPTEXTXFORM;
#endif //WIFE_ENABLE_GDIDEFS_SUPPORT

/****** Character set definitions ******************************************/

#ifndef WIFEH_NOCHARSET
typedef enum {
        CHARSET_ANSI = 0,
        CHARSET_SYMBOL = 2,
        CHARSET_SHIFTJIS = 128,
        CHARSET_KOREA = 129,
        CHARSET_CHINESEBIG5 = 136,
	CHARSET_GB2312 = 134,
        CHARSET_OEM = 255
} CHAR_SET;
#endif //WIFEH_NOCHARSET


/***************************************************************************/
/****** Control function support definitions  ******************************/

#ifndef WIFEH_NOCONTROL

/******************************************/
/*      FONT DRIVER MEDIA DESCRIPTER      */
/******************************************/
#ifndef WIFEWH_NOMEDIA
/* FDMEDIA enumration type */
typedef enum {
        FDMEDIA_ON_FILE = 1,
        FDMEDIA_ON_DRIVER = 2,
        FDMEDIA_ON_REMOVEABLE_HARDWARE = 4,
        FDMEDIA_ON_FIXED_HARDWARE = 8,
        FDMEDIA_UNDEFINED = 0x4000,
        FDMEDIA_ANY_MEDIA = 0x7fff
} FDMEDIA;
#endif


/******************************************/
/*    MINOR CHARACTER SETS DEFENITION     */
/******************************************/
#ifndef WIFEH_NOMINORCHARSET_IN_JAPAN

/* general default minor character set */
#define FD_MINOR_CHARSET_DEFAULT 1

/* Minor Character Set in Japan */
#define FD_MINOR_CHARSET_NEW_JIS 1      /* new JIS */
#define FD_MINOR_CHARSET_OLD_JIS 2      /* old JIS */
#define FD_MINOR_CHARSET_IBM_JIS 4      /* IBM JIS */
#define FD_MINOR_CHARSET_NEC_JIS 8      /* NEC JIS */

#endif

/******************************************/
/*        CODE AREA STRUCTURE             */
/******************************************/
#ifndef WIFEH_NOCODEAREA

typedef struct {
        UBCHAR CodeFrom;
        UBCHAR CodeTo;
} CODEAREA, NEAR * NPCODEAREA, FAR * LPCODEAREA;

#endif

/******************************************/
/*    SPECIAL ESCAPE FUNCTION ORDERS      */
/******************************************/

/* subfunction orders in WIFE */
#define FD_CONTROL_RESERVED             (0xa20)
#define FD_CONTROL_RESERVED_LIMIT       (FD_CONTROL_RESERVED+0x3f)

/* standard subfunctions */
#define FD_CONTROL_QUERY_ESC_SUPPORT    (FD_CONTROL_RESERVED+0)
#define FD_CONTROL_SUPPORT_CODES        (FD_CONTROL_RESERVED+1)
#define FD_CONTROL_NUMBER_OF_ATTRIBUTE  (FD_CONTROL_RESERVED+2)
#define FD_CONTROL_NAME_OF_ATTRIBUTE    (FD_CONTROL_RESERVED+3)
#define FD_CONTROL_SET_ATTRIBUTE        (FD_CONTROL_RESERVED+4)
#define FD_CONTROL_GET_ATTRIBUTE        (FD_CONTROL_RESERVED+5)
#define FD_CONTROL_SET_MINOR_CHARSET    (FD_CONTROL_RESERVED+6)
#define FD_CONTROL_GET_MINOR_CHARSET    (FD_CONTROL_RESERVED+7)
#define FD_CONTROL_GET_FONT_DRIVER_NAME (FD_CONTROL_RESERVED+8)
#define FD_CONTROL_GET_FONT_PACK_NAME   (FD_CONTROL_RESERVED+9)
#define FD_CONTROL_GET_MEDIA            (FD_CONTROL_RESERVED+10)
#define FD_CONTROL_GET_DBCS_STRING_KERN (FD_CONTROL_RESERVED+11)

#if defined(TAIWAN) || defined(PRC)
/* Chinese related functions */
#define FD_CONTROL_GET_USERFONT_TECH    (FD_CONTROL_RESERVED+0X0C)
#define FD_CONTROL_SET_USERFONT         (FD_CONTROL_RESERVED+0X0D)
#define FD_CONTROL_SETUP_DIALOG         (FD_CONTROL_RESERVED+0X0E)
#define FD_CONTROL_SET_DEFAULT_CHAR     (FD_CONTROL_RESERVED+0X0F)

/* private interface subfunctions */
#define FD_CONTROL_USER                 (FD_CONTROL_RESERVED+0x10)
#define FD_CONTROL_USER_LIMIT           (FD_CONTROL_RESERVED_LIMIT)

/* EUDC related subfunctions */
#define FD_CONTROL_LEVEL2_EUDC_INFO     (FD_CONTROL_RESERVED+0X12)
#else
/* EUDC related subfunctions */
#define FD_CONTROL_LEVEL2_EUDC_INFO     (FD_CONTROL_RESERVED+12)

/* private interface subfunctions */
#define FD_CONTROL_USER                 (FD_CONTROL_RESERVED+0x10)
#define FD_CONTROL_USER_LIMIT           (FD_CONTROL_RESERVED+0x1f)

/* Chinese related functions */
#define FD_CONTROL_GET_USERFONT_TECH    (FD_CONTROL_RESERVED+0x20)
#define FD_CONTROL_SET_USERFONT         (FD_CONTROL_RESERVED+0x21)
#define FD_CONTROL_SETUP_DIALOG         (FD_CONTROL_RESERVED+0x22)
#define FD_CONTROL_SET_DEFAULT_CHAR     (FD_CONTROL_RESERVED+0x23)
#endif
#if defined(TAIWAN)  || defined(PRC)
// we add this line for the FDCONTROL constant has get the limit
#define FD_CONTROL_CHINESE_RESERVED     FD_CONTROL_RESERVED+0x30
#endif  // TAIWAN

#ifdef WIFE_ENABLE_EUDC_SUPPORT

typedef struct {
        ULONG   cb;             /* length of this structure */
        BOOL    bForceFixedPitch;       /* force fixed pitch */
        BOOL    bVerticalFont;  /* vertical font flag */
        FIXED   fxCharRot;      /* character rotation */
        FIXED   fxInlineDir;    /* inline rotation */
        USHORT  usLimitWidth;   /* maximum width of cachable */
        SHORT   sFixedASpace;   /* font width when bForceFixedPitch is TRUE */
        USHORT  usFixedBSpace;  /* font width when bForceFixedPitch is TRUE */
        SHORT   sFixedCSpace;   /* font width when bForceFixedPitch is TRUE */
} EUDC_CONTEXT, NEAR * NPEUDC_CONTEXT, FAR * LPEUDC_CONTEXT;

#endif

#endif

#if defined(TAIWAN) || defined(PRC)
typedef struct {
HWND hWnd;
HANDLE hInst;
} CALLINGINFO, FAR *LPCALLINGINFO;
#endif  // TAIWAN

#ifndef WIFEH_NOFDCOMMONDEFENITION
typedef LONG HFF;
typedef LONG HFC;
typedef HANDLE HFD;
typedef HANDLE HFB;

#define FACESIZE 32
#define GLYPHNAMESIZE 16

#define WIFEERR_FACENAME_NOT_FOUND        23004L
#define WIFEERR_FD_ALREADY_INSTALLED      23005L
#define WIFEERR_INVALID_CONTEXTINFO       23006L
#define WIFEERR_NOT_A_FONT_FILE           23007L
#define WIFEERR_INVALID_FONT_SELECTION    23008L
#define WIFEERR_INVALID_FORMAT            23009L
#define WIFEERR_BUSY_HFC                  230010L
#define WIFEERR_INVALID_HFC               230011L
#define WIFEERR_INVALID_INDEX             230012L
#define WIFEERR_INVALID_QUERY_TYPE        230013L
#define WIFEERR_CONTEXT_NOT_SET           230014L

#define FD_QUERY_ABC_WIDTHS     2L
#define FD_QUERY_KERNINGPAIRS   3L

#define FD_QUERY_CHARIMAGE      1L
#define FD_QUERY_OUTLINE        2L
#define FD_QUERY_BITMAPMETRICS  4L

typedef UBCHAR GLYPH; /* gi */
typedef LPUBCHAR LPGLYPH; /* lpgi */


typedef struct _ABC_TRIPLETS { /* abc, npabc, lpabc */
        SHORT  sA;
        USHORT usB;
        SHORT  sC;
} ABC_TRIPLETS, NEAR * NPABC_TRIPLETS, FAR * LPABC_TRIPLETS;

typedef struct _SIZEL { /* sizl */
        ULONG cx; // Width.
        ULONG cy; // Height.
} SIZEL;

typedef struct _BITMAPMETRICS { /* bmm, npbmm, lpbmm */
        SIZEL     sizlExtent;
        POINTFX   pfxOrigin;    /* Return character origin. */
        POINTFX   pfxCharInc;   /* Return the device advance width */
} BITMAPMETRICS, NEAR * NPBITMAPMETRICS, FAR * LPBITMAPMETRICS;


typedef struct _FD_KERNINGPAIRS  { /* krnpr, npkrnpr, lpkrnpr */
        GLYPH     giFirst;
        GLYPH     giSecond;
        LONG      eKerningAmount;
} FD_KERNINGPAIRS, NEAR * NPFD_KERNINGPAIRS, FAR * LPFD_KERNINGPAIRS;


typedef struct _CONTEXTINFO  { /* ci */
        ULONG     cb;        /* Length in bytes of this structure. */
        ULONG     fl;        /* Flags. */
        SIZEL     sizlPPM;    /* Device resolution in pels/meter. */
        POINTFX   pfxSpot;   /* Spot size in pels. */
        MAT2      matXform;  /* Notional to Device transform. */
} CONTEXTINFO, NEAR * NPCONTEXTINFO, FAR * LPCONTEXTINFO;


typedef struct _CHARATTR  { /* chattr */
        ULONG     cb;
        ULONG     iQuery;   /* Query type. */
        GLYPH     gi;       /* Glyph index in font. */
        LPBYTE    lpBuffer;  /* Bitmap buffer. */
        ULONG     cbLen;    /* Size of buffer in bytes. */
} CHARATTR, NEAR * NPCHARATTR, FAR * LPCHARATTR;


/* bit-constants for fsType in IFIMETRICS  */

#define IFIMETRICS_FIXED       0x0001   /* Fixed pitch */
#define IFIMETRICS_LICENSED    0x0002   /* dummy defenition */
#define IFIMETRICS_SPARSE      0x0004   /* Incomplete font */
#define IFIMETRICS_SCALEABLE   0x8000   /* scalable font */

/* bit-constant for fsDefn in IFIMETRICS   */

#define IFIMETRICS_OUTLINE     0x0001   /* dummy definition */
                                        /* 1 - Outline. 0 - Raster */

/* bit-constant for fsSelection in IFIMETRICS */

#define IFIMETRICS_ITALIC      0x8000  /*Italic */
#define IFIMETRICS_UNDERSCORE  0x4000  /*Underscored */
#define IFIMETRICS_OVERSTRUCK  0x2000  /*Overstruck */

/* bit-constant for fsSelection in IFIMETRICS valid for bitmap fonts */

#define IFIMETRICS_NEGATIVE    0x1000   /*Negative image */
#define IFIMETRICS_HOLLOW      0x0800   /*Outline (hollow) */


typedef struct _IFIMETRICS {   /* ifim */
                                                                    /* UNITS */
  UCHAR   szFamilyname[FACESIZE];   /*Font Family Name, e.g. Roman */
  UCHAR   szFacename[FACESIZE];     /*Face name, e.g. Tms Rmn Bold Italic */
  UCHAR   szGlyphlistName[GLYPHNAMESIZE]; /*e.g. PM316, Latin-2, Greek */
  USHORT  idRegistry;          /*Dummy                                     I */
  SHORT   sCapEmHeight;        /*Height of uppercase M                     N */
  SHORT   sXHeight;            /*Nominal height of lowercase               N */
  SHORT   sMaxAscender;        /*Maximum height above baseline of any char N */
  SHORT   sMaxDescender;       /*Maximum depth below baseline of any char  N */
  SHORT   sLowerCaseAscent;    /*Maximum height above baseline of any a-z  N */
  SHORT   sLowerCaseDescent;   /*Maximum depth below basiline of any a-z   N */
  SHORT   sInternalLeading;    /*White space within character              N */
  SHORT   sExternalLeading;    /*White space between lines                 N */
  SHORT   sAveCharWidth;       /*Weighted average character width          N */
  SHORT   sMaxCharInc;         /*Maximum character increment               N */
  SHORT   sEmInc;              /*Increment for Capitals (typically 'M')    N */
  SHORT   sMaxBaselineExt;     /*Height of character cell                  N */
  FIXED   fxCharSlope;         /*Slope angle, degrees, clockwise           D */
  FIXED   fxInlineDir;         /*Drawing direction, degrees clockwise      D */
  FIXED   fxCharRot;           /*Glyph rotation in cell, degrees clockwise D */
  USHORT  usWeightClass;       /*Character weight, 1-9 (1=ultra-light)     I */
  USHORT  usWidthClass;        /*Character width, 1-9 (1=ultra condensed)  I */
  SHORT   sEmSquareSize;       /*Em Square size, x-direction               N */
  GLYPH   giFirstChar;         /*Number of first glyph in font             I */
  GLYPH   giLastChar;          /*Number of last glyph in font              I */
  GLYPH   giDefaultChar;       /*Glyph used if requested glyph invalid     I */
  GLYPH   giBreakChar;         /*Space glyph                               I */
  ULONG   aulPanose [1];       /*Panose Number */
  USHORT  usNominalPointSize;  /*Point size for which font was designed    N */
  USHORT  usMinimumPointSize;  /*Minimum point size scaling for font       N */
  USHORT  usMaximumPointSize;  /*Maximum point size scaling for font       N */
  USHORT  fsType;              /*Type indicators  (see #defines)           B */
  USHORT  fsDefn;              /*Font definition data (see #defines)       B */
  USHORT  fsSelection;         /*Font selection flags (see #defines)       B */
  USHORT  fsCapabilities;      /*Font capabilities must be 0               B */
  SHORT   sSubscriptXSize;     /*Size in x-direction of subscript          N */
  SHORT   sSubscriptYSize;     /*Size in y-direction of subscript          N */
  SHORT   sSubscriptXOffset;   /*Offset in x-direction of subscript        N */
  SHORT   sSubscriptYOffset;   /*Offset in y-direction of subscript        N */
  SHORT   sSuperscriptXSize;   /*Size in x-direction of superscript        N */
  SHORT   sSuperscriptYSize;   /*Size in y-direction of superscript        N */
  SHORT   sSuperscriptXOffset; /*Offset in x-direction of superscript      N */
  SHORT   sSuperscriptYOffset; /*Offset in y-direction of superscript      N */
  SHORT   sUnderscoreSize;     /*Underscore size                           N */
  SHORT   sUnderscorePosition; /*Underscore position                       N */
  SHORT   sStrikeoutSize;      /*Strikeout size                            N */
  SHORT   sStrikeoutPosition;  /*Strikeout position                        N */
  SHORT   cKerningPairs;       /*Number of kerning pairs in pair table     I */
  ULONG   ulFontClass;         /*IBM font classification                   B */
} IFIMETRICS, NEAR * NPIFIMETRICS, FAR * LPIFIMETRICS;

#ifdef ENABLE_CONTROL_TAG

/* Tag structure for Fd(i)Control */
typedef struct {
        USHORT SubFunction;
        LPDEVICE lpDevice;
        LPFONTINFO lpFontStructure;
        LPTEXTXFORM lpXform;
        LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#else
typedef struct {
        USHORT SubFunction;
        LPVOID lpDevice;
        LPVOID lpFontStructure;
        LPVOID lpXform;
        LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#endif

#endif


/****************************************/
/* Attribute bits for FdOpenFontContext */
/****************************************/
#ifndef WIFEH_NOWIFEMAN_EUDCFONTCONTEXT
#define OFC_EUDC_CONTEXT (0x80000000L)
#endif


#ifdef WIFE_CREATE_FONTDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in FONT DRIVER */
/***********************************************/

LONG FAR PASCAL FdClaimFontFile( LPSTR lpszFileName );

LONG FAR PASCAL FdConvertFontFile(
        LPSTR lpszSrcFileName,
        LPSTR lpszDestDirName,
        LPSTR lpszResultPackName
);
HFF FAR PASCAL FdLoadFontFile( LPSTR lpszPackName );

LONG FAR PASCAL FdUnloadFontFile( HFF hFF );

LONG FAR PASCAL FdQueryFaces(
        HFF hFF,
        LPIFIMETRICS lpIfiMetrics,
        ULONG cMetricLen,
        ULONG cFontCount,
        ULONG cStart
);

HFC FAR PASCAL FdOpenFontContext( HFF hFF, ULONG ulFont );

LONG FAR PASCAL FdSetFontContext(
        HFC hFC,
        LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdCloseFontContext( HFC hFC );

LONG FAR PASCAL FdQueryFaceAttr(
        HFC       hFC,
        ULONG     iQuery,
        LPVOID    lpBuffer,
        ULONG     cb,
        LPVOID    lpIndex,
        SHORT     Start
);

LONG FAR PASCAL FdQueryCharAttr(
        HFC        hFC,
        LPCHARATTR lpCharAttr,
        LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdControl(
        HFC hFC,
        LPCONTROLTAG lpControlTag,
        LPVOID lpOutData
);


/******************************************/
/*       FAR PTR TO EACH FUNCTION         */
/******************************************/
typedef LONG (FAR PASCAL * LPFDCLF)( LPSTR lpszFileName );

typedef LONG (FAR PASCAL * LPFDCFF)(
        LPSTR lpszSrcFileName,
        LPSTR lpszDestDirName,
        LPSTR lpszResultPackName
);

typedef HFF (FAR PASCAL * LPFDLFF)( LPSTR lpszPackName );

typedef LONG (FAR PASCAL * LPFDQF)(
        HFF hFF,
        LPIFIMETRICS lpIfiMetrics,
        ULONG cMetricLen,
        ULONG cFontCount,
        ULONG cStart
);

typedef LONG (FAR PASCAL * LPFDUFF)( HFF hFF );

typedef HFC (FAR PASCAL * LPFDOFC)( HFF hFF, ULONG ulFont );

typedef LONG (FAR PASCAL * LPFDSFC)(
        HFC hFC,
        LPCONTEXTINFO lpContextInfo
);

typedef LONG (FAR PASCAL * LPFDCFC)( HFC hFC );

typedef LONG (FAR PASCAL * LPFDQFA)(
        HFC       hFC,
        ULONG     iQuery,
        LPVOID    lpBuffer,
        ULONG     cb,
        LPVOID    lpIndex,
        SHORT     Start
);

typedef LONG (FAR PASCAL * LPFDQCA)(
        HFC        hFC,
        LPCHARATTR lpCharAttr,
        LPBITMAPMETRICS lpbmm
);

typedef SHORT (FAR PASCAL * LPFDCTL)(
        HFC hFC,
        LPCONTROLTAG lpControlTag,
        LPVOID lpOutData
);

typedef struct _FDHEADER { /* fdhdr */
        ULONG   cbLength;            /* Length of FDHEADER */
        UCHAR   strId[16];           /* String 'WIFE FONT DRIVER' */
        UCHAR   szTechnology[40];    /* Identifier of Font Driver technology */
        ULONG   ulVersion;           /* IFI version number (0x0100) */
        ULONG   ufDeviceCaps;        /* Capabilities of device */
        NPVOID  npfddisp;
        SHORT   dummy1;
} FDHEADER, NEAR * NPFDHEADER, FAR * LPFDHEADER;

#endif

#define WIFE_CREATE_DEVICEDRIVER
#ifdef WIFE_CREATE_DEVICEDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in WIFEMAN.DLL */
/***********************************************/

/***********************************************/
/*         Module Install Manager              */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MIM

typedef BOOL (FAR PASCAL * LPCBMEAD)
                ( LPSTR lpszFoundFileName, LPSTR lpszDescriptionName );
BOOL FAR PASCAL MimEnumAvailableDrivers
                        ( LPSTR lpszSeachFilePath, LPCBMEAD lpfCallBack );

typedef BOOL (FAR PASCAL * LPCBMEAP)
                ( HFD hFD, LPSTR lpszPackName );
BOOL FAR PASCAL MimEnumAvailablePacks
        ( HFD hFD, LPSTR lpszPackName, LPCBMEAP lpfCallBack );

HFD FAR PASCAL MimAddFontDriver( LPSTR lpszFileName );

HFF FAR PASCAL MimAddFontPack( HFD hFD, LPSTR lpszPackName );

BOOL FAR PASCAL MimRemoveFontDriver( HFD hFD );

BOOL FAR PASCAL MimRemoveFontPack( HFD hFD, HFF hFontPack );

HFD FAR PASCAL MimEnumFontDrivers( HFD hLastDriver );

HFF FAR PASCAL MimEnumFontPacks( HFD hFD, HFF hLastPack );

HFC FAR PASCAL MimOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont );

LONG FAR PASCAL MimCloseFontContext( HFD hFD, HFF hFF, HFC hFC );

typedef enum {
        MIMGETINFO_FD_DESCRIPTION = 0,
        MIMGETINFO_FF_DESCRIPTION = 1,
        MIMGETINFO_FD_FILENAME = 2,
        MIMGETINFO_FF_FILENAME = 3,
        MIMGETINFO_FD_USAGE = 4,
        MIMGETINFO_FF_USAGE = 5,
        MIMGETINFO_FD_INSTALL_COUNT = 6,
        MIMGETINFO_FF_INSTALL_COUNT = 7
} MIMGETINFO_ORDER;

SHORT FAR PASCAL MimGetInformations(
        MIMGETINFO_ORDER order,
        HFD hFD,
        HFF hFF,
        LPVOID AnswerBuffer,
        USHORT SizeOfBuffer
);

#endif

/***********************************************/
/*         Font Driver Interface               */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_FDI

LONG FAR PASCAL  FdiClaimFontFile( HFD hFD, LPSTR lpszFileName );

LONG FAR PASCAL FdiConvertFontFile(
        HFD hFD,
        LPSTR lpszSrcFileName,
        LPSTR lpszDestDirName,
        LPSTR lpszResultPackName
);

HFF FAR PASCAL FdiLoadFontFile( HFD hFD, LPSTR lpszPackName );

LONG FAR PASCAL FdiUnloadFontFile( HFD hFD, HFF hFF );

LONG FAR PASCAL FdiQueryFaces(
        HFD hFD,
        HFF hFF,            // Font File handle
        LPIFIMETRICS lpIfiMetrics,   // Buffer for the metrics
        ULONG cMetricLen,    // Length of the metrics structure
        ULONG cFontCount,    // # of fonts wanted.
        ULONG cStart         // index of the font to start with
);

HFC FAR PASCAL FdiOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont );

LONG FAR PASCAL FdiSetFontContext(
        HFD hFD,
        HFC hFC,
        LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdiCloseFontContext( HFD hFD, HFC hFC );

LONG FAR PASCAL FdiQueryFaceAttr(
        HFD hFD,
        HFC       hFC,
        ULONG     iQuery,
        LPVOID    lpBuffer,
        ULONG     cb,
        LPVOID    lpIndex,
        SHORT     Start
);

LONG FAR PASCAL FdiQueryCharAttr(
        HFD hFD,
        HFC        hFC,
        LPCHARATTR lpCharAttr,
        LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdiControl(
        HFD hFD,
        HFC hFC,
        LPCONTROLTAG lpControlTag,
        LPVOID lpOutData
);

#endif

/***********************************************/
/*         Font Cacheing Manager               */
/***********************************************/
#ifdef WIFE_ENABLE_FCM

#define FCM_WIFE_CHARACTER 1
#define FCM_CLIP_OUT 2
#define FCM_LEFT_CLIP 0x0100
#define FCM_RIGHT_CLIP 0x0200
#define FCM_TOP_CLIP 0x0400
#define FCM_BOTTOM_CLIP 0x0800

typedef struct {
        USHORT  SizeOfStruct;   /* size of structire */
        WORD    WifeFlag;       /* FCM processing flags */
        UBCHAR  ubCode;         /* character code */
        LPSTR   lpCacheBuffer; /* long ptr to cache bitmap */
        SHORT   nBitWidth;      /* x size of character image */
        SHORT   nBitHeight;     /* y size of character image */
        SHORT   nByteWidth;     /* byte width size in alloctaed buffer */
        USHORT  InternalIndex;  /* RESERVED FOR SYSTEM USE */
} FCM_CHARACTERISTIC, NEAR *NP_FCM_CHARACTERISTIC, FAR *LP_FCM_CHARACTERISTIC;

typedef struct {
        USHORT  SizeOfStruct;   /* size of structire */
        WORD    WifeFlag;       /* FCM processing flags */
        UBCHAR  ubCode;         /* character code */
        LPSTR   lpCacheBuffer; /* long ptr to cache bitmap */
        SHORT   nBitWidth;      /* x size of character image */
        SHORT   nBitHeight;     /* y size of character image */
        SHORT   nByteWidth;     /* byte width size in alloctaed buffer */
        USHORT  InternalIndex;  /* RESERVED FOR SYSTEM USE */

        SHORT   xPosOnDst;      /* x position on dst device */
        SHORT   yPosOnDst;      /* y position on dst device */

} FCM_EXTCHARACTERISTIC,
        NEAR * NP_FCM_EXTCHARACTERISTIC, FAR * LP_FCM_EXTCHARACTERISTIC;


HFB FAR PASCAL FcmCreateCacheBuffer(
        HFD hFD,
        HFF hFF,
        ULONG ulFont,
        LPTEXTXFORM lpXform,
        USHORT usMinorCharSet,
        USHORT usAttribute
);

BOOL FAR PASCAL FcmDeleteCacheBuffer( HFB hFontBuffer );

SHORT FAR PASCAL FcmRequestImages(
        HFB hFontBuffer,
        LP_FCM_CHARACTERISTIC AnswerBuffer,
        short length
);

BOOL FAR PASCAL FcmReleaseImages(
        HFB hFontBuffer,
        LP_FCM_CHARACTERISTIC AnswerBuffer,
        short length
);

HFB FAR PASCAL FcmRequestDefaultFB(
        LPFONTINFO lpFont,
        LPTEXTXFORM lpTextXform
);

BOOL FAR PASCAL FcmReleaseDefaultFB( HFB hFB );

#define FCMCALC_BIGFONT 1
#define FCMCALC_ROUGHCLIPINFO 2
#define FCMCALC_DETAILCLIPINFO 4

DWORD FAR PASCAL FcmCalculateTextExtent(
        HFB         hFB,
        LPSTR       lpString,
        short       count,
        LPFONTINFO  lpFont,
        LPDRAWMODE  lpDrawMode,
        LPTEXTXFORM lpXform,
        LPSHORT     lpCharWidths,
        USHORT      usMode
);

SHORT FAR PASCAL FcmCalculateOutputPositions(
        HFB             hFB,
        LP_FCM_EXTCHARACTERISTIC lpFcmCharacteristics,
        SHORT           nArrayLength,
        LPSHORT         lpx,
        LPSHORT         lpy,
        LPRECT          lpClipRect,
        LPSTR           FAR * lplpString,
        LPSHORT         lpcount,
        LPFONTINFO      lpFont,
        LPDRAWMODE      lpDrawMode,
        LPTEXTXFORM     lpXform,
        LPSHORT         FAR * lplpCharWidths,
        USHORT          usMode
);


SHORT FAR PASCAL FcmCleanUp( VOID );

HFB FAR PASCAL FcmEnumFontBuffers( HFB hLastBuffer );

HFC FAR PASCAL FcmGetFontContext( HFB hFB );

SHORT FAR PASCAL FcmCalcByteWidth( SHORT nBitWidth );

SHORT FAR PASCAL FcmForceCacheIn( HFB hFB, LPUBCHAR lpubStr );

BOOL FAR PASCAL FcmValidateFC( HFB hFB );

BOOL FAR PASCAL FcmUnvalidateFC( HFB hFB );

LONG FAR PASCAL FcmQueryFaceAttr(
        HFB         hFB,
        ULONG       iQuery,
        LPABC_TRIPLETS  lpBuffer,
        ULONG       cb,
        LPUBCHAR    lpIndex,
        UBCHAR      Start
);

#ifdef WIFE_ENABLE_FCM_CONTROL

SHORT FAR PASCAL FcmIsProcessableDeviceControl(
        HFB hFB,
        SHORT nFunction,
        GAIJIINFO FAR * lpGI
);

SHORT FAR PASCAL FcmProcessDeviceControl(
        HFB hFB,
        SHORT nFunction,
        GAIJIINFO FAR * lpGI,
        LPVOID lpOutData
);

#endif

USHORT FAR PASCAL FcmGetEUDCLeadByteRange( HFB hFB );

HFB FAR PASCAL FcmGetEUDCFB( HFB hFB );

USHORT FAR PASCAL FcmGetCharWidth(
        HFB         hFB,
        LPUSHORT    lpBuffer,
        USHORT      wFirstChar,
        USHORT      wLastChar,
        LPFONTINFO  lpFont,
        LPDRAWMODE  lpDrawMode,
        LPTEXTXFORM lpFontTrans,
        USHORT      usExpandPixels,
        USHORT      usMode
);

#endif

#endif

/***********************************************/
/*  WIFEMAN's Miscellaneous Service Functions  */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MISC

BOOL FAR PASCAL MiscIsDBCSLeadByte( CHAR_SET CharSet, USHORT ch );

#define MiscIsMBCSCharSet(c) (MiscIsDBCSLeadByte(c,0xffff))

VOID FAR PASCAL MiscSetErroInfo( ULONG ErrorCode );

ULONG FAR PASCAL MiscGetErroInfo( VOID );

SHORT FAR PASCAL MiscWarningMessage(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        USHORT mode
);

SHORT FAR PASCAL MiscWarningMessageWithArgument(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        LPSTR lpszArgument,
        USHORT mode
);

#ifdef ENABLE_MESSAGEBOX

/* MessageBox() Flags */
#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F
#define MB_ICONMASK         0x00F0
#define MB_DEFMASK          0x0F00
#define MB_MODEMASK         0x3000
#define MB_MISCMASK         0xC000

#endif /* ENABLE_MESSAGEBOX */

USHORT FAR PASCAL ubstrlen( LPUBCHAR cp );

LPUBCHAR FAR PASCAL ubstrcpy( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncpy( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

LPUBCHAR FAR PASCAL ubstrcat( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncat( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

SHORT FAR PASCAL ubstrcmp( LPUBCHAR str1, LPUBCHAR str2 );

USHORT FAR PASCAL AscizToUz(
        LPUBCHAR dst,
        LPSTR src,
        USHORT limit,
        CHAR_SET CharSet
);

USHORT FAR PASCAL UzToAsciz(
        LPSTR dst,
        LPUBCHAR src,
        USHORT limit
);

VOID FAR PASCAL MiscTrancateString(
        LPSTR lpszStr,
        SHORT length,
        SHORT CharSet
);

#define MiscTrancateByDefaultCharSet(s,l) MiscTrancateString(s,l,-1)

ULONG FAR PASCAL MiscGetVersion( VOID );

USHORT FAR PASCAL MiscGetEUDCLeadByteRange( CHAR_SET csCharSet );

BYTE FAR PASCAL MiscConvertFontFamily( LPSTR szFamilyName );

BYTE FAR PASCAL MiscConvertCharSet( LPSTR CharSetString );

#ifdef WIFE_ENABLE_FONT_STRUCT_CONVERT

/* follow two values are only for usLogicalMapFlag parameter */
/* in MiscIfiMetricsToLogFont function.  */
#define LOGMAP_IGNORE_DESCENT 1
#define LOGMAP_IGNORE_INTERNAL_LEADING 2
#define LOGMAP_NEGATIVE (0x8000)

VOID FAR PASCAL MiscIfiMetricsToLogFont(
        LPLOGFONT lpLogFont,
        LPIFIMETRICS lpIFIMetrics,
        USHORT usLogicalMapFlag
);

VOID FAR PASCAL MiscIfiMetricsToTextMetrics(
        LPTEXTMETRIC lpTextMetrics,
        LPIFIMETRICS lpIFIMetrics
);

#endif

#ifdef WIFE_ENABLE_FONT_STRUCT_MAKE

VOID FAR PASCAL MiscMakeTextXform(
        LPTEXTXFORM lpTXF,
        LPIFIMETRICS lpIM,
        LPLOGFONT lpLF
);

#endif

#ifndef WIFEH_NO_HUGE_SUPPORT
LPVOID FAR PASCAL MiscAddHugePtr( LPVOID src, ULONG offset );
USHORT FAR PASCAL MiscGetSegmentIncrement( VOID );
#endif

#ifndef WIFEH_NO_CONTROL_RANGES
BOOL FAR PASCAL MiscIsWifeControl( SHORT function );
BOOL FAR PASCAL MiscIsGaijiControl( SHORT function );
#endif

#ifndef WIFEH_NO_STRETCHER
BOOL FAR PASCAL MiscStretchMonoFontImage(
        LPVOID  lpDestImage,
        USHORT  usSizeOfDestX,
        USHORT  usSizeOfDestY,
        LPVOID  lpSrcImage,
        USHORT  usSizeOfSrcX,
        USHORT  usSizeOfSrcY
);
#endif

#define WIFE_ENABLE_QUICK_SEARCH_TABLE
#ifdef WIFE_ENABLE_QUICK_SEARCH_TABLE

typedef struct {
        HFD hFD;
        HFF hFF;
        ULONG ulFont;
        BOOL bScalable;
        LOGFONT LogFont;
}QUICK_SEARCH_TABLE, NEAR * NP_QUICK_SEARCH_TABLE, FAR * LP_QUICK_SEARCH_TABLE;

LP_QUICK_SEARCH_TABLE FAR PASCAL MiscValidateQuickSearchTable(
        USHORT usLogicalMapFlag
);

BOOL FAR PASCAL MiscUnvalidateQuickSearchTable(
        USHORT usLogicalMapFlag
);

typedef LP_QUICK_SEARCH_TABLE (FAR PASCAL * LPMISCVALIDATEQST)(
        USHORT usLogicalMapFlag
);

typedef BOOL (FAR PASCAL * LPMISCUNVALIDATEQST)(
        USHORT usLogicalMapFlag
);

#define NMISCVALIDATEQST (67)
#define NMISCUNVALIDATEQST (68)

#endif

#ifdef WIFE_ENABLE_NOTIFY_FUNCTIONS

typedef enum {
        WN_ADD_FONTDRIVER = 0,
        WN_ADD_FONTPACKAGE = 1,
        WN_REMOVE_FONTDRIVER = 2,
        WN_REMOVE_FONTPACKAGE = 3,
        WN_REGISTER_SYSTEM_EUDC_CHAR = 4,
        WN_CHANGE_SYSTEM_EUDC_FILE = 5
} WIFENOTIFY_ORDER;

typedef struct {
        HFD hTargetFontDriver;
} WNS_FONTDRIVER;

typedef struct {
        HFD hTargetFontDriver;
        HFF hTargetFontPackage;
} WNS_FONTPACKAGE;

typedef struct {
        HFD hTargetFontDriver;
        HFF hTargetFontPackage;
        UBCHAR ubRegistedCharCode;
} WNS_REGISTER_SYSTEM_EUDC_CHAR;

typedef struct {
        HFD hTargetFontDriver;
        HFF hTargetFontPackage;
        LPSTR lpszNewFileName;
} WNS_WN_CHANGE_SYSTEM_EUDC_FILE;

typedef BOOL (FAR PASCAL * LPNOTIFYCALLBACKFUNC)(
        WIFENOTIFY_ORDER NotifyOrder,
        LPVOID lpParamBlock
);

BOOL FAR PASCAL MiscRegisterNotifyFunction(
        LPNOTIFYCALLBACKFUNC lpfnCallBack
);

BOOL FAR PASCAL MiscUnregisterNotifyFunction(
        LPNOTIFYCALLBACKFUNC lpfnCallBack
);

#endif

#ifdef WIFE_ENABLE_REALIZE_FUNCTIONS

WORD FAR PASCAL MiscRealizeWifeFont(
        LPLOGFONT lpLogFont,
        LPFONTINFO lpExtFont,
        LPTEXTXFORM lpTextXform
);

BOOL FAR PASCAL MiscDeleteWifeFont(
        LPFONTINFO lpExtFont
);

#endif

#endif


/***********************************************/
/*    DIAGNOSTIC TEST&CHECKING FUNCTIONS       */
/***********************************************/
#ifdef ENABLE_DIAGNOSTIC_FUNCTION

/* test and return error code  */
SHORT FAR PASCAL DiagSelfCheck( VOID );

/* invoke self test and make error record file, display warning dialog */
SHORT FAR PASCAL DiagSelfCheckAndWarning( VOID );

#endif


/************************************************/
/* THESE ARE PRIVATE INTERFACE FOR TEST PROGRAM */
/************************************************/
#ifdef ENABLE_TEST_PROGRAM_INTERFACE

LPVOID FAR PASCAL DiagLocalLockAnything( LOCALHANDLE hAny );
LPVOID FAR PASCAL DiagLocalUnlockAnything( LOCALHANDLE hAny );
SHORT FAR PASCAL DiagGetConfirmString( LPSTR buffer, SHORT length );

#endif

//////  for WOW ///////////

#define IDS_NOTSUPORTFUNCTION	200
#define IDS_WIFETITLE           201


/* end of wife.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..
    nmake  /fmakefile.sub \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
     ALT_PROJECT=usa \
	 DBCS_FLAGS="-DFE_SB"
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\87emstar.asm ===
;-------------------------------------------------------
;
;  pull in the Windows start up module;
;  pull in the Windows floating-point emulator;
;
;  9876h value is so that the symbol defined won't easily match
;  a constant value in the debugger.
;
public	__acrtused
	__acrtused = 9876h	
extrn	__acrtused2:abs		; pull in winstart: ?winstar.obj or ?libstar.obj

public	__fptaskdata
	__fptaskdata = 9876h	; stub out __fptaskdata so that
				; non-Windows emulator is not brought in

extrn	__fpmath:far		; force in Windows-emulator imports definition

extrn	__fpsignal:far		; force in Windows version of __fpsignal

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wifeman\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\em386.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	em386.asm - Main Entry Point and Address Calculation Procedure
page
;*********************************************************************;
;								      ;
;	  Main Entry Point and Address Calculation Procedure	      ;
;								      ;
;		80386 version					      ;
;								      ;
;*********************************************************************;
;
; This routine fetches the 8087 instruction, calculates memory address
; if necessary into ES:ESI and calls a routine to emulate the instruction.
; Most of the dispatching is done through tables. (see comments in CONST)
;
; The instruction dispatching is designed to favor the 386 addressing modes

ifdef	XENIX

LDT_DATA=	02Fh		; emulator data LDT
STACK_ALIAS=	027h		; 32 bit alias for stack selector

endif	;XENIX

;------------------------------------------------------------------------------
;
;	emulation entry point
;
;------------------------------------------------------------------------------

pub	protemulation

	cld				; clear direction flag forever

ifdef	XENIX
	push	ss			; save ss
endif	;XENIX

	push	eax			; for common exit code (historical)

	push	ds			; save segment registers

ifdef	XENIX

	push	eax			; UNDONE - slow

	mov	ax,LDT_DATA		; load up emulator's data segment
	mov	ds,ax
	cmp	[Einstall],0		; check if emulator is initialized
	je	installemulator 	;   no - go install it

pub	protemcont

	pop	eax			; UNDONE - slow

endif	;XENIX

	push	es
	push	ss			;   save SegOvr (bp forces SS override)

	push	edi			; save registers
	push	esi			;   must be in this order for indexing
	push	ebp
	push	esp
	push	ebx
	push	edx
	push	ecx
	push	eax

ifdef	XENIX

	mov	ax,ss			; check for 286 using user SS
	lar	eax,ax			; load extended access bits
	test	eax,00400000h		; test BIG bit
	jnz	short prot386		;   386 - ok

	mov	ax,STACK_ALIAS		; setup stack with 32 bit alias segment
	mov	ss,ax
	movzx	esp,sp			; clean up ESP
;	mov	word ptr [esp].regEIP+2,0 ; clean up EIP

pub	prot386

endif	;XENIX

	mov	ebp,esp 		; set up frame pointer
	add	[ebp].regESP,regFlg-regESP	; adjust to original esp

	mov	eax,edi 		; may use original DI to calc address
	lds	edi,fword ptr [ebp].regEIP ; ds:edi = 287 instruction address
	mov	cx,[edi]		; cx = esc 0-7 and opcode

	cmp	cl,09Bh 		; UNDONE - check FWAIT's getting through
	je	sawFWAIT		; UNDONE -   and ignore it

	add	edi,2			; point to displacement
	add	cl,28h			; set carry if esc 0-7 (and cl = 0-7)
	jnc	short protSegOvr	;   no carry - must be segment override

	mov	es,[ebp].regDS		; es = user data segment
	mov	edx,ebx 		; may use original BX to calc address

pub	CommonDispatch
	rol	ch,2			; rotate MOD field next to r/m field


; UNDONE
; UNDONE  should check for instruction prefixes such as address size prefix
; UNDONE

	lar	ebx,[ebp].regCS 	; check if 286 or 386 segment
	test	ebx,00400000h		;
	mov	bl,ch			; get copy of operation
	jz	short Have286segment	;   286 segment - assume 286 addressing

	and	ebx,1FH 		; Mask to MOD and r/m fields
	jmp	EA386Tab[4*ebx]

pub	Have286segment
	and	ebx,1FH 		; Mask to MOD and r/m fields
	jmp	EA286Tab[4*ebx]


;	protect mode Segment override case

glb	<protSegOvrTab>

protSegOvrTab	label	word

	dd	DSSegOvr	; 11
	dd	ESSegOvr	; 00
	dd	CSSegOvr	; 01
	dd	SSSegOvr	; 10


pub	protSegOvr
	mov	edx,ebx 		; may use original BX to calc 286 address
	mov	bl,cl
	shr	bl,1
	and	ebx,0Ch 		; bl = (seg+1) and 0Ch
	inc	edi			; point to displacement
	mov	cx,[edi-2]		; cx = esc 0-7 and opcode
	jmp	protSegOvrTab[ebx]	; process appropriate segment override


pub	DSSegOvr			; 00
	mov	es,[ebp].regDS		; set ES to EA segment
	jmp	short ESSegOvr

pub	CSSegOvr			; 10
	push	ds			; DS = caller's CS
	pop	es			; set ES to EA segment
	jmp	short ESSegOvr

pub	SSSegOvr			; 01
	push	ss			; SS = caller's SS
	pop	es			; set ES to EA segment

pub	ESSegOvr			; 11
	mov	[ebp].regSegOvr,es	; save for bp rel EAs
	jmp	CommonDispatch


;	386 address modes

;	SIB does not handle SS overrides for ebp

SIB	macro	modval
	local	SIBindex,SIBbase

	xor	ebx,ebx
	mov	bl,[edi]		; ebx = SIB field
	inc	edi			; bump past SIB field
	mov	eax,ebx
	and	al,7			; mask down to base register

if	modval eq 0
	cmp	al,5			; base = ebp
	jne	short SIBbase		;   yes - get base register value
	mov	eax,[edi]		; eax = disp32
	add	edi,4			; bump past displacement
	jmp	short SIBindex
endif

SIBbase:
	mov	eax,[ebp+4*eax] 	; eax = base register value

SIBindex:
	mov	[ebp].regESP,0		; no esp indexing allowed
	push	ecx			; UNDONE - slow
	mov	cl,bl
	shr	cl,6			; cl = scale factor
	shr	bl,1
	and	bl,1Ch			; ebx = 4 * index register
	mov	esi,[ebp+ebx]		; esi = index register value
	shl	esi,cl			; esi = scaled index register value
	pop	ecx			; UNDONE - slow
	add	esi,eax 		; esi = SIB address value
	endm


pub	SIB00
	SIB	00			; decode SIB field
	jmp	CommonMemory

pub	SIB01
	SIB	01			; decode SIB field
	mov	al,[edi]
	inc	edi
	cbw				; ax = al
	cwde				; eax = ax
	add	esi,eax
	jmp	short CommonMemory

pub	SIB10
	SIB	10			; decode SIB field
	mov	eax,[edi]
	add	edi,4
	add	esi,eax
	jmp	short CommonMemory


;	386 single register addressing

pub	Exx00
	and	bl,1Ch			; mask off mod bits
	mov	esi,[ebp+ebx]
	jmp	short CommonMemory

pub	Exx01
	and	bl,1Ch			; mask off mod bits
	mov	esi,[ebp+ebx]
	mov	al,[edi]
	inc	edi
	cbw				; ax = al
	cwde				; eax = ax
	add	esi,eax
	jmp	short CommonMemory

pub	Exx10
	and	bl,1Ch			; mask off mod bits
	mov	esi,[ebp+ebx]
	mov	eax,[edi]
	add	edi,4
	add	esi,eax
	jmp	short CommonMemory


;	386 direct addressing

pub	Direct386
	mov	esi,[edi]
	add	edi,4

pub	CommonMemory
	MOV	[ebp].regEIP,edi	; final return offset
	mov	ax,LDT_DATA
	mov	ds,ax
	mov	[CURerr],MemoryOperand	; clear current error, set mem. op bit

; At this point ES:SI = memory address, CX = |Op|r/m|MOD|escape|MF|Arith|

	shr	ch,4			; Move Op field to BX for Table jump
	mov	bl,ch
	and	ebx,0EH

	test	cl,1			; Arith field set?
	JZ	short ArithmeticOpMem

pub	NonArithOpMem
	CALL	NonArithOpMemTab[2*ebx] ; is CH shl 4 needed?
	JMP	EMLFINISH

pub	ArithmeticOpMem
	PUSH	ebx			; Save Op while we load the argument
	CALL	eFLDsdri		; emulate proper load
	POP	ebx

	mov	ax,ds			; ES = DS = task data area
	mov	es,ax
	MOV	esi,[CURstk]		; address top of stack
	MOV	edi,esi
	ChangeDIfromTOStoNOS
	MOV	[RESULT],edi		; Set up destination Pointer

	JMP	short DoArithmeticOpPop


pub	NoEffectiveAddress		; Either Register op or Miscellaneous

	MOV	[ebp].regEIP,edi	; final return offset

	xor	eax,eax
	mov	di,LDT_DATA
	mov	ds,di
	mov	es,di
	mov	[CURerr],ax		; clear current error, memory op bit

; CX = |Op|r/m|MOD|escape|MF|Arith|

	mov	bl,ch
	shr	bl,4			; Mov Op field to BX for jump
	and	ebx,0Eh

	TEST	CL,1			; Arith field set?
	JZ	short ArithmeticOpReg

pub	NonArithOpReg
	CALL	NonArithOpRegTab[2*ebx]
	JMP	EMLFINISH


; For register arithmetic operations, one operand is always the stack top.
; The r/m field of the instruction is used to determine the address of
; the other operand (ST(0) - ST(7))
; CX = xxxRRRxxxxxxxxxx (x is don't care, RRR is relative register # 0-7)

pub	ArithmeticOpReg

	call	RegAddr 		;di <= address of 2nd operand
					;carry set if invalid register
	jc	short InvalidOperand	;no, invalid operand, don't do operation

	MOV	[RESULT],esi		; Set destination to TOS
	TEST	CL,04H			; Unless Dest bit is set
	JZ	short DestIsSet 	; in which case
	MOV	[RESULT],edi		; Set destination to DI

pub	DestIsSet
					; Need to Toggle Reverse bit for DIV or SUB
	TEST	BL,08H			; OP = 1xx for DIV and SUB; BX = |0000|OP|O|
	JZ	short SetUpPop
	XOR	BL,02H			; Toggle Reverse bit

pub	SetUpPop
	TEST	CL,02H
	JZ	short DoArithmeticOpNoPop

pub	DoArithmeticOpPop
	CALL	ArithmeticOpTab[2*ebx]

	POPST
	JMP	short EMLFINISH

pub	DoArithmeticOpNoPop
	CALL	ArithmeticOpTab[2*ebx]
	JMP	short EMLFINISH


;***	InvalidOperand - register operand does not exist
;
;	RETURNS
;		sets Stack Underflow and Invalid bits in [CURerr]
;
;	DESCRIPTION
;		a reference was made to a register that does not
;		exist on the stack.  Set error bits and exit.

pub	InvalidOperand

	call	UnderStk		;indicate stack underflow error
	or	[CURerr],Invalid	;indicate invalid operand
	jmp	short EMLFINISH 	;don't execute instruction


;***	RegAddr - compute register address
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m = register whose address is to be computed
;
;	RETURNS
;		SI = address of top of stack
;		DI = address of requested register
;		PSW.C set if register is not valid
;		PSW.C reset if register is valid
;
;	DESCRIPTION
;		multiply register number by 12 and subtract this from
;		[CURstk] (the address of TOS) to compute address of
;		register referenced by r/m.
;
;	REGISTERS
;		modifies dx

pub	RegAddr
	mov	esi,[CURstk]		; address top of stack
	mov	edi,esi

;set up address of 2nd operand based on r/m field of instruction

	xor	edx,edx
	mov	dl,ch			; dl <== byte containing reg#
	and	dl,01ch 		; mask all but r/m field

; Since r/m field contains the relative reg # in bits 2-4 of dl,
; and bits 0-1 of dl are zero, dl now contains 4*(reg #).  To compute
; the memory location of this register, calculate 12*(reg #) and
; subtract this from di, which contains the address of the TOS.  reg #
; is multiplied by 12 because that is the number of bytes in each stack
; entry.

	lea	edx,[2*edx+edx] 	; edx = 3 * (4 * reg #)
	sub	edi,edx 		; di is address of second operand
	cmp	edi,[BASstk]		; is register in range?
	clc				; assume valid register
	jg	short RAclc		; valid - skip next instruction
	cmc				; set carry to indicate invalid register
pub RAclc
	ret


pub	CallUnused
	CALL	UNUSED			; Treat as unimpleminted
	jmp	short EMLFINISH


;	sawFWAIT - UNDONE - workaround for a 386 bug

pub	sawFWAIT
	inc	edi			; bump past FWAIT
	MOV	[ebp].regEIP,edi	; final return offset
	xor	eax,eax
	mov	di,LDT_DATA
	mov	ds,di
	mov	[CURerr],ax		; clear current error, memory op bit

; return from routine;	restore registers and return

pub	EMLFINISH
	pop	eax
	pop	ecx
	pop	edx
	pop	ebx
	add	esp,4			; toss esp value
	pop	ebp
	pop	esi
	pop	edi
	add	esp,4			; toss regSegOvr

;	check for errors

	MOV	AX,[CURerr]		; fetch errors
	or	[UserStatusWord],ax	; save all exception errors
	OR	[SWerr],AL		; set errors in sticky error flag
	NOT	AL			; make a zero mean an error
	MOV	AH,byte ptr [UserControlWord]  ; get user's IEEE control word
	OR	AH,0C2H 		; mask reserved, IEM and denormal bits
	AND	AH,03FH 		; unmask invalid instruction,
					;    stack overflow.
	OR	AL,AH			; mask for IEEE exceptions
	NOT	AL			; make a one mean an error
	MOV	AH,byte ptr (CURerr+1)	; get stack over/underflow flags
	TEST	AX,0FFFFh-MemoryOperand ; test for errors to report

	pop	es
	pop	ds


	jnz	short ExceptionsEmulator ;   goto error handler

pub	errret
        error_return    noerror          ; common exit sequence

pub	ExceptionsEmulator
	JMP	CommonExceptions


;------------------------------------------------------------------------------
;
;	286 address modes	(for XENIX only)
;
;------------------------------------------------------------------------------

ifdef	XENIX

; In the address calculations below:
;   DX has BX original value
;   AX has DI original value
;   SI has SI original value
;   BP has BP original value
;  [EDI] is address of displacement bytes

pub BXXI0D
	MOV	eax,edx 		; use original BX index value
pub DSDI0D
	MOV	esi,eax 		; use alternate index value
pub DSSI0D
	JMP	short ADRFIN		; have offset in SI

pub BPXI1D
	XOR	eax,eax 		; no index register
pub BPDI1D
	MOV	esi,eax 		; use alternate index value
pub BPSI1D
	ADD	esi,[ebp].regEBP	; add original BP value
	mov	es,[ebp].regSegOvr	; ES = override segment (or SS if none)
	JMP	short DSSI1D		; go get one byte displacement

pub BXSI1D
	MOV	eax,esi 		; really will want SI, not DI
pub BXDI1D
	ADD	edx,eax 		; now DX is original BX plus index
pub BXXI1D
	MOV	eax,edx 		; use original BX index value
pub DSDI1D
	MOV	esi,eax 		; use alternate index value
pub DSSI1D
	MOV	AL,[edi]		; get one byte displacement
	CBW				; sign extend displacement
	INC	edi			; get past displacement byte
	JMP	short DISPAD		; go add AX to SI (time w/ ADD)

pub BPXI2D
	XOR	eax,eax 		; no index register
pub BPDI2D
	MOV	esi,eax 		; use alternate index value
pub BPSI2D
	ADD	esi,[ebp].regEBP	; add original BP value
	mov	es,[ebp].regSegOvr	; ES = override segment (or SS if none)
	JMP	short DSSI2D		; go get two byte displacement

pub BXSI2D
	MOV	eax,esi 		; really will want SI, not DI
pub BXDI2D
	ADD	edx,eax 		; now DX is original BX plus index
pub BXXI2D
	MOV	eax,edx 		; use original BX index value
pub DSDI2D
	MOV	esi,eax 		; use alternate index value
pub DSSI2D
	MOV	AX,[edi]		; get two byte displacement
	INC	edi			; get past displacement byte
	INC	edi			; get past displacement byte
	JMP	short DISPAD		; go add AX to SI (time w/ ADD)

pub DSXI2D
	MOV	SI,[edi]		; get two byte displacement
	INC	edi			; get past displacement byte
	INC	edi			; get past displacement byte
	JMP	short ADRFIN		; have offset in AX

pub BPSI0D
	MOV	eax,esi 		; really will want SI, not DI
pub BPDI0D
	MOV	edx,[ebp].regEBP	; really will want BP, not BX
	mov	es,[ebp].regSegOvr	; ES = override segment (or SS if none)
pub BXDI0D
	MOV	esi,eax 		; use alternate index value
pub BXSI0D
	MOV	eax,edx 		; use original BX (or BP) as base

pub DISPAD
	ADD	esi,eax 		; add original index value

pub	ADRFIN
	movzx	esi,si			; ES:ESI = user memory address
	jmp	CommonMemory

endif	;XENIX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emconst.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986-88
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emconst.asm - Constants
page
;*********************************************************************;
;								      ;
;		Constants					      ;
;								      ;
;*********************************************************************;

;	internally used constants

		EVEN


labelW	IEEEzero
    dw	    0,0,0,0		    ; Mantissa of 0
    dw	    IexpMin - IexpBias	    ; Smallest Exponent
    db	    0			    ; Sign positive, not single precision
    db	    ZROorINF		    ; Number is ZERO


labelW	IEEEinfinity
    dw	    0,0,0,0		    ; Mantissa of 0
    dw	    IexpMax - IexpBias	    ; Largest exponent
    db	    0			    ; Sign positive, not single precision
    db	    Special + ZROorINF


labelW	IEEEindefinite
    dw	    0,0,0,0C000H	    ; MSB Turned on in mantissa
    dw	    IexpMax - IexpBias	    ; Largest exponent
    db	    080H		    ; Sign negative, not single precision
    db	    Special


labelW	IEEEbiggest
    dw	    0FFFFH,0FFFFH,0FFFFH,0FFFFH     ; Turn on Mantissa
    dw	    IexpMax - IexpBias - 1	    ; Largest valid exponent
    db	    0			    ; Sign positive, not single precision
    db	    0			    ; Valid non-zero, non-special number



labelW IEEEinfinityS
    dw	    0, 7f80h		    ; Sign 0, Exp 1's, Mantissa 0


labelW	IEEEbiggestS
    dw	    0ffffh, 7f7fh	    ; Sign 0, Exp Max - 1, Mantissa 1's


labelW	IEEEinfinityD
    dw	    0, 0, 0		    ; Mantissa of 0
    dw	    7ff0h		    ; Largest exponent


labelW	IEEEbiggestD
    dw	    0ffffh, 0ffffh, 0ffffh  ; Turn on Mantissa
    dw	    7fefh		    ; Largest exponent - 1


;	transcendental constants

labelW	cFLDZ
    dw	    00000h, 00000h, 00000h, 08000h, IexpMin-IexpBias, 00100h

labelW	cFLD1
    dw	    00000h, 00000h, 00000h, 08000h, 00000h, 00000h


ifndef	frontend
ifndef	SMALL_EMULATOR


labelW	TWOMRT3
    dw	    0B18AH,0F66AH,0A2F4H,08930H,0FFFEH,00000H

labelW	RT3
    dw	    0539EH,0C265H,0D742H,0DDB3H,00000H,00000H

labelW	PIBY6
    dw	    02C23H,06B9BH,091C1H,0860AH,0FFFFH,00000H

labelW	RT2
    dw	    06484H,0F9DEH,0F333H,0B504H,00000H,00000H

labelW	TWO
    dw	    00000H,00000H,00000H,08000H,00001H,00000H

labelW	cFLDPI
    dw	    0C235H,02168H,0DAA2H,0C90FH,00001H,00000H

labelW	cFLDL2T
    dw	    08AFEH,0CD1BH,0784BH,0D49AH,00001H,00000H

labelW	cFLDL2E
    dw	    0F0BCH,05C17H,03B29H,0B8AAH,00000H,00000H

labelW	cFLDLG2
    dw	    0F799H,0FBCFH,09A84H,09A20H,0FFFEH,00000H

labelW	cFLDLN2
    dw	    079ACH,0D1CFH,017F7H,0B172H,0FFFFH,00000H


labelW	TANRAT
	dw	3
	dw	07BD4H,0D85AH,05C3EH,08F69H,00005H,00080H
	dw	04D37H,02CD7H,0D0F8H,0D6D4H,0000CH,00000H
	dw	0DCD3H,06617H,0BBEEH,082BAH,00012H,00080H
	dw	091CBH,05E58H,0868BH,0F506H,00014H,00000H
	dw	3
	dw	086E5H,00120H,00502H,09C79H,00009H,00080H
	dw	06663H,088CFH,0B270H,0C939H,0000FH,00000H
	dw	0FA96H,0C746H,00CFEH,0E4B7H,00013H,00080H
	dw	091CBH,05E58H,0868BH,0F506H,00014H,00000H


labelW	ATNRAT
	dw	4
	dw	05B32H,0CF08H,0A4C9H,0A650H,0FFFDH,00000H
	dw	0D1CEH,0D5CAH,0A84BH,0D0F0H,00002H,00000H
	dw	0899FH,0E22BH,052A8H,09C4AH,00005H,00000H
	dw	04265H,05550H,0E9CFH,090EFH,00006H,00000H
	dw	04B90H,024ADH,0E5E6H,0A443H,00005H,00000H
	dw	3
	dw	08310H,05638H,04F0AH,0F062H,00003H,00000H
	dw	0B4E7H,06D1EH,05190H,0EE50H,00005H,00000H
	dw	0243BH,05B6DH,09020H,0AC50H,00006H,00000H
	dw	04B90H,024ADH,0E5E6H,0A443H,00005H,00000H



labelW	EXPRAT
	dw	2
	dw	01898H,0F405H,006FCH,0F274H,00005H,00000H
	dw	0AD08H,014E1H,03D54H,0EC9BH,0000EH,00000H
	dw	05FAFH,0C3A3H,0D84AH,0FDF0H,00014H,00000H
	dw	2
	dw	0776FH,0387BH,0108BH,0DAA7H,0000AH,00000H
	dw	0E85DH,09B7BH,0B182H,0A003H,00012H,00000H
	dw	0837EH,0E709H,0F814H,0B72DH,00016H,00000H


labelW	LOGRAT
	dw	3
	dw	07704H,0C299H,057E2H,09B71H,0FFFEH,00000H
	dw	04F9CH,0F631H,05E35H,0DE91H,00004H,00080H
	dw	04B8AH,07AEAH,0C9EDH,0B2D3H,00008H,00000H
	dw	028C9H,01D09H,0E42FH,08AC4H,0000AH,00080H
	dw	2
	dw	076BBH,03E70H,0025BH,08EACH,00005H,00080H
	dw	0EF60H,0A933H,01FD0H,09C04H,00008H,00000H
	dw	0BB96H,06C83H,0F4E0H,0C05FH,00009H,00080H


endif	;not SMALL_EMULATOR
endif	;frontend
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\apisim.asm ===
title	OS2_STUB - OS/2 Simulation routines for DOS 3

;	These routines simulate family API routines for DOS 3
;
;	Routines which are never called under DOS 3 just return
;	popping the parameters.
;
;	87/04/24  SKS	DOSGETMACHINEMODE stores a Byte, not a Word!
;


memL=1			; simulate large model for returns
?PLM=1			; pascal calling conventions
?WIN=0			; no Windows

.xlist
	include  cmac_mrt.inc		; old, customized masm510 cmacros
.list
	include msdos.inc


sBegin	code
assumes cs,code


;	__DOSDEVCONFIG - return 8087/80287 indicator

cProc	__DOSDEVCONFIG,<PUBLIC>,<ES,BX>

	parmDP	devinfo
	parmW	devitem
	parmW	reserved

cbegin
	les	bx,devinfo
	mov	word ptr es:[bx],1	; assume have 287
	xor	ax,ax			; return no error
cend


;	__DOSGETMACHINEMODE - return real mode indicator

cProc	__DOSGETMACHINEMODE,<PUBLIC>,<ES,BX>

	parmDP	mode

cbegin
	les	bx,mode
	xor	ax,ax			; ax = return code and mode
	mov	es:[bx],al		; set machine mode to real
cend


;	__DOSSETVEC - never called under DOS 3.x

cProc	__DOSSETVEC,<PUBLIC>,<>

	parmDP	oldaddr
	parmDP	newaddr
	parmW	vecnum

cbegin
cend


;	__DOSCREATECSALIAS

cProc	__DOSCREATECSALIAS,<PUBLIC>,<ES,BX>

	parmW	dataseg
	parmDP	csalias

cbegin
	mov	ax,dataseg
	les	bx,csalias
	mov	es:[bx],ax		; use dataseg value
cend



;	__DOSFREESEG - never called from DOS 3.x

cProc	__DOSFREESEG,<PUBLIC>,<>

	parmW	dataseg

cbegin
cend

;	__DOSWRITE - stripped-down version called from emulator for no87 message
;		 - note that there is no error detection in this version
;		 - since the emulator doesn't check for write errors anyway

cProc	__DOSWRITE,<PUBLIC>,<ds>	; <di> commented out

	parmW	handle		; unsigned
	parmD	p_buffer	; char far *
	parmW	bytestowrite	; unsigned
	parmD	p_byteswritten	; unsigned far *
				; returns unsgined

cbegin
	mov	cx,bytestowrite
	mov 	bx,handle
	lds	dx,p_buffer
	callos	write
;	jc	wrtret		; if write error, error code already in AX
;				; if no error, set bytes written
;	les	di,p_byteswritten
;	mov	word ptr es:[di],ax
 	xor	ax,ax		; if no error, clear return code
;wrtret:
cend


sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emdisp.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emdisp.asm - Dispatch Tables
page
;*********************************************************************;
;								      ;
;		Dispatch Tables 				      ;
;								      ;
;*********************************************************************;

;	dispatch tables

;   These tables are based upon the layout of the 8087 instructions
;
;      8087 instruction fields:   |escape|MF|Arith|MOD|Op|r/m|disp1|disp2|
;	  field length in bits:       5    2   1    2	3   3	8     8
;
;   Disp1 and Disp2  are optional address bytes present only if MOD <> 11.
;   When (MOD <> 11) r/m describes which regs (SI,DI,BX,BP) are added to
;	Disp1 and Disp2 to calculate the effective address. This form
;	(memory format) is used for Loads, Stores, Compares, and Arithmetic
;   When using memory format MF determines the Type of the Memory operand
;	i.e. Single Real, Double real, Single Integer, or Double Integer
;   Arith is 0 for Arithmetic opetations (and compares), set to 1 otherwise
;   Op mostly determines which type of operation to do though when not in
;	memory format some of that is coded into MF and r/m
;   All of the tables are set up to do a jump based upon one or more of the
;	above fields. The outline for decoding instructions is:
;
;	    IF (memory format) THEN
;	       Assemble Effective Address (using MOD and r/m and EffectiveAddressTab)
;	       IF (Arith) THEN
;		  Load to the stack (using MF and FLDsdriTab)
;		  Do the Arithmetic Operation (using Op and ArithmeticOpTab)
;	       ELSE  (memory format non- arithmetic)
;		  Do the operation (using Op and NonArithOpMemTab  and
;		    depending on the case MF and one of the FLD or FST Tabs)
;	       ENDIF
;	    ELSE (Register format)
;	       IF (Arith) THEN
;		  Test r/m for legit Stack reference
;		  Do the Arithmetic Operation (using Op and ArithmeticOpTab)
;	       ELSE  (non-arithmetic register format)
;		  Do the operation (using Op and NonArithOpRegTab  and
;		    depending on the case r/m and one of:
;		    Constants, Miscellaneous, Transcendental, or Various Tabs)

	EVEN

glb	<EA286Tab>

eWORD	EA286Tab			; Uses |r/m|MOD| for indexing
	edw	BXSI0D
	edw	BXSI1D
	edw	BXSI2D
	edw	NoEffectiveAddress
	edw	BXDI0D
	edw	BXDI1D
	edw	BXDI2D
	edw	NoEffectiveAddress
	edw	BPSI0D
	edw	BPSI1D
	edw	BPSI2D
	edw	NoEffectiveAddress
	edw	BPDI0D
	edw	BPDI1D
	edw	BPDI2D
	edw	NoEffectiveAddress
	edw	DSSI0D
	edw	DSSI1D
	edw	DSSI2D
	edw	NoEffectiveAddress
	edw	DSDI0D
	edw	DSDI1D
	edw	DSDI2D
	edw	NoEffectiveAddress
	edw	DSXI2D
	edw	BPXI1D
	edw	BPXI2D
	edw	NoEffectiveAddress
	edw	BXXI0D
	edw	BXXI1D
	edw	BXXI2D
	edw	NoEffectiveAddress


ifdef	i386

glb	<EA386Tab>

eWORD	EA386Tab			; Uses |r/m|MOD| for indexing

	edw	Exx00			; eax
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; ecx
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; edx
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; ebx
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	SIB00			; esp (S-I-B follows)
	edw	SIB01
	edw	SIB10
	edw	NoEffectiveAddress
	edw	Direct386		; ebp (00 = direct addressing)
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; esi
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; edi
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress

endif	;i386


glb	<ArithmeticOpTab>

eWORD	ArithmeticOpTab 	; Uses |Op| for indexing
	edw	ADDRQQ		;FADD
	edw	MUDRQQ		;FMUL
	edw	eFCOM		;FCOM
	edw	eFCOMP		;FCOMP
	edw	SUDRQQ		;FSUB
	edw	SVDRQQ		;FSUBR
	edw	DIDRQQ		;FDIV
	edw	DRDRQQ		;FDIVR


glb	<NonArithOpMemTab>

eWORD	NonArithOpMemTab	; Uses |Op| for indexing
	edw	eFLDsdri	;load(single/double,real/integer)
	edw	 UNUSED 	;reserved
	edw	eFSTsdri	;Store(single/double,real/integer)
	edw	eFSTPsdri	;Store and POP (single/double,real/integer)
	edw	 UNUSED 	;reserved
	edw	eFLDtempORcw	;Load(TempReal or LongInteger), FLDCW
	edw	 UNUSED 	;reserved
	edw	eFSTtempORcw	;Store(TempReal or LongInteger), FSTCW ,FSTSW


glb	<NonArithOpRegTab>

eWORD	NonArithOpRegTab	; Uses |Op| for indexing
	edw	eFLDregOrFFREE	;load(register), FFREE
	edw	eFXCHGreg	;FXCHG
	edw	eFSTreg 	;Store(register),FNOP
	edw	eFSTPreg	;Store and POP (register)
	edw	eMISCELANEOUS	;FCHS, FABS, FTST, FXAM, FINIT, FENI, FDISI, FCLEX
	edw	eFLDconstants	;FLD1, FLDL2T, FLDL2E, FLDPI, FLDLG2, FLDLN2, FLDZ
	edw	etranscendental ;F2XM1, FYL2X, FPTAN, FPATAN, FXTRACT, FDECSTP, FINCSTP
	edw	eVARIOUS	;FPREM, FYL2XP1, FSQRT, FRNDINT, FSCALE


glb	<FLDsdriTab>

eWORD	FLDsdriTab		; Uses |MF| for indexing
	edw	eFLDsr		;load single real
	edw	eFLDdi		;load double integer
	edw	eFLDdr		;load double real
	edw	eFLDsi		;load single integer


glb	<FSTsdriTab>

eWORD	FSTsdriTab		; Uses |MF| for indexing
	edw	eFSTsr		;store single real
	edw	eFSTdi		;store double integer
	edw	eFSTdr		;store double real
	edw	eFSTsi		;store single integer


glb	<FLDtempORcwTab>

eWORD	FLDtempORcwTab		; Uses |MF| for indexing
	edw	eFLDCW		;load control word
	edw	eFLDtemp	;load temp real
	edw	 UNUSED 	;reserved
	edw	eFLDlongint	;load long integer


glb	<FSTtempORcwTab>

eWORD	FSTtempORcwTab		; Uses |MF| for indexing
	edw	eFSTCW		;store control word
	edw	eFSTtemp	;store temp real
	edw	eFSTSW		;store status word
	edw	eFSTlongint	;store long integer


glb	<FLDconstantsTab>

eWORD	FLDconstantsTab 	; Uses |r/m| for indexing
	edw	eFLD1
	edw	eFLDL2T
	edw	eFLDL2E
	edw	eFLDPI
	edw	eFLDLG2
	edw	eFLDLN2
	edw	eFLDZ
	edw	 UNUSED 	;reserved


glb	<TranscendentalTab>

eWORD	TranscendentalTab	; Uses |r/m| for indexing
	edw	eF2XM1
	edw	eFYL2X
	edw	eFPTAN
	edw	eFPATAN
	edw	eFXTRACT
	edw	 UNUSED 	;reserved
	edw	eFDECSTP
	edw	eFINCSTP


glb	<VariousTab>

eWORD	VariousTab		; Uses |r/m| for indexing
	edw	eFPREM
	edw	eFYL2XP1
	edw	eFSQRT
	edw	 UNUSED 	;reserved
	edw	eFRNDINT
	edw	eFSCALE
	edw	 UNUSED 	;reserved
	edw	 UNUSED 	;reserved


glb	<COMtab>

eWORD	COMtab			;   SI	      DI
	edw	COMvalidvalid	; valid     valid
	edw	COMsignSI	; valid     zero
	edw	COMincomprable	; valid     NAN
	edw	COMsignDIinf	; valid     INF
	edw	COMsignDI	; zero	    valid
	edw	COMequal	; zero	    zero
	edw	COMincomprable	; zero	    NAN
	edw	COMsignDIinf	; zero	    INF
	edw	COMincomprable	; NAN	    valid
	edw	COMincomprable	; NAN	    zero
	edw	COMincomprable	; NAN	    NAN
	edw	COMincomprable	; NAN	    INF
	edw	COMsignSIinf	; INF	    valid
	edw	COMsignSIinf	; INF	    zero
	edw	COMincomprable	; INF	    NAN
	edw	COMinfinf	; INF	    INF


glb	<TSTtab>

eWORD	TSTtab
	edw	COMsignSI	; valid
	edw	COMequal	; zero
	edw	COMincomprable	; NAN
	edw	COMsignSIinf	; INF


glb	<ADDJMPTAB>

eWORD	ADDJMPTAB
eWORD	TAJRQQ
	edw	RADRQQ	    ; 0000 D Valid non-0, S Valid non-0
	edw	DDD	    ; 0001 D Valid non-0, S 0
	edw	SSINV	    ; 0010 D Valid non-0, S NAN
	edw	SSS	    ; 0011 D Valid non-0, S Inf
	edw	SSS	    ; 0100 D 0, S Valid non-0
	edw	DDD	    ; 0101 D 0, S 0
	edw	SSINV	    ; 0110 D 0, S NAN
	edw	SSS	    ; 0111 D 0, S Inf
	edw	DDINV	    ; 1000 D NAN, S Valid non-0
	edw	DDINV	    ; 1001 D NAN, S 0
	edw	BIGNAN	    ; 1010 D NAN, S NAN
	edw	DDINV	    ; 1011 D NAN, S Inf
	edw	DDD	    ; 1100 D Inf, S Valid non-0
	edw	DDD	    ; 1101 D Inf, S 0
	edw	SSINV	    ; 1110 D Inf, S NAN
	edw	INFINF	    ; 1111 D Inf, S Inf


glb	<MULJMPTAB>

eWORD	MULJMPTAB
eWORD	TMJRQQ
	edw	RMDRQQ	    ; 0000 D Valid non-0, S Valid non-0
	edw	ZEROS	    ; 0001 D Valid non-0, S 0
	edw	SSINV	    ; 0010 D Valid non-0, S NAN
	edw	INFS	    ; 0011 D Valid non-0, S Inf
	edw	ZEROS	    ; 0100 D 0, S Valid non-0
	edw	ZEROS	    ; 0101 D 0, S 0
	edw	SSINV	    ; 0110 D 0, S NAN
	edw	INDINV	    ; 0111 D 0, S Inf
	edw	DDINV	    ; 1000 D NAN, S Valid non-0
	edw	DDINV	    ; 1001 D NAN, S 0
	edw	BIGNAN	    ; 1010 D NAN, S NAN
	edw	DDINV	    ; 1011 D NAN, S Inf
	edw	INFS	    ; 1100 D Inf, S Valid non-0
	edw	INDINV	    ; 1101 D Inf, S 0
	edw	SSINV	    ; 1110 D Inf, S NAN
	edw	INFS	    ; 1111 D Inf, S Inf


glb	<DIVJMPTAB>

eWORD	DIVJMPTAB
eWORD	TDJRQQ
	edw	RDDRQQ	    ; 0000 D Valid non-0, S Valid non-0
	edw	ZEROS	    ; 0001 D Valid non-0, S 0
	edw	SSINV	    ; 0010 D Valid non-0, S NAN
	edw	INFS	    ; 0011 D Valid non-0, S Inf
	edw	DIV0	    ; 0100 D 0, S Valid non-0
	edw	D0INDINV    ; 0101 D 0, S 0
	edw	D0SSINV     ; 0110 D 0, S NAN
	edw	DIV0	    ; 0111 D 0, S Inf
	edw	DDINV	    ; 1000 D NAN, S Valid non-0
	edw	DDINV	    ; 1001 D NAN, S 0
	edw	BIGNAN	    ; 1010 D NAN, S NAN
	edw	DDINV	    ; 1011 D NAN, S Inf
	edw	ZEROS	    ; 1100 D Inf, S Valid non-0
	edw	ZEROS	    ; 1101 D Inf, S 0
	edw	SSINV	    ; 1110 D Inf, S NAN
	edw	INDINV	    ; 1111 D Inf, S Inf


glb	<XAMtab>

			    ; Tag Flag	C3 C2 C1 C0	 meaning
XAMtab	DB	04H	    ;  00  0	 0  1  0  0   Positive Normal
	DB	06H	    ;  00  1	 0  1  1  0   Negative Normal
	DB	40H	    ;  01  0	 1  0  0  0   Positive Zero
	DB	42H	    ;  01  1	 1  0  1  0   Negative Zero
	DB	01H	    ;  10  0	 0  0  0  1   Positive NAN
	DB	03H	    ;  10  1	 0  0  1  1   Negative NAN
	DB	05H	    ;  11  0	 0  1  0  1   Positive Infinity
	DB	07H	    ;  11  1	 0  1  1  1   Negative Infinity

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emds.asm ===
page	,132
	title	emds.asm - Defines __FPDSARRAY
;***
;emmain.asm - Defines __FPDSARRAY.
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Defines __FPDSARRAY
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


_DATA	segment	word public 'DATA'
_DATA	ends

DGROUP	group _DATA

include os2supp.inc

; __FPDSARRAY[0] = MAXTHREADID
; __FPDSARRAY[i] = emulator DS for thread i, 1<=i<=MAXTHREADID


_DATA	segment	word public 'DATA'

public		__FPDSARRAY
__FPDSARRAY dw	    MAXTHREADID 		; table size = MAXTHREADID
	    dw	    MAXTHREADID dup (0) 	; array of per-thread DS's

_DATA	ends


_TEXT	segment word public 'CODE'
assume cs:_TEXT

extrn	__gettidtab:near

public __FarGetTidTab
__FarGetTidTab:
	call	__gettidtab

	retf

_TEXT	ends


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emdecode.asm ===
page	,132
	subttl	emdecode.asm - Instruction decoding
;***
;emdecode.asm - Instruction decoding
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Instruction decoding.
;	Further decoding of instructions done here.
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

ProfBegin  DECODE

	even

pub	eFLDsdri
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FLDsdriTab[2*ebx]
else
	JMP	FLDsdriTab[ebx]
endif

pub	eFSTsdri
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FSTsdriTab[2*ebx]
else
	JMP	FSTsdriTab[ebx]
endif

	even

pub  eFSTPsdri
	mov	bx, cx		; Dispatch on MF
	and	ebx, 6h

ifdef i386
	call	FSTsdriTab[2*ebx]
else
	call	FSTsdriTab[ebx]
endif
	mov	esi, [CURstk]
	cmp	esi, [BASstk]		   ; Do we have an empty stack?
	jbe	short FSTPSTUnder	   ;  Yes, Underflow.
FSTPSTOk:
	sub	esi, Reg87Len		   ; decrement SI to previous register
	mov	[CURstk], esi		   ; set current top of stack
	ret

FSTPSTUnder:
	call	UnderStk		   ;	stack underflow error
	jmp	FSTPSTOk


pub	eFLDtempORcw
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FLDtempORcwTab[2*ebx]
else
	JMP	FLDtempORcwTab[ebx]
endif

pub	eFSTtempORcw
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FSTtempORcwTab[2*ebx]
else
	JMP	FSTtempORcwTab[ebx]
endif

pub	eFLDregOrFFREE		; We only emulate FLD ST (Duplicate TOS)
;CX = |Op|r/m|MOD|esc|MF|Arith|

	test	cx,06h		; test MF. MF=01 is FFREE, MF=00 is FLD ST(i)
	jnz	short jmpeFFREE ; go emulate FFREE
	jmp	eFLDreg 	; emulate FLD ST(i)
jmpeFFREE:
	jmp	eFFREE		; emulate FFREE ST(i)

pub	eMISCELANEOUS		; We only emulate FCHS, FABS, FTST, &  FXAM
				; FCLEX is emulated in non-IBM version
	TEST	CX,0806H	; We already have match on Op,MOD,&Arith
	jz	short MFzero	; MF = 0, must be FCHS, FABS, FTST or FXAM
				; check for FCLEX  (cx = 8B03)
	xor	cx,00203h	; toggle low bit of MF and middle bit of r/m
	test	cx,00603h	; test for zero in MF and r/m fields

	jnz	short jnzUNUSED ; MF <> 01 and/or r/m <> 010 => unemulated

	cmp	cx,8104h	; check for FSTSW AX
	je	short eFSTSWAX	;   yes

	mov	[StatusWord],0	; FCLEX: clear status word
	ret

pub eFSTSWAX
ifdef	XENIX
	xor	eax,eax 	; UNDONE - set to non-zero - cleanup code
else
	push	sp		; test for 286 !!!
	pop	ax
	cmp	ax,sp
endif
pub	jnzUNUSED
	jnz	UNUSED		;   UNUSED if not 286

	mov	ax,[StatusWord] ; FSTSW AX: save status word in AX
	mov	[ebp].regAX,ax	; overwrite AX stack entry
	ret

MFzero:
	TEST	CX,1000H
	JZ	short FABSorFCHS
	TEST	CX,0400H	;			r/m = 101 for FXAM
	JNZ	short JMPeFXAM	;			r/m = 100 for FTST
	JMP	eFTST

pub	JMPeFXAM
	JMP	eFXAM

pub	FABSorFCHS
	TEST	CX,0400H	;			r/m = 001 for FABS
	JNZ	short JMPeFABS	;			r/m = 000 for FCHS
	JMP	eFCHS

pub	JMPeFABS
	JMP eFABS

pub	eFLDconstants
	MOV	BL,CH		; Mov r/m field to BX for jump
	SHR	BL,1
	AND	ebx,0EH
ifdef	i386
	JMP	FLDconstantsTab[2*ebx]
else
	JMP	FLDconstantsTab[ebx]
endif

pub	eTranscendental
	MOV	BL,CH		; Mov r/m field to BX for jump
	SHR	BL,1
	AND	ebx,0EH
ifdef	i386
	JMP	TranscendentalTab[2*ebx]
else
	JMP	TranscendentalTab[ebx]
endif

pub	eVARIOUS
	MOV	BL,CH		; Mov r/m field to BX for jump
	SHR	BL,1
	AND	ebx,0EH
ifdef	i386
	JMP	VariousTab[2*ebx]
else
	JMP	VariousTab[ebx]
endif


pub	eFXCHGreg		; only valid FXCHG is with r/m = 001, MF = 00
	TEST	CX,06h		; only valid FXCHG is with MF = 0
	JNZ	short UNUSED	; unemulated
	JMP	eFXCHG		; emulate FXCH ST(i)


pub	eFSTPreg
	xor	cl,04h		; test for MF = 10, valid encoding of FSTP ST(x)
	test	cx,06h
	jne	short UNUSED	; MF <> 10, no such instruction
	mov	ax,1		; indicate stack should be popped after xfer
	jmp	eFST_Preg	; emulate FSTP ST(x)


;***	eFSTreg - decode FST ST(i),FNOP
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;
;	DESCRIPTION
;		All parts of the instruction except MF and r/m have already
;		been decoded.  If MF=0, the instruction is FNOP, which is
;		unemulated.  Otherwise, clear AX to indicate FST ST(i), then
;		jump to eFST_Preg, the common emulator routine for
;		FST ST(i) and FSTP ST(i).
;

eFSTreg:
	test	cl,06h		;test for MF = 0
	jz	short UNUSED	;MF=0 ==> FNOP, which is unemulated
				;otherwise this is FST ST(i)
	xor	ax,ax		;clear ax to indicate FST ST(i), not FSTP ST(i)
	jmp	eFST_Preg	; emulate FSTP ST(x)


; This sets the error flag indicating Unemulated functions

eFXTRACT:
eFDECSTP:
eFINCSTP:


ifdef  frontend 		; unused instructions for frontend version

eFLDL2T:
eFLDL2E:
eFLDPI:
eFLDLG2:
eFLDLN2:

eFPREM:
eF2XM1:
eFYL2X:
eFPTAN:
eFPATAN:
eFYL2XP1:
eFSQRT:

endif	;frontend

ifdef  SMALL_EMULATOR

eFLDL2T:
eFLDL2E:
eFLDPI:
eFLDLG2:
eFLDLN2:

eFPREM:
eF2XM1:
eFYL2X:
eFPTAN:
eFPATAN:
eFYL2XP1:
eFSQRT:

endif	;SMALL_EMULATOR


pub	UNUSED
	OR	[CURerr],Unemulated
	RET

ProfEnd  DECODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emarith.asm ===
page	,132
	subttl	emarith.asm - Arithmetic Operations
;*** 
;emarith.asm -
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Arithmetic Operations
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History: (Also see emulator.hst)
;
;   12/19/89  WAJ   XORSIGN was not masking the sign bit correctly.
;
;*******************************************************************************

;-----------------------------------------------;
;						;
;   Double precision arithmetic 		;
;						;
;-----------------------------------------------;

; Inputs:
;	DI = (op1) NOS (Next on stack)
;	SI = (op2) TOS (Top of stack)
;
; Functions:
;	ADDRQQ - Addition	    RESULT  <--  [DI] + [SI]
;	SUDRQQ - Subtract	    RESULT  <--  [DI] - [SI]
;	MUDRQQ - Multiply	    RESULT  <--  [DI] * [SI]
;	DIDRQQ - Division	    RESULT  <--  [DI] / [SI]
;	SVDRQQ - Subtract Reversed  RESULT  <--  [SI] - [DI]
;	DRDRQQ - Division Reversed  RESULT  <--  [SI] / [DI]
; Outputs:
;	Destination of result is in RESULT
; Registers:
;	All except BP destroyed.

; Understanding this code:
;
;	Assign the  symbol  S  to  SI,	assign	the symbol D to DI.
;
;	Upon entry:  SI <-- S, DI <-- D , Performing D - S


ProfBegin  ARITH

	even

lab SVDRQQ			; Reverse Subtract
	MOV	DX,Sign*256	; DH will be flag[SI], prepare to switch sign
	JMP	short DOADD

	even

lab SUDRQQ			; Normal Subtract
	MOV	DX,Sign 	; DL will be flag[DI], prepare to switch sign
	JMP	short DOADD

	even

lab MUDRQQ			; Multiplication
	xor	idx,idx 	; Do not change signs on entry
	MOV	ibx,offset MULJMPTAB
	JMP	short INITIL

	even

lab DIDRQQ			; Normal Division
	xor	idx,idx
	XCHG	isi,idi 	; Make SI - Numerator, DI - Denominator
	MOV	ibx,offset DIVJMPTAB
	JMP	short INITIL

	even

lab DRDRQQ			; Reverse Division
	xor	idx,idx
	MOV	ibx,offset DIVJMPTAB
	JMP	short INITIL

	even

lab ADDRQQ			; Double Precision Add
	xor	idx,idx 	; No signs get switched
lab DOADD
	MOV	ibx,offset ADDJMPTAB

lab INITIL
	MOV	AL,Tag[idi]	 ; Get tags to determine special cases.
	SHL	AL,1
	SHL	AL,1
	OR	AL,Tag[isi]
	CBI
ifdef	i386
	SHL	iax,2
else
	SHL	iax,1
endif
	ADD	ibx,iax 	 ; BX now points to address of proper routine.

	XOR	DH,Flag[idi]	 ; Sign A
	XOR	DL,Flag[isi]	 ; Sign B
	MOV	CX,Expon[idi]	 ; Exponent of operand A
	MOV	AX,Expon[isi]	 ; Exponent of operand B

	JMP	cs:[ibx]	 ; Go to appropriate routine.

page
;-----------------------------------------------------------;
;							    ;
;	Special Case Routines for Arithmetic Functions	    ;
;							    ;
;-----------------------------------------------------------;

lab DDD
	mov	isi,idi 	;return DI with sign from Add/Subtract
	mov	dl,dh

lab SSS 			;Return SI with sign from Add/Subtract
	call	MOVresult
	MOV	Flag[idi],dl	;Overstore correct Sign from Add/Subtract
	ret


lab D0SSINV			;Return SI, set both Invalid and Zerodivide
	OR	[CURerr],ZeroDivide
	JMP	short SSINV

lab DDINV			;Return DI and set Invalid exception
	MOV	isi,idi

lab SSINV			;Return SI and set INVALID exception
	OR	[CURerr],Invalid
	jmp	short MOVresult


lab ZEROS			;Return 0 with xor of signs
	MOV	isi,offset IEEEzero

lab XORSIGN
	XOR	DH,DL
	AND	DH,80h		    ; Mask to just the sign.
	CALL	csMOVresult
	OR	Flag[idi],DH
	RET

lab DIV0			;Set exception, Return Infinity signed
	OR	[CURerr],ZeroDivide

lab INFS			;Return signed infinity
	MOV	isi,offset IEEEinfinity
	JMP	XORSIGN


lab D0INDINV			;Set div 0 exception, Return Indefinate and Invalid
	OR	[CURerr],ZeroDivide

lab INDINV
	MOV	isi,offset IEEEindefinite
	OR	[CURerr],Invalid

lab csMOVresult
	mov	idi,[RESULT]

lab csMOVRQQ			; as above for constants in CS
ifdef	i386
	MOVS	dword ptr es:[idi],dword ptr cs:[isi]
	MOVS	dword ptr es:[idi],dword ptr cs:[isi]
	MOVS	dword ptr es:[idi],dword ptr cs:[isi]
else
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
endif
	SUB	idi,Reg87Len
	SUB	isi,Reg87Len
	RET


lab MOVresult
	mov	idi,[RESULT]	; move to result
	cmp	isi,idi
	je	short MOVret	;   unless the same

lab MOVRQQ
ifdef	i386
	MOVS	dword ptr es:[idi],dword ptr ds:[isi]
	MOVS	dword ptr es:[idi],dword ptr ds:[isi]
	MOVS	dword ptr es:[idi],dword ptr ds:[isi]
else
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
endif
	SUB	idi,Reg87Len
	SUB	isi,Reg87Len

lab MOVret
	RET


lab INFINF			; Addition of two infinities was attempted
	TEST	[CWcntl],InfinityControl    ; Invalid if projective closure
	JSZ	INDINV
	XOR	DL,DH		; Invalid if signs are different
	JSS	INDINV
	JMP	DDD		; Otherwise Inf is the answer, already at DI

lab BIGNAN			; Return the NAN with the Bigger mantissa
	mov	iax, isi
	mov	ibx, idi

	add	isi, MantissaByteCnt-2	    ; UNDONE387:  Convert SNAN to QNAN
	add	idi, MantissaByteCnt-2
	mov	icx, MantissaByteCnt/2
	std
     repe cmps	word ptr ds:[isi], word ptr es:[idi]
	cld
	JSB	DDNAN

	mov	isi, iax	; Greater NAN was in si
	jmp	SSINV

lab DDNAN
	mov	isi, ibx	; Greater NAN was in di
	jmp	SSINV

page

if	fastSP

ifdef	i386
	BUG			; fastsp and i386 do not work together
endif

;Assumes DL = Flag[SI], DH = Flag[DI].	Will convert the mantissa on
;stack to double if necessary by appending zeros.
;Must not change AX, DX, SI, DI.

lab CoerceToDouble
	MOV	BX,DX			; get to work reg
	AND	BX,Single + 256*Single	; mask to single flags only
	JSNZ	CheckDI

lab CoerceToDoubleReturn
	RET

lab CheckDI
	XOR	BX,BX		; Prepare to zero out mantissa
	XCHG	AX,BX
	TEST	DH,Single
	JSZ	CheckSI
	STOSW			; Zero out lower five bytes
	STOSW
	STOSB
	SUB	DI,5		; Reset DI

lab CheckSI
	TEST	DL,Single
	JZ	short ExitCoerceToDouble
	XCHG	DI,SI
	STOSW			; Zero out lower five bytes
	STOSW
	STOSB
	SUB	DI,5		; Reset DI
	XCHG	DI,SI

lab ExitCoerceToDouble
	XCHG	AX,BX		; Reset AX
	XOR	BX,BX		; Set zero flag to indicate results now double
	RET

endif	;fastSP

ProfEnd  ARITH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emdoc.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emdoc.asm - Documentation
page
;--------------------------------------------------------------------
;
; WARNING - This may not be accurate for the stand-alone emulator.
;
; Glossary:
;   TOS - top-of-stack (e.g. simulated 8087 register stack)
;   single - single precision real number in one of two formats:
;     memory (IEEE), internal (on stack, see below)
;   double - double precision real number in one of two formats:
;     memory (IEEE), internal (on stack, see below).
;
; This source is organized into the following sections:
;  1. Introductory documentation of instructions and data structures
;  2. External routines, data segment, and const segment definitions
;  3. Startup and terminate, utility truncTOS
;  4. User memory macros
;  5. Macros and procedures for stack push and pop, error handling
;  6. Main entry point and effective address calculation routine
;
; Assumptions about segment usage:
;   SS = user's stack
;   DS = user's emulator data segment (not user's DS)
;   ES = effective address segment for memory operands
;      = user's emulator data segment (all other times)
;
; BASstk is DS offset of the stack base
; CURstk is DS offset of the current register (TOS).
; LIMstk is DS offset of LAST reg in stack
;
; CURerr has internal exception flag byte (<>0 iff exception occured).
; UserControlWord has user set values
; ControlWord has remapped version of UserControlWord
; CWcntl (high byte of ControlWord) has Rounding, precision, Inf modes
;
; Macros:
;   PUSHST allocates a new 12 byte register, and POPST frees one.
;   Both return an address in SI and save all other 8086 registers.
;
;   Five macros handle all data movement between user memory and local
;   memory or registers.
;
; Note standard forms:
;
;  Bits are counted from least significant;  bit 0 is 1's, bit 7 is 128's.
;
;  IEEE format is used, naturally, for values in user memory:
;
;  IEEE single precision:
;    +0: least significant byte of mantissa
;    +1: next sig. byte of mant.
;    +2: bits 6..0: most sig. bits of mant.
;    +2: bit  7:    low order bit of exponent
;    +3: bits 6..0: rest of exponent
;    +3: bit  7:    sign bit
;    mantissa does not include "hidden bit".
;    with hidden bit, mantissa value is 1.0 to 2.0
;    exponent is in biased form, with bias of 127
;    exponent of all 0's means a value of zero
;    exponent of all 1's means a value of "indefinite"
;
;  IEEE double precision:
;    +0: least significant byte of mantissa
;    +1..+5 next sig. bytes of mant.
;    +6: bits 3..0 (lo nibble): most sig. bits of mant.
;    +6: bits 7..4 (hi nibble): least sig. bits of exp.
;    +7: bits 6..0: most sig. bits of exponent
;    +7: bit  7: sign bit
;    mantissa does not include "hidden bit".
;    with hidden bit, mantissa value is 1.0 to 2.0
;    exponent is in biased form, with bias of 1023
;    exponent of all 0's means a value of zero or Denormal
;    exponent of all 1's means a value of NAN or Infinity

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emerror.asm ===
page	,132
	subttl	emerror.asm - Emulator error handler
;***
;emerror.asm - Emulator error handler
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Emulator error handler
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin ERROR

; error entry to check for unmasked errors


error_return    macro   noerror
	pop	eax		; common exit code
ifdef	XENIX
ifdef   i386
	pop	ss		; pop stack selector
endif
ifnb    <noerror>
        iretd                   ; normal return
else
        int     0FFh            ; special XENIX int for error
endif
else
        iretd
endif	;XENIX
	endm


TESTif	macro	nam
	mov	bl,err&nam	; default error number
   IF (nam GE 100H)
	test	ah,nam/256
   ELSE ;not (nam GE 100H)
	test	al,nam
   ENDIF ;(nam GE 100H)
	jnz	short signalerror
	endm

pub	CommonExceptions

ifdef	QB3

	jmp	$EM_INT 	; jump to QB3 error handler

else	;not QB3

	push	ds		; get address from task DS
	push	ebx

	TESTif	StackUnderflow	; Stack underflow
	TESTif	StackOverflow	; Stack overflow
	TESTif	SquareRootNeg	; Square root of negative number?
	TESTif	IntegerOverflow ; Would number not fit in integer?
	TESTif	Invalid 	; indefinite error ?
	TESTif	ZeroDivide	; zero divide error ?
	TESTif	Overflow	; overflow error ?
	TESTif	Underflow	; underflow error ?
;	TESTif	Denormal	; denormal error ?  not yet implemented
	TESTif	Precision	; Precision error ?
	TESTif	Unemulated	; unemulated error ?

; BL = error code value

pub	signalerror

ifndef  XENIX

ifdef	MTHREAD
	LOADthreadDS			; macro in emthread.asm	
					; load thread's DS; trash AX
elseifdef   standalone
	xor	ax,ax
	mov	ds,ax
	mov	ds,ds:[4*TSKINT+2]

elseifdef  _COM_
	mov	ds, [__EmDataSeg]

else	;Default
	mov	ax, edataBASE
	mov	ds,ax
endif	;Default


ifdef	MTHREAD
	; lock _SIGNAL_LOCK to guard SignalAddress (also used by signal func.)
	mov	ax,DGROUP
	mov	ds,ax			; establish DS == DGROUP for __lock
	push	_SIGNAL_LOCK
	call	__lockf
	add	sp,2
	mov	ax,EMULATOR_DATA	; use thread 1's data segment
	mov	ds,ax			; establish DS == EMULATOR_DATA
	mov	ax,word ptr [SignalAddress]	; check for nonzero address
	or	ax,word ptr [SignalAddress+2]
	jnz	short havehandler
	; go straight to DOSEXIT call below ...
	; don't bother cleaning up the stack or unlocking _SIGNAL_LOCK

	;pop	bx		; don't bother tossing
	;pop	ebx		; don't bother tossing
	;pop	ds		; don't bother tossing
	mov	ax,1		
	push	ax
; BL = error code value
	xchg	ax,bx		; al = return code
	xor	ah,ah
	push	ax
	os2call	DOSEXIT		; DOSEXIT(1,return code) to terminate process

elseifdef  WINDOWS
	push	es
	push	bx

	mov	ax, DOS_getvector*256 + TSKINT
	IntDOS

	mov	ax, es
	or	ax, bx

	pop	bx
	pop	es
	jnz	short havehandler

else	;not MTHREAD or WINDOWS
	mov	ax,word ptr [SignalAddress]
	or	ax,word ptr [SignalAddress+2]
	jnz	short havehandler
				; UNDONE - why no "os2call DOSEXIT" for the DOS5 case?
	;pop	bx		; don't bother tossing
	;pop	ds		; don't bother tossing
	xchg	ax,bx		; al = return code
	mov	ah,04Ch
	int	21h		; terminate process with fp error code

endif	;not MTHREAD or WINDOWS

pub	havehandler

ifdef	MTHREAD
;	DS == EMULATOR_DATA		; Use thread 1's DS for SignalAddress.
;	BL = return code
	xchg	ax,bx			; al = return code
	push	word ptr [SignalAddress+2]
	push	word ptr [SignalAddress]

	mov	bx,DGROUP
	mov	ds,bx			; establish DS == DGROUP for __unlock

	push	_SIGNAL_LOCK		; unlock _SIGNAL_LOCK
	call	__unlockf
	add	sp,2

	mov	bx,sp			; SS:BX points to a copy of SignalAddress on the stack

else	;not MTHREAD
					; bl = return code
	xchg	ax,bx			; al = return code

					; other error return info for recovery
	pop	ebx
endif	;not MTHREAD

; all registers are the original values except AX and DS
;
; al = error code (81h and up)
;
; if the signal routine is going to return to the user program, it can
; just do a long ret.  The users DS is sitting above the far return address


ifdef	POLLING 		; new exception handling code
ifndef	frontend

ifdef	DOS3and5
	cmp	[protmode],0	; check for protect mode
	jne	callsig 	;   yes - call signal now
endif	;DOS3and5

ifdef	DOS3
	cmp	[have8087],0	; check if emulating
	je	callsig 	;   yes - call signal now
	cmp	[errorcode],0	; check if pending error
ifdef	WF
	je	ncs1
	jmp	nocallsig
ncs1:
else
	jne	nocallsig	;   yes - just return
endif

	mov	[errorcode],al	; save error code for later


;*
;*  Set 80x87 exception occured flag.
;*

ifdef  USE_IRET
	mov	byte ptr cs:[FWAITiret], iNOP	; nop out "iret"

elseifdef  WINDOWS
ifdef	WF
	cmp	[wfGoFast], 0
	je      WinSlow2

	.286p
;	int 3
	push	bp			; bp[0], ds[2], ax[4], retip[6], retcs[8], retfl[10]
	mov	bp, sp			; faultip[12], faultcs[14]
	push	es
	pusha
	mov	ax, REMLSW
	mov	[wfErr], ax

	push	cs			; if fault CS:IP == our int 3d handler
	pop	ax			; then we don't want to patch it, we just want
	cmp	[bp+14], ax		; to set the flag as if we had
	jnz	wfPatch
	mov	ax, offset wfFaultHere
	cmp	[bp+12], ax
	jnz	wfPatch
	mov	[wfInsn], 3dcdh
	jmp	short wfNoPatch
wfPatch:

	push	[bp+14]			; copy faulting CS to data selector
	push	[wfSel]
	call	ChangeSelector

	mov	es, [wfSel]		; es:bx points to faulting insn
	mov	bx, [bp+12]

	mov	ax, es:[bx]		; save old insn value
	mov	[wfInsn], ax
	mov	es:[bx], 3dcdh		; put INT 3D at fault location
wfNoPatch:
	popa
	pop	es
	pop	bp
	pop	ds
	pop	ax
	iret
; fall through to old code
WinSlow2:
endif
	mov	[ExceptFlag], 1

else	;DEFAULT
	mov	byte ptr cs:[FWAITRetF], iNOP	; nop out "retf 2"
	mov	word ptr cs:[FWAITRetF2], wNOP
endif	;DEFAULT

	jmp	short nocallsig     ; just return
endif	;DOS3

endif	;not frontend
endif	;POLLING


callsig:

ifdef	MTHREAD
	call	dword ptr ss:[bx]   ; call thru thread 1's signal address
	add	sp, 4		    ; remove address of signal handler from stack
	pop	ebx		; note that bx is restored after the call to the
				; SIGFPE signal handler, but the SIG_DFL, SIG_IGN, or
				; user-handler shouldn't care; in the event of SIG_IGN
				; or a user handler that actually returns instead of
				; doing longjump(), this pop instruction will restore bx

elseifdef  WINDOWS
	mov	REMLSW, ax		; save error code

	pop	ds
	pop	ax			; stack is now just an int stack frame

ifdef WF0
	.286p
;	int 3
	push	bp			; bp[0], retip[2], retcs[4], retfl[6]
	mov	bp, sp			; faultip[8], faultcs[10]
	push	ds
	push	es
	pusha
	mov	ax, EMULATOR_DATA
	mov	ds, ax
	cmp	[wfGoFast], 1		; if running Std Mode
	jnz     WinSlow2
	mov	ax, REMLSW
	mov	[wfErr], ax
	push	[bp+10]			; copy faulting CS to data selector
	push	[wfSel]
	call	ChangeSelector

	mov	es, [wfSel]		; es:bx points to faulting insn
	mov	bx, [bp+8]

	mov	ax, es:[bx]		; save old insn value
	mov	[wfInsn], ax

	mov	es:[bx], 3dcdh		; put INT 3D at fault location

	popa
	pop	es
	pop	ds
	pop	bp
	iret
WinSlow2:			; can't do fast (non-poll) fp, so
	popa			; restore stack and use old method
	pop	es
	pop	ds
	pop	bp
; fall through to old code
endif

	inc	bp
	push	bp
	mov	bp, sp
	push	ds

	push	ax			; save user's ax

	push	cs			; must set up another stack frame
	mov	ax, offset DummyReturn
	push	ax
DummyReturn:

	mov	word ptr [bp-2], EMULATOR_DATA	; emulator's ds goes on first frame

	inc	bp
	push	bp
	mov	bp, sp
	push	ds			; push user's ds onto dummy stack frame

	mov	ax, EMULATOR_DATA
	mov	ds, ax

	push	es			; if windows => setup SignalAddress for
	push	bx			; far call

	mov	ax, DOS_getvector*256 + TSKINT
	IntDOS

	mov	word ptr [SignalAddress], bx
	mov	word ptr [SignalAddress+2], es

	pop	bx
	pop	es

	mov	ax, REMLSW		; al = error code

	call	[SignalAddress] 	; execute signal routine

	pop	ds			; restore user's ds
	add	sp, 6			; get rid of dummy stack frame
	pop	ax			; restore user's ax

	add	sp, 2			; get rid of emulator ds on stack

	pop	bp
	dec	bp

	iret				; return


else	;not MTHREAD or WINDOWS
	call	[SignalAddress] ; execute signal routine
endif	;not MTHREAD or WINDOWS

nocallsig:

	pop	ds		; restore user DS
        error_return    noerror ; treat as if nothing happened

else	;XENIX
        pop     ebx             ; restore EBX and DS
	pop	ds
        error_return            ; error exit for XENIX

endif	;XENIX


endif	;not QB3

ProfEnd  ERROR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emexcept.asm ===
page	,132
	subttl	emexcept.asm - Microsoft exception handler
;***
;emexcept.asm - Microsoft exception handler
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Microsoft exception handler
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:  (Also see emulator.hst.)
;
;   12-08-89  WAJ   Add fld tbyte ptr [mem] denormal check.
;
;*******************************************************************************


;----------------------------------------------------------------------
;   Structure for FSTENV and FLDENV, Store and Load 8087 Environment
;----------------------------------------------------------------------

glb	<ENV_ControlWord,ENV_StatusWord,ENV_TagWord,ENV_IP>
glb	<ENV_Opcode,ENV_OperandPointer,ENV_ControlMask>
glb	<ENV_CallOffset,ENV_CallSegment,ENV_CallFwait,ENV_Call8087Inst>
glb	<ENV_CallLongRet>

ENV_DS			EQU	-4
ENV_BX			EQU	-2

ENV_ControlWord 	EQU	0
ENV_StatusWord		EQU	2
ENV_TagWord		EQU	4
ENV_IP			EQU	6
ENV_Opcode		EQU	8
ENV_OperandPointer	EQU	10
ENV_ControlMask 	EQU	16

ENV_Temp		EQU	18	; Note ENV_Temp occupies

ENV_CallOffset		EQU	18	; the same space as ENV_Call*.
ENV_CallSegment 	EQU	20	; This is possible because there
ENV_CallFwait		EQU	22	; is never simultaneous use of
ENV_Call8087Inst	EQU	23	; this space
ENV_CallLongRet 	EQU	25

ENV_OldBP		EQU	28
ENV_OldAX		EQU	30
ENV_IRETadd		EQU	32

ENV_Size		EQU	28

; UNDONE	386 version is bad - 387 environment is longer

PAGE
;----------------------------------------------------------------------------
;
; 8087 EXCEPTION  HANDLER  - Fields 8087 stack over flow and under flow.
;
;----------------------------------------------------------------------------
;
;	I. The 8087 state vector.
;
;	Upon the execution of a FSAVE or FSTENV instruction the state of the
;	8087 is saved in a user defined state vector.  The first seven words
;	saved in the state vector by the two instructions are identical. The
;	definition of the words is:
;
;	Word.  Bits.	       Bytes.  Function.
;	-----  -----	       ------  ---------
;	0      15..0	       1..0    Control word.
;	1      15..0	       3..2    Status	word.	 (   8087  stack
;				       pointer and   condition	  codes.
;	2      15..0	       5..4    Tag word  ( 8087 stack slot usage
;				       flags ).
;	3      15..0	       7..6    Instruction pointer.	Operator
;				       segment offset.
;	4      15..12	       8       Operator paragraph   bits   (   (
;				       bits 16..19  )  of   address   ).
;	4      11	       8       Always zero.
;	4      10..8	       8       Upper opcode bits ( major opcode ).
;	4      7..0	       9       Lower opcode bits ( minor opcode ).
;	5      15..0	       11..10  Operand Segment offset.
;	6      15..12	       12      Operand paragraph bits.
;	6      11..0		       Not used. Must be zero.
;
;	II.  Restarting instructions.
;
;	Of interest in this  handler  is  the  necessity  of  restarting
;	8087 instructions  which  fail	because  of  8087 stack overflow
;	and underflow.	Even though the 8087  saves  enough  information
;	to restart  an	instruction,  it  is incapable of doing so.  The
;	instruction restart must be done in software.
;
;	There are two cases which must be  considered  after  the  stack
;	exception has been dealt with.
;
;	1.  The faulting instruction deals with top of stack.
;	2.  The faulting instruction deals with memory.
;
;	The first  case  is  handled  by  changing the upper five bits (
;	15..11 ) of vector word four ( 4 ) to  "11011B".   This  changes
;	word  four  into  an  "escape  opcode"	8087  instruction.   The
;	modified opcode is placed in  the  interrupt  code  segment  and
;	executed.
;
;	The second  case  is  handled  by  changing  the upper five bits
;	( 15..11 ) of vector word four	(  4  )  to  "11011B",	changing
;	the MOD  of  the  opcode  to  "00B"  ( 0 displacement ), loading
;	the operand address into DS:SI, and changing  the  RM  field  of
;	the   opcode  to  "100B"  (SI+DISP  addressing).   The	faulting
;	instruction may be restarted as above.
;
;	Instruction restart  may  also	be  accomplished  by building an
;	instruction stream  in	the  interrupt	stack  and  calling  the
;	instruction stream  indirectly.   This	method	is the preferred
;	method because it is reentrant.
;
;	III. Data Segment Considerations.
;
;	DS is restored from the task interrupt vector.	DS is used for
;	stack overflow memory.
;
;
; Documentation of the invalid exception handling code for the stand-alone
; 8087/80287 emulator
;
; The emulator software is being enhanced for the cmerge 4.0 generation of
; languages to support a larger subset of the numeric processor instruction
; set.	In addition to providing instructions which were not previously
; emulated, the model for representing the numeric processor stack is also
; being modified.  The 4.0 languages and their predecessors are object compat-
; ible so it will be possible for programs to be developed which will contain
; code generated by the old model as well as the new model.  For this reason
; it is important to understand the characteristics of both models and how
; the two models will interact.
;
; I.  The Old Model:  Infinite Stack
;
; The old model used an infinite stack model as the basis of its
; emulation of the numeric processor.  Only the classical stack form of
; instructions with operands were emulated so only ST(0) (top of stack)
; and ST(1) (next to top of stack) were referenced by any given instruction.
; In addition, the stack was allowed to overflow beyond the eight registers
; available on the chip into a memory stack overflow area.  The code genera-
; tor did not attempt to maintain all of its register data in the first eight
; register slots but instead made use of this overflow area.  In order to
; maintain compatible behavior with or without the presence of the chip, this
; model made it necessary to handle and recover from stack overflow exceptions
; in the case where the chip is present as well as when it is being emulated.
;
; This stack overflow exception handling could in turn generate a recoverable
; stack underflow exception since a situation could arise where a desired
; operand had been pushed into the memory overflow area (during stack overflow)
; and was not available in the on-chip register area when needed.  This
; scenario would signal an invalid exception due to stack underflow.
; It is recoverable because the required operand is still available in the
; overflow area and simply needs to be moved into a register on the chip.
;
; II.  The New Model:  Finite Stack
;
; The new model uses a finite stack model:  only the eight registers on the
; chip are available for use, so in the new model the invalid exception
; would never be signalled due to stack overflow.  In addition, it extends
; the emulated instruction set to include the general register form of
; instructions with operands (operands can be ST(i),ST or ST,ST(i)).  Since
; the new code generator is aware of how many items it has placed on the stack,
; it does not allow stack overflow or stack underflow to occur.  It can remove
; items from the registers either by storing to memory (FST or FSTP), or by
; using FFREE to mark the register as empty (this instruction is being added
; to the emulated instruction set).  The new model uses FFREE in a well-defined
; manner:  it will only free registers from the boundaries of the block of
; registers it is using.  For example, if the new code is using ST(0)-ST(6),
; it must free the registers in the order ST(6),ST(5),ST(4),... and so on.
; It cannot create gaps of free registers within the block of registers
; it is using.
;
; III.	The Hybrid Model:  Combination of New and Old Code
;
; Due to the possibility of mixture of code generated using both of the above
; models, the new exception handling and emulation software has to be able to
; handle all situations which can arise as a result of the interaction of the
; two models.  The following summarizes the behavior of the two models and
; restrictions placed on their interaction.
;
;	New Code:
;
;	1.  Cannot call anyone with any active entries on the stack.
;	    The new model is always at a conceptual stack level of zero
;	    when it makes external calls.  Thus old code will never
;	    incorrectly make use of register data that was placed on the
;	    register stack by new code.
;
;	2.  May create gaps of free registers in the register stack.
;	    It will not create gaps in the memory stack overflow area.
;
;	3.  Only causes stack overflow by pushing old code entries off of
;	    the register stack and into the memory stack overflow area.
;	    It will never overflow its own entries into the memory stack
;	    overflow area.
;
;	4.  Cannot cause stack underflow.
;
;
;	Old Code:
;
;	1.  Can only reference ST(0), ST(1).
;
;	2.  Can cause stack overflow by pushing too many entries onto the
;	    register stack.
;
;	3.  Can cause stack underflow in two situations:
;
;	    a.	It is trying to get something that is in the memory stack
;		overflow area (stack overflow occurred previously).
;
;	    b.	There are free entries on the chip.  This situation could
;		arise if new code creates free entries then calls old code,
;		so this is a situation that could not have existed before
;		the new model was introduced.
;
; IV.  Stack Overflow/Underflow Exception Handling
;
; The following algorithms will be used for detecting and recovering from
; stack overflow and underflow conditions (signalled via the invalid
; exception).  All invalid exceptions are "before" exceptions so that
; the instruction has to be reexecuted once the exception has been handled.
;
;	A.  Stack Overflow
;
;	If ST(7) is used (possible stack overflow) then {
;	    check for instructions which could cause stack overflow
;		(includes FLD,FPTAN,...)
;	    if instruction could cause stack overflow then {
;		save ST(7) in stack overflow area at [CURstk]
;		mark ST(7) empty
;		if FLD ST(7) instruction then
;		    FLD [CURstk] or rotate chip (clear exceptions)
;		else reexecute the instruction with ST(7) empty
;		}
;	    }
;
;	B.  Stack Underflow
;
;	If ST(0) is free then assume stack underflow since the stack
;		overflow case has already been handled (if the invalid
;		is due to a denormal exception, the exception will occur
;		again when the instruction is reexecuted):
;
;		if chip has any registers in use (check the tag word) then {
;		    rotate chip until ST(0) is not empty
;		    rotate tag word to reflect state of chip
;		    }
;		else (no registers in use)
;		    if operand is in stack overflow area then {
;			load into ST(0) from stack overflow area
;			mark ST(0) full
;			}
;		    else {
;			indicate true stack underflow
;			go print error
;			}
;		if ST(1) is  empty then {
;		    if any of ST(2) thru ST(7) are in use then {
;			rotate chip until ST(1) is not empty
;			    (to share code with first chip rotation above:
;			    store pop st(0) into temp
;			    rotate chip until st(0) is not free
;			    load st(0) back onto chip)
;			update tag word appropriately
;			}
;		    else
;			load ST(1) from overflow area if there
;		    }
;
;	At this point, ST(0) and ST(1) have been filled if possible.
;	Now we must categorize the instructions to determine which
;	of these is required.  Then we will either issue true stack
;	underflow or reexecute the instruction with the compressed
;	stack.
;----------------------------------------------------------------------------
;
; References:
;	Intel 8086 Family Numerics Supplement. 121586-001 Rev A.
;	Intel iAPX 86,88 User's Manual.
;
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;
;	All registers must be saved by __FPEXCEPTION87 except CS,IP,SS,SP.
;
;----------------------------------------------------------------------------


ifdef WINDOWS
;	stack consists of IRET frame and status word before FCLEX
;
;	Since the environment is different in protect mode, reconstruct
;	the opcode like in real mode.

lab protiret
	iret

lab protexskipsegovr
	inc	bx			; bump past segment override
	jmp	short protexsegovr	; try again

public __FPEXCEPTION87P
__FPEXCEPTION87P:
lab protexception
	push	eax			; save user ax
	push	ebp
	sub	esp,ENV_Size		; get Enough bytes for Environment
	mov	ebp,esp 		; set up for rational offsets.
	fstenv	word ptr [ebp]		; save environment.

	mov	eax,offset protiret	; set up for near return address
	xchg	ax,[ebp+ENV_Size+4]	; swap status word and near ret addr
	mov	ENV_StatusWord[ebp],ax	; save status word into environment

	push	ebx
	push	ds			; save a few more registers

	lds	ebx,dword ptr ENV_IP[ebp] ; get address of instruction
lab protexsegovr
	mov	ax,[ebx]		; get 1st 2 bytes of instruction
	add	al,28h			; add -(ESC 0)
	jnc	protexskipsegovr	;   wasn't ESC - skip seg. override
	xchg	al,ah			; swap bytes to make real opcode
	mov	ENV_Opcode[ebp],ax	; save it in environment

	sti
	jmp	short exceptionhandler
endif	;WINDOWS



ifdef	DOS5
;	stack consists of IRET frame and status word before FCLEX
;
;	Since the environment is different in protect mode, reconstruct
;	the opcode like in real mode.

lab protiret
	iret

lab protexskipsegovr
	inc	bx			; bump past segment override
	jmp	short protexsegovr	; try again

lab protexception
	push	eax			; save user ax
	push	ebp
	sub	esp,ENV_Size		; get Enough bytes for Environment
	mov	ebp,esp 		; set up for rational offsets.
	fstenv	word ptr [ebp]		; save environment.

	mov	eax,offset protiret	; set up for near return address
	xchg	ax,[ebp+ENV_Size+4]	; swap status word and near ret addr
	mov	ENV_StatusWord[ebp],ax	; save status word into environment

	push	ebx
	push	ds			; save a few more registers

	lds	ebx,dword ptr ENV_IP[ebp] ; get address of instruction
lab protexsegovr
	mov	ax,[ebx]		; get 1st 2 bytes of instruction
	add	al,28h			; add -(ESC 0)
	jnc	protexskipsegovr	;   wasn't ESC - skip seg. override
	xchg	al,ah			; swap bytes to make real opcode
	mov	ENV_Opcode[ebp],ax	; save it in environment
endif	;DOS5

ifdef	DOS3and5
	jmp	short exceptionhandler
endif	;DOS3and5


ifdef	DOS3
	public	__FPEXCEPTION87

__FPEXCEPTION87:
	PUSH	AX			; Save user's AX next to IRET
	PUSH	BP
	SUB	SP,ENV_Size		; Get Enough bytes for Environment
					; 8087 status.
	MOV	BP,SP			; Set up for rational offsets.

	;Caveat Programmer!
	;FSTENV does an implicit set of all exception masks.

	FNSTENV WORD PTR [BP]		; Save environment.
	FCLEX				; Clear exceptions.
	STI				; Restore host interrupts.

	PUSH	BX
	PUSH	DS			; Need access to user data
endif	;DOS3

;----------------------------------------------------------------------------
;   In	a  multitasking  environment  one  would  not  want  to  restore
;   interrupts at this point.  One would wait until the  8087  had  been
;   flushed and any operand data copied to a storage area.
;----------------------------------------------------------------------------

	;---------------
	; Inside of the while exception loop and Redo8087Instruction
	; registers AX and BX must contain the values as described
	; below:

	; AL bit 0 = 1 indicates invalid exception
	;    bit 1 = 1 indicates denormal exception
	;    bit 2 = 1 indicates divide by zero exception
	;    bit 3 = 1 indicates numeric overflow
	;    bit 4 = 1 indicates numeric underflow
	;    bit 5 = 1 indicates precision loss
	;    bit 6 = unused by 8087
	;    bit 7 = 1 indicates sqrt of negative number
	;		(this flag is not from the NPX status word, but
	;		 is set after all other exceptions have been
	;		 handled if the opcode is FSQRT)

	; AH bit 0 = unused
	;    bit 1 = 1 indicates stack overflow
	;    bit 2 = 1 indicates stack underflow
	;    bit 3 = unused
	;    bit 4 = unused
	;    bit 5 = 1 indicates memory operand
	;    bit 6 = 1 indicates instruction was reexcuted
	;    bit 7 = 1 indicates ST relative operand

	; BL = The complement of the exception masks copied from
	;      UserControlWord altered so that Denormal and Invalid
	;      exceptions are always unmasked, while the reserved
	;      bits are masked.

	; BH bit 0 = 1 indicates 8087 only invalid handling complete
	;    bit 1 = 1 indicates 8087 only denormal handling complete
	;    bit 2 = 1 indicates 8087 only divide by zero handling complete
	;    bit 3 = 1 indicates 8087 only numeric overflow handling complete
	;    bit 4 = 1 indicates 8087 only numeric underflow handling complete
	;    bit 5 = 1 indicates 8087 only precision loss handling complete
	;    bit 6 = unused
	;    bit 7 = unused
	;
	; Algorithm: Handle 8087 exceptions which do not occur in the
	; emulator and then jump to the common exception handling code.
	;
	; To handle 8087 only exceptions we must first determine if the
	; exception occured before the 8087 executed the instruction
	; or afterward.  Invalid, denormal (except FLD) and divide by
	; zero exceptions all occur before 8087 instruction execution,
	; others occur afterward.  "Before" exceptions must set the
	; "before" flag in AH and then reexecute the instruction.  After
	; reexecution (while all exceptions are masked) all of the
	; exceptions resulting from the current 8087 instruction will
	; be known and can be handled as a group.  "After" exceptions
	; are handled individually since reexecution of an already
	; executed instruction will destroy the validity of the 8087 stack.
	; A flag in AH is used by Redo8087instruction to avoid reexecuting
	; an instruction twice.   At the beginning of Redo8087instruction
	; the flag is checked, and if it is set the instruction is not
	; redone.
	;
	; "Before" exceptions must be reexecuted because it is
	; difficult to determine stack over/underflow if reexecution
	; is not performed.  Stack over/underflow is signaled by
	; an invalid exception.  The current algorithm for stack over/
	; underflow detection is as follows:
	;
	;	...
	;
	;---------------

ProfBegin EXCEPT

lab exceptionhandler


ifdef	MTHREAD			
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS; trashes AX
else	;MTHREAD

ifdef	standalone
	XOR	AX,AX			; Prepare to access vector, clear flags
	MOV	DS,AX
	MOV	DS,DS:[4*TSKINT+2]	; DS = emulator task data segment

elseifdef  _COM_
	mov	ds, [__EmDataSeg]
	xor	ax,ax

else
	mov	ax, edataBASE
	mov	ds,ax
	xor	ax,ax
endif

endif	;MTHREAD

	MOV	AL,ENV_StatusWord[eBP]	; Get 8087 status flags.
	XOR	BH,BH			; Clear out 8087 handling flags

;----------------------------------------------------------------------------
;
;   Can the interrupt be serviced by this routine?  Dispatch exceptional
;   conditions.
;
;   Multi-pass algorithm
;	Handle exception and reexcute instruction if necessary
;	Loop back to WhileException and handle additional exceptions
;
;	AX = status before exception handling
;	BX = flag indicating exception handled
;
;----------------------------------------------------------------------------

	cmp	[ExtendStack], 0	; check if the extended stack was
	jne	WhileException		;  turned off.

	or	bh, Invalid

lab WhileException

ifndef	_NOSTKEXCHLR			; no stack overflow/underflow handler
	TEST	BH,Invalid		; stack over/underflow already handled?
	JNZ	short NotOverUnderflow	; Yes - forget stack over/underflow
	TEST	AL,Invalid		; Invalid exception?
	JZ	short NotOverUnderflow	; No - bypass over/underflow checking
	OR	BH,Invalid		; Indicate stack over/undeflow checked
	JMP	ProcessOverUnderflow	; See about stack over/underflow
endif	;_NOSTKEXCHLR			

lab NotOverUnderflow

; Either the exception was not an invalid or stack over/underflow has
; already been handled.

; check for denormal exception - completely resolved on pass 1

	TEST	AL,Denormal		; Denormal exception?
	JZ	short NotDenormal	; No - bypass denormal handling
	JMP	ProcessDenormal 	; Process the denormal

lab NotDenormal

; check for zero divide exception

	TEST	BH,ZeroDivide		; Divide by zero already handled?
	JNZ	short NotZeroDivide	; Yes - bypass divide by zero handling
	TEST	AL,ZeroDivide		; Divide by zero exception?
	JZ	short NotZeroDivide	; No - bypass divide by zero handling
	OR	BH,ZeroDivide		; Indicate divide by zero handled

	CALL	ReDo8087Instruction	; Process divide by zero exception
	JMP	WhileException

lab NotZeroDivide

; check for numeric overflow exception

	TEST	BH,Overflow		; Overflow already handled?
	JNZ	short AllExceptionsHandled ; Yes - bypass overflow handling
	TEST	AL,Overflow		; Overflow exception?
	JZ	short AllExceptionsHandled ; No - bypass overflow handling
	OR	BH,Overflow		; Indicate overflow handled
	JMP	ProcessNumericOverflow	; Process numeric overflow


lab AllExceptionsHandled

; We have already handled any exceptions which require instruction
; reexecution.
; At this point 8087 instruction reexecution is done.  We need
; to extract a little more information for error message
; generation.

	MOV	BL, BYTE PTR UserControlWord	; 8087 exception masks
	OR	BL, 0C0H		; Mask reserved

	AND	BL, 0FDH		; Unmask denormal. DON'T unmask invalid
					; here. (Otherwiae user has no way of
					; masking invalids.)

	NOT	BL			; complement
	AND	AL, BL			; eliminate all masked exceptions
					; from AL
	TEST	AL,Invalid		; Possibly square root of neg?
	JZ	short NotFLDshortorlongNaN ; No - don't set square root flag
	PUSH	AX			; ... Use AX as scratch ...
	MOV	AX,ENV_Opcode[eBP]	; Get the instruction op code
	AND	AH,7			; Mask off the junk
	CMP	AX,001FAh		; Square root op code?
	JNE	short NotSquareRootError   ; No - don't set square root flag
	POP	AX			; ... Restore AX ...
	OR	AL,SquareRootNeg	; Set the square root flag
	JMP short NotFLDshortorlongNaN

;-----------------------------------------------------------------------------
; Test for invalid exception caused by an FLD of a NaN underflow or overflow.
;-----------------------------------------------------------------------------
lab NotSquareRootError		    ; Next check for FLD of a NaN
					; (only happens for SNaNs on
					; the 80387; not for 8087/287)
	MOV	AX,ENV_Opcode[eBP]
	AND	AX,0338h		; Mask off the inessential bits
	CMP	AX,0100h		; Check for possible FLD 
					; of short/long real from memory.
					; We are assuming that an invalid
					; exception means FLD of a NaN
					; since stack over/under-flow
					; has already been dealt with.
					; (we don't handle FLD ST(n) or
					; FLD temp real in this way)
	POP	AX			; ... Restore AX ...
	JNE	short NotFLDshortorlongNaN

	;
	; (MOD==11 case: no special code)
	; We don't handle FLD ST(n) here since it isn't properly 
	; handled in our stack overlow checking code either and
	; it doesn't generate an invalid in the case of an SNaN
	; without a stack overflow;  FFREE ST(n) will not cause
	; an Invalid exception.
	;
	; FLD TBYTE PTR ... shouldn't cause an Invalid due to a NaN
	;

	XOR	AL,Invalid		; Turn off invalid exception.
					; There should be a NaN in ST(0);
					; we will just leave it there.
	
lab NotFLDshortorlongNaN
	FCLEX
	FLDCW	ENV_ControlWord[eBP]	; Restore original Control Word

lab CleanUpHost
	or	[UserStatusWord],ax	; OR into user status word
	POP	DS
	POP	eBX
	ADD	eSP,ENV_Size		; Point to users BP
	POP	eBP
	TEST	AX,0FFFFh-Reexecuted	; exceptions?
	JNZ	Exceptions8087		; Process other exceptions as emulator
	POP	eAX			; Now just IRET address on stack
	ret				; return to OEM interrupt exit routine

lab Exceptions8087
; toss OEM routine return address

	push	eax
	push	ebx
	mov	ebx,esp

; UNDONE - this does not work for 386

	mov	eax,ss:[ebx+4]		; get original AX
	mov	ss:[ebx+6],eax		; overwrite OEM routine return address
	pop	ebx
	pop	eax

ifdef	i386
	add	esp,4			; remove original AX
else
	add	sp,2			; remove original AX
endif
	JMP	CommonExceptions

PAGE
;-----------------------------------------------------------------------------
; Test for stack underflow or overflow.
;-----------------------------------------------------------------------------

	; There are eight sets of tag bits in the tag  word.   Each  set
	; denotes the state of one of the 8087 stack elements.

	; 00 - normal
	; 01 - true zero
	; 10 - special: nan,infinity,unnormal
	; 11 - empty

	; If all are empty we have underflow, if all are full we have overflow

	; There was an invalid exception: check to see if it was stack
	; overflow or underflow.

	; Register usage in this code block:
	;	BX = tag word, complemented
	;	CL = NPX stack ptr

ifndef	_NOSTKEXCHLR			; no stack overflow/underflow handler
lab ProcessOverUnderflow
	PUSH	eSI
	PUSH	eBX			; Make room for local temps
	PUSH	eCX
	PUSH	eDX
	PUSH	eDI

	MOV	BX,ENV_TagWord[eBP]	; Get tag word.
	MOV	CX,ENV_StatusWord[eBP]	; Get status word
	NOT	BX			; Tag zero means empty, else full
	MOV	CL,CH			; Get stack pointer into CL
	AND	CL,038h 		; Mask to stack pointer
	SHR	CL,1
	SHR	CL,1			; compute number of bits to shift
	ROR	BX,CL			; tag ST(0) in low BL.

	; To service stack overflow we must make sure there is an empty space
	; above the top of stack before the instruction is reexecuted.	If
	; after reexecution we again get an invalid exception, then we
	; know there was something besides stack overflow causing the invalid
	; exception.

	; We check for stack overflow by seeing if ST(7) is empty.  We make
	; the check by testing the complemented, rotated tag word in BX.

	TEST	BH,0C0h 		; Possible stack overflow?
	JZ	short StackUnderflowCheck ; No - bypass offloading stack

	; ST(7) is not empty, so we may have stack overflow.  We verify that
	; we have stack overflow by looking at the instruction to be sure
	; that it can generate stack overflow (i.e., it puts more stuff on
	; the stack than it removes).
	; Note that a subset of the 287 instruction set is being decoded
	; here; only those instructions which can generate invalid exceptions
	; get to this point in the code (see Table 2-14 in the Numeric
	; Supplement for list of instructions and possible exceptions).
	;
	; The instructions which can generate stack overflow are:
	;	all memory FLDs,FILDs,FBLDs,constant instructions,
	;	FPTAN and FXTRACT

	MOV	DX,ENV_Opcode[eBP]	; Get the instruction op code
	XOR	DX,001E0h		; Toggle arith, mod and special bits

; Test for mod of 0,1, or 2 (indicates memory operand)

	TEST	DL,0C0h 		; Memory operand instruction?
	JNZ	short MemoryFLDCheck	; Yes - go see what kind

; Test bits 5 & 8 of instruction opcode: of remaining instructions, only those
; with stack relative operands do NOT have both of these bits as 1 in the opcode
; (remember these bits are toggled).

	TEST	DX,00120h		; ST Relative Op group?
	JNZ	short StackUnderflowCheck ; Yes - ST Relative Ops
					; cannot cause stack overflow

; Test bit 4 of the instruction opcode: of remaining instructions, only the
; transcendentals have this bit set.

	TEST	DL,010h 		; Constant or arith instruction?
	JNZ	short TransCheck	; No - must be Transcendental

; Test bit 3 of the instruction opcode: of remaining instructions, only the
; constant instructions have this bit set.

	TEST	DL,008h 		; Constant instruction?
	JNZ	short StackOverflowVerified ; Yes, can cause stack overflow

; The instructions which get to this point are FCHS, FABS, FTST and FXAM.
; None of these can cause stack overflow.

	JMP	StackUnderflowCheck	; so go check for stack underflow

lab TransCheck

; The instruction was a transcendental.  Of the transcendentals, only
; FPTAN and FXTRACT can cause stack overflow, so check for these.

	CMP	DL,012h 		; is this FPTAN
	JE	short StackOverflowVerified ; yes, can cause stack overflow
	CMP	DL,014h 		; is this FXTRACT
	JE	short StackOverflowVerified ; yes, can cause stack overflow
	JMP	StackUnderflowCheck	; not either one, won't cause overflow

lab MemoryFLDCheck
	TEST	DX,00110h		; FLD memory instruction?
	JNZ	short StackUnderflowCheck ; no - go check for stack underflow

lab StackOverflowVerified

	; ST(7) was not empty and the instruction can cause stack overflow.
	; To recover from stack overflow, move ST(7) contents to the
	; stack extension area, modifying the tag word appropriately.

	AND	BH,0FFh-0C0h		; Indicate 1st above TOS is free
	PUSHST				; Let PUSHST make room for value.
	FDECSTP 			; Point to bottom stack element.
	FSTP	TBYTE PTR [eSI] 	; Store out bottom stack element.
	JMP	InvalidReexecute	; No - reexecute instruction

lab StackUnderflowCheck

	; To service stack underflow we must make sure all the operands the
	; instruction requires are placed on the stack before the instruction
	; is reexecuted.  If after reexecution we again get an invalid
	; exception, then its due to something else.

	TEST	BL,003h 		; Is ST(0) empty?
	JZ	short UFMemoryFLDcheck	; yes - first check for memory FLD
	JMP	ST1EmptyCheck		; No - Let's try to fill ST(1), too.
					; We may need it!

	;
	; This block of code is for making sure that FLD memory operand is not
	; among those instructions where stack underflow could occur; this is
	; so FLD of SNaN can be detected (under the AllExceptionsHandled 
	; section) for the case of the 80387.
	;

lab UFMemoryFLDcheck
	MOV	DX,ENV_Opcode[eBP]	; Get the instruction opcode
	XOR	DX,001E0h		; Toggle arith, mod and special bits		
	TEST 	DL,0C0h			; Memory operand instruction?
	JZ	ST0Empty		; No - continue underflow processing
					; Try to fill ST(0)
	TEST	DX,00110h		; FLD memory instruction?
	JNZ	ST0Empty		; No - continue underflow processing
					; Try to fill ST(0)
	JMP	ST1EmptyCheck		; Let's try to fill ST(1), too.
					; We may need it!
	
	; Formerly we did JMP InvalidReexecute here; but this caused
	; an "invalid" to be reported for instructions with two stack
	; operands.  (Doing JMP ST1EMptyCheck fixes this bug: 
	; Fortran 4.01 BCP #1767.)  
	;
	; This fixes the underflow-handling case of instructions 
	; needing both ST0 and ST1 under the conditions that ST0 
	; is full but ST1 is empty.


lab ST0Empty

	; assume stack underflow since ST(0) is empty and we did not have
	; stack overflow

	OR	BX,BX			; Are any registers on the chip in
					; use? (BX = 0 if not)
	JZ	short LoadST0FromMemory ; No, load ST(0) from memory stack
	CALL	RotateChip		; yes, then point ST(0) at first
					; valid register and update tag in BX
	JMP	ST1EmptyCheck		; go check if ST(1) is empty

lab LoadST0FromMemory
	MOV	eSI,[CURstk]		; Get pointer to memory stack
	CMP	eSI,[BASstk]		; Anything in memory to load?
	JNE	short LoadST0		; Yes, go load it
	JMP	TrueUnderflow		; No, go issue error

lab LoadST0
	OR	BL,003h 		; Indicate ST(0) is full
	FINCSTP 			; Avoid altering stack pointer.
	FLD	TBYTE PTR [eSI] 	; Load value from memory.
	POPST				; Let POPST decrement memory pointer.

lab ST1EmptyCheck
	TEST	BL,00Ch 		; Is ST(1) empty?
	JNZ	short EndST1EmptyCheck	; No - so don't load from memory

	MOV	SI,BX			; move tag word to SI
	AND	SI,0FFF0h		; mask off ST(0),ST(1)
	OR	SI,SI			; Are any of ST(2)-ST(7) in use?
					; (SI = 0 if not)
	JZ	short LoadST1FromMemory ; No, try to get ST(1) from memory
	FSTP	TBYTE PTR [REG8087ST0]	; offload ST(0) temporarily
	SHR	BX,1
	SHR	BX,1			; ST(1) becomes ST(0) in tag word
	CALL	RotateChip		; get 1st in-use register into ST(1)
	FLD	TBYTE PTR [REG8087ST0]	; reload ST(0)
	SHL	BX,1
	SHL	BX,1			; adjust tag word for reloaded ST(0)
	OR	BL,003h 		; Indicate ST(0) is full
	JMP	SHORT EndST1EmptyCheck	; ST(0) and ST(1) are full

lab LoadST1FromMemory
	MOV	eSI,[CURstk]		; Get pointer to memory stack
	CMP	eSI,[BASstk]		; Anything in memory to load?
	JE	short EndST1EmptyCheck	; No, so don't load it.

	OR	BL,00Ch 		; Indicate ST(1) is full
	FINCSTP 			; Point to ST(1)
	FINCSTP 			; Point to ST(2)
	FLD	TBYTE PTR [eSI] 	; Load value from memory into ST(1).
	FDECSTP 			; Point to ST(0)
	POPST				; Let POPST decrement memory pointer.

lab EndST1EmptyCheck

; At this point we know that ST(0) is full.  ST(1) may or may not be full
; and may or may not be needed.
; Now we look at the instruction opcode and begin categorizing instructions
; to determine whether they can cause stack underflow and if so, whether
; they require ST(0) only or ST(1) as well.

	MOV	DX,ENV_Opcode[eBP]	; Get the instruction op code
	XOR	DX,001E0h		; Toggle arith, mod, and special bits

; Test for mod of 0,1, or 2 (indicates memory operand)

	TEST	DL,0C0h 		; Memory operand instruction?
	JNZ	short StackUnderflowServiced  ; Yes, then stack underflow cannot
					; be a problem since memory instructions
					; require at most one stack operand
					; and we know that ST(0) is full

; Test bits 5 & 8 of instruction opcode: of remaining instructions, only those
; with stack relative operands do NOT have both of these bits as 1 in the opcode
; (remember these bits are toggled).

	TEST	DX,00120h		; ST Relative Op group?
	JNZ	short STRelativeOpGroup ; Yes - ST Relative Ops

lab ConstOrTrans

; Test bit 4 of the instruction opcode: of remaining instructions, only the
; transcendentals have this bit set.

	TEST	DL,010h 		; Constant or arith instruction?
	JNZ	short TranscendentalInst ; No - must be Transcendental

; The instructions that get to here are the constant instructions and
; FCHS, FABS, FTST and FXAM.  The constant instructions do not have any
; stack operands; the others require ST(0) which we know is valid.
; Therefore, none of the remaining instructions can cause stack underflow.

lab StackUnderflowServiced
	JMP	InvalidReexecute	; Stack underflow corrected
					; reexecute instruction

lab TranscendentalInst
; Transcendentals may require one or two stack elements as operands.
; Here we decide whether or not ST(1) needs to be present.

	MOV	CL,DL			; Need low op code in CL
	AND	CL,00Fh 		; Mask to low four bits

; Read the next block of comments column-wise.	It shows the transcendental
; instructions represented by each bit in the constant loaded into DX below.
; Note: as it turns out, of the instructions requiring two operands below,
; only FSCALE and FPREM generate invalid exceptions when the second operand
; is missing.
	;	   FFFFFRFFFFFRFFRR
	;	   2YPPXEDIPYSERSEE
	;	   XLTATSENRLQSNCSS
	;	   M2ATRECCE2REDAEE
	;	   1XNAARSSMXTRILRR
	;	   ...NCVTT.P.VNEVV
	;	   ....TEPP.1.ET.EE
	;	   .....D.....D..DD

	MOV	DX,0101000011000100b	; 1's for 2 operand instructions

	SHL	DX,CL			; Get corresponding bit into sign
	JNS	short StackUnderflowServiced  ; If just ST(0) needed we're O.K.

	TEST	BL,00Ch 		; ST(1) full?
	JNZ	short StackUnderflowServiced  ; Yes - stack underflow no problem

lab STRelativeOpGroup

; The following code block handles the general operand ST(x) even though
; the original code generator only uses ST(0) and ST(1) as operands.
; The current code generator uses ST(x) but will never cause stack underflow
; exceptions.

	AND	DX,00007h		; Mask to relative register number
	SHL	DL,1			; Compute tag word shift amount
	MOV	CX,DX			; Get amount into CL
	MOV	DX,BX			; Get tag into DX
	ROR	DX,CL			; Shift operand tag into low DL
	TEST	DL,003h 		; Is operand register empty?
	JNZ	short InvalidReexecute	; No - go reexecute

; The following conditions could cause a true underflow error to be
; erroneously generated at this point:
; FST ST(x) signals an invalid because ST(0) is empty.	ST(0) gets filled
; by the stack underflow recovery code in this handler, but then
; the instruction is classified as an STRelative instruction and the
; above paragraph of code checks if ST(x) is empty.  HOWEVER, FST ST(x) does
; not require ST(x) to be empty so a true underflow error should not occur.
; This code should be changed if this situation can ever occur.

	JMP	TrueUnderflow		; true stack underflow

;***	RotateChip - rotate coprocessor registers
;
;	ENTRY
;		BX: tag word, complemented
;		ST(0): empty
;		at least one other register on the chip is non-empty
;			(or else this routine will loop infinitely)
;
;	RETURNS
;		BX: updated tag word, complemented
;		ST(0): non-empty
;
;	DESCRIPTION
;		This routine rotates the registers on the coprocessor
;		until the first in-use register is in ST(0).  This
;		will correct a stack underflow exception which has been
;		caused by old model code encountering a gap of free
;		registers created by new model code.  The complemented
;		tag word is also updated appropriately.
;
lab RotateChip
	ROR	BX,1			; Rotate tag word
	ROR	BX,1
	FINCSTP 			; Point to new ST(0)
	TEST	BX,00003h		; Is this register empty?
	JZ	short RotateChip	; No, go rotate again
	RET

lab TrueUnderflow
	OR	AH,StackUnderflow/256	; indicate true stack underflow
	MOV	BYTE PTR ENV_StatusWord[eBP],0	 ; Clear exceptions
	FLDENV	WORD PTR [eBP]		; Restore old environment.
	POP	eDI
	POP	eDX
	POP	eCX
	POP	eBX
	POP	eSI
	JMP	CleanUpHost		; Leave exception handler.

lab InvalidReexecute
	AND	AL,0FFH-Invalid 	; Reset invalid flag.
	CALL	ReDo8087Instruction	; Was invalid so redo instruction.

	POP	eDI
	POP	eDX
	POP	eCX
	POP	eBX
	POP	eSI
	JMP	WhileException
endif	;_NOSTKEXCHLR

;----------------------------------------------------------------------------

PAGE
lab ProcessDenormal

	; Correct 8087	bug.   The  FLD  instruction  signals a denormal
	; exception AFTER it  has  completed.	Reexecuting  FLD  for  a
	; denormal exception  would  thus mess up the 8087 stack.  INTEL
	; documentation   states   denormal   exceptions   are	  BEFORE
	; exceptions, so there is a contradiction.  To avoid reexecution
	; of FLD we do as follows:  And op code with 138H  to  mask  out
	; MOD, RM,  ESC  and  memory  format bits.  Compare with 100H to
	; distinguish FLD from other instructions which  could	possibly
	; generate a denormal exception.

	or	byte ptr [UserStatusWord],Denormal	; set denorm bit
	push	ecx

	mov	cx,ENV_Opcode[eBP]	; see if we have a reg,reg operation
	and	cl, bMOD
	cmp	cl, bMOD		; if MOD = 11b then we have a reg,reg op
	je	notMemOpDenormal

	mov	cx,ENV_Opcode[eBP]
	and	cx, not (0fc00h or bMOD or bRM) ; remove escape, OpSizeBit, MOD and R/M

	cmp	cx,0008h		; check for FMUL real-memory
	je	short isMemOpDenormal

	cmp	cx,0010h		; check for FCOM real-memory
	je	short isMemOpDenormal

	and	cl,30h			; clear low opcode bit
	cmp	cx,0030h		; check for FDIV/FDIVR real-memory
	jne	short notMemOpDenormal

;	have FDIV/FDIVR real-memory
;	have FMUL real-memory
;	have FCOM real-memory
;
;	do the following steps
;	1.	free ST(7) if not free to avoid stack overflow
;	2.	change instruction to FLD real-memory and redo
;	3.	normalize TOS
;	4.	change instruction to FMUL or FDIV[R]P ST(1),ST and redo

lab isMemOpDenormal
	TEST	BH,0C0h 		; 1. Possible stack overflow?
	JZ	short nostkovr		;    No - bypass offloading stack
	AND	BH,0FFh-0C0h		;    Indicate 1st above TOS is free
	PUSHST				;    Let PUSHST make room for value.
	FDECSTP 			;    Point to bottom stack element.
	FSTP	TBYTE PTR [eSI] 	;    Store out bottom stack element.
lab nostkovr

	mov	cx,ENV_Opcode[ebp]	; 2. get original instruction
	push	cx			;    save it for later
	and	cx,0400h
	add	cx,0104h		;    changed to FLD real DS:[SI]
	mov	ENV_Opcode[ebp],cx	;    change for redo
	call	ReDoIt			;    do FLD denormal

	call	normalize		; 3. normalize TOS

	pop	cx			; 4. restore original instruction
	and	cx,0038h		;    reduce to operation
	cmp	cl,08h			;    is it FMUL
	je	short isFMUL		;      yes
	cmp	cl,10h			;    is it FCOM
	je	short isFCOM		;      yes

	xor	cl,08h			;    must be FDIV[R] - flip R bit
lab isFMUL
	or	cx,06C1h		;    or to FoprP ST(1),ST
	mov	ENV_Opcode[ebp],cx	;    change for redo
	call	ReDo8087Instruction	;    do FDIV[R]P ST(1),ST
	jmp	short denormaldone	;    done with FDIV[R] denormal

lab notMemOpDenormal
	MOV	cx,ENV_Opcode[eBP]

	and	cx, 0738h
	cmp	cx, 0328h
	je	short noredo		; check for FLD long double

	AND	cx,0138H
	CMP	cx,0100H		; check for FLD float/double
	JZ	short noredo

	CALL	ReDo8087Instruction	; redo other instructions
lab noredo
	call	normalize
	jmp	short denormaldone

;	FCOM is a little more complicated to recover because of status
;
;	FCOM is like FDIV in that the operands need to be exchanged
;	and the value loaded onto the chip needs to be popped.
;
;	This routine is like a mini ReDo8087Instruction

lab isFCOM
	OR	AH,Reexecuted/256	; Flag instruction reexecuted
	FCLEX				; clear exceptions
	FXCH				; swap ST(0) and ST(1)
	FCOM	ST(1)			;   so that ST(1) is the "source"
	FXCH
	FSTP	ST(0)			; toss stack entry
	FSTSW	[NewStatusWord] 	; get status word
	FWAIT
	OR	AL,BYTE PTR [NewStatusWord]	; Include new with unhandled exceptions

lab denormaldone
	pop	ecx
	AND	AL,0FFh-Denormal	; clear denormal exception
	jmp	WhileException

lab normalize
	fstp	tbyte ptr ENV_Temp[ebp] 	; save denormal/unnormal
	fwait

	mov	cx,ENV_Temp[ebp+8]		; get old exponent
	test	cx,07FFFh			; test for zero exponent
	jz	short isdenormal		;   denormal temp real

	test	byte ptr ENV_Temp[ebp+7],80h	; test for unnormal
	jnz	short isnormal			;   no - skip normalization

	fild	qword ptr ENV_Temp[ebp] 	; load mantissa as integer*8
	fstp	tbyte ptr ENV_Temp[ebp] 	; save mantissa
	fwait

	cmp	word ptr ENV_Temp[ebp+8],0	; check for 0.0
	je	short isdenormal		;   yes - we had a pseudo-zero

	sub	cx,403Eh			; exponent adjust (3fff+3f)
	add	ENV_Temp[ebp+8],cx		; add to mantissa exponent

lab isnormal
	fld	tbyte ptr ENV_Temp[ebp] 	; reload normalized number
	ret

lab isdenormal
	xor	cx,cx				; make it into a zero
	mov	ENV_Temp[ebp],cx
	mov	ENV_Temp[ebp+2],cx
	mov	ENV_Temp[ebp+4],cx
	mov	ENV_Temp[ebp+6],cx
	mov	ENV_Temp[ebp+8],cx
	jmp	isnormal			; reload it as zero

PAGE
lab ProcessNumericOverflow

	; We must reexecute for numeric overflow only if the instruction
	; was an FST or FSTP.  This is because only  these  instructions
	; signal the  exception  before  the  instruction  is  executed.
	; If we reexecute under other conditions the state of  the  8087
	; will be  destroyed.	Only  memory operand versions of FST and
	; FSTP can produce  the  Overflow  exception,  and  of	all  the
	; non-arithmetic memory   operand  instructions,  only	FST  and
	; FSTP produce	overflow  exceptions.	Thus  it  is  sufficient
	; to reexecute	only  in  case	of non-arithmetic memory operand
	; instructions.  To check for these and the op code with  001C0H
	; to mask  down  to  the  arith  and  MOD fields, flip the arith
	; bit by xoring with 00100H and if the	result	is  below 000C0H
	; then we  have  a  non-arithmetic  memory  operand instruction.

	PUSH	eAX
	MOV	AX,ENV_Opcode[eBP]
	AND	AX,001C0H
	XOR	AH,001H
	CMP	AX,000C0H
	POP	eAX
	JAE	short NumericOverflowRet

	CALL	ReDo8087Instruction

lab NumericOverflowRet
	JMP	WhileException

PAGE
;----------------------------------------------------------------------------
; Reexecute aborted 8087 instruction, and include any exceptions in ENV [BP]
;----------------------------------------------------------------------------

ifdef  WINDOWS
lab ReDo8087InstructionRet
	ret
endif

lab ReDo8087Instruction
	TEST	AH,Reexecuted/256	; Already reexecuted?
	JNZ	short ReDo8087InstructionRet  ; If so don't do it again
	OR	AH,Reexecuted/256	; Flag instruction reexecuted

lab ReDoIt
	PUSH	DS
	PUSH	eDI
	PUSH	eSI
	PUSH	eCX
	PUSH	eBX
	FCLEX				; clear error summary flags


ifdef  WINDOWS
	mov	di, ss			; assume SS
	mov	bx, __WINFLAGS
	test	bx, WF_PMODE
	jz	SkipSSAlias

	push	es
;	push	ax		; CHICAGO needs 32-bit register saves ...
;	push	dx

	push	eax		; for CHICAGO
	push	ebx		; for CHICAGO
	push	ecx		; for CHICAGO
	push	edx		; for CHICAGO
	push	ebp		; for CHICAGO
	push	esi		; for CHICAGO
	push	edi		; for CHICAGO

	push	ss
	call	ALLOCDSTOCSALIAS

	pop		edi		; for CHICAGO
	mov	di, ax

;	pop	dx			; CHICAGO needs 32-bit register restores
;	pop	ax

	pop		esi		; for CHICAGO
	pop		ebp		; for CHICAGO
	pop		edx		; for CHICAGO
	pop		ecx		; for CHICAGO
	pop		ebx		; for CHICAGO
	pop		eax		; for CHICAGO
	pop		es

	or	di, di
	jz	ReExecuteRestoreRet
lab SkipSSAlias

else	;not WINDOWS

ifdef	DOS3and5
	mov	di,ss			; assume SS
	cmp	[protmode],0		; check if protect mode
	je	noSSalias		;   no - don't get SS alias
endif	;DOS3and5

ifdef	DOS5

ifdef SQL_EMMT
	push	ax

	push	ss			; The SQL server may have switched stacks
	push	ds			; so update SSalias.
	mov	ax,offset SSalias
	push	ax
	os2call DOSCREATECSALIAS

	pop	ax
endif	;SQL_EMMT

	mov	di,[SSalias]		; Get segment alias to stack
endif	;DOS5

endif	;not WINDOWS

ifdef	DOS3and5
lab noSSalias
endif	;DOS3and5

	MOV	CX,ENV_Opcode[eBP]	; Get aborted 8087 instruction.
	MOV	BX,CX			; Copy instruction.
	AND	CH,07H			; Clear upper 5 bits.
	OR	CH,0D8H 		; "OR" in escape code.
	AND	BL,0C0H 		; Mask to MOD field.
	XOR	BL,0C0H 		; If MOD = "11" (no memory operand)
	JZ	short REEXECUTE 	; then address mode modification code
					;    must be bypassed.
	AND	CL,38H			; Clear MOD and RM fields,
	OR	CL,4H			; Turn on bits in MOD and RM fields
					;    to force DS:[SI+0] addressing.
	LDS	SI,ENV_OperandPointer[eBP] ; DS:SI <-- operand address

lab REEXECUTE
	XCHG	CH,CL			; convert to non-byte swapped
					;    code format
	;
	; Stack restart method.  Restart instruction in interrupt stack
	; frame.  Code is reentrant.
	;

ifdef  WINDOWS
	mov	ENV_CallSegment[ebp],di ; Code segment alias to stack
elseifdef   DOS5
	mov	ENV_CallSegment[ebp],di ; Code segment alias to stack
else
	MOV	ENV_CallSegment[eBP],SS ; Stack segment
endif

	LEA	eDI,ENV_CallFwait[eBP]	  ; Offset to code in stack.
	MOV	ENV_CallOffset[BP],eDI
	MOV	BYTE PTR ENV_CallFwait[eBP],09BH   ; FWAIT.
	MOV	ENV_Call8087Inst[eBP],CX	   ; 8087 instruction.
	MOV	BYTE PTR ENV_CallLongRet[eBP],0CBH ; Intra segment return.
	CALL	DWORD PTR ENV_CallOffset[eBP]	   ; Reexecute instruction.

ifdef  WINDOWS
	mov	bx, __WINFLAGS
	test	bx, WF_PMODE
	jz	ReExecuteRestoreRet

	push	es		; if in PMODE, free alias
;	push	ax		; CHICAGO needs 32-bit register saves
;	push	dx

	push	eax		; for CHICAGO
	push	ebx		; for CHICAGO
	push	ecx		; for CHICAGO
	push	edx		; for CHICAGO
	push	ebp		; for CHICAGO
	push	esi		; for CHICAGO
	push	edi		; for CHICAGO

	push	ENV_CallSegment[eBP]
	call	FREESELECTOR

;	pop	dx			; CHICAGO needs 32-bit register restores
;	pop	ax

	pop		edi		; for CHICAGO
	pop		esi		; for CHICAGO
	pop		ebp		; for CHICAGO
	pop		edx		; for CHICAGO
	pop		ecx		; for CHICAGO
	pop		ebx		; for CHICAGO
	pop		eax		; for CHICAGO
	pop		es
endif	;WINDOWS


lab ReExecuteRestoreRet
	POP	eBX
	POP	eCX
	POP	eSI
	POP	eDI
	POP	DS

ifdef  SQL_EMMT
	push	ax			; free the ss alias because we always
	push	[SSalias]		; get a new one for the SQL_EMMT
	os2call DOSFREESEG
	pop	ax
endif	;SQL_EMMT


	FSTSW	[NewStatusWord] 	; 8/18/84 GFW need proper DS set
	FWAIT
	OR	AL,BYTE PTR [NewStatusWord]	; Include new with unhandled exceptions

ifndef	WINDOWS
lab ReDo8087InstructionRet
endif
	RET

ProfEnd EXCEPT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emdos.asm ===
page	,132
	subttl	emdos.asm - Initialization and Termination
;***
;emdos.asm - Initialization and Termination
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Initialization and Termination
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History: (Also see emulator.hst)
;
;   12-10-89  WAJ   Added MTHREAD DS == 0 check.
;
;*******************************************************************************


comment !

DOS interfaces to emulator/8087 functions

Certain emulator/8087 functions are performed by calling __fpmath
with an function code and arguments.

__fpmath	general floating point	math  package  interface  used
		by the emulator/8087 and float calls interfaces.  This
		is a far routine and must be far called.

entry:

  bx = 0	initialize floating point math
		dx:ax = task data area (dx = segment , ax = size)
			extra size is used to increase floating point stack
			(can pass segmented address of __fptaskdata in dx:ax)
		si = environment segment
		returns:
		  ax = 0 if successful and using software floating point
		       1 if successful and using 8087
		       negative if error

  bx = 1	reset (FINIT)

  bx = 2	terminate floating point math

  bx = 3	set error signal address
		dx:ax = segment:offset of user error handler

  bx = 4	load user control word
		(user should not use FLDCW instruction directly)
		ax = user control word value

  bx = 5	store user control word
		returns:
		  ax = user control word value

  bx = 6	truncate TOS to integer TOS
		ax = user control word (only use round mode)

  bx = 7	truncate TOS to 32-bit integer in DX:AX
		ax = user control word (only use round mode)

  bx = 8	store user status word
		returns:
		  ax = user status word value

  bx = 9	clear exceptions

  bx = 10	return number of stack elements in ax

  bx = 11	returns 1 if using 80x87, 0 if not

  bx = 12	if ax = 0, turn off extended stack. if ax = 1, turn on e.s.

QB3 version

  bx = 0	init, ax = initCW, es = PSP
  bx = 1	reset
  bx = 2	term
  bx = 3	set vectors
  bx = 4	reset vectors

!

glb	<functab>

functab label	word

	dw	initialization		; 0 - initialize emulator/8087
	dw	reset			; 1 - reset emulator/8087 stack
	dw	termination		; 2 - terminate emulator/8087

ifdef	QB3

	dw	set_vectors		; 3 - set interrupt vectors
	dw	rst_vectors		; 4 - reset interrupt vectors

SizeJmpTab  equ    4

else	;not QB3
	dw	setsignal		; 3 - set error signal address

	dw	loadcontrolword 	; 4 - load user control word
	dw	storecontrolword	; 5 - store user control word
	dw	truncateTOS		; 6 - truncate TOS to integer TOS
	dw	truncateTOSto32int	; 7 - truncate TOS to integer in DX:AX
	dw	storestatusword 	; 8 - store user status word
	dw	clearexceptions 	; 9 - clear execeptions
	dw	NumStack		; 10 - report number of elements in stack
	dw	ReturnHave8087		; 11 - report if using coprocessor
	dw	SetExtendedStack	; 12 - turn on or off extended stack

SizeJmpTab  equ    12

endif	;not QB3

endfunc label	word

szfunctab=	endfunc - functab



	public	__fpmath		; emulator entry point
					; (if linked with user program)

__fpmath	proc	far

	cmp	bx, SizeJmpTab
	ja	RetFPErr

	shl	bx,1
	push	ds			; save DS

ifdef	QB3
	push	es
	push	ax
	push	cx
	push	dx
	push	si
	push	di
endif

ifdef	MTHREAD
	or	bx,bx			; check for initialization
	jz	callfunc		;  yes - skip set up of ds
	
	push	ax			; preserve AX = __fpmath argument
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS; trashes AX
	mov	ax, ds
	or	ax, ax			; check for DS of zero.
	pop	ax
	jz	FPMathRet
callfunc:

else	;MTHREAD

ifdef	standalone
	xor	cx,cx
	mov	ds,cx
	mov	ds,ds:[TSKINT*4+2]	; point to task data area

elseifdef  _COM_
	mov	ds, [__EmDataSeg]

else
	mov	cx, edataBASE
	mov	ds,cx
endif	;standalone

endif	;MTHREAD

	call	functab[bx]

ifdef	QB3
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	ax
	pop	es
endif

lab FPMathRet
	pop	ds			; restore DS

pub emuret
	ret

RetFPErr:
	or	ax, -1
	mov	dx, ax
	jmp	emuret

__fpmath	endp


ProfBegin  DOS

subttl	emdos.asm - Initialization and Termination
page
;*********************************************************************;
;								      ;
;		      Initialization and Termination		      ;
;								      ;
;*********************************************************************;

wastetime macro
	push	cx
	mov	cx,20			;; wait for a short time
	loop	$
	pop	cx
endm

ifndef	only87
CHIPKEY 	db	'NO87='
CHIPKEYLEN	equ	$ - CHIPKEY
crlf		db	13,10
endif	;only87

ifdef	standalone
Installed	db	0		; installation flag

pub	sizeerror
	mov	ax,-1			; return size error
	stc
	ret
endif	;standalone


;	initialization
;
;	entry	dx:ax = task data area (segment and size) for standalone
;		si = DOS environment segment for NO87 lookup

pub	initialization

ifdef	QB3
	mov	[initCW],ax		; save initial BASIC control word
endif

setstacklimits macro
	mov	di,offset BEGstk	; di = base of register stack
	mov	[BASstk],di		; initialize stack base
	mov	cx,Reg87Len		; cx = register length
	xchg	ax,dx			; ax = task data segment size
	sub	ax,di			; ax = number bytes for stack
	cwd				; dx:ax = number of bytes
	div	cx			; ax = number of entries
	mul	cx			; ax = number of bytes
	add	ax,di			; ax = top of stack
	sub	ax,cx			; Leave room for one on overflow
	mov	[LIMstk],ax		; set top of stack
endm


ifdef	standalone

; check task data area sizes for correctness

	cmp	ax,offset __fptaskdata	; compare against minimum size
	jb	sizeerror		;  too small
	mov	ds,dx			; set up task data segment
	xchg	dx,ax			; set up size
	mov	ax,25h*256 + TSKINT	; set TASK DATA pointer vector
	int	21h

	setstacklimits
endif	;standalone

ifdef	MTHREAD
	ALLOCthreadDS			; macro in emthread.asm	
	mov	dx,(offset __fptaskdata)-cvtbufsize
					; set up size in dx
					; cvt buf not part of stack
	setstacklimits
endif	;MTHREAD


ifdef  QP
    mov     ax, edataOFFSET BEGstk	; initialize BASstk, CURstk, LIMstk
    mov     [BASstk], ax		; QuickPascal has no data initialization
    mov     [CURstk], ax

    mov     ax, edataOFFSET ENDstk
    sub     ax, 2*Reg87Len
    mov     [LIMstk], ax
endif	;QP


ifndef	frontend
ifdef	DOS5
	push	ss			; current stack segment selector
	push	ds
	mov	ax,offset SSalias
	push	ax			; address of SSalias
	os2call	DOSCREATECSALIAS	; get SS alias for exception handling
endif	;DOS5

endif	;frontend

ifdef	DOS3and5
	push	ds
	mov	ax,offset protmode
	push	ax
	os2call	DOSGETMACHINEMODE	; get machine mode flag
endif	;DOS3and5

ifdef	MTHREAD
 	mov	ax,ds
 	cmp	ax,EMULATOR_DATA	; check for thread 1
 	je	initcheckenv		;   yes - go look for NO87=
	

;	other threads should copy thread 1's Have8087 value
;	and then go to initfinish

	push	ds
	mov	ax,EMULATOR_DATA
	mov	ds,ax
	mov	al,[Have8087]		
	pop	ds
	mov	[Have8087],al	
	jmp	initfinish		
	
	
endif	;MTHREAD
pub	initcheckenv

ifdef	frontend
	mov	[Have8087],0		; indicate no 8087
else
ifndef	only87
	push	ds

;	Examine the environment looking for the NO87= switch

	or	si,si			; check for no environment passed in
	je	init1			;   don't look for NO87=

	mov	es,si			; ES = environment segment
	push	cs
	pop	ds
	xor	di,di			; DI -> 1st byte of environment
	cld

pub	envstart
	cmp	byte ptr es:[di],0	; 1st byte zero means end of env.
	je	init1			;   continue with initialization

	mov	cx,CHIPKEYLEN		; Length of key 'NO87='
	mov	si,offset CHIPKEY	; key string address

	repe	cmpsb

	je	envwrtmsg

	mov	cx,7FFFh		; Scan rest of environment
	xor	al,al			; for 0
	repne	scasb
	je	envstart		;   yes - check next entry
	jmp	short init1		; UNDONE - bad environment if here

pub	envwrtmsg
	mov	cx,7FFFh
	mov	al,' '			; skip leading blanks
	repe	scasb
	dec	di
	mov	dl,es:[di]		; Get character of message
	or	dl,dl			; Do we have a null?
	jz	envmsgend		; If so we're done

pub	envwrtlp
	xor	ax,ax	;** vvv 	; scan for a null byte
	mov	cx,7FFFh
	mov	bx,di			; save offset of string
	repne	scasb
	dec	di
	sub	di,bx
	mov	cx,di			; count of characters before null byte

;
;	write out NO87= environment string to standard output
;

ifdef	DOS5
	mov	di,bx			; restore offset of string
	push	ax
	mov	ax,sp			; allocate space for return count

	mov	bx,1
	push	bx			; file handle (standard output)
	push	es
	push	di			; address of buffer
	push	cx			; number of bytes to write
	push	ss
	push	ax			; address for return count
	os2call	DOSWRITE

;
;	write out CR-LF pair to standard output
;
	mov	ax,sp			; pointer to space for return count

	mov	bx,1
	push	bx			; file handle (standard output)
	push	cs
	mov	di,offset crlf
	push	di			; address of CR-LF pair
	mov	bx,2
	push	bx			; number of bytes to write: 2
	push	ss
	push	ax			; address for return count
	os2call	DOSWRITE
	pop	bx	;** ^^^ 	; deallocate space for return count
else
	push	es
	pop	ds
	mov	dx,bx			; ds:dx = string
	mov	bx,1			; bx = file handle (1)
	mov	ah,40H
	int	21h			; call DOS - write string

	push	cs
	pop	ds
	mov	dx,offset crlf		; ds:dx = CR/LF
	mov	cx,2			; cx = 2 bytes
	mov	ah,40H
	int	21h			; call DOS - write string
endif

pub	envmsgend
	pop	ds			; restore user data area
	mov	[Have8087],0		; indicate emulation
ifdef	_NO87INSTALL
	jmp	initinstallno87 	; go call __FPINSTALLNO87
else	;_NO87INSTALL
	jmp	initvec 		; initialize for emulation
endif	;_NO87INSTALL

pub	init1
	pop	ds			; restore user data area

endif	;only87


;	check if 8087/80287 is present

ifdef	DOS3and5
	cmp	[protmode],0		; check for protect mode
	jne	prot287chk		;   yes - check for 287
endif	;DOS3and5

ifdef	DOS3

;	real mode 8087/80287 check

ifdef	PCDOS
PCBIOSEQ	equ	11H		; PC BIO's Equipment determination call.
COPROCESSORMASK equ	 2H		; Mask for Coprocessor sense switch.

	int	PCBIOSEQ		; PC-DOS Bios Equipment
	and	al,COPROCESSORMASK	; Coprocessor present?
	shr	al,1			; al = 0 if no 8087/80287 , 1 = if yes
ifdef	only87
	jz	installerror		; error if no 8087/80287
endif	;only87
else
	fninit				; Initialize the 8087.
	wastetime
	xor	ax,ax			; Clean AX.
	mov	[statwd],ax		; Clear temporary.
	fnstcw	[statwd]		; have bits 033Fh  set	if  8087
	wastetime
	and	[statwd],0F3Fh	; (was 1F3Fh, but now allows for 80387-A1 step)
	cmp	[statwd],033Fh
	jnz	realno87		; no 8087 or 287

;	80287 can fool you - also check for status word

	fnstsw	[statwd]		; save status word
	wastetime
	inc	ax			; al = 1 (assume have an 80287)
	test	[statwd],0B8BFh 	; should be off if present

pub	realno87
	jz	realhave87
ifdef	only87
	jmp	short installerror	; error if no 8087/80287
else
	xor	ax,ax			; al = 0
endif	;only87

pub	realhave87
endif	;PCDOS

	MOV	[Have8087],al
endif	;DOS3

ifdef	DOS3and5
	jmp	short initinstall
endif	;DOS3and5

ifdef	DOS5

;	protect mode 80287 check

pub	prot287chk
	push	ds

	.286
	push	offset Have8087 	; directly change Have8087
	push	3			; 3rd byte is coprocessor flag
	push	0			; reserved parameter

ifndef	DOS5only
	.8086
endif

	os2call	DOSDEVCONFIG
ifdef	only87
	cmp	[Have8087],0		; error if no 87 present
	je	installerror
endif	;only87
endif	;DOS5

endif	;frontend


; check if floating point emulator/8087 already installed (device driver)

pub	initinstall

ifndef	QB3

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; check for 8087/80287
ifdef	_NO87INSTALL
	jne	initcontinue		
pub	initinstallno87
	extrn	__FPINSTALLNO87:near
	call	__FPINSTALLNO87
	jmp	initvec
initcontinue:
else	;_NO87INSTALL
	je	initvec 		;   no - don't install hardware
endif	;_NO87INSTALL
endif	;only87

ifdef	DOS3and5
	cmp	[protmode],0		; check for protect mode
	jne	initprotinstall 	;   yes - don't install hardware
endif	;DOS3and5
ifdef	DOS5only
	jmp	initprotinstall
endif

ifdef	DOS3
ifdef	standalone
	cmp	[Installed],0		; note - in code segment (not task)
	jnz	initvec 		;   installed - skip installation
endif	;standalone

	extrn	__FPINSTALL87:near
	call	__FPINSTALL87		; OEM installation
	jnc	initvec

endif	;DOS3

pub	installerror
	mov	ax,-2			; return installation error
	stc
	ret


ifdef	DOS5
pub	initprotinstall

	.286
	push	16			; exception error
	push	cs
	push	offset protexception
	push	ds
	push	offset oldvec+4 	; address for old exception vector

ifndef	DOS5only
	.8086
endif
	os2call	DOSSETVEC
endif	;DOS5
endif	;frontend

endif	;QB3

;	set up interrupt vectors for emulator or fixup-on-the-fly

pub	initvec

ifdef	DOS3and5
	cmp	[protmode],0
	jne	initvecprot		;   yes - protect mode setup
endif	;DOS3and5

ifdef	DOS3
;	real mode emulation and fixup on the fly vector setup

ifndef	QB3
	call	set_vectors
endif


endif	;DOS3
ifdef	DOS3and5
	jmp	short initfinish
endif

ifdef	DOS5
pub	initvecprot
ifndef	only87
	cmp	[Have8087],0		; emulation?
	jne	initfinish		;   no - don't setup vector

	.286
	push	7			; emulation
	push	cs
	push	offset protemulation
	push	ds
	push	offset oldvec		; address for old emulation vector

ifndef	DOS5only
	.8086
endif
	os2call	DOSSETVEC
endif	;only87
endif	;DOS5

;	finish initialization

pub	initfinish

	call	reset			; reset (0), FINIT if 8087 present

ifdef	QB3
	mov	ax,[initCW]
else
	mov	ax,InitControlWord	; setup initial control word
endif
	call	loadcontrolword

ifndef	QB3
	xor	ax,ax
	mov	word ptr [SignalAddress],ax    ; clear SignalAddress
	mov	word ptr [SignalAddress+2],ax
endif

ifdef  MTHREAD
	mov	[ExtendStack],1
endif	;MTHREAD


ifndef	only87
ifdef  LOOK_AHEAD
ifdef  DOS3and5
	mov	ax, offset DOSLookAhead
	cmp	[protmode], 0
	je	SetLookAheadRoutine

	mov	ax, offset ProtLookAhead
SetLookAheadRoutine:
	mov	[LookAheadRoutine], ax

endif	;DOS3and5
endif	;LOOK_AHEAD
endif	;not only87


	mov	al,[Have8087]
	cbw				; ax = 0 or 1 depending on 8087
	ret

ifdef  MTHREAD
lab  LoadDS_EDI 			; this is used from emds.asm
	push	bx
	push	cx
	push	dx

	mov	bx, DGROUP
	mov	ds, bx

	call	__FarGetTidTab
	mov	ds, dx
	mov	di, ax
	add	di, __fpds

	pop	dx
	pop	cx
	pop	bx

	ret
endif	;MTHREAD


;------ termination ----------------------------------------------------

pub	termination

ifdef	DOS3and5
	cmp	[protmode],0		; are we in protect mode?
	jne	termprot		;   yes
endif	;DOS3and5

ifdef	DOS3
;	real mode termination

ifndef	QB3
	call	rst_vectors
endif

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; Non zero if 8087 chip exists
ifdef	_NO87INSTALL
	jne	termcontinue
	extrn	__FPTERMINATENO87:near
	call	__FPTERMINATENO87
	ret
termcontinue:
else	;_NO87INSTALL
	je	termrealdone
endif	;_NO87INSTALL
endif	;only87

	FNINIT				; Clean up 8087.

ifndef	QB3
	extrn	__FPTERMINATE87:near
	call	__FPTERMINATE87 	; OEM 8087 cleanup routine
endif

endif	;frontend

pub	termrealdone
	ret
endif	;DOS3

ifdef	DOS5
;	protect mode termination

pub	termprot

;	UNDONE - don't do any cleanup - should be handled by DOS

ifndef	frontend			; UNDONE - should not be needed
	push	[SSalias]
	os2call	DOSFREESEG		; free up SSalias
endif	;frontend

ifdef	MTHREAD
	FREEthreadDS			; defined in emthread.asm
					; uses DOSFREESEG
endif	;MTHREAD

	ret
endif	;DOS5



subttl	emdos.asm - reset and clearexceptions
page
;*********************************************************************;
;								      ;
;		     Reset and Clearexceptions			      ;
;								      ;
;*********************************************************************;

pub	reset

ifndef	frontend
ifndef	only87
	cmp    [Have8087],0		; Nonzero if 8087 chip exists
	je     noFINIT
endif	;only87
	FNINIT				; Initialize 8087.
endif	;frontend

pub	noFINIT
	mov	ax,[BASstk]
	mov	[CURstk],ax		; reset stack to bottom

;	fall into clearexceptions


pub	clearexceptions

	xor	ax,ax
ifndef	frontend
ifndef	only87
	cmp	al,[Have8087]		; Nonzero if 8087 chip exists
	je	noFCLEX
endif	;only87
	FCLEX				; clear exceptions
endif	;frontend

pub	noFCLEX
ifndef	only87
	mov	[StatusWord],ax 	; clear status word
endif	;only87
	mov	[UserStatusWord],ax	; clear exception status word

ifdef	QB3
	mov	ax,[initCW]
	call	loadcontrolword 	; reload 8087 control word
endif	;QB3

	ret



subttl	emdos.asm - setsignal ---------------------------------
page
;*********************************************************************;
;								      ;
;		     Setsignal					      ;
;								      ;
;*********************************************************************;

ifndef	QB3

pub	setsignal
	mov	word ptr [SignalAddress],ax   ; set offset
	mov	word ptr [SignalAddress+2],dx ; set segment
	ret

endif	;QB3


ifdef	DOS3

pub	set_vectors

	mov	cx,NUMVEC		; save old vectors under DOS 3
	mov	ax,35h*256 + BEGINT	; get vector
	mov	di,offset oldvec	; di = old vector table
pub	getvecs
	int	21h
	inc	ax
	mov	[di],bx 		; save old vector
	mov	[di+2],es
	add	di,4
	loop	getvecs

ifndef	only87
	mov	dx,offset DStrap	; assume emulator
	mov	si,offset SOtrap
	mov	di,offset FWtrap
endif	;only87

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; are we using 8087 ?
	jz	setvectors		;    no - go ahead and set them
endif	;only87

	mov	dx,offset DSFixUpOnFly	; set up for fixup-on-the-fly
	mov	si,offset SOFixUpOnFly
	mov	di,offset FWFixUpOnFly
endif	;frontend

pub	setvectors
	push	ds

	push	cs
	pop	ds
	mov	ax,25h*256 + BEGINT
	mov	cx,8			; 8 vectors for DStrap
pub	vecloop
	int	21h			; set vector
	inc	ax			; bump to next one
	loop	vecloop

	mov	dx,si			; set Segtrap
	int	21h
	inc	ax
	mov	dx,di			; set FWtrap
	int	21h

	pop	ds			; restore task data area

	ret


pub	rst_vectors

	mov	cx,NUMVEC
	mov	ax,25h*256 + BEGINT	; set vector
	mov	di,offset oldvec	; di = old vector table

pub	termresetvecs
	push	ds
	lds	dx,[di] 		; get old vector value
	int	21h
	pop	ds
	inc	ax
	add	di,4
	loop	termresetvecs

	ret


endif	;DOS3



pub NumStack			; returns the number of stack elements in ax

	xor	dx, dx		; dx will count nonzero elements

ifndef	only87
	cmp	Have8087, 0
	je	CountEmulatorStack
endif	;only87

	sub	sp, 14		; need 14 bytes for fstenv
	mov	bx, sp
	fstenv	ss:[bx]
	fldcw	ss:[bx] 	; reset control word
	mov	ax, ss:[bx+4]	; put tag word in ax
	add	sp, 14		; reset stack

	mov	cx, 8
pub NotEmptyLoop
	mov	bx, ax

	shr	ax, 1
	shr	ax, 1

	and	bx, 3
	cmp	bx, 3
	je	StackEntryEmpty

	inc	dx		; stack element was not empty
pub StackEntryEmpty
	loop	NotEmptyLoop


pub CountEmulatorStack

	mov	ax, CURstk
	sub	ax, BASstk

	mov	bl, Reg87Len

	div	bl

	add	ax, dx		; add elements on 80x87 stack

	ret


ReturnHave8087 proc near

	mov	al, [Have8087]
	cbw

	ret
ReturnHave8087 endp


SetExtendedStack proc near

	mov	[ExtendStack], ax

	ret
SetExtendedStack endp

ProfEnd  DOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfcom.asm ===
page	,132
	subttl	emfcom.asm - Comparison instructions
;***
;emfcom.asm - Comparison instructions
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Comparison instructions
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;	    Comparison instructions: FCOM,FCOMP,FCOMPP,FTST,FXAM      ;
;								      ;
;*********************************************************************;

ProfBegin FCOM


pub	eFCOMP
	MOV	DX,1		; Counts number of POPs needed (0 or 1)
	JMP	short CommonCOM
pub	eFCOM
	XOR	DX,DX		; No extra POP needed at end

pub	CommonCOM		; SI points to ST, DI points to source
	TEST	WORD PTR [CURerr],MemoryOperand
	JZ	short ComSIandDIset
	XCHG	esi,edi 	; Switch SI, DI for memory operands

pub	ComSIandDIset
	MOV	AL,Flag[esi]	; All comparisons are ST ? source
	MOV	AH,Flag[edi]	; Fetch signs
	XOR	ebx,ebx
	MOV	BL,Tag[esi]
	SHL	BL,1
	SHL	BL,1
	OR	BL,Tag[edi]
ifdef	i386
	JMP	COMtab[4*ebx]
else
	SHL	BL,1
	JMP	COMtab[ebx]
endif

pub	COMvalidvalid
if	fastSP
	MOV	BX,AX			; Keep copy of the Single Flags
endif
	XOR	AH,AL			; Are signs different?
	JS	short COMsignSI 	; if so then sign of SI will determine
	OR	AL,AL			; else signs are same. See if negative
	JNS	short CompareExponents	; If negative then reverse sense of compare
	XCHG	esi,edi 		;  by swapping the arguments
	XCHG	BL,BH			;  Swap single flags

pub	CompareExponents
	MOV	AX,Expon[esi]
	CMP	AX,Expon[edi]
	JL	short COMless
	JG	short COMgreater

pub	CompareMantissas
if	fastSP
	XOR	BH,BL
	TEST	BH,Single	    ; Were both args the same length?
	JNZ	DifferentTypes
	TEST	BL,Single	    ; Args same type - Single?
	JZ	BothDouble
	MOV	ecx,3		    ; Compare 3 bytes of mantissa
DoCompare:
	ADD	esi,MB7 	    ; point to most significant byte
	ADD	edi,MB7
	STD
	REP	CMPS	word ptr es:[edi],word ptr ds:[esi]
	CLD
else
	mov	ecx,4		    ; compare 4 words of mantissa
	ADD	esi,MB6 	    ; point to most significant word
	ADD	edi,MB6
	STD
	REP	CMPS	word ptr [edi],word ptr [esi]
	CLD
endif
	JB	short COMless
	JA	short COMgreater

pub	COMequal
	MOV	[SWcc],CCequal
	JMP	short COMexit

if	fastSP
DifferentTypes:
	TEST	BL,Single
	JNZ	CoerceSI
	MOV	word ptr MB0[edi],0
	MOV	word ptr MB2[edi],0
	MOV	byte ptr MB4[edi],0
	MOV	ecx,8		    ; Compare 8 bytes of mantissa
	JMP	DoCompare

CoerceSI:
	MOV	word ptr MB0[esi],0
	MOV	word ptr MB2[esi],0
	MOV	byte ptr MB4[esi],0
BothDouble:
	MOV	ecx,8		    ; Compare 8 bytes of mantissa
	JMP	DoCompare
endif

pub	COMless
	MOV	[SWcc],CCless
	JMP	short COMexit

pub	COMgreater
	MOV	[SWcc],CCgreater
	JMP	short COMexit

pub	COMincomprable
	OR	[CURerr],Invalid
pub	COMincompr0
	MOV	[SWcc],CCincomprable
	JMP	short COMexit

pub	COMsignSIinf			; if projective inf numbers are incomprable
	TEST	[CWcntl],InfinityControl
	JZ	COMincompr0
pub	COMsignSI			; sign of SI tells all (DI = 0)
	AND	AL,Sign
	JS	COMless
	JMP	COMgreater

pub	COMsignDIinf			; if projective inf numbers are incomprable
	TEST	[CWcntl],InfinityControl
	JZ	COMincompr0
pub	COMsignDI			; sign of DI tells all (SI = 0)
	AND	AH,Sign
	JS	COMgreater
	JMP	COMless

pub	COMinfinf
	TEST	[CWcntl],InfinityControl
	JZ	COMincompr0
	XOR	AH,AL			; Are signs the same?
	AND	AH,Sign
	JZ	COMequal		; yes - infinities are equal
	JMP	COMsignSI		; else SI negative implies it is less

pub	COMexit
	OR	DX,DX			; do we need to pop the stack?
	JZ	short COMreturn
	POPST
pub	COMreturn
	RET

pub	eFXAM
	MOV	esi,[CURstk]

	mov	al, 41h 		; see if stack was empty
	cmp	esi,[BASstk]
	je	RetFXAM

	MOV	AX,Flag[esi]		; Sign in AH, Tag in AL
	XCHG	AL,AH
	ROL	AX,1
	AND	AL,7			; Mask to Tag-Sign
	MOV	ebx,offset XAMTAB
	XLAT	byte ptr cs:[ebx]	; Convert to condition code

pub  RetFXAM
	MOV	[SWcc],AL		; Stuff into hi-byte of status word
	RET

pub	eFTST
	MOV	esi,[CURstk]
	MOV	AL,Flag[esi]
	AND	AL,Sign 		; Mask to sign only
	XOR	ebx,ebx
	MOV	edx,ebx 		; DX 0 to indicate no POP in COMP
	MOV	BL,Tag[esi]
ifdef	i386
	jmp	TSTtab[4*ebx]
else
	SHL	ebx,1
	JMP	TSTtab[ebx]
endif

ProfEnd  FCOM

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfadd.asm ===
page	,132
	subttl	emfadd.asm - Addition and Subtraction
;***
;emfadd.asm - Addition and Subtraction
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Addition and Subtraction
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

;-----------------------------------------;
;					  ;
;   Addition and Subtraction		  ;
;					  ;
;-----------------------------------------;

ProfBegin FADD

RABRQQ: 	; Routine Add Both   must see if we have two singles.

if	fastSP
	MOV	BX,DX
	XOR	BX,Single + 256*Single
	TEST	BX,Single + 256*Single
	JNZ	RADRQQ
	MOV	BX,OFFSET TASRQQ
	JMP	[BX]
endif	;fastSP


pub	RADRQQ	; RoutineAddDouble    SI & DI point to valid non-0 reals
				; AX   CX  are the exponents
				; DL   DH  are the signs
if	fastSP
	CALL	CoerceToDouble	; insure that both args are double
endif	;fastSP

	SUB	AX,CX		; See which number is larger
	JL	short DIBIG
	XCHG	esi,edi 	; Swap pointers to operands
	XCHG	DH,DL		; Swap signs
	ADD	CX,AX		; CX = larger exponent (Tentative result)
	NEG	AX
pub	DIBIG			; DI = larger, CX = expon, DH = sign
	NEG	AX
	CMP	AX,64+3 	; Is smaller argument significant?
	JLE	short SIGNIF

	PUSH	ebp		; Not signif so result is at DI except for
	PUSH	edx		; rounding. ROUND assumes old BP and Sign on
	MOV	SI,Expon[edi]	; stack. Exponent in SI
	MOV	BP,1		; Other argument collapses into a sticky bit
	XOR	DL,DH		; if signs of operands differ bit is negative
	JNS	short GetOpMantissa
	NEG	BP
pub	GetOpMantissa
	MOV	DX,MB0[edi]
	MOV	CX,MB2[edi]
	MOV	BX,MB4[edi]
	MOV	DI,MB6[edi]
	OR	BP,BP
	JS	short NegativeStickyBit
	JMP	ROUND

pub	NegativeStickyBit
	SUB	DX,1		; Must propagate negative sticky bit
	SBB	CX,0
	SBB	BX,0
	SBB	DI,0
	JMP	NODRQQ

pub	SIGNIF
; Now things look like this:
;	SI has pointer to smaller operand
;	DI has pointer to larger operand
;	AX has exponent difference ( 0 <= CL <= 53 )
;	CX has exponent
;	DH has sign

	PUSH	ebp		; Need all the registers
	PUSH	edx		; Save sign
	PUSH	ecx		; Save exponent
	XOR	DL,DH		; Must eventually know whether signs are same
	PUSHF

	MOV	BP,AX		; Need all 8-bit registers now

; Load smaller operand

	LODS	word ptr ds:[esi]
	MOV	DX,AX
	LODS	word ptr ds:[esi]
	MOV	CX,AX
	LODS	word ptr ds:[esi]
	MOV	BX,AX
	LODS	word ptr ds:[esi]
	XOR	si,si		; BP Will be round,guard, & sticky bits (=0)
	XCHG	bp,si		; Done with Pointer to small. so SI = shift cnt

;			 hi	  lo 0
; Smaller operand now in AX:BX:CX:DX:BP with implied bit set, SI has shift count

	OR	si,si
	JZ	ALIGNED 	; Alignment operations necessary?
pub	CHKALN
	CMP	si,14		; Do shifts of 16 bits by word rotate
	JL	short BYTSHFT	; If not enough for word, go try byte
	OR	BP,BP		; See if we're shifting something off the end
	JZ	short NOSTIK
	OR	DX,1		; Ensure sticky bit will be set
pub	NOSTIK
	MOV	BP,DX
	MOV	DX,CX
	MOV	CX,BX
	MOV	BX,AX
	XOR	AX,AX
	SUB	si,16		; Counts for 16 bit shifts
	JA	short CHKALN	; If not enough, try again
	JZ	short ALIGNED	; Hit it exactly?
	JB	short SHFLEF	; Back up if too far

pub	BYTSHFT
	CMP	si,6		; Can we do a byte shift?
	JL	short BITSHFT
	XCHG	BP,AX
	OR	AL,AL
	JZ	short NSTIK
	OR	AH,1
pub	NSTIK
	MOV	AL,AH
	MOV	AH,DL
	XCHG	BP,AX
	MOV	DL,DH
	MOV	DH,CL
	MOV	CL,CH
	MOV	CH,BL
	MOV	BL,BH
	MOV	BH,AL
	MOV	AL,AH
	XOR	AH,AH
	SUB	SI,8
	JA	short BITSHFT
	JZ	short ALIGNED

; To get here, we must have used a byte shift when we needed to shift less than
; 8 bits. Now we must correct by 1 or 2 left shifts.

pub	SHFLEF
	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	RCL	AX,1
	INC	SI
	JNZ	SHFLEF		; Until DI is back to zero (from -1 or -2)
	JMP	SHORT ALIGNED

pub	BITSHFT
ifdef	i386
	and	esi,0FFFFh	; clear upper half of esi
endif
	XCHG	ecx,esi 	; Swap count into CX, lo3:lo4 into DI
	TEST	BP,3FH		; See if we're shifting stuff off the end
	JZ	short SHFRIG
	OR	BP,20H		; Set sticky bit if so
pub	SHFRIG
	SHR	AX,1
	RCR	BX,1
	RCR	SI,1
	RCR	DX,1
	RCR	BP,1
	LOOP	SHFRIG		; Do 1 to 5 64-bit right shifts
	MOV	CX,SI		; Get back CX = lo3:lo4
pub	ALIGNED
	MOV	esi,edi 	; Address of larger operand
	MOV	DI,AX		; Now DI = msb:mid
	TEST	BP,3FFFH	; Collapse LSBs into sticky bit
	JZ	short GETSIGN
	OR	BP,1		; Set sticky bit
pub	GETSIGN
	POPF			; Recover XOR of signs
				; 80286 errata for POPF shouldn't
				; apply because interrupts should be
				; turned on in this context
	POP	eax		; Recover Exponent
; Sign flag is XOR of signs

	JS	short SUBMAN	; Subtract mantissas if signs are different
	ADD	DX,[esi]
	ADC	CX,[esi+2]
	ADC	BX,[esi+4]
	ADC	DI,[esi+6]
	JNC	short JROUND	; Done if no overflow

; Have a carry, so result must be shifted right and exponent incremented
	RCR	DI,1
	RCR	BX,1
	RCR	CX,1
	RCR	DX,1
	RCR	BP,1
	JNC	short STIKYOK
	OR	BP,1		; Shifted out the sticky bit so reset it.
pub	STIKYOK
	INC	AX		; Bump exponent.
;	JMP	JROUND		; and go round. (need not normalize)

pub	JROUND
	MOV	SI,AX		; We must have SI equal to exponent
	JMP	ROUND		; on our way to Round

pub	SUBMAN
; Subtract mantissas since signs are different.  We'll be subtracting larger
; from smaller, so sign will be inverted first after the subtraction.

	SUB	DX,[esi]
	SBB	CX,[esi+2]
	SBB	BX,[esi+4]
	SBB	DI,[esi+6]
	JNC	short JNORM	; Won't carry if we mixed up larger and smaller

; As expected, we got a carry which means we original sign was OK
	XOR	SI,SI		; We'll need a zero, so let's use SI
	NOT	DI
	NOT	BX
	NOT	CX
	NOT	DX
	NEG	BP		; Carry clear if zero
	CMC			; Set CY
	ADC	DX,SI
	ADC	CX,SI		; Propagate carry
	ADC	BX,SI
	ADC	DI,SI
	MOV	SI,AX		; Get exponent to SI
	JMP	NODRQQ		; Go normalize

pub	JNORM
	MOV	SI,AX		; Exponent in SI
	POP	eax
	XOR	AH,SIGN 	; invert sign bit (on top of stack)
	PUSH	eax
	JMP	NODRQQ		; and go normalize

ProfEnd  FADD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfdiv.asm ===
page	,132
	subttl	emfdiv.asm - Division
;***
;emfdiv.asm - Division
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Division
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;		Division		  ;
;					  ;
;-----------------------------------------;

ProfBegin FDIV

RDBRQQ:     ; Routine Div Both	 must see if we have two singles.

if	fastSP
	MOV	BX,DX
	XOR	BX,Single + 256*Single
	TEST	BX,Single + 256*Single
	JNZ	RDDRQQ
	MOV	bx,offset TDSRQQ
	JMP	[bx]
endif	;fastSP


pub	RDDRQQ	; Routine Division Double
; Now we have
;   SI --> numerator   , AX - Expon , DL - Sign
;   DI --> denominator , CX - Expon , DH - Sign

if	fastSP
	CALL	CoerceToDouble	; insure that both args are double
endif	;fastSP

	STC			; exponent will be difference - 1
	SBB	AX,CX		; compute result exponent

; AH has the (tentative) true exponent of the result.  It is correct if the
; result does not need normalizing.  If normalizing is required, then this
; must be incremented to give the correct result exponent

	XOR	DH,DL		; Compute sign
	PUSH	ebp
	PUSH	edx		; Save sign
	PUSH	esi
	PUSH	edi
	ADD	esi,6
	ADD	edi,6
	MOV	ecx,4
	STD
	REP	CMPS  word ptr [esi],word ptr [edi] ; compare numerator mantissa
	CLD			;    with denominator mantissa
	POP	edi
	POP	esi
	PUSHF			; save the flags from the compare
	MOV	BP,AX		; save the exponent
	LODS	word ptr [esi]	; Load up numerator
	MOV	CX,AX
	LODS	word ptr [esi]
	MOV	BX,AX
	LODS	word ptr [esi]
	MOV	DX,AX
	LODS	word ptr [esi]
	XCHG	AX,DX

; Move divisor to DAC so we can get at it easily.

	MOV	esi,edi 	; Move divisor to DAC
	MOV	edi,offset DAC
ifdef	i386
	MOVSD
	MOVSD
else
	MOVSW
	MOVSW
	MOVSW
	MOVSW
endif

; Now we're all set:
;	DX:AX:BX:CX has dividend
;	DAC has divisor (in normal format)
; Both are 64 bits with zeros and have implied bit set.
; Top of stack has sign and tentative exponent.

	XOR	DI,DI
	POPF			; numerator mantissa < denominator?
				; 80286 errata for POPF shouldn't
				; apply because interrupts should be
				; turned on in this context
	JB	short DivNoShift ;    if so bypass numerator shift
	SHR	DX,1		; Make sure dividend is smaller than divisor
	RCR	AX,1		;   by dividing it by two
	RCR	BX,1
	RCR	CX,1
	RCR	DI,1
	INC	BP		; increment result exponent
pub	DivNoShift
	PUSH	ebp		; save result exponent
	MOV	[REMLSW],DI	; Save lsb of remainder
	CALL	DIV16		; Get a quotient digit
	PUSH	edi
	MOV	[REMLSW],0	; Turn off the shifted bit
	CALL	DIV16
	PUSH	edi
	CALL	DIV16
	PUSH	edi
	CALL	DIV16
	MOV	BP,8001H	; turn round and sticky on
	SHL	CX,1
	RCL	BX,1
	RCL	AX,1
	RCL	DX,1		; multiply remainder by 2
	JC	short BPset	; if overflow, then round,sticky valid
	MOV	esi,offset DAC
	CMP	DX,[esi+6]
	JNE	short RemainderNotHalf
	CMP	AX,[esi+4]
	JNE	short RemainderNotHalf
	CMP	BX,[esi+2]
	JNE	short RemainderNotHalf
	CMP	CX,[esi]	; compare 2*remainder with denominator

;Observe, oh wondering one, how you can assume the result of this last
;compare is not equality.  Use the following notation: n=numerator,
;d=denominator,q=quotient,r=remainder,b=base(2^64 here).  If
;initially we had n < d then there was no shift and we will find q and r
;so that q*d+r=n*b, if initially we had n >= d then there was a shift and
;we will find q and r so that q*d+r=n*b/2.  If we have equality here
;then r=d/2  ==>  n={possibly 2*}(2*q+1)*d/(2*b), since this can only
;be integral if d is a multiple of b, but by definition b/2 <= d < b, we
;have a contradiction.	Equality is thus impossible at this point.

pub	RemainderNotHalf	; if 2*remainder > denominator
	JAE	short BPset	;    then round and sticky are valid
	OR	AX,DX
	OR	AX,CX
	OR	AX,BX
	OR	AL,AH		; otherwise or sticky bits into AL
	XOR	AH,AH		; clear round bit
	MOV	BP,AX		; move round and sticky into BP
pub	BPset
	MOV	DX,DI		; get low 16 bits into proper location
	POP	ecx
	POP	ebx
	POP	edi
	POP	esi		; Now restore exponent

	JMP	ROUND		; Result is normalized, round it


;	Remainder in DX:AX:BX:CX:REMLSW

pub	DIV16
	MOV	SI,[DAC+6]	; Get high word of divisor
	XOR	DI,DI		; Initialize quotient digit to zero
	CMP	DX,SI		; Will we overflow?
	JAE	MAXQUO		; If so, go handle special
	OR	DX,DX		; Is dividend small?
	JNZ	short DDIV
	CMP	SI,AX		; Will divisor fit at all?
	JA	short ZERQUO	; No - quotient is zero

pub	DDIV
	DIV	SI		; AX is our digit "guess"
	PUSH	edx		; Save remainder -
	PUSH	ebx		;   top 32 bits
	XCHG	AX,DI		; Quotient digit in DI
	XOR	BP,BP		; Initialize quotient * divisor
	MOV	SI,BP
	MOV	AX,[DAC]
	OR	AX,AX		; If zero, save multiply time
	JZ	short REM2
	MUL	DI		; Begin computing quotient * divisor
	MOV	SI,DX

pub	REM2
	PUSH	eax		; Save lowest word of quotient * divisor
	MOV	AX,[DAC+2]
	OR	AX,AX
	JZ	short REM3
	MUL	DI
	ADD	SI,AX
	ADC	BP,DX

pub	REM3
	MOV	AX,[DAC+4]
	OR	AX,AX
	JZ	short REM4
	MUL	DI
	ADD	BP,AX
	ADC	DX,0
	XCHG	AX,DX

;	Remainder - Quotient * divisor
;	[SP+4]:[SP+2]:CX:REMLSW - AX:BP:SI:[SP]

pub	REM4
	MOV	DX,[REMLSW]	; Low word of remainder
	POP	ebx		; Recover lowest word of quotient * divisor
	SUB	DX,BX
	SBB	CX,SI
	POP	ebx
	SBB	BX,BP
	POP	ebp		; Remainder from DIV
	SBB	BP,AX
	XCHG	AX,BP

pub	ZERQUO			; Remainder in AX:BX:CX:DX
	XCHG	AX,DX
	XCHG	AX,CX
	XCHG	AX,BX
	JNC	short DRET	; Remainder in DX:AX:BX:CX

pub	RESTORE
	DEC	DI		; Drop quotient since it didn't fit
	ADD	CX,[DAC]	; Add divisor back in until remainder goes +
	ADC	BX,[DAC+2]
	ADC	AX,[DAC+4]
	ADC	DX,[DAC+6]
	JNC	RESTORE 	; Loop is performed at most twice

pub	DRET
	RET

pub	MAXQUO
	DEC	DI		; DI=FFFF=2**16-1, DX:AX:BX:CX is remainder,
	SUB	CX,[DAC]	;    DX = [DAC+6], d = divisor = [DAC]
	SBB	BX,[DAC+2]
	SBB	AX,[DAC+4]	; subtract 2^16*d from DX:AX:BX:CX:0000H
	ADD	CX,[DAC+2]	;    (DX-[DAC+6] = 0 is implied)
	ADC	BX,[DAC+4]
	ADC	AX,DX		; add high 48 bits of d to AX:BX:CX:0000H
	MOV	DX,[DAC]	; add low 16 bits of d to zero giving DX
	CMC			; DI should be FFFEH if no carry from add
	JMP	ZERQUO

ProfEnd  FDIV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfmisc.asm ===
page	,132
	subttl	emfmisc.asm - Miscellaneous Operations
;***
;emfmisc.asm - Miscellaneous Operations
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Miscellaneous Operations: FABS, FCHS, DupTOS, FSCALE, FXCHG
;
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin FMISC


pub	eFABS
	MOV	esi,[CURstk]			; point to TOS
	AND	byte ptr Flag[esi],0FFH - Sign	; mask off sign
	RET

pub	eFCHS
	MOV	esi,[CURstk]			; point to TOS
	XOR	byte ptr Flag[esi],Sign 	; toggle the sign
	RET


;	FLDCW and FSTCW should only be used in a nested fashion
;	and should never change the denormal and invalid masks (in real 8087)
;
;	FSTCW	old
;	FLDCW	new		; new and old have same denormal/invalid masks
;	...
;	FLDCW	old

pub	eFLDCW
	LDUS2AX 		; Fetch control word from user memory
	MOV	[ControlWord],AX ; Store in the emulated control word
	MOV	[UserControlWord],AX ; Store in the user control word
	RET

pub	eFSTCW
	MOV	AX,[UserControlWord] ; Fetch user control word
	MOV	edi,esi
	STAX2US 		; Store into user memory
	RET

pub	eFSTSW
	MOV	AX,[StatusWord]     ; Fetch emulated Status word
	MOV	edi,esi
	STAX2US 		; Store into user memory
	RET

pub	eFSCALE 		; NOS is treated as short integer and TOS gets
	MOV	esi,[CURstk]	 ; its exponent bumped by that amount
	MOV	edi,esi
	ChangeDIfromTOStoNOS
	MOV	CL,15
	MOV	AL,Expon[edi]	; Assume word integer
	AND	AL,0FH		; Assume exp is positive and in range
	SUB	CL,AL		; Generate shift count for mantissa
	MOV	AX,MB6[edi]	; MSW will contain the whole integer
	SHR	AX,CL		; AX is now the integer
	MOV	CL,Flag[edi]	; Get the sign for the integer
	OR	CL,CL
	JNS	short GotExponInc
	NEG	AX

pub	GotExponInc
	ADD	AX,Expon[esi]
	JO	short ExpOverflowed
	CMP	AX,IexpMax - IexpBias
	JGE	short ScaledToInfinity
	CMP	AX,IexpMin - IexpBias
	JLE	short ScaledToZero

pub	ScaleReturn
	MOV	Expon[esi],AX
	RET

pub	ExpOverflowed
	JNS	short ScaledToZero

pub	ScaledToInfinity
	MOV	AX,IexpMax - IexpBias
	MOV	byte ptr Tag[esi],Special + ZROorINF
	JMP	short ScaleReturn

pub	ScaledToZero
	MOV	AX,IexpMin - IexpBias
	MOV	byte ptr Tag[esi],ZROorINF
	JMP	short ScaleReturn

ProfEnd  FMISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfconst.asm ===
page	,132
	subttl	emfconst.asm - Loading of 8087 on chip constants
;***
;emfconst.asm - Loading of 8087 on chip constants
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Loading of 8087 on chip constants
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

;-----------------------------------------;
;					  ;
;	     Constant Loading		  ;
;					  ;
;-----------------------------------------;

;---------------------------------------------------
;						   !
;	8087 emulator constant loading		   !
;						   !
;---------------------------------------------------

ProfBegin FCONST


LoadConstantEntry	MACRO	cName,Position
pub	e&cName
	mov	ebx,offset c&cName
   IFIDN <&Position>,<Last>
   ELSE ;IFIDN <&Position>,<Last>
	jmp	short CommonConst
   ENDIF ;IFIDN <&Position>,<Last>
	ENDM

ifndef	frontend
ifndef	SMALL_EMULATOR

LoadConstantEntry	FLDPI,NotLast

LoadConstantEntry	FLDL2T,NotLast

LoadConstantEntry	FLDL2E,NotLast

LoadConstantEntry	FLDLG2,NotLast

LoadConstantEntry	FLDLN2,NotLast

endif	;not SMALL_EMULATOR
endif	;not frontend

LoadConstantEntry	FLDZ,NotLast

LoadConstantEntry	FLD1,Last

pub	CommonConst
	PUSHST
	MOV	esi,ebx
	MOV	edi,[CURstk]
ifdef	i386
	   rept Reg87Len/4
	MOVS	dword ptr es:[edi], dword ptr cs:[esi]
	   endm
else
	   rept Reg87Len/2
	MOVS	word ptr es:[edi], word ptr cs:[esi]
	   endm
endif
	RET

ProfEnd  FCONST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfixfly.asm ===
page	,132
	subttl	emfixfly.asm - Fixup-on-the-fly routines
;***
;emfixfly.asm - Fixup-on-the-fly routines
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Fixup-on-the-fly routines
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*******************************************************************************
;	03/29/85 - added 286 optimizations to change FWAITs to NOPs
;	09/10/87 - added FWAIT's for BASIC error handling
;	11/02/87 - changed FWFixUpOnFly to check for errors
;*******************************************************************************


ProfBegin FIXFLY


ifdef	DOS3

pub	SOFixUpOnFly
	sti				; turn on interrupts
	fwait				; For BASIC error handling
	push	ax
	push	bp
	push	ds
	push	si
	mov	bp,sp			; Point to stack
	lds	si,dword ptr 8[bp]	; Fetch ret address,(points to after instruction)
	mov	al,[si] 		; get ESC byte
	or	byte ptr [si],0C0h	; turn back into ESC x byte
	dec	si			; Make SI point to start off instruction
	dec	si
	mov	8[bp],si		; Change ret address to return to instruction
	shr	al,1			; move 2 bits into correct position
	shr	al,1
	shr	al,1
	not	al			; negate them
	and	al,018h 		; mask to middle 2 bits
	or	al,fES			; turn into correct segmented override
	xchg	al,ah			; into high half
	mov	al,fFWAIT		; low byte
	mov	[si],ax 		; stuff it
	push	bx
	mov	bx,1			; bx = 1 to skip segment override
ifdef	WF
	jmp	fixupdone
else
	jmp	short fixupdone
endif

;	new routine - don't back patch - check for error
;	UNDONE - need to change this for Windows - can't edit code
;		 need to check errorcode

pub	FWFixUpOnFly
	sti				; turn on interrupts
	fwait				; For BASIC error handling


ifdef	WF
wfFaultHere = $-1
;	int 3
	push	ds			; ds[18] retip[20] retcs[22] retfl[24]
	push	es			; es[16]
	pusha				;
	mov	bp, sp			;
	mov	ax, EMULATOR_DATA
	mov	ds, ax
	cmp	[wfGoFast], 1
	jnz	WinSlow
	push	[bp+22]			; faulting CS - get data alias
	push	[wfSel]
	call	ChangeSelector
	mov	es, [wfSel]
	sub	word ptr [bp+20], 2
	mov	bx, [bp+20]		; point to faulting insn
	xor	ax, ax
	xchg	[wfInsn], ax
	or	ax, ax			; are we here due to fault?
	je	wfNoFault
	mov	es:[bx], ax		; yes - restore 'fake' INT 3d
	xor	ax,ax
	xchg	[errorcode],al		; get and reset errorcode
	mov	REMLSW, ax		; save error code

	popa
	pop	es
	pop	ds
	jmp     WinFastContinue

;	mov	ax, 353eh
;	int	21h
;	mov	ax, es			; does app have a handler?
;	or	ax, bx
;	jz	wfDone
;
;	mov	ax, [wfErr]
;
;	push	cs			; return to wfDone
;	push	offset wfDone
;
;	push	es			; call app handler
;	push	bx
;
;	retf

FWAITNOP equ (iNOP + 256*fFWAIT)
wfNoFault:				; this was a 'real' INT 3d,
	mov	es:[bx], FWAITNOP	; so we'll patch it to inline code

wfDone:
	popa
	pop	es
	pop	ds
	iret

WinSlow:				; can't use fast method, fall through
	popa
	pop	es
	pop	ds			; fall through into old code
endif

ifdef	POLLING 			; new exception handling under POLLING

ifdef  USE_IRET
FWAITiret:
	iret				; Edit to nop if error occurs

elseifdef  WINDOWS

	push	ds
	push	ax

	mov	ax, EMULATOR_DATA
	mov	ds, ax

	cmp	[ExceptFlag], 0 	; if not zero, 80x87 exception occured.

	pop	ax
	pop	ds

	jnz	PolledException

	iret

else	;DEFUALT

FWAITRetF   db	  bRETF 		; Edit to 3 byte nop if error occurs
FWAITRetF2  dw	  2

endif	;DEFAULT


pub  PolledException
	push	eax			; same frame as in emerror.asm
	push	ds			; get address from task DS

ifdef	standalone
	xor	ax,ax
	mov	ds,ax
	mov	ds,ds:[4*TSKINT+2]

elseifdef  _COM_
	mov	ds, [__EmDataSeg]

else	;not standalone or _COM_
	mov	ax,EMULATOR_DATA
	mov	ds,ax
endif	;not standalone or _COM_

    ;*
    ;*	Reset fwait polling flag.
    ;*

ifdef  USE_IRET
	mov	byte ptr cs:[FWAITiret], bIRET	; reset "iret"

elseifdef  WINDOWS
	mov	[ExceptFlag], 0

else	;DEFAULT
	mov	[FWAITRetF], bRETF		; reset "retf 2"
	mov	[FWAITRetF2], 2
endif	;DEFAULT


	xor	ax,ax
	xchg	[errorcode],al		; get and reset errorcode


ifdef  WINDOWS
	mov	REMLSW, ax		; save error code

	pop	ds
	pop	ax			; stack is now just an int stack frame
WinFastContinue:
	inc	bp
	push	bp
	mov	bp, sp
	push	ds

	push	ax			; save user's ax

	push	cs			; must set up another stack frame
	mov	ax, offset FF_DummyReturn
	push	ax
FF_DummyReturn:

	mov	word ptr [bp-2], EMULATOR_DATA	; emulator's ds goes on first frame

	inc	bp
	push	bp
	mov	bp, sp
	push	ds			; push user's ds onto dummy stack frame

	mov	ax, EMULATOR_DATA
	mov	ds, ax

	push	es			; if windows => setup SignalAddress for
	push	bx			; far call

	mov	ax, DOS_getvector*256 + TSKINT
	IntDOS

	mov	word ptr [SignalAddress], bx
	mov	word ptr [SignalAddress+2], es

	pop	bx
	pop	es

	mov	ax, REMLSW		; al = error code

	call	[SignalAddress] 	; execute signal routine

	pop	ds			; restore user's ds
	add	sp, 6			; get rid of dummy stack frame
	pop	ax			; restore user's ax

	add	sp, 2			; get rid of emulator ds on stack

	pop	bp
	dec	bp

	iret				; return

else	;not WINDOWS

	call	[SignalAddress] 	; execute signal routine

	pop	ds			; restore user DS
	pop	eax
	iret

endif	;not WINDOWS


else	;not POLLING
	push	ax
	mov	ax,FIWRQQ		; isolated FWAIT fixup
	jmp	short FixUpOnFly
endif	;not POLLING

pub	DSFixUpOnFly
	sti				; turn on interrupts
	fwait				; For BASIC error handling
	push	ax
	mov	ax,FIDRQQ		; DS segment fixup

pub	FixUpOnFly
	PUSH	BP
	PUSH	DS
	PUSH	SI
	MOV	BP,SP			; Point to stack
	LDS	SI,dword ptr 8[BP]	; Fetch ret address,(points to after instruction)
	DEC	SI			; Make SI point to instruction
	DEC	SI
	MOV	8[BP],SI		; Change ret address to return to instruction
	SUB	[SI],ax 		; Remove Fixup to convert to 8087 instruction
	push	bx
	xor	bx,bx			; bx = 0 for no segment override

;	For the 286 change FWAITs on numeric instructions to NOPs
;
;	ds:si = FWAIT address
;	ds:(si+bx+1) = 8087/287 instruction

pub	fixupdone
	push	sp			; check for 286
	pop	ax
	cmp	ax,sp
	jne	fixupxit		; not 286

	mov	ax,[bx+si+1]		; get instruction
	and	ax,030FBh		; mask for FSTCW/FSTSW/FSTENV/FSAVE
	cmp	ax,030D9h		; underlying bits
	jne	fixcheck2		; not one of the above
	mov	al,[bx+si+2]		; get 2nd byte of instruction again
	cmp	al,0F0h 		; check if kernel functions
	jb	fixupxit		;   no - exit

pub	fixcheck2
	mov	ax,[bx+si+1]		; get instruction
	and	ax,0FEFFh		; mask for FCLEX/FINIT
	cmp	ax,0E2DBh		; underlying bits
	je	fixupxit		; can't remove FWAIT

	mov	ax,[bx+si+1]		; get instruction
	cmp	ax,0E0DFh		; check for FSTSW AX
	je	fixupxit		; can't remove FWAIT

	mov	byte ptr [si],iNOP	; NOP the FWAIT

pub	fixupxit
	pop	bx
	POP	SI
	POP	DS
	POP	BP
	pop	ax
	IRET


endif	;DOS3

ProfEnd  FIXFLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfmul.asm ===
page	,132
	subttl	emfmul.asm - Multiplication
;***
;emfmisc.asm - Multiplication
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Multiplication
;
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;	     Multiplication		  ;
;					  ;
;-----------------------------------------;

; Perform multiply by summing partial products of 16x16 hardware multiply.
; Before each multiply, the operands are checked for zero to see if it can be
; skipped, since it's a slow operation on the 8086.  The sum is kept in
; registers as much as possible.  Any insignificant bits lost are ORed together
; and kept in a word on the top of the stack.  This can be used for sticky bit
; rounding. First we will need some macros.

ProfBegin FMUL


MULP	MACRO	SIOFFSET,DIOFFSET,NEXTLOC
	;Will multiply the words found at the given offsets if those words
	;are non-0. since we assume the numbers are normalized and the
	;most significant word has offset 6 we know that words with offset
	;6 are non-0 hence the conditional code in this macro.

	MOV	AX,SIOFFSET[esi]

    IF	SIOFFSET - 6	  ;When SI offset is 6 it is most sig word hence not 0
	OR	AX,AX
	JZ	short NEXTLOC
    ENDIF

    IF	DIOFFSET - 6
	MOV	DX,DIOFFSET[edi]
	OR	DX,DX
	JZ	short NEXTLOC
	MUL	DX
    ELSE
	MUL	WORD PTR DIOFFSET[edi]
    ENDIF

ENDM

ADDP	MACRO	HI,MID,LO
	;Will add the double word result of a multiply to the triple word
	; at HI:MID:LO using HI to record overflow

	ADD	LO,AX
	ADC	MID,DX
	ADC	HI,0
ENDM

STICKY	MACRO	R
	;R is the register containing the least significant word which
	;should be ORed to the sticky bit (kept on the stack) and then
	;cleared so the register can be reused

	POP	eax
	OR	AX,R
	PUSH	eax
	XOR	R,R
ENDM

page


RMBRQQ:     ; Routine MUL Both	 must see if we have two singles.

if	fastSP
	MOV	BX,DX
	XOR	BX,Single + 256*Single
	TEST	BX,Single + 256*Single
	JNZ	RMDRQQ
	MOV	BX,OFFSET TMSRQQ
	JMP	[BX]
endif	;fastSP


pub	RMDRQQ	;RoutineMulDouble     SI & DI point to valid non-0 reals
				; AX   CX  are the exponents
				; DL   DH  are the signs
if	fastSP
	CALL	CoerceToDouble	; insure that both args are double
endif	;fastSP

	PUSH	ebp		; Must save BP
	MOV	BH,DH		; Save Single double flag
	XOR	DH,DL		; Get sign onto stack
	PUSH	edx
	ADD	AX,CX		; New exponent is sum of old plus 1
	INC	AX		;  because of the normalize step
	PUSH	eax		; Save it while we Multiply
	AND	BH,DL

pub	PROD1
	XOR	BX,BX
	MOV	BP,BX
	MOV	CX,BX
	MULP	0,0,PROD2
	MOV	BP,AX		; Save insignificant bits
	MOV	CX,DX
pub	PROD2
	PUSH	ebp		; Save Sticky bit on stack
	xor	ebp, ebp	; bp is now the working high word of bp:bx:cx
	MULP	0,2,PROD3
	ADDP	BP,BX,CX
pub	PROD3
	MULP	2,0,PROD4
	ADDP	BP,BX,CX

pub	PROD4
	STICKY	CX
	MULP	0,4,PROD5
	ADDP	CX,BP,BX
pub	PROD5
	MULP	2,2,PROD6
	ADDP	CX,BP,BX
pub	PROD6
	MULP	4,0,PROD7
	ADDP	CX,BP,BX

pub	PROD7
	STICKY	BX
	MULP	0,6,PROD8
	ADDP	BX,CX,BP
pub	PROD8
	MULP	2,4,PROD9
	ADDP	BX,CX,BP
pub	PROD9
	MULP	4,2,PROD10
	ADDP	BX,CX,BP
pub	PROD10
	MULP	6,0,PROD11
	ADDP	BX,CX,BP

pub	PROD11
	MOV	DX,BP		; Everything but guard and round go to sticky
	AND	BP,03FFFH
	STICKY	BP
	PUSH	edx		; Save guard and round on stack
	MULP	2,6,PROD12
	ADDP	BP,BX,CX
pub	PROD12
	MULP	4,4,PROD13
	ADDP	BP,BX,CX
pub	PROD13
	MULP	6,2,PROD14
	ADDP	BP,BX,CX

pub	PROD14
	PUSH	ecx		; Save LSW on stack (not enough registers)
	XOR	CX,CX
	MULP	4,6,PROD15
	ADDP	CX,BP,BX
pub	PROD15
	MULP	6,4,PROD16
	ADDP	CX,BP,BX

pub	PROD16
	MULP	6,6,PROD17
	ADD	AX,BP
	ADC	DX,CX
	POP	ecx
	POP	ebp		; Result in DX:AX:BX:CX:BP Sticky on stack

	MOV	DI,DX
	MOV	DX,CX
	MOV	CX,BX
	MOV	BX,AX		; Result in DI:BX:CX:DX:BP
	POP	eax		; Merge Sticky bit into BP
	OR	AX,AX
	JZ	short STBITOK
	OR	BP,1
pub	STBITOK
	POP	esi		; Exponent in SI, Sign on Stack, Old BP on Stack
	JMP	NORMSHF 	; Result must be normalized at most 1 bit

ProfEnd  FMUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfsqrt.asm ===
page	,132
	subttl	emfsqrt.asm - Square root
;***
;emfsqrt.asm - Square root
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Square root
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;	     Square root		  ;
;					  ;
;-----------------------------------------;

ProfBegin FSQRT


pub	eFSQRT
	MOV	esi,[CURstk]
	CALL	$FSQRT
	RET

;---------------------------------------------------
;						   !
;	8087 emulator square root		   !
;						   !
;---------------------------------------------------

;  With 0<=x={TOS=[SI]}<infinity,  $FSQRT  performs   {TOS=[SI]}   <--
;  {TOS=[SI]}^.5.  All	registers  except  SI  are  destroyed.	 Roots
;  of negative numbers, infinities, and NAN's result in  errors.   The
;  square root	of  -0	is  -0.   Algorithm:   x is initially adjusted
;  so that the exponent is even (when the exponent is odd the exponent
;  is incremented  and	the  mantissa  is shifted right one bit).  The
;  exponent is then  divided  by  two  and  resaved.   A  single  word
;  estimate of	y (the root of x) accurate to 5 bits is produced using
;  a wordlength implementation of a  linear  polynomial  approximation
;  of  sqrt  x.  Four  Newton-Raphson  iterations are then computed as
;  follows:
;
;  1) qa*ya+r1a=xa:0h,ya=(ya+qa)/2
;  2) qa*ya+r1a=xa:xb,ya=(ya+qa)/2
;  3) qa*ya+r1a=xa:xb,qb*ya+r2a=r1a:xc,ya:yb=(ya:yb+qa:qb)/2
;  *** iteration 4 implemented with standard divide ***
;  4) qa*ya+r1a=xa:xb,p1a:p1b=qa*yb,
;     if p1a<r1a continue
;	 if p1a=r1a
;	    if p1b=xc continue else r1a=r1a+ya,qa=qa-1 endif,
;	 else r1a=r1a+ya,qa=qa-1,p1a:p1b=p1a:p1b-yb endif,
;     r1a:r1b=r1a:xc-p1a:p1b,
;     qb:ya+r2a=r1a:r1b,p2a:p2b=qb*yb,
;     if p2a<r2a continue
;	 if p2a=r2a
;	    if p2b=xd continue else r2a=r2a+ya,qb=qb-1 endif,
;	 else r2a=r2a+ya,qb=qb-1,p2a:p2b=p2a:p2b-yb endif,
;     r2a:r2b=r2a:xd-p2a:p2b,
;     qc*ya+r3a=r2a:r2b,p3a:p3b=qc*yb,
;     if p3a>=r3a then r3a=r3a+ya,qc=qc-1 endif,
;     r3a=r3a-p3a,qd*ya+r4a=r3a:0h,
;     ya:yb:yc:yd=(ya:yb:0h:0h+qa:qb:qc:qd)/2

pub	SQRTSPECIAL
	RCR	AH,1			;if NAN
	JNC	short SETFLAG		;   set invalid flag and return
	RCL	AL,1			;if -infinity
	JC	short SQRTERROR 	;   return real indefinite
	MOV	AL,[CWcntl]		;get Infinity control
	TEST	AL,ICaffine		;if affine closure
	JNZ	short SQRTDONE		;   return +infinity
	JMP	SHORT SQRTERROR 	;else return real indefinite

pub	NOTPOSVALID
	TEST	AH,2			;if special
	JNZ	SQRTSPECIAL		;   process special
	RCR	AH,1			;if zero
	JC	SHORT SQRTDONE		;   return argument
					;otherwise -ve, return NAN

pub	SQRTERROR
	MOV	edi,esi
	MOV	esi,offset IEEEindefinite
	CALL	csMOVRQQ
	MOV	esi,edi 		;return indefinite

pub	SETFLAG
	OR	[CURerr],Invalid+SquareRootNeg	;Set flag indicating invalid

pub	SQRTDONE
	RET

pub	$FSQRT
	MOV	AX,[esi+Flag]		;get flags
	TEST	AX,00380H		;if Sign, Invalid or Zero
	JNZ	NOTPOSVALID		;   perform special processing
	PUSH	esi			;save ptr to x
	MOV	edi,offset TEMP1	;[DI]=y=temp
	MOV	word ptr [edi+Flag],0	;clear flags in y
	MOV	AX,[esi+Expon]		;get exponent of x
	DEC	AX			;adjust for shift divide by 2
	MOV	BX,[esi+6]
	MOV	CX,[esi+4]
	MOV	DX,[esi+2]		;get first three mantissa words of x
	TEST	AL,1			;if exponent is even
	JZ	short EXPEVEN		;   bypass adjust
	INC	AX			;increment exponent
	SHR	BX,1
	RCR	CX,1
	RCR	DX,1			;divide mantissa by 2

pub	EXPEVEN
	SAR	AX,1			;divide exponent by 2
	MOV	[edi+Expon],AX		;store exponent of y
	CMP	BX,0FFFEH		;if mantissa < 0.FFFEh
	JB	short NOTNEARONE1	;   perform main root routine
	STC				;otherwise x to become (1+x)/2
	JMP	SHORT SINGLEDONE	;single precision complete

pub	NOTNEARONE1
	PUSH	edx			;save third mantissa word
	MOV	AX,0B075H		;AX=.B075h
	MUL	BX			;DX=.B075h*x
	MOV	BP,057D8H		;BP=.57D8h
	ADD	BP,DX			;BP=.B075h*x+.57D8h
	JNC	short NORMEST		;if y is more than one
	MOV	BP,0FFFFH		;   replace y with .FFFFh

pub	NORMEST
	MOV	DX,BX
	XOR	AX,AX			;load divide regs with xa:0h
	DIV	BP			;qa*ya+r1a=xa:0h
	ADD	BP,AX			;ya=ya+qa
	RCR	BP,1			;ya=ya/2
	MOV	DX,BX
	MOV	AX,CX			;load divide regs with xa:xb
	DIV	BP			;qa*ya+r1a=xa:xb
	STC				;add one to qa for better rounding
	ADC	BP,AX			;ya=ya+qa
	RCR	BP,1			;ya=ya/2
	MOV	DX,BX
	MOV	AX,CX			;load divide regs with xa:xb
	DIV	BP			;qa*ya+r1a=xa:xb
	MOV	SI,AX			;save qa
	POP	eax			;load divide regs with r1a:xc
	DIV	BP			;qb*ya+r2a=r1a:xc
	MOV	BX,BP
	MOV	CX,AX			;move qa:qb
	ADD	CX,1			;add one to qa:qb for better rounding
	ADC	BX,SI			;ya:yb=ya:0h+qa:qb

pub	SINGLEDONE
	RCR	BX,1
	RCR	CX,1			;ya:yb=(ya:0h+qa:qb)/2
	MOV	word ptr [edi+6],BX
	MOV	word ptr [edi+4],CX
	MOV	word ptr [edi+2],0
	MOV	word ptr [edi],0	;save ya:yb:0h:0h
	MOV	esi,edi 		;[SI]=y
	POP	edi			;[DI]=x
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=x/y
	MOV	esi,offset TEMP1	;[SI]=y
	CALL	ADDRQQ			;[DI]=y+x/y
	DEC	word ptr [edi+Expon]	;[DI]=(y+x/y)/2=TOS
	MOV	esi,edi 		;[SI]=sqrt(x)
	RET

ProfEnd  FSQRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emintern.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emintern.asm - Emulator Internal Format and Macros
page
;---------------------------------------------------------------------------
;
; Emulator Internal Format:
;
;	     +0  +1  +2  +3  +4  +5  +6  +7  +8  +9  +10 +11
;	    .___.___.___.___.___.___.___.___.___.___.___.___.
;   ptr --> |___|___|___|___|___|___|___|___|___|___|___|___|
;	     lsb			 msb exl exh flg tag
;	    |<---      mantissa 	--->|exponent
;
;   The mantissa contains the leading 1 before the decimal point in the hi
;   bit of the msb. The exponent is not biased i.e. it is a signed integer.
;   The flag and tag bytes are as below.
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Flag:   |___|_X_|_X_|_X_|_X_|_X_|_X_|___|  X = unused
;	      ^ 			  ^
;	     SIGN			SINGLE (=1 if single precision)
;
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Tag:    |_X_|_X_|_X_|_X_|_X_|_X_|___|___|  X = unused
;				      ^   ^
;				      |   |
;    Special (Set for NAN or Inf)  ---+   |
;    ZROorINF (Set for 0 or Inf)   -------+
;
PAGE
; Data Structure Equates
Lsb		equ	0
Msb		equ	7
 MB0		equ	0
 MB1		equ	1
 MB2		equ	2
 MB3		equ	3
 MB4		equ	4
 MB5		equ	5
 MB6		equ	6
 MB7		equ	7

Expon		equ	8

Flag		equ	10
 Sign		equ	128
if	fastSP
 Single 	equ	1
endif

Tag		equ	11
 Special	equ	2
 ZROorINF	equ	1

Reg87Len	equ	12

MantissaByteCnt equ	Msb - Lsb + 1
IexpBias	equ	3FFFh	; 16,383
IexpMax 	equ	7FFFh	; Biased Exponent for Infinity
IexpMin 	equ	0	; Biased Exponent for zero

DexpBias	equ	3FFh	; 1023
DexpMax 	equ	7FFh	; Biased Exponent for Infinity
DexpMin 	equ	0	; Biased Exponent for zero

SexpBias	equ	07Fh	; 127
SexpMax 	equ	0FFh	; Biased Exponent for Infinity
SexpMin 	equ	0	; Biased Exponent for zero

; Control Word Format	CWcntl
InfinityControl 	equ	10h
    ICaffine		equ	10h
    ICprojective	equ	 0

RoundControl		equ	0Ch
    RCchop		equ	0Ch
    RCup		equ	08h
    RCdown		equ	04h
    RCnear		equ	 0

PrecisionControl	equ	03h
    PC24		equ	 0
    PC53		equ	02h
    PC64		equ	03h

; Status Word Format	SWcc
    C0			equ	01h
    C1			equ	02h
    C2			equ	04h
    C3			equ	40h
ConditionCode		equ	C0 + C1 + C2+ C3
    CCgreater		equ	 0
    CCless		EQU	C0
    CCequal		equ	C3
    CCincomprable	equ	C3 + C2 + C0


; Status Flags Format	CURerr

Invalid 		equ	   1h		; chip status flags
Denormal		equ	   2h
ZeroDivide		equ	   4h
Overflow		equ	   8h
Underflow		equ	  10h
Precision		equ	  20h

Unemulated		equ	  40h		; soft status flags
SquareRootNeg		equ	  80h
IntegerOverflow 	equ	 100h
StackOverflow		equ	 200h
StackUnderflow		equ	 400h

UStatMask		equ	1FFFh		; user status flags

MemoryOperand		equ	2000h		; special instruction flags
Reexecuted		equ	4000h


;	floating point error signals (also used as DOS return code)

errInvalid		equ	81h		; sorted as above
errDenormal		equ	82h
errZeroDivide		equ	83h
errOverflow		equ	84h
errUnderflow		equ	85h
errPrecision		equ	86h

errUnemulated		equ	87h
errSquareRootNeg	equ	88h
errIntegerOverflow	equ	89h
errStackOverflow	equ	8Ah
errStackUnderflow	equ	8Bh


subttl	emintern.asm - Emulator interrupt frame
page

; define emulator interrupt frame

ifdef	i386

ifdef	XENIX

;	386 frame for XENIX

frame		struc			; emulator interrupt frame

regEAX		dd	?		; 386 registers
regECX		dd	?
regEDX		dd	?
regEBX		dd	?
regESP		dd	?
regEBP		dd	?
regESI		dd	?
regEDI		dd	?

regSegOvr	dw	?,?		; segment override for bp relative EAs
regES		dw	?,?
regDS		dw	?,?

regAX		dw	?,?		; original EAX - stuff area for FSTSW AX
regSS		dd	?		; need to save ss
regEIP		dd	?
regCS		dw	?,?
regFlg		dd	?

frame		ends

else

;	386 frame

frame		struc			; emulator interrupt frame

regEAX		dd	?		; 386 registers
regECX		dd	?
regEDX		dd	?
regEBX		dd	?
regESP		dd	?
regEBP		dd	?
regESI		dd	?
regEDI		dd	?

regSegOvr	dw	?,?		; segment override for bp relative EAs
regES		dw	?,?
regDS		dw	?,?

regAX		dw	?,?		; original EAX - stuff area for FSTSW AX
regEIP		dd	?
regCS		dw	?,?
regFlg		dd	?

frame		ends

endif

else

;	286 frame

frame		struc			; emulator interrupt frame

regBP		dw	?
regSegOvr	dw	?		; segment override for bp relative EAs
regBX		dw	?
regCX		dw	?
regDX		dw	?
regSI		dw	?
regDI		dw	?
regDS		dw	?
regES		dw	?
regAX		dw	?
regIP		dw	?
regCS		dw	?
regFlg		dw	?

frame		ends

endif	;i386


subttl	emintern.asm - User Memory Management Macros
page
;*********************************************************************;
;								      ;
;		      User Memory Management Macros		      ;
;								      ;
;*********************************************************************;

; All user data access uses these five macros.

; Load user memory word at (DS:)SI to AX register;  smash AX only

LDUS2AX MACRO
	lods	word ptr es:[esi]		; 12 move word from ES:SI to AX
	ENDM


; Store word from AX to user memory at (ES:)DI;  smash AX only

STAX2US MACRO
	stos	word ptr es:[edi]		; 10 move word from AX to ES:DI
	ENDM


; Move user memory word at (DS:)SI to local at (ES:)DI;  smash AX only

MVUS2DI MACRO
	movs	word ptr es:[edi],word ptr ds:[esi] ; 18 move word from DS:SI to ES:DI
	ENDM


; Move local word at (DS:)SI to user memory at (ES:)DI;  smash AX only

MVSI2US MACRO
	movs	word ptr es:[edi],word ptr ds:[esi] ; 18 move word from DS:SI to ES:DI
	ENDM


; Move local word at (CS:)SI to user memory at (ES:)DI;  smash AX only

csMVSI2US MACRO
	movs	word ptr es:[edi],word ptr cs:[esi]
	ENDM

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfprem.asm ===
page	,132
	subttl emfprem.asm - fprem
;***
;emfprem.asm - FPREM emulation
;
;	Copyright (c) 1987, Microsoft Corporation
;
;Purpose:
;	To emulate the 8087/80287 FPREM instruction.
;
;Revision History:
;   08-12-86  JMB   Initial version
;
;   09-23-86  JMB   Changed from unsigned (jnc) to signed branch
;		    (jge) on lc < 0 comparison
;
;   10-24-86  BCM   Fixed a problem with large quotients that
;		    caused a signed comparison (cmp bp,2) to
;		    behave in an undesired manner when bp (quotient)
;		    becomes larger than 32767; we now use bigquot
;		    to indicate a quotients overflowing an unsigned word
;		    Also, the quotient is now enregistered in bp
;		    through most of the FPREM algorithm.
;
;   11-14-86  BCM   Fixed a problem with the 4-word comparison of
;		    numerator and denominator mantissas by substituting
;		    unsigned-compare jumps (JB and JA) for signed-compare
;		    jumps (JL and JG).
;
;   Also see emulator.hst
;
;*******************************************************************************

;	The following is a working C program which was used to simulate
;	floating point numbers and to test the algorithm used in the
;	fprem emulation.

;#include <math.h>
;#include <stdio.h>
;
;typedef struct floating {
;	unsigned long man;
;	unsigned int expo;
;	} FLOAT_NUM;
;
;double fprem(double,double,unsigned int *);
;
;#define normalize(n) while (n&0x8000==0) { \
;			if (lc == 0) \
;			    return(ldexp((double)(num.man)/65536,den.expo)); \
;			n <<= 1; \
;			lc--; \
;			*pq <<=1; \
;			}
;
;
;main() {
;	unsigned int qv,qt;
;	double n,d,rv,rt;
;	FILE *fpinp;
;
;	fpinp = fopen("fprem.dat","r");
;	if (fpinp) {
;		while (fscanf(fpinp,"%E %E",&n,&d) != EOF) {
;			qv=(unsigned int)(n/d);
;			rv=n-(d*qv);
;			printf(" \nnumerator is %f\n denominator is %f",n,d);
;			printf(" \nquotient is %x\n remainder is %f",qv,rv);
;			rt = fprem(n,d,&qt);
;			printf(" \nquotient is %x\n remainder is %f\n\n",qt,rt);
;			}
;		fclose(fpinp);
;		}
;	else
;		printf(" \nerror opening fprem.dat");
;	}
;
;double fprem(n,d,pq)
;	double n,d;
;	unsigned int *pq; {
;	int lc;
;	FLOAT_NUM num;
;	FLOAT_NUM den;
;
;	num.man = (unsigned long)(65536*frexp(n,&num.expo));
;	den.man = (unsigned long)(65536*frexp(d,&den.expo));
;
;	printf(" \nnumerator mantissa: %lx",num.man);
;	printf(" \nnumerator exponent: %x",num.expo);
;	printf(" \ndenominator mantissa: %lx",den.man);
;	printf(" \ndenominator exponent: %x",den.expo);
;
;	*pq=0;
;	lc = num.expo - den.expo;
;	if (lc < 0) { /* then the numerator is the remainder */
;		return(ldexp((double)(num.man)/65536,num.expo));
;		}
;	while(1) {
;		if (den.man <= num.man) { /* do subtraction */
;			num.man -= den.man;
;			(*pq)++;
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}
;			normalize(num.man)
;			}
;		else { /* don't do the subtraction */
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}
;
;			num.man <<= 1;
;			lc--;
;			(*pq) <<= 1;
;
;			num.man -= den.man;
;			(*pq)++;
;
;			normalize(num.man)
;			}
;		}
;	}

;***
;eFPREM - entry point for FPREM emulation
;Purpose:
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;*******************************************************************************

ProfBegin FPREM


pub	eFPREM

; NOTE: The C program excerpts interspersed below are from the C program
;	shown in its entirety above.
;
;	The correspondence between the C variables and the assembly
;	language version is as follows:
;
;		C version		masm version
;		*pq			bp (quotient)
;		lc			loopct
;		num.expo		Expon[di]
;		den.expo		Expon[si]
;		num.man 		MB0[di],MB2[di],MB4[di],MB6[di]
;		den.man 		MB0[si],MB2[si],MB4[si],MB6[si]

;	*pq=0;
;	lc = num.expo - den.expo;

	push	ebp			;save bp; use bp as quotient

	mov	edi,[CURSTK]		;point to ST(0), the numerator
	mov	[RESULT],edi		;ST(0) is result (remainder)
	xor	bp,bp			;begin with quotient = 0
	mov	bigquot,0		;quotient not > 65535 yet
	mov	esi,edi 		;si points to ST(0)
	sub	esi,Reg87Len		;si points to ST(1), the denominator

	mov	ax,word ptr Expon[edi]	;ax <== numerator exponent
	sub	ax,word ptr Expon[esi]	;loopct = (num exponent - den exponent)

	mov	loopct,ax

	mov	dx,MB0[edi]		;move the mantissa of the
	mov	cx,MB2[edi]		;numerator into
	mov	bx,MB4[edi]		;ax:bx:cx:dx
	mov	ax,MB6[edi]

;	if (lc < 0) { /* then the numerator is the remainder */
;		return(ldexp((double)(num.man)/65536,num.expo));
;		}
	jge	short fpremLoop
	mov	si,Expon[edi]
	jmp	DoneEarly

;	while(1) {
fpremLoop:

;		if (den.man <= num.man) { /* do subtraction */
	cmp	ax,MB6[esi]		;compare msw of num to msw of den
	jb	short NumLess		;numerator is less
	ja	short NumMore		;numerator is more
	cmp	bx,MB4[esi]		;compare word 2 of num to word 2 of den
	jb	short NumLess		;numerator is less
	ja	short NumMore		;numerator is more
	cmp	cx,MB2[esi]		;compare word 4 of num to word 4 of den
	jb	short NumLess		;numerator is less
	ja	short NumMore		;numerator is more
	cmp	dx,MB0[esi]		;compare lsw of num to lsw of den
	jb	short NumLess		;numerator is less

;			num.man -= den.man;
;			(*pq)++;
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}

NumMore:
	call	SubInc			;do subtraction, increment quotient
	cmp	loopct,0		;is expon diff zero?
	je	short Done		;yes, then we're done

;			normalize(num.man)
;			}

	call	fpremNorm		;normalize the numerator
	jnz	fpremLoop		;do the next iteration
	jmp	short Done		;loop counter is zero; we're done

;		else { /* don't do the subtraction */
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}
NumLess:
	cmp	loopct,0		;is expon diff zero?
	je	short Done		;yes, then all done

;
;			num.man <<= 1;
;			lc--;
;			(*pq) <<= 1;
	call	ShiftDec		;shift quotient, numerator

;
;			num.man -= den.man;
;			(*pq)++;
	call	SubInc			;do subtraction, increment quotient
;
;			normalize(num.man)
;			}
	call	fpremNorm		;normalize for next iteration
	jnz	fpremLoop		;do next iteration
	jmp	short Done		;loop counter is zero; we're done

;	remainder:	ax:bx:cx:dx is mantissa; Expon[si] is the exponent
Done:

;NOTE: the rounding routine wants the mantissa in di:bx:cx:dx:bp
;	the exponent in SI the sign and the old BP on the stack
	mov	si,Expon[esi]		; mov exponent to si

DoneEarly:
	mov	di,Flag[edi]		; move sign of remainder to di
	xchg	di,ax			; di becomes high mantissa word
	mov	ah,al			; move sign to ah
	push	ax			; put sign on stack

; Except for bp which gets zeroed out later,
; everything is now set up the way it needs to be for the normalization
; routine, NODRQQ.  Before we go there we need to set up the status
; word as it should be set by fprem.  For simplicity we did a complete
; reduction of the dividend in one pass, so we will always clear C2
; to indicate that the reduction is complete.

	mov	ax,bp			; move quotient into ax
	and	bp,0FFFCh		; check if quotient mod 64K < 4
	or	bp,bigquot		;      and quotient < 64K

; bp is zero if and only if quotient < 4
; (bp no longer holds the quotient itself)
; al has low byte of quotient
; ah will be for C0-C3 flags

	mov	ah,SWcc 		; move status word to ah
	and	ah,not C2		; clear C2 to indicate complete
	test	al,01h			; is low bit of quotient set?
	jnz	short SetC1		; yes, go set C1
	and	ah,not C1		; low bit off, turn off C1
	jmp	short DoC3		; do the C3 bit
SetC1:
	or	ah,C1			; low bit on, turn on C1

DoC3:
	test	al,02h			; is bit 1 of quotient set?
	jnz	short SetC3		; yes, go set C3
	or	bp,bp			; is quotient less than 4?
	jz	short QuotL2		; then quotient < 2 (bit 1 off)
					; so don't set c0 or c3 from quotient
					; else if quotient >= 4
	and	ah,not C3		; bit 1 is off, so turn off C3
	jmp	short DoC0		; do the C0 bit
SetC3:
	or	ah,C3			; bit 1 on, turn on C3

DoC0:
	test	al,04h			; is bit 2 of quotient set?
	jnz	short SetC0		; yes, go set C0
	or	bp,bp			; is quotient less than 4?
	jz	short QuotL4		; yes, don't set c0 from quotient
					; else if quotient >= 4
	and	ah,not C0		; bit 2 off, turn off C0
	jmp	short GoNormal		; we're done, go normalize

SetC0:
	or	ah,C0			; bit 1 on, turn on C0
GoNormal:
	mov	SWcc,ah 		; set new status word
	xor	bp,bp			; clear low mantissa word
	jmp	NODRQQ			; go normalize
					; (does pop ax, pop bp)

; special case code if quotient is less than 2

QuotL2:
	mov	al,SWcc 		; get old status word
	test	al,C1			; was C1 set
	jnz	short SetC3toC1 	; yes, set C3
	and	ah,not C3		; clear C3
	jmp	short QuotL4

SetC3toC1:
	or	ah,C3			; set C3

; special case code if quotient is less than 4

QuotL4:
	mov	al,SWcc 		; get old status word
	test	al,C3			; was C3 set
	jnz	short SetC0toC3 	; yes, set C0
	and	ah,not C0		; clear C0
	jmp	short GoNormal		; go normalize the result

SetC0toC3:
	or	ah,C0			; set C0
	jmp	short GoNormal		; go normalize the result

;#define normalize(n) while (n&0x8000==0) { \
;			if (lc == 0) \
;			    return(ldexp((double)(num.man)/65536,den.expo)); \
;			n <<= 1; \
;			lc--; \
;			*pq <<=1; \
;			}

;Inputs: ah contains high byte of numerator mantissa
;Outputs: zero flag set indicates the loop counter is zero so we're finished
;	  zero flag clear indicates the number was already normalized
fpremNorm:
	test	ah,80h			;is the numerator normalized?
	jnz	short fpremIsNorm	;yes
					;no, normalize it
	cmp	loopct,0		;is expon diff zero?
	je	short fpremIsNorm	;yes, then we're done
	call	ShiftDec		;shift num, quotient
					;decrement loop ctr
	jmp	short fpremNorm

fpremIsNorm:
	ret

ShiftDec:
	shl	dx,1			;numerator*2
	rcl	cx,1
	rcl	bx,1
	rcl	ax,1
	dec	loopct			;reduce exponent diff by one
	shl	bp,1			;quotient*2
	jc	short QuotLarge 	;carry out on quotient shift
	ret
QuotLarge:
	mov	bigquot,1		;indicate large quotient > 65535
	ret

SubInc:
	sub	dx,MB0[esi]		;subtract lsw of den from lsw of num
	sbb	cx,MB2[esi]		;subtract next word of den from num
	sbb	bx,MB4[esi]		;subtract next word of den from num
	sbb	ax,MB6[esi]		;subtract msw of den from msw of num
	inc	bp			;add one to quotient
	ret


ProfEnd  FPREM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emlsdbl.asm ===
page	,132
	subttl	emlsdbl.asm - Load/Store Double Precision Numbers
;***
;emlsdbl.asm - Load/Store Double Precision Numbers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store Double Precision Numbers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		   Load Double Real				      ;
;								      ;
;*********************************************************************;
;
; Subroutine pushes double internal with double IEEE format at ES:SI

ProfBegin LSDBL


FLDSTOver:
	xchg	edi, esi	    ;  di = TOS, es:si = double in memory
	call	OverStk
	xchg	edi, esi	    ;  di = TOS, es:si = double in memory
	jmp	short FLDSTOk

	even

pub  eFLDdr
	mov	edi, [CURstk]	    ; Get current register
	cmp	edi, [LIMstk]	    ; Is current register the last register?
	jae	short FLDSTOver     ;	Then report overflow.

FLDSTOk:
	add	edi, Reg87Len	    ; Move to next free register.
	mov	[CURstk], edi	    ; Update current top of stack

	LDUS2AX
	mov	bp, ax
	LDUS2AX
	mov	dx, ax
	LDUS2AX
	mov	cx, ax
	LDUS2AX 		    ; get final 2 bytes of source

	mov	esi, edi	    ; ds:si = TOS

	mov	bx, ax		    ; Double in bx:cx:dx:bp

    ; assume we have a valid non-zero number so normalize and store

	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1

	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1

	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1

	OR	BL,80H		; Set leading bit of mantissa
	MOV	MB7[esi],BL
	MOV	MB5[esi],CX
	MOV	MB3[esi],DX
	MOV	MB1[esi],BP

	OR	CX,BP		; Will need to determine if number is 0 later
	OR	CX,DX		; so mash all the bits together
	MOV	DH,AH
	AND	DH,Sign 	; Mask everything but sign
	MOV	Flag[esi],DH	;  and store
	XOR	DH,DH		; Clear for Tag
	MOV	MB0[esi],DH	; Also clear out least significant byte
	AND	AH,7FH		; Remove sign from exponent
	SHR	AX,1		; Adjust
	SHR	AX,1
	SHR	AX,1
	SHR	AX,1
	CMP	AX,DexpMax	; See if number is NAN or Inf
	JE	short DNANorInf
	CMP	AX,DexpMin	; See if number is Zero or Denormal
	JE	short DZeroorDenorm
	SUB	AX,DexpBias	; Unbias exponent

pub	DStoreExpnTag
	MOV	Expon[esi],AX
	MOV	Tag[esi],DH
	RET

pub	DNANorInf
	MOV	AX,IexpMax - IexpBias	; Set exponent to internal max
	MOV	DH,Special		; Set Tag to show NAN or Inf
	CMP	BL,80H			; If anything other than leading bit
	JNE	short DStoreExpnTag	;  is set number is NAN (not Inf)
	OR	CX,CX
	JNE	DStoreExpnTag
	OR	DH,ZROorINF		; Set Tag to show Inf
	JMP	DStoreExpnTag

pub	DZeroorDenorm
	CMP	BL,80H			; If anything other than leading bit
	JNE	short DDenormal 	;  is set number is Denormal
	OR	CX,CX
	JNE	short DDenormal
	MOV	AX,IexpMin - IexpBias	; Set exponent to internal min
	MOV	DH,ZROorINF		; Set Tag to show 0
	JMP	DStoreExpnTag

pub	DDenormal
	OR	[CURerr],Denormal	; Set Denormal Exception
	SUB	AX,DexpBias		; unbias the Exponent
	MOV	BP,MB0[esi]		; must refetch mantissa and normalize
	MOV	DX,MB2[esi]
	MOV	CX,MB4[esi]
	MOV	BX,MB6[esi]
	INC	AX			; Shift once if exp = expmin

pub	DNormalize
	DEC	AX			; Drop exponent
	SHL	BP,1			; Shift mantissa
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	OR	BX,BX
	JNS	DNormalize

	MOV	MB0[esi],BP		; Store mantissa
	MOV	MB2[esi],DX
	MOV	MB4[esi],CX
	MOV	MB6[esi],BX
	XOR	DH,DH		    ; Clear Tag
	JMP	DStoreExpnTag

page
;*********************************************************************;
;								      ;
;		    Store Double Real				      ;
;								      ;
;*********************************************************************;
;

pub	DSpecial
	TEST	CL,Special	; NAN or INF?
	JNE	short DDNANorINF
	XOR	AX,AX		; Number is zero
	STAX2US
	STAX2US
	STAX2US
	STAX2US
	JMP	DCommonExit

pub	DDNANorINF
	TEST	CL,ZROorINF
	JNE	short DInf
	MOV	DX,MB1[esi]	; Number is a NAN
	MOV	BX,MB3[esi]	; Fetch Mantissa
	MOV	AX,MB5[esi]
	MOV	CL,MB7[esi]

	SHR	CL,1		; Shift into place
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	; Now store the Mantissa

	XCHG	DX,AX
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,DX
	STAX2US

	MOV	BH,Flag[esi]	; Pick up Sign
	AND	BH,Sign
	MOV	AX,DexpMax*16	; Load shifted max exponent
	OR	AH,BH		; Merge in sign
	OR	AL,CL		; Merge in top bits of Mantissa
	STAX2US
	JMP	DCommonExit

pub	DInf
	MOV	BL,Flag[esi]
	AND	BL,Sign
	JMP	DSignedInfinity

pub	JMPDOver
	JMP	DOver

pub	JMPDUnder
	JMP	DUnder

pub	JMPDSpecial
	JMP	DSpecial

	even

pub	eFSTdr

; internal TOS register at DS:SI to double IEEE in memory at ES:DI

	MOV	edi,esi 	; 10 save target memory offset
	MOV	esi,[CURstk]	; 14 source offset is current TOS

	MOV	CL,Tag[esi]	; See if number is NAN, Inf, or 0
	OR	CL,CL
	JNZ	short JMPDSpecial
	MOV	CL,Flag[esi]	; Pick up sign
if	fastSP
	TEST	CL,Single
	JZ	DD1
	MOV	word ptr MB0[esi],0
	MOV	word ptr MB2[esi],0
	MOV	byte ptr MB4[esi],0
DD1:
endif
	MOV	BP,Expon[esi]	; See if we blatently over or under flow
	CMP	BP,DexpMax - DexpBias
	JGE	JMPDOver
	CMP	BP,DexpMin - DexpBias
	JLE	JMPDUnder

	;Since we won't have room to decide about rounding after we load
	;the mantissa we will determine the rounding style first

	MOV	AL,MB0[esi]	; Low byte becomes sticky bit ...
	MOV	DX,MB1[esi]	;  when combined with lo 2 bits of next byte
	OR	AL,AL
	JZ	short NOSTK
	OR	DL,1

pub	NOSTK
	TEST	DL,7H		; See if anything will be chopped off in truncation
	JZ	short DTRUNC
	OR	[CURerr],Precision  ; number is not exact so set flag and round
	MOV	AL,[CWcntl]	    ; Pick up rounding control

	; Mantissa gets incremented for rounding only on these conditions:
	; (UP and +) or (DOWN and -) or
	; (NEAR and Roundbit and (Sticky or Oddlastbit))

	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	JC	short StDOWNorCHOP53
	SHR	AL,1
	JC	short StUP53

pub	StNEAR53
	TEST	DL,4H		; 3rd bit over is round bit
	JZ	short DTRUNC
	TEST	DL,0BH		; 4th bit is last bit, 1st and 2nd are Sticky
	JZ	short DTRUNC

pub	DINC			; Know we must increment mantissa so
	MOV	BX,MB3[esi]	; Fetch mantissa
	MOV	AX,MB5[esi]
	MOV	CL,MB7[esi]
	AND	CL,7FH		; Mask off leading bit
	ADD	DX,8H		; Add 1 to what will be last bit after the shift

	ADC	BX,0
	ADC	AX,0
	ADC	CL,0
	JNS	short DShift

	AND	CL,7FH		; Mask off leading bit
	INC	BP		; Increment exponent
	CMP	BP,DexpMax - DexpBias
	JL	short DShift	; And test for the rare chance we went over
	JMP	short DOverReset

	even

pub	StUP53
	SHL	CL,1		; Test sign
	JNC	short DINC	; UP and + means inc
	JMP	SHORT DTRUNC

pub	StDOWNorCHOP53
	SHR	AL,1
	JC	short StCHOP53

pub	StDOWN53
	SHL	CL,1		; Test sign
	JC	short DINC	; DOWN and - means inc

StCHOP53:
pub	DTRUNC
	MOV	BX,MB3[esi]	; Fetch mantissa
	MOV	AX,MB5[esi]
	MOV	CL,MB7[esi]
	AND	CL,7FH		; Mask off leading bit

pub	DShift
	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	; Now store the Mantissa

	XCHG	DX,AX
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,DX
	STAX2US

	MOV	AX,BP		    ; Merge in the exponent
	ADD	AX,DexpBias	    ; Bias exponent
	SHL	AX,1		    ; Shift into position
	SHL	AX,1
	SHL	AX,1
	SHL	AX,1
	OR	AL,CL		    ; Merge in top bits of Mantissa
	MOV	CL,Flag[esi]	    ; Pick up sign
	AND	CL,Sign
	OR	AH,CL		    ; Merge in the sign
	STAX2US

pub	DCommonExit
	RET			;  8 return

pub	DOverReset	    ; We come here if we stored 6 bytes of mantissa
			    ; befor detecting overflow so must reset pointer
	SUB	edi,6	    ; to double in memory

pub	DOver			; Here on overflow
	OR	[CURerr],Overflow + Precision
	MOV	BL,Flag[esi]
	AND	BL,Sign 	; Mask to sign
	MOV	CL,[CWcntl]	; Determine rounding style
	SHR	CL,1
	SHR	CL,1
	SHR	CL,1
	JC	short StMOVDNorCHP53
	SHR	CL,1
	JC	short StMOVUP53

StMOVNEAR53:
pub	DSignedInfinity
	MOV	esi,offset IEEEinfinityD
pub	DStore
	csMVSI2US
	csMVSI2US
	csMVSI2US
	LODS	word ptr cs:[esi]
	OR	AH,BL		;Overstore correct sign
	STAX2US
	JMP	DCommonExit

pub	StMOVDNorCHP53
	SHR	CL,1
	JC	short StMOVCHOP53

pub	StMOVDOWN53
	OR	BL,BL		; DOWN and + means biggest
	JNZ	short DSignedInfinity

StMOVCHOP53:
pub	DSignedBiggest
	MOV	esi,offset IEEEbiggestD
	JMP	DStore

pub	StMOVUP53
	OR	BL,BL		; UP and - means biggest
	JZ	DSignedInfinity
	JMP	DSignedBiggest

pub	DUnder
	OR	[CURerr],Underflow+Precision  ; Set flag
	ADD	BP,DexpBias		; Bias the exponent which was less than
	NEG	BP			; Min = 0 so convert to positive difference
ifdef	i386
	movzx	ecx,BP			; Convert to shift count
else
	MOV	CX,BP			; Convert to shift count
endif
	ADD	ecx,4			; 3 for Double format 1 to expose hidden bit

	MOV	DH,Flag[esi]		; Need and exp of 0 for denormal
	AND	DH,Sign

	MOV	DL,MB7[esi]
	MOV	BX,MB5[esi]
	MOV	BP,MB3[esi]
	MOV	AX,MB1[esi]

pub	DshiftLoop
	SHR	DL,1
	RCR	BX,1
	RCR	BP,1
	RCR	AX,1
	LOOP	DshiftLoop

	STAX2US
	MOV	AX,BP
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,DX
	STAX2US
	JMP	DCommonExit

ProfEnd  LSDBL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emfrndi.asm ===
page	,132
	subttl	emfrndi.asm - Round to INT
;***
;emfrndi.asm - Round to INT
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Round to INT
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		Round TOS to Integer				      ;
;								      ;
;*********************************************************************;

ProfBegin FRNDI


pub	eFRNDINT
	MOV	esi,[CURstk]	    ; Point to TOS
	MOV	CX,Expon[esi]	     ; Get exponent
	CMP	CX,63		    ; See if we have very large integer
	JGE	short DONERNDINT

if	fastSP
	MOV	BX,MB4[esi]	 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	TEST	byte ptr Flag[esi],Single
	JZ	RNDD
	XOR	BL,BL
	MOV	BP,BX
	XOR	BX,BX
	MOV	DX,BX
RND:
else
	MOV	BP,MB4[esi]	; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger

	XOR	AX,AX		    ; Test for zero
	OR	AX,DI
	OR	AX,BP
	OR	AX,BX
	OR	AX,DX
	JZ	short RoundIntToZero

	MOV	AX,63		    ; What expon should be if no shifting

	CALL	IntegerToInternal

pub	DONERNDINT
	RET

if	fastSP
RNDD:
	MOV	BP,BX
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
	JMP	RND
endif

pub	RoundIntToZero
	MOV	Expon[esi],IexpMin - IexpBias
	MOV	MB0[esi],AX
	MOV	MB2[esi],AX
	MOV	MB4[esi],AX
	MOV	MB6[esi],AX
	MOV	byte ptr Tag[esi],ZROorINF
	JMP	DONERNDINT
PAGE
pub	IntegerToInternal
	; On entry DI:BP:BX:DX is the integer (unsigned i.e. no longer in 2's
	; compliment) DS:SI points to TOS (the ultimate destination).
	; AX contains the Exponent (assuming that the number will require
	; no shifting. the routine will adjust it as it goes along)
	; On exit the mantissa and exponent will be put in TOS.
	; This routine is used to Load int16 and int32 also to round-to-int

	XOR	ecx,ecx

pub	SHIFTLEFT
	SHL	DX,1	    ; Left justify number
	RCL	BX,1
	RCL	BP,1
	RCL	DI,1
	JC	short DONESHIFT
	LOOP	SHIFTLEFT   ; CX will count number of shifts done

pub	DONESHIFT
	RCR	DI,1	    ; We went one too far so reset
	RCR	BP,1
	RCR	BX,1
	RCR	DX,1

	ADD	AX,CX		; Adjust exponent
	MOV	Expon[esi],AX	 ; Store exponent
	MOV	MB0[esi],DX	 ; Store mantissa
	MOV	MB2[esi],BX
	MOV	MB4[esi],BP
	MOV	MB6[esi],DI
	RET
PAGE
pub	InternalToInteger
	; On entry DI:BP:BX:DX is the mantissa, CX is the Exponent, and
	; DS:SI points to TOS where the number came from. On exit
	; DI:BP:BX:DX is an integer (unsigned i.e. needs to be jiggled to
	; 2's compliment based upon the sign in TOS) rounded according to
	; Round control.  This routine used to Store int16 and int32 also
	; by round-to-integer

ifdef	i386
	movsx	ecx,cx		; (ecx) = sign-extended cx
endif
	XOR	AX,AX		; Clear Stickybit (AL) and roundbit (AH)
	SUB	ecx,63		; Convert exponent to shift count
	NEG	ecx		; Shift will be done in 2 parts, 1st to get
	DEC	ecx		;  sticky then 1 more to get round
ifdef	i386
	JGE	short NOTRUNCATE; Shift count Neg means num was large int.
	JMP	TRUNCATE
NOTRUNCATE:
	JE	short GETROUND	; Zero shift means no sticky bit, only round
else
	JL	short TRUNCATE	; Shift count Neg means num was large int.
	JE	short GETROUND	; Zero shift means no sticky bit, only round
endif
	CMP	ecx,64		; If big shift count then number is all sticky
	JGE	short STICKYNOROUND

	cmp	ecx,48		; fast out for 16-bit ints
	jle	SHIFTRIGHT	;   no

	or	dx,bx
	or	dx,bp		; dx = low 48 bits
	jz	nostick48	; if 0 then no sticky bits
	or	al,1		; set sticky bit
nostick48:
	mov	dx,di		; move upper 16 to lower 16
	xor	di,di		; zero upper 48 bits
	mov	bp,di
	mov	bx,di
	sub	ecx,48		; just like looping 48 times

pub	SHIFTRIGHT
	SHR	DI,1		; Shift into sticky bit (lsb of AL)
	RCR	BP,1
	RCR	BX,1
	RCR	DX,1
	JNC	short LOOPEND
	RCL	AL,1

pub	LOOPEND
	LOOP	SHIFTRIGHT

pub	GETROUND
	SHR	DI,1		; Shift into round
	RCR	BP,1
	RCR	BX,1
	RCR	DX,1
	RCL	AH,1		; Shift round into lsb of AH

pub	GOTROUNDANDSTICKY
	OR	AX,AX		; Was number exact?
	JZ	short TRUNCATE
	OR	[CURerr],Precision
	TEST	[CWcntl],RCdown ; True if down or chop
	JNZ	short INTDNorCHP
	TEST	[CWcntl],RCup	; True if UP (or CHOP)
	JNZ	short INTUP

pub	INTNEAR
	OR	AL,DL		; In near mode inc if (sticky or lastbit) and Roundbit
	AND	AH,AL
	SHR	AH,1
	JNC	short TRUNCATE

pub	INCREMENT
	XOR	AX,AX
	ADD	DX,1
	ADC	BX,AX
	ADC	BP,AX
	ADC	DI,AX

INTCHOP:
pub	TRUNCATE
	RET

pub	STICKYNOROUND
	MOV	AL,1
	XOR	AH,AH
	XOR	DI,DI
	MOV	BP,DI
	MOV	BX,DI
	MOV	DX,DI
	JMP	GOTROUNDANDSTICKY

pub	INTDNorCHP
	TEST	[CWcntl],RCup	    ; True if UP or CHOP
	JNZ	INTCHOP

pub	INTDOWN
	TEST	byte ptr Flag[esi],Sign ; Truncate if round down and +
	JNZ	INCREMENT
	JMP	TRUNCATE

pub	INTUP
	TEST	byte ptr Flag[esi],Sign ; Truncate if round up and -
	JNZ	TRUNCATE
	JMP	INCREMENT

ProfEnd  FRNDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emftran.asm ===
page	,132
	subttl	emftran.asm - Transcendentals
;***
;emftran.asm - Transcendentals
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Transcendentals
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;	     Transcendentals		  ;
;					  ;
;-----------------------------------------;

ProfBegin FTRAN


pub	MoveCodeSItoDataSI
	PUSH	edi
	MOV	edi,offset COEFFICIENT
ifdef	i386
    rept	Reg87Len/4
	MOVS	dword ptr es:[edi],dword ptr cs:[esi]
    endm
else
    rept	Reg87Len/2
	MOVS	word ptr es:[edi],word ptr cs:[esi]
    endm
endif
	MOV	esi,offset COEFFICIENT
	POP	edi
	RET

;---------------------------------------------------
;						   !
;	8087 emulator transcendental utilities	   !
;						   !
;---------------------------------------------------

;  COMPcsSIDI is  analogous  to the 8086 CMP instruction with operands
;  cs:[SI],[DI].  All registers except CX and DX are  left  unaltered.
;  Zero and  negative  zero  are  determined to be unequal.  NAN's and
;  infinities may not be compared with this routine.
;
;  FRAT2X performs   {TOS=[DI]}   <--	{TOS=[SI]}*PNUM({TOS=[SI]}^2),
;  and program created {temp=[SI]} <-- PDEN({TOS=[SI]}^2).  On	input,
;  [BX] must  contain  the  degree  of	PNUM, the coefficients of PNUM
;  in descending order, the degree-1  of  PDEN	and  the  coefficients
;  of PDEN in descending order.  PDEN is evaluated assuming an implied
;  highest coefficient of one.	[BX] is left unaltered, ARG2 is loaded
;  with   {TOS}^2,  DENORX is  used, all  registers are destroyed with
;  DI returning the value input in SI.

pub	BOTHZERO
	CMP	CH,CH			;set flags to equal
	JMP	short COMPDONE		;compare finished

pub	COMPcsSIDI
	MOV	CX,CS
	MOV	DS,CX
	MOV	CX,[esi+Flag]		;get sign byte of [SI]
	AND	CL,Sign 		;mask for sign
	MOV	DX,ES:[edi+Flag]	;get sign byte of [DI]
	AND	DL,Sign 		;mask for sign
	CMP	DL,CL			;compare signs
	JNE	short SIGNDIFF
	PUSH	ES
	PUSH	esi
	PUSH	edi			;save pointers
	OR	CL,CL			;if signs are +
	JNS	short BOTHPOS		;   don't exchange pointers
	PUSH	DS
	PUSH	ES
	POP	DS
	POP	ES
	XCHG	esi,edi 		;exchange pointers
	XCHG	CX,DX			;exchange flags

pub	BOTHPOS
	AND	CH,ZROorINF		;mask for zero
	AND	DH,ZROorINF		;mask for zero
	CMP	DH,CH			;if exactly one zero
	JNE	short COMPDONE		;   then finished
	OR	CH,CH			;if both zero
	JA	BOTHZERO		;   then done after flags set
	MOV	CX,[esi+Expon]		;get exponent of [SI]
	ADD	CX,IexpBias		;make it unbiased
	MOV	DX,ES:[edi+Expon]	;get exponent of [DI]
	ADD	DX,IexpBias		;make it unbiased
	CMP	CX,DX
	JNE	short COMPDONE		;compare exponents
	ADD	esi,MB6
	ADD	edi,MB6
	STD
	CMPS	word ptr [edi],word ptr [esi]
	JNE	short COMPDONE
	CMPS	word ptr [edi],word ptr [esi]
	JNE	short COMPDONE
	CMPS	word ptr [edi],word ptr [esi]
	JNE	short COMPDONE
	CMPS	word ptr [edi],word ptr [esi]	;compare mantissas

pub	COMPDONE
	CLD
	POP	edi
	POP	esi
	POP	ES

pub	SIGNDIFF
	MOV	CX,ES
	MOV	DS,CX
	RET

pub	FRAT2X
	MOV	edi,offset DENORX	;[DI]=temp
	CALL	MOVRQQ			;[DI]=x=temp
	PUSH	edi			;save ptr to x=temp
	PUSH	esi			;save ptr to TOS
	PUSH	ebx			;save ptr to polynomials
	MOV	edi,offset ARG2 	;get ptr to space for x^2
	CALL	MOVRQQ			;copy x to space for x^2
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;ARG2 gets x^2
	POP	esi			;get ptr to numerator poly
ifdef	i386
	xor	ecx,ecx
endif
	LODS	word ptr CS:[esi]
	XCHG	CX,AX			;CX=denominator degree-1
	POP	edi			;[DI]=TOS
	CALL	csMOVRQQ		;[DI]=first coeff=TOS
	MOV	[RESULT],edi		;result=[DI]

pub	POLYLOOPA
	PUSH	ecx			;save no. of terms left
	PUSH	esi			;save ptr to next coeff
	MOV	esi,offset ARG2 	;get ptr to x^2
	CALL	MUDRQQ			;multiply TOS by x^2
	POP	esi			;get pointer to coeff
	ADD	esi,Reg87Len		;point to next coeff
	PUSH	esi			;save pointer to coeff
	CALL	MoveCodeSItoDataSI
	CALL	ADDRQQ			;add coeff to TOS
	POP	esi			;get ptr to coeff
	POP	ecx			;get no. of terms remaining
	LOOP	POLYLOOPA		;loop until no terms left

	MOV	ebx,esi 		;move poly ptr
	POP	esi			;[SI]=x=temp
	PUSH	esi			;save ptr to x
	PUSH	ebx			;save poly ptr
	CALL	MUDRQQ			;multiply poly by x
	POP	esi			;get ptr to poly
	ADD	esi,12			;[SI]=denominator degree-1
ifdef	i386
	xor	ecx,ecx
endif
	LODS	word ptr CS:[esi]
	XCHG	CX,AX			;CX=denominator degree-1
	POP	ebx			;[BX]=temp
	PUSH	edi			;save denominator ptr
	MOV	edi,ebx 		;[DI]=temp
	CALL	csMOVRQQ		;move second coeff to temp
	PUSH	ecx			;save poly degree-1
	PUSH	esi			;save ptr to denominator poly
	MOV	esi,offset ARG2 	;get ptr to x^2
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;add x^2 to temp
	POP	esi			;get ptr to second coeff
	POP	ecx			;get poly degree-1

pub	POLYLOOPB
	PUSH	ecx			;save no. of terms left
	ADD	esi,Reg87Len		;point to next coeff
	PUSH	esi			;save ptr to next coeff
	MOV	esi,offset ARG2 	;get ptr to x^2
	CALL	MUDRQQ			;multiply temp by x^2
	POP	esi			;get pointer to coeff
	PUSH	esi			;save pointer to coeff
	CALL	MoveCodeSItoDataSI
	CALL	ADDRQQ			;add coeff to temp
	POP	esi			;get ptr to coeff
	POP	ecx			;get no. of terms remaining
	LOOP	POLYLOOPB		;loop until no terms left

	MOV	esi,edi 		;[SI]=denominator=temp
	POP	edi			;[DI]=numerator=TOS
	RET
;-------------------------------------------------------------------------------

pub	eFPTAN
	MOV	esi,[CURstk]
	CALL	$FPTAN
	PUSH	esi
	PUSHST
	MOV	edi,[CURstk]
	POP	esi
	CALL	MOVRQQ
	RET

;---------------------------------------------------
;						   !
;	8087 emulator partial tangent		   !
;						   !
;---------------------------------------------------

;  When 0<=x={TOS=[SI]}<=pi/4  then  $FPTAN  performs  {TOS=[DI]}  <--
;  numerator tangent  ({TOS=[SI]}),  system  created  {temp=[SI]}  <--
;  denominator tangent	({TOS=[SI]).   Every  register	except	DI  is
;  destroyed.

pub	$FPTAN
	MOV	ebx,offset TANRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=TOS,
	RET				;   [SI]=denominator=temp
;-------------------------------------------------------------------------------

pub	eFPATAN
	MOV	edi,[CURstk]
	MOV	esi,edi
	MOV	AX,Flag[esi]
	SUB	edi,Reg87Len

pub	CALLFPATAN
	CALL	$FPATAN
	MOV	esi,[CURstk]
	POPST
	RET

;---------------------------------------------------
;						   !
;	8087 emulator arctangent		   !
;						   !
;---------------------------------------------------

;  When 0<y={[DI]=NOS}<=x={[SI]=TOS}<infinity  then  $FPATAN  performs
;  {NOS=[DI]} <--   arctangent({NOS=[DI]}/{TOS=[SI]}),	 TOS  is  left
;  unaltered.  All registers except DI are destroyed.

pub	$FPATAN
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;NOS=[DI] <-- [DI]/[SI]=x
	MOV	AL,0			;flag reset
	MOV	esi,offset TWOMRT3	;[SI]=2-3^.5
	CALL	COMPcsSIDI		;if 2-3^.5 >= x
	JNB	short ATNREDUCED	;   then bypass arg reduction
	MOV	esi,edi 		;[SI]=x=NOS
	MOV	edi,offset TEMP1	;[DI]=temp
	CALL	MOVRQQ			;[DI]=x=temp
	PUSH	esi			;save NOS
	MOV	esi,offset RT3		;[SI]=3^.5
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;[DI]=3^.5*x=temp
	MOV	esi,offset cFLD1	;[SI]=1
	CALL	MoveCodeSItoDataSI
	CALL	SUDRQQ			;[DI]=3^.5*x-1
	POP	esi			;get NOS
	PUSH	edi			;save ptr to 3^.5*x-1
	MOV	edi,esi 		;DI gets NOS
	MOV	esi,offset RT3		;[SI]=3^.5
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;[DI]=x+3^.5=NOS
	POP	esi			;[SI]=3^.5*x-1
	CALL	DRDRQQ			;[DI]=(3^.5*x-1)/(x+3^.5)=NOS
	MOV	AL,1			;flag set

pub	ATNREDUCED
	PUSH	eax			;save flag
	MOV	esi,edi 		;[SI]=reduced x=NOS
	MOV	ebx,offset ATNRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=NOS,
					;   [SI]=denominator=temp
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=arctan(reduced x)=NOS
	POP	eax			;get flag
	OR	AL,AL			;if flag=0
	JZ	short ATNCOMPLETE	;   bypass adjust
	MOV	esi,offset PIBY6	;[SI]=pi/6
	CALL	MoveCodeSItoDataSI
	CALL	ADDRQQ			;[DI]=arctan(x)=NOS

pub	ATNCOMPLETE
	RET
;-------------------------------------------------------------------------------

pub	eF2XM1
	MOV	esi,[CURstk]
	CALL	$F2XM1
	RET

;---------------------------------------------------
;						   !
;	8087 emulator exponential		   !
;						   !
;---------------------------------------------------

;  When  0<=x={TOS=[SI]}<=.5  then  $F2XM1  performs  {TOS=[SI]}   <--
;  2^{TOS=[SI]}-1.  All registers except SI are destroyed.

pub	$F2XM1
	MOV	ebx,offset EXPRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=TOS
	PUSH	edi			;save numerator=TOS
	XCHG	esi,edi 		;[SI]=numerator, [DI]=denominator
	MOV	[RESULT],edi		;result=[DI]
	CALL	SUDRQQ			;[DI]=denominator-numerator
	MOV	esi,edi 		;[SI]=denominator-numerator
	POP	edi			;[DI]=numerator=TOS
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=(2^x-1)/2
	INC	word ptr [edi+Expon]	;[DI]=2^x-1
	MOV	esi,edi 		;[SI]=2^x-1
	RET
;-------------------------------------------------------------------------------

pub	eFYL2X
	MOV	edi,[CURstk]
	MOV	esi,edi
	MOV	AX,Flag[esi]
	SUB	edi,Reg87Len

pub	CALLFYL2X
	CALL	$FYL2X
	MOV	esi,[CURstk]
	POPST
	RET


;---------------------------------------------------
;						   !
;	8087 emulator multiple of logarithm	   !
;						   !
;---------------------------------------------------

;  When -infinity<y={NOS=[DI]}<infinity   and  0<x={TOS=[SI]}<infinity
;  then $FYL2X performs  {NOS=[DI]}  <--  {NOS=[DI]}*log2({TOS=[SI]}).
;  TOS is  left  unaltered,  all  registers  except  DI are destroyed.

pub	$FYL2X
	PUSH	esi			;save ptr to x=TOS
	MOV	esi,edi 		;[SI]=y=NOS
	MOV	edi,offset TEMP2	;[DI]=temp2
	CALL	MOVRQQ			;[DI]=y=temp2
	MOV	edi,esi 		;[DI]=y=NOS
	POP	esi			;[SI]=x=TOS
	PUSH	edi			;save ptr to y=NOS
	MOV	edi,offset TEMP3	;[DI]=temp3
	CALL	MOVRQQ			;[DI]=x=temp3
	MOV	BX,[edi+Expon]		;BX=exponent of x
	MOV	word ptr [edi+Expon],0	;set exponent of x to 0
	MOV	esi,offset RT2		;[SI]=2^.5
	CALL	COMPcsSIDI		;if reduced x < 2^.5
	JA	short LOGREDUCED	;   then bypass normalization
	DEC	word ptr [edi+Expon]	;otherwise make x < 2^.5
	INC	BX			;adjust exponent

pub	LOGREDUCED
	PUSH	ebx			;save exponent of x
	MOV	esi,offset cFLD1	;[SI]=1
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	SUDRQQ			;[DI]=(reduced x)-1=temp3
	MOV	esi,edi 		;[SI]=(reduced x)-1=temp3
	POP	ebx			;get exponent of x
	POP	edi			;[DI]=y=NOS
	PUSH	ebx			;save exponent of x
	CALL	$FYL2XP1		;[DI]=y*log2(reduced x)=NOS
	POP	ebx			;get exponent of x
	XOR	AX,AX			;zero AX
	OR	BX,BX			;if exponent is zero
	JZ	short LOGRETURN 	;   then done
	MOV	DX,AX			;make sign +
	JNS	short EXPPOSITIVE	;if + then bypass adjust
	MOV	DL,Sign 		;make sign -
	NEG	BX			;negate exponent

pub	EXPPOSITIVE
	MOV	CX,16			;initialize bit count

pub	LOGLOOP
	DEC	CX			;decrement shift count
	SHL	BX,1			;and shift exponent of x left
	JNC	LOGLOOP 		;until carry detected
	PUSH	edi			;save ptr to y*log2(reduced x)=NOS
	RCR	BX,1			;normalize exponent of x
	MOV	edi,offset TEMP3	;[DI]=temp3
	STOS	word ptr es:[edi]
	STOS	word ptr es:[edi]
	STOS	word ptr es:[edi]
	MOV	AX,BX
	STOS	word ptr es:[edi]
	MOV	AX,CX
	STOS	word ptr es:[edi]
	MOV	AX,DX
	STOS	word ptr es:[edi]	;store exponent of x in temp3
	MOV	edi,offset TEMP2	;[DI]=y=temp2
	MOV	esi,offset TEMP3	;[SI]=exponent of x=temp3
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;[DI]=y*exponent of x=temp2
	MOV	esi,edi 		;[SI]=y*exponent of x=temp2
	POP	edi			;[DI]=y*log2(reduced x)=NOS
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;[DI]=y*log2(x)=NOS

pub	LOGRETURN
	RET
;-------------------------------------------------------------------------------

pub	eFYL2XP1
	MOV	edi,[CURstk]
	MOV	esi,edi
	MOV	AX,Flag[esi]
	SUB	edi,Reg87Len

pub	CALLFYL2XP1
	CALL	$FYL2XP1
	MOV	esi,[CURstk]
	POPST
	RET

;---------------------------------------------------
;						   !
;	8087 emulator add 1 multiple of logarithm  !
;						   !
;---------------------------------------------------

;  When 	      -infinity<y={[DI]=NOS}<infinity		   and
;  2^-.5-1<=x={[SI]=TOS}<2^.5-1 then  $FYL2XP1	 performs   {NOS=[DI]}
;  <-- {NOS=[DI]}*log2({TOS=[SI]}+1).	TOS  is  left  unaltered,  all
;  registers except DI are destroyed.

pub	$FYL2XP1
	PUSH	edi			;save ptr to y
	MOV	edi,offset TEMP1	;[DI]=temp
	CALL	MOVRQQ			;[DI]=x=temp
	PUSH	esi			;save ptr to x
	MOV	esi,offset TWO		;[SI]=2
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;[DI]=x+2=temp
	POP	esi			;[SI]=x=TOS
	CALL	DRDRQQ			;[DI]=x/(x+2)=temp
	INC	word ptr [edi+Expon]	;[DI]=2x/(x+2)=temp
	MOV	esi,edi 		;[SI]=2x/(x+2)=temp
	MOV	ebx,offset LOGRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=temp,
					;   [SI]=denominator=temp
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=log2(x+1)=temp
	MOV	esi,edi 		;[SI]=log2(x+1)=temp
	POP	edi			;get ptr to y=NOS
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;[DI]=y*log2(x+1)=NOS
	RET

ProfEnd  FTRAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emlsint.asm ===
page	,132
	subttl	emlsint.asm - Load/Store 16/32-bit integers
;***
;emlsint.asm - Load/Store 16/32-bit integers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store 16/32-bit integers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		 Load Single (16 Bit) Integer			      ;
;								      ;
;*********************************************************************;

; ES:SI: memory address of 16 bit integer

ProfBegin LSINT


pub	eFLDsi
	LDUS2AX 		; Fetch the integer
	MOV	DI,AX		;  into DI:BP:BX:DX
	OR	DI,DI
	JZ	short LoadZero
	XOR	BP,BP
	MOV	BX,BP
	MOV	DX,BX

	MOV	AX,15		; Exponent would be 15 if no shifts needed
	PUSHST			; Get a new TOS
	XOR	CL,CL
	MOV	Tag[esi],CL	; Tag number as valid non-zero
	MOV	CX,DI		; Sign of Integer to CH
	AND	CH,Sign
if	fastSP
	OR	CH,Single
endif
	JNS	short SETFLAG16 ; If positive integer set the flag

	NEG	DI		; Otherwise compliment the number first

pub	SETFLAG16
	MOV	Flag[esi],CH
	JMP	IntegerToInternal

pub	LoadZero
	PUSHST			; Get a new TOS
	XOR	AX,AX
	MOV	MB0[esi],AX
	MOV	MB2[esi],AX
	MOV	MB4[esi],AX
	MOV	MB6[esi],AX
	MOV	Expon[esi],IexpMin - IexpBias
	MOV	Flag[esi],AH
	MOV	AH,ZROorINF
	MOV	Tag[esi],AH
	RET
PAGE
;*********************************************************************;
;								      ;
;		 Store Single (16 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 16 bit integer

pub	eFSTsi
	PUSH	esi		; Save memory address for store
	MOV	esi,[CURstk]
				; Test for special conditions
	TEST	byte ptr Tag[esi],Special ; If number is not in range it is overflow
	JNZ	short IntegerOverflow16
	TEST	byte ptr Tag[esi],ZROorINF
	JNZ	short StoreIntegerZero16
				; Fetch Exponent & test fo blatent overflow
	MOV	CX,Expon[esi]
	CMP	CX,15
	JG	short IntegerOverflow16

if	fastSP
	MOV	BX,MB4[esi]	 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	TEST	byte ptr Flag[esi],Single
	JZ	SSID
	XOR	BL,BL
	MOV	BP,BX
	XOR	BX,BX
	MOV	DX,BX
SSI:
else
	MOV	BP,MB4[esi]	 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger
				; Integer now in BX:DX (not yet 2's compliment)
	OR	BX,BX		; Test again for Overflow
	JNZ	short IntegerOverflow16
	MOV	AH,Flag[esi]	; See if we need to compliment
	OR	AH,AH
	JNS	short Int16in2sComp

	NEG	DX
	JZ	short Store16	; Special case 0

pub	Int16in2sComp
	XOR	AX,DX		; If Signs agree we did not overflow
	JS	short IntegerOverflow16

pub	Store16
	POP	edi		; Restore Memory address
	MOV	AX,DX
	STAX2US
	RET

if	fastSP
SSID:
	MOV	BP,BX
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
	JMP	SSI
endif

pub	StoreIntegerZero16
	XOR	DX,DX
	JMP	Store16

pub	IntegerOverflow16
	OR	[CURerr],Invalid
	MOV	DX,8000H	; Integer Indefinite
	JMP	Store16

page
;*********************************************************************;
;								      ;
;		 Load Double (32 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 32 bit integer

pub	eFLDdi
	LDUS2AX 		; Fetch the integer
	MOV	BP,AX		;  into DI:BP:BX:DX
	LDUS2AX
	MOV	DI,AX

	OR	AX,BP
	JZ	short JMPLoadZeroBecauseThisLanguageHasNoFarConditionalJump
	XOR	BX,BX
	MOV	DX,BX

	MOV	AX,31		; Exponent would be 31 if no shifts needed
	PUSHST			; Get a new TOS
	XOR	CL,CL
	MOV	Tag[esi],CL	; Tag number as valid non-zero
	MOV	CX,DI		; Sign of Integer to CH
	AND	CH,Sign
	JNS	short SETFLAG32 ; If positive integer set the flag

	XOR	DI,0FFFFH	; Otherwise compliment the number first
	XOR	BP,0FFFFH
	ADD	BP,1
	ADC	DI,0

pub	SETFLAG32
	MOV	Flag[esi],CH
	OR	DI,DI
	JZ	short SPEEDSHIFT32
	JMP	IntegerToInternal

JMPLoadZeroBecauseThisLanguageHasNoFarConditionalJump:
	JMP	LoadZero

pub	SPEEDSHIFT32
	MOV	DI,BP
	XOR	BP,BP
	SUB	AX,16
	JMP	IntegerToInternal

page
;*********************************************************************;
;								      ;
;		Store Double (32 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 32 bit integer

pub	eFSTdi
	PUSH	esi
	call	TOSto32int		; convert TOS to 32-bit integer
	POP	edi			; Restore Memory address
	MOV	AX,DX
	STAX2US
	MOV	AX,BX
	STAX2US
	RET


pub	TOSto32int
	MOV	esi,[CURstk]
					; Test for special conditions
	TEST	byte ptr Tag[esi],Special ; If number is not in range it is overflow
	JNZ	short IntegerOverflow32
	TEST	byte ptr Tag[esi],ZROorINF
	JNZ	short StoreIntegerZero32
					; Fetch Exponent & test fo blatent overflow
	MOV	CX,Expon[esi]
	CMP	CX,31
	JG	short IntegerOverflow32

if	fastSP
	MOV	BX,MB4[esi]		 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	TEST	byte ptr Flag[esi],Single
	JZ	SDID
	XOR	BL,BL
	MOV	BP,BX
	XOR	BX,BX
	MOV	DX,BX
SDI:
else
	MOV	BP,MB4[esi]		; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger
					; Integer in BP:BX:DX (not yet 2's compliment)
	OR	BP,BP			; Test again for Overflow
	JNZ	short IntegerOverflow32
	MOV	AH,Flag[esi]		; See if we need to compliment
	OR	AH,AH
	JNS	short Int32in2sComp

	XOR	BX,0FFFFH		; 2's Compliment of BX:DX
	XOR	DX,0FFFFH
	ADD	DX,1
	ADC	BX,0

pub	Int32in2sComp
	XOR	AX,BX			; If Signs agree we did not overflow
	JS	short IntOverOrZero32	; Special case is -0 which we let pass

pub	Store32
	ret

if	fastSP
SDID:
	MOV	BP,BX
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
	JMP	SDI
endif

pub	StoreIntegerZero32
	XOR	DX,DX
	MOV	BX,DX
	ret

pub	IntOverOrZero32
	OR	BX,DX
	JZ	Store32

pub	IntegerOverflow32
	OR	CURerr,Invalid
	MOV	BX,8000H	; Integer Indefinite
	XOR	DX,DX
	ret

ProfEnd  LSINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emlssng.asm ===
page	,132
	subttl	emlssng.asm - Load/Store Single Precision Numbers
;***
;emlssng.asm - Load/Store Single Precision Numbers
;
;	Copyright (c) 1984-89, Microsoft Corporation
;
;Purpose:
;	Load/Store Single Precision Numbers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin LSSNG

;*********************************************************************;
;								      ;
;			 Load Single Real			      ;
;								      ;
;*********************************************************************;
;
; Subroutine converts single in regs to internal at ES:SI


pub	eFLDsr
	LDUS2AX 		;    get lower mantissa part
	MOV	DI,AX		;  2 keep lower mantissa in DX
	LDUS2AX 		;    get upper exponent/sign part
	MOV	DL,AL		;  2 copy most sig. mantissa byte
	ROL	AX,1		;  2 sign to AL, exponent to AH
	AND	AL,1		;  4 clear all flags except sign
	ROR	AL,1		;  2 get sign in right position
	XCHG	AL,AH

    ; AX, DI, DL: operand one

	PUSHST			; 64 allocate another register

pub	SingleToInternal

	OR	DL,80H		; Set leading bit of mantissa
	XOR	DH,DH		; Set Tag to valid non-zero
	CMP	AL,SexpMax	; Is Number NAN or Inf?
	JE	short SNANorInf
if	fastSP
	OR	AH,Single	; Set single Precision flag
endif
	CMP	AL,SexpMin	; Is Number Zero or Denormal
	JE	short SZeroOrDenorm
				; Otherwise number is valid non-zero
	MOV	Flag[esi],AH	 ; Store sign
	SUB	AL,SexpBias	; Unbias the exponent
	CBW

pub	SStoreExpnTag
	MOV	Expon[esi],AX	 ; Store Exponent
	MOV	Tag[esi],DH	 ; Store Tag
	MOV	MB7[esi],DL	 ; Store Mantissa
	MOV	MB5[esi],DI
ife	fastSP
	XOR	AX,AX		; Clear low order bytes of Mantissa
	MOV	MB4[esi],AL
	MOV	MB2[esi],AX
	MOV	MB0[esi],AX
endif
	RET

pub	SNANorInf
	MOV	Flag[esi],AH		; Store sign
	MOV	AX,IexpMax - IexpBias	; Set exponent to internal max
	MOV	DH,Special		; Set Tag to show NAN or Inf
	CMP	DL,80H			; If anything other than leading bit
	JNE	short SStoreExpnTag	;  is set number is NAN (not Inf)
	OR	DI,DI
	JNE	short SStoreExpnTag
	OR	DH,ZROorINF		; Set Tag to show Inf
	JMP	SStoreExpnTag

pub	SZeroorDenorm
	MOV	Flag[esi],AH		; Store sign
	CMP	DL,80H			; If anything other than leading bit
	JNE	short SDenormal 	;  is set number is Denormal
	OR	DI,DI
	JNE	short SDenormal
	MOV	AX,IexpMin - IexpBias	; Set exponent to internal min
	OR	DH,ZROorINF		; Set Tag to show 0
	JMP	SStoreExpnTag

pub	SDenormal
	OR	[CURerr],Denormal	; Set Denormal Exception
	SUB	AL,SexpBias		; unbias the Exponent
	CBW
	INC	AX

pub	SNormalize
	DEC	AX
	SHL	DI,1
	RCL	DL,1
	OR	DL,DL
	JNS	SNormalize

	JMP	SStoreExpnTag

page
;************************************************************;
;							     ;
;		 Store Single Real			     ;
;							     ;
;************************************************************;

pub	SSpecial		; number is NAN or INF or Zero
	TEST	CL,Special	; NAN or INF?
	JNE	short SSNANorINF
	XOR	AX,AX		; Number is Zero
	MOV	BX,AX
	JMP	STRUNC

pub	SSNANorINF
	TEST	CL,ZROorINF
	JNE	short SInf
	MOV	BX,MB5[esi]	 ; Number is a NAN
	MOV	AL,MB7[esi]
	MOV	AH,Flag[esi]	 ; Pick up Sign
	SHL	AX,1		; Destroy leading bit, Sign to CF
	MOV	AH,SexpMax
	RCR	AX,1
	JMP	STRUNC

 pub	SInf
	MOV	AH,Flag[esi]
	JMP	SSignedInfinity

pub	JMPSOver
	JMP	SOver

pub	JMPSUnder
	JMP	SUnder

; ES:SI: memory address of single
; stores and misc. operations;	first setup register values as follows:
; AX: TOS flags (for DOUB and SIGN flags)
; SI: TOS address (offset)

pub	eFSTsr
	mov	edi,esi 	; ES:DI = store address
	MOV	esi,[CURstk]	 ; 14 load TOS address
	MOV	AX,Flag[esi]	 ; 21 get TOS flags (sign, double)

; convert internal at DS:SI to single
; DS:SI = TOS, ES:DI = memory, CH = operation (POP), BP = old ES value

	MOV	CL,Tag[esi]	 ; See if number is NAN or Inf or Zero
	OR	CL,CL
	JNZ	short SSpecial
	MOV	CL,Flag[esi]	 ; Pick up sign & single precision flag

	MOV	AX,Expon[esi]
	CMP	AX,SexpMax - SexpBias
	JGE	short JMPSOver
	CMP	AX,SexpMin - SexpBias
	JLE	short JMPSUnder

	ADD	AL,SexpBias	; Bias the Exponent
	MOV	AH,MB7[esi]	 ; Pick up MSB of Mantissa
	XCHG	AH,AL
	SHL	AL,1		; Shift mantissa to destroy leading integer bit
	SHL	CL,1		; Get sign into CF
	RCR	AX,1		; Pack sign, exp, & MSB
if	fastSP
	TEST	CL,Single*2	; if number was single rounding is not needed
	JZ	SS1
	MOV	BX,MB5[esi]
	JMP	SHORT STRUNC
SS1:
endif
	MOV	DX,MB0[esi]	 ; DL Will be the sticky bit
	OR	DX,MB2[esi]	 ; DH will be round and the rest of sticky
	OR	DL,DH
	XOR	DH,DH
	MOV	BX,MB5[esi]
	OR	DX,MB3[esi]
	JZ	short STRUNC	; If no Round or Sticky result is exact
	OR	[CURerr],Precision

pub	SRound			; single in AX:BX:DX
	MOV	CL,[CWcntl]	; Need to know Rounding Control
	SHR	CL,1
	SHR	CL,1
	SHR	CL,1
	JC	short StDOWNorCHOP24
	SHR	CL,1
	JC	short StUP24

pub	StNEAR24
	CMP	DX,8000H	; How are round and sticky bits?
	JB	short STRUNC	; No round, so truncate
	JA	short SINC	; Round and sticky so round up
	TEST	BL,1		; Round and no sticky, is last bit even?
	JZ	short STRUNC	; Yes, so truncate.

pub	SINC
	MOV	DL,AL		; Increment mantissa
	ADD	BX,1
	ADC	AX,0
	XOR	DL,AL		; See if we overflowed a bit into the exponent
	JNS	short STRUNC	; If not number is now correct so go store
	MOV	DX,AX		; Exponent was incremented, see if it overflowed
	SHL	DX,1
	CMP	DH,SexpMax
	JE	short SOver

pub	StCHOP24
STRUNC:
	XCHG	AX,BX
	STAX2US
	MOV	AX,BX
	STAX2US

pub	SStoreExit
	RET

pub	StDOWNorCHOP24
	SHR	CL,1
	JC	short StCHOP24

pub	StDOWN24
	OR	AH,AH			; Test the sign
	JS	short SINC
	JMP	short STRUNC

pub	StUP24
	OR	AH,AH			; Test the sign
	JS	short STRUNC
	JMP	short SINC

pub	SOver				; Number overflowed Single Precision range.
					; Result returned depends upon rounding control
	OR	[CURerr],Overflow + Precision
	MOV	CL,[CWcntl]
	SHR	CL,1
	SHR	CL,1
	SHR	CL,1
	JC	short StMOvDNorCHP24

	SHR	CL,1
	JC	short StMOvUP24

StMOvNEAR24:				; Masked Overflow Near Rounding

pub	SSignedInfinity 		; Return signed infinity
	MOV	BX,[IEEEinfinityS + 2]
	AND	AH,Sign 		; Overstore the proper sign
	OR	BH,AH
	MOV	AX,[IEEEinfinityS]
	STAX2US
	MOV	AX,BX
	STAX2US
	JMP	SStoreExit

pub	StMOvDNorCHP24
	SHR	CL,1
	JC	short StMOvCHOP24

pub	StMOvDOWN24			; Masked Overflow Down Rounding
	TEST	AH,Sign 		; Positive goes to biggest
	JNZ	short SSignedInfinity

StMOvCHOP24:				; Masked Overflow Chop Rounding
pub	SSignedBiggest
	MOV	BX,[IEEEbiggestS + 2]
	AND	AH,Sign 		; Overstore the proper sign
	OR	AH,BH
	MOV	AL,BL
	STAX2US
	MOV	AX,[IEEEbiggestS]
	STAX2US
	JMP	SStoreExit

pub	StMOvUP24			; Masked Overflow Up Rounding
	TEST	AH,Sign 		; Negative goes to biggest
	JZ	short SSignedInfinity
	JMP	SSignedBiggest

pub	SUnder				; Masked Underflow - Try to denormalize
	OR	[CURerr],Underflow+Precision
	NEG	AX			; Convert exponent (which is too small)
	ADD	AX,SexpMin-SexpBias+1	; To a positive shift count
	CMP	AX,24			; Is shift more than mantissa precision
	JGE	short Szero
	XCHG	CX,AX
ifdef	i386
	movzx	ecx,cx			; (ecx) = zero-extended loop count
endif
	MOV	DX,MB0[esi]		; Pick up Insignif bytes for sticky bit
	OR	DX,MB2[esi]
	MOV	AL,DL
	OR	AL,DH
	MOV	DX,MB4[esi]
	MOV	BX,MB6[esi]
	OR	AL,AL
	JZ	short SSHIFTR
	OR	DL,1			; Set the sticky bit

pub	SSHIFTR
	SHR	BX,1
	RCR	DX,1
	JNC	short SSLOOP
	OR	DL,1
pub	SSLOOP
	LOOP	SSHIFTR

	XCHG	AH,CH			; Restore operation to CH
	MOV	AH,Flag[esi]		; Pick up sign
	AND	AH,Sign 		; Mask to sign only
	MOV	AL,BH			; Biased exponent for a denormal is 0
	MOV	BH,BL
	MOV	BL,DH
	MOV	DH,DL
	XOR	DL,DL
	JMP	SRound

pub	Szero
	XOR	AX,AX
	MOV	BX,AX
	JMP	STRUNC			; Go store single and exit

ProfEnd  LSSNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emlstmp.asm ===
page	,132
	subttl	emlstmp.asm - Load/Store Temp Real Numbers
;***
;emlstmp.asm - Load/Store Temp Real Numbers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store Temp Real Numbers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin LSTMP

;*********************************************************************;
;								      ;
;		 Load 80 Bit Temp Real				      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 80 bit tempreal

pub	eFLDtemp
	MOV	edi,esi 	; Get a new stack element and leave
	PUSHST
	XCHG	edi,esi

	mov	ax,es
	mov	dx,ds
	mov	es,dx
	mov	ds,ax
	MVUS2DI 		; Move 8 bytes of mantissa to TOS
	MVUS2DI
	MVUS2DI
	MVUS2DI
	mov	ax,es
	mov	dx,ds
	mov	es,dx
	mov	ds,ax
	LDUS2AX 		; Fetch exponent
	SUB	edi,8		; Reset pointer to TOS
	XCHG	esi,edi 	; Now DS:SI points to TOS

	MOV	DH,AH		; Exponent and Sign to DX
	AND	DH,Sign 	; Mask to Sign only
	MOV	Flag[esi],DH
	AND	AH,7FH		; Mask out sign
	XOR	DH,DH		; Set Tag to valid non-zero
	CMP	AX,IexpMax
	JE	short TNANorInf
	CMP	AX,IexpMin
	JE	short TZeroOrDenorm
	SUB	AX,IexpBias

pub	TStoreExpnTag
	MOV	Expon[esi],AX
	MOV	Tag[esi],DH
	RET

pub	TNANorInf
	MOV	AX,IexpMax - IexpBias
	MOV	DH,Special
	CMP	MB6[esi],8000H	     ; Test for Infinity
	JNE	short TStoreExpnTag
	MOV	BP,MB4[esi]
	OR	BP,MB2[esi]
	OR	BP,MB0[esi]
	JNZ	TStoreExpnTag
	OR	DH,ZROorINF
	JMP	TStoreExpnTag

pub	TZeroOrDenorm
	MOV	BP,MB6[esi]
	OR	BP,MB4[esi]
	OR	BP,MB2[esi]
	OR	BP,MB0[esi]
	JNZ	short TDenormal

pub	TZero
	MOV	AX,IexpMin - IexpBias
	MOV	DH,ZROorINF
	JMP	TStoreExpnTag

pub	TDenormal
	OR	[CURerr],Underflow+Precision ; Say it underflowed - set it to 0
	XOR	BP,BP
	MOV	MB0[esi],BP
	MOV	MB2[esi],BP
	MOV	MB4[esi],BP
	MOV	MB6[esi],BP
	JMP	TZero

PAGE
;*********************************************************************;
;								      ;
;   Store 80 Bit Temp Real (& POP since only FSTP supported for temp) ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 80 bit tempreal

pub	TNANorINFST
	TEST	BH,ZROorINF
	JNZ	short TInfST

pub	TNANST
	MVSI2US 		; copy mantissa
	MVSI2US
	MVSI2US
	MVSI2US
	MOV	AX,IexpMax	; Set maximum mantissa
	OR	AH,DH		; Overstore proper sign
	STAX2US
	POPST
	RET

pub	TInfST
	XOR	AX,AX
	STAX2US
	STAX2US
	STAX2US
	MOV	AX,8000H
	STAX2US
	MOV	AX,IexpMax	; Set maximum mantissa
	OR	AH,DH		; Overstore proper sign
	STAX2US
	POPST
	RET

pub	TSpecialST
	TEST	BH,Special
	JNZ	TNANorINFST

pub	TzeroST
	XOR	AX,AX
	STAX2US
	STAX2US
	STAX2US
	STAX2US
	STAX2US
	POPST
	RET

pub	eFSTtemp
	MOV	edi,esi
	MOV	esi,[CURstk]

	MOV	AX,Expon[esi]	; Adjust exponent of TOS
	ADD	AX,IexpBias
	MOV	DH,Flag[esi]
if	fastSP
	TEST	DH,Single
	JZ	TD1
	MOV	word ptr MB0[esi],0
	MOV	word ptr MB2[esi],0
	MOV	byte ptr MB4[esi],0
TD1:
endif
	AND	DH,Sign 	; Mask to sign only
	OR	AH,DH
	MOV	BH,Tag[esi]	 ; See if it is a special case
	OR	BH,BH
	JNZ	TSpecialST

	MVSI2US 		; Move Mantissa
	MVSI2US
	MVSI2US
	MVSI2US
	STAX2US 		; Move Exponent & Sign

	SUB	esi,8		; Reset pointer to TOS
	POPSTsi

	RET

ProfEnd  LSTMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emlsquad.asm ===
page	,132
	subttl	emlsquad.asm - Load/Store 64-bit integers
;***
;emlsquad.asm - Load/Store 64-bit integers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store 64-bit integers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		 Load Quad (64 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 64 bit integer


ProfBegin LSQUAD

pub	eFLDlongint
	LDUS2AX 		; Fetch the integer
	MOV	DX,AX		;  into DI:BP:BX:DX
	LDUS2AX
	MOV	BX,AX
	LDUS2AX
	MOV	BP,AX
	LDUS2AX
	MOV	DI,AX

	OR	AX,BP
	OR	AX,BX
	OR	AX,DX
	JZ	short Jmp2LoadZero

	MOV	AX,63		; Exponent would be 63 if no shifts needed
	PUSHST			; Get a new TOS
	XOR	CL,CL
	MOV	Tag[esi],CL	; Tag number as valid non-zero
	MOV	CX,DI		; Sign of Integer to CH
	AND	CH,Sign
	JNS	short SETFLAG64 ; If positive integer set the flag

	call	TwosComplement64; Otherwise complement the number first

pub	SETFLAG64
	MOV	Flag[esi],CH
	OR	DI,DI
	JNZ	Jmp2IntegerToInternal
	OR	BP,BP
	JNZ	Jmp2IntegerToInternal

pub	SPEEDSHIFT64
	MOV	DI,BX
	MOV	BP,DX
	XOR	BX,BX
	XOR	DX,DX
	SUB	AX,32
Jmp2IntegerToInternal:
	JMP	IntegerToInternal

Jmp2LoadZero:
	JMP	LoadZero


page
;*********************************************************************;
;								      ;
;		Store Quad (64 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 64 bit integer

pub	eFSTlongint
	PUSH	esi
	call	TOSto64int		; convert TOS to 64-bit integer
					;  in DI:BP:BX:DX
	XCHG	AX,DI
	XCHG	AX,DX			;  now in DX:BP:BX:AX
	POP	edi			; Restore Memory address
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,BP
	STAX2US
	MOV	AX,DX			
	STAX2US
	RET


pub	TOSto64int
	MOV	esi,[CURstk]
					; Test for special conditions
	TEST	byte ptr Tag[esi],Special ; If number is not in range it is overflow
	JNZ	short IntegerOverflow64
	TEST	byte ptr Tag[esi],ZROorINF
	JNZ	short StoreIntegerZero64
					; Fetch Exponent & test fo blatent overflow
	MOV	CX,Expon[esi]
	CMP	CX,63
	JG	short IntegerOverflow64

if	fastSP
	;UNDONE - ????
else
	MOV	BP,MB4[esi]		; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger
					; Integer in DI:BP:BX:DX 
					;  (not yet 2's complement)
	MOV	AH,Flag[esi]		; See if we need to complement
	OR	AH,AH
	JNS	short Int64in2sComp
	call	TwosComplement64

pub	Int64in2sComp
	XOR	AX,DI			; If Signs agree we did not overflow
	JS	short IntOverOrZero64	; Special case is -0 which we let pass

pub	Store64
	POPSTsi			; store POP to long-integer
	ret

if	fastSP
	;UNDONE ???
endif

pub	StoreIntegerZero64
	XOR	DI,DI
pub	ZeroLower48
	XOR	BP,BP	
	MOV	BX,BP
	MOV	DX,BP
	JMP Store64 

pub	IntOverOrZero64
	OR	DI,BP
	OR	DI,BX
	OR	DI,DX	
	JNZ	IntegerOverflow64
	JMP	Store64	; Return zero

pub	IntegerOverflow64
	OR	CURerr,Invalid
	MOV	DI,8000H	; Integer Indefinite
	JMP	short ZeroLower48

pub	TwosComplement64
	NOT	DI			; 2's Complement of DI:BP:BX:DX
	NOT	BP
	NOT	BX
	NEG	DX
	CMC
	ADC	BX,0
	ADC	BP,0
	ADC	DI,0
	ret


ProfEnd  LSQUAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emnew.asm ===
page	,132
	subttl	emnew - emulator new instruction support
;***
;emnew.asm - emulator new instruction support
;
;	Copyright (c) 1985-89, Microsoft Corporation
;
;Purpose:
;	Emulator new instruction support
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

ProfBegin NEW

;***	eFFREE - emulate FFREE ST(i)
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m is register to free
;
;	DESCRIPTION
;		This routine assumes that the register being freed is
;		either at the top or the bottom of the floating point
;		stack.	This is consistent with its use by the cmerge
;		compiler.  If ST(i) is valid, all registers from ST(0)
;		to ST(i-1) are moved down one position in the stack,
;		eliminating ST(i).  [CURstk] is moved to the new location
;		of ST(0).
;
;	REGISTERS
;		modifies si,di,dx

pub	eFFREE
	call	RegAddr 	; di <== address of ST(i)
				; carry set if invalid register
	jnc	short validSTi	; ok, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	; set stack underflow/invalid and exit

validSTi:
	mov	esi,edi 	; si <== address of ST(i)
MovLoop:
	add	esi,Reg87Len	; si <== address of ST(i-1)
	cmp	esi,[CURstk]	; source addr <= top of stack?
	jg	short SetCURstk ; set [CURstk] and exit
	call	MOVRQQ		; ST(j) <== ST(j-1)
	add	edi,Reg87Len	; move dest ptr to next stack entry
	jmp	short MovLoop	; continue moving register entries

SetCURstk:
	sub	edi,Reg87Len	; di points to new location of ST(0)
	mov	[CURstk],edi	; set new top of stack ptr
	ret

;***	eFXCHG - emulate FXCH ST(i)
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m is the source register
;
;	DESCRIPTION
;		exchange ST(i) and ST(0) as follows:
;			temp <== ST(0); ST(0) <== ST(i); ST(i) <== temp
;		indicate stack underflow error if ST(i) does not exist
;
;	REGISTERS
;		modifies ax,es,si,di,dx,cx,bx

pub	eFXCHG
	test	cx,01c00h	;test for ST(i) == ST(0)
	jz	short fxchRet	;fxch ST(0),ST(0) is a nop
	mov	ax,ds
	mov	es,ax		;set es == ds
	call	RegAddr 	;di points to ST(i), si points to ST(0)
				;carry set if invalid register
	jnc	short okReg	;ok, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	;give stack underflow/invalid error

okReg:
	mov	ecx,6			;loop counter
WordSwap:				;exchange a word of ST(0) and ST(i)
	mov	ax,[esi]		;ax <== [si]
	mov	bx,[edi]		;bx <== [di]
	stos	word ptr es:[edi]	;[(di++)] <== ax
	mov	[esi],bx		;[si] <== bx
	inc	esi
	inc	esi			;si++
	loop	WordSwap		;exchange the six words of ST(0), ST(i)
fxchRet:
	ret

;***	eFLDreg - emulate FLD ST(i)
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m is the source register
;
;	DESCRIPTION
;		allocate new ST(0) and copy ST(i) into it
;		indicate stack underflow error if ST(i) does not exist
;
;	REGISTERS
;		modifies ax,di,si

pub	eFLDreg
	call	RegAddr 	;di <== address of ST(i), si points to ST(0)
				;carry set if invalid register
	jnc	short okSTi	;yes, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	;stack underflow, invalid operation

okSTi:
	PUSHST			;allocate new TOS
	mov	ax,ds
	mov	es,ax		;set ES == DS
	xchg	esi,edi 	;si = source , di = destination
	call	MOVRQQ		;move ST(i) to new ST(0)
	ret

;***	eFST_Preg - emulate FST ST(i) and FSTP ST(i)
;
;	ARGUMENTS
;		AX = 0 if FST ST(i)
;		     1 if FSTP ST(i)
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;			(except bit 2 of cl is toggled)
;		r/m is the source register
;
;	DESCRIPTION
;		move contents of ST(0) to ST(i).  If ax <> 0 pop stack
;		after transfer.
;
;	REGISTERS
;		modifies si,di,dx

pub	eFST_Preg
	test	cx,01c0h	;test for ST(i) == ST(0)
	jz	short FSTRet	;pop stack and return
	call	RegAddr 	;di <== address of ST(i), si points to ST(0)
				;carry set if invalid register
	jnc	short ValidReg	;yes, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	;no, indicate stack underflow/invalid

ValidReg:
	mov	dx,ds
	mov	es,dx		;set es == ds
	call	MOVRQQ		;ST(i) <== ST(0)

FSTRet:
	or	ax,ax		;FST ST(i) or FSTP ST(i)?
	jz	short NoPOP	;FST ST(i) - don't pop the stack
	POPST			;pop the 8087 stack
NoPOP:
	ret


ProfEnd  NEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emoem.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987-92
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
title	emoem.asm - OEM dependent code for 80x87

;--------------------------------------------------------------------
;
;	OEM customization routines for 8087/80287/80387 coprocessor
;
;	This module is designed to work with the following
;	Microsoft language releases:
;
;		Microsoft C 3.00 and later
;		Microsoft FORTRAN 77 3.30 and later
;		Microsoft Pascal 3.30 and later
;
;	This module supersedes the OEMR7.ASM module used in earlier
;	versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;	provided with the FORTRAN and Pascal releases refers to the old
;	OEMR7.ASM module and is only slightly relevant to this module.
;
;	The following routines need to be written to properly handle the
;	8087/80287/80387 installation, termination, and interrupt handler
;
;	__FPINSTALL87		install 80x87 interrupt handler
;	__FPTERMINATE87 	deinstall 80x87 interrupt handler
;	__fpintreset		reset OEM hardware if an 80x87 interrupt
;
;	*****  NEW INSTRUCTIONS  *****
;
;	If you want a PC clone version, do nothing.  The libraries are
;	setup for working on IBM PC's and clones.
;
;	These instructions only need to be followed if a non-IBM PC
;	clone version is desired.
;
;	This module should be assembled with the
;	Microsoft Macro Assembler Version 4.00 or later as follows:
;
;		masm -DOEM -r emoem.asm;
;
;	Most hardware handles the 8087/80287/80387 in one of the following
;	three ways -
;
;	1.	NMI - IBM PC and clones all handle the interrupt this way
;	2.	single 8259
;	3.	master/slave 8259
;
;	Manufacturer specific initialization is supported for these 3
;	machine configurations either by modifying this file and replacing
;	the existing EMOEM module in the math libraries or by patching
;	the .LIB and .EXE files directly.
;
;		LIB 87-+EMOEM;
;		LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef	OEM
if1
	%out	OEM version for non-clone support
endif
endif

;---------------------------------------------------------------------
;	Assembly constants.
;---------------------------------------------------------------------

; MS-DOS OS calls

   OPSYS	EQU	21H
   SETVECOP	EQU	25H
   GETVECOP	EQU	35H
   DOSVERSION	EQU	30h
ifndef	_NOCTRLC
   CTLCVEC	EQU	23h
endif	;_NOCTRLC

EMULATOR_DATA	segment para public 'FAR_DATA'
assume	ds:EMULATOR_DATA

;	User may place data here if DS is setup properly.
;	Recommend keeping the data items in the code segment.

EMULATOR_DATA	ends



EMULATOR_TEXT	segment para public 'CODE'
assume	cs:EMULATOR_TEXT

	public	__FPINSTALL87		; DO NOT CHANGE THE CASE ON
	public	__FPTERMINATE87 	; THESE PUBLIC DEFINITIONS

	extrn	__FPEXCEPTION87:near	; DO NOT CHANGE CASE


ifdef	_NO87INSTALL	; install/terminate routines for NO87 case for QuickC

	public	__FPINSTALLNO87	
	public	__FPTERMINATENO87

endif	;_NO87INSTALL


ifdef	OEM

;***********************************************************************
;
; Hardware dependent parameters in the 80x87 exception handler.
;
; For machines using 2 8259's to handle the 80x87 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 80x87
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 80x87 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum	db	0		; MS-DOS OEM number (IBM is 00h)
intnum	db	2		; IBM PC clone interrupt number
share	db	0		; nonzero if original vector should be taken
a8259	dw	0		; 1st 8259 (A0=0) port #
aocw2	db	0		; 1st 8259 (A0=0) EOI command
b8259	dw	0		; 2nd 8259 (A0=0) port #
bocw2	db	0		; 2nd 8259 (A0=0) EOI command
a8259m	dw	0		; 1st 8259 (A0=1) port #
aocw1m	db	0		; 1st 8259 (A0=1) value to mask against IMR
b8259m	dw	0		; 2nd 8259 (A0=1) port #
bocw1m	db	0		; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;	OEM specific 80x87 information
;
;	If the OEM number returned from the DOS version call matches,
;	this information is automatically moved into the oem struc below.

oemtab	label	byte	; Table of OEM specific values for 80x87

;		OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db	0	; end of table

;	Unique pattern that can be searched for with the debugger so that
;	.LIB or .EXE files can be patched with the correct values.
;	If new values are patched into .LIB or .EXE files, care must be
;	taken in insure the values are correct.  In particular, words and
;	bytes are intermixed in oeminfo structure.  Remember words are
;	stored low byte - high byte in memory on the 8086 family.

	db	'<<8087>>'	; older versions used '<8087>'

;	Some manufacturer's machines can not be differentiated by the
;	OEM number returned by the MS-DOS version check system call.
;	For these machines it is necessary to replace the line below

oem1	oeminfo <>		; default values for IBM PC & clones

;	with one of the following.  If your machine has an 80x87 capability
;	and it is not in the list below, you should contact your hardware
;	manufacturer for the necessary information.

;ACT Apricot
;oem1	 oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1	 oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

aoldIMR 	db	0	; 1st 8259 original IMR value
boldIMR 	db	0	; 2nd 8259 original IMR value

endif	;OEM

statwd		dw	0	; Temporary for status word
oldvec		dd	0	; Old value in 80x87 exception interrupt vector
ifndef	_NOCTRLC
ctlc		dd	0	; Old value of Control-C vector (INT 23h)
endif	;_NOCTRLC

page

;---------------------------------------------------------------------
;
;	Perform OEM specific initialization of the 80x87.
;

__FPINSTALL87:
	push	ds			; DS = EMULATOR_DATA

	push	cs			; Move current CS to DS for opsys calls.
	pop	ds
assume	ds:EMULATOR_TEXT

ifdef	OEM
	push	ds
	pop	es			; CS = DS = ES
	mov	ah,DOSVERSION
	int	OPSYS			; bh = OEM#
	cld
	mov	si,offset oemtab	; start of OEM 80x87 info table
	mov	di,offset oem1+1
	mov	cx,(size oem1)-1
OEMloop:
	lodsb				; get OEM#
	or	al,al
	jz	OEMdone 		; OEM# = 0 - did not find OEM
	cmp	al,bh			; correct OEM#
	je	OEMfound
	add	si,cx			; skip over OEM information
	jmp	OEMloop

OEMfound:
	rep	movsb			; move the information

OEMdone:				; done with automatic customization
endif	;OEM

; Save old interrupt vector.
; Ask operating system for vector.

ifdef  WINDOWS
	mov	ax, word ptr [oldvec]
	or	ax, word ptr [oldvec+2]
	jnz	SetVector
endif	;WINDOWS

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.

	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

SetVector:
	mov	dx,offset __fpinterrupt87 ; Load DX with 80x87 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

ifndef	_NOCTRLC
; Intercept Control-C vector to guarentee cleanup

	mov	ax,GETVECOP shl 8 + CTLCVEC
	int	OPSYS
	mov	word ptr [ctlc],bx
	mov	word ptr [ctlc+2],es
	mov	dx,offset ctlcexit
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
endif	;_NOCTRLC

ifdef	OEM

;	set up 8259's so that 80x87 interrupts are enabled

	mov	ah,[oem1].aocw1m 	; get mask for 1st 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;   and only 1 8259
	mov	dx,[oem1].a8259m 	; get port number for 1st 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[aoldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

	mov	ah,[oem1].bocw1m 	; get mask for 2nd 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;
	mov	dx,[oem1].b8259m 	; get port number for 2nd 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[boldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

installdone:

endif	;OEM

assume	ds:EMULATOR_DATA
	pop	ds
	ret


page
;	__FPTERMINATE87
;
;	This routine should do the OEM 80x87 cleanup.  This routine is called
;	before the program exits.
;
;	DS = EMULATOR_DATA

__FPTERMINATE87:
	push	ds
	push	ax
	push	dx

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
	int	OPSYS

ifdef	OEM

;	reset 8259 IMR's to original state

	push	cs
	pop	ds			; DS = CS
assume	ds:EMULATOR_TEXT
	cmp	[oem1].aocw1m,0		; did we have to change 1st 8259 IMR
	je	term2nd8259		;   no - check 2nd 8259
	mov	al,[aoldIMR]		; get old IMR
	mov	dx,[oem1].a8259m 	; get 1st 8259 (A0=1) port #
	out	dx,al			; restore IMR

term2nd8259:
	cmp	[oem1].bocw1m,0		; did we have to change 2nd 8259 IMR
	je	terminatedone		;   no
	mov	al,[boldIMR]		; get old IMR
	mov	dx,[oem1].b8259m 	; get 2nd 8259 (A0=1) port #
	out	dx,al			; restore IMR

terminatedone:

endif	;OEM

	pop	dx
	pop	ax
	pop	ds
assume	ds:EMULATOR_DATA
	ret


;	Forced cleanup of 80x87 exception handling on Control-C

ifndef	_NOCTRLC
ctlcexit:
	push	ax
	push	dx
	push	ds
	call	__FPTERMINATE87 	; forced cleanup of exception handler
	lds	dx,[ctlc]		; load old control C vector
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
	pop	ds
	pop	dx
	pop	ax
	jmp	[ctlc]			; go through old vector
endif	;_NOCTRLC

page
;	__fpinterrupt87
;
;	This is the 80x87 exception interrupt routine.
;
;	All OEM specific interrupt and harware handling should be done in
;	__fpintreset because __FPEXCEPTION87 (the OEM independent 80x87
;	exception handler) may not return.  __FPEXCEPTION87 also turns
;	interrupts back on.
;

PENDINGBIT=	80h		; Bit in status word for interrupt pending

__fpinterrupt87:
assume	ds:nothing
	nop
	fnstsw	[statwd]	; Store out exceptions
	push	cx		; waste time
	mov	cx,3
self:
	loop	self
	pop	cx
	test	byte ptr [statwd],PENDINGBIT	; Test for 80x87 interrupt
	jz	not87int	; Not an 80x87 interrupt.

ifdef	OEM
	call	__fpintreset	; OEM interrupt reset routine
endif	;OEM

	call	__FPEXCEPTION87 ; 80x87 error handling - may not return
				; this routine turns interrupts back on

ifdef	OEM
	cmp	[oem1].share,0	; Should we execute the old interrupt routine?
	jnz	not87int	;    if so then do it
				;    else return from interrupt

;	If you fall through here to do further hardware resetting, things
;	may not always work because __FPEXCEPTION87 does not always return
;	This only happens when the 80x87 handler gets an exception that is
;	a fatal error in the language runtimes.  I.e., divide by zero
;	is a fatal error in all the languages, unless the control word has
;	set to mask out divide by zero errors.

endif	;OEM

done8087:
	iret

not87int:
	jmp	[oldvec]	; We should never return from here.


ifdef	OEM


__fpintreset:
	push	ax
	push	dx
	mov	al,[oem1].aocw2	; Load up EOI instruction.
	or	al,al		; Is there at least one 8259 to be reset?
	jz	Reset8259ret	; no
	mov	dx,[oem1].a8259
	out	dx,al		; Reset (master) 8259 interrupt controller.
	mov	al,[oem1].bocw2	; Load up EOI instruction.
	or	al,al		; Is there a slave 8259 to be reset?
	jz	Reset8259ret
	mov	dx,[oem1].b8259
	out	dx,al		; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop	dx
	pop	ax
	ret

endif	;OEM

ifdef	_NO87INSTALL
__FPINSTALLNO87:
	push	bx
	push	es
	push	ax
	push	dx
	push	ds

	mov	ax,cs			; Move current CS to DS for opsys calls.
	mov	ds,ax
assume	ds:EMULATOR_TEXT
	
; Save old interrupt vector.
; Ask operating system for vector.

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

	mov	dx,offset __fpinterruptno87 ; Load DX with fake 80x87 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

	pop	ds
assume	ds:nothing
	pop	dx
	pop	ax
	pop	es
	pop	bx
	
	ret

__fpinterruptno87:
	jmp	[oldvec]		; will use CS: override

__FPTERMINATENO87:
	push	ds
	push	ax
	push	dx

	mov	ax,cs
	mov	ds,ax
assume	ds:EMULATOR_TEXT

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
assume	ds:nothing
	int	OPSYS

	pop	dx
	pop	ax
	pop	ds

	ret

endif	;_NO87INSTALL

EMULATOR_TEXT	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emmain.asm ===
page	,132
	subttl	emmain.asm - Main Entry Point and Address Calculation Procedure
;***
;emmain.asm - Main Entry Point and Address Calculation Procedure
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Main Entry Point and Address Calculation Procedure
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;	  Main Entry Point and Address Calculation Procedure	      ;
;								      ;
;*********************************************************************;
;
; This routine fetches the 8087 instruction, calculates memory address
; if necessary into ES:SI and calls a routine to emulate the instruction.
; Most of the dispatching is done through tables. (see comments in CONST)


ProfBegin MAIN

ifdef	XENIX

ifdef   i386
LDT_DATA=       02Fh            ; UNDONE - 386 emulator data LDT
else
LDT_DATA=       037h            ; UNDONE - 286 emulator data LDT
endif   ;i386

endif	;XENIX


ifdef   PROTECT
;	protect mode Segment override case

glb	<protSegOvrTab>

protSegOvrTab	label	word

	dw	DSSegOvr	; 11
	dw	ESSegOvr	; 00
	dw	CSSegOvr	; 01
	dw	SSSegOvr	; 10
endif   ;PROTECT


ifdef	DOS3
;	isolated FWAIT


ifdef  WINDOWS
pub  FWtrap
	cld		    ; this CLD is a nop.
	iret

else	;not WINDOWS
pub  FWtrap
	PUSH	BP			; fix up isolated FWAIT
	PUSH	DS
	PUSH	SI
	MOV	BP,SP			; Point to stack
	LDS	SI,DWORD PTR 6[BP]	; Fetch ret address,(points to after instruction)
	DEC	SI			; Make DI point to instruction
	DEC	SI
	MOV	6[BP],SI		; Change ret address to return to instruction
	mov	word ptr [si],0C0h*256+89h  ; change interrupt to mov ax,ax
	POP	SI
	POP	DS
	POP	BP
	IRET				; interrupt return

endif	;not WINDOWS
;	Segment override case

glb	<SegOvrTab>

SegOvrTab	label	word

	dw	DSSegOvr
	dw	SSSegOvr
	dw	CSSegOvr
	dw	ESSegOvr

pub	SOtrap
	STI				; re-enable interrupts
	push	ax
	push	es			; set up frame
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	sub	sp,2			; reserve for regSegOvr
	push	bp
	mov	bp,sp			; set up frame pointer
	CLD				; clear direction flag forever

; get address mode information, dispatch to address calculation

	MOV	DX,BX			; may use original BX to calc address
	MOV	AX,DI			; may use original DI to calc address
	LDS	DI,dword ptr [bp].regIP ; DS:DI is caller's CS:IP
	INC	DI			; increment past operation byte
	INC	DI			; increment past operation byte
	MOV	CX,[DI-2]		; get trap number, opcode (DS=caller CS)
	mov	bx,cx			; upper 2 bits indicate segment override
	rol	bl,1
	rol	bl,1
	and	bx,3
	rol	bx,1
	jmp	SegOvrTab[bx]
endif	;DOS3


pub	DSSegOvr			; 00
	mov	es,[bp].regDS		; set ES to EA segment
	jmp	short ESSegOvr

pub	CSSegOvr			; 10
	mov	bx,ds			; DS = caller's CS
	mov	es,bx			; set ES to EA segment
	jmp	short ESSegOvr

pub	SSSegOvr			; 01
	mov	bx,ss			; SS = caller's SS
	mov	es,bx			; set ES to EA segment

pub	ESSegOvr			; 11
	mov	[bp].regSegOvr,es	; save for bp rel EAs
	jmp	short CommonDispatch


ifdef   PROTECT
pub	protSegOvr
	mov	dx,bx			; may use original BX to calc address
	mov	bl,cl

	.286
	shr	bl,2

ifndef	DOS5only
	.8086
endif
	and	bx,6			; bl = (seg+1) and 6
	inc	di			; point to displacement
	mov	cx,[di-2]		; cx = esc 0-7 and opcode
	jmp	protSegOvrTab[bx]	; process appropriate segment override


ifdef   XENIX
pub     jinstall
        jmp     installemulator
endif   ;XENIX


pub	protemulation
	cld				; clear direction flag forever

ifdef	XENIX

        push    ax                      ; UNDONE - slow
        push    ds                      ; UNDONE - slow

	mov	ax,LDT_DATA		; load up emulator's data segment
	mov	ds,ax
	cmp	[Einstall],0		; check if emulator is initialized
        je      jinstall                ;   no - go install it

pub	protemcont

        pop     ds                      ; UNDONE - slow
        pop     ax                      ; UNDONE - slow

endif	;XENIX

	push	ax
	push	es			; set up frame
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	push	ss			; save SegOvr (bp forces SS override)
	push	bp
	mov	bp,sp			; set up frame pointer
	mov	dx,ds			; save original DS for default case
	mov	ax,di			; may use original DI to calc address
	lds	di,dword ptr [bp].regIP ; ds:di = 287 instruction address
	mov	cx,[di] 		; cx = esc 0-7 and opcode
	add	di,2			; point to displacement
	add	cl,28h			; set carry if esc 0-7 (and cl = 0-7)
	jnc	protSegOvr		;   no carry - must be segment override
	mov	es,dx			; es = user data segment
	mov	dx,bx			; may use original BX to calc address
endif   ;PROTECT

ifdef	DOS3and5
	jmp	short CommonDispatch
endif	;DOS3and5


ifdef	DOS3
;	normal entry point for emulator interrupts

	even

pub	DStrap
	STI				; re-enable interrupts
	push	ax
	push	es			; set up frame
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	push	ss			; save SegOvr (bp forces SS override)
	push	bp
	mov	bp,sp			; set up frame pointer
	mov	ax,ds
	mov	es,ax			; ES = caller's DS
	CLD				; clear direction flag forever

; get address mode information, dispatch to address calculation

	MOV	DX,BX			; may use original BX to calc address
	MOV	AX,DI			; may use original DI to calc address
	LDS	DI,dword ptr [bp].regIP ; DS:DI is caller's CS:IP
	INC	DI			; increment past operation byte
	MOV	CX,[DI-2]		; get trap number, opcode (DS=caller CS)
; Otherwise, CL contains BEGINT + |MF|Arith| so we must unbias it
	SUB	CL,BEGINT
endif	;DOS3


;	DS:DI = original CS:IP of displacement field
;	ES    = Effective Address segment (original DS if no segment override)
;	DX    = original BX
;	AX    = original DI
;	SI    = original SI
;	CX    = (opcode,0-7 from ESC byte)
;	stack = saved register set

pub	CommonDispatch
	ROL	CH,1			; rotate MOD field next to r/m field
	ROL	CH,1
	MOV	BL,CH			; get copy of operation
	AND	BX,1FH			; Mask to MOD and r/m fields
	SHL	BX,1			; make into word offset
	JMP	EA286Tab[BX]


OneByteDisp  macro
	mov	al, [di]		;; get one byte displacement
	cbw				;; sign extend displacement
	inc	di			;; get past displacement byte
	add	si, ax			;; add one byte displacement
	endm

TwoByteDisp  macro
	add	si, [di]		;; add word displacement
	add	di, 2			;; get past displacement word
	endm


	even

pub BXXI0D
	MOV	SI,DX			; use original BX index value
	JMP	short ADRFIN		; have offset in SI

pub DSDI0D
	MOV	SI,AX			; use alternate index value
	JMP	short ADRFIN		; have offset in SI

	even

pub BPXI1D
	mov	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	OneByteDisp
	JMP	short ADRFIN

	even

pub BPDI1D
	MOV	SI,AX			; use alternate index value
pub BPSI1D
	ADD	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	OneByteDisp
	JMP	short ADRFIN

	even

pub BXSI1D
	MOV	AX,SI			; really will want SI, not DI
pub BXDI1D
	ADD	DX,AX			; now DX is original BX plus index
pub BXXI1D
	MOV	AX,DX			; use original BX index value
pub DSDI1D
	MOV	SI,AX			; use alternate index value
pub DSSI1D
	OneByteDisp
	JMP	short ADRFIN

	even

pub BPXI2D
	mov	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	TwoByteDisp
	JMP	short ADRFIN

	even

pub BPDI2D
	MOV	SI,AX			; use alternate index value
pub BPSI2D
	ADD	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	TwoByteDisp
	JMP	short ADRFIN

	even

pub BXSI2D
	MOV	AX,SI			; really will want SI, not DI
pub BXDI2D
	ADD	DX,AX			; now DX is original BX plus index
pub BXXI2D
	MOV	AX,DX			; use original BX index value
pub DSDI2D
	MOV	SI,AX			; use alternate index value
pub DSSI2D
	TwoByteDisp
	JMP	short ADRFIN

	even

pub BPDI0D
	MOV	SI,AX			; use alternate index value
pub BPSI0D
	add	si,[bp].regBP		; really will want BP, not BX
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	jmp	short ADRFIN

	even

pub BXDI0D
	MOV	SI,AX			; si = regDI
pub BXSI0D
	add	si,dx			; si = regSI+regBX
	jmp	short ADRFIN

	even

pub DSXI2D
	MOV	SI,[DI] 		; get two byte displacement
	INC	DI			; get past displacement byte
	INC	DI			; get past displacement byte

pub DSSI0D				; SI = EA (original SI for DSSI0D)

pub	ADRFIN
	MOV	[bp].regIP,DI		; final return offset

ifdef  LOOK_AHEAD
	mov	bl,[di] 		; get byte of next instruction
endif

ifdef	MTHREAD			
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS, trashes AX
else	;not MTHREAD
    ifdef   standalone
	xor	ax,ax
	mov	ds,ax
	mov	ds,ds:[4*TSKINT+2]	; DS = emulator task data segment

    elseifdef  XENIX
	mov	ax,LDT_DATA
	mov	ds,ax

    elseifdef  _COM_
	mov	ds, [__EmDataSeg]

    else
	mov	ax, edataBASE
	mov	ds,ax
    endif
endif	;not MTHREAD

ifdef  LOOK_AHEAD
	mov	[NextOpCode], bl	; save byte of next instruction
endif

	mov	[CURerr],MemoryOperand	; clear current error, set mem. op bit

; At this point ES:SI = memory address, CX = |Op|r/m|MOD|escape|MF|Arith|

	SHR	CH,1
	SHR	CH,1			; Move Op field to BX for Table jump
	SHR	CH,1
	SHR	CH,1
	MOV	BL,CH
	AND	BX,0EH

	TEST	CL,1			; Arith field set?
	JZ	ArithmeticOpMem

pub	NonArithOpMem
	mov	eax,offset EMLFINISH
	push	eax
	jmp 	NonArithOpMemTab[BX]

	even

pub	ArithmeticOpMem
	PUSH	BX			; Save Op while we load the argument
	MOV	BX,CX			; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	call	FLDsdriTab[2*ebx]	; emulate proper load
else
	call	FLDsdriTab[ebx] 	; emulate proper load
endif
	POP	BX

	mov	ax,ds			; ES = DS = task data area
	mov	es,ax
	MOV	SI,[CURstk]		; address top of stack
	MOV	DI,SI
	ChangeDIfromTOStoNOS
	MOV	[RESULT],DI		; Set up destination Pointer

	JMP	short DoArithmeticOpPop


	even

pub	NoEffectiveAddress		; Either Register op or Miscellaneous

	MOV	[bp].regIP,DI		; final return offset

ifdef  LOOK_AHEAD
	mov	bl, [di]		; get first byte of next instruction.
endif

ifdef	MTHREAD			
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS; trashes AX
	mov	ax,ds
	mov	es,ax			; DS = ES = per-thread em. data area
	xor	ax,ax

else	;not MTHREAD

	xor	ax,ax

    ifdef   standalone
	mov	ds,ax
	mov	di,ds:[4*TSKINT+2]	; DI = emulator task data segment

    elseifdef	XENIX
        mov     di,LDT_DATA

    elseifdef  _COM_
	mov	di, [__EmDataSeg]

    else
	mov	di, edataBASE
    endif

	mov	ds,di			; di = emulator data segment
	mov	es,di			; ax = 0
endif	;not MTHREAD

; ES = emulator data segment
; DS = emulator data segment
; AX = 0 

ifdef  LOOK_AHEAD
	mov	[NextOpCode], bl	; save first byte of next instruction
endif

	mov	[CURerr],ax		; clear current error, memory op bit

; CX = |Op|r/m|MOD|escape|MF|Arith|

	MOV	BL,CH
	SHR	BL,1			; Mov Op field to BX for jump
	SHR	BL,1
	SHR	BL,1
	SHR	BL,1
	AND	BX,0EH

	TEST	CL,1			; Arith field set?
	JZ	ArithmeticOpReg

pub	NonArithOpReg
	CALL	NonArithOpRegTab[BX]
	JMP	EMLFINISH

; For register arithmetic operations, one operand is always the stack top.
; The r/m field of the instruction is used to determine the address of
; the other operand (ST(0) - ST(7))
; CX = xxxRRRxxxxxxxxxx (x is don't care, RRR is relative register # 0-7)

	even

pub	ArithmeticOpReg

	call	RegAddr 		;di <= address of 2nd operand
					;carry set if invalid register
	jc	InvalidOperand		;no, invalid operand, don't do operation

	MOV	[RESULT],SI		; Set destination to TOS
	TEST	CL,04H			; Unless Dest bit is set
	JZ	DestIsSet		; in which case
	MOV	[RESULT],DI		; Set destination to DI

pub	DestIsSet
					; Need to Toggle Reverse bit for DIV or SUB
	TEST	BL,08H			; OP = 1xx for DIV and SUB; BX = |0000|OP|O|
	JZ	SetUpPop
	XOR	BL,02H			; Toggle Reverse bit

pub	SetUpPop
	TEST	CL,02H
	JZ	DoArithmeticOpNoPop

pub	DoArithmeticOpPop
	CALL	ArithmeticOpTab[BX]
	mov	esi,[CURstk]
	cmp	esi,[BASstk]		   ; 15 was it last register in the chunk ?
	jz 	short AOPstovr		   ; 16 yes, overflow
AOPstok:
	sub	esi,Reg87Len		   ;  4 decrement SI to previous register
	mov	[CURstk],esi		   ; 15 set current top of stack
	JMP	short EMLFINISH

AOPstovr:
	call	UnderStk		   ;	stack underflow error
	jmp	AOPstok

	even

pub	DoArithmeticOpNoPop
	mov	eax,offset EMLFINISH
	push	eax
	jmp 	ArithmeticOpTab[BX]


;***	InvalidOperand - register operand does not exist
;
;	RETURNS
;		sets Stack Underflow and Invalid bits in [CURerr]
;
;	DESCRIPTION
;		a reference was made to a register that does not
;		exist on the stack.  Set error bits and exit.

pub	InvalidOperand
	call	UnderStk		;indicate stack underflow error
	or	[CURerr],Invalid	;indicate invalid operand
	jmp	short EMLFINISH 	;don't execute instruction

;***	RegAddr - compute register address
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m = register whose address is to be computed
;
;	RETURNS
;		SI = address of top of stack
;		DI = address of requested register
;		PSW.C set if register is not valid
;		PSW.C reset if register is valid
;
;	DESCRIPTION
;		multiply register number by 12 and subtract this from
;		[CURstk] (the address of TOS) to compute address of
;		register referenced by r/m.
;
;	REGISTERS
;		modifies dx

pub	RegAddr
	MOV	SI,[CURstk]		; address top of stack
	MOV	DI,SI
;set up address of 2nd operand based on r/m field of instruction
	mov	dl,ch			; dl <== byte containing reg#
	and	dl,01ch 		; mask all but r/m field

; Since r/m field contains the relative reg # in bits 2-4 of dl,
; and bits 0-1 of dl are zero, dl now contains 4*(reg #).  To compute
; the memory location of this register, calculate 12*(reg #) and
; subtract this from di, which contains the address of the TOS.  reg #
; is multiplied by 12 because that is the number of bytes in each stack
; entry.
	mov	dh,dl			; dh = dl = 4*(reg #)
	shl	dh,1			; dh = 2*dh = 8*(reg #)
	add	dl,dh			; dl = 8*(reg #) + 4*(reg #) = 12*(reg #)
	xor	dh,dh			; zero out high byte of DX
	sub	di,dx			; di is address of second operand
	cmp	di,[BASstk]		; is register in range?
	clc				; assume valid register
	jg	$+3			; valid - skip next instruction
	cmc				; set carry to indicate invalid register
	ret


pub	CallUnused
	CALL	UNUSED			; Treat as unimpleminted
	jmp	EMLFINISH


;	out of line returns from emulator


pub	SawException
	pop	bp			; restore registers
	add	sp,2			; toss regSegOvr
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es

pub	ExceptionsEmulator
	JMP	CommonExceptions


ifdef LOOK_AHEAD

pub  NoPipeLine

	pop	bp			; restore registers
	add	sp,2			; toss regSegOvr
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es

pub	errret
        error_return    noerror         ; common exit sequence

endif	;LOOK_AHEAD

; return from routine;	restore registers and return


	even

pub	EMLFINISH

    ; check for errors

	MOV	AX,[CURerr]		; fetch errors
	or	[UserStatusWord],ax	; save all exception errors
	OR	[SWerr],AL		; set errors in sticky error flag
	NOT	AL			; make a zero mean an error
	MOV	bh,byte ptr [UserControlWord]	; get user's IEEE control word
	OR	bh,0C2H 		; mask reserved, IEM and denormal bits
	AND	bh,03FH 		; unmask invalid instruction,
					;    stack overflow.
	OR	AL,bh			; mask for IEEE exceptions
	NOT	AL			; make a one mean an error
	TEST	AX,0FFFFh-MemoryOperand ; test for errors to report

	jnz	SawException		; goto error handler

ifndef	LOOK_AHEAD
	pop	bp			; restore registers
	add	sp,2			; toss regSegOvr
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es

pub	errret
        error_return    noerror         ; common exit sequence

else	;LOOK_AHEAD


ifdef  DOS3and5
	jmp	[LookAheadRoutine]
endif


ifdef  DOS3

pub  DOSLookAhead
	cmp	[NextOpcode], fINT	; Quick check.	If first byte isn't
	jne	NoPipeLine		; an int instruction then exit.

    ; can stay in the emulator - set up registers for CommonDispatch

	mov	bp, sp			; set up frame pointer
	lds	di, dword ptr [bp].regIP ; DS:DI = address of next instruction
	add	di, 3			; skip 3 bytes to displacement field
	mov	cx, [di-2]		; CX = (opcode byte,0-7 from ESC)
	sub	cl, BEGINT

	cmp	cl, 7			; Can't handle segment overrides with
	ja	NoPipeLine		; pipe lining.

	mov	ax, [bp].regDI		; ax = original di
	mov	dx, [bp].regBX		; dx = original bx
	mov	si, [bp].regSI		; si = original si
	mov	es, [bp].regDS		; es = original ds (no segment override)
	mov	[bp].regSegOvr, ss	; reset override segment

	rol	ch, 1			; rotate MOD field next to r/m field
	rol	ch, 1
	mov	bl, ch			; get copy of operation
	and	bx, 1fh 		; Mask to MOD and r/m fields
	shl	bx, 1			; make into word offset
	jmp	EA286Tab[bx]

endif	;DOS3


ifdef  PROTECT

pub ProtLookAhead
	mov	cl, [NextOpcode]

	cmp	cl, fFWAIT
	je	CheckNextByte

	cmp	cl, iNOP
	je	CheckNextByte

	xor	cl,  20h		; See if this is a floating point instruction.
	cmp	cl, 0f8h
jbNoPipeLine:
	jb	NoPipeLine

	mov	bp, sp			 ; set up frame pointer
	lds	di, dword ptr [bp].regIP ; ds:di = address of next instruction

	jmp	short CanDoPipeLine

pub CheckNextByte
	mov	bp, sp			 ; set up frame pointer
	lds	di, dword ptr [bp].regIP ; ds:di = address of next instruction
	inc	di			 ; next instruction was NOP or FWAIT

	mov	cl, [di]
	xor	cl,  20h
	cmp	cl, 0f8h
	jb	jbNoPipeLine

pub CanDoPipeLine
	mov	ch, [di+1]		; we already have first byte of next
	add	di, 2			; instruction in cl

	add	cl, 8h			; clear out what's left of escape

	mov	ax, [bp].regDI		; ax = original di
	mov	dx, [bp].regBX		; dx = original bx
	mov	si, [bp].regSI		; si = original si
	mov	es, [bp].regDS		; es = original ds (no segment override)
	mov	[bp].regSegOvr, ss	; reset override segment

	rol	ch, 1			; rotate MOD field next to r/m field
	rol	ch, 1
	mov	bl, ch			; get copy of operation
	and	bx, 1fh 		; Mask to MOD and r/m fields
	shl	bx, 1			; make into word offset
	jmp	EA286Tab[bx]

endif	;PROTECT



endif	;LOOK_AHEAD


ProfEnd  MAIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emoemqb.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;
	page	,132
title	emoem.asm - OEM dependent code for 8087

;--------------------------------------------------------------------
;
;	OEM customization routines for 8087/80287 coprocessor
;
;	This module is designed to work with the following
;	Microsoft language releases:
;
;		Microsoft Quick BASIC 4.0 and later
;		Microsoft Quick BASIC (KANJI) 4.0 and later
;		Microsoft BASCOM 3.0
;		Microsoft BASCOMK 3.0
;		Microsoft BASCOM/2
;		Microsoft BASCOMK/2
;
;	This module supersedes the OEMR7.ASM module used in earlier
;	versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;	provided with the FORTRAN and Pascal releases refers to the old
;	OEMR7.ASM module and is only slightly relevant to this module.
;
;	The following routines need to be written to properly handle the
;	8087/808287 installation, termination, and interrupt handler
;
;	__FPINSTALL87		install 8087 interrupt handler
;	__FPTERMINATE87 	deinstall 8087 interrupt handler
;	__fpintreset		reset OEM hardware if an 8087 interrupt
;
;	*****  NEW INSTRUCTIONS  *****
;
;	If you want a PC clone version, do nothing.  The libraries are
;	setup for working on IBM PC's and clones.
;
;	This instructions only need to be followed if a non-IBM PC
;	clone version is desired.
;
;	This module should be assembled with the
;	Microsoft Macro Assembler Version 4.00 or later as follows:
;
;		masm -DOEM -r emoem.asm;
;
;	For QuickBASIC, assemble as follows:
;
;		masm -D_QB -DOEM -r emoem.asm;
;
;	Most hardware handles the 8087/80287 in one of the following
;	three ways -
;
;	1.	NMI - IBM PC and clones all handle the interrupt this way
;	2.	single 8259
;	3.	master/slave 8259
;
;	Manufacturer specific initialization is supported for these 3
;	machine configurations either by modifying this file and replacing
;	the existing EMOEM module in the math libraries or by patching
;	the .LIB and .EXE files directly.
;
;		LIB 87-+EMOEM;
;		LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef	OEM
if1
	%out	OEM version for non-clone support
endif
endif

ifndef	_QB
	_HOOK_CTRLC=1
endif

ifdef	_HOOK_CTRLC
if1
	%out	Non-QB version.  Hooks Ctrl-C.  Hooks INT 75h.
endif
else
if1
	%out	QB version.  Doesn't hook Ctrl-C.  Hooks INT 75h.
endif
endif

;---------------------------------------------------------------------
;	Assembly constants.
;---------------------------------------------------------------------

; MS-DOS OS calls

   OPSYS	EQU	21H
   SETVECOP	EQU	25H
   GETVECOP	EQU	35H
   DOSVERSION	EQU	30h
ifdef	_HOOK_CTRLC
   CTLCVEC	EQU	23h
endif	;_HOOK_CTRLC

EMULATOR_DATA	segment public 'FAR_DATA'
assume	ds:EMULATOR_DATA

;	User may place data here if DS is setup properly.
;	Recommend keeping the data items in the code segment.

EMULATOR_DATA	ends



EMULATOR_TEXT	segment public 'CODE'
assume	cs:EMULATOR_TEXT

	public	__FPINSTALL87		; DO NOT CHANGE THE CASE ON
	public	__FPTERMINATE87 	; THESE PUBLIC DEFINITIONS

	extrn	__FPEXCEPTION87:near	; DO NOT CHANGE CASE


ifdef	OEM

;***********************************************************************
;
; Hardware dependent parameters in the 8087 exception handler.
;
; For machines using 2 8259's to handle the 8087 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 8087
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 8087 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum	db	0		; MS-DOS OEM number (IBM is 00h)
intnum	db	2		; IBM PC clone interrupt number
share	db	0		; nonzero if original vector should be taken
a8259	dw	0		; 1st 8259 (A0=0) port #
aocw2	db	0		; 1st 8259 (A0=0) EOI command
b8259	dw	0		; 2nd 8259 (A0=0) port #
bocw2	db	0		; 2nd 8259 (A0=0) EOI command
a8259m	dw	0		; 1st 8259 (A0=1) port #
aocw1m	db	0		; 1st 8259 (A0=1) value to mask against IMR
b8259m	dw	0		; 2nd 8259 (A0=1) port #
bocw1m	db	0		; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;	OEM specific 8087 information
;
;	If the OEM number returned from the DOS version call matches,
;	this information is automatically moved into the oem struc below.

oemtab	label	byte	; Table of OEM specific values for 8087

;		OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db	0	; end of table

;	Unique pattern that can be searched for with the debugger so that
;	.LIB or .EXE files can be patched with the correct values.
;	If new values are patched into .LIB or .EXE files, care must be
;	taken in insure the values are correct.  In particular, words and
;	bytes are intermixed in oeminfo structure.  Remember words are
;	stored low byte - high byte in memory on the 8086 family.

	db	'<<8087>>'	; older versions used '<8087>'

;	Some manufacturer's machines can not be differentiated by the
;	OEM number returned by the MS-DOS version check system call.
;	For these machines it is necessary to replace the line below

oem1	oeminfo <>		; default values for IBM PC & clones

;	with one of the following.  If your machine has an 8087 capability
;	and it is not in the list below, you should contact your hardware
;	manufacturer for the necessary information.

;ACT Apricot
;oem1	 oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1	 oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

aoldIMR 	db	0	; 1st 8259 original IMR value
boldIMR 	db	0	; 2nd 8259 original IMR value

endif	;OEM

statwd		dw	0	; Temporary for status word
oldvec		dd	0	; Old value in 8087 exception interrupt vector
ifdef	_HOOK_CTRLC
ctlc		dd	0	; Old value of Control-C vector (INT 23h)
endif	;_HOOK_CTRLC
ifndef	OEM
oldvec75	dd	0	; Old value INT 75H interrupt vector
INT75FLAGS	DW	0	; flags at INT 75 time
INT75CS 	DW	0	; CS at INT 75 time
INT75IP 	DW	0	; IP at INT 75 time
INT75VEC	DW	OFFSET FPREALINT2	; place INT 75 IRETs to
endif	;OEM
page

;---------------------------------------------------------------------
;
;	Perform OEM specific initialization of the 8087.
;

__FPINSTALL87:
	push	ds			; DS = EMULATOR_DATA

	push	cs			; Move current CS to DS for opsys calls.
	pop	ds
assume	ds:EMULATOR_TEXT

ifdef	OEM
	push	ds
	pop	es			; CS = DS = ES
	mov	ah,DOSVERSION
	int	OPSYS			; bh = OEM#
	cld
	mov	si,offset oemtab	; start of OEM 8087 info table
	mov	di,offset oem1+1
	mov	cx,(size oem1)-1
OEMloop:
	lodsb				; get OEM#
	or	al,al
	jz	OEMdone 		; OEM# = 0 - did not find OEM
	cmp	al,bh			; correct OEM#
	je	OEMfound
	add	si,cx			; skip over OEM information
	jmp	OEMloop

OEMfound:
	rep	movsb			; move the information

OEMdone:				; done with automatic customization
endif	;OEM


; Save old interrupt vector.
; Ask operating system for vector.

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es
else
	mov	ax,GETVECOP shl 8 + 75H ; get interrupt vector 75H
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec75],bx	; Squirrel away old vector.
	mov	word ptr [oldvec75+2],es;

	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es
endif	;OEM

; Have operating system install interrupt vectors.

ifdef	OEM
	mov	dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
	int	OPSYS			; Install vector.
else
	mov	dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
	int	OPSYS			; Install vector.

	mov	dx,offset __fpinterrupt75 ; Load DX with 8087 interrupt handler.
	mov	ax,SETVECOP shl 8 + 75H ; set interrupt vector 75
	int	OPSYS			; Install vector.
endif	;OEM

; Intercept Control-C vector to guarentee cleanup

ifdef	_HOOK_CTRLC			;
	mov	ax,GETVECOP shl 8 + CTLCVEC
	int	OPSYS
	mov	word ptr [ctlc],bx
	mov	word ptr [ctlc+2],es
	mov	dx,offset ctlcexit
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
endif	;_HOOK_CTRLC

ifdef	OEM

;	set up 8259's so that 8087 interrupts are enabled

	mov	ah,[oem1].aocw1m 	; get mask for 1st 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;   and only 1 8259
	mov	dx,[oem1].a8259m 	; get port number for 1st 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[aoldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

	mov	ah,[oem1].bocw1m 	; get mask for 2nd 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;
	mov	dx,[oem1].b8259m 	; get port number for 2nd 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[boldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

installdone:

endif	;OEM

assume	ds:EMULATOR_DATA
	pop	ds
	ret


page
;	__FPTERMINATE87
;
;	This routine should do the OEM 8087 cleanup.  This routine is called
;	before the program exits.
;
;	DS = EMULATOR_DATA

__FPTERMINATE87:
	push	ds
	push	ax
	push	dx

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
	lds	dx,[oldvec]
	int	OPSYS
else
	mov	ax,SETVECOP shl 8 + 2
	lds	dx,[oldvec]
	int	OPSYS

	mov	ax,SETVECOP shl 8 + 75H ; restore int 75
	lds	dx,[oldvec75]		;
	int	OPSYS			;
endif	;OEM

ifdef	OEM

;	reset 8259 IMR's to original state

	push	cs
	pop	ds			; DS = CS
assume	ds:EMULATOR_TEXT
	cmp	[oem1].aocw1m,0		; did we have to change 1st 8259 IMR
	je	term2nd8259		;   no - check 2nd 8259
	mov	al,[aoldIMR]		; get old IMR
	mov	dx,[oem1].a8259m 	; get 1st 8259 (A0=1) port #
	out	dx,al			; restore IMR

term2nd8259:
	cmp	[oem1].bocw1m,0		; did we have to change 2nd 8259 IMR
	je	terminatedone		;   no
	mov	al,[boldIMR]		; get old IMR
	mov	dx,[oem1].b8259m 	; get 2nd 8259 (A0=1) port #
	out	dx,al			; restore IMR

terminatedone:

endif	;OEM

	pop	dx
	pop	ax
	pop	ds
assume	ds:EMULATOR_DATA
	ret

ifdef	_HOOK_CTRLC
;	Forced cleanup of 8087 exception handling on Control-C

ctlcexit:
	push	ax
	push	dx
	push	ds
	call	__FPTERMINATE87 	; forced cleanup of exception handler
	lds	dx,[ctlc]		; load old control C vector
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
	pop	ds
	pop	dx
	pop	ax
	jmp	[ctlc]			; go through old vector
endif	;_HOOK_CTRLC

page
;
; __fpinterrupt75
;
; This is the "real" 80x87 interrupt routine for AT's and clones.
; Entire routine added [2].
;
; We hook INT 75 in order to work around a DOS nuance that otherwise causes the
; exception handler to get executed with the wrong stack segment.
;
; In PC's, a math exception is a simple INT 2, which since we hook, we recieve
; unobstructed. On AT's, an INT 75H is generated, which is normally trapped by
; the BIOS, which performs some hardware magic, and then executes an INT 2
; instruction to simulate the PC's behaviour. Hooking INT 2 alone is sufficient
; to handle these two cases.
;
; In MS-DOS (and PC-DOS) versions 3.2x, a stack swapping scheme is employed in
; which the DOS actually allocates a new SS:SP before executing the interrupt
; handler. If we do not hook INT 75H, then it gets a new SS:SP, and executes
; the INT 2 with that stack, and we cannot look back on the stack for our
; context, nor can we really know anything about the stack at the time of the
; exception.
;
; The process used to over come this problem is, essentially, to allow the
; INT 75H to execute, including it's embedded INT 2, but to do nothing in that
; INT 2. We fake the INT 75H return, though, such that it returns to us, (with
; the right stack to boot), and we can continue to process the exception.
;
; The steps invoved:
;
; 1) Hook BOTH INT 2 and INT 75H
;
; 2) On an INT 75, save the CS, IP and FLAGS of the return address, and REPLACE
;    THEM with values that will cause the INT 75H's IRET to return step 5,
;    below.
;
; 3) Just jump to the previous INT 75H handler.
;
; 4) On the subsequent INT 2, IF there is a CS as saved in step 1, then do
;    nothing. Just IRET. If there is not saved CS, then we have a plain old
;    INT 2 (running on an XT, most likely), and we just go to step 6.
;
; 5) On return from the INT 75H, we have the SS:SP at the time of the
;    exception. Just push the previously saved FLAGS, CS and IP of the
;    exception, clear the saved CS, and fall into....
;
; 6) A normal INT 2 handler.
;
ifndef	OEM			;
__fpinterrupt75:
ASSUME	DS:NOTHING

	POP	CS:[INT75IP]	;Squirel away exception address
	POP	CS:[INT75CS]
	POP	CS:[INT75FLAGS]
	PUSHF			;Set up INT 75 to return to our code
	PUSH	CS
	PUSH	CS:[INT75VEC]
	JMP	[oldvec75]	;And execute original INT 75H
endif				; ifndef OEM
;
;	__fpinterrupt87
;
;	This is the 8087 exception interrupt routine.
;
;	All OEM specific interrupt and harware handling should be done in
;	__fpintreset because __FPEXCEPTION87 (the OEM independent 8087
;	exception handler) may not return.  __FPEXCEPTION87 also turns
;	interrupts back on.
;

PENDINGBIT=	80h		; Bit in status word for interrupt pending

__fpinterrupt87:
assume	ds:nothing

	nop
	fnstsw	[statwd]	; Store out exceptions
ifndef	OEM			;
	TEST	CS:[INT75CS],-1 ; has INT 75 ocurred?
	JZ	FPWASINT2	; jump if not
	IRET			; just return to original INT 75 handler

FPREALINT2:			; INT 75 IRETs here
	PUSH	CS:[INT75FLAGS] ; fake up original exception
	PUSH	CS:[INT75CS]	;
	PUSH	CS:[INT75IP]	;
	MOV	CS:[INT75CS],0	; and clear the INT75 occurred flag.

FPWASINT2:			;
endif				; ifndef OEM

	push	cx		; waste time
	mov	cx,3
self:
	loop	self
	pop	cx
	test	byte ptr [statwd],PENDINGBIT	; Test for 8087 interrupt
	jz	not87int	; Not an 8087 interrupt.

ifdef	OEM
	call	__fpintreset	; OEM interrupt reset routine
endif	;OEM

	call	__FPEXCEPTION87 ; 8087 error handling - may not return
				; this routine turns interrupts back on

ifdef	OEM
	cmp	[oem1].share,0	; Should we execute the old interrupt routine?
	jz	done8087	;    if not then return

;	If you fall through here to do further hardware resetting, things
;	may not always work because __FPEXCEPTION87 does not always return
;	This only happens when the 8087 handler gets an exception that is
;	a fatal error in the language runtimes.  I.e., divide by zero
;	is a fatal error in all the languages, unless the control word has
;	set to mask out divide by zero errors.

else				;
	iret			;
endif	;OEM

not87int:
	jmp	[oldvec]	; We should never return from here.


ifdef	OEM

done8087:
	iret


__fpintreset:
	push	ax
	push	dx
	mov	al,[oem1].aocw2	; Load up EOI instruction.
	or	al,al		; Is there at least one 8259 to be reset?
	jz	Reset8259ret	; no
	mov	dx,[oem1].a8259
	out	dx,al		; Reset (master) 8259 interrupt controller.
	mov	al,[oem1].bocw2	; Load up EOI instruction.
	or	al,al		; Is there a slave 8259 to be reset?
	jz	Reset8259ret
	mov	dx,[oem1].b8259
	out	dx,al		; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop	dx
	pop	ax
	ret

endif	;OEM


EMULATOR_TEXT	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emnormal.asm ===
page	,132
	subttl	emnormal.asm - Normalize and Round
;***
;emnormal.asm - Normalize and Round
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Normalize and Round.
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin NORMAL

;------------------------------------------;
;					   ;
;   Double Precision Normalize and Round   ;
;					   ;
;------------------------------------------;

	even

pub	NODRQQ
; Normalize the double precision number
; All arithmetic operations exit through NODRQQ or RNDR7Q
; Mantissa in DI:BX:CX:DX:BP, Exponent in SI, sign on Stack, old BP on Stack

	MOV	AL,4		; Maximum of 4 word shifts, sign in AH(6)
pub	DNOR
	OR	DI,DI		; See if any bits on in high word
	JNZ	short HIBYT	; If so, go check high byte for zero
	SUB	SI,16		; Drop exponent by shift count
	DEC	AL		; Bump count
	JZ	short NORZERO
	MOV	DI,BX
	MOV	BX,CX
	MOV	CX,DX
	MOV	DX,BP
	XOR	BP,BP
	JMP	DNOR

pub	NORZERO 	       ; Here if result after normalization is zero
	MOV	esi,offset IEEEzero
	MOV	edi,[RESULT]
	POP	eax	    ; Throw out sign on stack
	POP	ebp	    ; Restore Old BP
	JMP	csMOVRQQ    ; Move IEEE zero to TOS and return

	even

pub	HIBYT
	TEST	DI,0FF00H	; See if high byte is zero
	JNZ	short NORMSHF2
	SUB	SI,8		; Drop exponent by shift amount

pub	DN2
	XCHG	AX,DI
	MOV	AH,AL
	MOV	AL,BH
	MOV	BH,BL
	MOV	BL,CH
	MOV	CH,CL
	MOV	CL,DH
	MOV	DH,DL
	XCHG	AX,DI
	XCHG	AX,BP
	MOV	DL,AH
	MOV	AH,AL
	XOR	AL,AL
	XCHG	AX,BP

	even

pub	NORMSHF2
	TEST	DI,8000H	; Normalization complete?
	JNZ	ROUND		; Normalization complete

pub	NORMLP			; Have to shift left
	DEC	SI		; Account for shift in exponent
	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	RCL	DI,1
	TEST	DI,8000H	; Check for normalized result
	JZ	NORMLP		; Bit will be set when normalized
	JMP	short ROUND


pub	ROUND24 		; Round to 24 bits
	OR	DX,BP		; See if result fits exactly in 24 bits
	OR	CX,DX
	OR	CL,CH
	MOV	CH,BL
	OR	CX,CX
	JZ	short JEXACT
	OR	[CURerr],Precision   ; Set flag on inexact result
	SHR	AL,1
	JC	short DOWNorCHOP24
	SHR	AL,1
	JC	short UP24

pub	NEAR24			; Round to nearest or Even
	CMP	CX,8000H
	JA	short INC24	; Remainder Bigger then .5 so Bump up
	JB	short MSK24	; Remainder Less then .5 so Mask off
	TEST	BH,1		; Remainder = .5 so see if even
	JZ	short MSK24	; When even Mask
	JMP	short INC24	; When odd Bump up

pub	UP24
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short MSK24	; Trunc neg numbers to move toward + Inf
	JMP	short INC24

pub	DOWNorCHOP24
	SHR	AL,1
	JC	short CHOP24

pub	DOWN24
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short INC24
	JMP	short MSK24	; Trunc Pos numbers to move toward - Inf

pub	INC24
	ADD	BH,1
	ADC	DI,0
	JNC	short MSK24
	MOV	DI,8000H	; Number overflowed from 1,111... to 10,000...
	INC	SI		; Bump up Exponent

pub	CHOP24
MSK24:				; Mask off insignificant bits
	XOR	BP,BP
	MOV	DX,BP
	MOV	CX,DX
	MOV	BL,CL
pub	JEXACT
	JMP	EXACT


	even

pub	NORMSHF 		; from multiply only
	TEST	DI,8000H	; Normalization complete?
	JNZ	ROUND		; Normalization complete

	DEC	SI		; Account for shift in exponent
	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	RCL	DI,1

	even
				; mantissa in DI:BX:CX:DX:BP

pub	ROUND			; Drop into ROUND when normalized
	MOV	AL,[CWcntl]	; Pick up hi byte of control word
	SHR	AL,1		; Which has Rounding & Precision Control
	jnc	short ROUND53

pub	ROUND64 		; Round to 64 bits
	SHR	AL,1		; Remove other bit of Precision control
	OR	BP,BP		; See if result fits exactly in 64 bits
	JZ	short EXACT
	OR	[CURerr],Precision   ; Set flag on inexact result
	SHR	AL,1
	JC	short DOWNorCHOP64
	SHR	AL,1
	JC	short UP64

pub	NEAR64			; Round to nearest or Even
	CMP	BP,8000H
	JA	short INC64	; Remainder Bigger then .5 so Bump up
	JB	short MSK64	; Remainder Less then .5 so Mask off
	TEST	DL,1		; Remainder = .5 so see if even
	JZ	short MSK64	; When even Mask

pub	INC64
	XOR	BP,BP		; Need a 0
	ADD	DX,1
	ADC	CX,BP
	ADC	BX,BP
	ADC	DI,BP
	JNC	short EXACT

	MOV	DI,8000H	; Number overflowed from 1,111... to 10,000...
	INC	SI		; Bump up Exponent

	even

CHOP64:
MSK64:				; Mask off insignificant bits

pub	EXACT
	MOV	eax,[RESULT]
	XCHG	eax,edi
	MOV	MB0[edi],DX	   ; Save Mantissa
	MOV	MB2[edi],CX
	MOV	MB4[edi],BX
	MOV	MB6[edi],AX
	POP	eax		; Fetch Sign
	POP	ebp		; Fetch Old BP
	AND	AH,Sign 	; Mask off single precision
	MOV	Flag[edi],AH

	CMP	SI,IexpMax - IexpBias ; Test for overflow
	JGE	short jOVER
	CMP	SI,IexpMin - IexpBias ; Test for Underflow
	JLE	short UNDER

pub	NORTAG
	MOV	Expon[edi],SI
	MOV	byte ptr Tag[edi],0	  ; Number is in range and on TOS so ret
	RET

jOVER:	jmp	OVER

pub	UP64
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short MSK64	; Trunc neg numbers to move toward + Inf
	JMP	short INC64

pub	DOWNorCHOP64
	SHR	AL,1
	JC	short CHOP64

pub	DOWN64
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short INC64
	JMP	short MSK64	; Trunc Pos numbers to move toward - Inf


jROUND24:
	jmp	ROUND24

pub	ROUND53 		; Round to 53 bits (or 24)
	SHR	AL,1
	JNC	short jROUND24

	XCHG	BP,AX		; See if result fits exactly in 53 bits
	OR	AL,AH
	OR	AL,DL
	MOV	AH,DH
	AND	AH,007H
	AND	DH,0F8H
	XCHG	BP,AX
	OR	BP,BP
	JZ	EXACT
	OR	[CURerr],Precision   ; Set flag on inexact result
	SHR	AL,1
	JC	short DOWNorCHOP53
	SHR	AL,1
	JC	short UP53

pub	NEAR53			; Round to nearest or Even
	CMP	BP,0400H
	JA	short INC53	; Remainder Bigger then .5 so Bump up
	JB	short MSK53	; Remainder Less then .5 so Mask off
	TEST	DH,08H		; Remainder = .5 so see if even
	JZ	short MSK53	; When even Mask
	JMP	short INC53	; When odd Bump up


pub	UNDER
MUNDER: 	; Masked Underflow
	MOV	esi,offset IEEEzero
	CALL	csMOVRQQ
	MOV	Flag[edi],AH	     ; Overstore correct sign
	RET


pub	UP53
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short MSK53	; Trunc neg numbers to move toward + Inf
	JMP	short INC53

pub	DOWNorCHOP53
	SHR	AL,1
	JC	short CHOP53

pub	DOWN53
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short INC53
	JMP	short MSK53	; Trunc Pos numbers to move toward - Inf

pub	INC53
	XOR	BP,BP		; Need a 0
	ADD	DH,08H
	ADC	CX,BP
	ADC	BX,BP
	ADC	DI,BP
	JNC	short MSK53

	MOV	DI,8000H	; Number overflowed from 1,111... to 10,000...
	INC	SI		; Bump up Exponent

pub	CHOP53
MSK53:				; Mask off insignificant bits
	XOR	BP,BP
	XOR	DL,DL		; Note: The garbage in DH was masked off at ROUND53
	JMP	EXACT

PAGE

pub	OVER			    ; Here if number overflowed
MOVER:		; The masked response to rounding depends on whether rounding
		;  is directed or not.	If it is then Overflow flag is not set
		;  but precision is. Also the result is set to Inf or Biggest
		;  If rounding is not directed then Overflow is set and result
		;  is set to Inf.

	OR	[CURerr],Overflow
	MOV	AL,[CWcntl]
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	JC	short MOvDNorCHP

	SHR	AL,1
	JC	short MOvUP

MOvNEAR:	; Masked Overflow Near Rounding

pub	SignedInfinity			; Return signed infinity

	MOV	esi,offset IEEEinfinity
	CALL	csMOVRQQ
	MOV	Flag[edi],AH		 ; Overstore the proper sign
	RET

pub	MOvDNorCHP
	SHR	AL,1
	JC	short MOvCHOP

pub	MOvDOWN 			; Masked Overflow Down Rounding
	OR	[CURerr],Precision
	TEST	AH,Sign 		; Positive goes to biggest
	JNZ	short SignedInfinity

MOvCHOP:	; Masked Overflow Chop Rounding
pub	SignedBiggest
	MOV	esi,offset IEEEbiggest
	CALL	csMOVRQQ
	MOV	Flag[edi],AH		 ; Overstore the proper sign
	RET

pub	MOvUP				; Masked Overflow Up Rounding
	OR	[CURerr],Precision
	TEST	AH,Sign 		; Negative goes to biggest
	JZ	short SignedInfinity
	JMP	SignedBiggest

ProfEnd  NORMAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emoemwin.asm ===
;
;
;       Copyright (C) Microsoft Corporation, 1987-89
;
;       This Module contains Proprietary Information of Microsoft
;       Corporation and should be treated as Confidential.
;
title   emoem.asm - OEM dependent code for 8087

;--------------------------------------------------------------------
;
;       OEM customization routines for 8087/80287 coprocessor
;
;       This module is designed to work with the following
;       Microsoft language releases:
;
;               Microsoft C 3.00 and later
;               Microsoft FORTRAN 77 3.30 and later
;               Microsoft Pascal 3.30 and later
;
;       This module supersedes the OEMR7.ASM module used in earlier
;       versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;       provided with the FORTRAN and Pascal releases refers to the old
;       OEMR7.ASM module and is only slightly relevant to this module.
;
;       The following routines need to be written to properly handle the
;       8087/808287 installation, termination, and interrupt handler
;
;       __FPINSTALL87           install 8087 interrupt handler
;       __FPTERMINATE87         deinstall 8087 interrupt handler
;       __fpintreset            reset OEM hardware if an 8087 interrupt
;
;       *****  NEW INSTRUCTIONS  *****
;
;       If you want a PC clone version, do nothing.  The libraries are
;       setup for working on IBM PC's and clones.
;
;       These instructions only need to be followed if a non-IBM PC
;       clone version is desired.
;
;       This module should be assembled with the
;       Microsoft Macro Assembler Version 4.00 or later as follows:
;
;               masm -DOEM -r emoem.asm;
;
;       Most hardware handles the 8087/80287 in one of the following
;       three ways -
;
;       1.      NMI - IBM PC and clones all handle the interrupt this way
;       2.      single 8259
;       3.      master/slave 8259
;
;       Manufacturer specific initialization is supported for these 3
;       machine configurations either by modifying this file and replacing
;       the existing EMOEM module in the math libraries or by patching
;       the .LIB and .EXE files directly.
;
;               LIB 87-+EMOEM;
;               LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef   OEM
if1
	%out    OEM version for non-clone support
endif
endif

;---------------------------------------------------------------------
;       Assembly constants.
;---------------------------------------------------------------------

NULL_JMP    macro
	jmp     $+2
	endm

WASTE_TIME  macro   count
	local   WasteLoop

	push    cx
ifnb  <count>
	mov     cx, count
else
	mov     cx, 10h
endif
WasteLoop:
	push    ax
	pop     ax

	loop    WasteLoop
	pop     cx

	endm


; MS-DOS OS calls

   OPSYS        EQU     21H
   SETVECOP     EQU     25H
   GETVECOP     EQU     35H
   DOSVERSION   EQU     30h
ifndef  _NOCTRLC
   CTLCVEC      EQU     23h
endif   ;_NOCTRLC

extrn __WINFLAGS:abs
WF_PMODE    equ     1
WF_CPU286   equ     2
WF_CPU386   equ     4
WF_WIN286   equ     10h
WF_WIN386   equ     20h

EMULATOR_DATA   segment para public 'FAR_DATA'
assume  ds:EMULATOR_DATA

;       User may place data here if DS is setup properly.
;       Recommend keeping the data items in the code segment.


ifdef  OEM
extrn  aoldIMR:byte             ; 1st 8259 original IMR value
extrn  boldIMR:byte             ; 2nd 8259 original IMR value
endif   ;OEM


extrn  OldNMIVec:dword          ; Old value in 8087 exception interrupt vector

ifndef  _NOCTRLC
extrn  ctlc:dword               ; Old value of Control-C vector (INT 23h)
endif   ;_NOCTRLC


EMULATOR_DATA   ends



EMULATOR_TEXT   segment para public 'CODE'
assume  cs:EMULATOR_TEXT

	public  __FPINSTALL87           ; DO NOT CHANGE THE CASE ON
	public  __FPTERMINATE87         ; THESE PUBLIC DEFINITIONS

	extrn   __FPEXCEPTION87:near    ; DO NOT CHANGE CASE
	extrn   __FPEXCEPTION87P:near


ifdef   _NO87INSTALL    ; install/terminate routines for NO87 case for QuickC

	public  __FPINSTALLNO87 
	public  __FPTERMINATENO87

endif   ;_NO87INSTALL


ifdef   OEM

;***********************************************************************
;
; Hardware dependent parameters in the 8087 exception handler.
;
; For machines using 2 8259's to handle the 8087 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 8087
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 8087 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum  db      0               ; MS-DOS OEM number (IBM is 00h)
intnum  db      2               ; IBM PC clone interrupt number
share   db      0               ; nonzero if original vector should be taken
a8259   dw      0               ; 1st 8259 (A0=0) port #
aocw2   db      0               ; 1st 8259 (A0=0) EOI command
b8259   dw      0               ; 2nd 8259 (A0=0) port #
bocw2   db      0               ; 2nd 8259 (A0=0) EOI command
a8259m  dw      0               ; 1st 8259 (A0=1) port #
aocw1m  db      0               ; 1st 8259 (A0=1) value to mask against IMR
b8259m  dw      0               ; 2nd 8259 (A0=1) port #
bocw1m  db      0               ; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;       OEM specific 8087 information
;
;       If the OEM number returned from the DOS version call matches,
;       this information is automatically moved into the oem struc below.

oemtab  label   byte    ; Table of OEM specific values for 8087

;               OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db      0       ; end of table

;       Unique pattern that can be searched for with the debugger so that
;       .LIB or .EXE files can be patched with the correct values.
;       If new values are patched into .LIB or .EXE files, care must be
;       taken in insure the values are correct.  In particular, words and
;       bytes are intermixed in oeminfo structure.  Remember words are
;       stored low byte - high byte in memory on the 8086 family.

	db      '<<8087>>'      ; older versions used '<8087>'

;       Some manufacturer's machines can not be differentiated by the
;       OEM number returned by the MS-DOS version check system call.
;       For these machines it is necessary to replace the line below

oem1    oeminfo <>              ; default values for IBM PC & clones

;       with one of the following.  If your machine has an 8087 capability
;       and it is not in the list below, you should contact your hardware
;       manufacturer for the necessary information.

;ACT Apricot
;oem1    oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1    oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

endif   ;OEM


page

;---------------------------------------------------------------------
;
;       Perform OEM specific initialization of the 8087.
;

__FPINSTALL87:
	push    ds                      ; DS = EMULATOR_DATA


ifdef   OEM
	push    ds
	pop     es                      ; CS = DS = ES
	mov     ah,DOSVERSION
	int     OPSYS                   ; bh = OEM#
	cld
	mov     si,offset oemtab        ; start of OEM 8087 info table
	mov     di,offset oem1+1
	mov     cx,(size oem1)-1
OEMloop:
	lodsb                           ; get OEM#
	or      al,al
	jz      OEMdone                 ; OEM# = 0 - did not find OEM
	cmp     al,bh                   ; correct OEM#
	je      OEMfound
	add     si,cx                   ; skip over OEM information
	jmp     OEMloop

OEMfound:
	rep     movsb                   ; move the information

OEMdone:                                ; done with automatic customization
endif   ;OEM

; Save old interrupt vector.
; Ask operating system for vector.

ifdef  WINDOWS
	mov     ax, word ptr [OldNMIVec]
	or      ax, word ptr [OldNMIVec+2]
	jnz     SetVector
endif   ;WINDOWS

ifdef   OEM
	mov     al,[oem1].intnum        ; Interrupt vector number.
	mov     ah,GETVECOP             ; Operating system call interrupt.
else
	mov     ax,GETVECOP shl 8 + 2   ; get interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Call operating system.

	mov     word ptr [OldNMIVec],bx ; Squirrel away old vector.
	mov     word ptr [OldNMIVec+2],es

; Have operating system install interrupt vectors.

SetVector:
	push    cs                      ; Move current CS to DS for opsys calls.
	pop     ds
assume  ds:EMULATOR_TEXT

	mov     dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
ifdef   OEM
	mov     ah,SETVECOP             ; Set interrupt vector code in AH.
	mov     al,[oem1].intnum        ; Set vector number.
else
	mov     ax,SETVECOP shl 8 + 2   ; set interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Install vector.

	mov     ax, __WINFLAGS
	test    ax, WF_PMODE
	jz      SkipSettingIRQ13

	.286p
	.287
	fsetpm                          ; set PM just in case Windows didn't.
	.8086
	.8087

	push    cs
	pop     ds                       ; Move current CS to DS for opsys calls.
assume  ds:EMULATOR_TEXT
	mov     dx, offset __fpIRQ13     ; Load DX with IRQ 13 interrupt handler.
	mov     ax, SETVECOP shl 8 + 75h ; set interrupt vector 75h
	int     OPSYS                    ; Install vector.
SkipSettingIRQ13:

ifndef  _NOCTRLC
; Intercept Control-C vector to guarentee cleanup

	mov     ax,GETVECOP shl 8 + CTLCVEC
	int     OPSYS
	mov     word ptr [ctlc],bx
	mov     word ptr [ctlc+2],es
	mov     dx,offset ctlcexit
	mov     ax,SETVECOP shl 8 + CTLCVEC
	int     OPSYS
endif   ;_NOCTRLC

ifdef   OEM

;       set up 8259's so that 8087 interrupts are enabled

	mov     ah,[oem1].aocw1m        ; get mask for 1st 8259 IMR
	or      ah,ah                   ;   if 0, don't need to do this
	jz      installdone             ;   and only 1 8259
	mov     dx,[oem1].a8259m        ; get port number for 1st 8259 (A0=1)
	in      al,dx                   ; read old IMR value
	mov     [aoldIMR],al            ; save it to restore at termination
	and     al,ah                   ; mask to enable interrupt
	jmp     short $+2               ; for 286's
	out     dx,al                   ; write out new mask value

	mov     ah,[oem1].bocw1m        ; get mask for 2nd 8259 IMR
	or      ah,ah                   ;   if 0, don't need to do this
	jz      installdone             ;
	mov     dx,[oem1].b8259m        ; get port number for 2nd 8259 (A0=1)
	in      al,dx                   ; read old IMR value
	mov     [boldIMR],al            ; save it to restore at termination
	and     al,ah                   ; mask to enable interrupt
	jmp     short $+2               ; for 286's
	out     dx,al                   ; write out new mask value

installdone:

endif   ;OEM

assume  ds:EMULATOR_DATA
	pop     ds
	ret


page
;       __FPTERMINATE87
;
;       This routine should do the OEM 8087 cleanup.  This routine is called
;       before the program exits.
;
;       DS = EMULATOR_DATA

__FPTERMINATE87:
	push    ds
	push    ax
	push    dx

ifdef   OEM
	mov     ah,SETVECOP
	mov     al,[oem1].intnum
else
	mov     ax,SETVECOP shl 8 + 2
endif   ;OEM
	lds     dx,[OldNMIVec]
	int     OPSYS

ifdef   OEM

;       reset 8259 IMR's to original state

	push    cs
	pop     ds                      ; DS = CS
assume  ds:EMULATOR_TEXT
	cmp     [oem1].aocw1m,0         ; did we have to change 1st 8259 IMR
	je      term2nd8259             ;   no - check 2nd 8259
	mov     al,[aoldIMR]            ; get old IMR
	mov     dx,[oem1].a8259m        ; get 1st 8259 (A0=1) port #
	out     dx,al                   ; restore IMR

term2nd8259:
	cmp     [oem1].bocw1m,0         ; did we have to change 2nd 8259 IMR
	je      terminatedone           ;   no
	mov     al,[boldIMR]            ; get old IMR
	mov     dx,[oem1].b8259m        ; get 2nd 8259 (A0=1) port #
	out     dx,al                   ; restore IMR

terminatedone:

endif   ;OEM

	pop     dx
	pop     ax
	pop     ds
assume  ds:EMULATOR_DATA
	ret


;       Forced cleanup of 8087 exception handling on Control-C

ifndef  _NOCTRLC
ctlcexit:
	push    ax
	push    dx
	push    ds
	call    __FPTERMINATE87         ; forced cleanup of exception handler
	lds     dx,[ctlc]               ; load old control C vector
	mov     ax,SETVECOP shl 8 + CTLCVEC
	int     OPSYS
	pop     ds
	pop     dx
	pop     ax
	jmp     [ctlc]                  ; go through old vector
endif   ;_NOCTRLC

page
;       __fpinterrupt87
;
;       This is the 8087 exception interrupt routine.
;
;       All OEM specific interrupt and harware handling should be done in
;       __fpintreset because __FPEXCEPTION87 (the OEM independent 8087
;       exception handler) may not return.  __FPEXCEPTION87 also turns
;       interrupts back on.
;

PENDINGBIT=     80h             ; Bit in status word for interrupt pending

public __fpIRQ13
__fpIRQ13:
	cli

	WASTE_TIME  70

	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	mov     al, 65h
	NULL_JMP
	out     0a0h, al        ; EOI slave irq 5
	NULL_JMP
	mov     al, 62h
	NULL_JMP
	out     20h, al         ; EOI master irq 2
	NULL_JMP
	pop     ax


	sub     sp, 2

	push    bp
	mov     bp, sp

	fnstsw  [bp+2]
	WASTE_TIME
	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	pop     ax

	pop     bp

;       fnclex                  ; 486 bug - must wait till after last
				; "out f0" to clear fp exceptions
				; or IGNNE# will be permanently active.
	WASTE_TIME
	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	pop     ax

;       fnclex                  ; 486 bug - must wait till after last
				; "out f0" to clear fp exceptions
				; or IGNNE# will be permanently active.
	WASTE_TIME
	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	pop     ax

	fnclex                  ;Now this is safe.
	WASTE_TIME 70           ;Fix timing problem??

	jmp     __FPEXCEPTION87P


public __fpinterrupt87
__fpinterrupt87:
assume  ds:nothing
	nop

	push    bp
	mov     bp, sp
	sub     sp, 2

	fnstsw  word ptr [bp-2]     ; Store out exceptions

	push    cx                  ; waste time
	mov     cx, 3
self:
	loop    self
	pop     cx

	test    byte ptr [bp-2],PENDINGBIT  ; Test for 8087 interrupt

	mov     sp, bp
	pop     bp

	jz      not87int                    ; Not an 8087 interrupt.

ifdef   OEM
	call    __fpintreset    ; OEM interrupt reset routine
endif   ;OEM

	call    __FPEXCEPTION87 ; 8087 error handling - may not return
				; this routine turns interrupts back on

ifdef   OEM
	cmp     [oem1].share,0  ; Should we execute the old interrupt routine?
	jnz     not87int        ;    if so then do it
				;    else return from interrupt

;       If you fall through here to do further hardware resetting, things
;       may not always work because __FPEXCEPTION87 does not always return
;       This only happens when the 8087 handler gets an exception that is
;       a fatal error in the language runtimes.  I.e., divide by zero
;       is a fatal error in all the languages, unless the control word has
;       set to mask out divide by zero errors.

endif   ;OEM

done8087:
	iret

not87int:
	sub     sp, 4

	push    bp
	mov     bp, sp

	push    ds
	push    ax

	mov     ax, EMULATOR_DATA
	mov     ds, ax
	assume  ds:EMULATOR_DATA

	mov     ax, word ptr [OldNMIVec+2]      ; segment of OldNMIVec
	mov     [bp+4], ax

	mov     ax, word ptr [OldNMIVec]        ; offset of OldNMIVec
	mov     [bp+2], ax

	pop     ax
	pop     ds
	mov     sp, bp
	pop     bp

	retf                    ; jmp  [OldNMIVec]. We should not return.


ifdef   OEM


__fpintreset:
	push    ax
	push    dx
	mov     al,[oem1].aocw2 ; Load up EOI instruction.
	or      al,al           ; Is there at least one 8259 to be reset?
	jz      Reset8259ret    ; no
	mov     dx,[oem1].a8259
	out     dx,al           ; Reset (master) 8259 interrupt controller.
	mov     al,[oem1].bocw2 ; Load up EOI instruction.
	or      al,al           ; Is there a slave 8259 to be reset?
	jz      Reset8259ret
	mov     dx,[oem1].b8259
	out     dx,al           ; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop     dx
	pop     ax
	ret

endif   ;OEM

ifdef   _NO87INSTALL
__FPINSTALLNO87:
	push    bx
	push    es
	push    ax
	push    dx
	push    ds

	mov     ax,cs                   ; Move current CS to DS for opsys calls.
	mov     ds,ax
assume  ds:EMULATOR_TEXT  r
	
; Save old interrupt vector.
; Ask operating system for vector.

ifdef   OEM
	mov     al,[oem1].intnum        ; Interrupt vector number.
	mov     ah,GETVECOP             ; Operating system call interrupt.
else
	mov     ax,GETVECOP shl 8 + 2   ; get interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Call operating system.
	mov     word ptr [OldNMIVec],bx ; Squirrel away old vector.
	mov     word ptr [OldNMIVec+2],es

; Have operating system install interrupt vectors.

	mov     dx,offset __fpinterruptno87 ; Load DX with fake 8087 interrupt handler.
ifdef   OEM
	mov     ah,SETVECOP             ; Set interrupt vector code in AH.
	mov     al,[oem1].intnum        ; Set vector number.
else
	mov     ax,SETVECOP shl 8 + 2   ; set interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Install vector.

	pop     ds
assume  ds:nothing
	pop     dx
	pop     ax
	pop     es
	pop     bx
	
	ret

__fpinterruptno87:
	jmp     [OldNMIVec]             ; will use CS: override

__FPTERMINATENO87:
	push    ds
	push    ax
	push    dx

	mov     ax,cs
	mov     ds,ax
assume  ds:EMULATOR_TEXT

ifdef   OEM
	mov     ah,SETVECOP
	mov     al,[oem1].intnum
else
	mov     ax,SETVECOP shl 8 + 2
endif   ;OEM
	lds     dx,[OldNMIVec]
assume  ds:nothing
	int     OPSYS

	pop     dx
	pop     ax
	pop     ds

	ret

endif   ;_NO87INSTALL

EMULATOR_TEXT   ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emstack.asm ===
page	,132
	subttl	emstack.asm - Emulator Stack Management Area
;***
;emstack.asm - Emulator Stack Management Area
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Emulator Stack Management Area
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin STACK


;*********************************************************************;
;								      ;
;		    Emulator Stack Management Area		      ;
;								      ;
;*********************************************************************;

; The emulator maintains an "finite" stack of 12 byte registers.

; Stand-alone emulator has 1 chunk only.

; This is done using a list of finite length stack chunks, each of
; which has the following format:
;      +00   first (deepest) 12 byte register
;      +12   next 12 byte register
;	     (and so on through last possible register)


; MACROS used to manipulate the emulator/8087 memory stack


; This macro allocates a new TOS register, returns SI with its address.

PUSHST	MACRO
	local	pushstok
	mov	esi,[CURstk]	; 14 get address of current register
	cmp	esi,[LIMstk]	; 15 is current register end of stack
	jne	short pushstok	; 16 no, still room in stack
	call	OverStk 	;    stack overflow error
pushstok:
	add	esi,Reg87Len	;  4 increment SI to next free register
	mov	[CURstk],esi	; 15 set current top of stack
	ENDM			; 64 total


; This macro deallocates TOS register, returns SI with new TOS address.
; Note:  assumes SI contains TOS address, CURstk
; BASstk converted back to a variable to enable macro use for 8087 stack
; handling.  Brad Verheiden, 4-13-84.

POPSTsi MACRO
	local	popstok
	cmp	esi,[BASstk]		   ; 15 was it last register in the chunk ?
	jnz	short popstok		   ; 16 no, still room in current chunk
	call	UnderStk		   ;	stack underflow error
popstok:
	sub	esi,Reg87Len		   ;  4 decrement SI to previous register
	mov	[CURstk],esi		   ; 15 set current top of stack
	ENDM				   ; 64 total

POPST	MACRO
	mov	esi,[CURstk]
	POPSTsi
	ENDM


ChangeDIfromTOStoNOS	MACRO
	sub	edi,Reg87Len
	ENDM


page
; This area contains two procedures, OverStk and UnderStk,
; which generate a stack overflow error.

; OverStk:   invoked within PUSHST macro
;   on entry, the stack is full
;   on return, SI contains address of base of stack

; UnderStk:  invoked within POPST macro
;   on entry, the stack is empty
;   on return, SI contains address of base of stack

pub	OverStk
	OR	byte ptr [CURerr+1],StackOverflow/256 ; raise stack overflow
	CMP	[Have8087],0		; Is 8087 present
	JZ	short OverStkEnd	; No - don't touch AX
	OR	AH,StackOverflow/256	; Indicate memory overflow for 8087

pub	OverStkEnd
	RET				; finished

pub	UnderStk
	OR	byte ptr [CURerr+1],StackUnderflow/256 ; raise stack underflow
	RET				; finished

ProfEnd  STACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emoemqp.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
title	emoem.asm - OEM dependent code for 8087

;--------------------------------------------------------------------
;
;	OEM customization routines for 8087/80287 coprocessor
;
;	This module is designed to work with the following
;	Microsoft language releases:
;
;		Microsoft C 3.00 and later
;		Microsoft FORTRAN 77 3.30 and later
;		Microsoft Pascal 3.30 and later
;
;	This module supersedes the OEMR7.ASM module used in earlier
;	versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;	provided with the FORTRAN and Pascal releases refers to the old
;	OEMR7.ASM module and is only slightly relevant to this module.
;
;	The following routines need to be written to properly handle the
;	8087/808287 installation, termination, and interrupt handler
;
;	__FPINSTALL87		install 8087 interrupt handler
;	__FPTERMINATE87 	deinstall 8087 interrupt handler
;	__fpintreset		reset OEM hardware if an 8087 interrupt
;
;	*****  NEW INSTRUCTIONS  *****
;
;	If you want a PC clone version, do nothing.  The libraries are
;	setup for working on IBM PC's and clones.
;
;	These instructions only need to be followed if a non-IBM PC
;	clone version is desired.
;
;	This module should be assembled with the
;	Microsoft Macro Assembler Version 4.00 or later as follows:
;
;		masm -DOEM -r emoem.asm;
;
;	Most hardware handles the 8087/80287 in one of the following
;	three ways -
;
;	1.	NMI - IBM PC and clones all handle the interrupt this way
;	2.	single 8259
;	3.	master/slave 8259
;
;	Manufacturer specific initialization is supported for these 3
;	machine configurations either by modifying this file and replacing
;	the existing EMOEM module in the math libraries or by patching
;	the .LIB and .EXE files directly.
;
;		LIB 87-+EMOEM;
;		LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef	OEM
if1
	%out	OEM version for non-clone support
endif
endif

;---------------------------------------------------------------------
;	Assembly constants.
;---------------------------------------------------------------------

; MS-DOS OS calls

   OPSYS	EQU	21H
   SETVECOP	EQU	25H
   GETVECOP	EQU	35H
   DOSVERSION	EQU	30h
ifndef	_NOCTRLC
   CTLCVEC	EQU	23h
endif	;_NOCTRLC

DATA   segment word public
assume	ds:DATA

;	User may place data here if DS is setup properly.
;	Recommend keeping the data items in the code segment.

DATA   ends



CODE   segment word public
assume	cs:CODE

	public	__FPINSTALL87		; DO NOT CHANGE THE CASE ON
	public	__FPTERMINATE87 	; THESE PUBLIC DEFINITIONS

	extrn	__FPEXCEPTION87:near	; DO NOT CHANGE CASE


ifdef	_NO87INSTALL	; install/terminate routines for NO87 case for QuickC

	public	__FPINSTALLNO87	
	public	__FPTERMINATENO87

endif	;_NO87INSTALL


ifdef	OEM

;***********************************************************************
;
; Hardware dependent parameters in the 8087 exception handler.
;
; For machines using 2 8259's to handle the 8087 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 8087
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 8087 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum	db	0		; MS-DOS OEM number (IBM is 00h)
intnum	db	2		; IBM PC clone interrupt number
share	db	0		; nonzero if original vector should be taken
a8259	dw	0		; 1st 8259 (A0=0) port #
aocw2	db	0		; 1st 8259 (A0=0) EOI command
b8259	dw	0		; 2nd 8259 (A0=0) port #
bocw2	db	0		; 2nd 8259 (A0=0) EOI command
a8259m	dw	0		; 1st 8259 (A0=1) port #
aocw1m	db	0		; 1st 8259 (A0=1) value to mask against IMR
b8259m	dw	0		; 2nd 8259 (A0=1) port #
bocw1m	db	0		; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;	OEM specific 8087 information
;
;	If the OEM number returned from the DOS version call matches,
;	this information is automatically moved into the oem struc below.

oemtab	label	byte	; Table of OEM specific values for 8087

;		OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db	0	; end of table

;	Unique pattern that can be searched for with the debugger so that
;	.LIB or .EXE files can be patched with the correct values.
;	If new values are patched into .LIB or .EXE files, care must be
;	taken in insure the values are correct.  In particular, words and
;	bytes are intermixed in oeminfo structure.  Remember words are
;	stored low byte - high byte in memory on the 8086 family.

	db	'<<8087>>'	; older versions used '<8087>'

;	Some manufacturer's machines can not be differentiated by the
;	OEM number returned by the MS-DOS version check system call.
;	For these machines it is necessary to replace the line below

oem1	oeminfo <>		; default values for IBM PC & clones

;	with one of the following.  If your machine has an 8087 capability
;	and it is not in the list below, you should contact your hardware
;	manufacturer for the necessary information.

;ACT Apricot
;oem1	 oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1	 oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

aoldIMR 	db	0	; 1st 8259 original IMR value
boldIMR 	db	0	; 2nd 8259 original IMR value

endif	;OEM

statwd		dw	0	; Temporary for status word
oldvec		dd	0	; Old value in 8087 exception interrupt vector
ifndef	_NOCTRLC
ctlc		dd	0	; Old value of Control-C vector (INT 23h)
endif	;_NOCTRLC

page

;---------------------------------------------------------------------
;
;	Perform OEM specific initialization of the 8087.
;

__FPINSTALL87:
	push	ds			; DS = EMULATOR_DATA

	push	cs			; Move current CS to DS for opsys calls.
	pop	ds
assume	ds:CODE

ifdef	OEM
	push	ds
	pop	es			; CS = DS = ES
	mov	ah,DOSVERSION
	int	OPSYS			; bh = OEM#
	cld
	mov	si,offset oemtab	; start of OEM 8087 info table
	mov	di,offset oem1+1
	mov	cx,(size oem1)-1
OEMloop:
	lodsb				; get OEM#
	or	al,al
	jz	OEMdone 		; OEM# = 0 - did not find OEM
	cmp	al,bh			; correct OEM#
	je	OEMfound
	add	si,cx			; skip over OEM information
	jmp	OEMloop

OEMfound:
	rep	movsb			; move the information

OEMdone:				; done with automatic customization
endif	;OEM

; Save old interrupt vector.
; Ask operating system for vector.

ifdef  WINDOWS
	mov	ax, word ptr [oldvec]
	or	ax, word ptr [oldvec+2]
	jnz	SetVector
endif	;WINDOWS

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.

	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

SetVector:
	mov	dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

ifndef	_NOCTRLC
; Intercept Control-C vector to guarentee cleanup

	mov	ax,GETVECOP shl 8 + CTLCVEC
	int	OPSYS
	mov	word ptr [ctlc],bx
	mov	word ptr [ctlc+2],es
	mov	dx,offset ctlcexit
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
endif	;_NOCTRLC

ifdef	OEM

;	set up 8259's so that 8087 interrupts are enabled

	mov	ah,[oem1].aocw1m 	; get mask for 1st 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;   and only 1 8259
	mov	dx,[oem1].a8259m 	; get port number for 1st 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[aoldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

	mov	ah,[oem1].bocw1m 	; get mask for 2nd 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;
	mov	dx,[oem1].b8259m 	; get port number for 2nd 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[boldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

installdone:

endif	;OEM

assume	ds:DATA
	pop	ds
	ret


page
;	__FPTERMINATE87
;
;	This routine should do the OEM 8087 cleanup.  This routine is called
;	before the program exits.
;
;	DS = EMULATOR_DATA

__FPTERMINATE87:
	push	ds
	push	ax
	push	dx

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
	int	OPSYS

ifdef	OEM

;	reset 8259 IMR's to original state

	push	cs
	pop	ds			; DS = CS
assume	ds:CODE
	cmp	[oem1].aocw1m,0		; did we have to change 1st 8259 IMR
	je	term2nd8259		;   no - check 2nd 8259
	mov	al,[aoldIMR]		; get old IMR
	mov	dx,[oem1].a8259m 	; get 1st 8259 (A0=1) port #
	out	dx,al			; restore IMR

term2nd8259:
	cmp	[oem1].bocw1m,0		; did we have to change 2nd 8259 IMR
	je	terminatedone		;   no
	mov	al,[boldIMR]		; get old IMR
	mov	dx,[oem1].b8259m 	; get 2nd 8259 (A0=1) port #
	out	dx,al			; restore IMR

terminatedone:

endif	;OEM

	pop	dx
	pop	ax
	pop	ds
assume	ds:DATA
	ret


;	Forced cleanup of 8087 exception handling on Control-C

ifndef	_NOCTRLC
ctlcexit:
	push	ax
	push	dx
	push	ds
	call	__FPTERMINATE87 	; forced cleanup of exception handler
	lds	dx,[ctlc]		; load old control C vector
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
	pop	ds
	pop	dx
	pop	ax
	jmp	[ctlc]			; go through old vector
endif	;_NOCTRLC

page
;	__fpinterrupt87
;
;	This is the 8087 exception interrupt routine.
;
;	All OEM specific interrupt and harware handling should be done in
;	__fpintreset because __FPEXCEPTION87 (the OEM independent 8087
;	exception handler) may not return.  __FPEXCEPTION87 also turns
;	interrupts back on.
;

PENDINGBIT=	80h		; Bit in status word for interrupt pending

__fpinterrupt87:
assume	ds:nothing
	nop
	fnstsw	[statwd]	; Store out exceptions
	push	cx		; waste time
	mov	cx,3
self:
	loop	self
	pop	cx
	test	byte ptr [statwd],PENDINGBIT	; Test for 8087 interrupt
	jz	not87int	; Not an 8087 interrupt.

ifdef	OEM
	call	__fpintreset	; OEM interrupt reset routine
endif	;OEM

	call	__FPEXCEPTION87 ; 8087 error handling - may not return
				; this routine turns interrupts back on

ifdef	OEM
	cmp	[oem1].share,0	; Should we execute the old interrupt routine?
	jnz	not87int	;    if so then do it
				;    else return from interrupt

;	If you fall through here to do further hardware resetting, things
;	may not always work because __FPEXCEPTION87 does not always return
;	This only happens when the 8087 handler gets an exception that is
;	a fatal error in the language runtimes.  I.e., divide by zero
;	is a fatal error in all the languages, unless the control word has
;	set to mask out divide by zero errors.

endif	;OEM

done8087:
	iret

not87int:
	jmp	[oldvec]	; We should never return from here.


ifdef	OEM


__fpintreset:
	push	ax
	push	dx
	mov	al,[oem1].aocw2	; Load up EOI instruction.
	or	al,al		; Is there at least one 8259 to be reset?
	jz	Reset8259ret	; no
	mov	dx,[oem1].a8259
	out	dx,al		; Reset (master) 8259 interrupt controller.
	mov	al,[oem1].bocw2	; Load up EOI instruction.
	or	al,al		; Is there a slave 8259 to be reset?
	jz	Reset8259ret
	mov	dx,[oem1].b8259
	out	dx,al		; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop	dx
	pop	ax
	ret

endif	;OEM

ifdef	_NO87INSTALL
__FPINSTALLNO87:
	push	bx
	push	es
	push	ax
	push	dx
	push	ds

	mov	ax,cs			; Move current CS to DS for opsys calls.
	mov	ds,ax
assume	ds:CODE
	
; Save old interrupt vector.
; Ask operating system for vector.

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

	mov	dx,offset __fpinterruptno87 ; Load DX with fake 8087 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

	pop	ds
assume	ds:nothing
	pop	dx
	pop	ax
	pop	es
	pop	bx
	
	ret

__fpinterruptno87:
	jmp	[oldvec]		; will use CS: override

__FPTERMINATENO87:
	push	ds
	push	ax
	push	dx

	mov	ax,cs
	mov	ds,ax
assume	ds:CODE

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
assume	ds:nothing
	int	OPSYS

	pop	dx
	pop	ax
	pop	ds

	ret

endif	;_NO87INSTALL

CODE   ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emu8087.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
only87  equ     1                       ; no emulator

include emulator.asm

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emspec.asm ===
page	,132
	subttl	emspec.asm - Special emulator functions for speed
;***
;emspec.asm - Special emulator functions for speed
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Special emulator functions for speed
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin SPEC


pub	loadcontrolword
ifdef	QB3
	or	al,2			; mask denormal exceptions
endif	;QB3
	mov	[UserControlWord],ax	; save user's version
	and	ax,0FF3CH		; Turn off reserved, IEM, Denormal
					; & invalid exception mask bits
ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; Non-0 if 8087 present
	je	EmulateFLDCW
endif	;only87

	mov	[REMLSW],ax		; use this cell (not busy)
	fnop				; fix for intel erratum #8
	fldcw	[REMLSW]		; 8087 gets new control word
endif	;frontend

pub	EmulateFLDCW
	mov	[ControlWord],ax	; save internal control word
	ret


;-----------------------------------------------------------------------------

ifndef	QB3				; rest not needed if QB 3

pub	storecontrolword
	mov	ax,[UserControlWord]	; get user's version
	ret


pub	storestatusword
	xor	ax,ax
ifndef	frontend
	cmp	al,[Have8087]
	je	no87status
	fstsw	[NewStatusWord]
	fwait
	mov	al,byte ptr [NewStatusWord] ; get exception summary
	and	al,03Fh 		; only low 6 bits are wanted
endif	;frontend

pub	no87status
	or	ax,[UserStatusWord]	; or with full status
	and	ax,UStatMask		; mask down to actual status bits
	mov	[UserStatusWord],ax	; update full status word
	ret

page

; Procedure to truncate TOS to integer TOS

;	ax = new rounding control

pub	truncateTOS
	and	ax,RoundControl shl 8	; mask to new rounding control

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0
	je	Emulatetruncate
endif	;only87

	FSTCW	[ControlWord]		; get control word
	FWAIT				; synchronize
	MOV	CX,[ControlWord]	; round mode saved
	and	ch,not RoundControl	; clear rounding control bits
	OR	ax,cx			; set new rounding
	MOV	[REMLSW],AX		; back to memory
	FLDCW	[REMLSW]		; reset rounding
	FRNDINT 			; "round" top of stack
	FLDCW	[ControlWord]		; restore rounding
	RET				; simple return
endif	;frontend

ifndef	only87
pub	Emulatetruncate
	mov	cx,[ControlWord]
	push	cx			; remember what control word was
	and	ch,not RoundControl	; clear rounding control bits
	OR	ah,ch			; set new rounding
	MOV	[CWcntl],ah		; flag new rounding mode
	PUSH	BP			; save BP
	CALL	eFRNDINT
	POP	BP			; restore BP
	POP	[ControlWord]		; set back to the way it was

	call	checktrunc		; check for truncation error

	RET				; finished
endif	;only87

page

; Procedure to truncate TOS to integer in DX:AX

;	ax = new rounding control

pub	truncateTOSto32int
	and	ax,RoundControl shl 8

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0
	je	Emulatetruncateto32int
endif	;only87

	FSTCW	[ControlWord]		; get control word
	FWAIT				; synchronize
	MOV	CX,[ControlWord]	; round mode saved
	and	ch,not RoundControl	; clear rounding control bits
	OR	ax,cx			; set new rounding
	MOV	[REMLSW],AX		; back to memory
	FLDCW	[REMLSW]		; reset rounding
	FISTP	dword ptr [REMLSW]	; "round" top of stack
	FLDCW	[ControlWord]		; restore rounding
	mov	ax,[REMLSW]
	mov	dx,[REMLSW+2]
	RET				; simple return
endif	;frontend

ifndef	only87
pub	Emulatetruncateto32int
	mov	cx,[ControlWord]
	push	cx			; remember what control word was
	and	ch,not RoundControl	; clear rounding control bits
	OR	ah,ch			; set new rounding
	MOV	[CWcntl],ah		; flag new rounding mode
	PUSH	BP			; save BP
	CALL	TOSto32int		; convert to 32-bit int in BX:DX
	POP	BP			; restore BP
	mov	ax,dx
	mov	dx,bx

	call	checktrunc		; check for truncation error

	POPST				; pop of current stack entry
	POP	[ControlWord]		; set back to the way it was

pub	truncerrOK			; (reuse RET for routine below)
	RET				; finished

;	check for errors

pub	checktrunc			; !!! check emmain for same code
	MOV	cx,[CURerr]		; fetch errors
	or	[UserStatusWord],cx	; OR into user status word
	OR	[SWerr],cl		; set errors in sticky error flag
	NOT	cl			; make a zero mean an error
	MOV	ch,byte ptr [UserControlWord]  ; get user's IEEE control word
	OR	ch,0C2H 		; mask reserved, IEM and denormal bits
	AND	ch,03FH 		; unmask invalid instruction,
					;    stack overflow.
	OR	cl,ch			; mask for IEEE exceptions
	NOT	cl			; make a one mean an error
	MOV	ch,byte ptr (CURerr+1)	; get stack over/underflow flags
	TEST	cx,0FFFFh-MemoryOperand ; test for errors to report
	jz	truncerrOK		;   error is masked

	xchg	ax,cx			; ax = exception
	jmp	CommonExceptions	; handle error (??? unclean stack)

endif	;only87


endif	;QB3


ProfEnd  SPEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emthread.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emthread.asm - Emulator multi-thread support for OS/2
page


thread1static=1		; set DS = EMULATOR_DATA for thread 1
			; dynamically allocate data areas for other threads

_DATA	segment	word public 'DATA'
_DATA	ends

DGROUP	group _DATA

_DATA	segment	word public 'DATA'
	extrn	__FPDSARRAY:WORD

	ifdef	i386
		extrn	__threadid:FWORD	; far pointer to ???? thread id
	else
		extrn	__threadid:DWORD	; far pointer to WORD thread id
	endif	
_DATA	ends

dataoffset equ offset DGROUP:

include	os2dll.inc			; defines _SIGNAL_LOCK
					; and other lock values;
					; must be synchronized with
					; \clib\include\86\os2dll.inc
					; and \clib\include\os2dll.h
extrn __lockf:FAR
extrn __unlockf:FAR

LOAD_DS_EDI	macro
		local	TIDOk, LoadDone
;
;	loads ds:edi with far pointer to thread's DS selector
;	(pointer into __FPDSARRAY)
;
;	uses eax,edi,es,ds
;
;	sets eax = 2 * (thread id)
;

	mov	ax,DGROUP
	mov	ds,ax			; set DS = DGROUP temporarily
	assume 	ds:DGROUP
	les	edi,[__threadid]	; ES:eDI = far pointer to thread id
	mov	ax,es:[edi]		; AX = thread id (far ptr to WORD)

	cmp	ax, MAXTHREADID
	jbe	TIDOk

	push	ax
	call	LoadDS_EDI
	pop	ax
	shl	ax, 1			; thread id times 2
	jmp	short LoadDone

TIDOk:
	shl	eax,1			; thread id times 2
	mov	edi,dataoffset __FPDSARRAY
	add	edi,eax			; index into __FPDSARRAY 
LoadDone:
	endm


LOADthreadDS	macro
;
; loads thread's DS from __FPDSARRAY indexed by thread id 
; preserves all registers except DS and eAX
;
; __FPDSARRAY[0] = MAXTHREAD
; __FPDSARRAY[i] = emulator DS for thread i, 1<=i<=MAXTHREAD
;
	push	edi			; save eDI
	push	es			; save ES

	LOAD_DS_EDI			; get pointer (ds:edi) to thread's DS
	
	mov	ds,ds:[edi]		; set up DS to thread's data area
	assume 	ds:EMULATOR_DATA 	; or dynamically allocated copy

	pop	es
	pop	edi			; restore DI
	endm

ALLOCthreadDS	macro
pub	allocperthread
	LOAD_DS_EDI			; get pointer into __FPDSARRAY
; eAX = 2 * (thread_id)
ifdef	thread1static
;
; for thread 1, use EMULATOR_DATA segment
;
	cmp	eax,2			; thread 1?
	jnz	allocds			;  no - dynamically allocate DS
	mov	ax,EMULATOR_DATA	;  yes - use static area
	mov 	ds:[edi],ax		; store new DS into __FPDSARRAY 
	mov	ds,ax
	assume	ds:EMULATOR_DATA	; or dynamically allocated copy
	mov	es,ax			; ES = DS = EMULATOR_DATA
	jmp	allocdone
else	
	jmp	allocds
endif	;thread1static

pub	allocerror
	mov	ax,-3			; return allocation error
	stc
	ret
;
ifdef	thread1static
; for threads other than thread 1, allocate new DS from the system
else
; for all threads, allocate new DS from the system
endif
;

pub	allocds
	assume	ds:DGROUP
	push	offset __fptaskdata	; size of per-thread data area
	push	ds			; ds:di = addr of thread's DS
	push	edi
	push	0			; non-shared segment
	os2call	DOSALLOCSEG	

	or	ax,ax			; allocation error?
	jnz	allocerror		;  yes - cause thread init to fail

	mov	di,ds:[edi]		; set ES = DS = thread's data selector 
	mov	ds,di			
	mov	es,di		
	assume 	ds:EMULATOR_DATA 	; or dynamically allocated copy

pub	allocdone
;
; ES = DS = selector for emulator data area
;
	mov	edx,offset __fptaskdata	; dx = size of emulator data area
	sub	edx,offset EMULATOR_DATA; jwm

	xor	ax,ax			; prepare to zero out data segment
	xor	edi,edi			; start at offset zero 
	mov	edi,offset EMULATOR_DATA; jwm : begin at the beginning

	mov	ecx,edx			; cx = size of segment (even)
	shr	ecx,1			; halve it
	rep	stosw			; zero it!
	endm

FREEthreadDS	macro
pub	freeperthread
	assume	ds:EMULATOR_DATA	; or dynamically allocated copy
ifdef	thread1static
 	mov	ax,ds
 	cmp	ax,EMULATOR_DATA	; don't free thread 1's area
 	je	nofreeseg
endif	;thread1static
 
	push	ds
	os2call	DOSFREESEG		; free per-thread emulator data area

nofreeseg:
	LOAD_DS_EDI			; get pointer into __FPDSARRAY
	mov	word ptr ds:[edi],0	; zero out __FPDSARRAY element
					; for the current thread
	assume 	ds:EMULATOR_DATA 	
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emulator.asm ===
page	,132
	title	emulator - 8087/287 emulator for MS-DOS, XENIX, OS/2, Windows
;*** 
;emulator.asm -  8087/287 emulator for MS-DOS, XENIX, OS/2, Windows
;
;	Copyright (c) 1984-89, Microsoft Corporation
;
;Purpose:
;	8087/287 emulator for MS-DOS, XENIX, OS/2, Windows
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

	include  emulator.hst	    ; Emulator history file.


major_ver   equ     6
minor_ver   equ     0

fastSP = 0			    ; default to no fast single precision


;*******************************************************************************
;
;   Print out emulator version.
;
;*******************************************************************************


OutMsg	macro	text
    ifndef  ?QUIET
	%out text
    endif
	endm


outver	macro	maj,tens,hunds
	OutMsg	<Emulator Version maj&.&tens&hunds>
	endm


if1

    outver  %major_ver,%(minor_ver/10),%(minor_ver mod 10)

    ifdef WINDOWS
	OutMsg	<Windows 2.00 Emulator>
    endif

    ifdef QB3
	OutMsg	<QuickBASIC 3.00 Emulator>
    endif

    ifdef _NOSTKEXCHLR				; formerly called QB4
	OutMsg	<No stack overflow/underflow hadler.>
    endif

    ifdef PCDOS
	OutMsg	<IBM PC-DOS version - Uses int 11h BIOS equipment check.>
    endif

    ifdef MTHREAD
	ifdef DOS5only
	    OutMsg  <Reentrant multithread OS/2 emulator.>
	else
	    %out  *** Error: MTHREAD supported only if DOS5only defined.
	endif
    endif

    ifdef  SQL_EMMT
	ifdef  MTHREAD
	    OutMsg  <Special SQL version.>
	else
	    %out  *** Error: SQL supported only if MTHREAD is defined.
	endif
    endif

    ifdef  _COM_
	OutMsg	<COM files supported.>
    endif ;_COM_

    ifdef XENIX
	OutMsg	<XENIX emulator.>
        PROTECT = 1             ; XENIX is always protect mode

    else    ;not XENIX
	ifdef DOS5only
	    OutMsg  <DOS 5 only emulator.>
	    DOS5 = 1
	    PROTECT = 1 	 ; DOS 5 is always protect mode

	else	;not DOS5only
	    DOS3=	1		; DOS 3 support is default
	    ifdef DOS5
		OutMsg	<DOS 3 & 5 emulator.>
		DOS3and5=	1
		PROTECT = 1	      ; DOS 5 is always protect mode

	    else    ;not DOS5
		OutMsg	<DOS 3 only emulator.>
	    endif   ;not DOS5

	endif	;not DOS5only

	ifdef standalone
	    OutMsg  <Stand-alone version (uses task vector for DS).>
	    ifdef   DOS5
		%out	*** Error: DOS 5 support not allowed.
		.error
	    endif   ;DOS5
	endif	;standalone

	ifdef frontend
	    OutMsg  <Front-end version - No hardware and limited instructions.>
	endif	;frontend

	ifdef SMALL_EMULATOR
	    OutMsg  <Small Emulator - Limited instructions.>
	endif	;SMALL_EMULATOR

	ifdef only87
	    OutMsg  <8087 only version - No emulation.>
	endif	;only87

	ifdef POLLING
	    OutMsg  <Exception handling uses polling FWAITs.>
	endif

    endif   ;not XENIX

    ifdef i386
	OutMsg	<386 version>
    endif

    if	  fastSP
	%out	Fast Single Precision version - Not supported.
    endif   ;fastSP

    ifdef DEBUG
	OutMsg	<+++  Debug Version  +++>
    endif   ;DEBUG

    ifdef  PROFILE
	OutMsg	<Profiling version.>
    endif   ;PROFILE

endif	;if1


;*******************************************************************************
;
;   Include cmacros.inc
;
;*******************************************************************************

?PLM = 1
?WIN = 0
?DF = 1

?NOGLOBAL = 1
?NOSTATIC = 1
?NOEXTERN = 1
?NODEF = 1
?NOPTR = 1

	include  cmac_mrt.inc		; old, customized masm510 cmacros
	include  mrt386.inc

ifdef  MTHREAD
	include os2supp.inc
endif


;*******************************************************************************
;
;   Include emulator macros.
;
;*******************************************************************************

	include  emulator.inc


;*******************************************************************************
;
;   Processor  setup.
;
;*******************************************************************************

ifdef  i386
	.386p
	.287

elseifdef  XENIX
	.286c		    ; allow 286 instructions if XENIX
	.287

elseifdef  DOS5only
	.286c		    ; allow 286 instructions if DOS 5 only
	.287

else	;Default
	.8086		    ; otherwise only 8086 instructions
	.8087		    ; make sure there are fwaits before all instruction
endif


;*******************************************************************************
;
;   Define segments.
;
;*******************************************************************************

ifdef  QB3

    createSeg EMULATOR_DATA, edata, para, public, CODE, <>
    createSeg EMULATOR_TEXT, ecode, para, public, CODE, <>

elseifdef QP

    createSeg DATA, edata, word, public,, <>
    createSeg CODE, ecode, word, public,, <>

else	;DEFAULT

    createSeg EMULATOR_DATA, edata, para, public, FAR_DATA, <>
    createSeg EMULATOR_TEXT, ecode, para, public, CODE, <>

endif	;DEFAULT



;*******************************************************************************
;
;   Define Number of stack elements, BEGINT and TSKINT
;
;*******************************************************************************


ifdef XENIX
    Numlev  equ     10			    ; 10 levels minimum for floating point

else	;not XENIX

    ifdef  QB3

	extrn	$EM_INT:far		    ; QB3 emulator error entry
	BEGINT	equ	084h		    ; MSDOS beginning interrupt
	Numlev	equ	10		    ; 10 levels minimum for floating point

    else    ;not QB3

	BEGINT	equ	034h		    ; MSDOS beginning interrupt

	ifdef _NOSTKEXCHLR
	    Numlev  equ     10		    ; 10 levels minimum for floating point

	elseifdef MTHREAD
	   Numlev equ	  16		    ; 16 levels minimum for floating-point

	else	;Default
	   Numlev  equ	  16		    ; 16 levels minimum for floating point
	endif	;Default

	ifdef	standalone
	  TSKINT  equ	  BEGINT + 10	    ; Task data pointer
	endif

	ifdef	WINDOWS
	  TSKINT  equ	  BEGINT + 10	    ; SignalAddress pointer
	endif

    endif   ;not QB3


    ifdef WINDOWS

	FIDRQQ	equ	(fINT + 256*(BEGINT + 0)) - (fFWAIT + 256*fESCAPE)
	FIERQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fES)
	FIWRQQ	equ	(fINT + 256*(BEGINT + 9)) - (iNOP + 256*fFWAIT)

	FIARQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fDS)
	FJARQQ	equ	256*(((0 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FISRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fSS)
	FJSRQQ	equ	256*(((1 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FICRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fCS)
	FJCRQQ	equ	256*(((2 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)

    elseifdef QP	; QuickPascal can't do absolutes

	FIDRQQ	equ	(fINT + 256*(BEGINT + 0)) - (fFWAIT + 256*fESCAPE)
	FIERQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fES)
	FIWRQQ	equ	(fINT + 256*(BEGINT + 9)) - (iNOP + 256*fFWAIT)

	FIARQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fDS)
	FJARQQ	equ	256*(((0 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FISRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fSS)
	FJSRQQ	equ	256*(((1 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FICRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fCS)
	FJCRQQ	equ	256*(((2 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)

    else    ;not WINDOWS or QuickPascal

	extrn	FIWRQQ:abs, FIERQQ:abs, FIDRQQ:abs
	extrn	FISRQQ:abs, FJSRQQ:abs
	extrn	FIARQQ:abs, FJARQQ:abs
	extrn	FICRQQ:abs, FJCRQQ:abs

    endif   ;not WINDOWS or QuickPascal

endif	;not XENIX


;*******************************************************************************
;
;   List external functions.
;
;*******************************************************************************


ifdef  WINDOWSP
    extrn   DOS3CALL:far
endif

ifdef  WINDOWS
    extrn   __WINFLAGS:abs
    extrn   ALLOCDSTOCSALIAS:far
    extrn   FREESELECTOR:far
ifdef WF
    extrn   ALLOCSELECTOR:far
;if we are linking to LIBW from Win 3.0, CS isn't found, use PCS
	CHANGESELECTOR equ <PRESTOCHANGOSELECTOR>
    extrn   CHANGESELECTOR:far
endif
endif


ifdef  DOS3and5
	os2extrn    DOSGETMACHINEMODE
endif	;DOS3and5

ifdef  DOS5

    ifndef  frontend
	ifndef	only87
	    os2extrn	DOSWRITE	    ; only needed to print out "NO87="
	endif	;only87

	os2extrn    DOSCREATECSALIAS
	os2extrn    DOSFREESEG
	os2extrn    DOSDEVCONFIG

    endif   ;not frontend

    os2extrn	DOSSETVEC

    ifdef  MTHREAD
	os2extrn    DOSALLOCSEG
	os2extrn    DOSEXIT
	extrn	    __FarGetTidTab:far
    endif   ;MTHREAD

endif	;DOS5


;*******************************************************************************
;
;   Include some more macros and constants.
;
;*******************************************************************************


	include emdoc.asm
	include emintern.asm

ifdef  MTHREAD
	include	emthread.asm
endif	;MTHREAD

subttl	emulator.asm - Emulator Task DATA Segment
page
;*********************************************************************;
;								      ;
;		  Emulator Task DATA Segment			      ;
;								      ;
;*********************************************************************;


sBegin	edata


; eventually this needs to be a big struct

glb	<REMLSW,InitControlWord,CURerr>
glb	<UserControlWord,UserStatusWord,Have8087>
glb	<ControlWord,CWcntl,StatusWord,SWcc>
glb	<BASstk,CURstk,LIMstk>

;*******************************************************************************
;
;   Order of information here must not change (for CodeView debugging).
;	Check with CodeView guys before changing.
;
;*******************************************************************************


ifndef	i386
glb	<SignalAddress>
nedd	SignalAddress,<1 dup (?)> ; Error signal address
endif

Have8087	db	0	; Is a real 8087 present (0 = no 8087)
Einstall	db	0	; Emulator installed flag (XENIX sets to 1)

UserControlWord dw	?	; User level control word
UserStatusWord	dw	?	; User level exception status word

ControlWord	label	word
  CWmask	db	?	; exception masks
  CWcntl	db	?	; arithmetic control flags

StatusWord	label	word
  SWerr 	db	?	; Initially no exceptions (sticky flags)
  SWcc		db	?	; Condition codes from various operations


ifdef	XENIX
    nedw    BASstk,<?>			    ; init to BEGstk + 8*Have8087*Reg87Len
					    ;	 = start of memory (+ 8 regs if 8087)
    nedw    CURstk,<?>			    ; init to BASstk = start of stack
    nedw    LIMstk,<?>			    ; ENDstk - 1 reg = end of memory

else	;not XENIX
    nedw    BASstk,<offset BEGstk>	    ; init to BEGstk + 8*Have8087*Reg87Len
					    ;	 = start of memory (+ 8 regs if 8087)
    nedw    CURstk,<?>			    ; init to BASstk = start of stack
    nedw    LIMstk,<offset ENDstk-(2*Reg87Len)> ; ENDstk - 1 reg = end of memory
endif	;not XENIX

;*******************************************************************************
;
;   End of fixed area
;
;*******************************************************************************


ifdef	DOS3and5
glb	<protmode>
protmode	dw	?		; Protect mode flag (0 = real)
endif	;DOS3and5

ifdef	POLLING 			; used by new POLLING exception code
ifdef	DOS3
glb	<errorcode>
errorcode	db	0		; error code
		db	0
endif	;DOS3
endif	;POLLING

ifdef	QB3
initCW		dw	?		; QB3 initial control word
endif

InitControlWord equ	1332H		; Default - Affine, Round near,
					;   64 bits, all exceptions unmasked

NewStatusWord	label	word		; space for status after reexecution
CURerr		dw	?		; initially 8087 exception flags clear
					; this is the internal flag reset after
					; each operation to detect per instruction
					; errors

ifndef	XENIX
glb	<env_seg>
env_seg 	dw	?		; environment segment
endif

REMLSW		dw	?		; sometimes used as a temp
		dw	?		;   (2 or 4 bytes)


ifndef	XENIX

  ifdef   DOS5only
  NUMVEC= 2				  ; coprocesser no present + exception
  else
  NUMVEC= 11				  ; 8 DS + 1 segovr + 1 fwait + 1 task
  endif   ;DOS5only

  glb	  <oldvec>
  oldvec  dd	  NUMVEC dup (0)	  ; old interrupt vector values

endif


;Transcendental working variables

glb	<Reg8087ST0,TEMP1>

Reg8087ST0	label	word
TEMP1		dw	Reg87Len/2 DUP (?)


ifndef	frontend
ifdef	DOS5
SSalias 	dw	?		; SSalias for exception handler
endif	;DOS5
endif	;frontend

ifdef	DOS3
ifndef	frontend
glb	<statwd>
statwd	dw	0			; Location for 8087 status/control word
endif	;frontend
endif	;DOS3

ifndef	only87
glb	<TEMP2,TEMP3,ARG2,DENORX,COEFFICIENT,RESULT,DAC>
TEMP2		dw	Reg87Len/2 DUP (?)
TEMP3		dw	Reg87Len/2 DUP (?)
ARG2		dw	Reg87Len/2 DUP (?)
DENORX		dw	Reg87Len/2 DUP (?)
COEFFICIENT	dw	Reg87Len/2 DUP (?)
nedw		RESULT,<?>
DAC		dw	MantissaByteCnt/2 DUP (?)
endif	;only87

ifndef	frontend
ifndef	SMALL_EMULATOR

    loopct	    dw	    0	    ; data for FPREM emulation
    bigquot	    dw	    0	    ; quotient > 65535 ?

endif	;not SMALL_EMULATOR
endif	;not frontend

ExtendStack	dw	1		; 1 => extend 80x87 stack


ifdef  WINDOWS

Installed	dw	0		; Installation flag

ExceptFlag	db	0		; 80x87 exception flag for polling.
		db	0

ifdef WF
wfInsn		dw	0		; instruction we overwrote with INT 3d
wfSel		dw	0		; selector to use for alias
wfErr		dw	0		; FP error code (YAEC)
wfGoFast	dw	0		; 1 if we are Enhanced with coproc
endif

public OldNMIVec
OldNMIVec	dd	0		; Old value in 8087 exception interrupt vector

endif	;WINDOWS

ifdef  LOOK_AHEAD
NextOpCode	db	0		; first byte of next instruction
LookAheadRoutine dw	0
endif



; Emulator stack area

glb	<BEGstk,ENDstk>

BEGstk		db	Numlev*Reg87Len dup (?)     ; emulator stack area
ENDstk		label	byte

ifdef	MTHREAD
cvtbufsize= 349				; see \clib\include\cvt.h
cvtbuf		db	cvtbufsize	dup (?)	    ; used by ecvt/fcvt	
						    ; routines
endif	;MTHREAD

	public	__fptaskdata

__fptaskdata	label	byte		; task data pointer and size
					; (if linked with user program)

sEnd  edata



subttl	emulator.asm
page
;*********************************************************************;
;								      ;
;		Start of Code Segment				      ;
;								      ;
;*********************************************************************;


sBegin	ecode

assumes cs, ecode
assumes ds, edata

	public	__fpemulatorbegin
__fpemulatorbegin:			    ; emulator really starts here


reservedspace:		; IMPORTANT: Must be EMULATOR_TEXT:0000

	EMver		; IMPORTANT: Emulator version number
			; IMPORTANT: EBASIC needs this here!


	db	'gfw...GW'

ifdef  _COM_
extrn	__EmDataSeg:word
endif	;_COM_

page


ifdef	XENIX
	include emxenix.asm		; XENIX initialization

elseifdef WINDOWS
	include emwin.asm		; WINDOWS initialization

else	;not XENIX or WINDOWS
	include emdos.asm		; DOS initialization
endif	;not XENIX or WINDOWS

	include emstack.asm		; stack management macros

ifndef  QB3                             ; no exception handling for QB3
ifndef  XENIX                           ; UNDONE - no exception handling for XENIX
ifndef	frontend
	include emexcept.asm		; oem independent 8087 exception handling
endif	;frontend
endif   ;XENIX                          ; UNDONE -   at this time
endif   ;QB3

	include emerror.asm		; error handler

ifndef	XENIX				; not used with XENIX

	include emspec.asm		; special emulator/8087 functions

ifndef	frontend
	include emfixfly.asm		; fixup on the fly
endif	;not frontend

endif	;not XENIX

ifndef	only87

	public	__fpemulator
__fpemulator:				; emulator starts here

	include emdisp.asm		; dispatch tables
	include emconst.asm		; constants

ifdef	i386
	include em386.asm		; 386 emulation/initialization entry
else
	include emmain.asm		; main entry and address calculation
endif
	include emdecode.asm		; instruction decoder

	include emarith.asm		; arithmetic dispatcher
	include emfadd.asm		; add and subtract
	include emfmul.asm		; multiply
	include emfdiv.asm		; division
	include emnormal.asm		; normalize and round
	include emlssng.asm		; load and store single
	include emlsdbl.asm		; load and store double
	include emlsint.asm		; load and store integer
	include	emlsquad.asm		; load and store quadword integer
	include emfrndi.asm		; round to integer
	include emlstmp.asm		; load and store temp real
	include emfmisc.asm		; miscellaneous instructions
	include emfcom.asm		; compare
	include emfconst.asm		; constant loading
	include emnew.asm		; new instructions: f<op> ST(i)

ifndef	frontend
ifndef	SMALL_EMULATOR

	include emfprem.asm		; partial remainder
	include emfsqrt.asm		; square root
	include emftran.asm		; transcendentals

endif	;not SMALL_EMULATOR
endif	;not frontend


endif	;not only87

	public	__fpemulatorend
__fpemulatorend:			  ; emulator ends here

sEnd  ecode


ifdef WINDOWS
    EM_END  equ   <end	 LoadTimeInit>

else
    EM_END  equ   <end>
endif


EM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emwin.asm ===
page	,132
	subttl	emwin.asm - Initialization and Termination for Windows
;***
;emwin.asm - Initialization and Termination for Windows
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Initialization and Termination for Windows
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


comment !

Windows/DOS interfaces to emulator/8087 functions

Certain emulator/8087 functions are performed by calling __fpmath
with an function code and arguments.

__fpmath	general floating point	math  package  interface  used
		by the emulator/8087 and float calls interfaces.  This
		is a far routine and must be far called.

entry:

  bx = 0	initialize floating point math (program startup)
		dx, ax, si input values ignored in WINDOWS emulator
		returns:
		  ax = 0 if successful and using software floating point
		       1 if successful and using 8087
		  just terminates process if error

  bx = 1	reset (FINIT) - finit ok even under WINDOWS;
		typical usage will load control word afterward
		so other tasks won't be hindered (as with _fpreset() call)

  bx = 2	terminate floating point math (program termination)

  bx = 3	set error signal address
		dx:ax = segment:offset of user error handler

  bx = 4	load user control word
		(user should not use FLDCW instruction directly)
		ax = user control word value

  bx = 5	store user control word
		returns:
		  ax = user control word value

  bx = 6	truncate TOS to integer TOS
		ax = user control word (only use round mode)

  bx = 7	truncate TOS to 32-bit integer in DX:AX
		ax = user control word (only use round mode)

  bx = 8	store user status word
		returns:
		  ax = user status word value

  bx = 9	clear exceptions

  bx = 10	return number of stack elements in ax

  bx = 11	returns 1 if using 80x87, 0 if not

  bx = 12	if ax = 0, turn off extended stack. if ax = 1, turn on e.s.

! 


glb	<functab>

functab label	word

	dw	initialization		; 0 - initialize emulator/8087
	dw	reset			; 1 - reset emulator/8087 stack
	dw	termination		; 2 - terminate emulator/8087
	dw	setsignal		; 3 - set error signal address
	dw	loadcontrolword 	; 4 - load user control word
	dw	storecontrolword	; 5 - store user control word
	dw	truncateTOS		; 6 - truncate TOS to integer TOS
	dw	truncateTOSto32int	; 7 - truncate TOS to integer in DX:AX
	dw	storestatusword 	; 8 - store user status word
	dw	clearexceptions 	; 9 - clear execeptions
	dw	NumStack		; 10 - report number of elements in stack
	dw	ReturnHave8087		; 11 - report if using coprocessor
	dw	SetExtendedStack	; 12 - turn on or off extended stack
endfunc label	word

SizeJmpTab  equ    12

sEnd  ecode


sBegin	ecode

assumes cs, ecode
assumes ds, edata



public	__fpmath

__fpmath  proc	far

	cmp	bx, SizeJmpTab
	ja	RetFPErr

	shl	bx, 1
	push	ds			; save DS

	mov	cx, EMULATOR_DATA
	mov	ds, cx

	call	functab[bx]

	pop	ds			; restore DS

EmuRet:
	ret


RetFPErr:
	or	ax, -1
	cwd
	jmp	EmuRet

__fpmath  endp




subttl	emwin.asm - Initialization and Termination
page
;*********************************************************************;
;								      ;
;		      Initialization and Termination		      ;
;								      ;
;*********************************************************************;

wastetime macro
	push	cx
	mov	cx,20			;; wait for a short time
	loop	$
	pop	cx
endm



;	program initialization
;
;	entry	dx:ax = task data area (segment and size) for standalone
;		si = DOS environment segment for NO87 lookup ???
;	DX,AX,SI - ignored in WINDOWS case
;	these register inputs are ignored for Windows app
;		program-time initialization

pub  initialization			; all initialization is done when loaded

ifdef WF
	cmp	[Installed],0
	jnz	@F
	.286p
	push	0
	call	AllocSelector
	mov	[wfSel], ax		; Error checking??
	mov	ax, __WINFLAGS
;	int 3
	test	ax, WF_WIN386
	jz	wfSlow1
	cmp	[Have8087], 0
	je	wfSlow1
	or	[wfGoFast], 1		; We can use fast if Enh Mode & FPU
wfSlow1:
@@:
endif
	inc	[Installed]		; Installed will count number of apps
					; using the emulator.

	cmp	[Have8087], 0		; check for 8087/80287
	je	NoInstall87

	extrn	__FPINSTALL87:near
	call	__FPINSTALL87		; set NMI (int 2) for this instance
NoInstall87:

	call	reset
	xor	ax, ax

	ret




ifdef	standalone
	mov	di,offset BEGstk	; di = base of register stack
	mov	[BASstk],di		; initialize stack base
	mov	cx,Reg87Len		; cx = register length
	xchg	ax,dx			; ax = task data segment size
	sub	ax,di			; ax = number bytes for stack
	cwd				; dx:ax = number of bytes
	div	cx			; ax = number of entries
	mul	cx			; ax = number of bytes
	add	ax,di			; ax = top of stack
	sub	ax,cx			; Leave room for one on overflow
	mov	[LIMstk],ax		; set top of stack
endif	;standalone



; check if floating point emulator/8087 already installed (device driver)



    ; load time initialization

pub  LoadTimeInit

	push	di
	push	si
	push	ds
	mov	ax,EMULATOR_DATA
	mov	ds,ax

	mov	ax, __WINFLAGS
	and	ax, WF_80x87
	cmp	ax, WF_80x87
	jz	WinHave87

ifdef only87
	jmp	loadiniterrorret
endif
	jmp	WinSet87

pub WinHave87
	mov	al,1

pub WinSet87
	mov	[Have8087],al

    ; real mode emulation and fixup on the fly vector setup

pub  initvec
	call	SaveVectors
	call	SetVectors


pub  loadinitfinish


    ; finish initialization

pub  initfinish

	mov	[Installed], 0		; Installed will count number of apps

	call	reset			; reset (0), FINIT if 8087 present and
					; set up default control word

	mov	ax, 1			; return non zero result

pub  loadiniterrorret

	pop	ds
	pop	si
	pop	di
	retf				 ; far return for dynalink lib entry pt.


;*
;*  DLL termination routine.
;*

public	WEP
WEP  label  far

	push	ds
	push	ax

	push	si
	push	di

	mov	ax,EMULATOR_DATA
	mov	ds,ax

	call	reset
	call	RestoreVectors

	pop	di
	pop	si
	pop	ax
	pop	ds

	retf	2	    ; WEP functions are called with a word paramater.


;------ program termination ----------------------------------------------------

pub termination

	call	reset			; reset chip for other apps

	dec	[Installed]		; if Installed is not 0, someone is
	jnz	termrealdone		; still using the emulator.

ifdef WF
	xor	ax, ax
	xchg	ax, [wfSel]
	or	ax, ax
	jz	@F
	push	ax
	call	FreeSelector
@@:
endif

ifndef	only87
	cmp	[Have8087],0		; Non zero if 8087 chip exists
	je	termrealdone
endif	;only87

	extrn	__FPTERMINATE87:near   ; reset NMI (int 2) for this instance
	call	__FPTERMINATE87

pub termrealdone
	ret




subttl	emwin.asm - reset and clearexceptions
page
;*********************************************************************;
;								      ;
;		     Reset and Clearexceptions			      ;
;								      ;
;*********************************************************************;

pub reset

ifndef	only87
	cmp    [Have8087],0		; Nonzero if 8087 chip exists
	je     NoFINIT
endif	;only87
	fninit
	fwait				; Workaround for 80387 bug.
	fninit

pub NoFINIT
	mov	ax, [BASstk]
	mov	[CURstk], ax		; reset stack to bottom

	mov	ax, InitControlWord	; setup initial control word
	call	loadcontrolword


    ; fall into clearexceptions


pub  clearexceptions

	xor	ax, ax
ifndef	only87
	cmp	al, [Have8087]		; Nonzero if 8087 chip exists
	je	NoFCLEX
endif	;only87
	fclex				; clear exceptions

pub NoFCLEX
ifndef	only87
	mov	[StatusWord], ax	; clear status word
endif	;only87
	mov	[UserStatusWord], ax	; clear exception status word

	ret



subttl	emwin.asm - setsignal ---------------------------------
page
;*********************************************************************;
;								      ;
;		     Setsignal					      ;
;								      ;
;*********************************************************************;


pub  setsignal

	push	ds

	mov	ds, dx			; set TSKINT to SignalAddress
	mov	dx, ax
	mov	ax, 25h*256 + TSKINT
	IntDOS

	pop	ds
	ret


pub  SaveVectors

	mov	cx, NUMVEC		; save old vectors under DOS 3
	mov	ax, 35h*256 + BEGINT	; get vector
	mov	di, offset oldvec	; di = old vector table

pub getvecs
	IntDOS
	inc	ax
	mov	[di], bx		; save old vector
	mov	[di+2], es
	add	di, 4
	loop	getvecs

	ret

pub  SetVectors

ifndef	only87
	mov	dx, offset DStrap	; assume emulator
	mov	si, offset SOtrap
	mov	di, offset FWtrap
ifdef  WINDOWS
	mov	ax, __WINFLAGS		  ; if we are in PMODE & win386 increment all of
	and	ax, WF_PMODE or WF_WIN386 ; the handler address past the "sti".
	cmp	ax, WF_PMODE or WF_WIN386
	jne	NotPmode1

	inc	dx
	inc	si
	inc	di
lab NotPmode1
endif	;WINDOWS

	cmp	[Have8087], 0		; are we using 8087 ?
	jz	SetEmVecs		;    no - go ahead and set them
endif	;only87

	mov	dx, offset DSFixUpOnFly ; set up for fixup-on-the-fly
	mov	si, offset SOFixUpOnFly
	mov	di, offset FWFixUpOnFly
ifdef  WINDOWS
	mov	ax, __WINFLAGS		  ; if we are in PMODE & win386 increment all of
	and	ax, WF_PMODE or WF_WIN386 ; the handler address past the "sti".
	cmp	ax, WF_PMODE or WF_WIN386
	jne	NotPmode2

	inc	dx
	inc	si
	inc	di
lab NotPmode2
endif	;WINDOWS

pub  SetEmVecs
	push	ds

	push	cs
	pop	ds
	mov	ax, 25h*256 + BEGINT
	mov	cx, 8			; 8 vectors for DStrap

pub  SetDSLoop
	IntDOS				; set vector
	inc	ax			; bump to next one
	loop	SetDSLoop

	mov	dx, si			; set Segtrap
	IntDOS
	inc	ax
	mov	dx, di			; set FWtrap
	IntDOS

	pop	ds			; restore task data area

	ret


pub  RestoreVectors

	mov	cx, NUMVEC
	mov	ax, 25h*256 + BEGINT	; Dos set vector.
	mov	di, offset oldvec	; di = old vector table

pub  ResetVecLoop
	push	ds
	lds	dx, [di]		; get old vector value
	IntDOS
	pop	ds
	inc	ax
	add	di,4

	loop	ResetVecLoop

	ret



pub  NumStack			; returns the number of stack elements in ax

	xor	dx, dx		; dx will count nonzero elements

ifndef	only87
	cmp	Have8087, 0
	je	CountEmulatorStack
endif	;only87

	sub	sp, 14		; need 14 bytes for fstenv
	mov	bx, sp
	fstenv	ss:[bx]
	fldcw	ss:[bx] 	; reset control word
	mov	ax, ss:[bx+4]	; put tag word in ax
	add	sp, 14		; reset stack

	mov	cx, 8
pub NotEmptyLoop
	mov	bx, ax

	shr	ax, 1
	shr	ax, 1

	and	bx, 3
	cmp	bx, 3
	je	StackEntryEmpty

	inc	dx		; stack element was not empty
pub StackEntryEmpty
	loop	NotEmptyLoop


pub CountEmulatorStack

	mov	ax, CURstk
	sub	ax, BASstk

	mov	bl, Reg87Len

	div	bl

	add	ax, dx		; add elements on 80x87 stack

	ret


ReturnHave8087 proc near

	mov	al, [Have8087]
	cbw

	ret
ReturnHave8087 endp


SetExtendedStack proc near

	mov	[ExtendStack], ax

	ret
SetExtendedStack endp



;***
;int far pascal __Win87EmInfo( WinInfoStruct far * p, int cb );
;
;Purpose:
;   returns information about win87em.exe to CodeView
;
;Entry:
;   WinInfoStruct far * p
;   int cb  - size of WinInfoStruct
;
;Exit:
;   returns non zero if error.
;
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	__WIN87EMINFO,<PUBLIC,FAR,PLM>,<ds>

	parmD	p
	parmW	cb

cBegin
	or	ax, -1
	cmp	[cb], size WinInfoStruct
	jb	WIDone

	mov	ax, edataBASE
	mov	es, ax
	assumes es, edata

	lds	bx, [p]
	assumes ds, nothing

	mov	[bx.WI_Version], (major_ver shl 8) +  minor_ver
	mov	[bx.WI_SizeSaveArea], Size80x87Area + edataOFFSET __fptaskdata
	mov	[bx.WI_WinDataSeg], es
	mov	[bx.WI_WinCodeSeg], cs

	mov	al, [Have8087]
	cbw
	mov	[bx.WI_Have80x87], ax
	assumes es, nothing

	xor	ax, ax			    ; return 0 if no error
	mov	[bx.WI_Unused], ax
WIDone:
cEnd


;***
;int far pascal __Win87EmSave( void far * p, int cb );
;
;Purpose:
;   saves win87em.exe info in p
;
;Entry:
;   void far * p    - pointer to save area.
;   int cb	    - size of save area.
;
;Exit:
;   returns non zero if error.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	__WIN87EMSAVE,<PUBLIC,FAR,PLM>,<ds,si,di>

	parmD	p
	parmW	cb

cBegin
	or	ax, -1
	cmp	[cb], Size80x87Area + edataOFFSET __fptaskdata
	jb	WSDone

	mov	ax, edataBASE
	mov	ds, ax
assumes  ds, edata

	les	di, [p]
assumes  es, nothing

	cmp	[Have8087], 0
	je	NoSave80x87

	fsave	es:[di.WSA_Save80x87]
NoSave80x87:

	add	di, (WSA_SaveEm - WSA_Save80x87)
	xor	si, si
	mov	cx, edataOFFSET __fptaskdata
	shr	cx, 1

	rep movsw

	jnc	NoSaveLastByte
	movsb
NoSaveLastByte:

	xor	ax, ax		; return 0 if no error.

WSDone:
cEnd



;***
;int far pascal __Win87EmRestore( void far * p, int cb );
;
;Purpose:
;   retores win87em.exe info from p
;
;Entry:
;   void far * p    - pointer to save area.
;   int cb	    - size of save area.
;
;Exit:
;   returns non zero if error.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	__WIN87EMRESTORE,<PUBLIC,FAR,PLM>,<ds,si,di>

	parmD	p
	parmW	cb

cBegin
	or	ax, -1
	cmp	[cb], Size80x87Area + edataOFFSET __fptaskdata
	jb	WRDone

	mov	ax, edataBASE
	mov	es, ax
assumes  es, edata

	lds	si, [p]
assumes  ds, nothing

	add	si, (WSA_SaveEm - WSA_Save80x87)
	xor	di, di
	mov	cx, edataOFFSET __fptaskdata
	shr	cx, 1

	rep movsw

	jnc	NoRestoreLastByte
	movsb
NoRestoreLastByte:

	mov	si, [OFF_p]	    ; reset source pointer.

	cmp	[Have8087], 0
	je	NoRestore80x87

	frstor	[si.WSA_Save80x87]
NoRestore80x87:

	xor	ax, ax		; return 0 if no error.

WRDone:
cEnd

assumes ds, edata
assumes es, nothing
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emulator.inc ===
subttl	emulator.inc - Emulator macros.
;*** 
;emulator.inc - Emulator history.
;
;	Copyright (c) 1989-89, Microsoft Corporation
;
;Purpose:
;	Defines macros for emulator.
;
;Revision History
;
;   See emulator.hst
;
;*******************************************************************************



;*******************************************************************************
;
;   EMver  - defines version tag put in code segment.
;
;*******************************************************************************


EMver	macro
	db	'MSEM87',major_ver,minor_ver
	endm


;*******************************************************************************
;
;   Define pub and glb macros to make labels public for debugging.
;
;*******************************************************************************


ifdef  DEBUG

    lab     macro   name
    public  name
    name:
	    endm

    pub     macro   name
    public  name
    name:
	    endm

    glb     macro   name
	    irp     nm,<name>
	    public  nm
	    endm
	    endm

elseifdef  WINDOWS		; If windows, make these public for the map file.

    lab     macro   name
    public  name
    name:
	    endm

    pub     macro   name
    public  name
    name:
	    endm

    glb     macro   name
	    irp     nm,<name>
	    public  nm
	    endm
	    endm

else	;DEFAULT
    lab     macro   name
    name:
	    endm

    pub     macro   name
    name:
	    endm

    glb     macro   name
	    endm

endif	;DEFAULT



;*******************************************************************************
;
;   Macros and register aliases to keep the 386/8086 versions close.
;
;*******************************************************************************

ifdef	i386

eWORD	macro	nam				; 386 macros
nam	label	dword
	endm

nedw	macro	nam,contents
nam	dd	contents
	endm

nedd	macro	nam,contents
nam	df	contents
	endm

edw	macro	contents
	dd	contents
	endm

edd	macro	contents
	df	contents
	endm


else	; not i386

eWORD	macro	nam				; 286 macros
nam	label	word
	endm

nedw	macro	nam,contents
nam	dw	contents
	endm

nedd	macro	nam,contents
nam	dd	contents
	endm

edw	macro	contents
	dw	contents
	endm

edd	macro	contents
	dd	contents
	endm

eax	equ	ax
ecx	equ	cx
edx	equ	dx
ebx	equ	bx
esp	equ	sp
ebp	equ	bp
esi	equ	si
edi	equ	di

iretd   equ     iret

endif	;not i386


;*******************************************************************************
;
;   Processor opcode byte definitions.
;
;*******************************************************************************

fINT	equ	0cdh
fFWAIT	equ	9bh
fESCAPE equ	0d8h

iNOP	equ	90h	    ; byte nop

fES	equ	26h	    ; segment prefix opcodes
fCS	equ	2eh
fSS	equ	36h
fDS	equ	3eh

bIRET	equ	0cfh	    ; "iret"

bRETF	equ	0cah	    ; first byte of "retf 2".  Followed by word operand.
wNOP	equ	0c08bh	    ; word nop.  "mov  ax, ax"

bEscMask equ	0f8h	    ; masks all bits but escape
bMOD	equ	0c0h	    ; MOD bits are the two highest bits
bRM	equ	7h	    ; R/M bits are the three lowest bits.


;*******************************************************************************
;
;   Define os2extrn and os2call for dual mode emulators
;
;*******************************************************************************


ifdef	DOS3and5

    os2call macro name
	    call    __&name
	    endm

    os2extrn macro name
	    extrn   __&name : far
	    endm

endif	;DOS3and5

ifdef	DOS5only

    os2call macro name
	    call    name
	    endm

    os2extrn macro name
	    extrn   name : far
	    endm

endif	;DOS5only


;*******************************************************************************
;
;   Define ProfBegin ProfEnd macros for when profiling emulator.
;
;*******************************************************************************

ProfBegin  macro   name

ifdef  PROFILE
	nop

public EM_&name&_BEGIN
EM_&name&_BEGIN  label	far
endif
	endm


ProfEnd macro	name

ifdef  PROFILE
public EM_&name&_END
EM_&name&_END  label  far

	nop
endif
	endm


;*******************************************************************************
;
;   Define IntDOS macro for handling "int 21h" and "call DOS3CALL".
;
;*******************************************************************************


IntDOS	macro

ifdef  WINDOWSP
	call	DOS3CALL
else
	int	21h
endif
	endm


;*******************************************************************************
;
;   Define constants for DOS int 21h
;
;*******************************************************************************


DOS_getvector	equ	35H



INT_GetEquipList equ	 11h		 ; PC BIOS equipment list call.
GEL_80x87	 equ	  2h		 ; Mask for Coprocessor sense switch.


;*******************************************************************************
;
;   Define structures for __WinInfo(), __WinSave(), and __WinRestore().
;
;*******************************************************************************

WinInfoStruct	struc

    WI_Version	    dw	    ?	    ; High byte is major version.
    WI_SizeSaveArea dw	    ?	    ; Size of save area.
    WI_WinDataSeg   dw	    ?
    WI_WinCodeSeg   dw	    ?
    WI_Have80x87    dw	    ?
    WI_Unused	    dw	    ?	    ; Coprocessor type will go here.

WinInfoStruct	ends


Size80x87Area	equ	94


WinSaveArea struc

    WSA_Save80x87   db	    Size80x87Area dup(?)   ; Where 80x87 info will go.
    WSA_SaveEm	    db	    ?			   ; Where emulator data will go.

WinSaveArea ends



;*******************************************************************************
;
;   Define constants for checking "extrn __WINFLAGS:asb"
;
;*******************************************************************************


WF_PMODE    equ     1
WF_CPU286   equ     2
WF_CPU386   equ     4
WF_WIN286   equ     10h
WF_WIN386   equ     20h
WF_80x87    equ     400h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\emxenix.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emxenix.asm - XENIX function jump tables and Initialization
page


	public	__eminit, __emulate, __87exception


	org	10h

__eminit:                               ; UNDONE - not used any more


	org	15h

__emulate:
	jmp	protemulation		; protect mode emulation


	org	1Ah

__87exception:
        pop     eax                     ; eax = error code
        int     0FFh

page
;------------------------------------------------------------------------------
;
;	install emulator (initial all data elements
;
;	This routine is executed once for the 1st emulated instruction
;
;------------------------------------------------------------------------------


pub	installemulator

	mov	[Einstall],1		; mark emulator as initialized

	mov	eax,offset BEGstk	; pointer to beginning of stack
	mov	[BASstk],eax		; set base of stack
	mov	[CURstk],eax		; set current stack element
	mov	eax,offset ENDstk-Reg87Len
	mov	[LIMstk],eax		; set end of stack

        mov     ax,InitControlWord
	mov	[UserControlWord],ax	; initialize control words
	mov	[ControlWord],ax

	xor	eax,eax
	mov	[UserStatusWord],ax	; initialize status words
	mov	[StatusWord],ax

	jmp	protemcont		; continue emulating 1st instruction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\wfpsig.asm ===
page	,132
	title	wfpinit  - Functions for initializing win87em.exe from a DLL
;*** 
;wfoinit.asm - Functions for initializing win87em.exe from a DLL
;
;	Copyright (c) 1988-89, Microsoft Corporation
;
;Purpose:
;	Functions for initializing win87em.exe from a DLL
;
;Revision History:
;   04/06/89  WAJ   Added this header.
;   04/06/89  WAJ   Cleaned up source, Save more registers in __fpsignal
;
;*******************************************************************************


	memL = 1

	?PLM = 1	; Pascal naming
	?WIN = 1	; Windows calling convention

.xlist
	include  cmac_mrt.inc		; old, customized masm510 cmacros
.list


externFP POSTQUITMESSAGE


sBegin	code

assumes cs,code
assumes ds,data

;
; Windows floating-point emulator error routine
; (replaces CFPSIG.ASM in regular C math runtime)
;
; The behavior is to die with error code.
; (Calling POSTQUITMESSAGE doesn't cause immediate termination of
; the Windows "task", but sends a WM_QUIT message
; to the application queue of the current Windows app.)
;

cProc	__fpsignal,<PUBLIC,FAR>,<es,bx,cx,dx>

cBegin
	sub	ah, ah

	push	ax
	call	POSTQUITMESSAGE
cEnd

sEnd	code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\wfpinit.asm ===
page	,132
	title	 wfpinit - Functions for initializing win87em.exe from a DLL
;***
;wfpinit.asm - Functions for initializing win87em.exe from a DLL
;
;	Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	Defines the initialization and termination routines for the Windows
;	emulator (used in DLLs).
;
;Revision History:
;   04/14/88  WAJ   Initial version.
;   04/06/89  WAJ   Cleaned up source.
;   04/12/90  WAJ   Will now work in protected mode.
;
;*******************************************************************************


memL = 1
?PLM = 1	    ; Pascal names.
?WIN = 1	    ; Windows calling sequence

.xlist
	include  cmac_mrt.inc		; old, customized masm510 cmacros
.list

TSKINT	    equ     3eh 		; int 3e is used for the Signal handler
OPSYS	    equ     21h
SETVECOP    equ     25h
GETVECOP    equ     35h


externFP  __fpmath
externFP  __fpsignal

sBegin	data
DefaultFPSignal  dd  __fpsignal 	; want to a thunk for this function
sEnd	data

sBegin	code

assumes cs, code
assumes ds, data


;***
; _FPInit -
;
;Purpose: Initializes the Windows emulator.
;
;Entry:
;
;Exit:	returns the old signal handler
;
;Uses:
;
;Exceptions: none
;
;*******************************************************************************

cProc	_FPINIT,<PUBLIC,FAR>,<>

cBegin
	xor	bx, bx			; initialize Emulator/Coprocessor
	call	__fpmath


	push	ds
	mov	ax,GETVECOP shl 8 + TSKINT  ; get interrupt vector TSKINT
	int	OPSYS			    ; Call operating system.
	pop	ds

	push	es			; save previous FP signal handler on
	push	bx			; stack

	mov	ax, word ptr [DefaultFPSignal]
	mov	dx, word ptr [DefaultFPSignal+2]

	mov	bx, 3			; 3 => set SignalAddress
	call	__fpmath

	pop	ax			; get previous FP signal handler off
	pop	dx			; stack
cEnd



;***
; _FPTerm -
;
;Purpose: terminates Windows emulator
;
;Entry: old floating point signal handler
;
;Exit: none
;
;Uses:
;
;Exceptions: none
;
;*******************************************************************************

cProc	_FPTERM,<PUBLIC,FAR>,<>

	parmD  DefaultSignalHandler

cBegin
	mov	ax, [OFF_DefaultSignalHandler]
	mov	dx, [SEG_DefaultSignalHandler]

	mov	bx, 3			; 3 => set SignalAddress
	call	__fpmath

	mov	bx, 2			; 2 => terminate FP
	call	__fpmath
cEnd

sEnd  code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winoldap\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winsock\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winoldap\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winsock\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winspool\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\win87em\win87em.h ===
/***
*win87em.h - definitions/declarations for win87em.exe exports.
*
*   Copyright (c) 1989-1989, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   exported from win87em.exe
*
*Revision History:
*
*   06-26-89  WAJ   Initial version.
*
****/


typedef  struct _Win87EmInfoStruct {
			    unsigned	 Version;
			    unsigned	 SizeSaveArea;
			    unsigned	 WinDataSeg;
			    unsigned	 WinCodeSeg;
			    unsigned	 Have80x87;
			    unsigned	 Unused;
			    } Win87EmInfoStruct;

#define SIZE_80X87_AREA     94

/*
 * The Win87EmSaveArea loks like this:
 *
 * typedef  struct _Win87EmSaveArea {
 *			       unsigned char  Save80x87Area[SIZE_80X87_AREA];
 *			       unsigned char  SaveEmArea[];
 *			       } Win87EmSaveArea;
 */


int far pascal __Win87EmInfo( Win87EmInfoStruct far * pWIS, int cbWin87EmInfoStruct );
int far pascal __Win87EmSave( void far * pWin87EmSaveArea, int cbWin87EmSaveArea );
int far pascal __Win87EmRestore( void far * pWin87EmSaveArea, int cbWin87EmSaveArea );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winspool\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wowdeb\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wowdeb\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\winnls.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINNLS.ASM
;   Win16 WINNLS thunks
;
;   History:
;
;   Created 3-Feb-1992 by Junichi Okubo (junichio)
;--

	TITLE	WINNLS.ASM
	PAGE	,132

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
	;
	; NOTICE THIS junichio memo: This is on the developement.
	;			    I cannot figure out it need or not?
        ;LIBINIT equ 1

	FIRST_CALL_MUST_BE_USER_BUG equ 1

	ifdef	FIRST_CALL_MUST_BE_USER_BUG
	;LIBINIT equ 1
	endif

	.286p

	.xlist
	include wow.inc
	include wownls.inc
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.

ifdef LIBINIT
externFP LocalInit
endif
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA


sBegin	DATA
Reserved    db	16 dup (0)	;reserved for Windows

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

ifdef LIBINIT
;externFP LibMain
endif

cProc	WINNLS16,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>

	cBegin <nogen>
	IFDEF	LIBINIT
        ; push params and call user initialisation code

	push di 		;hModule

        ; if we have a local heap declared then initialize it

        jcxz no_heap

	push 0			;segment
	push 0			;start
	push cx 		;length
        call LocalInit

no_heap:
;	call LibMain		;return exit code from LibMain
	ELSE
	mov  ax,1		;are we dressed for success or WHAT?!
	ENDIF
	ret
	cEnd <nogen>


cProc	WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
	parmW	iExit		;DLL exit code

	cBegin
	mov	ax,1		;always indicate success
	cEnd

;	WINNLSThunk   INQUIREWINNLS
cProc InquireWINNLS,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
	mov	ax,0		; WOW does not support
cEnd InquireWINNLS

;	WINNLSTHunk   HOOKKEYBOARDMESSAGE
cProc HookKeyboardMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW nCode
parmW VKey
parmD lParam
cBegin
	mov	ax,0		; WOW does not support
cEnd HookKeyboardMessage

	WINNLSThunk   SENDIMEMESSAGE
	WINNLSThunk   SENDIMEMESSAGEEX

;	WINNLSThunk   WINNLSSETKEYBOARDHOOK
cProc WINNLSSetKeyboardHook,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW fHookNew
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetKeyboardHook

;	WINNLSThunk   WINNLSSETIMEHANDLE
cProc WINNLSSetIMEHandle,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpszName
parmW hWnd
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetIMEHandle

;	WINNLSThunk   WINNLSSETIMESTATUS
cProc WINNLSSetIMEStatus,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW fStatus
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetIMEStatus

;	WINNLSThunk   WINNLSSETIMEHOTKEY
cProc WINNLSSetIMEHotkey,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW key
ifdef KOREA
parmW unknown
endif
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetIMEHotkey

	WINNLSThunk   WINNLSGETIMEHOTKEY
	WINNLSThunk   WINNLSENABLEIME	

;	WINNLSThunk   WINNLSGETKEYSTATE
cProc WINNLSGetKeyState,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSGetKeyState

	WINNLSThunk   WINNLSGETENABLESTATUS

;	WINNLSThunk   WINNLSSETKEYSTATE
cProc WINNLSSetKeyState,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW uVKey
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetKeyState

;	WINNLSThunk   IMPADDIME
cProc IMPAddIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpCIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPAddIME

;	WINNLSThunk   IMPDELETEIME
cProc IMPDeleteIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpCIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPDeleteIME

	WINNLSThunk   IMPQUERYIME
	WINNLSThunk   IMPGETIME
	WINNLSThunk   IMPSETIME

;	WINNLSThunk   IMPMODIFYIME
cProc IMPModifyIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpszFile
parmD lpCIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPModifyIME

;	WINNLSThunk   IMPGETDEFAULTIME
cProc IMPGetDefaultIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpNIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPGetDefaultIME

;	WINNLSThunk   IMPSETDEFAULTIME
cProc IMPSetDefaultIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpNIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPSetDefaultIME

;	WINNLSThunk   WINNLSSENDSTRING
cProc WINNLSSendString,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW wFunc
parmD lpData
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSendString

;	WINNLSThunk   WINNLSPOSTAPPMESSAGE
cProc WINNLSPostAppMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW uMsg
parmW wParam
parmD lParam
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSPostAppMessage

;	WINNLSThunk   WINNLSSENDAPPMESSAGE
cProc WINNLSSendAppMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW uMsg
parmW wParam
parmD lParam
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSendAppMessage

ifdef TAIWAN_PRC 
;dchiang 032594 add NULL THUNK for CWIN30 & 31 Internal-ISV
;       WINNLSThunk   WINNLSSetSysIME
cProc WINNLSSetSysIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSSetSysIME

;       WINNLSThunk   WINNLSGetSysIME
cProc WINNLSGetSysIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSGetSysIME

;       WINNLSThunk   WINNLSIMEControl
cProc WINNLSIMEControl,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW hIMEWnd
parmD lpIME
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSIMEControl

;       WINNLSThunk   WINNLSSendControl
cProc WINNLSSendControl,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW wChar
parmW wCount
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSSendControl

;       WINNLSThunk   WINNLSQueryIMEInfo
cProc WINNLSQueryIMEInfo,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW hIMEWnd
parmD lpCIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSQueryIMEInfo

;       WINNLSThunk   IMPEnableIME
cProc IMPEnableIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
parmW fFlag
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPEnableIME

;       WINNLSThunk   IMPSetFirstIME
cProc IMPSetFirstIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpNIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPSetFirstIME

;       WINNLSThunk   IMPGetFirstIME
cProc IMPGetFirstIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPGetFirstIME

;       WINNLSThunk   IMPSetUsrFont
cProc IMPSetUsrFont,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPSetUsrFont

;       WINNLSThunk   InquireIME
cProc InquireIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
        mov     ax,0            ; WOW does not support
cEnd InquireIME


;dchiang 032494 add THUNK for CWIN31
;       WINNLSThunk   IMPRETRIEVEIME
cProc IMPRetrieveIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpCIMEPro
parmW wFlags
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPRetrieveIME

;       WINNLSThunk   WINNLSDEFIMEPROC
cProc WINNLSDefIMEProc,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW hDC
parmW wProc
parmW wFunc
parmD lParam1
parmD lParam2
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSDefIMEProc

;       WINNLSThunk   CONTROLIMEMESSAGE
cProc ControlIMEMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
parmW wControl
parmW wFunc
parmD lpParam
cBegin
        mov     ax,0            ; WOW does not support
cEnd ControlIMEMessage
endif

sEnd	CODE

end	WINNLS16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winnls\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=usa \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winspool\winspool.asm ===
TITLE	WINSPOOL.ASM
	PAGE	,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; WINSPOOL.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   17-OCT-1991 Matt Felton (mattfe)
;   Created.
;

	.286p

	.xlist
	include wow.inc
	include wowgdi.inc
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.

externFP WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA

sBegin	DATA
Reserved	db  16 dup (0)	    ;reserved for Windows  //!!!!! what is this

WINSPOOL_Identifier	db	'WINSPOOL16 Data Segment'
public _iLogLevel
_iLogLevel	dw	0
public _iBreakLevel
_iBreakLevel	dw	0

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,DATA
assumes ES,NOTHING

cProc	WINSPOOL16,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>
	cBegin	<nogen>
	mov	ax,1		;always indicate success
	ret
	cEnd	<nogen>

assumes DS,NOTHING

cProc	WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
	parmW	iExit		;DLL exit code

	cBegin
	mov	ax,1		;always indicate success
	cEnd

assumes DS,DATA

assumes DS,NOTHING

	DGDIThunk	 DEVICEMODE
	DGDIThunk	 EXTDEVICEMODE
	DGDIThunk	 DEVICECAPABILITIES

cProc	ExtTextOut,<PUBLIC,FAR>
cBegin
	int 3
cEnd


sEnd	CODE

end	WINSPOOL16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winoldap\winoldap.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    winoldap.c

Abstract:

    This module is a Win16 "stub" run by the WOW kernel when invoking
    non-Win16 applications.  It calls WowLoadModule to wait for the
    non-win16 app to terminate, and then exits

    This makes WINOLDAP a strange Windows program, since it doesn't
    create a window or pump messages.

    The binary is named WINOLDAP.MOD for historic reasons.

Author:

    04-Apr-1995 Jonle , created

Environment:

    Win16 (WOW)

Revision History:

--*/

#include <windows.h>

HINSTANCE WINAPI WowLoadModule(LPCSTR, LPVOID, LPCSTR);

//
// WinMain
//

int PASCAL WinMain(HANDLE hInstance, HANDLE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
    return (int) WowLoadModule(NULL,           // no module name
                               NULL,           // no parameterblock
                               lpszCmdLine     // pass along cmd line
                               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\winsock\winsock.asm ===
TITLE   WINSOCK.ASM
        PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; MMSYSTEM.ASM
; Thunks in 16-bit space to route Winsock API calls to WOW32
;
; History:
;   02-Oct-1992 David Treadwell (davidtr)
;   Created.
;

        .286p

        .xlist
        include wow.inc
        include wowwsock.inc
        include cmacros.inc
        .list

        __acrtused = 0
        public  __acrtused      ;satisfy external C ref.

externFP WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  DATA
Reserved        db  16 dup (0)      ;reserved for Windows  //!!!!! what is this

WINSOCK_Identifier   db      'WINSOCK16 Data Segment'

sEnd
sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

cProc   WINSOCK16,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>

        cBegin  <nogen>
            mov     ax,1
        ret
        cEnd    <nogen>

assumes DS,NOTHING

cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
        parmW   iExit           ;DLL exit code

        cBegin
        mov     ax,1            ;always indicate success
        cEnd

assumes DS,NOTHING

       WinsockThunk    ACCEPT
       WinsockThunk    BIND
       WinsockThunk    CLOSESOCKET
       WinsockThunk    CONNECT
       WinsockThunk    GETPEERNAME
       WinsockThunk    GETSOCKNAME
       WinsockThunk    GETSOCKOPT
       WinsockThunk    HTONL
       WinsockThunk    HTONS
       WinsockThunk    INET_ADDR
       WinsockThunk    INET_NTOA
       WinsockThunk    IOCTLSOCKET
       WinsockThunk    LISTEN
       WinsockThunk    NTOHL
       WinsockThunk    NTOHS
       WinsockThunk    RECV
       WinsockThunk    RECVFROM
       WinsockThunk    SELECT
       WinsockThunk    SEND
       WinsockThunk    SENDTO
       WinsockThunk    SETSOCKOPT
       WinsockThunk    SHUTDOWN
       WinsockThunk    SOCKET
       WinsockThunk    GETHOSTBYADDR
       WinsockThunk    GETHOSTBYNAME
       WinsockThunk    GETPROTOBYNAME
       WinsockThunk    GETPROTOBYNUMBER
       WinsockThunk    GETSERVBYNAME
       WinsockThunk    GETSERVBYPORT
       WinsockThunk    GETHOSTNAME
       WinsockThunk    WSAASYNCSELECT
       WinsockThunk    WSAASYNCGETHOSTBYADDR
       WinsockThunk    WSAASYNCGETHOSTBYNAME
       WinsockThunk    WSAASYNCGETPROTOBYNUMBER
       WinsockThunk    WSAASYNCGETPROTOBYNAME
       WinsockThunk    WSAASYNCGETSERVBYPORT
       WinsockThunk    WSAASYNCGETSERVBYNAME
       WinsockThunk    WSACANCELASYNCREQUEST
       WinsockThunk    WSASETBLOCKINGHOOK
       WinsockThunk    WSAUNHOOKBLOCKINGHOOK
       WinsockThunk    WSAGETLASTERROR
       WinsockThunk    WSASETLASTERROR
       WinsockThunk    WSACANCELBLOCKINGCALL
       WinsockThunk    WSAISBLOCKING
       WinsockThunk    WSASTARTUP
       WinsockThunk    WSACLEANUP
       WinsockThunk    __WSAFDISSET

; End of additions

sEnd    CODE

end     WINSOCK16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\wowdeb\wowdeb.c ===
#include <windows.h>                /* required for all Windows applications */

#define MAX_COMMUNICATION_BLOCK_SIZE    4096
#define DEAD_VALUE                      0xFEFEFEFEL

#include <dbginfo.h>

extern BOOL FAR PASCAL WowKillRemoteTask( LPSTR lpBuffer );

int PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance, LPSTR lpszCmdLine, int iCmd )
{
    HANDLE          hCommunicationBlock;
    LPSTR           lpCommunicationBlock;
    BOOL            b;
    LPCOM_HEADER    lphead;
    WORD            wArgsPassed;
    WORD            wArgsSize;
    WORD            wSuccess;
    DWORD           dwReturnValue;
    LPSTR           lpModuleName;
    LPSTR           lpEntryName;
    HANDLE          hModule;
    DWORD           (FAR PASCAL *lpfn)();
    BOOL            fFailed;
    LPWORD          lpw;

    // We only want 1 instance of WOWDEB
    if ( hPrevInstance != NULL ) {
        return( FALSE );
    }

    hCommunicationBlock = GlobalAlloc(GMEM_FIXED, MAX_COMMUNICATION_BLOCK_SIZE);
    if ( hCommunicationBlock == (HANDLE)0 ) {
        OutputDebugString("Failed to allocate memory block\n");
        return( FALSE );
    }

    lpCommunicationBlock = GlobalLock(hCommunicationBlock);
    if ( lpCommunicationBlock == NULL ) {
        OutputDebugString("Failed to lock memory block\n");
        return( FALSE );
    }

    /*
    ** Just make sure that TOOLHELP is loaded before we remotely kill
    ** ourselves.
    */
    hModule = LoadLibrary( "TOOLHELP.DLL" );

    dwReturnValue = DEAD_VALUE;
    wSuccess = (WORD)FALSE;

    do {
        /*
        ** Initialize the communications block
        */
        lphead = (LPCOM_HEADER)lpCommunicationBlock;

        lphead->dwBlockAddress = (DWORD)lpCommunicationBlock;
        lphead->dwReturnValue  = dwReturnValue;
        lphead->wArgsPassed    = 0;
        lphead->wArgsSize      = 0;
        lphead->wBlockLength   = MAX_COMMUNICATION_BLOCK_SIZE;
        lphead->wSuccess       = (WORD)wSuccess;

        b = WowKillRemoteTask( lpCommunicationBlock );

        if ( !b ) {
            break;
        }

        wSuccess = (WORD)FALSE;
        dwReturnValue = 0;

        /*
        ** Unpacketize the information and execute it
        ** Note: The below statements expect the contents of the structures
        ** to change after the above "WowKillRemoteTask" API call.  If the
        ** compiler attempts to optimize the references below, it will get
        ** the wrong values.
        */
        wArgsPassed  = lphead->wArgsPassed;
        wArgsSize    = lphead->wArgsSize;
        lpModuleName = lpCommunicationBlock + sizeof(COM_HEADER) + wArgsSize;
        lpEntryName  = lpModuleName + lstrlen(lpModuleName) + 1;

        hModule = LoadLibrary( lpModuleName );
        if ( hModule == 0 ) {
#ifdef DEBUG
            OutputDebugString("Failed to load library\n");
#endif
            continue;
        }

        lpfn = (DWORD (FAR PASCAL *)())GetProcAddress( hModule, lpEntryName );
        if ( lpfn == NULL ) {
#ifdef DEBUG
            OutputDebugString("Failed to get proc address\n");
#endif
            continue;
        }

        // Now copy the right number of bytes onto the stack and call the
        // function.
        lpw = (LPWORD)(lpCommunicationBlock + sizeof(COM_HEADER));
        fFailed = FALSE;

        // Cheesy way of putting a variable number of arguments on the stack
        // for a pascal call.
        switch( wArgsPassed ) {
            case 0:
                dwReturnValue = (* lpfn)();
                break;
            case 2:
                dwReturnValue = (* lpfn)( lpw[ 0] );
                break;
            case 4:
                dwReturnValue = (* lpfn)( lpw[ 1], lpw[ 0] );
                break;
            case 6:
                dwReturnValue = (* lpfn)( lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 8:
                dwReturnValue = (* lpfn)( lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 10:
                dwReturnValue = (* lpfn)( lpw[ 4], lpw[ 3], lpw[ 2], lpw[ 1],
                                          lpw[ 0] );
                break;
            case 12:
                dwReturnValue = (* lpfn)( lpw[ 5], lpw[ 4], lpw[ 3], lpw[ 2],
                                          lpw[ 1], lpw[ 0] );
                break;
            case 14:
                dwReturnValue = (* lpfn)( lpw[ 6], lpw[ 5], lpw[ 4], lpw[ 3],
                                          lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 16:
                dwReturnValue = (* lpfn)( lpw[ 7], lpw[ 6], lpw[ 5], lpw[ 4],
                                          lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 18:
                dwReturnValue = (* lpfn)( lpw[ 8], lpw[ 7], lpw[ 6], lpw[ 5],
                                          lpw[ 4], lpw[ 3], lpw[ 2], lpw[ 1],
                                          lpw[ 0] );
                break;
            case 20:
                dwReturnValue = (* lpfn)( lpw[ 9], lpw[ 8], lpw[ 7], lpw[ 6],
                                          lpw[ 5], lpw[ 4], lpw[ 3], lpw[ 2],
                                          lpw[ 1], lpw[ 0] );
            case 22:
                dwReturnValue = (* lpfn)( lpw[10], lpw[ 9], lpw[ 8], lpw[ 7],
                                          lpw[ 6], lpw[ 5], lpw[ 4], lpw[ 3],
                                          lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 24:
                dwReturnValue = (* lpfn)( lpw[11], lpw[10], lpw[ 9], lpw[ 8],
                                          lpw[ 7], lpw[ 6], lpw[ 5], lpw[ 4],
                                          lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 26:
                dwReturnValue = (* lpfn)( lpw[12], lpw[11], lpw[10], lpw[ 9],
                                          lpw[ 8], lpw[ 7], lpw[ 6], lpw[ 5],
                                          lpw[ 4], lpw[ 3], lpw[ 2], lpw[ 1],
                                          lpw[ 0] );
                break;
            case 28:
                dwReturnValue = (* lpfn)( lpw[13], lpw[12], lpw[11], lpw[10],
                                          lpw[ 9], lpw[ 8], lpw[ 7], lpw[ 6],
                                          lpw[ 5], lpw[ 4], lpw[ 3], lpw[ 2],
                                          lpw[ 1], lpw[ 0] );
                break;
            case 30:
                dwReturnValue = (* lpfn)( lpw[14], lpw[13], lpw[12], lpw[11],
                                          lpw[10], lpw[ 9], lpw[ 8], lpw[ 7],
                                          lpw[ 6], lpw[ 5], lpw[ 4], lpw[ 3],
                                          lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 32:
                dwReturnValue = (* lpfn)( lpw[15], lpw[14], lpw[13], lpw[12],
                                          lpw[11], lpw[10], lpw[ 9], lpw[ 8],
                                          lpw[ 7], lpw[ 6], lpw[ 5], lpw[ 4],
                                          lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            default:
#ifdef DEBUG
            OutputDebugString("Wrong number of parameters\n");
#endif
                fFailed = TRUE;
                break;
        }
        if ( fFailed ) {
            continue;
        }

        wSuccess = (WORD)TRUE;

    } while( TRUE );

    return( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\aaa.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* aaa.c -- special bogus module to substitute dummy function(s)
   for c library stuff which is never called but gets pulled in anyway. */


_malloc()
{
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\addprm.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* AddPrm.c -- Routines to add prms and sprms to docs */
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSMETRICS
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOPEN
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NOWNDCLASS
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOHDC
#define NOMB
#define NOMENUS
#define NOMETAFILE
#define NOMSG
#define NOTEXTMETRIC
#define NOSOUND
#define NOSCROLL
#define NOCOMM
/* no everything except MEMMGR */
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "code.h"
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "stcdefs.h"
#include "fkpdefs.h"
#include "macro.h"
#include "dispdefs.h"

/* E X T E R N A L S */

extern int docCur;
extern struct SEL selCur;
extern struct DOD (**hpdocdod)[];
extern struct UAB vuab;
extern int vfSysFull;
extern CHAR dnsprm[];
extern struct CHP vchpSel;
extern typeCP vcpLimParaCache;
extern typeCP cpMacCur;
extern typeCP CpLimNoSpaces();
extern int ferror;

/* G L O B A L S */

struct FPRM     fprmCache = { 0 };
struct PRM      prmCache = {0,0,0,0};


/* A D D  O N E  S P R M */
/* applies sprm at psprm to the current selection. Take care of
undoing, invalidation, special endmark cases, and extension of selection
to paragraph boundaries */
void AddOneSprm(psprm, fSetUndo)
CHAR *psprm;
int fSetUndo; /* True if we need to set up the undo buffer */
{
        int cch;
        int fParaSprm = fFalse;
        typeCP cpFirst, cpLim, dcp;

        if (!FWriteOk( fwcNil ))
            return;

        if ((dnsprm[*psprm] & ESPRM_sgc) != sgcChar)
            {
            typeCP dcpExtraPara = cp0;

            cpFirst = CpFirstSty( selCur.cpFirst, styPara );
            CachePara( docCur, CpMax( selCur.cpLim - 1, selCur.cpFirst ) );
            cpLim = vcpLimParaCache;

            dcp = cpLim - cpFirst;

            /* Check for para following selection that has no Eol */

            if (cpLim < cpMacCur)
                {
                /* Note that in this case only, dcp (the # of cp's affected
                   by the change) does not equal (cpLim - cpFirst)
                   (the # of cp's to which the sprm should apply) */
                CachePara( docCur, cpLim );
                dcpExtraPara = vcpLimParaCache - cpLim;
                }

            if (cpFirst + dcp + dcpExtraPara > cpMacCur)
                {   /* Last para affected has no Eol -- add one */
                struct SEL selSave;

                dcp += dcpExtraPara;
                Assert( cpFirst + dcp == cpMacCur + (typeCP) ccpEol);

                if (fSetUndo)
                    {
                    SetUndo( uacReplNS, docCur, cpFirst, dcp,
                             docNil, cpNil, dcp - ccpEol, 0 );
                    fSetUndo = fFalse;
                    }
                /* Add an eol.  Save the current selection so
                   it does not get adjusted */
                selSave = selCur;
                InsertEolInsert(docCur,cpMacCur);
                selCur = selSave;
                }
            }
        else
            { /* Char sprm -- eliminate trailing spaces from the
                 affected region, so we don't underline spaces after words. */
            cpFirst = selCur.cpFirst;
            cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);
            dcp = cpLim - cpFirst;
            if (dcp == 0)
                { /* Doing character looks to the insert point...  */
                if (fSetUndo)
                    SetUndo(uacReplNS, docCur, cpFirst, cp0,
                                       docNil, cp0, cp0, 0);
                DoSprm(&vchpSel, 0, *psprm, psprm + 1);
                return;
                }
            }

        if (fSetUndo)
            SetUndo(uacReplNS, docCur, cpFirst, dcp, docNil, cpNil, dcp, 0);

        if (ferror)  /* not enough memory to store info for undo operation */
            {
            NoUndo();
            return;
            }

        AddSprmCps(psprm, docCur, cpFirst, cpLim);
        AdjustCp( docCur, cpFirst, dcp, dcp );
}

/* E X P A N D  C U R  S E L */
ExpandCurSel(pselSave)
struct SEL *pselSave;
{
        *pselSave = selCur;

        selCur.cpFirst = CpFirstSty(selCur.cpFirst, styPara);
        CachePara(docCur, CpMax(selCur.cpLim - 1, selCur.cpFirst));
        selCur.cpLim = vcpLimParaCache;
}

/* E N D  L O O K  S E L */
EndLookSel(pselSave, fPara)
struct SEL *pselSave; BOOL fPara;
        {
        typeCP cpLim, cpFirst, dcp;
        dcp = (cpLim = selCur.cpLim) - (cpFirst = selCur.cpFirst);
        if (fPara)
                {
                TrashCache();
                if (cpLim <= cpMacCur)
                        {
                        CachePara(docCur, selCur.cpLim);
                        if (vcpLimParaCache > cpMacCur) /* Last (partial) paragraph */
                                dcp = cpMacCur - cpFirst + 1;
                        }
                }
        AdjustCp(docCur, cpFirst, dcp, dcp);

        selCur = *pselSave;
        }



/* A D D  S P R M */

AddSprm(psprm)
CHAR *psprm;
{ /* Add a single property modifier to the pieces contained in selCur. */
        AddSprmCps(psprm, docCur, selCur.cpFirst, selCur.cpLim);
}


/* A D D  S P R M  C P S */
AddSprmCps(char *psprm, int doc, typeCP cpFirst, typeCP cpLim)
{
        struct PCTB **hpctb;
        int ipcdFirst, ipcdLim, ipcd;
        struct DOD *pdod;
        int cch;
        struct PCD *ppcd;

/* First get address of piece table and split off desired pieces. */
        pdod = &(**hpdocdod)[doc];
        hpctb = pdod->hpctb;
        pdod->fFormatted = fTrue;
        ipcdFirst = IpcdSplit(hpctb, cpFirst);
        ipcdLim = IpcdSplit(hpctb, cpLim);
        if (ferror)
                /* Ran out of memory trying to expand piece table */
            return;

/* Now just add this sprm to the pieces. */
        FreezeHp();
        for (ipcd = ipcdFirst, ppcd = &(**hpctb).rgpcd[ipcdFirst];
                ipcd < ipcdLim && !vfSysFull; ++ipcd, ++ppcd)
                ppcd->prm = PrmAppend(ppcd->prm, psprm);
        MeltHp();
}

/* P R M  A P P E N D */

struct PRM PrmAppend(struct PRM prm, CHAR *psprm)
{ /* Append <sprm, val> to the chain of sprm's in prm.  Return new prm. */
        struct FPRM *pfprmOld;
        CHAR *pfsprm;
        CHAR *pfsprmOld;
        int sprm = *psprm;
        int sprmOld;
        register int esprm = dnsprm[sprm];
        register int esprmOld;
        int cchNew = (esprm & ESPRM_cch);
        int cchOld;
        int sgc = (esprm & ESPRM_sgc);
        int spr = (esprm & ESPRM_spr);
        int fSame = (esprm & ESPRM_fSame);
        int fClobber = (esprm & ESPRM_fClobber);
        int dval = 0;
        int cch;
        int cchT;
        typeFC fcPrm;

        struct FPRM fprm;

        if (cchNew == 0) cchNew = CchPsprm(psprm);

        pfsprm = fprm.grpfsprm;

        if (prm.fComplex)
                { /* Get the old list of sprm's from scratch file; copy it to fprm. */
                pfprmOld = (struct FPRM *) PchFromFc(fnScratch,
                        //(typeFC)(unsigned)(((struct PRMX *) &prm)->bfprm << 1), &cch);
                        fcSCRATCHPRM(prm), &cch);
                pfsprmOld = pfprmOld->grpfsprm;
                cchT = cch = pfprmOld->cch;
                while (cchT)
                        { /* Copy grpsprm, removing ones which we will clobber */
                        sprmOld = *pfsprmOld;
                        esprmOld = dnsprm[sprmOld];
                        if ((cchOld = (esprmOld & ESPRM_cch)) == 0)
                                cchOld = CchPsprm(pfsprmOld);
#ifdef DEBUG
                        if (cchOld == 0)
                                panic();
#endif
                        if (sprmOld == sprm && fSame ||
                                (esprmOld & ESPRM_sgc) == sgc &&
                                (esprmOld & ESPRM_spr) <= spr && fClobber)
                                {
				/* make sure we properly coalesce change
				   size prms */
                                if (sprm == sprmOld && sprm == sprmCChgHps)
                                        dval += *(pfsprmOld + 1);
                                cch -= cchOld;
                                }
                        /* CHps overrides CChgHps */
                        else if (sprmOld == sprmCChgHps && sprm == sprmCHps)
                                {
                                cch -= cchOld;
                                }
                        else
                                pfsprm = (CHAR *)bltbyte(pfsprmOld, pfsprm, cchOld);
                        pfsprmOld += cchOld;
                        cchT -= cchOld;
                        }
                }
        else
                { /* No file entry yet; convert simple prm to fsprm */
                int valOld = prm.val;
                sprmOld = prm.sprm;
                esprmOld = dnsprm[sprmOld];

                if (bPRMNIL(prm) ||
                        sprmOld == sprm && fSame ||
                        (esprmOld & ESPRM_sgc) == sgc &&
                        (esprmOld & ESPRM_spr) <= spr && fClobber)
                        {
                         /* make sure we are combinning consecutive sprmCChgHps */
                        if (sprm == sprmOld && sprm == sprmCChgHps)
                                dval += valOld;
                        cch = 0;
                        }
                /* CHps overrides CChgHps */
                else if (sprmOld == sprmCChgHps && sprm == sprmCHps)
                        {
                        cch = 0;
                        }
                else
                        { /* Save old sprm */
                        *pfsprm++ = sprmOld;
                        if ((cch = (esprmOld & ESPRM_cch)) == 2)
                                *pfsprm++ = valOld;
                        }
                }
/* we have: cch = length of old prm after removal of clobbered/etc. entries.
cchNew: length of the entry to be appended.
dval: correction for 2nd byte of new entry
pfsprm: where 1st byte of new entry will go
*/
        bltbyte((CHAR *) psprm, pfsprm, imin(cchNew, cchMaxGrpfsprm - cch));
        *(pfsprm + 1) += dval;

        if (cch == 0 && cchNew <= 2)
                { /* Pack sprm and val into a prm word. */
                struct PRM prmT;
                prmT.dummy=0;
                bltbyte(pfsprm, (CHAR *) &prmT, cchNew);
                prmT.fComplex = false;
                prmT.sprm = *pfsprm;
                return (prmT);
                }

        if ((cch += cchNew) > cchMaxGrpfsprm)
                {
                int fSave = ferror;
                Error(IDPMT2Complex);
                ferror = fSave;
                return (prm);
                }
        if (vfSysFull)
                return prm; /* Assume disk full message already given */

        fprm.cch = cch;

/* Check newly created prm to see if same as previous */
        if (CchDiffer(&fprmCache, &fprm, cch + 1) == 0)
                return prmCache;
        bltbyte(&fprm, &fprmCache, cch + 1);

        AlignFn(fnScratch, cch = ((cch >> 1) + 1) << 1, fTrue);
        prm.fComplex = fTrue;

        //((struct PRMX)prm).bfprm = FcWScratch((CHAR *) &fprm, cch) >> 1;

        fcPrm = FcWScratch((CHAR *) &fprm, cch) >> 1;
        ((struct PRMX *)&prm)->bfprm_hi = (fcPrm >> 16) & 0x7F;
        ((struct PRMX *)&prm)->bfprm_low = fcPrm & 0xFFFF;

        prmCache = prm;
        return prm;
}


/* A P P L Y  C  L O O K S */
/* character looks. val is a 1 char value */
ApplyCLooks(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{
/* Assemble sprm */
        CHAR rgbSprm[1 + cchINT];
        CHAR *pch = &rgbSprm[0];
        *pch++ = sprm;
        *pch = val;

        if (pchp == 0)
                {
                /* apply looks to current selection */
                AddOneSprm(rgbSprm, fTrue);
                vuab.uac = uacChLook;
                SetUndoMenuStr(IDSTRUndoLook);
                }
        else
                {
                /* apply looks to pchp */
                DoSprm(pchp, 0, sprm, pch);
                }
}


/* A P P L Y  L O O K S  P A R A  S */
/* val is a char value */
ApplyLooksParaS(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
        {
        int valT = 0;
        CHAR *pch = (CHAR *)&valT;
        *pch = val;
/* all the above is just to prepare bltbyte later gets the right byte order */
        ApplyLooksPara(pchp, sprm, valT);
        }


/* A P P L Y  L O O K S  P A R A */
/* val is an integer value. Char val's must have been bltbyte'd into val */
ApplyLooksPara(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{

if (FWriteOk(fwcNil)) /* Check for out-of-memory/ read-only */
        {
        CHAR rgbSprm[1 + cchINT];
        CHAR *pch = &rgbSprm[0];

        *pch++ = sprm;
        bltbyte(&val, pch, cchINT);
        AddOneSprm(rgbSprm, fTrue);
        vuab.uac = uacChLook;
        SetUndoMenuStr(IDSTRUndoLook);
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\ch.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file defines the characters used by Windows Word. */
/* You must include windows.h to get virtual key definitions */

#define chNil		(-1)

/* Characters in files */

#define chDelPrev	0x08
#define chTab		0x09
#define chEol		0x0A
#define chNewLine	0x0B
#define chSect		0x0C
#define chReturn	0x0D
#define chNRHFile	0x1F	    /* Non-required hyphen */

#ifndef NOKCCODES
/* Keyboard Characters */
/* A high bit of 1 means that this is a command character */
/* For Windows, a command character it one that is processed through */
/* the virtual key mechanism (WM_KEYBOARD) instead of translated (WM_CHAR) */

#define wKcCommandMask		0x8000		/* mask that tells if command */
#define FIsCommandKc(kc)	((int)(kc) < 0) /* or, test it this way */

#define kcDelPrev	(wKcCommandMask | VK_BACK)
#define kcDelNext	(wKcCommandMask | VK_DELETE)
#define kcInsert	(wKcCommandMask | VK_INSERT)
#define kcTab		(wKcCommandMask | VK_TAB )
#define kcReturn	(wKcCommandMask | VK_RETURN)
#define kcLeft		(wKcCommandMask | VK_LEFT)
#define kcUp		(wKcCommandMask | VK_UP)
#define kcRight 	(wKcCommandMask | VK_RIGHT)
#define kcDown		(wKcCommandMask | VK_DOWN)
#define kcPageUp	(wKcCommandMask | VK_PRIOR)
#define kcPageDown	(wKcCommandMask | VK_NEXT)
#define kcBeginLine	(wKcCommandMask | VK_HOME)
#define kcEndLine	(wKcCommandMask | VK_END)
#define kcGoto		(wKcCommandMask | VK_CLEAR)

/* Special for windows: we must handle these key codes & update shift state */

#define kcShift 	(wKcCommandMask | VK_SHIFT)
#define kcControl	(wKcCommandMask | VK_CONTROL)
#define kcAlt		(wKcCommandMask | VK_MENU)
#define kcCapsLock	(wKcCommandMask | VK_CAPITAL)

/* Phony Keyboard Characters, used to force actions */

#define kcNextPara	0xFFFE		/* Generated from GOTO-DOWN */
#define kcPrevPara	0xFFFD		/* Generated from GOTO-UP */
/* #define kcAlphaVirtual  0xFFFC      Defined below, outside ifdef   */

/* Keys that affect the look of the current selection (char or para) */

#define kcLookMin	0x8001		/* As of now, no look keys */
#define kcLookMax	0x8000

/* These control keys are processed as WM_CHAR ASCII codes */

#define kcLFld		(wKcCommandMask | ('[' & 0x1F)) /* Print-Merge <<>> */
#define kcRFld		(wKcCommandMask | (']' & 0x1F)) /* CTRL-[ and CTRL-] */

/* Keyboard Kontrol (CTRL) codes -- a key message word is interpreted
   as a kk instead of a kc, if the CTRL key is down */

#define kkUpScrollLock	(kcUp)
#define kkDownScrollLock (kcDown)
#define kkTopDoc	(wKcCommandMask | VK_HOME)
#define kkEndDoc	(wKcCommandMask | VK_END)
#define kkTopScreen	(wKcCommandMask | VK_PRIOR)
#define kkEndScreen	(wKcCommandMask | VK_NEXT)
#define kkWordLeft	(wKcCommandMask | VK_LEFT)
#define kkWordRight	(wKcCommandMask | VK_RIGHT)
#define kkCopy    	(wKcCommandMask | VK_INSERT)
#define kkDelPrev	(wKcCommandMask | VK_BACK)

#if WINVER < 0x300
#define kkNonReqHyphen	(wKcCommandMask | VK_MINUS)
#else
/* I don't know how the above EVER worked so I'm changing 
   it to use the return value from VkKeyScan().  See routines
   KcAlphaKeyMessage() and FNonAlphaKeyMessage() ..pault */

#define kkNonReqHyphen  (wKcCommandMask | vkMinus)
#endif

#ifdef CASHMERE     /* These keys not supported by MEMO */
#define kkNonBrkSpace	(wKcCommandMask | (unsigned) ' ')
#define kkNLEnter	(wKcCommandMask | VK_RETURN)   /* EOL w/o end Para */
#endif

/* CTRL-shifted keys */

#define kksPageBreak	(wKcCommandMask | VK_RETURN)

#ifdef DEBUG
#define kksEatWinMemory  (wKcCommandMask | 'H') /* Hog Windows Heap */
#define kksFreeWinMemory (wKcCommandMask | 'R') /* Release Windows heap */
#define kksEatMemory	 (wKcCommandMask | 'E') /* Eat WRITE Heap Space */
#define kksFreeMemory	 (wKcCommandMask | 'F') /* Free WRITE Heap Space */
#define kksTest 	 (wKcCommandMask | VK_ESCAPE)
#endif

/* Transformation from kk && kks codes to a unique kc code */

#define KcFromKk(kk)	( (kk) + 0x100 )
#define KcFromKks(kks)	( (kks) + 0x200 )

/* new style ctrl-key accelerators (7.22.91) v-dougk */
#define kkNewCopy   (wKcCommandMask | 'C')
#define kkNewUndo   (wKcCommandMask | 'Z')
#define kkNewPaste  (wKcCommandMask | 'V')
#define kkNewCut    (wKcCommandMask | 'X')

/* Kc codes for CTRL-keys that are processed at the virtual key level */

#define kcNewCopy   KcFromKk( kkNewCopy )
#define kcNewUndo   KcFromKk( kkNewUndo )
#define kcNewPaste  KcFromKk( kkNewPaste )
#define kcNewCut    KcFromKk( kkNewCut )
#define kcTopDoc	KcFromKk( kkTopDoc )
#define kcEndDoc	KcFromKk( kkEndDoc )
#define kcTopScreen	KcFromKk( kkTopScreen )
#define kcEndScreen	KcFromKk( kkEndScreen )
#define kcWordLeft	KcFromKk( kkWordLeft )
#define kcWordRight	KcFromKk( kkWordRight )
#define kcCut		KcFromKk( kkCut )
#define kcPaste 	KcFromKk( kkPaste )
#define kcCopy		KcFromKk( kkCopy )
#define kcClear 	KcFromKk( kkClear )
#define kcUndo		KcFromKk( kkUndo )
#define kcUpScrollLock	KcFromKk( kkUpScrollLock )
#define kcDownScrollLock KcFromKk( kkDownScrollLock )

#ifdef DEBUG	/* kc codes for Debugging control keys */
#define kcEatWinMemory	KcFromKks(kksEatWinMemory)
#define kcFreeWinMemory KcFromKks(kksFreeWinMemory)
#define kcEatMemory	KcFromKks(kksEatMemory)
#define kcFreeMemory	KcFromKks(kksFreeMemory)
#define kcTest		(KcFromKks(kksTest))
#endif /* DEBUG */

/* A special case: kcPageBreak is a CTRL-SHIFT key that is processed in
   AlphaMode */
#define kcPageBreak	KcFromKks( kksPageBreak )

#define kcNonReqHyphen	KcFromKk( kkNonReqHyphen )

#ifdef CASHMERE     /* These keys not supported by MEMO */
#define kcNonBrkSpace	KcFromKk( kkNonBrkSpace )
#define kcNLEnter	KcFromKk( kkNLEnter )
#endif

#endif	/* #ifndef NOKCCODES */

    /* Outside #ifdef because these are return codes from Kc funcs */
    /* Also defined in mmw.c because of compiler stack overflow problems */
#define kcNil		0xFFFF
#define kcAlphaVirtual	0xFFFC	   /* Means "Virtual Key, must translate it" */

/* Display & text-processing characters.  These are real characters in the ANSI
character set as opposed to characters that appear in the file. */

#define chSpace 	' '
#define chHyphen	'-'

#ifndef DBCS
/* we defined them in kanji.h */
#define chStatPage	(CHAR)'\273'
#define chStatRH	'>'
#define chEMark 	(CHAR)'\244'
#endif

#define chSplat 	'.'
#define chSectSplat	':'
#define chDot		'.'
#define chDecimal	'.'
#define chBang		'!'
#define chQMark 	'?'
#define chQuote 	'"'
#define chFldSep	','
#define chLParen	'('
#define chRParen	')'
#define chStar		'*'
#define chLFldFile	(CHAR)'\253'
#define chRFldFile	(CHAR)'\273'
#define chNBH		(CHAR)'\255'	/* Non-breaking hyphen */
#define chNBSFile	(CHAR)'\240'	/* Non-breaking space */


/* The following are "special" characters that are essentially macros for longer
strings. */

#define schPage 	(CHAR)'\001'
#define schFootnote	(CHAR)'\005'
#define schInclude	(CHAR)'\006'

/* Characters in Search patterns */
#define chPrefixMatch	'^'
#define chMatchAny	'?'
#define chMatchWhite	'w'
#define chMatchTab	't'
#define chMatchEol	'p'
#define chMatchNewLine	'n'
#define chMatchSect	'd'
#define chMatchNBSFile	's'
#define chMatchNRHFile	'-'

/* ANSI block character, see FWriteExtTextScrap! ..pault */

#define chBlock 0x7f

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\bitmaps.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* These are defines for the different-sized, conditionally-loaded Ruler 
   bitmaps.  See header of WRITE.RC and also FCreateRuler()   ..pault */


#define idBmBtns       100     /* Ruler Buttons */
#define idBmBtnsCGA    100
#define idBmBtnsEGA    101
#define idBmBtnsVGA    102
#define idBmBtns8514   103
#define idBmBtnsMax    104

#define idBmMarks      200     /* Ruler Marks */
#define idBmMarksCGA   200
#define idBmMarksEGA   201
#define idBmMarksVGA   202
#define idBmMarks8514  203
#define idBmMarksMax   204

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\chlook.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* chlook.c -- modify format from the keyboard or directly from dropdown */
#define NOCLIPBOARD
#define NOCTLMGR
#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES

#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "dispdefs.h"
#include "menudefs.h"

/* E X T E R N A L S */
extern HMENU vhMenu;
extern int vfVisiMode;
extern int vfInsLast;
extern int vfSeeSel;
extern int fGrayChar;
extern struct UAB vuab;
#ifdef ENABLE /* myMenus and mpifntfont not used */
extern MENUHANDLE myMenus[];
extern int mpifntfont[];
#endif
extern int vifntMac;
extern int vifntApplication;

#define keyDownMask     8

CHAR rgbAgain[1 + cchINT]; /* holds last sprm with value for Again key */

/* D O  C H  L O O K */
/* decode ch and apply looks to pchp (or to current sel if pchp == 0) */
DoChLook(ch, pchp)
int ch;
struct CHP *pchp;
{
#ifdef ENABLE /* DoChLook not implemented yet */
        typeCP cpFirst, cpLim;
        int val;
        int sprm;
        int enbSave;

        vfSeeSel = vfInsLast = fTrue;
        if (ch == chAgain)
                {
                AddOneSprm(rgbAgain, fTrue);
                vuab.uac = uacChLook;
                SetUndoMenuStr(IDSTRUndoLook);
                return;
                }

        val = fTrue;
        switch(ChUpper(ch & 0377))
                {
        default:
/*----          Error(IDPMTBadLook);----*/
                beep();
                return;
        case chLookStd & 0377:
                sprm = sprmCPlain;
                val = stcNormal;
                goto LApplyCLook;
        case chLookItalic & 0377:
                sprm = sprmCItalic;
                goto LApplyCLook;
        case chLookBold & 0377:
                sprm = sprmCBold;
                goto LApplyCLook;
        case chLookUline & 0377:
                sprm = sprmCUline;
                goto LApplyCLook;
        case chLookShadow & 0377:
                sprm = sprmCShadow;
                goto LApplyCLook;
        case chLookOutline & 0377:
                sprm = sprmCOutline;
                goto LApplyCLook;
        case chLookSuper & 0377:
                sprm = sprmCPos;
                val = ypSubSuper;
                goto LApplyCLook;
        case chLookSub & 0377:
                sprm = sprmCPos;
                val = -ypSubSuper;
                goto LApplyCLook;
        case chLookSmCaps & 0377:
                sprm = sprmCCsm;
                val = csmSmallCaps;
                goto LApplyCLook;
        case chLookHpsBig & 0377:
                sprm = sprmCChgHps;
                val = 1;
                goto LApplyCLook;
        case chLookHpsSmall & 0377:
                sprm = sprmCChgHps;
                val = -1;
                goto LApplyCLook;
        case chLookFont & 0377:
/* Disable eject disk/ print image key handlers */
#define SCRDMPENB (0x2f8L)
                enbSave = LDBI(SCRDMPENB);
                STBI(0, SCRDMPENB);
                ch = ChInpWait();
                STBI(enbSave, SCRDMPENB);
                if (ch < '0' || ch > '9')
                        {
/*----                  Error(IDPMTBadLook);----*/
                        beep();
                        return;
                        }
                sprm = sprmCChgFtc;
                val = ch - '0';
/* Map from font index to system font code */
                val = val >= vifntMac ? vifntApplication  & 0377: mpifntfont[val];
                goto LApplyCLook;

 /* Paragraph looks */
        case chLookGeneral & 0377:
                sprm = sprmPNormal;
                /*val = 0;*/
                break;
        case chLookLeft & 0377:
                sprm = sprmPJc;
                val = jcLeft;
                break;
        case chLookRight & 0377:
                sprm = sprmPJc;
                val = jcRight;
                break;
        case chLookJust & 0377:
                sprm = sprmPJc;
                val = jcBoth;
                break;
        case chLookCenter & 0377:
                sprm = sprmPJc;
                val = jcCenter;
                break;
        case chLookIndent & 0377:
                val = czaInch/2;
                sprm = sprmPFIndent;
                goto LApplyPLook;
        case chLookDouble & 0377:
                val = czaLine * 2;
                sprm = sprmPDyaLine;
                goto LApplyPLook;
        case chLookOpen & 0377:
                val = czaLine;
                sprm = sprmPDyaBefore;
                goto LApplyPLook;
        case chLookNest & 0377:
                sprm = sprmPNest;
                /*val = 0;*/
                break;
        case chLookUnNest & 0377:
                sprm = sprmPUnNest;
                /*val = 0;*/
                break;
        case chLookHang & 0377:
                sprm = sprmPHang;
                /*val = 0;*/
                break;
                }
/* apply look with 1 char value */
        ApplyLooksParaS(pchp, sprm, val);
        return;
/* apply look with cchInt char value */
LApplyPLook:
        ApplyLooksPara(pchp, sprm, val);
        return;

LApplyCLook:
        ApplyCLooks(pchp, sprm, val);
        return;
#endif /* ENABLE */
}

/* A P P L Y  C  L O O K S */
/* character looks. val is a 1 char value */
ApplyCLooks(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{
/* Assemble sprm */
        CHAR *pch = rgbAgain;
        *pch++ = sprm;
        *pch = val;

        if (pchp == 0)
                {
/* apply looks to current selection */
                AddOneSprm(rgbAgain, fTrue);
                vuab.uac = uacChLook;
                SetUndoMenuStr(IDSTRUndoLook);
                }
        else
/* apply looks to pchp */
                DoSprm(pchp, 0, sprm, pch);
}

/* A P P L Y  L O O K S  P A R A  S */
/* val is a char value */
ApplyLooksParaS(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
        {
        int valT = 0;
        CHAR *pch = (CHAR *)&valT;
        *pch = val;
/* all the above is just to prepare bltbyte later gets the right byte order */
        ApplyLooksPara(pchp, sprm, valT);
        }

/* A P P L Y  L O O K S  P A R A */
/* val is an integer value. Char val's must have been bltbyte'd into val */
ApplyLooksPara(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{

#ifdef ENABLE /* related to footnote */
if (FWriteCk(fwcNil)) /* Just check for illegal action in footnote */
#endif
        {
/* set Again stuff since we may have been called from the menu */
        CHAR *pch = rgbAgain;
        *pch++ = sprm;
        bltbyte(&val, pch, cchINT);
        AddOneSprm(rgbAgain, fTrue);
        vuab.uac = uacChLook;
        SetUndoMenuStr(IDSTRUndoLook);
        }
return;
}


#ifdef ENABLE  /* fnChar/fnPara */
/* F N  C H A R  P L A I N */
void fnCharPlain()
{
        ApplyCLooks(0, sprmCPlain, 0);
}

/* F N  C H A R  B O L D */
void fnCharBold()
{
        ApplyCLooks(0, sprmCBold, FMenuUnchecked(imiBold));
}

void fnCharItalic()
{
        ApplyCLooks(0, sprmCItalic, FMenuUnchecked(imiItalic));
}

void fnCharUnderline()
{
        ApplyCLooks(0, sprmCUline, FMenuUnchecked(imiUnderline));
}

void fnCharSuperscript()
{
        ApplyCLooks(0, sprmCPos, FMenuUnchecked(imiSuper) ? ypSubSuper : 0);
}

void fnCharSubscript()
{
        ApplyCLooks(0, sprmCPos, FMenuUnchecked(imiSub) ? -ypSubSuper : 0);
}

void fnParaNormal()
{
extern int vfPictSel;

        ApplyLooksParaS(0, sprmPNormal, 0);
        if (vfPictSel)
                CmdUnscalePic();
}

void fnParaLeft()
{
        ApplyLooksParaS(0, sprmPJc, jcLeft);
}

void fnParaCentered()
{
        ApplyLooksParaS(0, sprmPJc, jcCenter);
}

void fnParaRight()
{
        ApplyLooksParaS(0, sprmPJc, jcRight);
}

void fnParaJustified()
{
        ApplyLooksParaS(0, sprmPJc, jcBoth);
}

void fnParaOneandhalfspace()
{
        ApplyLooksPara(0, sprmPDyaLine, czaLine * 3 / 2);
}

void fnParaDoublespace()
{
        ApplyLooksPara(0, sprmPDyaLine, czaLine * 2);
}

void fnParaSinglespace()
{
        ApplyLooksPara(0, sprmPDyaLine, czaLine);
}

int
FMenuUnchecked(imi)
int     imi;
{ /* Return true if there is NO check mark in front of menu */
int flag;

        if (fGrayChar)
                return true;
        flag = CheckMenuItem(vhMenu, imi, MF_CHECKED);
        CheckMenuItem(vhMenu, imi, flag); /* back to original status */
        return(flag == MF_UNCHECKED ? true : false);

#ifdef SAND
        GetItemMark(myMenus[CHARACTER - 1], imi, &ch);
/***** WRONG COMMENT BELOW! *****/
        return (ch != 18); /* Return true is there is a check mark in front of menu */
#endif /* SAND */
}
#endif


int ChInpWait()
{
#ifdef ENABLE /* CpInpWait not implemented yet */
EVENT event;
int i;
for (i = 0; i < 15000; i++)
        {
        if(GetNextEvent(keyDownMask, &event))
                return (event.message.wl & 0x007f);
        }
return -1; /* Will cause a beep if the user times out */
#endif /* ENABLE */
}

#ifdef CASHMERE /* smcap, overstrike, dbline, open para, visible mode */
fnCharSmallcaps()
{
        ApplyCLooks(0, sprmCCsm, FMenuUnchecked(7) ? csmSmallCaps : csmNormal);
}
fnCharOutline()
{
        ApplyCLooks(0, sprmCOutline, FMenuUnchecked(5));
}

fnCharShadow()
{
        ApplyCLooks(0, sprmCShadow, FMenuUnchecked(6));
}
fnParaOpenspace()
{
        ApplyLooksPara(0, sprmPDyaBefore, czaLine);
}
fnVisiMode()
{
        vfVisiMode = !vfVisiMode;
        TrashAllWws();
}
#endif /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\chngwin.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOCLIPBOARD
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#define NODRAWTEXT
#define NOSOUND
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "winddefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "docdefs.h"
#include "debug.h"

extern HWND             vhWnd;
extern HWND             vhWndSizeBox;
extern HWND             vhWndRuler;
extern HWND             vhWndPageInfo;
extern HWND             vhWndCancelPrint;
extern HDC              vhDCPrinter;
extern HFONT            vhfPageInfo;
extern HCURSOR          vhcArrow;
extern HCURSOR          vhcIBeam;
extern HCURSOR          vhcBarCur;
extern struct WWD       rgwwd[];
extern struct WWD       *pwwdCur;
extern HANDLE           hMmwModInstance; /* handle to own module instance */
extern int              vfShiftKey;
extern int              vfCommandKey;
extern int              vfOptionKey;
extern int              vfDoubleClick;
extern struct SEL       selCur;
extern long             rgbBkgrnd;
extern long             rgbText;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;
extern int              vfIconic;
extern int              vfLargeSys;
extern int              dxpRuler;
extern HMENU    vhMenu;

#ifdef	JAPAN	// Indicate whether to show IME convert window
extern	BOOL	ConvertEnable;
#endif



void MmwSize(hWnd, cxpNew, cypNew, code)
HWND hWnd;
int cxpNew;
int cypNew;
WORD code;
{
    if (code == SIZEICONIC)
        {
#ifdef NOT_RECOMMENDED
/* This should already be done by Windows itself! 
   Moving here could cause confusion */

        /* Resize the document window. */
        if (wwdCurrentDoc.wwptr != NULL)
            MoveWindow(wwdCurrentDoc.wwptr, 0, 0, 0, 0, FALSE);
#endif

        /* Deselect our fonts so that they can move if necessary. */
        ResetFont(FALSE);
        if (vhWndCancelPrint == NULL)
            {
            /* Reset the printer font iff we are not printing or repaginating.
            */
            ResetFont(TRUE);
            }
        if (!vfLargeSys && vhfPageInfo != NULL)
            {
            DeleteObject(SelectObject(GetDC(vhWndPageInfo),
              GetStockObject(SYSTEM_FONT)));
            vhfPageInfo = NULL;
            }

        vfIconic = TRUE;
        }
    else
        {
        int dxpBorder = GetSystemMetrics(SM_CXBORDER);
        int dypBorder = GetSystemMetrics(SM_CYBORDER);
        int xpMac = cxpNew - dxpScrlBar + dxpBorder;
        int ypMac = cypNew - dypScrlBar + dypBorder;
        int dypOverlap = 0;

        /* If we are coming back from being iconic, then reestablish the printer
        DC. */
        if (vfIconic && vhDCPrinter == NULL)
            {
            GetPrinterDC(FALSE);
            }

        /* Reposition all of the windows. */
        MoveWindow(wwdCurrentDoc.hVScrBar, xpMac, -dypBorder, dxpScrlBar, ypMac
          + (dypBorder << 1), TRUE);
        MoveWindow(wwdCurrentDoc.hHScrBar, dxpInfoSize, ypMac, cxpNew -
          dxpInfoSize - dxpScrlBar + (dxpBorder << 1), dypScrlBar, TRUE);
#ifndef NOMORESIZEBOX        
        MoveWindow(vhWndSizeBox, xpMac, ypMac, dxpScrlBar, dypScrlBar, TRUE);
#endif
        MoveWindow(vhWndPageInfo, 0, ypMac, dxpInfoSize, dypScrlBar, TRUE);
        if (vhWndRuler != NULL)
            {
            dypOverlap = dypRuler - (wwdCurrentDoc.ypMin - 1);
            MoveWindow(vhWndRuler, 0, 0, xpMac, dypRuler, TRUE);
            }

        /* Resize the document window. */
        if (wwdCurrentDoc.wwptr != NULL)
            {
            MoveWindow(wwdCurrentDoc.wwptr, 0, dypOverlap, xpMac, ypMac -
              dypOverlap, FALSE);

            /* Validate the area of the document window that is overlapped by
            the ruler if necessary. */
            if (vhWndRuler != (HWND)NULL)
                {
                RECT rc;

                rc.left = rc.top = 0;
                rc.right = dxpRuler;
                rc.bottom = wwdCurrentDoc.ypMin;
                ValidateRect(wwdCurrentDoc.wwptr, (LPRECT)&rc);
                }

            }

        vhMenu = GetMenu(hWnd); // kludge patch cause Write does its own
                                // accelerator handling (6.24.91) v-dougk
        vfIconic = FALSE;
        }
}




void MdocSize(hWnd, cxpNew, cypNew, code)
HWND hWnd;
int cxpNew;
int cypNew;
WORD code;
{
extern int wwCur;
extern int vfSeeSel;
extern int vfInitializing;

    typeCP cp;
    struct EDL *pedl;

    /* Let's start thing off with a couple of assumptions. */
    Assert( code == SIZENORMAL || code == SIZEFULLSCREEN );
    Assert( wwdCurrentDoc.wwptr == hWnd );

#ifdef ENABLE   /* We repaint completely on resize */
    if (cypNew > wwdCurrentDoc.ypMac)
            /* We are growing vertically, mark exposed area invalid
               so UpdateWw does not try to recycle a partial line
               at the bottom of the window. */
        InvalBand( &wwdCurrentDoc, wwdCurrentDoc.ypMac, cypNew );
#endif
    if (wwCur != wwNil)
        TrashWw( wwCur );

        /* Mark the window dirty so that dlMac gets reset according to the new
           window size */
    wwdCurrentDoc.fDirty = TRUE;

    wwdCurrentDoc.xpMac = cxpNew;
    wwdCurrentDoc.ypMac = cypNew;

    /* If minimizing the window, we are done */
    if ((cxpNew == 0) && (cypNew == 0))
        return;

        /* If the selection was visible before, so shall it be hereafter */
    if ( ((cp = CpEdge()) >= wwdCurrentDoc.cpFirst) &&
         (wwdCurrentDoc.dlMac > 0) &&
         (cp < (pedl =
                   &(**wwdCurrentDoc.hdndl)[wwdCurrentDoc.dlMac - 1])->cpMin +
               pedl->dcpMac))
        {
        /* Normally, we would just set vfSeeSel and wait for Idle to
           put the selection in view.  However, we can be resized even
           when we are not the current app, and in that case Idle will not
           get called soon enough. So, we scroll the selection into view here */

        if (!vfInitializing)
            {    /* Avoid the peril of trying to do this operation too early */
            extern int wwCur;

            UpdateWw( wwCur, FALSE );   /* To lock in the new dlMac */
            PutCpInWwVert( cp );
            UpdateWw( wwCur, FALSE );
            }
        }
}



FreeMemoryDC( fPrinterToo )
BOOL fPrinterToo;
{
extern HDC vhMDC;
extern int dxpbmMDC;
extern int dypbmMDC;
extern HBITMAP hbmNull;

/* Delete the memory DC if necessary. */
if ( vhMDC != NULL )
    {
    /* Delete the old bitmap if necessary. */
    if (dxpbmMDC != 0 || dypbmMDC != 0)
        {
        DeleteObject( SelectObject( vhMDC, hbmNull ) );
        dxpbmMDC = dypbmMDC = 0;
        }
    /* Discard the screen fonts. */
    FreeFonts( TRUE, FALSE );

    /* Delete the memory DC. */
    DeleteDC( vhMDC );
    vhMDC = NULL;
    }

/* Also, delete the DC for the printer width, if necessary. */
if ( fPrinterToo )
    {
    FreePrinterDC();
    }
}


FreePrinterDC()
{
extern int vdocBitmapCache;
extern HDC vhDCPrinter;
extern BOOL vfPrinterValid;
extern HWND hParentWw;

/* Delete the printer DC if necessary. */
if ( vhDCPrinter != NULL )
    {
    /* Discard the printer fonts. */
    FreeFonts( FALSE, TRUE );

    if ( vfPrinterValid )
        {
        /* This is a real printer DC; delete it. */
        DeleteDC( vhDCPrinter );
        }
    else
        {
        /* This is really the screen DC; it must be released. */
        ReleaseDC( hParentWw, vhDCPrinter );
        }
    vhDCPrinter = NULL;

    /* Free the cached bitmap because it was stretched for the display to
    reflect its appearance on the printer. */
    if (vdocBitmapCache != docNil)
        FreeBitmapCache();
    }
}


void MdocGetFocus(hWnd, hWndPrevFocus)
HWND hWnd;
HWND hWndPrevFocus;
{
extern int vfInsertOn;
extern int vfFocus;

 if (!vfFocus)
    {
    vfFocus = TRUE;
        /* Start up a timer event to blink the caret */
        /* MdocWndProc gets notified with a message of WM_TIMER */
        /* every wCaretBlinkTime milliseconds */
    SetTimer( hWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );

        /* Set the caret on right away, for looks */
    if (!vfInsertOn)
        MdocTimer( hWnd, tidCaret );

        /* Update globals that tell us the state of the lock/shift keys */
    SetShiftFlags();
    }
#ifdef	JAPAN
	ConvertEnable = TRUE;
	IMEManage( FALSE );
#endif
}



void MdocLoseFocus(hWnd, hWndNewFocus)
HWND hWnd;
HWND hWndNewFocus;
{
 extern int vfFocus;

 if (vfFocus)
    {
    extern int vfGotoKeyMode;

        /* Cancel caret blink timer event & clear the caret */
    KillTimer( hWnd, tidCaret );
    ClearInsertLine();
        /* Free up the memory DC */
        /* We interpret the loss of focus as a signal that */
        /* some other app will be using resources */
    vfFocus = FALSE;
    vfGotoKeyMode = FALSE;  /* Cancel GOTO key modifier */
        /* Close all files on removable media in case the guy swaps disks */
    CloseEveryRfn( FALSE );
    }
#ifdef	JAPAN
	ConvertEnable = FALSE;
	IMEManage( TRUE );
#endif
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\clipbord.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* clipbord.c -- Cut/Paste to clipboard */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCTLMGR
#define NOFONT
#define NOPEN
#define NOBRUSH
#define NOSCROLL
#define NOCOMM
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "str.h"
#include "propdefs.h"
#include "editdefs.h"
#include "winddefs.h"
#include "filedefs.h"
#include "wwdefs.h"
#include "prmdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
#endif

#include "debug.h"

extern struct SEL       selCur;      /* Current selection (i.e., sel in current ww */
extern int              docCur;     /* Document in current ww */

extern int              docUndo;
extern int              docScrap;
extern int              vfSeeSel;
extern struct DOD       (**hpdocdod)[];
extern struct PAP       vpapAbs;
extern typeCP           vcpLimParaCache;
extern typeCP           vcpFirstParaCache;
extern int              vfPictSel;
extern HCURSOR          vhcIBeam;
extern int              vfScrapIsPic;
extern struct UAB       vuab;
extern int              ferror;
extern struct FCB       (**hpfnfcb)[];
extern struct WWD       rgwwd[];

/* THESE ARE LOCAL TO THIS MODULE */
#if defined(OLE)
int NEAR PASCAL CopyScrapToTmp(void);
#endif

    /* fn we created during the last non-local cut of MEMO rich text */
int fnLastCut=fnNil;
    /* Local communication between ChangeClipboard() and MdocDestroyClip() */
int fDontDestroyClip=FALSE;


FMdocClipboardMsg( message, wParam, lParam )
unsigned message;
WORD wParam;
LONG lParam;
{   /* Process WRITE clipboard messages sent to MdocWndproc.
       return TRUE if a message was processed, FALSE otherwise */

 switch (message)
    {
    default:
        return FALSE;

    /*-------DATA INTERCHANGE COMMANDS-----------*/
    case WM_CUT:
        fnCutEdit();
        break;

    case WM_COPY:
        fnCopyEdit();
        break;

    case WM_PASTE:
#if defined(OLE)
        vbObjLinkOnly = FALSE;
#endif
        fnPasteEdit();
        break;

    case WM_CLEAR:
        fnClearEdit(OBJ_DELETING);
        break;

    case WM_UNDO:
        fnUndoEdit();
        break;

    /*---------------CLIPBOARD INTERACTION-------------*/

    case WM_DESTROYCLIPBOARD:
        /*  A notification that we are about to lose the ownership
            of the clipboard.  We should free any resources that are
            holding the contents of the clipboard */
        MdocDestroyClip();
        break;

    case WM_RENDERFORMAT:
        /* A request to render the contents of the clipboard
           in the data format specified.  Reception of this message
           implies that the receiver is the current owner of the
           clipboard. See clipbord.c */
        MdocRenderFormat( wParam );
        break;

    /*-------CLIPBOARD DISPLAY---------------------*/

    case WM_PAINTCLIPBOARD:
            /* A request to paint the clipboard contents.
               wParam is a handle to the clipboard window
               LOWORD( lParam ) is a handle to a PAINTSTRUCT giving
                    a DC and RECT for the area to repaint */

        MdocPaintClipboard( wParam, LOWORD(lParam) );
        break;

    case WM_VSCROLLCLIPBOARD:
            /* A request to vertically scroll the clipboard contents.
               wParam is a handle to the clipboard window
               LOWORD( lParam ) is the scroll type (SB_)
               HIWORD( lParam ) is the new thumb position (if needed) */

        MdocVscrollClipboard( wParam, LOWORD(lParam), HIWORD(lParam) );
        break;

    case WM_HSCROLLCLIPBOARD:
            /* A request to horizontally scroll the clipboard contents.
               wParam is a handle to the clipboard window
               LOWORD( lParam ) is the scroll type (SB_)
               HIWORD( lParam ) is the new thumb position (if needed) */

        MdocHscrollClipboard( wParam, LOWORD(lParam), HIWORD(lParam) );
        break;

    case WM_SIZECLIPBOARD:
            /* A notification that the clipboard window is being re-sized.
               wParam is a handle to the clipboard window
               LOWORD(lParam) is a handle to a RECT giving the new size */

        MdocSizeClipboard( wParam, LOWORD(lParam) );
        break;

    case WM_ASKCBFORMATNAME:
        /* A request for the name of the CF_OWNERDISPLAY clip format.
           wParam is the max. # of chars to store (including terminator)
           lParam is a long pointer to a buffer in which to store the name */

        MdocAskCBFormatName( (LPCH) lParam, wParam );
        break;
    }

 return TRUE;
}




fnCopyEdit()
{               /* COPY command: copy selection to clipboard */
 extern int vfOwnClipboard;
 typeCP cpFirst;
 typeCP dcp;

 StartLongOp();

 cpFirst = selCur.cpFirst;
 SetUndo( uacReplScrap, docCur, cpFirst, dcp = selCur.cpLim - cpFirst,
          docNil, cpNil, cp0, 0);
 SetUndoMenuStr(IDSTRUndoEdit);

 ClobberDoc(docScrap, docCur, cpFirst, dcp);

#ifdef DCLIP
    {
    char rgch[100];
    wsprintf(rgch,"fnCopyEdit: cpFirst %lu, dcp %lu \n\r", cpFirst, dcp);
    CommSz(rgch);
    }
#endif

 if (ferror)
    NoUndo();
 else
    {
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        MakeScrapUnRunning();
    vfScrapIsPic = vfPictSel;
    }

#ifdef STYLES
(**hpdocdod)[docScrap].docSsht = (**hpdocdod)[docCur].docSsht;
#endif


#if defined(OLE)
    ObjEnumInDoc(docScrap,ObjCloneObjectInDoc);
#endif

ChangeClipboard();      /* Force repaint of clipboard display & Set ownership */

 EndLongOp(vhcIBeam);
}


MakeScrapUnRunning()
{   /* If the 1st para of docScrap is a running head,
       apply a sprm to the whole of docScrap that gives it an rhc code of 0.
       This is to avoid pasting running head stuff into the main part of a doc */

 CHAR rgb [2];
 typeCP cpMacScrap = (**hpdocdod) [docScrap].cpMac;

 if (cpMacScrap != cp0 )
    {
    CachePara( docScrap, cp0 );
    if (vpapAbs.rhc != 0)
        {
        rgb [0] = sprmPRhc;
        rgb [1] = 0;
        AddSprmCps( rgb, docScrap, cp0, cpMacScrap );
        }
    }
}




fnCutEdit()
{               /* CUT command: copy selection to clipboard & delete it */
 extern int vfOwnClipboard;
 typeCP cpFirst, cpLim, dcp;

 ClearInsertLine();     /* Since we will be affecting cp's */

 if (!FWriteOk( fwcDelete ))
        /* Not OK to write on this doc */
    return;

 cpFirst = selCur.cpFirst;
 cpLim = selCur.cpLim;

 if (!ObjDeletionOK(OBJ_CUTTING))
    return;

 StartLongOp();

 SetUndo( uacDelScrap, docCur, cpFirst, dcp = cpLim - cpFirst, docNil,
          cpNil, cp0, 0);
 ClobberDoc(docScrap, docCur, cpFirst, dcp);
 if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
    MakeScrapUnRunning();


 if (!ferror) /* Don't stomp document if Clobber Doc failed	*/
    {
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        MakeScrapUnRunning();
    Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
    }
else
    NoUndo(); /* undo would be invalid */

#ifdef STYLES
(**hpdocdod)[docScrap].docSsht = (**hpdocdod)[docCur].docSsht;
#endif

 vfScrapIsPic = vfPictSel;
 vfPictSel = false;

 ChangeClipboard();     /* Force repaint of clipboard display, get ownership */

#if 0
#if defined(OLE)
    ObjEnumInDoc(docScrap,ObjCloneObjectInDoc);
#endif
#endif

 EndLongOp(vhcIBeam);
}


fnPasteEdit()
{
 /* PASTE command: replace selection    with clipboard contents */
 extern CHAR szDocClass[];
 extern int vfScrapIsPic;
 extern HWND vhWnd;
 HWND hWndClipOwner;
 int fUnFormattedText = FALSE;
 typeCP cpFirst = selCur.cpFirst;
 BOOL bClearScrap=FALSE;

 StartLongOp();

 if ( (hWndClipOwner = GetClipboardOwner()) != vhWnd )
    {   /* Clipboard owner is not this instance of memo */
    if ( (hWndClipOwner == NULL) ||
         !FSameClassHwndSz( hWndClipOwner, szDocClass ))
        {   /* Clipboard owner is not MEMO -- process standard CF_ formats */
        if ( !FReadExtScrap() )
            goto PasteErr;

        bClearScrap = TRUE;
        fUnFormattedText = !vfScrapIsPic;
        }
    else
        {   /* Clipboard owner is another instance of MEMO */
        if (!FGrabExtMemoScrap())
            goto PasteErr;
        }
    }

    /* Replace the selection with the scrap document */
 CmdInsScrap( fUnFormattedText );

 if (ferror)
    goto PasteErr;

#if defined(OLE)
    if (!bClearScrap) // then we're keeping scrap, need to clone
    {
        if (ObjEnumInDoc(docScrap,ObjCloneObjectInDoc) < 0)
            goto PasteErr;
    }

    else // then we're not keeping scrap (came from clipboard)
    {
        /*
        We don't need contents anymore, and if it contains an object,
        then its got to go because its been inserted into the doc and not cloned
        and we don't want a duplicate around.

        Also gotta mark the object in docCur as no longer reusable (if
        it gets copied later we will need to clone it).
        */
        typeCP cpLim = cpFirst+CpMacText(docScrap);
        ClobberDoc(docScrap,docNil,cp0,cp0);
        ObjEnumInRange(docCur,cpFirst,cpLim,ObjFromCloneInDoc);
    }
#endif

 EndLongOp(vhcIBeam);
 return;

PasteErr:
 NoUndo();
 EndLongOp(vhcIBeam);
 _beep();
}



MdocRenderFormat( wCf )
int wCf;
{       /* Render clipboard data in format specified by wCf */
 typeCP cpMac=CpMacText( docScrap );
 struct PICINFOX picInfo;

#if defined(OLE)
    if (vfScrapIsPic)
    {
        GetPicInfo( cp0, cpMac, docScrap, &picInfo );

        if ((picInfo.mfp.mm == MM_OLE) && (wCf != CF_OWNERDISPLAY))
            goto Render;
    }
#endif

 switch (wCf) {

    case CF_OWNERDISPLAY:
            /* Render rich text to another MEMO instance */
        FPutExtMemoScrap();
        break;

    case CF_TEXT:
            /* Remove formatting from scrap; put bare text out to clipboard */
        goto Render;

    case CF_BITMAP:
            if (picInfo.mfp.mm == MM_BITMAP)
                {
                goto Render;
                }
        break;

    case CF_METAFILEPICT:
            /* We can supply this if the scrap is a metafile picture */
            if (picInfo.mfp.mm != MM_BITMAP)
                {
                Render:
                if (!FWriteExtScrap())
                    Error( IDPMTClipLarge );
                }
        break;

 }

}




MdocDestroyClip()
{       /* Handles WM_DESTROYCLIPBOARD message.  We are being notified that
           the clipboard is being emptied & we don't need to keep its
           contents around anymore. */

 extern int vfOwnClipboard;
 extern HWND vhWnd;

 if (fDontDestroyClip)
    return;

 vfOwnClipboard = FALSE;

     /* Clear out the scrap document */
 ClobberDoc( docScrap, docNil, cp0, cp0 );

     /* Disable UNDO operations that require the clipboard */
 switch (vuab.uac) {
 case uacDelScrap:
 case uacUDelScrap:
 case uacReplScrap:
 case uacUReplScrap:
    NoUndo();
    break;
 }

    /* Remove all records of the file we generated in FPutExtMemoScrap
       from the hpfnfcb array.  Note that we assume that no document
       in this instance has pieces of fn. */

if ( fnLastCut != fnNil )
    {
    FreeFn( fnLastCut );
    fnLastCut = fnNil;
    }

    /* If we made a wwd entry for the display of the clipboard,
       remove it now.  We test here to avoid bringing in the
       CLIPDISP module if we never did any display. */
    {
    if (wwClipboard != wwNil)
        FreeWw( wwClipboard );
    }
}




int FPutExtMemoScrap()
{   /* Write docScrap to a new file; send the normalized name
       of the file to the clipboard as data handle for rich text type.
       Assumes clipboard is open for SetClipboardData call.  On exit,
       the file written has an fn, but no document (including docScrap)
       has pieces that point to it.  This allows us to relinquish
       ownership of the fn to the pasting instance.
       RETURN: TRUE == OK, FALSE == ERROR
     */
 int fn;
 CHAR szT[ cchMaxFile ];
 HANDLE hMem;
 LPCH   lpch;
 int cch;
#if defined(OLE)
 int     docTemp;
#endif

    /* Create a new, formatted file with a unique name */
 szT [0] = '\0';    /* Create it on a temp drive in the root */
 if ((fn = FnCreateSz( szT, cp0, dtyNetwork ))== fnNil )
    {
    return FALSE;
    }

 fnLastCut = fn;    /* Save in a static so we can relinquish it later */

    /* Save scrap document to file.  Note that FWriteFn does NOT modify
       the piece table of docScrap, so no document has pieces pointing
       to fn.  This is important because we don't want local pastes
       to generate pieces pointing to this fn; we want to be able to cleanly
       transfer ownership of the fn to another instance */

#if defined(OLE)
 if ((docTemp = CopyScrapToTmp()) == docNil)
 {
    FDeleteFn( fn );    /* This will free the fn even if deleting the file
                           fails */
    return FALSE;
 }
#endif

 if (!FWriteFn( fn, docTemp, TRUE ))
    {
    FDeleteFn( fn );    /* This will free the fn even if deleting the file
                           fails */
    return FALSE;
    }


#if defined(OLE)
 if (docTemp != docScrap)
    KillDoc (docTemp);
#endif

    /* Make a global handle containing the name of the file; send it to the
       clipboard as the rendering of the rich text format */

 if ( ((hMem = GlobalAlloc( GMEM_MOVEABLE, (LONG)(cch=CchSz( szT ))))== NULL ) ||
      ((lpch = GlobalLock( hMem )) == NULL) )
    {
    return FALSE;
    }
 bltbx( (LPCH)szT, lpch, cch );
 GlobalUnlock( hMem );

 SetClipboardData( CF_OWNERDISPLAY, hMem );

 return TRUE;
}




int FGrabExtMemoScrap()
{
/* We get here on a PASTE if the clipboard contains rich text from a
   MEMO instance other than this one.  This routine requests the contents of
   the clipboard from the other instance, and places the contents into docScrap.
   The contents of the clipboard are passed in a MEMO formatted file, whose
   filename is contained in the clipboard's	handle.	 The instance that owns
   the clipboard does not keep any references to the fn for the clipboard
   file (once we EmptyClipboard).  After pasting, this routine arrogates
   the ownership of the clipboard to this instance.
   returns FALSE=error, true=OK */

    extern int vfOwnClipboard;
    extern HWND vhWnd;

    LPCH lpch;
    CHAR szT [cchMaxFile];
    int  fn;
    typeFC dfc;
    HANDLE hData;
    int fOK=false;

    /* Open Clipboard to lock out contenders */

    if ( !OpenClipboard( vhWnd ))
        {
        return FALSE;
        }

    /* Grab clipboard data handle contents: it is a normalized
       filename string referring to a formatted file containing
       the rich text.  The GetClipboardData call actually initiates
       a WM_RENDERFORMAT message to which MdocRenderFormat responds */

    if ( ((hData = GetClipboardData( CF_OWNERDISPLAY )) == NULL ) ||
         ((lpch = GlobalLock( hData )) == NULL ) )
        {
        goto GrabErr;
        }

    bltszx( lpch, (LPCH)szT );
    GlobalUnlock( hData );  /* handle will be freed in EmptyClipboard sequence */

    /* Open the file; replace the contents of the scrap document
       with the contents of the file */

    if ((fn = FnOpenSz( szT, dtyNormal, FALSE )) == fnNil)
        {   /* Unfortunately, if this fails, the file that the other
               instance created will "float", with noone holding an fn
               for it, and it will not get deleted at the end of the session.
               On the bright side, if the reason for the failure was that
               the file never got created anyway, we have done exactly right */
        goto GrabErr;
        }

    {   /* Opened file OK */
    struct FCB *pfcb = &(**hpfnfcb)[fn];
    struct FFNTB **hffntb;
    struct FFNTB **HffntbCreateForFn();
    int wUnused;

    pfcb->fDelete = TRUE;
    dfc = pfcb->fFormatted ? cfcPage : fc0;
    Replace( docScrap,
             cp0,
             (**hpdocdod)[docScrap].cpMac,
             fn,
             dfc,
             pfcb->fcMac - dfc );

    /* give the scrap the correct font table */
    FreeFfntb((**hpdocdod)[docScrap].hffntb);
    if (FNoHeap(hffntb = HffntbCreateForFn(fn, &wUnused)))
            hffntb = 0;
    (**hpdocdod)[docScrap].hffntb = hffntb;
    }

#if defined(OLE)
    /* if there are any objects in there, Load 'em */
    if (ObjEnumInDoc(docScrap,ObjLoadObjectInDoc) < 0)
        fOK = FALSE;
    else
#endif
        fOK = !ferror;     /* All is well if we didn't run out of memory */

        /* Take over ownership of the clipboard.  This results in a
           WM_DESTROYCLIPBOARD message being sent to the other instance,
           which will delete its fn entry for the file so we are the
           exclusive owners */

GrabErr:
    CloseClipboard();
    ChangeClipboard();
    return fOK;
}




ChangeClipboard()
{   /* Mark clipboard as changed.  If we are not the owner of the clipboard, */
    /* make us the owner (via EmptyClipboard).  The EmptyClipboard call */
    /* will result in a WM_DESTROYCLIPBOARD message being sent to the */
    /* owning instance.  The CloseClipboard call will result in a */
    /* WM_DRAWCLIPBOARD message being sent to the clipboard viewer. */
    /* If the clipboard viewer is CLIP.EXE, we will get a WM_PAINTCLIPBOARD */
    /* message */
    /* Added 10/8/85 by BL: If docScrap is empty, relinquish ownership */
    /* of the clipboard */

 extern int vfOwnClipboard;
 extern HWND vhWnd;
 int cf;
 struct PICINFOX picInfo;
 typeCP cpMacScrap = (**hpdocdod) [docScrap].cpMac;

 if (!OpenClipboard( vhWnd ))
    {   /* Couldn't	open the clipboard,	wipe out contents &	disable	UNDO */
    MdocDestroyClip();
    return;
    }

 /* We want to clear out previous data formats in the clipboard.
    Unfortunately, the only way to do this is to call EmptyClipboard(),
    which has the side effect of calling us with a WM_MDOCDESTROYCLIP
    message. We use this primitive global comunication to prevent
    docScrap from being wiped out in MdocDestroyClip() */

 fDontDestroyClip = TRUE;
 EmptyClipboard();
 fDontDestroyClip = FALSE;

 /* Re-validate vfScrapIsPic (in case a docScrap edit changed what it should be */

 CachePara( docScrap, cp0 );
 vfScrapIsPic = (vpapAbs.fGraphics && vcpLimParaCache == cpMacScrap);

 if (!vfScrapIsPic)
    cf = CF_TEXT;
 else
    {
    GetPicInfo( cp0, cpMacScrap, docScrap, &picInfo );
    switch(picInfo.mfp.mm)
    {
        case MM_BITMAP:
            cf = CF_BITMAP;
        break;

        case MM_OLE:
            cf = 0;
        break;

        default:
            cf = CF_METAFILEPICT;
        break;
    }
    }

 vfOwnClipboard = (cpMacScrap != cp0);
 if (vfOwnClipboard)
    {   /* only set handles if we really have something in docScrap */
    SetClipboardData( CF_OWNERDISPLAY, NULL );
    if ((cf != CF_TEXT) && (picInfo.mfp.mm == MM_OLE))
    {
        while (cf = OleEnumFormats(lpOBJ_QUERY_OBJECT(&picInfo),cf))
        {
            if (cf == vcfLink)
                SetClipboardData( vcfOwnerLink, NULL );
            else
                SetClipboardData( cf, NULL );
            //if (cf == vcfNative)
                //SetClipboardData( vcfOwnerLink, NULL );
        }
    }
    else
        SetClipboardData( cf, NULL );
    }

 CloseClipboard();
}

#ifdef JAPAN //T-HIROYN Win3.1
extern typeCP          vcpFetch;
extern int             vcchFetch;
extern CHAR            *vpchFetch;
#endif

CmdInsScrap( fUnFormattedText )
int fUnFormattedText;
{    /* Insert the scrap into the document at the current point (PASTE) */
     /* If fUnFormattedText is TRUE, the scrap is treated as unformatted */
     /* text; that is, the characters are put into the document with the */
     /* formatting that is active at the selection */
extern struct CHP vchpSel;
typeCP cp, dcp;
int cchAddedEol=0;
struct CHP chpT;

if (!FWriteOk( fwcInsert ))
    return;

if ((dcp = CpMacText(docScrap)) == cp0)
    return;

ClearInsertLine();

if (fnClearEdit(OBJ_INSERTING))
    return;

chpT = vchpSel;
cp = selCur.cpFirst;

CachePara( docScrap, cp0 );
if (vpapAbs.fGraphics && cp > cp0)
    { /* Special case for inserting a picture paragraph */
      /* Must put an Eol in front of the picture unless we're
         inserting it at the start of the document or one is there already */

    Assert( !fUnFormattedText );
    (**hpdocdod)[docCur].fFormatted = fTrue;
    CachePara(docCur, cp - 1);
    if (vcpLimParaCache != cp)
        {
        cchAddedEol = ccpEol;

        InsertEolPap(docCur, cp, &vpapAbs);
        dcp += (typeCP)ccpEol;
        }
    }

SetUndo( uacInsert, docCur, cp, dcp, docNil, cpNil, cp0, 0 );

SetUndoMenuStr(IDSTRUndoEdit);
ReplaceCps(docCur, cp + (typeCP)cchAddedEol, cp0, docScrap, cp0,
                                        dcp - (typeCP)cchAddedEol);
if (ferror) /* Not enough memory to do replace operation */
    NoUndo();  /* should not be able to undo what never took place */
else
    {
    typeCP cpSel=CpFirstSty( cp + dcp, styChar );

    if (vfScrapIsPic && vuab.uac == uacReplNS)
            /* Special UNDO code for picture paste */
        vuab.uac = uacReplPic;

    if (fUnFormattedText)
        {   /* If pasting unformatted text, give it the props at the selection */
        CHAR rgch[ cchCHP + 1 ];

        rgch [0] = sprmCSame;
#ifdef JAPAN //T-HIROYN Win3.1
            {
                struct CHP savechpT;
                typeCP  cpF, cpFirst, cpLim, kcpF, kcpL;
                int     cchF;
                int     kanjiftc, alphaftc;
                CHAR    *rp;
                CHAR    ch;
                int     cch, cblen;

                if(NATIVE_CHARSET != GetCharSetFromChp(&chpT)) {
                    kanjiftc = GetKanjiFtc(&chpT);
                    alphaftc = GetFtcFromPchp(&chpT);
                    savechpT = chpT;
                    cpFirst = cp;

                    do {
                        FetchCp(docCur, cpFirst, 0, fcmChars);
                        cpF = vcpFetch;
                        cchF = vcchFetch;
                        kcpF = cpF;

                        if ((cpF+cchF) < cp + dcp)
                            cpLim = (cpF+cchF);
                        else
                            cpLim = cp + dcp;

                        cch = 0;
                        rp = vpchFetch;

                        while ( kcpF < cpLim ) {
                            ch = *rp;

                            if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                                cblen = GetKanjiStringLen(cch, cchF, rp);
                                chpT.ftc = kanjiftc;
                            } else {
                                cblen = GetAlphaStringLen(cch, cchF, rp);
                                chpT.ftc = alphaftc;
                            }

                            kcpL = kcpF + cblen;
                            cch += cblen;
                            rp  += cblen;

                            bltbyte( &chpT, &rgch [1], cchCHP );
                            AddSprmCps(rgch, docCur, kcpF, kcpL);

                            kcpF = kcpL;
                        }
						cpFirst = kcpF;
                    } while ((cpF + cchF) < cp + dcp );
                    chpT = savechpT;
                } else {
                    bltbyte( &chpT, &rgch [1], cchCHP );
                    AddSprmCps( rgch, docCur, cp, cp + dcp );
                } //END IF ELSE
            } // END JAPAN
#else
        bltbyte( &chpT, &rgch [1], cchCHP );
        AddSprmCps( rgch, docCur, cp, cp + dcp );
#endif
        }
    Select( cpSel, cpSel );
    vchpSel = chpT; /* Preserve insert point props across this operation */
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {   /* If running head/foot, remove chSects & set para props */
        MakeRunningCps( docCur, cp, dcp );
        }
    if (ferror)
        NoUndo();
    }

vfSeeSel = true;    /* Tell Idle() to scroll the selection into view */
}


#if defined(OLE)
int NEAR PASCAL CopyScrapToTmp(void)
/*
    If scrap doesn't contain OLE objects, return docScrap.  Else 
    create docTemp and copy docScrap into it.  Make sure objects
    all have their data and have their lpObjInfos NULL'd out.
*/
{
    extern typeCP cpMinCur, cpMacCur, cpMinDocument;
    typeCP  cpMinCurT       = cpMinCur,
            cpMacCurT       = cpMacCur,
            cpMinDocumentT  = cpMinDocument;
    int     docTemp         = docNil,
            docReturn       = docNil;

    /* are there any objects? */
    switch (ObjEnumInDoc(docScrap,NULL))
    {
        case -1: // error
        return docNil;
        case 0:  // no objects in scrap
        return docScrap;
    }

    /* Create copy of document */
    if ((docTemp = DocCreate(fnNil, HszCreate(""), dtyNormal)) == docNil)
        return docNil;

    /* copy scrap to docTemp */
    ClobberDoc(docTemp, docScrap, cp0, CpMacText(docScrap));

    if (ferror)
        goto error;

    /* now save objects to make sure their data is present */
    {
        OBJPICINFO picInfo;
        typeCP cpPicInfo;

        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,docTemp,cp0,CpMacText(docTemp),&cpPicInfo);
            )
        {
            OBJINFO ObjInfoSave;
            typeCP cpRetval;

            if (picInfo.lpObjInfo == NULL)
                continue;

            ObjInfoSave = *picInfo.lpObjInfo;

            cpRetval = ObjSaveObjectToDoc(&picInfo,docTemp,cpPicInfo);

            /*
                Do this just in case saving the object to docTemp changes the
                object's state.  We don't want the object to appear clean
                or saved when in fact it isn't or hasn't been except in docTemp,
                which will be deleted by the calling routine.
            */
            *picInfo.lpObjInfo = ObjInfoSave;

            if (cpRetval == cp0) // save failed
                goto error;

            /* so pasting instance will reload object */
            picInfo.lpObjInfo = NULL;
            ObjSetPicInfo(&picInfo,docTemp,cpPicInfo);
        }
    }

    /* success */
    docReturn = docTemp;

    error:

    if ((docReturn == docNil) && (docTemp != docNil))
        KillDoc(docTemp);

    /* Restore cpMinCur, cpMacCur */
    cpMinCur = cpMinCurT;
    cpMacCur = cpMacCurT;
    cpMinDocument = cpMinDocumentT; /* destroyed possibly by DocCreate */

    return docReturn;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\cache.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* cache.c -- Paragraph attribute fetching and caching for WRITE */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NOATOM
#define NOMETAFILE
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOPEN
#define NOBITMAP
#define NOCOLOR
#define NODRAWTEXT
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NORESOURCE
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "fmtdefs.h"
#define NOKCCODES
#include "ch.h"
#include "prmdefs.h"
#include "debug.h"

extern int              vfDiskError;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern typeFC           fcMacPapIns;
extern struct           FCB (**hpfnfcb)[];
extern struct           FKPD vfkpdParaIns;
extern int              ichInsert;
extern CHAR             rgchInsert[];
extern int              vdocExpFetch;
extern int              vdocSectCache;
extern typeCP           vcpFirstSectCache;
extern typeCP           vcpLimSectCache;
extern int              vdocPageCache;
extern typeCP           vcpMinPageCache;
extern typeCP           vcpMacPageCache;
extern typeCP           cpMinCur;

extern struct PAP      vpapAbs;
extern struct PAP      *vppapNormal;
extern struct DOD (**hpdocdod)[];
extern struct FLI vfli;
extern int              vdxaPaper;
extern int              vdyaPaper;
extern typePN           PnFkpFromFcScr();


extern int     vdocParaCache;
extern int                     visedCache;
extern int              vdocPageCache;

extern struct SEP              vsepAbs;
extern struct SEP               vsepPage;
extern struct SEP       vsepNormal;

extern   int      ctrCache;
extern   int      itrFirstCache;
extern   int      itrLimCache;
extern   typeCP   cpCacheHint;

CHAR *PchFromFc();
CHAR *PchGetPn();

CachePara(doc, cp)
int doc;
typeCP cp;
{ /* Make the para containing <doc, cp> the currently cached para */
struct PCD *ppcd, *ppcdBase;
typeCP cpMac, cpGuess;
struct DOD *pdod;
int     dty;
struct PCTB *ppctb;

if (vdocParaCache == doc && vcpFirstParaCache <= cp &&
    cp < vcpLimParaCache)
        return; /* That's what the cache is for */

Assert(cp >= cp0);

pdod = &(**hpdocdod)[doc];
dty = pdod->dty;
if (cp >= pdod->cpMac)
        { /* Use normal para for end mark and beyond */
#ifdef ENABLE   /* Occasionally this is not true (but it should be) */
        Assert( cp == pdod->cpMac );
#endif

        if (cp > cpMinCur)
            {   /* this piece of code treats the case when the whole document
                   is a non-empty semi-paragraph (chars but no EOL's) */
            CachePara( doc, cp - 1 );   /* Recursion will not happen */
            if ( vcpLimParaCache > cp )
                {
                vcpLimParaCache = pdod->cpMac + ccpEol;
                return;
                }
             }
        vdocParaCache = doc;
        vcpLimParaCache = (vcpFirstParaCache = pdod->cpMac) + ccpEol;
        DefaultPaps( doc );
        return;
        }

FreezeHp();
ppctb = *pdod->hpctb;
ppcdBase = &ppctb->rgpcd [ IpcdFromCp( ppctb, cpGuess = cp ) ];

if (vdocParaCache == doc && cp == vcpLimParaCache)
        vcpFirstParaCache = cp;
else
        { /* Search backward to find para start */
        for (ppcd = ppcdBase; ; --ppcd)
                { /* Beware heap movement! */
                typeCP cpMin = ppcd->cpMin;
                int fn = ppcd->fn;
                if (! ppcd->fNoParaLast)
                        { /* Don't check if we know there's no para end */
                        typeFC fcMin = ppcd->fc;
                        typeFC fc;

                        if ((fc = FcParaFirst(fn,
                            fcMin + cpGuess - cpMin, fcMin)) != fcNil)
                                { /* Found para begin */
                                vcpFirstParaCache = cpMin + (fc - fcMin);
                                break;
                                }
                        }
                /* Now we know there's no para end from cpMin to cpGuess. */
                /* If original piece, may be one after cp */
#ifdef BOGUSBL
                /* vfInsertMode protects against a critical section in insert */
                /* when the CR is already inserted but the supporting PAP structure */
                /* is not in place yet */

                if (cp != cpGuess && fn != fnInsert && !vfInsertMode)
#else           /* Insert CR works differently now, above test slows us down
                   by forcing many calls to FcParaLim */
                if (cp != cpGuess)
#endif
                        ppcd->fNoParaLast = true; /* Save some work next time */
                if (cpMin == cp0)
                        { /* Beginning of doc is beginning of para */
                        vcpFirstParaCache = cpMinCur;
                        break;
                        }

                /** Some low memory error conditions may cause ppctb to be 
                    messed up **/
                if (ppcd == ppctb->rgpcd)
                {
                    Assert(0);
                    vcpFirstParaCache = cp0; // hope for divine grace
                    break;
                }

                cpGuess = cpMin;
                }
        }

vdocParaCache = doc;
/* Now go forward to find the cpLimPara */
cpMac = pdod->cpMac;
cpGuess = cp;

for (ppcd = ppcdBase; ; ++ppcd)
        {
        typeCP cpMin = ppcd->cpMin;
        typeCP cpLim = (ppcd + 1)->cpMin;
        typeFC fc;
        int fn = ppcd->fn;

        if (! ppcd->fNoParaLast)
                { /* Don't check if we know there's no para end */
                typeFC fcMin = ppcd->fc;
                if ((fc = FcParaLim(fn, fcMin + cpGuess - cpMin,
                    fcMin + (cpLim - cpMin), &vpapAbs)) != fcNil)
                        { /* Found para end */
                        vcpLimParaCache = cpMin + (fc - fcMin);
                        /* Under Write, FcParaLim can't set the correct rgtbd */
                        /* That's because tabs are a DOCUMENT property */
                        /* We set it here instead */
                        GetTabsForDoc( doc );
                        break;
                        }
                }
        /* Now we know there's no para end. */
#ifdef BOGUSBL
        /* The check for vfInsertMode is necessary because of a critical */
        /* section in insertion between the insertion of a CR and the call */
        /* to AddRunScratch */
        if (cp != cpGuess && fn != fnInsert && !vfInsertMode)
#else   /* Insert CR has changed, we no longer try to pretend that
           the CR is not in the scratch file piece before the run is
           added. This new approach gains us speed, especially during backspace */
        if (cp != cpGuess)
#endif
                ppcd->fNoParaLast = true;    /* Save some work next time */
        if (cpLim == cpMac)
                { /* No EOL at end of doc */
                vcpLimParaCache = cpMac + ccpEol;
                MeltHp();
                DefaultPaps( doc );
                return;
                }
        /** Some low memory error conditions may cause ppctb to be 
            messed up **/
        else if ((cpLim > cpMac) || (ppcd == (ppctb->rgpcd + ppctb->ipcdMac - 1)))
        {
            Assert(0);
            vcpLimParaCache = cpMac + ccpEol; // hope for divine grace
            MeltHp();
            DefaultPaps( doc );
            return;
        }
        cpGuess = cpLim;
        }

/* Don't bother with properties for buffers */
#ifdef ENABLE       /* No buffers or styles in MEMO */
if (dty != dtyBuffer || pdod->docSsht != docNil)
#endif
        {
        struct PRM prm = ppcd->prm;
        if (!bPRMNIL(prm))
                DoPrm((struct CHP *) 0, &vpapAbs, prm);
#ifdef STYLES
        blt(vpapCache.fStyled ? PpropXlate(doc, &vpapCache, &vpapCache) :
            &vpapCache, &vpapAbs, cwPAP);
#endif /* STYLES */
        }

/* This little piece of code is necessary to provide compatibility between Word
and Memo documents.  It compresses the entire range of line spacing into single
spacing, one and one-half spacing, and double spacing. */
if (vpapAbs.dyaLine <= czaLine)
    {
    vpapAbs.dyaLine = czaLine;
    }
else if (vpapAbs.dyaLine >= 2 * czaLine)
    {
    vpapAbs.dyaLine = 2 * czaLine;
    }
else
    {
    vpapAbs.dyaLine = (vpapAbs.dyaLine + czaLine / 4) / (czaLine / 2) *
      (czaLine / 2);
    }

MeltHp();
}




DefaultPaps( doc )
int doc;
{
typeCP cpFirstSave, cpLimSave;
struct TBD (**hgtbd)[];

if (vcpFirstParaCache > cpMinCur)
        { /* Get pap from previous paragraph */
        cpFirstSave = vcpFirstParaCache;
        cpLimSave = vcpLimParaCache;
        CachePara(doc, cpFirstSave - 1); /* Recursion should not happen */
        vpapAbs.fGraphics = false; /* Don't make last para a picture */
        vpapAbs.rhc = 0;        /* Don't make last para a running head */
        vcpLimParaCache = cpLimSave;
        vcpFirstParaCache = cpFirstSave;
        return;
        }
#ifdef CASHMERE
blt(vppapNormal, &vpapAbs, cwPAPBase+cwTBD);
#else   /* For MEMO, the default PAPS have the document's tab table */
blt(vppapNormal, &vpapAbs, cwPAPBase);
GetTabsForDoc( doc );
#endif

#ifdef STYLES
blt(&vpapNormal, &vpapCache, cwPAP);
blt(PpropXlate(doc, &vpapNormal, &vpapStd), &vpapAbs, cwPAP);
#endif
}




GetTabsForDoc( doc )
int doc;
{   /* Get tab table for passed document into vpapAbs.rgtbd */
struct TBD (**hgtbd)[];

hgtbd = (**hpdocdod)[doc].hgtbd;
if (hgtbd==0)
    bltc( vpapAbs.rgtbd, 0, cwTBD * itbdMax );
else
    blt( *hgtbd, vpapAbs.rgtbd, cwTBD * itbdMax );
}



#ifdef CASHMERE
CacheSect(doc, cp)
int doc;
typeCP cp;
{
struct SETB **hsetb, *psetb;
struct SED *psed;
CHAR *pchFprop;
int cchT;
struct DOD *pdod;

if (doc == vdocSectCache && cp >= vcpFirstSectCache && cp < vcpLimSectCache)
        return;

if ( vdocSectCache != doc && cp != cp0 )
    CacheSect( doc, cp0 );  /* Changing docs, assure vsepPage is accurate */

vdocSectCache = doc;
visedCache = iNil;
blt(&vsepNormal, &vsepAbs, cwSEP);

if ((hsetb = HsetbGet(doc)) == 0)
        {
        vcpFirstSectCache = cp0;
        vcpLimSectCache =  (pdod = &(**hpdocdod)[doc])->cpMac + 1;
        blt(&vsepAbs, &vsepPage, cwSEP);        /* set up page info */
        return;
        }

psetb = *hsetb;
psed = psetb->rgsed;

FreezeHp();
psed += (visedCache = IcpSearch(cp + 1, psed, cchSED, bcpSED, psetb->csed));

Assert( (visedCache >= 0) && (visedCache < psetb->csed) );

vcpFirstSectCache = (visedCache == 0) ? cp0 : (psed - 1)->cp;
vcpLimSectCache = psed->cp;

if (psed->fc != fcNil)
    {
    pchFprop = PchFromFc(psed->fn, psed->fc, &cchT);
    if (*pchFprop != 0)
        bltbyte(pchFprop + 1, &vsepAbs, *pchFprop);
    }

if (vcpFirstSectCache == cp0)
    blt(&vsepAbs, &vsepPage, cwSEP);
else
    RecalcSepText();    /* Since this is not the first section of a document,
                         the margins could be wrong and must be recalculated */
MeltHp();
}
#endif  /* CASHMERE */



CacheSect(doc, cp)
int doc;
typeCP cp;
{           /* Get current section properties into vsepAbs; section
               limits into vcpFirstSectCache, vcpLimSectCache
               MEMO VERSION: one section per document */
 struct DOD *pdod;

 if (doc == vdocSectCache)
    return;

 vdocSectCache = doc;
 pdod = &(**hpdocdod)[doc];

 if ( pdod->hsep )
    blt( *pdod->hsep, &vsepAbs, cwSEP );
 else
    blt( &vsepNormal, &vsepAbs, cwSEP );

 vcpFirstSectCache = cp0;
 vcpLimSectCache = pdod->cpMac;
 blt(&vsepAbs, &vsepPage, cwSEP);
}




RecalcSepText()
{
/* calculate value to be changed because of change in page dimensions */
int xaRight, dxaText, cColumns;
int yaBottom, dyaText;

xaRight = vsepPage.xaMac - vsepPage.cColumns * vsepPage.dxaText -
          vsepPage.xaLeft - vsepPage.dxaGutter -
          (vsepPage.cColumns - 1) * vsepPage.dxaColumns;
dxaText = vdxaPaper - xaRight - vsepPage.xaLeft;
cColumns = vsepAbs.cColumns;
vsepAbs.dxaText = max(dxaMinUseful,
       ((dxaText-vsepPage.dxaGutter-(cColumns-1)*vsepAbs.dxaColumns)/cColumns));
vsepAbs.xaMac = vdxaPaper;

 /* Calculate bottom margin, correct */
yaBottom = vsepPage.yaMac - vsepPage.yaTop - vsepPage.dyaText;
vsepAbs.dyaText = max(dyaMinUseful, vdyaPaper - vsepPage.yaTop - yaBottom);
vsepAbs.yaMac = vdyaPaper;
}




InvalidateCaches(doc)
int doc;
{
if (doc == vfli.doc)    /* Invalidate current formatted line */
        vfli.doc = docNil;
if (doc == vdocExpFetch)
        vdocExpFetch = docNil;
if (doc == vdocParaCache)
        vdocParaCache = docNil;
if (doc == vdocSectCache)
        vdocSectCache = docNil;

/* When the current doc is equal to the cached doc, it is unnecessary */
/*  to invalidate the page cache when the vcpMinPageCache is 0 and the  */
/*  vcpMacPageCache is cpMax, since this indicates that all characters in  */
/*  the document are on page 1.           */
if ((doc == vdocPageCache) &&
    (!(vcpMinPageCache == cp0 && vcpMacPageCache == cpMax)))
        vdocPageCache = docNil;
}




TrashCache()
{ /* Invalidate scrolling cache */
ctrCache = 0;
cpCacheHint = cp0;
itrFirstCache = itrLimCache = 0;
}




typeFC FcParaFirst(fn, fc, fcMin)
int fn;
typeFC fc, fcMin;
{ /* Return the fc after the latest para end before fc.
        if there is no para end in [fcMin, fc), return fcNil. */
struct FCB *pfcb;

if ((fn == fnInsert) || (fc == fcMin))
    return fcNil;

if (fn == fnScratch && fc >= fcMacPapIns)
    return (fcMin <= fcMacPapIns) ? fcMacPapIns : fcNil;

pfcb = &(**hpfnfcb)[fn];
if (!pfcb->fFormatted)
    { /* Unformatted file; scan for an EOL */
    typePN pn;
    typeFC fcFirstPage;

#ifdef p2bSector
    fcFirstPage = (fc - 1) & ~(cfcPage - 1);
    pn = fcFirstPage / cfcPage;
#else
    pn = (fc - 1) / cfcPage;
    fcFirstPage = pn * cfcPage;
#endif

    while (fc > fcMin)
        {
        CHAR *pch;
        int cchT;

        pch = PchGetPn( fn, pn--, &cchT, false ) + (fc - fcFirstPage);
        if (fcMin > fcFirstPage)
            fcFirstPage = fcMin;
        while (fc > fcFirstPage)
            {
            if (*(--pch) == chEol)
                {
                return fc;
                }
            fc--;
            }
        fcFirstPage -= cfcPage;
        }
    return fcNil;
    }
else
    { /* Formatted file; get info from para run */
    struct FKP *pfkp;
    typeFC fcFirst, fcLim;
    int cchT;

    pfkp = (struct FKP *) PchGetPn(fn, fn == fnScratch ?
        PnFkpFromFcScr(&vfkpdParaIns, fc) :
          pfcb->pnPara + IFromFc(**pfcb->hgfcPap, fc), &cchT, false);
    if (vfDiskError)
        return fcNil;
    BFromFc(pfkp, fc, &fcFirst, &fcLim);
    return (fcMin < fcFirst) ? fcFirst : fcNil;
    }
}




typeFC FcParaLim(fn, fc, fcMac, ppap)
int fn;
typeFC fc, fcMac;
struct PAP *ppap;
{ /* Return the fc after the first para end after or at fc.
        if there is no para end in [fc, fcMac), return fcNil. */
/* Also return paragraph properties in ppap */
 struct FCB *pfcb;

/* Start out by feeding caller the normal pap */
#ifdef CASHMERE
 blt(vppapNormal, ppap, cwPAPBase + cwTBD);
#else
 blt(vppapNormal, ppap, cwPAPBase);
#endif

 if ( (fn == fnInsert) || ((fn == fnScratch) && (fc >= fcMacPapIns)) )
        return fcNil;

 if (!(pfcb = &(**hpfnfcb) [fn])->fFormatted)
        { /* Unformatted file; scan for EOL */
        typePN pn;
        typeFC fcFirstPage;

#ifdef p2bSector
        fcFirstPage = fc & ~(cfcPage - 1);
        pn = fcFirstPage / cfcPage;
#else
        pn = fc / cfcPage;
        fcFirstPage = pn * cfcPage;
#endif

        while (fc < fcMac)
                {
                CHAR *pch;
                int cchT;

                pch = PchGetPn( fn, pn++, &cchT, false ) + (fc - fcFirstPage);

                if ((fcFirstPage += cfcPage) > fcMac)
                        fcFirstPage = fcMac;
                while (fc < fcFirstPage)
                        {
                        fc++;
                        if (*pch++ == chEol)
                                return fc;
                        }
                }
        return fcNil;
        }
else
        { /* Formatted file; get info from para run */
        struct FKP *pfkp;
        struct FPAP *pfpap;
        int bfpap;
        typeFC fcLim;
        int cchT;

        pfkp = (struct FKP *) PchGetPn(fn, fn == fnScratch ?
            PnFkpFromFcScr(&vfkpdParaIns, fc) :
              pfcb->pnPara + IFromFc(**pfcb->hgfcPap, fc), &cchT, false);
        if (vfDiskError)
            {   /* Recover from severe disk error reading formatting info */
            blt(vppapNormal, ppap, cwPAP);
            return (fcMac == pfcb->fcMac) ? fcMac : fcNil;
            }

        {   /* In-line, fast substitute for BFromFc */
        register struct RUN *prun = (struct RUN *) pfkp->rgb;

        while (prun->fcLim <= fc)
            prun++;

        fcLim = prun->fcLim;
        bfpap = prun->b;
        }

        if (fcLim <= fcMac)
                {
                if (bfpap != bNil)
                        { /* Non-standard para */
                        pfpap = (struct FPAP *) &pfkp->rgb[bfpap];
                        bltbyte(pfpap->rgchPap, ppap, pfpap->cch);
                        }
                return fcLim;
                }
        return fcNil;
        }
}


/* B  F R O M  FC */
int BFromFc( pfkp, fc, pfcFirst, pfcLim )
struct FKP *pfkp;
typeFC fc;
typeFC *pfcFirst, *pfcLim;
{   /* Return the base offset & bounds for the first run with fcLim > fc. */
    /* Short table, linear search */
 register struct RUN *prun = (struct RUN *) pfkp->rgb;

 while (prun->fcLim <= fc)
    prun++;

 *pfcFirst = ((prun == (struct RUN *)pfkp->rgb) ?
                                       pfkp->fcFirst : (prun - 1)->fcLim);
 *pfcLim = prun->fcLim;
 return prun->b;
}



/* I  F R O M  F C */
int IFromFc(pfcLim, fc)
register typeFC *pfcLim;
typeFC fc;
{ /* Return the index of the first fcLim > fc. */
int ifc = 0;

/* Probably a small table, so linear search? */
while (*pfcLim++ <= fc)
        ++ifc;
return ifc;
}





#ifdef BOGUSBL
/*  B  F R O M   F C */
int BFromFc(pfkp, fc, pfcFirst, pfcLim)
struct FKP *pfkp;
typeFC fc;
typeFC *pfcFirst, *pfcLim;
{ /* Return the base offset & bounds for the first run with fcLim > fc. */
struct RUN *prun, *rgrun;
int ifcMin, ifcLim;

ifcMin = 0;
ifcLim = pfkp->crun;
rgrun = (struct RUN *)pfkp->rgb;

#ifdef INEFFICIENT
ifc = IcpSearch(fc + 1, pfkp->rgb, cchRUN, bfcRUN, pfkp->crun);
#endif

while (ifcMin + 1 < ifcLim)
        {
        int ifcGuess = (ifcMin + ifcLim - 1) >> 1;
        if (rgrun[ifcGuess].fcLim <= fc)
                ifcMin = ifcGuess + 1;
        else
                ifcLim = ifcGuess + 1;
        }

prun = &rgrun[ifcMin];
*pfcLim = prun->fcLim;
*pfcFirst = (ifcMin == 0 ? pfkp->fcFirst : (prun - 1)->fcLim);
return prun->b;
}
#endif  /* BOGUSBL */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\clipdisp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* clipdisp.c -- Clipboard display routines */
/* This module only gets called in when the clipboard view window is up */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCTLMGR
#include "windows.h"

#include "mw.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "str.h"
#include "propdefs.h"
#include "editdefs.h"
#include "winddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#define SCRIBBLE
#include "debug.h"

extern int              docCur;     /* Document in current ww */
extern int              docScrap;
extern struct WWD       rgwwd [];


int NEAR FGetClipboardDC( void );
int NEAR SetupClipboardDC( void );
int NEAR ReleaseClipboardDC( void );


MdocPaintClipboard( hWnd, hPS )
HWND   hWnd;
HANDLE hPS;
{   /* Paint portion of clipboard window indicated by hPS */
 LPPAINTSTRUCT lpps;

 if (wwClipboard == wwNil)
    return;

 /* Must set the scroll bar range each time we get a PAINT message;
    CLIPBRD.EXE resets it when it gets WM_DRAWCLIPBOARD */

 SetScrollRange( wwdClipboard.wwptr, SB_VERT, 0, drMax-1, FALSE );
 SetScrollRange( wwdClipboard.wwptr, SB_HORZ, 0, xpRightLim, FALSE );

 if ( (lpps = (LPPAINTSTRUCT)GlobalLock( hPS )) != NULL )
    {   /* Paint the clipboard */
    wwdClipboard.hDC = lpps->hdc;
    SetupClipboardDC();
    NewCurWw( wwClipboard, TRUE );
    InvalBand( &wwdClipboard, lpps->rcPaint.top, lpps->rcPaint.bottom - 1 );
    UpdateWw( wwClipboard, FALSE );
    NewCurWw( wwDocument, TRUE );
    GlobalUnlock( hPS );
    }

    /* Since the DC is no longer good, we'll set it to NULL */
  wwdClipboard.hDC = NULL;

#if 0
#if defined(OLE)
    /* gotta delete objects loaded from scrap document */
    ObjEnumInDoc(docScrap,ObjDeleteObjectInDoc);
#endif
#endif
}




MdocSizeClipboard( hWnd, hRC )
HWND    hWnd;
HANDLE  hRC;
{   /* Set clipboard window to be the rect in hRC */
    /* If rectangle is 0 units high or wide, this means we're losing the
        necessity for display until the next size message */
 LPRECT lprc;
 int    dypRect;

 if ( (lprc = (LPRECT)GlobalLock( hRC )) == NULL )
    return;

 if ( (dypRect = lprc->bottom - lprc->top) <= 0 )
    {   /* NULL rect, means lose display until we get a nonnull size */
    if (wwClipboard != wwNil)
        FreeWw( wwClipboard );
    }
 else if ( (wwClipboard != wwNil) ||
           ((wwClipboard=WwAlloc( hWnd, docScrap )) != wwNil))
        {   /* Have WWD entry for clipboard, set its size */

        wwdClipboard.wwptr = hWnd;  /* Just in case clipboard
                                       was closed, then re-opened */
        wwdClipboard.xpMin = lprc->left;
        wwdClipboard.xpMac = lprc->right;
        wwdClipboard.ypMin = lprc->top;
        wwdClipboard.ypMac = lprc->bottom;
#ifdef WIN30        
        SetScrollPos(hWnd, SB_HORZ, 0, TRUE); /* suggested by sankar */
#endif
        }

 GlobalUnlock( hRC );
}




MdocVScrollClipboard( hWnd,  sbMessage, wNewThumb )
HWND    hWnd;
int     sbMessage;
int     wNewThumb;
{
 if ( hWnd != wwdClipboard.wwptr || wwClipboard == wwNil)
    {
    Assert( FALSE );
    return;
    }

 if (!FGetClipboardDC())
        /* Unable to create clipboard device context */
    return;

 NewCurWw( wwClipboard, TRUE );

switch ( sbMessage )
{
case SB_THUMBPOSITION:
    {
    extern typeCP cpMacCur;

    DirtyCache( wwdClipboard.cpFirst = (cpMacCur - wwdClipboard.cpMin) *
                        wNewThumb / (drMax - 1) + wwdClipboard.cpMin);
    wwdClipboard.ichCpFirst = 0;
    wwdClipboard.fCpBad = TRUE;
    TrashWw( wwClipboard );
    break;
    }

case SB_LINEUP:
    ScrollUpCtr( 1 );
    break;
case SB_LINEDOWN:
    ScrollDownCtr( 1 );
    break;
case SB_PAGEUP:
    ScrollUpDypWw();
    break;
case SB_PAGEDOWN:
    ScrollDownCtr( 100 );   /* 100 > tr's in a page */
    break;
}

UpdateWw( wwClipboard, FALSE );

NewCurWw( wwDocument, TRUE );          /* Frees the memory DC */
ReleaseClipboardDC();
}




MdocHScrollClipboard( hWnd,  sbMessage, wNewThumb )
HWND    hWnd;
int     sbMessage;
int     wNewThumb;
{
 if ( hWnd != wwdClipboard.wwptr || wwClipboard == wwNil)
    {
    Assert( FALSE );
    return;
    }

 if (!FGetClipboardDC())
        /* Unable to create clipboard device context */
    return;

 NewCurWw( wwClipboard, TRUE );

 switch (sbMessage)
    {
    case SB_LINEUP:     /* line left */
        ScrollRight(xpMinScroll);
        break;
    case SB_LINEDOWN:   /* line right */
        ScrollLeft(xpMinScroll);
        break;
    case SB_PAGEUP:     /* page left */
        ScrollRight(wwdClipboard.xpMac - xpSelBar);
        break;
    case SB_PAGEDOWN:   /* page right */
        ScrollLeft(wwdClipboard.xpMac - xpSelBar);
        break;
    case SB_THUMBPOSITION:
        /* position to posNew */
        AdjWwHoriz( wNewThumb - wwdClipboard.xpMin );
        break;
    }

UpdateWw( wwClipboard, FALSE );

NewCurWw( wwDocument, TRUE );          /* Frees the memory DC */
ReleaseClipboardDC();
}




MdocAskCBFormatName( lpchName, cchNameMax )
LPCH lpchName;
int cchNameMax;
{   /* Copy the format name for the current contents of the clipboard
       (of which we are the owner) to lpchName, copying no more than
        cchNameMax characters */

extern int vfOwnClipboard;
extern int vfScrapIsPic;
extern CHAR szWRITEText[];
int cchCopy;

Assert( vfOwnClipboard );

/* Don't give a format name for pictures; the name is covered by the
   standard types */

if (!vfScrapIsPic)
    {
    if ( (cchCopy=CchSz( szWRITEText )) > cchNameMax )
        {
        lpchName[ cchCopy = cchNameMax - 1 ] = '\0';
        }

    bltbx( (LPSTR)szWRITEText, (LPSTR)lpchName, cchCopy );
    }

}




int NEAR FGetClipboardDC()
{   /* Get a DC for the clipboard window.  Leave it in rgwwd [wwClipboard].
       Call SetupClipboardDC to set up proper colors */

 if ((wwdClipboard.hDC = GetDC( wwdClipboard.wwptr )) == NULL )
    return FALSE;

 SetupClipboardDC();
 return TRUE;
}

int NEAR SetupClipboardDC()
{  /*  Select in the background brush for appropriate color behavior. */

 extern long rgbBkgrnd;
 extern long rgbText;
 extern HBRUSH hbrBkgrnd;

SelectObject( wwdClipboard.hDC, hbrBkgrnd );
SetBkColor( wwdClipboard.hDC, rgbBkgrnd );
SetTextColor( wwdClipboard.hDC, rgbText );
}



int NEAR ReleaseClipboardDC()
{
ReleaseDC( wwdClipboard.wwptr, wwdClipboard.hDC );
wwdClipboard.hDC = NULL;    /* Mark clipboard DC as invalid */
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\clipbrd2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Clipbrd2.c -- less frequently used clipboard routines */

#define NOWINMESSAGES
#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOVIRTUALKEYCODES
#define NOMENUS
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOOPENFILE
#define NOSOUND
#define NOCOMM
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOWH
#define NOSCROLL
#define NOPEN
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "winddefs.h"
#include "fmtdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#if defined(JAPAN) & defined(DBCS_IME)
#include "prmdefs.h"        /* IME: use sprmCSame in CmdInsIRString() */
#else
#define NOSTRMERGE
#define NOSTRUNDO
#endif

#include "str.h"

#define NOIDISAVEPRINT
#define NOIDIFORMATS
#include "dlgdefs.h"
#include "wwdefs.h"
#include "debug.h"

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
#include "fontdefs.h"
#include "kanji.h"
extern struct CHP vchpSel;
#endif

extern struct WWD   rgwwd[];
extern int              wwMac;
extern struct DOD       (**hpdocdod)[];
extern int              docCur;     /* Document in current ww */
extern int              docMac;
extern int              ferror;
extern int              docScrap;

#if  defined(JAPAN) & defined(DBCS_IME)     /* Document for IRSTRING */
extern int              docIRString;
#include <ime.h>
extern int              wwCur;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
typeCP selUncpFirst = cp0;
typeCP selUncpLim   = cp0;
HANDLE hImeUnAttrib = NULL;
HANDLE hImeUnString = NULL;
BOOL   ImeClearInsert = FALSE;
struct CHP vchpHidden;
extern int     HiddenTextTop;
extern int     HiddenTextBottom;
// 12/28/92
extern BOOL    whileUndetermine; // if TRUE we are managing IR_UNDETERMINE
#endif

#endif

extern struct PAP       vpapAbs;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern struct PAP       *vppapNormal;
extern struct CHP       vchpNormal;
extern int              vfScrapIsPic;
extern typeCP           vcpLimParaCache;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              vfOwnClipboard;
extern struct FLI       vfli;


#if WINVER >= 0x300
/* We can copy more than 64k in the clipboard and need to
   correctly handle when we cross segment boundaries.  See
   note in bltbh() ..pault */
void bltbh(HPCH, HPCH, int);
#define  bltbx(from,to,count)      bltbh(from,to,count)
#define  LPCHCLIP   HPCH
#else
#define  LPCHCLIP   LPCH
#endif /* if-else-WINVER */


FRenderAll()
{   /* WRITE is going away, and we are the owners of the clipboard.
       Render the contents of the clipboard in as many formats as
       we know.  Prompt the user if the save will use more than 1000
       cp's; this is to avoid massive inadvertant gobbling of global
       heap space. */
 extern int vfOwnClipboard;
 extern HANDLE hMmwModInstance;
 extern HANDLE hParentWw;
 extern FARPROC lpDialogConfirm;
 typeCP cpMac=CpMacText( docScrap );


 if ( (cpMac == cp0) || !vfOwnClipboard)
    {   /* We are not the clipboard owner OR the scrap is empty:
           no actions required */
    return TRUE;
    }
#ifdef ENABLE   /* By popular demand, this dialog box is removed */
 else if (cpMac > 1000L)
    {
    /* Clipboard contents (docScrap) are > 1000 bytes; ask the user to confirm
       that it should be saved away in a global handle */

    switch ( OurDialogBox( hMmwModInstance, MAKEINTRESOURCE( dlgSaveScrap ),
                        hParentWw, lpDialogConfirm ) )
        {
        default:
        case idiCancel:     /* [CANCEL]     Abort exit sequence */
            return FALSE;
        case idiNo:         /* [DISCARD]    Discard large clipboard */
            return TRUE;
        case idiOk:         /* [SAVE]       Save large clipboard */
            break;
        }
    }

    /* Believe it or not, we have to check the vfOwnClipboard flag AGAIN.
       A user as sneaky as gaben might have gone into another app and
       copied to the clipboard while our dialog is up. */

if (!vfOwnClipboard)
    /* We have to check the vfOwnClipboard flag AGAIN.
       A user might have gone into another app and
       copied to the clipboard while our dialog was up. */
    return TRUE;
#endif  /* ENABLE */

    /* Render the clipboard contents */
if (OpenClipboard( wwdCurrentDoc.wwptr ))
    {
    int f;

    f = FWriteExtScrap();
    CloseClipboard();
    if (f)
        return TRUE;
    else
        {   /* Failed to write scrap contents -- report error */

        extern HWND hParentWw;
        CHAR *PchFillPchId( CHAR *, int, int );
        CHAR sz[ 256 ];

        PchFillPchId( sz, IDPMTClipQuest, sizeof(sz) );

        switch ( IdPromptBoxSz( hParentWw, sz,
                                MB_OKCANCEL | MB_ICONHAND | MB_SYSTEMMODAL ) )
            {
            default:
                break;
            case IDOK:
                return TRUE;
            }
        }
    }
return FALSE;
}




FWriteExtScrap()
{   /* Write the scrap document into the external scrap */
    /* This means: Write the clipboard contents to the clipboard */
    /* in the standard Windows CF_TEXT format, or, if a picture, */
    /* in CF_BITMAP or CF_METAFILEPICT, whichever it was originally. */
    /* We get here in response to a WM_RENDERFORMAT or WM_RENDERALLFORMATS */
    /* message.  The clipboard is assumed to be already OPEN, and is left open */
    /* Returns TRUE if all is well, FALSE if an error occurs.  The caller
    /* is responsible for reporting errors. */

int NEAR FWriteExtTextScrap();
typeCP  cpNow;
typeCP  cpMac=(**hpdocdod) [docScrap].cpMac;
unsigned long cbScrap;
struct  PICINFOX picInfo;
HANDLE  hScrapDescriptor=NULL;
HANDLE  hScrap;

if (!vfScrapIsPic)
    {   /* Text */
    return FWriteExtTextScrap();
    }

GetPicInfo( cp0, cpMac, docScrap, &picInfo );

#if defined(OLE)
    if (picInfo.mfp.mm == MM_OLE)
        return ObjWriteToClip(&picInfo);
#endif

    /* Prime the loop */
FetchCp(docScrap, cpNow = (typeCP)picInfo.cbHeader, 0, fcmChars + fcmNoExpand);
if ((hScrap = GlobalAlloc( GMEM_MOVEABLE, cbScrap = (LONG)vccpFetch )) == NULL)
    goto SetFailed;

while (cpNow < cpMac)
    {
    LPCHCLIP lpch;
    HANDLE hScrapT;

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"FWES:cpNow %lu cpMac %lu vccpFetch %d \n\r", cpNow, cpMac, vccpFetch);
    CommSz(rgch);
    }
#endif

    /* Add bytes from scrap document to global handle */

    if ((lpch = GlobalLock( hScrap )) == NULL)
        goto SetFailed;
    bltbx( (LPCHCLIP) vpchFetch, lpch + (cbScrap - vccpFetch), vccpFetch );
    GlobalUnlock( hScrap );

    /* Fetch the next run and expand the handle */

    if ((cpNow += vccpFetch) >= cpMac)
        break;
    FetchCp( docScrap, cpNow, 0, fcmChars + fcmNoExpand );
    /* the above fetchcp should probably be converted to use the speed-
       hack in fetchcp which passes docnil cpnil to get the next series
       of chars ..pault */

    hScrapT = hScrap;
    hScrap = GlobalReAlloc( hScrap, cbScrap += vccpFetch, GMEM_MOVEABLE );
    if (hScrap == NULL)
        {   /* Could not grow the handle; bail out */
        hScrap = hScrapT;   /* So it gets freed */
        goto SetFailed;
        }
    }

/* Now we have the whole of docScrap in a windows Global handle */
/* See whether we have a bitmap or a metafile picture */

switch(picInfo.mfp.mm)
{
    case MM_BITMAP:
    {   /* Bitmap */
        LPCHCLIP lpch;

        if ( ((lpch=GlobalLock( hScrap ))==NULL) ||
            (picInfo.bm.bmBits=lpch,
                ((hScrapDescriptor=
                    CreateBitmapIndirect((LPBITMAP)&picInfo.bm))==NULL)))
            {
            if (lpch != NULL)
                GlobalUnlock( hScrap );
            goto SetFailed;
            }
        else
            {
                /* Tell the clipboard about the "goal size" for this guy */
            SetBitmapDimension( hScrapDescriptor, picInfo.mfp.xExt,
                                                picInfo.mfp.yExt );
            SetClipboardData( CF_BITMAP, hScrapDescriptor );
            }

        GlobalUnlock( hScrap );
        GlobalFree( hScrap );   /* Bitmap was copied by CreateBitmapIndirect,
                                don't need it anymore */
        hScrap = NULL;
    }
    break;

    default:
    {   /* Metafile Picture */
        LPCHCLIP lpch;
        Diag(CommSzNum("FWES: sizeof(metafilepict) ==",sizeof(METAFILEPICT)));

        if ( ((hScrapDescriptor=GlobalAlloc(GMEM_MOVEABLE,
                                            (long)sizeof(METAFILEPICT) ))==NULL) ||
            ((lpch=GlobalLock( hScrapDescriptor ))==NULL))
            {
            goto SetFailed;
            }
        else
            {
            picInfo.mfp.hMF = hScrap;
            bltbx( (LPCHCLIP) &picInfo.mfp, lpch, sizeof(METAFILEPICT) );
            GlobalUnlock( hScrapDescriptor );
            SetClipboardData( CF_METAFILEPICT, hScrapDescriptor );
            }
    }
    break;
}

return true;

SetFailed:
    if (hScrapDescriptor != NULL)
        GlobalFree( hScrapDescriptor );
    if (hScrap != NULL)
        GlobalFree( hScrap );
    return false;   /* Caller should report errors */
}




int NEAR FWriteExtTextScrap()
{   /* Create ASCII text in a global Windows handle corresponding
       to the contents of docScrap.  Add CR-LF combinations at the
       points at which text would wrap on the display.
       Set the handle into the clipboard if successful, as type CF_TEXT.
       Returns the handle built up, or NULL if we ran out of memory */

long lcchHandle = 0L;
HANDLE h=GlobalAlloc( GMEM_MOVEABLE, (long) 1 );
LPCHCLIP lpch;
typeCP cpNow=cp0;
typeCP cpMac=(**hpdocdod) [docScrap].cpMac;
HANDLE hT;
#if WINVER < 0x300
int cLine = 0;
#endif

Assert( !vfScrapIsPic );
Assert( vfOwnClipboard );

if (h==NULL)
    goto Failed;

while (cpNow < cpMac)
    {
    int ich;
    int dcpLine;

    /* Check for picture para */

    /** Is this syntax intentional???!!! (1.28.91) D. Kent **/
    if (CachePara( docScrap, cpNow ), vpapAbs.fGraphics )
        {
        cpNow = vcpLimParaCache;
        continue;
        }

    /* Format a line of text for the screen */

    FormatLine( docScrap, cpNow, 0, cpMac, flmSandMode );
    dcpLine = vfli.ichReal;

    /* Special: Check for NULLs */
    /* This is a last-minute workaround for a WRITE */
    /* bug in which FormatLine sometimes returns a NULL in vfli.rgch */

    for ( ich = 0; ich < vfli.ichReal; ich++ )
        {
        if (vfli.rgch [ich] == '\0')
            {
#ifdef DCLIP
            CommSzNum("Oddity in FormatLine: returned a zero in rgch at ich==",ich);
#endif

#if WINVER < 0x300
            dcpLine = ich;
            break;
#else
            /* Rather than assign the string a zero length if there is
               just one block character in the selection, we make it the
               ansi block char!  This fixes WINBUG #8150..pault 1/16/90 */
            vfli.rgch [ich] = chBlock;
#endif
            }
        }

    /* Put the chars + a CRLF into the handle */

#define cbNeeded (lcchHandle + dcpLine + 2)

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"FWETS:cbNeeded %lu (lcchHandle %lu, dcpLine %d) \n\r",
            cbNeeded, lcchHandle, dcpLine);
    CommSz(rgch);
    }
#endif

    hT = h;
    if ((h=GlobalReAlloc( h, (LONG) cbNeeded, GMEM_MOVEABLE ))==NULL)
        {   /* Could not expand handle */
        h = hT;  /* So it gets freed */
        goto Failed;
        }

    if ((lpch=GlobalLock( h )) == NULL)
        goto Failed;

    if (vfli.cpMac > cpMac)
            /* Do not cut the endmark character (but alloc for it to allow
               space for zero-terminating the clipboard string) */
#ifdef DBCS
/* We use double byte charactor for END Mark,So we have to go back 2 byte */
#if defined(JAPAN) || defined(KOREA)   //T-HIROYN 1992.07.28
/* In Win31J We use single byte charactor for END Mark */
    dcpLine--;
#else
    dcpLine -= 2;
#endif
#else
        dcpLine--;
#endif

    bltbx( (LPCHCLIP) vfli.rgch, lpch + lcchHandle, dcpLine );

    lpch [lcchHandle += dcpLine] = 0x0D;
    lpch [++lcchHandle] = 0x0A;
#if WINVER < 0x300
    cLine++;
#endif

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"      cpNow %lu cpMac %lu lcchHandle %lu dcpLine %d \n\r",
             cpNow, cpMac, lcchHandle+1, dcpLine);
    CommSz(rgch);
    }
#endif

    ++lcchHandle;
    cpNow = vfli.cpMac;
    GlobalUnlock( h );
    }

 /* SUCCEEDED!  NULL-terminate the string before returning the handle */
#if WINVER >= 0x300
 /* This means we must alloc one more byte at the end ..pault 1/11/90 */

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"FWETS:cbNeeded to fit in sz %lu \n\r", lcchHandle+1);
    CommSz(rgch);
    }
#endif
 hT = h;
 if ((h=GlobalReAlloc( h, (LONG) lcchHandle+1, GMEM_MOVEABLE ))==NULL)
     {   /* Could not expand handle */
     h = hT;  /* So it gets freed */
     goto Failed;
     }
#endif

 if ((lpch = GlobalLock( h )) == NULL)
    goto Failed;

#if WINVER >= 0x300
/* It turns out that we're not really representing the contents of the 
   selection correctly.  The user should really ONLY end up at the start
   of a new line (that is, the last thing "pasted in" was a CRLF sequence)
   if they were really at the end of a line!  (Especially a problem when
   pasting 3 lines of text into the CALENDAR Scratchpad)  12/3/89..pault */

 if (cpMac < vfli.cpMac)
#else
 if (cLine == 1)   /* Special case: < 1 line, do not terminate w/ CRLF */
#endif
    /* Back up over crlf already written */
    lcchHandle = max(0, lcchHandle-2);

 lpch [lcchHandle] = '\0';
 GlobalUnlock( h );
 SetClipboardData( CF_TEXT, h );
 return TRUE;

Failed:

 if (h != NULL)
    GlobalFree( h );
 return FALSE;
}



int FReadExtScrap()
{       /* Transfer the external scrap to the scrap document.  This means:
           read the contents of the clipboard into docScrap, using whatever
           available standard format we can process. Return FALSE=ERR, TRUE=OK */

    extern int vfSysFull;
    extern BOOL fError;
    extern HWND vhWnd;
    extern int vfOwnClipboard;
    int    fOk = FALSE;
    struct PICINFOX picInfo;

    Assert( !vfOwnClipboard );

    vfScrapIsPic = false;
    ClobberDoc( docScrap, docNil, cp0, cp0 );

    if ( !OpenClipboard( vhWnd ) )
        return FALSE;

    /* Get the handle for the highest-priority type available in the clipboard */

    /* if !(PasteLink or (PasteSpecial and not CF_TEXT)) */
    if (!(vbObjLinkOnly || vObjPasteLinkSpecial ||
        (cfObjPasteSpecial && (cfObjPasteSpecial != CF_TEXT))))  // no text handler yet
    /* try to use text format */
    {
        WORD wFormat=0;
        typeCP  cp=cp0;
        unsigned long cb;
        struct PAP *ppap = NULL;
        CHAR    rgch[256];
        HANDLE  hClipboard; /* Handle that was being kept in the clipboard */
        LPCHCLIP lpch;

        while (wFormat = EnumClipboardFormats(wFormat))
        /* enumerate to see whether text precedes native.  If so, take it */
        {
            if (wFormat == CF_TEXT) // take it
            {
                if ((hClipboard = GetClipboardData( wFormat )) == NULL)
                    goto done;

                cb = GlobalSize( hClipboard );
                lpch = MAKELP(hClipboard,0);

                while (cb > 0)
                {   /* Copy bytes from lpch to docScrap's cp stream */
                    #define ulmin(a,b)  (((a) < (b)) ? a : b)

                    unsigned cch=ulmin(cb,255);    /* <= 255 bytes per pass */
                    int fEol;
#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
                    unsigned ccht;

                    if ((cch = CchReadLineExtDBCS((LPCHCLIP) lpch, cch, rgch,
                                 &fEol, &ccht))==0) /* Reached terminator */
                    {
                        fOk = TRUE;
                        goto done;
                    }

                    if (fEol)
                        ppap = vppapNormal;
#ifdef KKBUGFIX     //  added by Hiraisi (pasted several lines. BUG#2791)
                    else
                        ppap = NULL;
#endif

                    InsertRgch( docScrap, cp, rgch, ccht, &vchpNormal, ppap );
                    if (fError)      /* an error was reported mid-copy */
                        goto done;

                    cb -= cch;
                    cp += (typeCP) ccht;
                    lpch += cch;
#else
                    if ((cch = CchReadLineExt((LPCHCLIP) lpch, cch, rgch,
                                 &fEol))==0) /* Reached terminator */
                    {
                        fOk = TRUE;
                        goto done;
                    }

                    if (fEol)
                        ppap = vppapNormal;
#ifdef KKBUGFIX     //  added by Hiraisi (pasted several lines. in Japan)
                    else
                        ppap = NULL;
#endif

                    InsertRgch( docScrap, cp, rgch, cch, &vchpNormal, ppap );
                    if (fError)      /* an error was reported mid-copy */
                        goto done;

                    cb -= cch;
                    cp += (typeCP) cch;
                    lpch += cch;
#endif
                }
                Assert(0); // shouldn't get here
            }
            else if ((cfObjPasteSpecial != CF_TEXT) &&
                      (wFormat == vcfNative)) // make an object
                /* NOTE: if pastespecial and the format == CF_TEXT, then
                   we look for the text format regardless of presence of
                   native */
                break;
        }
    }

    /*  Fell through to here, so didn't find or don't want text,
        see whether can make an object (static included) */

    if (!ObjCreateObjectInClip(&picInfo))
        goto done;

    vfScrapIsPic = true;

    /* save new picinfo to doc */
    CachePara(docScrap,cp0);
    if (ObjSaveObjectToDoc(&picInfo,docScrap,cp0) == cp0)
    {
        OleDelete(lpOBJ_QUERY_OBJECT(&picInfo));
        goto done;
    }

    /* this'll force paste to reuse rather than clone */
    if (ObjToCloneInDoc(&picInfo,docScrap,cp0) == cp0)
    {
        OleDelete(lpOBJ_QUERY_OBJECT(&picInfo));
        goto done;
    }

    fOk = TRUE;

    done:

    CloseClipboard();
    if (vfSysFull || (!fOk && (picInfo.mfp.mm == MM_OLE)))
        {   /* Filled the scratch file trying to bring in the object */
        ClobberDoc(docScrap, docNil, cp0, cp0);
        fOk = FALSE;
        }

    return fOk;
}

#if defined(JAPAN) & defined(DBCS_IME)
// We know that this special routine is particularly useful for Japanese IME

//CmdInsIRString(int doc)   T-HIROYN 3.1J
CmdInsIRString()
{
    extern struct CHP vchpSel;
    typeCP cp, dcp;
    struct CHP chpT;
    extern struct SEL       selCur;     /* Current Selection */
    extern int              vfSeeSel;

    if (!FWriteOk(fwcInsert))
        return;

    if ((dcp = CpMacText(docIRString))  == cp0)
        return;

    NoUndo();   /* So the Undo doesn't get combined	with previous ops */

    /* Stomp the current selection, if any */
    if (selCur.cpLim > selCur.cpFirst)
        DeleteSel();

    chpT = vchpSel;
    cp = selCur.cpFirst;

    CachePara( docIRString, cp0 );

    SetUndo( uacInsert, docCur, cp, dcp, docNil, cpNil, cp0, 0 );

    SetUndoMenuStr(IDSTRUndoEdit);
    ReplaceCps(docCur, cp , cp0, docIRString, cp0, dcp);

    if (ferror) /* Not enough memory to do replace operation */
        NoUndo();  /* should not be able to undo what never took place */
    else
    {
        CHAR rgch[ cchCHP + 1 ];

        typeCP cpSel=CpFirstSty( cp + dcp, styChar );

        rgch [0] = sprmCSame;
        bltbyte( &chpT, &rgch [1], cchCHP );
        AddSprmCps( rgch, docCur, cp, cp + dcp );

        Select( cpSel, cpSel );
        vchpSel = chpT; /* Preserve insert point props across this operation */
        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {   /* If running head/foot, remove chSects & set para props */
            MakeRunningCps( docCur, cp, dcp );
        }
        if (ferror)
            NoUndo();
    }

    vfSeeSel = true;    /* Tell Idle() to scroll the selection into view */
}


PutImeString( hWnd,  hIME )
HWND hWnd;
HANDLE hIME;
{
    LPCHCLIP lpch;
    CHAR rgch[256];
    unsigned long cb;
    typeCP cp = cp0;
    extern BOOL fError;
    extern int vfSysFull;
    int fUnFormattedText =  FALSE;
    extern void ForceImeBlock();

    //T-HIROUN 3.1J    ForceImeBlock(hWnd, TRUE);
    //StartLongOp();
    ClearInsertLine();

    vfScrapIsPic = false;
    ClobberDoc( docIRString, docNil, cp0, cp0 );
    cb = GlobalSize( hIME );

    if (lpch = GlobalLock( hIME )) {

        //T-HIROYN  Win3.1
        //change CHARSET to KANJI_CHARSET
        {
            int ftc;
            if( ftcNil != (ftc = GetKanjiFtc(&vchpSel))) {
                ApplyCLooks(&vchpSel, sprmCFtc, ftc);
            }
        }

        while(cb > 0) {
            unsigned cch = ulmin(cb, 255);
            int fEol;
            struct PAP *ppap = NULL;

            if ((cch = CchReadLineExt((LPCHCLIP)lpch,cch,rgch,&fEol)) == 0)
                break;
            if (fEol)
                ppap = vppapNormal;

            InsertRgch(docIRString, cp, rgch, cch, &vchpNormal, ppap );
            if (fError) {
                break;
            }
            cb -= cch;
            cp += (typeCP) cch;
            lpch += cch;
        }
        GlobalUnlock( hIME );
    }
    if (vfSysFull) {
        ClobberDoc( docIRString, docNil, cp0, cp0 );
    }
    fUnFormattedText = !vfScrapIsPic;
    // T-HIROYN 3.1J CmdInsIRString(docIRString);
    //EndLongOp();
    // T-HIROYN 3.1J ForceImeBlock(hWnd, FALSE);
}
#endif // JAPAN & DBCS_IME

CchReadLineExt( lpch, cbRead, rgch, pfEol)
LPCHCLIP lpch;
int     cbRead;
CHAR    rgch[];
int     *pfEol;
{ /* Read from lpch to the next eol or null terminator, whichever comes first */
/* Return number of bytes read (max is 255) and whether there is a eol at end */
/* The count does not include the null terminator, but does include the eol */

CHAR    *pch;
extern  CHAR *index();

Assert(cbRead <= 255);
bltbx( lpch, (LPCHCLIP) rgch, cbRead );
rgch[ cbRead ] = 0;       /* Null terminate the string (so index will work) */

if (*pfEol = ((pch=index(rgch,chEol)) != NULL))
    {   /* FOUND EOL */
    return (pch - rgch + 1);
    }
else
    {   /* NO EOL */
    return CchSz(rgch) - 1;
    }
}

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
CchReadLineExtDBCS( lpch, cbRead, rgch, pfEol, ccht)
LPCHCLIP lpch;
int     cbRead;
CHAR    rgch[];
int     *pfEol;
int     *ccht;
{
/*Read from lpch to the next eol or null terminator, whichever comes first */
/*Return number of bytes read (max is 255) and whether there is a eol at end */
/*The count does not include the null terminator, but does include the eol */

CHAR    *pch;
int     i, j, ret;

    Assert(cbRead <= 255);

#ifdef KKBUGFIX     //  added by Hiraisi (BUG#2791)
    *pfEol = FALSE;
#endif
    i = j = 0;
    while( j < cbRead) {
        if( IsDBCSLeadByte(*lpch) ) {
            if(j + 2 > cbRead)
                break;
            if( FKanji2(*(lpch+1)) ) {
                rgch[j++] = *lpch++;
                rgch[j++] = *lpch++;
                i += 2;
            } else {
                lpch++;
                i++;
            }
        } else {
            /* FOUND Null */
            if(*lpch == 0)
                break;
            rgch[j++] = *lpch;
            i++;
            /* FOUND EOL */
            if(*lpch == chEol)
#ifdef KKBUGFIX     //  added by Hiraisi (BUG#2791)
            {
                *pfEol = TRUE;
                break;
            }
#else
                break;
#endif
            lpch++;
        }
    }

    rgch[j] = 0;    /* Null terminate the string (so index will work) */
                    /* j == set bytes for rgch */
                    /* i == read bytes from lpch */
    *ccht = j;

    if(j == 0)
        i = 0;
    return(i);
}
#endif



FComputePictSize( pmfp, pdxa, pdya )
register METAFILEPICT *pmfp;
int *pdxa;
int *pdya;
{   /* Compute an initial size, in twips, for the picture described by the
       passed metafile picture structure. Return the size through
       parameters.  Return FALSE if the metafile picture structure
       contained bad information, TRUE otherwise */

#ifdef SCALE_FOR_SCREEN
#define hDCBasis    wwdCurrentDoc.hDC
#define dxaConvert  czaInch
#define dxpConvert  dxpLogInch
#define dyaConvert  czaInch
#define dypConvert  dypLogInch
#else   /* Scale for printer */
 extern int dxaPrPage, dxpPrPage, dyaPrPage, dypPrPage;
 extern HDC vhDCPrinter;
#define hDCBasis    vhDCPrinter
#define dxaConvert  dxaPrPage
#define dxpConvert  dxpPrPage
#define dyaConvert  dyaPrPage
#define dypConvert  dypPrPage
#endif

 int mm = pmfp->mm;
 int dxp, dyp;
 int xres;
 int yres;
 int xsiz;
 int ysiz;

#if defined(OLE)
 if (mm == MM_OLE)
    return ObjQueryObjectBounds((struct PICINFOX FAR *)pmfp, vhDCPrinter, pdxa, pdya);
 else
#endif

{
 xres = GetDeviceCaps( hDCBasis, HORZRES );
 yres = GetDeviceCaps( hDCBasis, VERTRES );
 xsiz = GetDeviceCaps( hDCBasis, HORZSIZE );
 ysiz = GetDeviceCaps( hDCBasis, VERTSIZE );

 switch (mm) {
    case MM_ISOTROPIC:
    case MM_ANISOTROPIC:
        if (! ((pmfp->xExt > 0) && (pmfp->yExt > 0)))
            {   /* No "Suggested Size" given */
                /* Use 3" vertically, 3" or as dictated by */
                /* aspect ratio horizontally */
            dyp = PxlConvert( MM_LOENGLISH, 300, yres, ysiz );
            dxp = ((pmfp->xExt == 0) && (pmfp->yExt == 0)) ?
                       /* No aspect ratio info given -- use 3" horizontal */
                       PxlConvert( MM_LOENGLISH, 300, xres, xsiz ) :
                       /* Info has neg #'s; use to compute aspect ratio */
                      ((long)((long)dyp * (long)(iabs(pmfp->xExt)))) /
                      (long) (iabs(pmfp->yExt));
            break;
            }
         else
             mm = MM_HIMETRIC;
        /* FALL THROUGH TO COMPUTE "SUGGESTED SIZE" */
    default:
        dxp = PxlConvert( mm, pmfp->xExt, xres, xsiz );
        dyp = PxlConvert( mm, pmfp->yExt, yres, ysiz );
        break;
    }
}

if ((dxp == 0) || (dyp == 0))
    /* bogus info or unknown map mode */
    return FALSE;

*pdxa = MultDiv( dxp, dxaConvert, dxpConvert );
*pdya = MultDiv( dyp, dyaConvert, dypConvert );
return TRUE;
}


HbmMonoFromHbmColor( hbmSrc )
HBITMAP hbmSrc;
{   /* Return a monochrome copy of the passed bitmap. Return NULL
       if an error occurred.  Assumes that the passed bitmap can be
       selected into a memory DC which is compatible with the doc DC. */

extern long rgbBkgrnd;
extern long rgbText;
extern HWND vhWnd;

BITMAP bm;
HBITMAP hbmMono=NULL;
HDC hMDCSrc = NULL;
HDC hMDCDst = NULL;

/* Create memory DC for source, set colors, select in passed bitmap */

 if ((hMDCSrc = CreateCompatibleDC( wwdCurrentDoc.hDC )) == NULL)
    goto Error;

#ifdef BOGUS
 /* We can't assume that every window out there has the same window colors that
 we have.  In fact, we have no way to figure out how to convert this color
 bitmap; so white will map to white and everything else will map to black. */
 SetBkColor( hMDCSrc, rgbBkgrnd );
 SetTextColor( hMDCSrc, rgbText );
#endif /* BOGUS */

 if (SelectObject( hMDCSrc, hbmSrc ) == NULL)
    goto Error;

 /* Create memory DC for destination, select in a new monochrome bitmap */

 if ( ((hMDCDst = CreateCompatibleDC( wwdCurrentDoc.hDC )) == NULL) ||
      ((GetObject( hbmSrc, sizeof (BITMAP), (LPSTR) &bm ) == 0)) ||
      ((hbmMono = CreateBitmap( bm.bmWidth, bm.bmHeight,
                                1, 1, (LPSTR) NULL )) == NULL) ||
      (SelectObject( hMDCDst, hbmMono ) == NULL) )
    {
    goto Error;
    }

#ifdef DCLIP
 {
 char rgch[200];
 wsprintf(rgch,"HMFH: (dst) bmWidthB %lu * bmHeight %lu bmPlanes %lu\n\r",
         (unsigned long) bm.bmWidthBytes, (unsigned long) bm.bmHeight,
         (unsigned long) bm.bmPlanes );
 CommSz(rgch);
 }
#endif

 /* Now blt the bitmap contents.  The screen driver in the source will
    "do the right thing" in copying color to black-and-white. */

 if (!BitBlt( hMDCDst, 0, 0, bm.bmWidth, bm.bmHeight, hMDCSrc, 0, 0, SRCCOPY ))
    goto Error;

 DeleteDC( hMDCSrc );
 DeleteDC( hMDCDst );
 return hbmMono;

Error:

    if (hMDCSrc != NULL)            /* ORDER IS IMPORTANT: DC's before */
        DeleteDC( hMDCSrc );    /* objects selected into them */
    if (hMDCDst != NULL)
        DeleteDC( hMDCDst );
    if (hbmMono != NULL)
        DeleteObject( hbmMono );
    return NULL;
}


#if WINVER >= 0x300
    /* Since copying more than 64k to the clipboard is now a real
       possibility under protect mode, we really need a good assembler
       bltbh().  We don't copy more than 64k at a time but we do 
       need to properly handle crossing segment boundaries.  For now
       the clipboard is the only place we need this so this C routine
       will suffice for now ..pault */

void bltbh(HPCH hpchFrom, HPCH hpchTo, int cch)
    {
    HPCH hpchFromLim;

    for (hpchFromLim  = hpchFrom + cch;
            hpchFrom < hpchFromLim;
                *(hpchTo++) = *(hpchFrom++))
        ;
    }
#endif

#if defined(JAPAN) & defined(DBCS_IME)
LONG GetIRString(HWND, LPARAM);
LONG GetIRStringEx(HWND, LPARAM);

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J

LONG GetIRUndetermin(HWND, LPARAM);

//IR_UNDETERMINE
LONG GetIRUndetermin(hWnd, lParam)
HANDLE    hWnd;
LONG      lParam;
{
    LPUNDETERMINESTRUCT lpUn;
    HANDLE      hImeUn;
    LPSTR       lpImeattrbuf, lpImechbuf, lpImeDchbuf;
    LPSTR       lpAttrib, lpText;
    UINT        uC, uCurPos, uLen, cb, clen, uDLen;
    UINT	uDelta = 0; //12/28/92 add
    HANDLE      hMem;
    typeCP      cpSel = 0L;
    typeCP      dcp = 0L;
    BOOL        bUpdate = FALSE;
    WORD        lRet = (LONG)FALSE;

    extern int              vfSeeSel;

    ImeClearInsert = FALSE;

    if(NULL == (hImeUn = LOWORD(lParam))) {
        //Cut prev IME string
        if(selUncpLim > selUncpFirst) {
            dcp = selUncpLim - selUncpFirst;
            Replace(docCur, selUncpFirst, dcp, fnNil, fc0, fc0);
            selCur.cpFirst = selCur.cpLim = selUncpLim = selUncpFirst;

            HiddenTextTop = 0;              //IME rectangle top
            HiddenTextBottom = 0;           //IME rectangle bottom
        }
        return lRet;
    }

    // Undetermine string attribute area alloc. when it free is Write close:
    if (hImeUnAttrib == NULL) {
        if ((hImeUnAttrib = GlobalAlloc(GMEM_MOVEABLE, 512L)) == NULL)
            return lRet; // something wrong
    }

#if 0 //12/28/92 cut
    // Undetermine string area alloc. when it free is Write close:
    if (hImeUnString == NULL) {
        if ((hImeUnString = GlobalAlloc(GMEM_MOVEABLE, 512L)) == NULL)
            return lRet; // something wrong
    }
#endif

    whileUndetermine = TRUE;

    if(selUncpLim == selUncpFirst)
        SetImeFont(hWnd);

    if (lpUn = (LPUNDETERMINESTRUCT)GlobalLock(hImeUn)) {
        uCurPos = lpUn->uCursorPos;
        uC = uCurPos;
		uDelta = lpUn->uDeltaStart; //12/28/92
        lpImechbuf = (LPSTR)lpUn;
        lpImechbuf += lpUn->uUndetTextPos;
        lpImeattrbuf = (LPSTR)lpUn;
        lpImeattrbuf += lpUn->uUndetAttrPos;
        lpImeDchbuf = (LPSTR)lpUn;
        lpImeDchbuf += lpUn->uDetermineTextPos;

        //Undetermine string length
        if( lpUn->uUndetTextPos != 0 && lpUn->uUndetTextLen != 0 )
            uLen = lpUn->uUndetTextLen;
        else
            uLen = 0;

        //Determine string length
        if( lpUn->uDetermineTextPos != 0 &&
            lpUn->uDetermineTextLen != 0)
            uDLen = lpUn->uDetermineTextLen;
        else
            uDLen = 0;

        //Insert Determin string
        if( uDLen != 0 ) {
            if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uDLen+1))) {
                if (lpText = GlobalLock(hMem)) {
#if 1
			        struct DOD *pdod;

	                pdod = &(**hpdocdod)[docCur];
                    pdod->fDirty = true;	//because we don't use undo()
#endif
                    //copy string from IME UNDETERMIN struct
                    lstrcpy(lpText, lpImeDchbuf);

                    //chp Set
                    vchpSel = vchpHidden;

                    // string set to docIRString
                    PutImeString( hWnd, hMem);

                    // inset point set
                    selCur.cpFirst = selUncpFirst;

                    // copy from docIRString to docCur
                    CmdInsIRStringUndetermin((typeCP)uDLen);

                    bUpdate = TRUE;

                    GlobalUnlock(hMem);

                    lRet = (LONG)TRUE;

                    selUncpFirst += (typeCP)uDLen;
                    selUncpLim   += (typeCP)uDLen;

                    HiddenTextTop = 0;           //IME rectangle top

                }
                GlobalFree(hMem);
            }
        }

        // cursor position
        if(uC == -1)
           uC = uLen;

        // IME IR_UNDETERMIN Mode start or No change
        if(selUncpFirst == selUncpLim && uLen == 0) {
            GlobalUnlock(hImeUn);
            whileUndetermine = FALSE; //12/28/92
            return lRet;
        }

        /* prev SELECT doc ? */
        if (selCur.cpLim > selCur.cpFirst)
            DeleteSel();

        //First Undetermine string
        if(selUncpFirst == selUncpLim && uLen != 0) {
            selUncpFirst = selCur.cpFirst;
            selUncpLim = selUncpFirst;
            vchpHidden = vchpSel;
        }

        clen = 0;

        //Cut prev IME string
        if(selUncpLim > selUncpFirst) {
            dcp = selUncpLim - selUncpFirst;
#if 0 //12/28/92 rep
            //Compare prev Undetermin string and New Undetermin string
            if ( lpText = GlobalLock(hImeUnString) ) {
                if( lpAttrib = GlobalLock(hImeUnAttrib) ){

                    for(clen = 0; ((typeCP)clen < dcp && clen < uLen); clen++) {
                        if( *(lpText+clen) != *(lpImechbuf+clen)) {
                            break;
                        }
                        if( *(lpAttrib+clen) != *(lpImeattrbuf+clen)) {
                            break;
                        }
                        if(IsDBCSLeadByte(*(lpText+clen))) {
                            if( *(lpText+clen+1) != *(lpImechbuf+clen+1)) {
                                break;
                            }
                            clen++;
                        }
                    }

                    GlobalUnlock(hImeUnAttrib);
                }

                GlobalUnlock(hImeUnString);
            }
#else
			if(-1 == uDelta)
				clen = uLen;
			else
				clen = uDelta;
#endif
            if((typeCP)clen < dcp) {
                Replace(docCur, selUncpFirst+(typeCP)clen, dcp-(typeCP)clen,
                         fnNil, fc0, fc0);
                bUpdate = TRUE;
            }
        }

        selUncpLim = selUncpFirst + (typeCP)uLen;

        //Insert New Undetermin string
        if(uLen != 0 && clen < uLen) {
            if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uLen+1))) {
                if (lpText = GlobalLock(hMem)) {

                    //copy string from IME UNDETERMIN struct
                    lstrcpy(lpText, lpImechbuf + clen);

                    //chp Set;
                    vchpSel = vchpHidden;

                    // string set to docIRString
                    PutImeString( hWnd, hMem);

                    // inset point set
                    selCur.cpFirst = selUncpFirst+(typeCP)clen;

                    // copy from docIRString to docCur
                    CmdInsIRStringUndetermin((typeCP)uC);

                    bUpdate = TRUE;

                    GlobalUnlock(hMem);

                    HiddenTextBottom = 0;           //IME rectangle bottom
                }
                GlobalFree(hMem);
            }
        } else {
            //ALL Cut only
            if(uLen == 0) {
                selCur.cpFirst = selCur.cpLim = selUncpLim = selUncpFirst;
                HiddenTextTop = 0;              //IME rectangle top
                HiddenTextBottom = 0;           //IME rectangle bottom
            }
        }

        // save new info
        //save new Undetermin string;
#if 0  //12/28/92 cut
        if (lpText = GlobalLock(hImeUnString)) {
            bltbcx(lpText, 0, 512);
            if(uLen < 512)
                lstrcpy(lpText,lpImechbuf);
            GlobalUnlock(hImeUnString);
        }
#endif
        //save new Undetermin string Attrib
        //12/28/92 add
        if(uLen > 512) {
            hImeUnAttrib = GlobalReAlloc(hImeUnAttrib, (DWORD)uLen, 0);
        }

        if(lpAttrib = GlobalLock(hImeUnAttrib)) {
// 12/28/92 bltbcx(lpAttrib, 0, 512);
            for(cb = 0;cb < uLen;cb++) {
                lpAttrib[cb] = lpImeattrbuf[cb];
            }
            GlobalUnlock(hImeUnAttrib);
        }

        //Insert Point set:
        cpSel=CpFirstSty( selUncpFirst + (typeCP)uC, styChar );
        Select( cpSel, cpSel );

        //InsertPoint(caret) don`t disp ?
        if( -1 == uCurPos && selUncpLim > selUncpFirst )
            ImeClearInsert = TRUE;

		vfSeeSel = true; /* Tell Idle() to scroll the selection into view */

        GlobalUnlock(hImeUn);
    }

    //text display
    if(bUpdate) {
        UpdateWw(wwCur, FALSE);
// 12/28/92        DoHiddenRectSend();
    }

    whileUndetermine = FALSE;
    return lRet;
}

CmdInsIRStringUndetermin(typeCP cpCc)
{
    extern struct CHP vchpSel;
    typeCP cp, dcp;
    struct CHP chpT;
    extern struct SEL       selCur;     /* Current Selection */
    extern int              vfSeeSel;

    if (!FWriteOk(fwcInsert))
        return;

    if ((dcp = CpMacText(docIRString))  == cp0)
        return;

//NNN    NoUndo();   /* So the Undo doesn't get combined with previous ops */

    /* Stomp the current selection, if any */
//NNN    if (selCur.cpLim > selCur.cpFirst)
//NNN        DeleteSel();

    chpT = vchpSel;
    cp = selCur.cpFirst;

    CachePara( docIRString, cp0 );

//NNN    SetUndo( uacInsert, docCur, cp, dcp, docNil, cpNil, cp0, 0 );

//NNN    SetUndoMenuStr(IDSTRUndoEdit);
    ReplaceCps(docCur, cp , cp0, docIRString, cp0, dcp);

    if (ferror) /* Not enough memory to do replace operation */
        NoUndo();  /* should not be able to undo what never took place */
    else
    {
        CHAR rgch[ cchCHP + 1 ];

//NNN        typeCP cpSel=CpFirstSty( cp + dcp, styChar );
//      typeCP cpSel=CpFirstSty( cp + uC, styChar );
        typeCP cpSel=CpFirstSty( selUncpFirst + cpCc, styChar );

        rgch [0] = sprmCSame;
        bltbyte( &chpT, &rgch [1], cchCHP );
        AddSprmCps( rgch, docCur, cp, cp + dcp );

        Select( cpSel, cpSel );

        vchpSel = chpT; /* Preserve insert point props across this operation */
        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {   /* If running head/foot, remove chSects & set para props */
            MakeRunningCps( docCur, cp, dcp );
        }
        if (ferror)
            NoUndo();
    }

    vfSeeSel = true;    /* Tell Idle() to scroll the selection into view */
}

UndetermineToDetermine(HWND hWnd)
{
    selUncpFirst   = selUncpLim;
    selCur.cpFirst = selUncpLim;
    selCur.cpLim   = selUncpLim;
    ImeClearInsert = FALSE;
    NoUndo();
    InvalidateRect(hWnd, (LPRECT)NULL, FALSE);
    SendIMEVKFLUSHKey(hWnd);
    HiddenTextTop = 0;              //IME rectangle top
    HiddenTextBottom = 0;           //IME rectangle bottom
}

#endif  //End IME_HIDDEN

SendIMEVKFLUSHKey(HWND hWnd)
{
    LPIMESTRUCT lpmem;
    HANDLE      hIMEBlock;
	WORD	wRet;

    /* Get comunication area with IME */
    hIMEBlock=GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
                        (DWORD)sizeof(IMESTRUCT));
    if(!hIMEBlock)  return;

    lpmem           = (LPIMESTRUCT)GlobalLock(hIMEBlock);
    lpmem->fnc      = IME_SENDVKEY;
    lpmem->wParam   = VK_DBE_FLUSHSTRING;
    lpmem->wCount   = 0;

    GlobalUnlock(hIMEBlock);
    wRet = MySendIMEMessageEx(hWnd,MAKELONG(hIMEBlock,NULL));

    GlobalFree(hIMEBlock);
	return wRet;
}

//New3.1 IR_STRING
LONG GetIRString(hWnd, lParam)
HANDLE    hWnd;
LONG      lParam;
{
    HANDLE hMem, hIme;
    LPSTR lpText, lpIme;
    UINT uLen;
    LONG lRet = 0L;

    hIme = LOWORD(lParam);

    if(lpIme = GlobalLock(hIme)) {
        uLen = lstrlen(lpIme);
        if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uLen+1) )) {
            if (lpText = GlobalLock(hMem)) {

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                //Cut Undetermine string
                if(selUncpLim > selUncpFirst) {
                    typeCP Undcp;
                    Undcp = selUncpLim - selUncpFirst;
                    Replace(docCur, selUncpFirst, Undcp, fnNil, fc0, fc0);
                    selCur.cpFirst = selUncpLim = selUncpFirst;
                }
#endif
                //ime string copy
                lstrcpy(lpText, lpIme);

                ForceImeBlock(hWnd, TRUE);
                PutImeString( hWnd, hMem );
                CmdInsIRString();
                ForceImeBlock(hWnd, FALSE);
                GlobalUnlock(hMem);
                lRet = 1L;
            }
            GlobalFree(hMem);
        }
        GlobalUnlock(hIme);
    }
    return lRet;
}

//New3.1 IR_STRINGEX

LONG GetIRStringEX(hWnd, lParam)
HANDLE    hWnd;
LONG      lParam;
{
    LPSTRINGEXSTRUCT lpString;
    HANDLE      hIme, hMem;
    LPSTR       lpImechbuf, lpText;
    UINT        uLen;
    LONG        lRet = (LONG)FALSE;

    if(NULL == (hIme = LOWORD(lParam))) {
        return lRet;
    }

    if (lpString = (LPSTRINGEXSTRUCT)GlobalLock(hIme)) {
        lpImechbuf = (LPSTR)lpString;
        lpImechbuf += lpString->uDeterminePos;

        //Undetermine string length
        if( lpString->uDeterminePos != 0)
            uLen = lstrlen(lpImechbuf);

        //Insert Determin string
        if( uLen != 0 ) {
            if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uLen+1))) {
                if (lpText = GlobalLock(hMem)) {

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                    //Cut Undetermine string
                    if(selUncpLim > selUncpFirst) {
                        typeCP Undcp;
                        Undcp = selUncpLim - selUncpFirst;
                        Replace(docCur, selUncpFirst, Undcp, fnNil, fc0, fc0);
                        selCur.cpFirst = selUncpLim = selUncpFirst;
                    }
#endif
                    //copy string from IME UNDETERMIN struct
                    lstrcpy(lpText, lpImechbuf);

                    ForceImeBlock(hWnd, TRUE);
                    PutImeString( hWnd, hMem );
                    CmdInsIRString();
                    ForceImeBlock(hWnd, FALSE);
                    GlobalUnlock(hMem);
                    lRet = (LONG)TRUE;
                }
                GlobalFree(hMem);
            }
        }
        GlobalUnlock(hIme);
    }
    return lRet;
}
#endif // JAPAN & DBCS_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\cmd.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* cmd.c -- key handling for WRITE */

#define NOCTLMGR
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOHDC
#define NOBRUSH
#define NOPEN
#define NOFONT
#define NOWNDCLASS
#define NOCOMM
#define NOSOUND
#define NORESOURCE
#define NOOPENFILE
#define NOWH
#define NOCOLOR
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "code.h"
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "debug.h"
#include "fmtdefs.h"
#include "winddefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "menudefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef  KOREA
#include <ime.h>
extern  BOOL fInterim; // MSCH bklee 12/22/94
#endif

int                     vfAltKey;
extern int              vfPictSel;
extern int              vfCommandKey;
extern int              vfShiftKey;
extern int              vfGotoKeyMode;
extern int              vfInsertOn;
extern struct WWD       rgwwd[];
extern struct SEL       selCur;         /* Current selection (i.e., sel in current ww) */
extern int vkMinus;

#ifdef JAPAN            //T-HIROYN Win3.1
int                     KeyAltNum = FALSE;
#endif

int fnCutEdit();
int fnCopyEdit();
int fnPasteEdit();
int fnUndoEdit();


FCheckToggleKeyMessage( pmsg )
register MSG *pmsg;
{   /* If the passed message is an up- or down- transition of a
       keyboard toggle key (e.g. shift), update our global flags & return
       TRUE; if not, return FALSE */

 switch ( pmsg->message ) {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        switch( pmsg->wParam ) {
            case VK_SHIFT:
            case VK_CONTROL:
            case VK_MENU:
                SetShiftFlags();
                return TRUE;

#if 0
            #ifdef DEBUG
            default:
            {
                char msg[100];
                wsprintf(msg,"%s\t0x%x\n\r",(LPSTR)((pmsg->message == WM_KEYDOWN) ?
                            "keydown" : "keyup"), pmsg->wParam);
                OutputDebugString(msg);
            }
            #endif
#endif
        }
#ifdef JAPAN //T-HIROYN
        if(vfAltKey){
            if(pmsg->wParam >= VK_NUMPAD0 && pmsg->wParam <= VK_NUMPAD9 ) {
                KeyAltNum = TRUE;
            }
        } else {
            KeyAltNum = FALSE;
        }
#endif
 }
return FALSE;
}




SetShiftFlags()
{
extern int vfShiftKey;     /* Whether shift is down */
extern int vfCommandKey;   /* Whether ctrl key is down */

MSG msg;

PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

vfShiftKey = GetKeyState( VK_SHIFT ) < 0;
vfCommandKey  = GetKeyState( VK_CONTROL ) < 0;
vfAltKey  = GetKeyState( VK_MENU ) < 0;
#if 0
#ifdef DEBUG
{
    char msg[100];
    wsprintf(msg,"%s\t%s\t%s\n\r",
            (LPSTR)(vfShiftKey ? "Shift":"OFF"),
            (LPSTR)(vfCommandKey  ? "Control":"OFF"),
            (LPSTR)(vfAltKey ? "Alt":"OFF"));
    OutputDebugString(msg);
}
#endif
#endif
}




KcAlphaKeyMessage( pmsg )
register MSG *pmsg;
{       /* If the passed message is a key-down transition for a key
           that is processed by the Alpha Mode loop, return a kc
           code for it.  If not, return kcNil.
           If the key is a virtual key that must be translated,
           return kcAlphaVirtual */
 int kc;


 if (pmsg->hwnd != wwdCurrentDoc.wwptr)
    return kcNil;

 kc = pmsg->wParam;
 switch (pmsg->message) {
 default:
    break;
 case WM_KEYDOWN:
#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  KcAlphaKeyMessage(WM_KEYDOWN)  kc=pmsg->wParam==%X\n\r",kc);
    CommSz(rgch);
    }
#endif

    if (vfAltKey)
        return kcAlphaVirtual;

    if (vfCommandKey)
        {   /* Alpha mode control keys */
        if (vfShiftKey && kc == (kkNonReqHyphen & ~wKcCommandMask))
            return kcNonReqHyphen;
        else if (kc == (kksPageBreak & ~wKcCommandMask))
            return KcFromKks( kksPageBreak );
        }

    else
        {   /* There are two classes of Alpha Mode virtual keys:
                (1) Keys that can successfully be filtered out
                    and processed at the virtual key level
                (2) Keys that must be translated first

               We assume here that there is NOT a third class of key
               that will cause synchronous messages to be sent to our
               window proc when TranslateMessage is called.  */

        switch (kc) {
            default:
                return kcAlphaVirtual;

            case VK_F1:     /* THIS IS A COPY OF THE ACCELERATOR TABLE, */
                            /* AND MUST BE UPDATED IN SYNC WITH THE TABLE */
            case VK_F2:
            case VK_F3:
            case VK_F4:
            case VK_F5:
            case VK_F6:
            case VK_F7:
            case VK_F8:
                return kcNil;

            case kcDelNext & ~wKcCommandMask:
                /* If selection, return kcNil, else return kcDelNext */
                return (selCur.cpFirst < selCur.cpLim) ? kcNil : kcDelNext;

            case kcDelPrev & ~wKcCommandMask:
                /* New standard for Win 3.0... Backspace key deletes
                   the selection if there is one (implemented by faking
                   a Delete keypress) ..pault 6/20/89 */
                if (selCur.cpFirst < selCur.cpLim)
                    {
                    pmsg->wParam = (kcDelNext & ~wKcCommandMask);
                    return(kcNil);
                    }
                /* else process as before... */

            case kcTab & ~wKcCommandMask:
            case kcReturn & ~wKcCommandMask:
                return kc | wKcCommandMask;
            }
        }
    break;

#ifdef KOREA    /* interim support by sangl 90.12.23 */
 case WM_INTERIM:
#endif
 case WM_CHAR:
#ifdef KOREA
      if(pmsg->message == WM_INTERIM) // MSCH bklee 12/22/94
           fInterim = TRUE;
      else fInterim = FALSE;
#endif

#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  KcAlphaKeyMessage(WM_CHAR)  returning kc==%X\n\r",kc);
    CommSz(rgch);
    }
#endif
#ifdef PRINTMERGE
    if (kc < ' ')
            /* CTRL-key. The print merge brackets are treated as commands,
               since they require special handling in AlphaMode().
               All others are directly inserted. */
        switch ( kc ) {
            case kcLFld & ~wKcCommandMask:
            case kcRFld & ~wKcCommandMask:
                kc |= wKcCommandMask;
                break;
            }
#endif

#ifdef JAPAN
    // inhibit form inputing Alt + Numkey T-HIROYN WIN3.1
    if(KeyAltNum) {
        _beep();
        KeyAltNum = FALSE;
        return kcNil;
    }
#endif
    return kc;
 }  /* end switch (msg.message) */

#ifdef DINPUT
    CommSz("  KcAlphaKeyMessage(not WM_CHAR or WM_KEYDOWN)  returning kc==kcNil");
#endif
 return kcNil;
}
#ifdef  KOREA
CHAR chDelete;
typeCP cpConversion;
extern int docCur;
extern CHAR *vpchFetch;
extern int IsInterim;
extern typeCP       cpMacCur;
#endif




FNonAlphaKeyMessage( pmsg, fAct )
register MSG *pmsg;
int fAct;           /* Whether to act on the passed key */
{
extern HMENU vhMenu;
extern HWND hParentWw;
int kc;
int message;


 if (pmsg->hwnd != wwdCurrentDoc.wwptr)
    return FALSE;

 message = pmsg->message;
 kc = pmsg->wParam | wKcCommandMask;

 /* Check for Alt-Bksp */
 if ((message == WM_SYSKEYDOWN) && (kc == (VK_BACK | wKcCommandMask)))
     /* Alt-Backspace = UNDO */
     {
     if (fAct)
        PhonyMenuAccelerator( EDIT, imiUndo, fnUndoEdit );
     return TRUE;
     }

 /* Only look at key down messages */

 if (message != WM_KEYDOWN)
    return FALSE;

#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  FNonAlphaKeyMessage(keydown)  kc==%X\n\r",kc);
    CommSz(rgch);
    }
#endif

 /* Translate CTRL keys by mapping valid kk & kks codes to valid kc codes */

 if ( vfCommandKey )
    {
    if (vfShiftKey)
        switch ( kc ) {     /* Handle CTRL-SHIFT keys */
        default:
            goto CtrlKey;
#if 0
#ifdef DEBUG
        case kksTest:
        case kksEatWinMemory:
        case kksFreeWinMemory:
        case kksEatMemory:
        case kksFreeMemory:
            kc = KcFromKks( kc );
            break;
#endif
#endif
        }
    else        /* Handle CTRL keys */
        {
CtrlKey:
        switch ( kc ) {
        case kkUpScrollLock:
        case kkDownScrollLock:
        case kkTopDoc:
        case kkEndDoc:
        case kkTopScreen:
        case kkEndScreen:
        case kkCopy:
#ifdef CASHMERE   /* These keys not supported by MEMO */
        case kkNonReqHyphen:
        case kkNonBrkSpace:
        case kkNLEnter:
#endif
        case kkWordLeft:
        case kkWordRight:
            kc = KcFromKk( kc );    /* Translate control code */
#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  FNonAlphaKeyMessage, translated kc %X\n\r",kc);
    CommSz(rgch);
    }
#endif
            break;

        default:
#ifdef DINPUT
    CommSz("  FNonAlphaKeyMessage returning false, nonsupported kc\n\r");
#endif
            return FALSE;
        }
        }
    }   /* end of if (vfCommandKey) */


    /* Act on valid kc codes */

#ifdef DINPUT
    CommSz("  FNonAlphaKeyMessage processing valid kc codes\n\r");
#endif
    switch ( kc ) {
     /* ---- CURSOR KEYS ---- */
     case kcEndLine:
     case kcBeginLine:
     case kcLeft:
     case kcRight:
     case kcWordRight:
     case kcWordLeft:
        if (fAct)
            {
            ClearInsertLine();
            MoveLeftRight( kc );
            }
        break;

     case kcUp:
     case kcDown:
     case kcUpScrollLock:
     case kcDownScrollLock:
     case kcPageUp:
     case kcPageDown:
     case kcTopDoc:
     case kcEndDoc:
     case kcEndScreen:
     case kcTopScreen:
        if (fAct)
            {
            ClearInsertLine();
            MoveUpDown( kc );
            }
        break;

    case kcGoto:       /* Modifies next cursor key */
        if (!fAct)
            break;
        vfGotoKeyMode = true;
        goto NoClearGoto;

    /* Phony Menu Accelerator Keys */

    case kcNewUndo:
     {
     if (fAct)
        PhonyMenuAccelerator( EDIT, imiUndo, fnUndoEdit );
     return TRUE;
     }

    case kcCopy:
    case kcNewCopy:
        if (fAct)
            PhonyMenuAccelerator( EDIT, imiCopy, fnCopyEdit );
        break;

    case kcNewPaste:
    case VK_INSERT | wKcCommandMask:
        if (fAct && (vfShiftKey || (kc == kcNewPaste)))
        {
#if defined(OLE)
            vbObjLinkOnly = FALSE;
#endif
            PhonyMenuAccelerator( EDIT, imiPaste, fnPasteEdit );
        }
        break;

    case kcNewCut:
    case VK_DELETE | wKcCommandMask:
        if (vfShiftKey || (kc == kcNewCut))
            {   /* SHIFT-DELETE = Cut */
            if (fAct)
                PhonyMenuAccelerator( EDIT, imiCut, fnCutEdit );
            }
        else
            {   /* DELETE = Clear */
            if (fAct)
                fnClearEdit(FALSE);
            }
        break;

    case VK_ESCAPE | wKcCommandMask:
        /* The ESC key does: if editing a running head or foot, return to doc
                             else beep */
        if (!fAct)
            break;

        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
            {   /* Return to document from editing header/footer */
            extern HWND vhDlgRunning;

            SendMessage( vhDlgRunning, WM_CLOSE, 0, (LONG) 0 );
            return TRUE;
            }
        else
            _beep();
        break;

#ifdef  KOREA
    case VK_HANJA | wKcCommandMask:

        if(IsInterim)   break;

        if (selCur.cpFirst == cpMacCur) {
                _beep();
                break;
        }
        cpConversion = selCur.cpFirst;
        Select( cpConversion, cpConversion+1 );   // 2/9/93
        FetchCp( docCur, cpConversion, 0, fcmChars );
        chDelete = *vpchFetch;
        { HANDLE  hKs;
          LPIMESTRUCT  lpKs;
          LPSTR lp;

          hKs = GlobalAlloc (GMEM_MOVEABLE|GMEM_DDESHARE,(LONG)sizeof(IMESTRUCT));
          lpKs = (LPIMESTRUCT)GlobalLock(hKs);
          lpKs->fnc = IME_HANJAMODE;
          lpKs->wParam = IME_REQUEST_CONVERT;
          lpKs->dchSource = (WORD)( &(lpKs->lParam1) );
          lp = lpSource( lpKs );
          *lp++ = *vpchFetch++;
          *lp++ = *vpchFetch;
          *lp++ = '\0';
          GlobalUnlock(hKs);
          if(SendIMEMessage (hParentWw, MAKELONG(hKs,0)))
              selCur.cpLim = selCur.cpFirst + 2;
          else
              Select( cpConversion, cpConversion );   // 2/9/93

          GlobalFree(hKs);
        }
        break;
#endif       /* KOREA */

#if 0
#ifdef DEBUG
    case kcEatWinMemory:
        if (!fAct)
            break;
        CmdEatWinMemory();
        break;
    case kcFreeWinMemory:
        if (!fAct)
            break;
        CmdFreeWinMemory();
        break;
    case kcEatMemory:
        {
        if (!fAct)
            break;
        CmdEatMemory();
        break;
        }
    case kcFreeMemory:
        if (!fAct)
            break;
        CmdFreeMemory();
        break;
    case kcTest:
        if (!fAct)
            break;
        fnTest();
        break;
#endif
#endif
    default:
        return FALSE;
     }   /*  end of switch (kc) */

    vfGotoKeyMode = false;
NoClearGoto:
    return TRUE;
}





#ifdef DEBUG
ScribbleHex( dch, wHex, cDigits )
int dch;            /* Screen position at which to show Last digit (see fnScribble) */
unsigned wHex;      /* hex # to show*/
int cDigits;        /* # of digits to show */
{
  extern fnScribble( int dchPos, CHAR ch );

  for ( ; cDigits--; wHex >>= 4 )
    {
    int i=wHex & 0x0F;

    fnScribble( dch++, (i >= 0x0A) ? i + ('A' - 0x0A) : i + '0' );
    }
}
#endif  /* DEBUG */






#ifdef DEBUG
#ifdef OURHEAP
CHAR (**vhrgbDebug)[] = 0;
int     vrgbSize = 0;
#else
#define iHandleMax  100
HANDLE rgHandle[ iHandleMax ];
int iHandleMac;
unsigned cwEaten = 0;
#endif

CmdEatMemory()
{ /* For debugging purposes, eat up memory */
#ifdef OURHEAP       /* Restore this with a LocalCompact when are
                       operational under the Windows heap */
int **HAllocate();
int cwEat = cwHeapFree > 208 ? cwHeapFree - 208 : 20;

if (vrgbSize == 0)
        vhrgbDebug = (CHAR (**)[])HAllocate(cwEat);
else
        FChngSizeH(vhrgbDebug, cwEat + vrgbSize, true);
vrgbSize += cwEat;
CmdShowMemory();
#endif  /* OURHEAP */
}

CmdFreeMemory()
{ /* Free up the memory we stole */
#ifdef OURHEAP
if (vhrgbDebug != 0)
        FreeH(vhrgbDebug);
vhrgbDebug = (CHAR (**)[]) 0;
vrgbSize = 0;
CmdShowMemory();
#endif
}

extern CHAR     szMode[];
extern int      docMode;
extern int      vfSizeMode;

#ifdef OURHEAP
CmdShowMemory()
#else
CmdShowMemory(cw)
int cw;
#endif
{

extern CHAR szFree[];

CHAR *pch = szMode;

#ifdef OURHEAP
/* cch = */ ncvtu( cwHeapFree, &pch );
#else
ncvtu(cw, &pch);
#endif

blt( szFree, pch, CchSz( szFree ));
vfSizeMode = true;
/* docMode = -1; */
DrawMode();
}




CmdEatWinMemory()
{
#ifndef OURHEAP
unsigned cwEat;
int cPage;
int fThrowPage = TRUE;

extern int cPageMinReq;
extern int ibpMax;

while (true)
    {
    while ((cwEat = ((unsigned)LocalCompact((WORD)0) / sizeof(int))) > 0 &&
          iHandleMac < iHandleMax)
        {
        if ((rgHandle [iHandleMac] = (HANDLE)HAllocate(cwEat)) == hOverflow)
            goto AllocFail;
        else
            {
            ++iHandleMac;
            cwEaten += cwEat;
            CmdShowMemory(cwEaten);
            }

        if (iHandleMac >= iHandleMax)
            goto AllocFail;

        if ((rgHandle [iHandleMac] = (HANDLE)HAllocate(10)) == hOverflow)
            goto AllocFail;
        else
            {
            ++iHandleMac;
            cwEaten += 10;
            CmdShowMemory(cwEaten);
            }
        }

    if (iHandleMac >= iHandleMax)
        goto AllocFail;

    cPage = cPageUnused();
    Assert(cPage + 2 < ibpMax);
    if (fThrowPage)
        {
        /* figure out how many bytes we need to invoke the situation
        where we need to throw some pages out to get the space */
        cwEat = ((cPage+2) * 128) / sizeof(int);
        cPageMinReq = ibpMax - cPage - 2;
        }
    else
        {
        cwEat = ((cPage-2) * 128) / sizeof(int);
        cPageMinReq = ibpMax - cPage;
        }

    if ((rgHandle[ iHandleMac++ ] = (HANDLE)HAllocate(cwEat)) == hOverflow)
        {
        iHandleMac--;
        break;
        }
    cwEaten += cwEat;
    CmdShowMemory(cwEaten);
    }

AllocFail:  /* Allocation failed, or we ran out of slots */
    CmdShowMemory( cwEaten );
#endif
}




CmdFreeWinMemory()
{
#ifndef OURHEAP
unsigned cwFree = 0;

Assert(iHandleMac <= iHandleMax);

while (iHandleMac > 0)
    {
    HANDLE h = rgHandle[ iHandleMac - 1];

    if ( (h != NULL) && (h != hOverflow))
        {
        cwFree += (unsigned)LocalSize(h) / sizeof(int);
        FreeH( h );
        }
    iHandleMac--;
    }

cwEaten = 0;
CmdShowMemory(cwFree);
#endif
}
#endif  /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\cmddefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define cchInsBlock     32      /* Length of quick insert block */

struct SEL
        {
        typeCP          cpFirst;
        typeCP          cpLim;
        unsigned        fForward : 1;     /* Only needs 1 bit */
        unsigned        fEndOfLine : 1;
        };

#define cwSEL   (sizeof (struct SEL) / sizeof (int))
#define cbSEL  (sizeof (struct SEL))

#define styNil          0
#define styChar         1
#define styWord         2
#define stySent         3
#define styPara         4
#define styLine         5
#define styDoc          6

#ifndef NOUAC
/* UNDO Action Codes: */
#define uacNil           0       /* Nothing to UNDO */
#define uacInsert        1       /* Insert text <--> UInsert */
#define uacReplNS        2       /* Replace text, no scrap <--> UReplNS */
#define uacDelNS         3       /* Delete text, no scrap <--> UDelNS */
#define uacMove          4       /* Move text <--> Move */
#define uacDelScrap      5       /* Delete to scrap <--> UDelScrap */
#define uacUDelScrap     6       /* Undo of Delete <--> DelScrap */
#define uacReplScrap     7       /* Replace with del to scrap
                                        <--> UReplScrap */
#define uacUReplScrap    8       /* Undo of ReplScrap <--> ReplScrap */
#define uacDelBuf        9      /* Delete to buffer <--> UDelBuf */
#define uacUDelBuf      10      /* Undo of DelBuf <--> DelBuf */
#define uacReplBuf      11      /* Replace with del to buf <--> UReplBuf */
#define uacUReplBuf     12      /* Undo of ReplBuf <--> ReplBuf */
#define uacCopyBuf      13      /* Copy to buf <--> UCopyBuf */
#define uacUInsert      14      /* undo of Insert <--> Insert */
#define uacUDelNS       15      /* undo of DelNS <--> DelNS */
#define uacUReplNS      16      /* undo of ReplNS <--> ReplNS */
#define uacUCopyBuf     17      /* Undo of CopyBuf <--> CopyBuf */
#define uacReplGlobal   18
#define uacFormatCStyle 19
#define uacChLook       20
#define uacChLookSect   21
#define uacFormatChar   22
#define uacFormatPara   23
#define uacGalFormatChar        24
#define uacGalFormatPara        25
#define uacFormatSection        26
#define uacGalFormatSection     27
#define uacFormatPStyle 28
#define uacFormatSStyle 29
#define uacFormatRHText 30
#define uacLookCharMouse 31
#define uacLookParaMouse 32
#define uacClearAllTab 33
#define uacFormatTabs 34
#define uacClearTab 35
#define uacOvertype 36
#define uacPictSel 37
#define uacInsertFtn 38
#define uacReplPic 39
#define uacUReplPic 40

#ifndef CASHMERE
#define uacRulerChange 41
#define uacRepaginate 42
#endif /* not CASHMERE */
#endif /* NOUAC */

#if defined(OLE)
#define uacObjUpdate  43
#define uacUObjUpdate  44
#endif

/* Units */
#define utInch          0
#define utCm            1
#define utP10           2
#define utP12           3
#define utPoint         4
#define utLine          5
#define utMax           6

#define czaInch         1440
#define czaP10          144
#define czaPoint        20
#define czaCm           567
#define czaP12          120

#define czaLine         240

#define ZaFromMm(mm)    (unsigned)MultDiv(mm, 14400, 254);

#ifdef	KOREA		/* Dum Write doesn't accept it's default value!! 90.12.29 */
#define FUserZaLessThanZa(zaUser, za)	((zaUser) + (7 * czaInch) / 1000 < (za))
#else
#define FUserZaLessThanZa(zaUser, za)   ((zaUser) + (5 * czaInch) / 1000 < (za))
#endif

/* Modes -- see menu.mod */
#define ifldEdit        0
#define ifldGallery     1

#define ecrSuccess      1
#define ecrCancelled    2
#define ecrMouseKilled  4

typeCP  CpFirstSty(), CpLastStyChar();

#define psmNil          0
#define psmCopy         1
#define psmMove         2
#define psmLookChar     3
#define psmLookPara     4
#define psmLooks        3

#define crcAbort        0
#define crcNo           1
#define crcYes          2

/* FWrite checks */
#define fwcNil          0
#define fwcInsert       1
#define fwcDelete       2
#define fwcReplace      3
#define fwcEMarkOK      4       /* Additive -- must be a bit */

/* Dialog item parsing variants */
#define wNormal 0x1
#define wBlank 0x2
#ifdef AUTO_SPACING
#define wAuto 0x4
#endif /* AUTO_SPACING */
#define wDouble 0x8
          /* wSpaces means treat string of all spaces as a null string */
#define wSpaces 0x10

/* page bound */
#define pgnMin 1
#define pgnMax 32767

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\code.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* code.h */
typedef struct {
		int *fNew; 
		int bpc, cwFrame;
} ENV;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\dbcs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#ifdef DBCS

#define	cchDBCS		2
#define fkNonDBCS	((CHAR) 0)
#define fkDBCS1		((CHAR) 1)
#define fkDBCS2		((CHAR) 2)

#define MAKEWORD(_bHi, _bLo) ((((WORD) _bHi) << 8) | ((WORD) _bLo))

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\commdlg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#include <windows.h>
#include "mw.h"
#include "menudefs.h"
#include "str.h"
#include <commdlg.h>
#include "filedefs.h"
#include <dlgs.h>
#include "doslib.h"
#include "obj.h"

extern HANDLE   hMmwModInstance;
extern CHAR     szAppName[];
extern HWND     vhWndMsgBoxParent,hParentWw,vhWnd;
static OPENFILENAME    OFN;
static bSave;
FARPROC lpfnOFNHook=NULL;
BOOL FAR PASCAL fnOFNHook(HWND hDlg, unsigned msg, WORD wParam, LONG lParam) ;

#define hINSTANCE  hMmwModInstance

#define hDOCWINDOW vhWnd
#define hMAINWINDOW hParentWw
#define hPARENTWINDOW  ((vhWndMsgBoxParent == NULL) ? \
                    hParentWw : vhWndMsgBoxParent)

#define	CBPATHMAX	cchMaxFile
#define	CFILTERMAX	6			/* Max # filters */
#define CBFILTERSIZE  40
#define	CBFILTERMAX	(CBFILTERSIZE * CFILTERMAX)	/* Max # chars/filter */
#define CBMESSAGEMAX 80

static char fDefFileType;
#define SA_WORDTEXT 0
#define SA_TEXTONLY 1
#define SA_WORD     2
#define SA_OLDWRITE 3
#define SA_WRITE    4

static char *szDefExtensions[6];
static int   nTextOnly,nWordText,nWord,nOldWrite; // position in filterspec list box
static char  szNull[1] = "";
static char  szWild[3] = "*.";
static char	 szOpenFile[CBMESSAGEMAX];
static char	 szSaveFile[CBMESSAGEMAX];
static char  szFileName[CBPATHMAX];
static char  szLastDir[CBPATHMAX];
static char  szDefWriExtension[CBMESSAGEMAX];
static char  szDefDocExtension[CBMESSAGEMAX];
static char  szDefTxtExtension[CBMESSAGEMAX];
static char  szWriDescr[CBMESSAGEMAX];
static char  szDocDescr[CBMESSAGEMAX];
static char  szTxtDescr[CBMESSAGEMAX];
static char  szAllFilesDescr[CBMESSAGEMAX];
static char  szDocTxtDescr[CBMESSAGEMAX];
static char  szOldWriteDescr[CBMESSAGEMAX];
static char  szFilterSpec[CBFILTERMAX];
static char  szCustFilterSpec[CBFILTERSIZE];

static MakeFilterString(int iWhichOper);
int InitCommDlg(int iWhichOper);

int InitCommDlg(int iWhichOper) 
{
    OFN.lpstrDefExt         = NULL;
    OFN.lpstrFile           = szFileName;
    OFN.lpstrFilter         = szFilterSpec;
    OFN.lpstrCustomFilter   = szCustFilterSpec;

    switch(iWhichOper)
    {
        case 0:  // beginning of Write session
            OFN.lStructSize         = sizeof(OPENFILENAME);
            OFN.hInstance           = hINSTANCE;
            OFN.lCustData           = NULL;
            OFN.lpTemplateName      = NULL;
            OFN.lpstrFileTitle      = NULL;
            OFN.nMaxFileTitle       = 0;
            OFN.nMaxFile            = CBPATHMAX;
            OFN.lpstrInitialDir     = NULL;
            OFN.nMaxCustFilter      = CBFILTERSIZE;

            LoadString(hINSTANCE, IDSTROpenfile, szOpenFile, sizeof(szOpenFile));
            LoadString(hINSTANCE, IDSTRSavefile, szSaveFile, sizeof(szSaveFile));
            LoadString(hINSTANCE, IDSTRDefWriExtension, szDefWriExtension, sizeof(szDefWriExtension));
            LoadString(hINSTANCE, IDSTRDefDocExtension, szDefDocExtension, sizeof(szDefDocExtension));
            LoadString(hINSTANCE, IDSTRDefTxtExtension, szDefTxtExtension, sizeof(szDefTxtExtension));
            LoadString(hINSTANCE, IDSTRWriDescr, szWriDescr, sizeof(szWriDescr));
            LoadString(hINSTANCE, IDSTRDocDescr, szDocDescr, sizeof(szDocDescr));
            LoadString(hINSTANCE, IDSTRTxtDescr, szTxtDescr, sizeof(szTxtDescr));
            LoadString(hINSTANCE, IDSTRDocTextDescr, szDocTxtDescr, sizeof(szDocTxtDescr));
            LoadString(hINSTANCE, IDSTRAllFilesDescr, szAllFilesDescr, sizeof(szAllFilesDescr));
            LoadString(hINSTANCE, IDSTROldWriteDescr, szOldWriteDescr, sizeof(szOldWriteDescr));
                           
        return FALSE;

        case imiOpen:
            if ((lpfnOFNHook = MakeProcInstance(fnOFNHook, hINSTANCE)) == NULL)
                return TRUE;

            OFN.hwndOwner           = hPARENTWINDOW;
            OFN.Flags               = OFN_ENABLEHOOK|OFN_HIDEREADONLY|OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST;
            OFN.lpfnHook            = lpfnOFNHook;
            lstrcpy(szFileName,szWild);
            lstrcat(szFileName,szDefWriExtension);
            OFN.lpstrTitle          = szOpenFile;
            szCustFilterSpec[0] = '\0';
            
            fDefFileType = SA_WRITE; /* see MakeFilterSpec */
            MakeFilterString(iWhichOper);

        return FALSE;

        case imiSaveAs:
            /* read only will become the backup check box */
            if ((lpfnOFNHook = MakeProcInstance(fnOFNHook, hINSTANCE)) == NULL)
                return TRUE;

            OFN.hwndOwner           = hPARENTWINDOW;
            OFN.Flags               = OFN_ENABLEHOOK|OFN_PATHMUSTEXIST|OFN_OVERWRITEPROMPT;
            OFN.lpfnHook            = lpfnOFNHook;
            OFN.lpstrTitle          = szSaveFile;
            szCustFilterSpec[0] = '\0';
            MakeFilterString(iWhichOper);

        return FALSE;
    }

}

int DoCommDlg(int iWhichOper) 
/* returns whether file was retrieved */
/* iWhichOper is the imi* code from the menu */
{
    int iRetval;

    bSave =  iWhichOper == imiSaveAs;

    iRetval = !InitCommDlg(iWhichOper);

    if (!iRetval)
        goto end;

    LockData(0);
    switch(iWhichOper)
    {
        case imiOpen:
            iRetval = GetOpenFileName((LPOPENFILENAME)&OFN);
        break;
        case imiSaveAs:
            iRetval = GetSaveFileName((LPOPENFILENAME)&OFN);
        break;
    }
    UnlockData(0);

    if (CommDlgExtendedError())
    {
        iRetval = FALSE;
        Error(IDPMTNoMemory);
    }

    end:

    if (iRetval)
    {
        lstrcpy(szLastDir,szFileName);
        szLastDir[OFN.nFileOffset] = 0;
        OFN.lpstrInitialDir = szLastDir;
    }

    switch(iWhichOper)
    {
        case imiOpen:
        case imiSaveAs:
            if (lpfnOFNHook)
                FreeProcInstance(lpfnOFNHook);
            lpfnOFNHook = NULL;
        break;
    }

    return iRetval;
}

#include "docdefs.h"

BOOL FAR PASCAL fnOFNHook(HWND hDlg, unsigned msg, WORD wParam, LONG lParam) 
{
    static unsigned wmListBoxChange;
    static unsigned wmCheckShare;
    extern int         docCur;
    extern struct DOD      (**hpdocdod)[];

    switch (msg) 
    {
        case WM_INITDIALOG: 
            if (bSave)
            {
                char szTitle[CBMESSAGEMAX];

                LoadString(hINSTANCE, IDSTRBackup, szTitle, sizeof(szTitle));
                SetDlgItemText(hDlg,chx1,szTitle);

                CheckDlgButton(hDlg,chx1,OFN.Flags&OFN_READONLY);
                if (szFileName[0] == 0)
                    SetDlgItemText(hDlg,edt1,"");
            }
            else // open
                wmCheckShare = RegisterWindowMessage(SHAREVISTRING);
            wmListBoxChange = RegisterWindowMessage(LBSELCHSTRING);

        break;

        case WM_COMMAND:
            if (bSave)
                switch (wParam)
                {
                    case chx1:
                    /* handle checking the readonly button (I forget what does this do??)
                        (we've changed readonly to be a "Backup" button) */
                        return TRUE;
                    break;
                }
        break;

        default:
            if ((msg == wmListBoxChange) && (wParam == cmb1))
                /* file type selected, set the default extension */
                OFN.lpstrDefExt  = szDefExtensions[LOWORD(lParam)];
            else if ((msg == wmCheckShare) && !bSave)
            /* we want to be able to reopen current document */
            {
                if (!lstrcmpi((LPSTR)(**((**hpdocdod)[docCur].hszFile)),(LPSTR)lParam))
                    return OFN_SHAREFALLTHROUGH;
                else
                    return OFN_SHAREWARN;
            }
        break;

    }
    return FALSE;
}


static MakeFilterString(int iWhichOper)
/* Construct the filter string for the Open, Save dialogs */
/* assume fDefFileType is set */
{
    LPSTR lpStr = szFilterSpec;
    char **ppstr = szDefExtensions;
    int nCount=1;

    /* WRI */
    lstrcpy(lpStr, szWriDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, szDefWriExtension);
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = szDefWriExtension;
    ++nCount;

    if (iWhichOper == imiSaveAs)
    {
        /* Old WRI (without objects) */
        vcObjects = ObjEnumInDoc(docCur,NULL);

        if (vcObjects > 0)
        {
            lstrcpy(lpStr, szOldWriteDescr);
            lpStr += lstrlen(lpStr)+1;
            lstrcpy(lpStr, szWild);
            lstrcat(lpStr, szDefWriExtension);
            lpStr += lstrlen(lpStr)+1;
            *ppstr++ = szDefWriExtension;
            nOldWrite = nCount;
            ++nCount;
        }
        else if (fDefFileType == SA_OLDWRITE)
            fDefFileType = SA_WRITE;
    }

#ifndef JAPAN                  // added  09 Jun. 1992  by Hiraisi
    /*
     *  The reason is as follows.
     *      We don't show the MS-WORD document at list files of type in OPEN
     *    DIALOG and SAVE (AS) DIALOG in Japan because the file format of
     *    MS-WORD(JPN) differs from that of WRITE.
     *      But I modified only this part, because it is easy to restore when
     *    we show the MS-WORD document at file type lists in those dialogs.
    */
    /* DOC */
    lstrcpy(lpStr, szDocDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, szDefDocExtension);
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = szDefDocExtension;
    nWord = nCount;
    ++nCount;

    /* DOC, Text only */
    if (iWhichOper == imiSaveAs)
    {
        lstrcpy(lpStr, szDocTxtDescr);
        lpStr += lstrlen(lpStr)+1;
        lstrcpy(lpStr, szWild);
        lstrcat(lpStr, szDefDocExtension);
        lpStr += lstrlen(lpStr)+1;
        *ppstr++ = szDefDocExtension;
        nWordText = nCount;
        ++nCount;
    }
#endif // !JAPAN

    /* Text only */
    lstrcpy(lpStr, szTxtDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, szDefTxtExtension);
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = szDefTxtExtension;
    nTextOnly = nCount;
    ++nCount;

    /* All files */
    lstrcpy(lpStr, szAllFilesDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, "*");
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = NULL;
    ++nCount;

    *lpStr = 0;

    switch(fDefFileType)
    {
        case SA_WORDTEXT:
            OFN.nFilterIndex = nWordText;
        break;
        case SA_TEXTONLY:
            OFN.nFilterIndex = nTextOnly;
        break;
        case SA_WORD    :
            OFN.nFilterIndex = nWord;
        break;
        case SA_OLDWRITE:
            OFN.nFilterIndex = nOldWrite;
        break;
        case SA_WRITE   :
            OFN.nFilterIndex = 1;
        break;
    }
    OFN.lpstrDefExt  = szDefExtensions[OFN.nFilterIndex - 1];
}


DoOpenFilenameGet(LPSTR lpstrFilenameBuf)
/* returns whether filename retrieved */
{
    int nRetval;

    if (nRetval = DoCommDlg(imiOpen))
        lstrcpy(lpstrFilenameBuf,(LPSTR)szFileName);
        
    return nRetval;
}

DoSaveAsFilenameGet(LPSTR lpstrDefault,LPSTR lpstrFilenameBuf,int *fBackup,int *fTextOnly,int *fWordFmt,int *fOldWriteFmt)
/* Returns whether filename retrieved.  Returns filename.  If readonly is checked,
   returns if readonly is checked in fBackup.  Returns file type selected in fTextOonly and
   fWordFmt. */
{
    int nRetval;

    lstrcpy(szFileName,lpstrDefault);

    /* see MakeFilterSpec */
    if (*fTextOnly && *fWordFmt)
        fDefFileType = SA_WORDTEXT;
    else if (*fTextOnly)
        fDefFileType = SA_TEXTONLY;
    else if (*fWordFmt)
        fDefFileType = SA_WORD;
    else if (*fOldWriteFmt)
        fDefFileType = SA_OLDWRITE;
    else
        fDefFileType = SA_WRITE;

    /* check or uncheck backup prompt */
    OFN.Flags |= (*fBackup) ? OFN_READONLY : 0;

    if (nRetval = DoCommDlg(imiSaveAs))
    {
        lstrcpy(lpstrFilenameBuf,(LPSTR)szFileName);

        if (OFN.nFilterIndex == 1)
        {
            *fTextOnly    = *fWordFmt = FALSE;
            *fOldWriteFmt = FALSE;
        }
        else if (OFN.nFilterIndex == nOldWrite)
        {
            *fTextOnly    = *fWordFmt = FALSE;
            *fOldWriteFmt = TRUE;
        }
        else if (OFN.nFilterIndex == nWord)
        {
            *fTextOnly  = *fOldWriteFmt = FALSE;
            *fWordFmt   = TRUE;
        }
        else if (OFN.nFilterIndex == nWordText)
        {
            *fTextOnly    = *fWordFmt   = TRUE;
            *fOldWriteFmt = FALSE;
        }
        else if (OFN.nFilterIndex == nTextOnly)
        {
            *fTextOnly  = TRUE;
            *fWordFmt   = *fOldWriteFmt = FALSE;
        }

        *fBackup = OFN.Flags & OFN_READONLY;
    }

    return nRetval;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\createww.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* CreateWw.c -- WRITE window & document creation */




#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
//#define NOATOM
#define NOBITMAP
#define NOPEN
#define NODRAWTEXT
#define NOCOLOR
#define NOCREATESTRUCT
#define NOHDC
#define NOMB
#define NOMETAFILE
#define NOMSG
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOWH
#define NOWINOFFSETS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#include <windows.h>

#include "mw.h"
#include "dispdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "fontdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "code.h"
#include "prmdefs.h"
#if defined(OLE)
#include "obj.h"
#endif
#define PAGEONLY
#include "printdef.h"   /* printdefs.h */
/*
#include "dlgdefs.h"
*/

#ifdef  KOREA
#include    <ime.h>
#endif

#ifndef JAPAN                 //  added  10 Jun. 1992  by Hiraisi
/*
 *    These defines are not referrenced, and "dlgdefs.h" is included
 *  at the bottom of this file using JAPAN flag.          by Hiraisi
*/

    /* These defines replace dlgdefs.h to combat compiler heap overflows */
#define idiYes               IDOK
#define idiNo                3
#define idiCancel            IDCANCEL
#endif    //JAPAN

    /* These defines replace heapdefs.h and heapdata.h for the same
       irritating reason */
#define cwSaveAlloc         (128)
#define cwHeapMinPerWindow  (50)
#define cwHeapSpaceMin      (60)

/* E X T E R N A L S */

extern CHAR             (**vhrgbSave)[];
extern HANDLE           hParentWw;
extern HANDLE           hMmwModInstance;
extern struct WWD rgwwd[];
extern int wwMac;
extern struct FCB (**hpfnfcb)[];
extern struct DOD (**hpdocdod)[];
extern int docMac;
extern struct WWD *pwwdCur;
extern int fnMac;
extern CHAR stBuf[];

/* *** Following declarations used by ValidateHeaderFooter */
    /* Min, Max cp's for header, footer */
extern typeCP cpMinHeader;
extern typeCP cpMacHeader;
extern typeCP cpMinFooter;
extern typeCP cpMacFooter;
extern typeCP cpMinDocument;
extern typeCP vcpLimParaCache;
extern struct PAP vpapAbs;
    /* Current allowable cp range for display/edit/scroll */
extern typeCP cpMinCur;
extern typeCP cpMacCur;
    /* cpFirst and selection are saved in these during header/footer edit */
extern typeCP           cpFirstDocSave;
extern struct SEL       selDocSave;


short WCompSzC();
CHAR (**HszCreate())[];
struct FNTB **HfntbCreate();
#ifdef CASHMERE
struct SETB **HsetbCreate();
#else
struct SEP **HsepCreate();
#endif
struct PGTB **HpgtbCreate();


CHAR *PchFromFc( int, typeFC, CHAR * );
CHAR *PchGetPn( int, typePN, int *, int );
typeFC FcMacFromUnformattedFn( int );
int CchReadAtPage( int, typePN, CHAR *, int, int );


/* W W  N E W */
/* allocates and initializes a new wwd structure at wwMac.
ypMin, ypMax are estimates of the height of window used to allocate dl's.
wwMac++ is returned.
Errors: message is made and wwNil is returned.
remains to be initialized: xp, yp. Many fields must be reset if lower pane.
*/
WwNew(doc, ypMin, ypMax)
int doc, ypMin, ypMax;
{
    extern CHAR szDocClass[];
    struct EDL (**hdndl)[];
    register struct WWD *pwwd = &rgwwd[wwMac];
    int dlMax = (ypMax - ypMin) / dypAveInit;
    int cwDndl = dlMax * cwEDL;

#ifdef CASHMERE     /* WwNew is only called once in MEMO */
    if (wwMac >= wwMax)
        {
        Error(IDPMT2ManyWws);
        return wwNil;
        }
#endif

    bltc(pwwd, 0, cwWWDclr);

    if (!FChngSizeH( vhrgbSave,
                     cwSaveAlloc + wwMac * cwHeapMinPerWindow, false ) ||
        FNoHeap( pwwd->hdndl = (struct EDL (**)[]) HAllocate( cwDndl )) )
        {   /* Could not alloc addtl save space or dl array */
        return wwNil;
        }
    else
        bltc( *pwwd->hdndl, 0, cwDndl );

#ifdef SPLITTERS
    pwwd->ww = wwNil;
#endif /* SPLITTERS */

    /* contents of hdndl are init to 0 when allocated */
    pwwd->dlMac = pwwd->dlMax = dlMax;
    pwwd->ypMin = ypMin;
    pwwd->doc = doc;
    pwwd->wwptr = CreateWindow(
                    (LPSTR)szDocClass,
                    (LPSTR)"",
                    (WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE),
                    0, 0, 0, 0,
                    (HWND)hParentWw,
                    (HMENU)NULL,                /* use class menu */
                    (HANDLE)hMmwModInstance,    /* handle to window instance */
                    (LPSTR)NULL);               /* no params to pass on */
    if (pwwd->wwptr == NULL)
        return wwNil;

/* inefficient
    pwwd->cpFirst = cp0;
    pwwd->ichCpFirst = 0;
    pwwd->dcpDepend = 0;
    pwwd->fCpBad = false;
    pwwd->xpMin = 0;
    pwwd->xpMac = 0;
    pwwd->ypMac = 0;
    pwwd->fFtn = false;
    pwwd->fSplit= false;
    pwwd->fLower = false;
    pwwd->cpMin = cp0;
    pwwd->drElevator = 0;
    pwwd->fRuler = false;
    pwwd->sel.CpFirst = cp0;
    pwwd->sel.CpFirst = cp0;
*/

    pwwd->sel.fForward = true;
    pwwd->fDirty = true;
    pwwd->fActive = true;
    pwwd->cpMac = CpMacText(doc);
/* this is to compensate for the "min" in InvalBand */
    pwwd->ypFirstInval = ypMaxAll;

#ifdef JAPAN /*May 26,92 t-Yosho*/
{
    HDC hdc;
    hdc = GetDC(pwwd->wwptr);
    SelectObject(hdc,GetStocKObject(ANSI_VAR_FONT));
    ReleaseDC(pwwd->wwptr,hdc);
}
#endif

#ifdef  KOREA       /* for level 3, 90.12.12 by Sangl */
  { HANDLE  hKs;
    LPIMESTRUCT  lpKs;

    hKs = GlobalAlloc (GMEM_MOVEABLE|GMEM_DDESHARE,(LONG)sizeof(IMESTRUCT));
    lpKs = (LPIMESTRUCT)GlobalLock(hKs);
    lpKs->fnc = IME_SETLEVEL;
    lpKs->wParam = 3;
    GlobalUnlock(hKs);
    SendIMEMessage (pwwd->wwptr, MAKELONG(hKs,0));
    GlobalFree(hKs);
  }
#endif
    return wwMac++;
} /* end of  W w N e w  */




ChangeWwDoc( szDoc )
CHAR szDoc[];
{   /* Set up wwd fields for a new document to be held in wwdCurrentDoc.
       docCur is used as the document */
 extern HANDLE hParentWw;
 extern int docCur;
 extern struct SEL selCur;
 extern typeCP cpMinDocument;
 extern int vfInsEnd;
 extern int vfPrPages;
 extern int    vfDidSearch;
 extern typeCP cpWall;

 register struct WWD *pwwd = &rgwwd[wwDocument];

 pwwd->fDirty = true;

 ValidateHeaderFooter( docCur );

 pwwd->doc = docCur;
 pwwd->drElevator = 0;
 pwwd->ichCpFirst = 0;
 pwwd->dcpDepend = 0;
 pwwd->cpMin = pwwd->cpFirst = selCur.cpLim = selCur.cpFirst = cpMinDocument;
 selCur.fForward = TRUE;
 selCur.fEndOfLine = vfInsEnd = FALSE;
 pwwd->cpMac = CpMacText(docCur);
 TrashWw( wwDocument );

 SetScrollPos( pwwd->hVScrBar, pwwd->sbVbar,
               pwwd->drElevator = 0, TRUE);
 SetScrollPos( pwwd->hHScrBar, pwwd->sbHbar,
               pwwd->xpMin = 0, TRUE);

 NewCurWw(0, true);
 TrashCache();      /* Invalidate Scrolling cache */

 vfPrPages = FALSE;

 if (pwwd->fRuler)
     {
     ResetTabBtn();
     }

 SetTitle(szDoc);

/* Since we are changing document, ensure that we don't use parameters
                set by a search in a previous window by setting flag false */
 vfDidSearch = FALSE;
 cpWall = selCur.cpLim;
}




/* F N  C R E A T E  S Z */
int FnCreateSz(szT, cpMac, dty )
CHAR *szT;
typeCP cpMac;
int dty;
{             /* Create & Open a new file of the specified type. */
              /* If cpMac != cpNil, write an FIB to the file */
              /* if dty==dtyNetwork, generate a unique name in the current
                 directory and copy it to szT */
              /* WARNING: dty != dtyNetwork SUPPORT HAS BEEN REMOVED */

    int fn;
    struct FCB *pfcb; /* Be VERY careful of heap movement when using pfcb */
    struct FIB fib;
    CHAR (**hsz)[];
    CHAR sz[cchMaxFile];

    bltsz(szT, sz);
    sz[cchMaxFile - 1] = 0;

    if ((fn = FnAlloc()) == fnNil)
        return fnNil;

    pfcb = &(**hpfnfcb)[fn];
    pfcb->mdExt = pfcb->dty = dtyNormal;
    pfcb->mdFile = mdBinary;

    Assert( dty == dtyNetwork );

    if (!FCreateFile( sz, fn ))     /* Sets pfcb->hszFile, pfcb->rfn */
        return fnNil;

    FreezeHp();
    pfcb = &(**hpfnfcb)[fn];

        /* Copy unique filename to parm */
    bltsz( **pfcb->hszFile, szT );

#ifdef INEFFICIENT
    pfcb->fcMac = fc0;
    pfcb->pnMac = pn0;
#endif

    if (cpMac == cpNil)
        { /* Unformatted file */
#ifdef INEFFICIENT
        pfcb->fFormatted = false;
#endif
        MeltHp();
        }
    else
        { /* Formatted file; write FIB */
        bltbc(&fib, 0, cchFIB);
        pfcb->fFormatted = true;
#ifdef INEFFICIENT
        pfcb->pnChar = pfcb->pnPara = pfcb->pnFntb =
            pfcb->pnSep = pfcb->pnSetb = pfcb->pnBftb = pn0;
#endif
        MeltHp();
        fib.wIdent = wMagic;
        fib.dty = dtyNormal;
        fib.wTool = wMagicTool;
        fib.fcMac = cpMac + cfcPage;
        WriteRgch(fn, &fib, (int)cfcPage);
        }
    return fn;
} /* end of  F n C r e a t e S z  */





int DocCreate(fn, hszFile, dty)
int fn, dty;
CHAR (**hszFile)[];
{ /* Create a document */
extern int vfTextOnlySave;
struct FNTB **HfntbCreate();
struct TBD (**HgtbdCreate())[];
int doc;
int fFormatted, fOldWord;

struct DOD *pdod;
struct SEP **hsep = (struct SEP **)0;  /* MEMO only; for CASHMERE, use hsetb */
struct PGTB **hpgtb=(struct PGTB **)0;
struct FFNTB **hffntb=(struct FFNTB **)0;
struct TBD (**hgtbd)[]=(struct TBD (**)[])0;
struct FNTB **hfntb = (struct FNTB **) 0;
CHAR (**hszSsht)[];

fFormatted = (fn == fnNil) || (**hpfnfcb)[fn].fFormatted;
fOldWord = FALSE;

if ((doc = DocAlloc()) == docNil ||   /* HEAP MOVEMENT */
    !FInitPctb(doc, fn)) /* HEAP MOVEMENT */
    return docNil;

pdod = &(**hpdocdod)[doc];

pdod->fReadOnly = (fn != fnNil) && ((**hpfnfcb)[fn].mdFile == mdBinRO);
pdod->cref = 1;
pdod->fFormatted = fFormatted;
pdod->dty = dty;
pdod->fBackup = false;  /* Default: don't automatically make backup */
pdod->fDisplayable = TRUE;

switch(dty)
    { /* HEAP MOVEMENT */
case dtyHlp:
    if (FNoHeap(hpgtb = HpgtbCreate(fn)))
        goto ErrFree;
    if (FNoHeap(hffntb = HffntbCreateForFn(fn, &fOldWord)))
        goto ErrFree;
    break;

case dtyNormal:
    if (fn != fnNil && fFormatted)
        {
#ifdef FOOTNOTES
        if (FNoHeap(hfntb = HfntbCreate(fn)))
            goto ErrFree;
#endif
        if (FNoHeap(hsep = HsepCreate(fn)))
            goto ErrFree;
        if (FNoHeap(hpgtb = HpgtbCreate(fn)))
            goto ErrFree;
        if (FNoHeap(hgtbd = HgtbdCreate(fn)))
            goto ErrFree;
        }
    if (FNoHeap(hffntb = HffntbCreateForFn(fn, &fOldWord)))
        goto ErrFree;

#ifdef JAPAN                  //  added  10 Jun. 1992  by Hiraisi
{
    int fnCheckFacename(CHAR *, struct FFNTB **);
    int fontChg;   // This specifies whether facenames are changed or not.

    if( fn != fnNil && fFormatted ){
        fontChg = fnCheckFacename( *hszFile[0], hffntb );
        if( fontChg == docNil ){        // Changing facenames was cancelled.
            goto ErrFree;
        }
        else{
            if( fontChg == TRUE ){      // Facenames were changed.
                /* Flag wheter doc has been edited.    30 Jul. */
                (**hpdocdod)[doc].fDirty = TRUE;
            }
        }
    }
}
#endif    //JAPAN

    break;
case dtySsht:
    goto DtyCommon;
case dtyBuffer:
    if (fn != fnNil)
        {
#ifdef FOOTNOTES
        if (FNoHeap(hfntb = HfntbCreate(fn)))
            goto ErrFree;
#endif
        if (FNoHeap(hsep = HsepCreate(fn)))
            goto ErrFree;
        if (FNoHeap(hgtbd = HgtbdCreate(fn)))
            goto ErrFree;
        }
DtyCommon:
    hpgtb = 0;
    }

pdod = &(**hpdocdod)[doc];

pdod->hszFile = hszFile;
pdod->docSsht = docNil;
pdod->hfntb = hfntb;
pdod->hsep = hsep;
pdod->hpgtb = hpgtb;
pdod->hffntb = hffntb;
pdod->hgtbd = hgtbd;
if (fOldWord)
        if (!FApplyOldWordSprm(doc))
                goto ErrFree;

ApplyRHMarginSprm( doc );
vfTextOnlySave = !fFormatted;
return doc;

ErrFree:
        FreeH( hsep );
        FreeFfntb( hffntb );
        FreeH(hgtbd);
        FreeH(hpgtb);
#ifdef FOOTNOTES
        FreeH(hfntb);
#endif
        FreeH((**hpdocdod)[doc].hpctb);
        (**hpdocdod)[doc].hpctb = 0;

return docNil;
} /* end of  D o c C r e a t e  */




ApplyRHMarginSprm( doc )
int doc;
{   /* Apply a sprm to adjust paper-relative running head indents to
       be margin-relative */
extern typeCP cpMinDocument;
extern struct SEP vsepNormal;

ValidateHeaderFooter( doc );
if (cpMinDocument != cp0)
    {   /* Doc has running head/foot, apply sprm */
    CHAR rgb[ 2 + (2 * sizeof( int )) ];
    struct SEP **hsep = (**hpdocdod) [doc].hsep;
    struct SEP *psep = (hsep == NULL) ? &vsepNormal : *hsep;

    rgb[0] = sprmPRhcNorm;
    rgb[1] = 4;
    *((int *) (&rgb[2])) = psep->xaLeft;
    *((int *) (&rgb[2 + sizeof(int)])) = psep->xaMac -
                                         (psep->xaLeft + psep->dxaText);
    AddSprmCps( rgb, doc, cp0, cpMinDocument );
    }
}




int DocAlloc()
{
int doc;
struct DOD *pdod = &(**hpdocdod)[0];
struct DOD *pdodMac = pdod + docMac;

for (doc = 0; pdod < pdodMac; ++pdod, ++doc)
    if (pdod->hpctb == 0)
        return doc;
if (!FChngSizeH((int **)hpdocdod, cwDOD * ++docMac, false))
    {
    --docMac;
    return docNil;
    }
return docMac - 1;
} /* end of  D o c A l l o c  */

FInitPctb(doc, fn)
int doc, fn;
{ /* Initialize the piece table for a doc, given its initial fn */
struct PCTB **hpctb;
struct DOD *pdod;
struct PCTB *ppctb;
struct PCD *ppcd;
typeFC dfc;
typeCP cpMac;

hpctb = (struct PCTB **)HAllocate(cwPCTBInit);  /* HM */
if (FNoHeap(hpctb))
    return false;
pdod = &(**hpdocdod)[doc];
ppctb = *(pdod->hpctb = hpctb); /* Beware hp mvmt above */
ppcd = ppctb->rgpcd;
dfc = (fn != fnNil && (**hpfnfcb)[fn].fFormatted ? cfcPage : fc0);
cpMac = (fn == fnNil ? cp0 : (**hpfnfcb)[fn].fcMac - dfc);

ppctb->ipcdMax = cpcdInit;
ppctb->ipcdMac = (cpMac == cp0 ) ? 1 : 2; /* One real piece and one end piece */
ppcd->cpMin = cp0;

if ((pdod->cpMac = cpMac) != cp0)
    {
    ppcd->fn = fn;
    ppcd->fc = dfc;
    SETPRMNIL(ppcd->prm);
    ppcd->fNoParaLast = false;
    (++ppcd)->cpMin = cpMac;
    }

ppcd->fn = fnNil;
SETPRMNIL(ppcd->prm);
ppcd->fNoParaLast = true;

pdod->fDirty = false;
return true;
} /* end of  F I n i t P c t b  */

int FnAlloc()
{ /* Allocate an fn number */
int fn;
struct FCB *pfcb;

for (fn = 0 ; fn < fnMac ; fn++)
    if ((**hpfnfcb)[fn].rfn == rfnFree)
    goto DoAlloc;
if (!FChngSizeH(hpfnfcb, (fnMac + 1) * cwFCB, false))
    return fnNil;
fn = fnMac++;

DoAlloc:
bltc(pfcb = &(**hpfnfcb)[fn], 0, cwFCB);
pfcb->rfn = rfnFree;
return fn;
} /* end of  F n A l l o c  */



fnNewFile()
{       /* Open a new, fresh, untitled document in our MEMO window */
        /* Offer confirmation if the current doc is dirty & permit save */
 extern HANDLE hMmwModInstance;
 extern HANDLE hParentWw;
 extern int docCur;
 extern struct SEL selCur;
 extern typeCP cpMinDocument;
 extern int vfTextOnlySave, vfBackupSave;
 extern CHAR szUntitled[];

 if (FConfirmSave())    /* Allow the user to save if docCur is dirty */
    {

#if defined(OLE)
    if (ObjClosingDoc(docCur,szUntitled))
        return;
#endif

    KillDoc( docCur );

    docCur = DocCreate( fnNil, HszCreate( "" ), dtyNormal );
    Assert( docCur != docNil );
    ChangeWwDoc( "" );

#if defined(OLE)
    ObjOpenedDoc(docCur); // very unlikely to fail, not fatal if it does
#endif

#ifdef WIN30
    FreeUnreferencedFns();
#endif
    }
} /* end of  f n N e w F i l e  */







struct FFNTB **HffntbCreateForFn(fn, pfOldWord)
/* returns heap copy of ffntb (font names) for fn */

int fn, *pfOldWord;
{
struct FFNTB **hffntb;
typePN pn;
struct FCB *pfcb;
typePN pnMac;
#ifdef NEWFONTENUM
BOOL fCloseAfterward;
#endif

if (FNoHeap(hffntb = HffntbAlloc()))
        return(hffntb);
pfcb = &(**hpfnfcb)[fn];
pn = pfcb->pnFfntb;
if (fn == fnNil || !pfcb->fFormatted)
        {
#if WINVER >= 0x300
        /* WINBUG 8992: Clean up so don't lose alloc'd memory! ..pault 2/12/90 */
        FreeFfntb(hffntb);
#endif
        hffntb = HffntbNewDoc(FALSE);
        }
else if (pn != (pnMac=pfcb->pnMac))
        {   /* "normal" memo file - has a font table */
        CHAR *pch;
        int cch;
        int iffn;
        int iffnMac;

        /* Read the first page:
                bytes 0..1              iffnMac
                0..n sections of:
                    bytes 0..1          cbFfn
                    bytes 2..cbFfn+2    Ffn
                bytes x..x+1            0xFFFF  (end of page)
            OR  bytes x..x+1            0x0000  (end of font table) */

        pch = PchGetPn( fn, pn, &cch, FALSE );
        if (cch != cbSector)
            goto Error;
        iffnMac = *( (int *) pch);
        pch += sizeof (int);
#ifdef NEWFONTENUM
        /* Since we now support multiple charsets, but write 2 and write 1
           documents did not save these in their ffntb's, we have to do an
           extra step now in order to "infer" the proper charset values.  We
           enumerate all the possible fonts, and then as we read in each new
           document font we try to match it up with what the system knows
           about ..pault 10/18/89 */
        fCloseAfterward = FInitFontEnum(docNil, 32767, FALSE);
#endif

        for ( iffn = 0; ; )
            {
            /* Add ffn entries from one disk page to the font table */

            while ( TRUE )
                {
                int cb = *((int *) pch);

                if (cb == 0)
                    goto LRet;      /* Reached end of table */
                else if (cb == -1)
                    break;          /* Reached end of disk page */
                else
                    {
#ifdef NEWFONTENUM
                    /* Having added the chs field to the (RAM) FFN structure,
                       we now have trouble reading FFN's from the document 
                       directly.  And because Write was designed very early
                       without regard to variable charsets, we can't store 
                       the charset value along with the fontname, so we have
                       to infer it! ..pault */
                    CHAR rgbFfn[ibFfnMax];
                    struct FFN *pffn = (struct FFN *)rgbFfn;
                    pch += sizeof(int);

                    bltsz(pch + sizeof(BYTE), pffn->szFfn);
                    pffn->ffid = *((FFID *) pch);
                    pffn->chs = ChsInferred(pffn);
                    if (FtcAddFfn(hffntb, pffn) == ftcNil)
#else
                    if (FtcAddFfn( hffntb, pch += sizeof(int) ) == ftcNil)
#endif
                        {
Error:
#ifdef NEWFONTENUM
                        if (fCloseAfterward)
                            EndFontEnum();
#endif
                        FreeFfntb( hffntb );
                        return (struct FFNTB **) hOverflow;
                        }
                    iffn++;
                    if (iffn >= iffnMac)
                            /* Reached last item in table, by count */
                            /* This is so we can read old WRITE files, */
                            /* in which the table was not terminated by 0 */
                        goto LRet;
                    pch += cb;
                    }
                }   /* end while */

            /* Read the next page from the file. Page format is like the first
               ffntb page (see above) but without the iffnMac */

            if (++pn >= pnMac)
                break;
            pch = PchGetPn( fn, pn, &cch, FALSE );
            if (cch != cbSector)
                goto Error;
            }   /* end for */
        }
else
        {
        /* word file - create a simple font table that we can map word's
           fonts onto */

        /* temporarily we map them all onto one font - soon we'll have a set */
#if WINVER >= 0x300
        /* WINBUG 8992: Clean up so don't lose alloc'd memory! ..pault 2/12/90 */
        FreeFfntb(hffntb);
#endif
        hffntb = HffntbNewDoc(TRUE);
        *pfOldWord = TRUE;
        }

LRet:
#ifdef NEWFONTENUM
            if (fCloseAfterward)
                EndFontEnum();
#endif
return(hffntb);
}



struct FFNTB **HffntbNewDoc(fFullSet)
/* creates a font table with the default font for this doc */

int fFullSet;
{
struct FFNTB **hffntb;

hffntb = HffntbAlloc();
if (FNoHeap(hffntb))
        return(hffntb);

/* make sure we at least have a "standard" font */
#ifdef  KOREA    /* ROMAN as family of standard font(myoungjo). sangl 91.4.17 */
if (!FEnsurePffn(hffntb, PffnDefault(FF_ROMAN)))
#else
if (!FEnsurePffn(hffntb, PffnDefault(FF_DONTCARE)))
#endif
        {
        goto BadAdd;
        }

if (fFullSet)
        /* we need a full set of fonts for word ftc mapping */
        if (!FEnsurePffn(hffntb, PffnDefault(FF_MODERN)) ||
#ifdef  KOREA
            !FEnsurePffn(hffntb, PffnDefault(FF_DONTCARE)) ||
#else
            !FEnsurePffn(hffntb, PffnDefault(FF_ROMAN)) ||
#endif
            !FEnsurePffn(hffntb, PffnDefault(FF_SWISS)) ||
            !FEnsurePffn(hffntb, PffnDefault(FF_SCRIPT)) ||
            !FEnsurePffn(hffntb, PffnDefault(FF_DECORATIVE)))
        BadAdd:
                {
                FreeFfntb(hffntb);
                hffntb = (struct FFNTB **)hOverflow;
                }

return(hffntb);
}



CHAR * PchBaseNameInUpper(szName)
CHAR *szName;
{
    CHAR * pchStart = szName;
#ifdef DBCS
    CHAR * pchEnd = AnsiPrev( pchStart, pchStart + CchSz(szName) );
#else
    CHAR * pchEnd = pchStart + CchSz(szName) - 1;
#endif

    while (pchEnd >= pchStart)
        {
#ifdef DBCS
        if (*pchEnd == '\\' || *pchEnd == ':') {
            // T-HIROYN 1992.07.31 bug fix
            pchEnd++;
            break;
        }
        else if (!IsDBCSLeadByte(*pchEnd))
           *pchEnd = ChUpper(*pchEnd);
      {
        LPSTR lpstr = AnsiPrev( pchStart, pchEnd );
        if( pchEnd == lpstr )
            break;
        pchEnd = lpstr;
      }
#else
        if (*pchEnd == '\\' || *pchEnd == ':')
            break;
        else
           *pchEnd = ChUpper(*pchEnd);
        pchEnd--;
#endif
        }
#ifdef DBCS
    return(AnsiUpper(pchEnd));
#else
    return(pchEnd+1);
#endif
}


SetTitle(szSource)
CHAR *szSource;
{
extern CHAR szUntitled[];
extern int  vfIconic;
extern CHAR szAppName[];
extern CHAR szSepName[];

CHAR *pch = stBuf;
CHAR szDocName[cchMaxFile];

    pch += CchCopySz((PCH)szAppName, stBuf);
    pch += CchCopySz((PCH)szSepName, pch);

    if (szSource[0] == '\0')
        {
        CchCopySz( szUntitled, pch );
        }
    else
        { /* get the pointer to the base file name and convert to upper case */
        CchCopySz(szSource, szDocName);
        CchCopySz(PchBaseNameInUpper(szDocName), pch);
        }
    SetWindowText(hParentWw, (LPSTR)stBuf);
}



ValidateHeaderFooter( doc )
{       /* Look for a MEMO-style running header and/or footer in the document.
           We scan from the beginning of the document, taking the first
           contiguous sequence of running head paragraphs as the running
           head region, and the first contiguous sequence of running foot
           paragraphs as the running foot region. We break the process
           at the first non-running paragraph or when we have both runs
           Update values of cpMinDocument, cpMinFooter, cpMacFooter,
           cpMinHeader, cpMacHeader.
           These ranges INCLUDE the EOL (and Return, if CRLF) at the end of the
           header/footer
           If we are currently editing a header or footer in the passed doc,
           adjust the values of cpFirstDocSave, selDocSave to reflect the
           change */

 extern int docScrap;
 extern typeCP vcpFirstParaCache;
 extern typeCP vcpLimParaCache;

#define fGot        0
#define fGetting    1
#define fNotGot     2

 int fGotHeader=fNotGot;
 int fGotFooter=fNotGot;
 typeCP cpMinDocT=cpMinDocument;
 typeCP cpMinCurT = cpMinCur;
 typeCP cpMacCurT = cpMacCur;
 typeCP cp;

 if (doc == docNil || doc == docScrap)
    return;

 /* Want access to the entire doc cp range for this operation */

 cpMinCur = cp0;
 cpMacCur = (**hpdocdod) [doc].cpMac;

 cpMinDocument = cpMinFooter = cpMacFooter = cpMinHeader = cpMacHeader = cp0;

 for ( cp = cp0;
      (cp < cpMacCur) && (CachePara( doc, cp ), vpapAbs.rhc);
      cp = vcpLimParaCache )
    {
    int fBottom=vpapAbs.rhc & RHC_fBottom;

    if (fBottom)
        {
        if (fGotHeader == fGetting)
            fGotHeader = fGot;
        switch (fGotFooter) {
            case fGot:
                    /* Already have footer from earlier footer run */
                return;
            case fNotGot:
                cpMinFooter = vcpFirstParaCache;
                fGotFooter = fGetting;
                /* FALL THROUGH */
            case fGetting:
                cpMacFooter = cpMinDocument = vcpLimParaCache;
                break;
            }
        }
    else
        {
        if (fGotFooter == fGetting)
            fGotFooter = fGot;
        switch (fGotHeader) {
            case fGot:
                    /* Already have header from earlier header run */
                return;
            case fNotGot:
                cpMinHeader = vcpFirstParaCache;
                fGotHeader = fGetting;
                /* FALL THROUGH */
            case fGetting:
                cpMacHeader = cpMinDocument = vcpLimParaCache;
                break;
             }
        }
    }   /* end of for loop through paras */

    /* Restore saved cpMacCur, cpMinCur */
 cpMinCur = cpMinCurT;
 cpMacCur = cpMacCurT;

    /* Adjust saved cp's that refer to the document to reflect
       header/footer changes */
 if ((wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter) &&
     wwdCurrentDoc.doc == doc )
    {
    typeCP dcpAdjust=cpMinDocument - cpMinDocT;

    if (dcpAdjust != (typeCP) 0)
        {
        selDocSave.cpFirst += dcpAdjust;
        selDocSave.cpLim   += dcpAdjust;
        cpFirstDocSave += dcpAdjust;
        }
    }
}

#ifdef JAPAN                  //  added  10 Jun. 1992  by Hiraisi

#include "dlgdefs.h"
BOOL FAR PASCAL _export DialogCvtFont( HWND, UINT, WPARAM, LPARAM );

BOOL FAR PASCAL _export DialogCvtFont( hDlg, uMsg, wParam, lParam )
HWND   hDlg;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
{
    switch (uMsg){
    case WM_INITDIALOG:
        {
        char szPrompt[cchMaxSz];
        CHAR *pch = stBuf;

        if( *pch == '\\' )
            pch++;
        MergeStrings(IDPMTFontChange, pch, szPrompt);
        SetDlgItemText(hDlg, idiChangeFont, (LPSTR)szPrompt);
        }
        break;
    case WM_COMMAND:
        switch (wParam){
        case IDOK:
            EndDialog(hDlg, FALSE);
            break;
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return(FALSE);
    }
    return(TRUE);
}

/*
 *    This function checks facenames and removes '@' from "@facename"(s)
 *  if facenames with '@' are found in doc of WRITE.
 *      Return : TRUE=deleted ,FALSE=not found ,docNil(-1)=cancelled
*/
int fnCheckFacename( sz, hffntb )
CHAR *sz;
struct FFNTB **hffntb;
{

    struct FFNTB *pffntb;
    struct FFN *pffn;
    int  ix, len;
    BOOL bChange, bRet;
    CHAR *szFfn;
    CHAR *pch = stBuf;
    FARPROC lpDialogCvtFont;

    pffntb = *hffntb;
    bChange = FALSE;
    for( ix = 0; ix < pffntb->iffnMac; ix++ ){
        pffn = *pffntb->mpftchffn[ix];
        szFfn = pffn->szFfn;
        if( *szFfn == '@' ){
            if( !bChange ){
                lpDialogCvtFont = MakeProcInstance(DialogCvtFont,
                                                   hMmwModInstance);
                CchCopySz(PchBaseNameInUpper(sz), pch);
                bRet = DialogBox( hMmwModInstance,
                                  MAKEINTRESOURCE(dlgChangeFont),
                                  hParentWw, lpDialogCvtFont);
                FreeProcInstance(lpDialogCvtFont);
                if( bRet )
                    return(docNil);

                bChange = TRUE;
            }
            len = CchCopySz( szFfn+1, pffn->szFfn);
            *(pffn->szFfn+len) = '\0';
        }
    }

    return(bChange);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\curskeys.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* curskeys.c-- cursor key movement subroutines */
/* Oct 4, 1984, KJS */

#define NOGDICAPMASKS
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOATOM
#define NOSYSCOMMANDS
#define NOCOMM
#define NOSOUND
#define NOMENUS
#define NOGDI
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "debug.h"
#include "fmtdefs.h"
#include "printdef.h"

struct DOD          (**hpdocdod)[];
extern typeCP       cpMinCur;
extern typeCP       cpMacCur;
extern struct PAP   vpapAbs;
extern int          vfSeeSel;
extern int          vfShiftKey;
extern struct FLI   vfli;
extern struct SEL   selCur;
extern int          wwCur;
extern struct WWD   rgwwd[];
extern struct WWD   *pwwdCur;    /* Current window descriptor */
extern int          docCur;
extern typeCP       vcpSelect;
extern int          vfSelAtPara;
extern int          vfLastCursor;
extern int          vfMakeInsEnd;
extern CHAR         *vpchFetch;

int vfSeeEdgeSel=FALSE; /* Whether Idle() should show edge of selection
                           even if selection is partially visible */

     /* Absolute x-position to try to achieve on up-down motions;
        used in this module only */
int vxpCursor;




MoveLeftRight( kc )
int kc;
{    /* Move or drag selection in left or right directions */
extern int vfInsEnd;
typeCP CpEdge();

extern int vfGotoKeyMode;
extern int xpRightLim;
int fDrag = vfShiftKey ;
int fFwdKey = FALSE;
int fForward = selCur.fForward;
int sty;
typeCP cp;

MSG msg;

PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

vfGotoKeyMode |= (GetKeyState( kcGoto & ~wKcCommandMask) < 0);

switch( kc ) {
    int dl;
    int xp;
    int xpJunk;

    default:
        Assert( FALSE );
        return;
    case kcNextPara:
        fFwdKey = TRUE;
    case kcPrevPara:
        sty = styPara;
        break;
    case kcWordRight:
        fFwdKey = TRUE;
    case kcWordLeft:
        sty = styWord;
        break;
    case kcEndLine:
        if (vfGotoKeyMode)
            {
            MoveUpDown( kcEndDoc );
            return;
            }
        xp = xpRightLim;
        goto GoDlXp;

    case kcBeginLine:
        if (vfGotoKeyMode)
            {
            MoveUpDown( kcTopDoc );
            return;
            }
        xp = xpSelBar - wwdCurrentDoc.xpMin;
GoDlXp:

        if (CpBeginLine( &dl, CpEdge() ) == selCur.cpFirst &&
            selCur.cpFirst > cpMinCur && vfInsEnd )
            {
            CpBeginLine( &dl, selCur.cpFirst - 1);
            }
        vcpSelect = cpNil;
        vfSelAtPara = false;
        SelectDlXp( dl, xp, styChar, fDrag );
        goto SeeSel;
    case kcRight:
        fFwdKey = TRUE;
    case kcLeft:
        sty = (vfGotoKeyMode) ? stySent : styChar;
        break;
 }

    /* Find cp to start extension from */
if (selCur.cpLim == selCur.cpFirst || fDrag)
       cp = fForward ? selCur.cpLim : selCur.cpFirst;
else
       cp = fFwdKey ? selCur.cpLim - 1 : selCur.cpFirst + 1;

/* Catch attempts to run off the document start or end */

if (fFwdKey)
    {
    if (cp == cpMacCur)
        {
        _beep();
        return;
        }
    }
else if (cp == cpMinCur)
    {
    _beep();
    return;
    }

if (fFwdKey)
    {
    if (cp >= cpMacCur)
            /* If at end, stay at end.  */
        cp = cpMacCur;
    else
        {
        cp = CpLimSty( cp, sty );
        }
    }
 else
    {
    if (cp > cpMinCur)
            /* So we go back to the PREVIOUS sty unit */
        cp--;
    cp = CpFirstSty( cp, sty );
    }

if (fDrag)
        { /* Drag selection edge to new bound. */
/* If selection flips, keep one sty unit selected EXCEPT if it's styChar;
   when dragging by char, the selection can become an insertion point */

        ChangeSel( cp, sty == styChar ? styNil : sty );
        }
else
        {
        Select(cp, cp);
        if (!fFwdKey)
                selCur.fForward = false;
        }

SeeSel:

vfSeeSel = true;    /* Tell Idle to scroll the selection into view */
vfSeeEdgeSel = true;  /* And the edge of it even if it's already partly visible */
return;
}




/* M O V E  U P  D O W N */
MoveUpDown(kc)
int kc;
{ /* Move the selection in direction of kc, in up or down directions */

  /* Our goal with up-and-down motions is to keep (if applicable) an */
  /* absolute x-position to which the cursor tends to go if there is */
  /* text on the line at that position.  We set this position (vxpCursor) */
  /* when we process the first up/down key, and hang onto it thereafter */
  /* A global flag, vfLastCursor, tells us whether we should use the */
  /* last calculated setting of vxpCursor or generate a new one.  vxpCursor */
  /* is set below and cleared in Select() and AlphaMode() */

extern int vfGotoKeyMode;
int fDrag = vfShiftKey;
int dl;
typeCP cpT;
struct EDL (**hdndl)[] = wwdCurrentDoc.hdndl;
register struct EDL *pedl;
int dipgd;
int xpNow;

MSG msg;

PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

vfGotoKeyMode |= (GetKeyState( kcGoto & ~wKcCommandMask) < 0);

 /* Compute dl, vxpCursor for selection starting point */

 switch (kc)
    {
    default:
        Assert( FALSE );
        break;
    case kcUp:
        if (vfGotoKeyMode)
            {   /* GOTO-UP is Prev Para */
            MoveLeftRight( kcPrevPara );
            return;
            }
    case kcPageUp:
    case kcUpScrollLock:
    case kcTopScreen:
    case kcTopDoc:
        cpT = selCur.fForward && fDrag ? selCur.cpLim : selCur.cpFirst;
        break;
    case kcDown:
        if (vfGotoKeyMode)
            {   /* GOTO-DOWN is Next Para */
            MoveLeftRight( kcNextPara );
            return;
            }
    case kcPageDown:
    case kcDownScrollLock:
    case kcEndScreen:
    case kcEndDoc:
        cpT = selCur.fForward || !fDrag ? selCur.cpLim : selCur.cpFirst;
        break;
    }

 CpToDlXp( cpT, &dl, (vfLastCursor) ? &xpNow : &vxpCursor );


 /* HACK: If the guy is dragging up/down and is on the first/last line of
    the doc but not right at the start/end of the doc, extend him to
    the start/end of the doc */

 if (fDrag && !vfGotoKeyMode)
    {
    switch (kc) {
       case kcUp:
 /* Special fix for dragging upward: if we are seeking up to a position
    that is equivalent in cp space to where we are now, force a decrement
    of the source dl so we really go up a line */

        if (vfLastCursor && xpNow <= xpSelBar && vxpCursor > xpSelBar &&
                                                 cpT > cpMinCur)
            {
            CpToDlXp( CpFirstSty( cpT - 1, styChar), &dl, &xpNow );
            }
       case kcPageUp:
       case kcUpScrollLock:
            if (wwdCurrentDoc.cpFirst == cpMinCur && cpT > cpMinCur)
                if (dl == 0 || kc == kcPageUp)
                    {
                    MoveUpDown( kcTopDoc );
                    return;
                    }
            break;
        case kcPageDown:
        case kcDown:
        case kcDownScrollLock:
            {
            typeCP cpLimDl;

            pedl = &(**hdndl) [dl];
            cpLimDl = pedl->cpMin + pedl->dcpMac;
            if (cpLimDl >= cpMacCur && cpT >= pedl->cpMin && cpT < cpMacCur)
                {
                MoveUpDown( kcEndDoc );
                return;
                }
            break;
            }
        }
    }

 /* Do the cursor movement, scrolling if necessary */
 switch (kc)
    {
    case kcPageUp:
        if (vfGotoKeyMode)
            {   /* Go to previous printed page */
            extern int vipgd;
            extern int rgval[];
            struct PGTB **hpgtb;
            int ipgd;

            dipgd = -1;

            CachePage( docCur, selCur.cpFirst );
            if (vipgd != iNil)
                {
                hpgtb = (**hpdocdod) [docCur].hpgtb;
                if ((**hpgtb).rgpgd [vipgd].cpMin != selCur.cpFirst)
                        /* Not at page start; go there first */
                    dipgd++;
                }

GoPage:     CachePage( docCur, selCur.cpFirst ); /*validate vipgd*/
            hpgtb = (**hpdocdod)[docCur].hpgtb;
            if ((vipgd == iNil) ||
                ((ipgd = vipgd + dipgd) < 0) ||
                (ipgd >= (**hpgtb).cpgd))
                {   /*Whole doc on one page || run off either end*/
                _beep();
                }
            else
                {
                rgval [0] = (**hpgtb).rgpgd[ipgd].pgn;
                CmdJumpPage();  /* rgval [0] is a parm to CmdJumpPage */
                }
            return;
            }
        ScrollUpDypWw();
        break;
    case kcPageDown:
        if (vfGotoKeyMode)
            {   /* Go to next printed page */
            dipgd = 1;
            goto GoPage;
            }

        /* Special case for extending selection one page down from the
           top line of the ww -- extend to the NEXT line so we don't
           end up without any part of the selection on the screen */

        ScrollDownCtr( 100 );   /* 100 > tr's in a page */
        vcpSelect = cpNil;
        vfSelAtPara = false;
        SelectDlXp( dl, (**hdndl)[dl].fGraphics ? 0 : vxpCursor, styChar, fDrag );
        if (fDrag && (dl == 0) && selCur.cpLim == wwdCurrentDoc.cpFirst)
            {
            MoveUpDown( kcDown );
            }
        goto DontSelect;

    case kcUpScrollLock:
    case kcUp:
        UpdateWw(wwCur, false);

        pedl = &(**hdndl) [dl];

        if ( fDrag && (selCur.fForward ? selCur.cpLim : selCur.cpFirst) ==
                                     pedl->cpMin && pedl->cpMin > cpMinCur)
            {   /* Up into picture == left */
            CachePara( docCur, pedl->cpMin - 1 );
            if (vpapAbs.fGraphics)
                {
                MoveLeftRight( kcLeft );
                return;
                }
            }

        if ((pedl->cpMin == cpMinCur) && (pedl->ichCpMin == 0))
            {       /* At beginning of doc or area */
            int xpT;

            _beep();
            CpToDlXp(cpMinCur, &dl, &xpT);
            goto DoSelect;
            }
        else if ( (dl == 0) || (kc == kcUpScrollLock) )
            {    /* At top of screen OR keep posn */
            ScrollUpCtr( 1 );
            UpdateWw(wwCur, false);
            }
        else
            {
            --dl;
            }
        break;

    case kcDownScrollLock:
    case kcDown:
        UpdateWw(wwCur, false);
        pedl = &(**hdndl)[dl];
        {
        int xpT;
        typeCP cp;

        cp = pedl->cpMin + pedl->dcpMac;

        if (selCur.cpFirst < selCur.cpLim && selCur.fForward &&
            pedl->cpMin == selCur.cpLim &&
            cp < cpMacCur &&
            (!fDrag ||
               ((vxpCursor > pedl->xpLeft + xpSelBar) &&
                (pedl->dcpMac > ccpEol))))
            {   /* In this case, it thinks we are at the start of the
                   next line; incrementing/scrolling is unnecessary */
            goto DoSelect;
            }

        if (pedl->fGraphics)
            {   /* Special for pictures */
            MoveLeftRight( kcRight );

            if (!fDrag)
                {
                extern struct PAP vpapAbs;

                CachePara( docCur, selCur.cpFirst );
                if (vpapAbs.fGraphics)
                    {
                    vfShiftKey = TRUE;
                    MoveLeftRight( kcRight );
                    SetShiftFlags();
                    }
                }
            goto DontSelect;
            }

        if (cp > cpMacCur)
            {
            if (selCur.cpLim == selCur.cpFirst || selCur.cpLim == cpMacCur)
                    /* test is because CpToDlXp cannot account for
                       selection extending to end of next-to-last line */
                _beep();
            CpToDlXp(cpMacCur, &dl, &xpT);
            goto DoSelect;
            }
        if ( (dl >= wwdCurrentDoc.dlMac - 2) || (kc == kcDownScrollLock) )
            {   /* within one line of window end */
            ScrollDownCtr( 1 );
            UpdateWw(wwCur, false);
            }
        else
            dl++;
        }
        break;

    case kcTopScreen:
        dl = 0;
        break;
    case kcEndScreen:
        dl = wwdCurrentDoc.dlMac - 1;
        if ( dl > 0 && (**wwdCurrentDoc.hdndl) [dl].yp >= wwdCurrentDoc.ypMac)
            {   /* Back up if last (and not only) dl is partially clipped */
            dl--;
            }
        break;
    case kcTopDoc:
        CpToDlXp(cpMinCur, &dl, &vxpCursor);
        break;
    case kcEndDoc:
        CpToDlXp(cpMacCur, &dl, &vxpCursor);
        break;

    default:
        return;
    }

DoSelect:              /* select at/to position vxpCursor on line dl */
 vcpSelect = cpNil;
 vfSelAtPara = false;
 SelectDlXp( dl, (**hdndl)[dl].fGraphics ? 0 : vxpCursor, styChar, fDrag );
DontSelect:
 vfLastCursor = true;    /* don't recalc vxpCursor next time */
}




/* C P  T O  D L  X P */
CpToDlXp(cp, pdl, pxp)
typeCP cp;
int *pdl, *pxp;
{ /* Transform cp into cursor coordinates */
extern int vfInsEnd;
typeCP cpBegin;
int dcp;
int xp;

 if (!vfInsEnd)
    PutCpInWwHz(cp);

 cpBegin = CpBeginLine(pdl, cp);
 ClearInsertLine();
 if ( (cp == selCur.cpFirst) && (cp == selCur.cpLim) && vfInsEnd &&
      cp > cpMinCur)
    {   /* cp indicates we are at line beginning, but we are really
           kludged at the end of the previous line */
    CpToDlXp( cp - 1, pdl, pxp );
    PutCpInWwHz( cp - 1 );
    return;
    }

 dcp = (int) (cp - cpBegin);
 FormatLine(docCur, cpBegin, 0, cpMacCur, flmSandMode);
 xp = DxpDiff(0, dcp, &xp) + vfli.xpLeft;
 *pxp = xp + (xpSelBar - wwdCurrentDoc.xpMin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\debug.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* DEBUG.C -- Diagnostic routines for WRITE */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOATOM
#define NODRAWTEXT
#define NOMETAFILE
#define NOOPENFILE
#define NOWH
#define NOWINOFFSETS
#define NOOPENFILE
#define NORECT
#define NOSOUND
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "prmdefs.h"
#include "editdefs.h"
#include "docdefs.h"

extern struct WWD rgwwd[];


extern beep();
extern toggleProf();

#ifdef DEBUG

BOOL fDebugOut = TRUE;

fnTest()
{
beep();
TestFormat();
beep();
beep();
dbgWait();      /* for use by symdeb to check variables */
}

TestFormat()
{
     //toggleProf();
}

dbgWait()
{
}


/* --- Integrity check for all piece tables in all docs --- */

CheckPctb()
{
extern int fnMac;
extern int fPctbCheck;
extern struct DOD (**hpdocdod) [];
extern struct FCB (**hpfnfcb) [];
extern int docMac;
int doc;
struct PCTB **hpctb;
struct PCTB *ppctb;
struct DOD *pdod;
struct PCD *ppcd;
int ipcd;

if (!fPctbCheck)
    return;

for ( doc = 0, pdod = &(**hpdocdod) [0] ; doc < docMac; doc++, pdod++ )
    if ((hpctb = pdod->hpctb) != 0)
        {   /* Doc entry is nonempty -- check it */
        ppctb = *hpctb;

            /* # pieces used does not exceed # allocated */
        Assert( ppctb->ipcdMac <= ppctb->ipcdMax );
        Assert( ppctb->ipcdMac >= 1 );

#ifndef OURHEAP
            /* handle contains enough space for pieces */
        Assert( LocalSize( (HANDLE)hpctb ) >= sizeof (struct PCTB)  +
                (sizeof (struct PCD) * (ppctb->ipcdMax - cpcdInit)));
#endif

        /* Now check the contents of the pieces */

        {

            /* cpMin of first piece is always 0 for nonnull piece table */
        Assert( ppctb->rgpcd [0].cpMin == cp0 || ppctb->rgpcd [0].fn == fnNil);

        for ( ipcd = 0, ppcd = &(ppctb->rgpcd [0]); ipcd < ppctb->ipcdMac;
              ipcd++, ppcd++ )
            {
            int fn = ppcd->fn;
            typeFC fc = ppcd->fc;
            unsigned sprm;
            struct FCB *pfcb;

            if (fn == fnNil)
                {   /* end piece */

                    /* first piece with fnNil is in fact the end piece */
                /* Assert( ipcd == ppctb->ipcdMac - 1 ); */
                    /* end piece is intact */
                Assert( bPRMNIL(ppcd->prm) );
                break;
                }

            if (ipcd > 0)
                    /* Pieces are in ascending cp order */
                Assert(ppcd->cpMin > (ppcd-1)->cpMin);

                /* fn is valid */
            Assert( (fn >= 0 && fn < fnMac) || fn == fnInsert );
            pfcb = &(**hpfnfcb) [fn];
                /* fn does not point to an unallocated fcb entry */
            Assert( pfcb->rfn != rfnFree );
                /* fc is reasonable for the fn */
            Assert( fc >= 0 );
            Assert( fc + (ppcd+1)->cpMin - ppcd->cpMin <= pfcb->fcMac );

                /* prm is a valid value */
            Assert( bPRMNIL(ppcd->prm) ||
                    (((struct PRM *) &ppcd->prm)->fComplex) ||
                    ((sprm = ((struct PRM *) &ppcd->prm)->sprm) > 0 &&
                    sprm < sprmMax) );
            }
        }

        }
}



/*      COMM Output routines        */

#define cchSzCommMax    100

static CHAR szCRLF[] = "\r\n";
BOOL vfCommDebug = fTrue;       /* True for AUX, False for LPT */

#if WINVER < 0x300
/* This method isn't quite working under Win 3.0 ..pault */
void CommSz( CHAR * );          /* Main string output, defined in doslib.asm */
#else
void CommSz( psz )
register CHAR *psz;
{
    CHAR szT[512];
    char *pszT;

    if (fDebugOut)
        {
        /* The following loops essentially copies psz to szT
           but with the addition that chars > 127 are changed 
           to a representation readable on a dumb terminal, i.e.
           ASCII 164 shows up as '{164}' ..pault */

        for (pszT = szT; ; psz++)
            {
            if (*psz < 128)
                *(pszT++) = *psz;
            else
                {
                *(pszT++) = '{';
                ncvtu((int) *psz, &pszT);
                *(pszT++) = '}';
                }
            if (*psz == '\0')   /* finally copied null terminator */
                break;
            }

        OutputDebugString( (LPSTR) szT );
        }
}
#endif


CommSzNum( sz, num )
CHAR *sz;
int num;
{
CHAR szBuf[ cchSzCommMax ];
CHAR *pch = szBuf;

Assert( CchSz( sz ) <= cchSzCommMax );

pch = &szBuf[ CchCopySz( sz, szBuf ) ];
ncvtu( num, &pch );

CchCopySz( szCRLF, pch );

CommSz( szBuf );
}


/* This is extremely useful when displaying coordinates 
   when the values are not in contiguous locations */
CommSzNumNum( sz, num, num2 )
CHAR *sz;
int num, num2;
{
CHAR szBuf[ cchSzCommMax ];
CHAR *pch = szBuf;

Assert( CchSz( sz ) <= cchSzCommMax );

pch = &szBuf[ CchCopySz( sz, szBuf ) ];
ncvtu( num, &pch );
*(pch++) = ' ';
ncvtu( num2, &pch );

CchCopySz( szCRLF, pch );

CommSz( szBuf );
}


CommSzRgNum( sz, rgw, cw)
CHAR *sz;
int *rgw;
int cw;
{
CHAR szBuf[ cchSzCommMax ];
CHAR *pch = szBuf;

Assert( CchSz( sz ) <= cchSzCommMax );

pch = &szBuf[ CchCopySz( sz, szBuf ) ];
for ( ; cw > 0; cw--)
    {
    ncvtu( *(rgw++), &pch );
    *(pch++) = ' ';
    }

CchCopySz( szCRLF, pch );

CommSz( szBuf );
}


CommSzSz( sz1, sz2 )
CHAR *sz1, *sz2;
{
CHAR szBuf[ cchSzCommMax ];
int cch;

Assert( CchSz( sz1 ) + CchSz( sz2 ) - 1 <= cchSzCommMax );

cch = CchCopySz( sz1, szBuf );
cch += CchCopySz( sz2, &szBuf[ cch ] );
CchCopySz( szCRLF, &szBuf[ cch ] );

CommSz( szBuf );
}



/* ASSERT */

Do_Assert(pch, line, f)
PCH pch;
int line;
BOOL f;
{
 extern HWND    vhWndMsgBoxParent;
 extern FARPROC lpDialogAlert;
 static CHAR szAssert[] = "Assertion failure in ";
 static CHAR szLine[] = " at line ";


if (f)
     return;
 else
    {
#ifdef OURHEAP
    extern int cHpFreeze;
    int cHpFreezeT = cHpFreeze;
#endif
    CHAR szAlertMsg[50];
    PCH pchtmp;
    int  cch;
    int  idi;
    HWND hWndParent = (vhWndMsgBoxParent == NULL) ?
                               wwdCurrentDoc.wwptr : vhWndMsgBoxParent;

    bltbc((PCH)szAlertMsg, 0, 50);
    bltbyte((PCH)szAssert, (PCH)szAlertMsg, 21);
    pchtmp = (PCH)&szAlertMsg[21];
    bltbyte((PCH)pch, pchtmp, (cch = CchSz(pch) - 1));
    pchtmp += cch;
    bltbyte((PCH)szLine, pchtmp, 9);
    pchtmp += 9;
    ncvtu(line, (PCH)&pchtmp) - 1;
#ifdef OURHEAP
    cHpFreeze = 0;  /* So we don't panic in MdocLoseFocus */
#endif

    do
        {
        idi = MessageBox( hWndParent, (LPSTR) szAlertMsg,
                          (LPSTR)"Assert",
                          MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);
        switch (idi) {
            default:
            case IDABORT:
            case IDCANCEL:
                FatalExit( line );
                break;

            case IDIGNORE:
#ifdef OURHEAP
                cHpFreeze = cHpFreezeT;
#endif
                return;
            case IDRETRY:
                break;
            }
        }  while (idi == IDRETRY);
    }   /* end else */
} /* end of _Assert */


ShowDocPcd(szID, doc)
    CHAR    *szID;
    int     doc;
{
    struct PCTB **hpctb;
    struct PCD  *ppcdCur, *ppcdMac;
    extern struct DOD (**hpdocdod)[];

    hpctb = (**hpdocdod)[doc].hpctb;
    ppcdCur = &(**hpctb).rgpcd[0];
    ppcdMac = &(**hpctb).rgpcd[(**hpctb).ipcdMac];
    for (; ppcdCur < ppcdMac; ppcdCur++)
        {
        ShowPpcd(szID, ppcdCur);
        }
}


ShowPpcd(szID, ppcd)
    CHAR        *szID;
    struct PCD  *ppcd;
{
    /* Dump a given piece descriptor on COM1: along with a
       given an ID string.  */
    CommSz(szID);
    CommSz("\r\n");

    CommSzNum("ppcd: ", (int) ppcd);
    CommSzNum("cpMin: ", (int) (ppcd->cpMin));
    CommSzSz("fNoParaLast: ", (ppcd->fNoParaLast) ? "TRUE" : "FALSE");
    CommSzNum("fn: ", (int) (ppcd->fn));
    CommSzNum("fc: ", (int) (ppcd->fc));
    CommSzNum("prm: ", (int) *((int *) &(ppcd->prm)));
}



#endif      /* DEBUG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\debug.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef DEBUG

#ifdef SCRIBBLE
#define Scribble(a, b) fnScribble(a, b)
#else /* not SCRIBBLE */
#define Scribble(a, b)
#endif /* not SCRIBBLE */

#else /* not DEBUG */
#define Scribble(a, b)
#endif /* not DEBUG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\cmacros2.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg FILE_TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\cmacros3.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg UTIL_TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diadiv.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "docdefs.h"
#include "str.h"
#include "printdef.h"


extern HCURSOR vhcArrow;
extern int     vfCursorVisible;

extern int utCur;  /* current conversion unit */


BOOL far PASCAL DialogTabs(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles input to the Tabs dialog box. */

    extern struct DOD (**hpdocdod)[];
    extern int docCur;
    extern int vdocParaCache;
    extern HWND vhWndMsgBoxParent;
    extern int ferror;

    struct TBD (**hgtbd)[];
    int idi;

    switch (message)
    {
    case WM_INITDIALOG:
        /* Disable modeless dialog boxes. */
        EnableOtherModeless(FALSE);

        /* Set up the fields for each of the tabs. */
        hgtbd = (**hpdocdod)[docCur].hgtbd;
        if (hgtbd != NULL)
        {
        struct TBD *ptbd;
        unsigned dxa;
        CHAR szT[cchMaxNum];
        CHAR *pch;

        for (ptbd = &(**hgtbd)[0], idi = idiTabPos0; (dxa = ptbd->dxa) != 0;
          ptbd++, idi++)
            {
            pch = &szT[0];
            CchExpZa(&pch, dxa, utCur, cchMaxNum);
            SetDlgItemText(hDlg, idi, (LPSTR)szT);
            CheckDlgButton(hDlg, idi + (idiTabDec0 - idiTabPos0), ptbd->jc
              == (jcTabDecimal - jcTabMin));
            }
        }
        break;

    case WM_SETVISIBLE:
        if (wParam)
            EndLongOp(vhcArrow);
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
            the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            struct TBD rgtbd[itbdMax];
            struct TBD *ptbdLast;

        case idiOk:
            /* Sort the new tab descriptors. */
            bltc(rgtbd, 0, itbdMax * cwTBD);
            ptbdLast = &rgtbd[itbdMax - 1];
            for (idi = idiTabPos0; idi <= idiTabPos11; idi++)
                {
                unsigned dxa;
                unsigned dxaTab;
                struct TBD *ptbd;

                /* If an invalid position was entered, then punt. */
                if (!FPdxaPosBIt(&dxa, hDlg, idi))
                    {
                    ferror = FALSE;
                    return (TRUE);
                    }

                /* Ignore blank tabs or tabs at zero. */
                if (dxa == valNil || dxa == 0)
                    {
                    continue;
                    }

                for (ptbd = &rgtbd[0]; (dxaTab = ptbd->dxa) != 0; ptbd++)
                    {
                    /* If there is already a tab at this position, then ignore
                    the new tab. */
                    if (dxa == dxaTab)
                    {
                    goto GetNextTab;
                    }
        
                    /* If the new tab position is smaller than the current tab,
                    then make room for the new tab. */
                    if (dxa < dxaTab)
                        {
                        bltbyte(ptbd, ptbd + 1, (unsigned)ptbdLast - (unsigned)ptbd);
                        break;
                        }
                    }

                /* Put the tab into rgtbd. */
                ptbd->dxa = dxa;
                ptbd->jc = (IsDlgButtonChecked(hDlg, idi + (idiTabDec0 -
                  idiTabPos0)) ? jcTabDecimal : jcTabLeft) - jcTabMin;
GetNextTab:;
                }

                /* Set up the undo stuff. */
                SetUndo(uacFormatTabs, docCur, cp0, cp0, docNil, cpNil, cpNil, 0);

                /* Ensure that this document has a tab-stop table. */
                if ((hgtbd = (**hpdocdod)[docCur].hgtbd) == NULL)
                    {
                    if (FNoHeap(hgtbd = (struct TBD (**)[])HAllocate(itbdMax *
                          cwTBD)))
                        {
                        goto DestroyDlg;
                        }
                    (**hpdocdod)[docCur].hgtbd = hgtbd;
                    }
                blt(rgtbd, &(**hgtbd)[0], itbdMax * cwTBD);

                /* Changing the tabs makes everything dirty. */
                (**hpdocdod)[docCur].fDirty = TRUE;
                vdocParaCache = docNil;
                TrashAllWws();

        case idiCancel:
DestroyDlg:
            /* Destroy the tabs dialog box and enable any existing modeless
            dialog boxes.*/
            OurEndDialog(hDlg, NULL);
            break;

        case idiTabClearAll:
            /* Clear all of the tabs. */
            for (idi = idiTabPos0; idi <= idiTabPos11; idi++)
                {
                SetDlgItemText(hDlg, idi, (LPSTR)"");
                CheckDlgButton(hDlg, idi + (idiTabDec0 - idiTabPos0), FALSE);
                }
            break;

        case idiTabDec0:
        case idiTabDec1:
        case idiTabDec2:
        case idiTabDec3:
        case idiTabDec4:
        case idiTabDec5:
        case idiTabDec6:
        case idiTabDec7:
        case idiTabDec8:
        case idiTabDec9:
        case idiTabDec10:
        case idiTabDec11:
            CheckDlgButton(hDlg, wParam, !IsDlgButtonChecked(hDlg, wParam));
            break;

        default:
            return(FALSE);
        }
        break;

    case WM_CLOSE:
        goto DestroyDlg;

    default:
        return(FALSE);
    }
    return(TRUE);
}
/* end of DialogTabs */


BOOL far PASCAL DialogDivision(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles input to the Division dialog box. */

    extern struct DOD (**hpdocdod)[];
    extern int docCur;
    extern struct SEP vsepNormal;
    extern int vdocSectCache;
    extern BOOL vfPrinterValid;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern HWND vhWndMsgBoxParent;
    extern typeCP cpMinDocument;
    extern int ferror;

    struct SEP **hsep = (**hpdocdod)[docCur].hsep;
    register struct SEP *psep;
    CHAR szT[cchMaxNum];
    CHAR *pch = &szT[0];

#ifdef KINTL /* Kanji/International version */
static int iRBDown;
static int utInit;
#endif

    switch (message)
    {
    case WM_INITDIALOG:

#ifdef KINTL /* Kanji/International version */
       /* base initial setting on value in utCur */

        utInit = utCur;  /* for testing at ok */
            if (utCur == utCm)
                iRBDown = idiDivCm;
            else
                iRBDown = idiDivInch;

        CheckDlgButton(hDlg, iRBDown, TRUE);

#endif


        EnableOtherModeless(FALSE);

        /* Get a pointer to the section properties. */
        psep = (hsep == NULL) ? &vsepNormal : *hsep;

        /* Initialize the starting page number. */
        if (psep->pgnStart != pgnNil)
            {
            szT[ncvtu(psep->pgnStart, &pch)] = '\0';
            SetDlgItemText(hDlg, idiDivPNStart, (LPSTR)szT);
            pch = &szT[0];
            }
        else
            {
            SetDlgItemText(hDlg, idiDivPNStart, (LPSTR)"1");
            }
        SelectIdiText(hDlg, idiDivPNStart);

        /* Initialize the margins. */
#ifdef DMARGINS
        CommSzNum("Left Twips: ", psep->xaLeft);
        CommSzNum("Right Twips: ", psep->xaMac - psep->dxaText - psep->xaLeft);
        CommSzNum("Top Twips: ", psep->yaTop);
        CommSzNum("Bottom Twips: ", psep->yaMac - psep->dyaText - psep->yaTop);
#endif /* DEBUG */

#ifdef	KOREA
        if (vfPrinterValid)
                CchExpZa(&pch, imax(psep->xaLeft, dxaPrOffset), utCur,cchMaxNum);
        else
                CchExpZa(&pch, psep->xaLeft, utCur, cchMaxNum);
#else
        CchExpZa(&pch, psep->xaLeft, utCur, cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivLMarg, (LPSTR)szT);
        pch = &szT[0];
#ifdef	KOREA		/* 90.12.29 sangl */
        if ( vfPrinterValid )
                CchExpZa (&pch, imax(psep->xaMac - psep->dxaText - psep->xaLeft,
                  vsepNormal.xaMac - dxaPrOffset - dxaPrPage), utCur, cchMaxNum);
        else
                CchExpZa(&pch, psep->xaMac - psep->dxaText - psep->xaLeft, utCur,
                  cchMaxNum);
#else
        CchExpZa(&pch, psep->xaMac - psep->dxaText - psep->xaLeft, utCur,
          cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivRMarg, (LPSTR)szT);
        pch = &szT[0];
#ifdef	KOREA		/* 90.12.29 sangl */
        if (vfPrinterValid)
          CchExpZa(&pch, imax( psep->yaTop, dyaPrOffset), utCur, cchMaxNum);
        else
          CchExpZa(&pch, psep->yaTop, utCur, cchMaxNum);
#else
        CchExpZa(&pch, psep->yaTop, utCur, cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivTMarg, (LPSTR)szT);
        pch = &szT[0];
#ifdef	KOREA	/* 90.12.29 sangl */
        if (vfPrinterValid)
           CchExpZa(&pch, imax(psep->yaMac - psep->dyaText - psep->yaTop,
            vsepNormal.yaMac - dyaPrOffset - dyaPrPage), utCur, cchMaxNum);
        else
           CchExpZa(&pch, psep->yaMac - psep->dyaText - psep->yaTop, utCur,
            cchMaxNum);
#else
        CchExpZa(&pch, psep->yaMac - psep->dyaText - psep->yaTop, utCur,
          cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivBMarg, (LPSTR)szT);
        break;

    case WM_SETVISIBLE:
        if (wParam)
            EndLongOp(vhcArrow);
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
            the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            int pgn;
            int iza;
            int za[4];
            int zaMin[4];
            int dza;
            int *pza;
            int dxaMax;
            int dyaMax;

        case idiOk:
            /* Is the page number valid? */
            if (!WPwFromItW3Id(&pgn, hDlg, idiDivPNStart, pgnMin, pgnMax,
                       wNormal, IDPMTNPI))
                {
                ferror = FALSE; /* minor error, stay in dialog */
                break;
                }

        /* Determine the minimum margins of the page. */
            if (vfPrinterValid)
                {
                zaMin[0] = dxaPrOffset;
                zaMin[1] = imax(0, vsepNormal.xaMac - dxaPrOffset - dxaPrPage);
                zaMin[2] = dyaPrOffset;
                zaMin[3] = imax(0, vsepNormal.yaMac - dyaPrOffset - dyaPrPage);
                }
            else
                {
                zaMin[0] = zaMin[1] = zaMin[2] = zaMin[3] = 0;
                }

            /* Are the margins valid? */
            for (iza = 0; iza < 4; iza++)
                {
                /* Is the margin a positive measurement? */
                if (!FPdxaPosIt(&za[iza], hDlg, iza + idiDivLMarg
                        ))
                    {
                    ferror = FALSE; /* minor error, stay in dialog */
                    return (TRUE);
                    }

                /* Is it less than the minimum? */
                if (FUserZaLessThanZa(za[iza], zaMin[iza]))
                    {
                    ErrorBadMargins(hDlg, zaMin[0], zaMin[1], zaMin[2],
                      zaMin[3]);
                    SelectIdiText(hDlg, iza + idiDivLMarg);
                    SetFocus(GetDlgItem(hDlg, iza + idiDivLMarg));
                    return (TRUE);
                    }
                }
#ifdef DMARGINS
            CommSzNum("New Left Twips: ", za[0]);
            CommSzNum("New Right Twips: ", za[1]);
            CommSzNum("New Top Twips: ", za[2]);
            CommSzNum("New Bottom Twips: ", za[3]);
#endif /* DEBUG */

            /* Ensure that this document has a valid section property
                descriptor. */
            if (hsep == NULL)
                {
                if (FNoHeap(hsep = (struct SEP **)HAllocate(cwSEP)))
                    {
                    goto DestroyDlg;
                    }
                blt(&vsepNormal, *hsep, cwSEP);
                (**hpdocdod)[docCur].hsep = hsep;
                }
            psep = *hsep;

            /* Are the combined margins longer or wider than the page? */
            pza = &za[0];
            dxaMax = psep->xaMac - dxaMinUseful;
            dyaMax = psep->yaMac - dyaMinUseful;
            if ((dza = *pza) > dxaMax || (dza += *(++pza)) > dxaMax ||
              (dza = *(++pza)) > dyaMax || (dza += *(++pza)) > dyaMax)
                {
                Error(IDPMTMTL);
                ferror = FALSE; /* minor error, stay in dialog */
                SelectIdiText(hDlg, (int)(idiDivLMarg + (pza - &za[0])));
                SetFocus(GetDlgItem(hDlg, (int)(idiDivLMarg + (pza - &za[0]))));
                return (FALSE);
                }

            /* If the margins have changed, then set the new values. */
            if (psep->pgnStart != pgn || psep->xaLeft != za[0] || psep->dxaText
              != psep->xaMac - za[0] - za[1] || psep->yaTop != za[2] ||
              psep->dyaText != psep->yaMac - za[2] - za[3])
                {
                /* Set up the undo stuff. */
                SetUndo(uacFormatSection, docCur, cp0, cp0, docNil, cpNil,
                  cpNil, 0);
                    
                /* Reset psep in case some heap movement has taken place. */
                psep = *hsep;

                if (psep->pgnStart != pgn)
                    {
                    /* Renumber the page table. */
                    extern int docMode;
                    register struct PGTB **hpgtb = (**hpdocdod)[docCur].hpgtb;
                    register struct PGD *ppgd;
                    int ipgd;
                    int cpgdMac;

                    /* Initialize page table if it does not already exist. */
                    if (hpgtb == NULL)
                    {
                    if (FNoHeap(hpgtb =
                      (struct PGTB **)HAllocate(cwPgtbBase + cpgdChunk *
                          cwPGD)))
                        {
                        NoUndo();
                        return(TRUE);
                        }
                    (**hpgtb).cpgdMax = cpgdChunk;
                    (**hpgtb).cpgd = 1;
                    (**hpgtb).rgpgd[0].cpMin = cpMinDocument;

                    /* Reset psep because of heap movement. */
                    psep = *hsep;
                    }

                /* Save the starting page number in the section properties.
                */
                psep->pgnStart = pgn;

                /* Update the page table with the new starting page number.
                */
                for (ipgd = 0, cpgdMac = (**hpgtb).cpgd, ppgd =
                     &((**hpgtb).rgpgd[0]) ; ipgd < cpgdMac; ipgd++, ppgd++)
                    {
                    ppgd->pgn = pgn++;
                    }

                /* Force the page info window to be repainted. */
                docMode = docNil;
                }

            /* Set the new section properties. */
            psep->dxaText = psep->xaMac - (psep->xaLeft = za[0]) - za[1];
            psep->dyaText = psep->yaMac - (psep->yaTop = za[2]) - za[3];

            /* Invalidate the section cache. */
            vdocSectCache = docNil;
            TrashAllWws();

            /* Mark the document as dirty. */
            (**hpdocdod)[docCur].fDirty = TRUE;
            }

#ifdef KINTL     /* Kanji/International version */
             /* redraw ruler if visible and units changed */
        if (utInit != utCur) {
        ReframeRuler();
        }
#endif

        goto DestroyDlg;

    case idiCancel:

#ifdef KINTL /* International version */
        utCur = utInit;  /* restore units at actual cancel */
#endif     /* KINTL */

DestroyDlg:
        OurEndDialog(hDlg, TRUE);
        break;

#ifdef KINTL /* International version */
    {
         int margin;

/* Maximum number of characters in the edit control */
#define cchMaxEditText 64

    case idiDivInch:
        utCur = utInch;
        goto SetUnits;
    case idiDivCm:
        utCur = utCm;
       /* measurment button fall into this code */
SetUnits:
        /* set up buttons appropriately */
#ifdef INTL
        CheckRadioButton(hDlg, idiDivInch, idiDivCm, wParam);
#else /* KANJI */
        CheckRadioButton(hDlg, idiDivInch, idiDivCch, wParam);
#endif

        if (wParam != iRBDown) {
            /* reevaluate margin values based on new units */
            iRBDown = wParam;

            /* want most recently entered value from screen into
               twips, then convert using current unit scale */

            szT[0] = GetDlgItemText(hDlg, idiDivLMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivLMarg, (LPSTR)szT);
                }

            szT[0] = GetDlgItemText(hDlg, idiDivRMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivRMarg, (LPSTR)szT);
                }

            szT[0] = GetDlgItemText(hDlg, idiDivTMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivTMarg, (LPSTR)szT);
                }

            szT[0] = GetDlgItemText(hDlg, idiDivBMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivBMarg, (LPSTR)szT);
                }
            }

        break;
        }
#endif     /* KINTL */


    default:
        return (FALSE);
        }
    break;

    default:
    return (FALSE);
    }
    return (TRUE);
} /* end of DialogDivision */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diachgpr.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

/* This file contains the routines for the change printer dialog box. */


#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOCLIPBOARD
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOWH
#define NOWNDCLASS
#define NOSOUND
#define NOCOLOR
#define NOSCROLL
#define NOCOMM
#include <windows.h>
#ifdef EXTDEVMODESUPPORT
#include <drivinit.h>   /* new for win 3.0 and extdevicemode pr.drv. calls */
#endif
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "machdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "printdef.h"
#include "str.h"

extern CHAR  szExtDrv[];
extern CHAR  szDeviceMode[];
extern CHAR  szNone[];
extern HWND             vhWnd;
#ifdef EXTDEVMODESUPPORT
extern CHAR  szExtDevMode[];
extern HANDLE hDevmodeData;
#endif

BOOL far PASCAL DialogPrinterSetup( hDlg, message, wParam, lParam )
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
   {
    extern CHAR *vpDlgBuf;
    extern HWND hParentWw;
    extern CHAR szDevices[];
    extern CHAR stBuf[];
    extern HDC vhDCPrinter;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern BOOL vfPrinterValid;
    extern HANDLE hMmwModInstance;
    extern BOOL vfPrDefault;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;
    extern HCURSOR vhcIBeam;
    extern HWND vhWndMsgBoxParent;

    void BuildPrSetupSz(CHAR *, CHAR *, CHAR *);

    CHAR (***phszPr)[] = (CHAR (***)[])vpDlgBuf;
    BOOL *pfOkEnabled = (BOOL *)(phszPr + 3);
    CHAR stKeyName[cchMaxIDSTR];
    CHAR szPrinters[cchMaxProfileSz];
    CHAR *pchPrinters;
    CHAR szDevSpec[cchMaxProfileSz];
    CHAR szListEntry[cchMaxProfileSz];
    CHAR *pchPort;
    CHAR *pchDriver;
    CHAR chNull = '\0';
    int  iPrinter;
    BOOL fSingleClick;

    switch (message)
      {
      case WM_INITDIALOG:
        /* Disable any modeless dialog boxes. */
        EnableOtherModeless(FALSE);

        /* Save away the heap strings that describe the current printer. */
        *phszPr++ = hszPrinter;
        *phszPr++ = hszPrDriver;
        *phszPr = hszPrPort;

        /* Get a string that holds all of the printer names. */
        GetProfileString((LPSTR)szDevices, (LPSTR)NULL, (LPSTR)&chNull,
          (LPSTR)szPrinters, cchMaxProfileSz);

        /* There must be two nulls at the end of the list. */
        szPrinters[cchMaxProfileSz - 1] = szPrinters[cchMaxProfileSz - 2] =
          '\0';

        /* Parse out the names of the printers. */
        pchPrinters = &szPrinters[0];
        while (*pchPrinters != '\0')
            {
            /* Get the corresponding printer driver and port. */
            GetProfileString((LPSTR)szDevices, (LPSTR)pchPrinters,
              (LPSTR)&chNull, (LPSTR)szDevSpec, cchMaxProfileSz);
            szDevSpec[cchMaxProfileSz - 1] = '\0';

            /* If there is no driver for this printer, then it cannot be added
            to the list. */
            if (szDevSpec[0] != '\0')
                {
                /* Parse the ports and the driver. */
                int cPort = ParseDeviceSz(szDevSpec, &pchPort, &pchDriver);
                int iPort;

                for (iPort = 0; iPort < cPort; iPort++)
                    {
                    /* Contruct the list box entry. */
                    BuildPrSetupSz(szListEntry, pchPrinters, pchPort);

                    /* Put the string in the list box 
                       provided printer is not on "None" */

                    if (!FSzSame(pchPort, szNone))
                        SendDlgItemMessage(hDlg, idiPrterName, LB_ADDSTRING, 
                                           0, (LONG)(LPSTR)szListEntry);

                    /* Bump the pointer to the next port in the list. */
                    pchPort += CchSz(pchPort);
                    }
                }

            /* Skip to the next printer in the list. */
            while (*pchPrinters++) ;
            }

        /* Select the current printer. */
        if (!(*pfOkEnabled = hszPrinter != NULL && hszPrPort != NULL &&
          (BuildPrSetupSz(szListEntry, &(**hszPrinter)[0], &(**hszPrPort)[0]),
          SendDlgItemMessage(hDlg, idiPrterName, LB_SELECTSTRING, -1,
          (LONG)(LPSTR)szListEntry) >= 0)))
            {
            EnableWindow(GetDlgItem(hDlg, idiOk), FALSE);
            }
        return(fTrue); /* we processed the message */

      case WM_SETVISIBLE:
        if (wParam)
            {
            EndLongOp(vhcArrow);
            }
        break; /* to return false below */

      case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        break; /* to return false below */

      case WM_COMMAND:
        fSingleClick = FALSE;
        switch (wParam)
          {
          case idiPrterName:
            if (HIWORD(lParam) == 1)    /* remember single mouse clicks */
                {
                fSingleClick = fTrue;
                }
            else if (HIWORD(lParam) != 2)  /* 2 is a double mouse click */
                break; /* LBNmsg (listbox notification) we don't handle */

          case idiPrterSetup:
          case idiOk:
            /* If none of the printers is currently selected... */
            if ((iPrinter = SendDlgItemMessage(hDlg, idiPrterName, LB_GETCURSEL,
              0, 0L)) == -1)
                {
                /* Disable the "OK" button. */
                if (*pfOkEnabled)
                    {
                    EnableWindow(GetDlgItem(hDlg, idiOk), FALSE);
                    *pfOkEnabled = FALSE;
                    }
                return(fTrue); /* we processed the message */
                }
            else
                {
                CHAR *index(CHAR *, int);
                CHAR *bltbyte(CHAR *, CHAR *, int);

                CHAR *pch;
                CHAR szDriver[cchMaxFile];
                HANDLE hDriver;
                FARPROC lpfnDevMode;
#ifdef EXTDEVMODESUPPORT
                BOOL fExtDevModeSupport = fTrue; /* assume until told otherwise */
#endif                
                int cwsz;

                if (fSingleClick)
                    {
                    /* If this is just a single mouse-click, then just update the
                    status of the "OK" button. */
                    if (!*pfOkEnabled)
                        {
                        EnableWindow(GetDlgItem(hDlg, idiOk), TRUE);
                        *pfOkEnabled = TRUE;
                        }
                    return(fTrue); /* we processed the message */
                    }
                
                /* Let the user know that this may take a while. */
                StartLongOp();

                /* Get the printer's name, it's port, and it's driver. */
                SendDlgItemMessage(hDlg, idiPrterName, LB_GETTEXT, iPrinter,
                  (LONG)(LPSTR)szListEntry);

                /* Parse the port name out of the list entry. */
                pchPort = &szListEntry[0] + CchSz(szListEntry) - 1;
                while (*(pchPort - 1) != ' ')
                    {
                    pchPort--;
                    }

                /* Parse the name of the printer out of the list entry. */
                pch = &szListEntry[0];
                FillStId(stBuf, IDSTROn, sizeof(stBuf));
                for ( ; ; )
                    {
                    if ((pch = index(pch, ' ')) != 0 && FRgchSame(pch,
                      &stBuf[1], stBuf[0]))
                        {
                        *pch = '\0';
                        break;
                        }
                    pch++;
                    }

                /* Get the driver name for this printer. */
                GetProfileString((LPSTR)szDevices, (LPSTR)szListEntry,
                 (LPSTR)&chNull, (LPSTR)szDevSpec, cchMaxProfileSz);
                ParseDeviceSz(szDevSpec, &pch, &pchDriver);

                /* Update the heap strings describing the printer. */
                if (hszPrinter != *phszPr)
                    {
                    FreeH(hszPrinter);
                    }
                if (FNoHeap(hszPrinter = (CHAR (**)[])HAllocate(cwsz =
                  CwFromCch(CchSz(szListEntry)))))
                    {
                    hszPrinter = NULL;
Error:
                    EndLongOp(vhcIBeam);
                    goto DestroyDlg;
                    }
                blt(szListEntry, *hszPrinter, cwsz);
                if (hszPrDriver != *(phszPr + 1))
                    {
                    FreeH(hszPrDriver);
                    }
                if (FNoHeap(hszPrDriver = (CHAR (**)[])HAllocate(cwsz =
                  CwFromCch(CchSz(pchDriver)))))
                    {
                    hszPrDriver = NULL;
                    goto Error;
                    }
                blt(pchDriver, *hszPrDriver, cwsz);
                if (hszPrPort != *(phszPr + 2))
                    {
                    FreeH(hszPrPort);
                    }
                if (FNoHeap(hszPrPort = (CHAR (**)[])HAllocate(cwsz =
                  CwFromCch(CchSz(pchPort)))))
                    {
                    hszPrPort = NULL;
                    goto Error;
                    }
                blt(pchPort, *hszPrPort, cwsz);

                /* Get the name of the driver, complete with extension. */
                bltbyte(szExtDrv, 
                            bltbyte(pchDriver, szDriver, CchSz(pchDriver) - 1), 
                                CchSz(szExtDrv));

                /* That's all we need for Setup ..pault */
                if (wParam != idiPrterSetup)
                    goto LSetupDone;
                
                /* The driver is not resident; attempt to load it. */
                if ((hDriver = LoadLibrary((LPSTR)szDriver)) <= 32)
                    {
                    if (hDriver != 2)
                        {
                        /* If hDriver is 2, then the user has cancelled a dialog
                        box; there's no need to put up another. */
                        Error(IDPMTBadPrinter);
                        }
Abort:
                    EndLongOp(vhcArrow);
                    return (TRUE);  /* True means we processed the message */
                    }

#ifdef EXTDEVMODESUPPORT
                /* First see if ExtDeviceMode is supported (Win 3.0 drivers) */
                if ((lpfnDevMode = GetProcAddress(hDriver,
                       (LPSTR)szExtDevMode)) == NULL)
                    {
                    fExtDevModeSupport = fFalse;
#else
                    {
#endif
                    /* Otherwise get the driver's DeviceMode() entry. */
                    if ((lpfnDevMode = GetProcAddress(hDriver,
                           (LPSTR)szDeviceMode)) == NULL)
                        {
                        /* No can do, eh? */
                        Error(IDPMTBadPrinter);
LUnloadAndAbort:
                        FreeLibrary(hDriver);
                        goto Abort;
                        }
                    }

#ifdef EXTDEVMODESUPPORT
                /* Actual calls to the device modes setup. 
                   Much of this new ExtDevModeSupport stuff 
                   borrowed from MULTIPAD ..pault */

                if (fExtDevModeSupport)
                    {
                    int     cb;
                    int     wId;
                    HANDLE  hT;
                    LPDEVMODE lpOld, lpNew;
                    BOOL    flag;    /* devmode mode param */

                    /* pop up dialog for user */
                    flag = DM_PROMPT|DM_COPY;

                    if (hDevmodeData != NULL)
                        {
                        NPDEVMODE npOld;

                        /* Modify the user's last print settings */

                        flag |= DM_MODIFY;
                        lpOld = (LPDEVMODE)(npOld = (NPDEVMODE)LocalLock(hDevmodeData));
                        
                        /* Check to see if they're using the same printer 
                           driver as last time.  If so, let them modify all
                           of their previous settings.  If not, we tell  
                           ExtDevMode to save as many of the hardware-
                           independent settings as it can (e.g. copies) */
                    
                        if (!FSzSame(szListEntry, npOld->dmDeviceName))
                            {
                            npOld->dmDriverVersion = NULL;
                            npOld->dmDriverExtra = NULL;
                            bltsz(szListEntry, npOld->dmDeviceName);
                            }
                        }
                    else
                        /* We haven't done a printer setup yet this session */
                        lpOld = NULL;
            
                    /* how much space do we need for the data? */
                    cb = (*lpfnDevMode)(hDlg, hDriver, (LPSTR)NULL, 
                            (LPSTR)szListEntry, (LPSTR)pchPort,
                            (LPDEVMODE)NULL, (LPSTR)NULL, 0);

                    if ((hT = LocalAlloc(LHND, cb)) == NULL)
                        goto LUnloadAndAbort;
                    lpNew = (LPDEVMODE)LocalLock(hT);

                    /* post the device mode dialog.  0 flag iff user hits OK button */
                    wId = (*lpfnDevMode)(hDlg, hDriver, (LPDEVMODE)lpNew,
                            (LPSTR)szListEntry, (LPSTR)pchPort, 
                            (LPDEVMODE)lpOld, (LPSTR)NULL, flag);
                    if (wId == IDOK)
                        flag = 0;

                    /* unlock the input structures */
                    LocalUnlock(hT);
                    if (hDevmodeData != NULL)
                        LocalUnlock(hDevmodeData);

                    /* if the user hit OK and everything worked, free the original init
                     * data and retain the new one.  Otherwise, toss the new buffer
                     */
                    if (flag != 0)
                        {
                        LocalFree(hT);
                        goto LUnloadAndAbort;
                        }
                    else
                        {
                        if (hDevmodeData != NULL)
                            LocalFree(hDevmodeData);
                        hDevmodeData = hT;
                        }
                    }
                    
                else /* older Win 2.0 driver, make DeviceMode call */
                    {
                    if (hDevmodeData != NULL)
                        {
                        /* We'd opened a Win3 printer driver before; now discard */
                        LocalFree(hDevmodeData);
                        hDevmodeData = NULL;
                        }
#else /* ifdef EXTDEVMODESUPPORT */
                    {
#endif /* else-def-EXTDEVMODESUPPORT */     
                    if (!(*lpfnDevMode)(hDlg, hDriver, (LPSTR)szListEntry,
                         (LPSTR)pchPort))
                        goto LUnloadAndAbort;
                    }
                FreeLibrary(hDriver);
LSetupDone:
                /* Let the user know the waiting is over. */
                EndLongOp(vhcIBeam);

                /* Printer setup should take us back to printer choices! */
                if (wParam == idiPrterSetup)
                    {
                    return (TRUE);  /* True means we processed the message */
                    }
                
                /* Previously we freed these guys before returning 
                   and that fouled up our heap ..pault */
                FreeH(*phszPr++);
                FreeH(*phszPr++);
                FreeH(*phszPr);

                vfPrDefault = FALSE;

#ifdef WIN30
                /* Need to indicate to FormatLine and Friends here
                   that we (may) have a different font pool to work
                   with and we should look at the new ones!  Invalidating
                   the window will cause FormatLine to be called, and 
                   when it hits the null printer dc it'll force a call 
                   to GetPrinterDC ..pault */
                
                FreePrinterDC();
                InvalidateRect(vhWnd, (LPRECT) NULL, fFalse);
#endif
                
                goto DestroyDlg;
                }

          case idiCancel:
            hszPrinter = *phszPr++;
            hszPrDriver = *phszPr++;
            hszPrPort = *phszPr;

DestroyDlg:
            /* Close the dialog box and enable any modeless dialog boxes. */
            OurEndDialog(hDlg, NULL);
            return(fTrue);  /* we processed the message */
            }
      }
    
    return(fFalse); /* if we got here we didn't process the message */
    }


void BuildPrSetupSz(szPrSetup, szPrinter, szPort)
CHAR *szPrSetup;
CHAR *szPrinter;
CHAR *szPort;
    {
    /* This routine pieces together the string for the Change Printers list box.
    szPrinter is the name of the printer, and szPort, the name of the port.  It
    is assumed that the setup string, szPrSetup, is large enough to hold the
    string created by this routine. */

    extern CHAR stBuf[];
    extern CHAR szNul[];

    CHAR *bltbyte(CHAR *, CHAR *, int);
    CHAR ChUpper(CHAR);

    register CHAR *pch;

    pch = bltbyte(szPrinter, szPrSetup, CchSz(szPrinter) - 1);
    FillStId(stBuf, IDSTROn, sizeof(stBuf));
    pch = bltbyte(&stBuf[1], pch, stBuf[0]);

    /* If the port name is not "None", then raise the port name to all capitals.
    */
    bltbyte(szPort, pch, CchSz(szPort));
    if (WCompSz(pch, szNul) != 0)
        {
        while (*pch != '\0')
            {
            *pch++ = ChUpper(*pch);
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diaalert.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOSCALABLEFONT
#define NOSYSPARAMSINFO
#define NODBCS
#define NODRIVERS
#define NODEFERWINDOWPOS
#define NOPROFILER
#define NOHELP
#define NOKEYSTATES
#define NOWINMESSAGES
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCOMM
#define NODRAWTEXT
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#define NOBITMAP
#define NOKEYSTATE
#define NOMENUS
#define NOMETAFILE
#define NOPEN
#define NOOPENFILE
#define NORASTEROPS
#define NORECT
#define NOSCROLL
#define NOSHOWWINDOW
#define NOSOUND
#define NOSYSCOMMANDS
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOVIRTUALKEYCODES
#define NOWH
#define NOWINOFFSETS
#define NOWINSTYLES
#define NOUAC
#define NOIDISAVEPRINT
#define NOSTRUNDO
#define NOCTLMGR
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "code.h"
#include "debug.h"
#include "dlgdefs.h"
#include "str.h"
#include "propdefs.h"
#include "wwdefs.h"

extern struct WWD   rgwwd[];
extern int             utCur;
extern int             vfInitializing;
extern CHAR            szAppName[];
extern struct FCB      (**hpfnfcb)[];
extern struct BPS      *mpibpbps;
extern int             ibpMax;
extern typeTS          tsMruBps;
extern int             vfSysFull;
extern int             ferror;
extern int             vfnWriting;
extern int             vibpWriting;
extern HANDLE          hMmwModInstance;
extern HWND            vhWndMsgBoxParent;
extern int             vfMemMsgReported;
extern int             vfDeactByOtherApp;
extern MSG             vmsgLast;
extern HWND            vhDlgFind;
extern HWND            vhDlgChange;
extern HWND            vhDlgRunningHead;
extern HANDLE          hParentWw;


#ifdef JAPAN //01/21/93
extern BOOL			   FontChangeDBCS;
HANDLE hszNoMemorySel = NULL;
#endif
HANDLE hszNoMemory = NULL;
HANDLE hszDirtyDoc = NULL;
HANDLE hszCantPrint = NULL;
HANDLE hszPRFAIL = NULL;
HANDLE hszCantRunM = NULL;
HANDLE hszCantRunF = NULL;
HANDLE hszWinFailure = NULL;
BOOL vfWinFailure = FALSE;
#ifdef INEFFLOCKDOWN
FARPROC lpDialogBadMargins;
#endif

#define FInModeless(hWnd) (hWnd == vhDlgFind || hWnd == vhDlgChange || \
 hWnd == vhDlgRunningHead)

CHAR *PchFillPchId( CHAR *, int, int );
NEAR WaitBeforePostMsg(int);

#ifdef CANCELMSG    /* During debug, permit an abort for stack traces */
#define MB_MESSAGE        (MB_OKCANCEL | MB_APPLMODAL | MB_ICONASTERISK)
#define MB_ERROR          (MB_OKCANCEL | MB_APPLMODAL | MB_ICONEXCLAMATION)
#define MB_TROUBLE        (MB_OKCANCEL | MB_APPLMODAL | MB_ICONHAND)
#else
#define MB_MESSAGE        (MB_OK | MB_APPLMODAL | MB_ICONASTERISK)
#define MB_ERROR          (MB_OK | MB_APPLMODAL | MB_ICONEXCLAMATION)
#define MB_TROUBLE        (MB_OK | MB_APPLMODAL | MB_ICONHAND)
#endif
#define MB_DEFYESQUESTION (MB_YESNOCANCEL | MB_APPLMODAL | MB_ICONHAND)
#define MB_DEFNOQUESTION  (MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_APPLMODAL | MB_ICONHAND)


ErrorLevel(IDPMT idpmt)
{

/* A long story.  But to fix Winbug #1097, we need to take special
   exception for this error message -- when this is displayed in a
   low mem situation, this must be system modal (match params used
   in FRenderAll() ...pault */
if (idpmt == IDPMTClipLarge)
    return(MB_OK | MB_SYSTEMMODAL | MB_ICONHAND);

else
    switch (idpmt & MB_ERRMASK)
    {
    case MB_ERRASTR:             /*  *  level  */
        return(MB_MESSAGE);
    case MB_ERREXCL:             /*  !  level  */
        return(MB_ERROR);
    case MB_ERRQUES:             /*  ?  level  */
        return(MB_DEFYESQUESTION);
    case MB_ERRHAND:             /*  HAND  level  */
        return(MB_TROUBLE);
    default:
        Assert(FALSE);
    }
}


int far Abort(response)
int response;
{
        for( ; ; );
}

#ifdef DEBUG
ErrorWithMsg(IDPMT idpmt, CHAR *szMessage)
{
#ifdef REALDEBUG
        extern int vfOutOfMemory;
        CHAR szBuf[cchMaxSz];
        int errlevel = ErrorLevel(idpmt);
        BOOL fDisableParent = FALSE;
        register HWND hWndParent = (vhWndMsgBoxParent == NULL) ?
          hParentWw : vhWndMsgBoxParent;

        Assert(IsWindow(hWndParent));

        if (idpmt == IDPMTNoMemory)
            {
            vfOutOfMemory = TRUE;
            if (vfMemMsgReported)
                {
                return;
                }
            vfMemMsgReported = TRUE;
            }
        if (ferror)
            return;

        ferror = TRUE;

        if (vfInitializing)
            return;

        CchCopySz( szMessage, PchFillPchId( szBuf, idpmt, sizeof(szBuf) ) );
        if (vfDeactByOtherApp && !InSendMessage())
            WaitBeforePostMsg(errlevel);

/* force user to answer the error msg */
        if (hWndParent != NULL && FInModeless(hWndParent))
            {
            EnableExcept(hWndParent, FALSE);
            }
        else
            {
            if (hWndParent != NULL && !IsWindowEnabled(hWndParent))
                {
                EnableWindow(hWndParent, TRUE);
                fDisableParent = TRUE;
                }
            EnableOtherModeless(FALSE);
            }

        if (MessageBox(hWndParent, (LPSTR)szBuf,
                       (LPSTR)NULL, errlevel) == IDCANCEL)
                /* A debugging feature -- show stack trace if he hit "cancel" */
            FatalExit( 0 );

        if (hWndParent != NULL && FInModeless(hWndParent))
            {
            EnableExcept(hWndParent, TRUE);
            }
        else
            {
            if (fDisableParent)
                {
                EnableWindow(hWndParent, FALSE);
                }
            EnableOtherModeless(TRUE);
            }
#else
 Error( idpmt );
#endif
}
#endif /* DEBUG */

void Error(IDPMT idpmt)
{
 extern int vfOutOfMemory;
 CHAR szBuf [cchMaxSz];
 HANDLE hMsg;
 LPCH lpch;
 static int nRecurse=0;
 int errlevel = ErrorLevel(idpmt);
 register HWND hWndParent = (vhWndMsgBoxParent == NULL) ? hParentWw :
                                                          vhWndMsgBoxParent;

 if (nRecurse)
    return;

 ++nRecurse;

 Assert((hWndParent == NULL) || IsWindow(hWndParent));

 if (idpmt == IDPMTNoMemory)
    {
    vfOutOfMemory = TRUE;
    if (vfMemMsgReported)
        {
        goto end;
        }
    vfMemMsgReported = TRUE;
    }

 if (!ferror && !vfInitializing)
    {
    CloseEveryRfn( FALSE );
    switch (idpmt)
        {
    case IDPMTNoMemory:
#ifdef JAPAN //01/21/93
		if(FontChangeDBCS)
	        hMsg = hszNoMemorySel;
		else
    	    hMsg = hszNoMemory;
#else
        hMsg = hszNoMemory;
#endif
GetMsg:
        if (hMsg == NULL || (lpch = GlobalLock(hMsg)) == NULL)
            {
            goto end;
            }
        bltbx(lpch, (LPCH)szBuf, LOWORD(GlobalSize(hMsg)));
        GlobalUnlock(hMsg);
        break;
    case IDPMTCantPrint:
        hMsg = hszCantPrint;
        goto GetMsg;
    case IDPMTPRFAIL:
        hMsg = hszPRFAIL;
        goto GetMsg;
    case IDPMTCantRunM:
        hMsg = hszCantRunM;
        goto GetMsg;
    case IDPMTCantRunF:
        hMsg = hszCantRunF;
        goto GetMsg;
    case IDPMTWinFailure:
        hMsg = hszWinFailure;
        goto GetMsg;
    default:
        PchFillPchId( szBuf, idpmt, sizeof(szBuf) );
        break;
        }
    if (vfDeactByOtherApp && !InSendMessage())
        {
        WaitBeforePostMsg(errlevel);
        }

#ifdef CANCELMSG
    if (IdPromptBoxSz( hWndParent, szBuf, errlevel ) == IDCANCEL)
        {
        /* A debugging feature -- show stack trace if he hit "cancel" */
        FatalExit( 100 );
        }
#else
    IdPromptBoxSz( hWndParent, szBuf, errlevel );
#endif
    }

 if (errlevel != MB_MESSAGE)
    {
    ferror = TRUE;
    }

    end:
    --nRecurse;
}
/* end of  E r r o r  */


IdPromptBoxSz( hWndParent, sz, mb )
HWND hWndParent;
CHAR sz[];
int mb;
{   /* Put up a message box with string sz. mb specifies buttons to display,
       "level" of message (HAND, EXCL, etc.).
       hWndParent is the parent of the message box.
       Returns the id of the button selected by the user */

 int id;
 BOOL fDisableParent = FALSE;
 extern int  wwMac;
 int  wwMacSave=wwMac;

 Assert((hWndParent == NULL) || IsWindow(hWndParent));

 if ((mb == MB_ERROR) || (mb == MB_TROUBLE))
    {
    extern int ferror;
    extern int vfInitializing;

    if (ferror)
        return;
    ferror = TRUE;
    if (vfInitializing)
        return;
    }

 CloseEveryRfn( FALSE );    /* Protect against disk swap while in message box */

 /* don't allow painting doc, it may be in an unpaintable state (5.8.91) v-dougk */
 if (mb == MB_TROUBLE)
    wwMac=0;

 /* force user to answer the msg */
 if (hWndParent != NULL && FInModeless(hWndParent))
    {
    EnableExcept(hWndParent, FALSE);
    }
 else
    {
    if (hWndParent != NULL && !IsWindowEnabled(hWndParent))
        {
        EnableWindow(hWndParent, TRUE);
        fDisableParent = TRUE;
        }
    EnableOtherModeless(FALSE);
    }

 /* We almost ALWAYS want the parent window to be passed to MessageBox
    except in a couple RARE cases where even Write's main text window
    hasn't yet gotten displayed.  In that case we'll rip out of Windows
    if we DO tell MessageBox about it... so NULL is the prescribed hwnd
    to pass ..pault */

 id = MessageBox((hWndParent == hParentWw && !IsWindowVisible(hWndParent)) ?
                  NULL : hWndParent, (LPSTR)sz, (LPSTR)szAppName, mb);

 if (hWndParent != NULL && FInModeless(hWndParent))
    {
    EnableExcept(hWndParent, TRUE);
    }
 else
    {
    if (fDisableParent)
        {
        EnableWindow(hWndParent, FALSE);
        }
    EnableOtherModeless(TRUE);
    }

 wwMac = wwMacSave;
 return id;
}




WinFailure()
{
    /* Windows has run out of memory.  All we can do is discard all of our
    Windows objects and pray the problem goes away.  At the very worst, the
    might be stuck with a saved document and unable to edit. */
    /* FM 9/4/87 - Take out the call to FreeMemoryDC, hopefully to allow
       Write to continue formatting lines. */

    extern int vfOutOfMemory;

    vfOutOfMemory = TRUE;
    if (!vfWinFailure)
        {
        Error(IDPMTWinFailure);
        vfWinFailure = TRUE;
        }
}


#ifdef DEBUG
DiskErrorWithMsg(idpmt, szMessage)
IDPMT idpmt;
CHAR  *szMessage;
#else
DiskError(idpmt)
IDPMT idpmt;
#endif
{ /* Description:  Given an error message descriptor,
                   outputs an Alert Box. If the message indicates a serious disk
                   error, all files are closed and a flag set so that
                   the user will be restricted to the "Save" option only.
     Returns:      nothing
  */
 extern HWND hParentWw;
 extern int vfDiskError;
 extern int vfInitializing;
 int errlevel = ErrorLevel( idpmt );
 CHAR rgch[cchMaxSz];
 CHAR *pch, *PchFillPchId();
 register HWND hWndParent = (vhWndMsgBoxParent == NULL) ? hParentWw : vhWndMsgBoxParent;

 Assert( (hWndParent == NULL) || IsWindow(hWndParent));

 if (idpmt == IDPMTSDE || idpmt == IDPMTSDE2)
        /* Serious disk error, put the guy in "SAVE-ONLY" state */
    if (!vfDiskError)
        {
        vfDiskError = TRUE;
        CloseEveryRfn( TRUE );
        }

 if (ferror || vfInitializing)
        /* Only report one error per operation */
        /* Don't report errors during inz; FInitWinInfo handles them */
    return;

 CloseEveryRfn( FALSE );    /* Close floppy files so the guy can change
                               disks while in the message box. */
 pch = PchFillPchId( rgch, idpmt, sizeof(rgch) );

#ifdef REALDEBUG    /* Only enable extra message if really debugging */
 CchCopySz( szMessage, pch );
#endif
 if (vfDeactByOtherApp && !InSendMessage())
     WaitBeforePostMsg(errlevel);

#ifdef CANCELMSG
 if (IdPromptBoxSz( hWndParent, rgch, errlevel ) == IDCANCEL)
        /* A debugging feature -- show stack trace if he hit "cancel" */
    FatalExit( 0 );
#else
 IdPromptBoxSz( hWndParent, rgch, errlevel );
#endif
 ferror = TRUE;
}
/* end of  D i s k E r r o r  */


ErrorBadMargins(hWnd, xaLeft, xaRight, yaTop, yaBottom)
HWND hWnd;
unsigned xaLeft;
unsigned xaRight;
unsigned yaTop;
unsigned yaBottom;
    {
    /* Warn the user that the margins for this page must be xaLeft, xaRight,
    yaTop, and yaBottom. */

    extern CHAR *vpDlgBuf;
    extern HANDLE hMmwModInstance;
    extern int vfDeactByOtherApp;

    unsigned rgzaMargin[4];
#ifndef INEFFLOCKDOWN
    extern BOOL far PASCAL DialogBadMargins(HWND, unsigned, WORD, LONG);
    FARPROC lpDialogBadMargins;

    if (!(lpDialogBadMargins = MakeProcInstance(DialogBadMargins, hMmwModInstance)))
        {
        WinFailure();
        return;
        }
#endif

    /* These values are kept on the stact to cut down on static variables. */
    rgzaMargin[0] = xaLeft;
    rgzaMargin[1] = xaRight;
    rgzaMargin[2] = yaTop;
    rgzaMargin[3] = yaBottom;
    vpDlgBuf = (CHAR *)&rgzaMargin[0];

    if (vfDeactByOtherApp && !InSendMessage())
        WaitBeforePostMsg(MB_ERROR);

    /* Create the "error" dialog box. */
    DialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgBadMargins), hWnd,
      lpDialogBadMargins);

#ifndef INEFFLOCKDOWN
    FreeProcInstance(lpDialogBadMargins);
#endif
    }


BOOL far PASCAL DialogBadMargins(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles the messages for the Bad Margins dialog box. */

    extern CHAR *vpDlgBuf;
    extern HWND vhWndMsgBoxParent;

    int idi;
    unsigned *prgzaMargin = (unsigned *)vpDlgBuf;

    switch (message)
    {
    case WM_INITDIALOG:
    /* Disable modeless dialog boxes. */
    EnableOtherModeless(FALSE);

    /* Set the values of the margins on the dialog box. */
    for (idi = idiBMrgLeft; idi <= idiBMrgBottom; idi++, prgzaMargin++)
        {
        CHAR szT[cchMaxNum];
        CHAR *pch = &szT[0];

        CchExpZa(&pch, *prgzaMargin, utCur, cchMaxNum);
        SetDlgItemText(hDlg, idi, (LPSTR)szT);
        }
    return (TRUE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
    if (wParam == idiOk)
        {
        /* Destroy the tabs dialog box and enable any existing modeless
        dialog boxes.*/
        OurEndDialog(hDlg, NULL);
        return (TRUE);
        }
    }
    return (FALSE);
    }


/******************* ERROR SITUATION ROUTINES **************************/




FGrowRgbp(cbp)
int cbp;
{
#ifdef CKSM
#ifdef DEBUG
extern unsigned (**hpibpcksm) [];
extern int ibpCksmMax;
#endif
#endif
extern CHAR       (*rgbp)[cbSector];
extern CHAR       *rgibpHash;
extern int        fIbpCheck;
extern int        vcCount;

int ibpMaxNew = ibpMax + cbp;
int iibpHashMaxNew;
int cbNew;
extern int ibpMaxFloat;

if (ibpMaxNew > ibpMaxFloat)
    return(FALSE);

iibpHashMaxNew = ibpMaxNew * 2 + 1;
cbNew = ibpMaxNew * cbSector * sizeof(CHAR) +
        ((iibpHashMaxNew * sizeof(CHAR) + sizeof(int) - 1) & ~1) +
        ((ibpMaxNew * sizeof(struct BPS) + sizeof(int) - 1) & ~1);

if (LocalReAlloc((HANDLE)rgbp, cbNew, LPTR) == (HANDLE)NULL
#ifdef CKSM
#ifdef DEBUG
    || !FChngSizeH( hpibpcksm, ibpMaxNew, FALSE )
#endif
#endif
    )
    {
    if (cbp == 1)
        {
#ifdef CHIC
        CommSzNum("Can't grow any more, current ibpMax = ", ibpMax);
#endif
        vcCount = 1024; /* so that we wait for a longer period before attemp again */
        }
    return(FALSE);
    }
else
    {
    int cbRgbpTotalNew = ibpMaxNew * cbSector;
    int cbHashOrg = (iibpHashMax * sizeof(CHAR) + sizeof(int) - 1) & ~1;
    int cbHashTotalNew = (iibpHashMaxNew * sizeof(CHAR) + sizeof(int) - 1) & ~1;
    int cbBpsOrg = (ibpMax * sizeof(struct BPS) + sizeof(int) - 1) & ~1;
    int ibp;
    struct BPS *pbps;
    CHAR *pNew;

    /* blt tail end stuff first, in the following order --
       mpibpbps, rgibpHash */

    pNew = (CHAR *)rgbp + cbRgbpTotalNew + cbHashTotalNew;
    bltbyte((CHAR*)mpibpbps, pNew, cbBpsOrg);
    mpibpbps =  (struct BPS *)pNew;

    pNew = (CHAR *)rgbp + cbRgbpTotalNew;
    bltbyte((CHAR *)rgibpHash, pNew, cbHashOrg);
    rgibpHash = pNew;

    for (ibp = 0, pbps = &mpibpbps[0]; ibp < ibpMaxNew; ibp++, pbps++)
        {
        if (ibp >= ibpMax)
            {
            /* initialize new bps */
            pbps->fn = fnNil;
            pbps->ts = tsMruBps - (ibpMax * 4);
            }
        pbps->ibpHashNext = ibpNil;
        }
    ibpMax = ibpMaxNew;
    iibpHashMax = iibpHashMaxNew;
#ifdef CKSM
#ifdef DEBUG
    ibpCksmMax = ibpMax;
#endif
#endif
    RehashRgibpHash();
#ifdef CHIC
    CommSzNum("ibpMax = ", ibpMax);
#endif
    return(TRUE);
    }
}


FStillOutOfMemory()
{
/* Return FALSE if there is enough memory available to pop us out of the "out of
memory" state; TRUE otherwise */

extern HANDLE vhReservedSpace;

/* If we have had to give up our reserved space block, re-establish it BEFORE
testing memory availability */

    //return vfWinFailure;

if (vhReservedSpace == NULL && (vhReservedSpace = LocalAlloc(LHND, cbReserve))
  == NULL)
    {
    /* Nothing we can do. */
    return (TRUE);
    }

/* OK, we have our reserve block, but do we have any other memory?  (The use of
cbReserve here is abritrary.) */
if (LocalCompact(0) < cbReserve)
    {
    HANDLE hBuf = LocalAlloc(LMEM_MOVEABLE, cbReserve);

    if (hBuf == NULL)
        {
        return(TRUE);
        }
    else
        {
        LocalFree(hBuf);
        if (GlobalCompact(0) < cbReserve)
            {
            HANDLE hBuf = GlobalAlloc(GMEM_MOVEABLE, cbReserve);

            if (hBuf == NULL)
                {
                return(TRUE);
                }
            else
                {
                GlobalFree(hBuf);
                return(FALSE);
                }
            }
        }
    }


return(FALSE);
}



IbpFindSlot(fn)
int fn;
{ /*
        Description:    Called from IbpEnsureValid (file.c) when a disk
                        full error is generated while trying to write out
                        scratch file records.  A buffer slot for a piece of
                        file fn must be found
                        which is either non-dirty or is dirty but does
                        not contain scratch file information.  We search
                        for the least recently used slot with the above
                        requirements.
                        If fn == fnScratch, we are trying to find a buffer
                        slot for a scratch file page.  We may not put it in
                        the beginning cbpMustKeep slots.
        Returns:        ibp (slot #).
  */
        int ibpOuterLoop;
        int ibpNextTry;
        int ibpStart;
        typeTS ts, tsLastTry = 0;
        int ibp;

#ifdef DEBUG
                Assert(vfSysFull);
#endif
        if (fn == fnScratch) ibpStart = cbpMustKeep;
                else ibpStart = 0;

        /* In LRU timestamp order, we are looking for any slot */
        /* which is non dirty or is dirty but is not part of the */
        /* scratch file. */
        for (ibpOuterLoop = ibpStart; ibpOuterLoop < ibpMax; ibpOuterLoop++)
                {
                struct BPS *pbps = &mpibpbps[ibpStart];
                typeTS tsNextTry = -1;/* largest possible timestamp */
                for(ibp = ibpStart; ibp < ibpMax; ibp++, pbps++)
                        {
                        ts = pbps->ts - (tsMruBps + 1);
                        if ((ts <= tsNextTry) && (ts > tsLastTry))
                                {
                                tsNextTry = ts;
                                ibpNextTry = ibp;
                                }
                        }
                if (mpibpbps[ibpNextTry].fDirty == fFalse) break;
                if (mpibpbps[ibpNextTry].fn != fnScratch)
                        {
                        FFlushFn(mpibpbps[ibpNextTry].fn);
                                        /* We need not check a return value.
                                           If the flush failed, vfDiskFull
                                           will get set */
                        break;
                        }
                else tsLastTry = tsNextTry;
                }

        if (ibpOuterLoop < ibpMax)
                {
                if (fn == vfnWriting) vibpWriting = ibpNextTry;
                return(ibpNextTry);
                }
#ifdef DEBUG
                Assert(FALSE);  /* there just had to be some slot available */
                                /* not used by the scratch file */
#endif
} /* end IbpFindSlot */


NEAR WaitBeforePostMsg(errlevel)
int errlevel;
{
extern int flashID;
extern HWND hwndWait;
BOOL fParentEnable = IsWindowEnabled(hParentWw) || hwndWait;

    MessageBeep(errlevel);

    Diag(CommSzNum("WAITBEFOREPOSTMSG: vfDeactByOtherApp==",vfDeactByOtherApp));
    if (!fParentEnable)
        EnableWindow(hParentWw, TRUE); /* make sure parent window is enabled
                                      to let the user click in it */
    flashID = SetTimer(hParentWw, NULL, 500, (FARPROC)NULL);
    while (vfDeactByOtherApp)
        {
        if (PeekMessage((LPMSG)&vmsgLast, (HWND)NULL, NULL, NULL, PM_REMOVE))
            {
            if (vfDeactByOtherApp)
                {
                TranslateMessage( (LPMSG)&vmsgLast);
                DispatchMessage((LPMSG)&vmsgLast);
                }
            }
        }

    if (!fParentEnable)
        EnableWindow(hParentWw, FALSE); /* reset */
}


EnableExcept(hWnd, fEnable)
HWND hWnd;
BOOL fEnable;
{ /* Enable hParentWw and all modeless except hWnd according to fEnable */
extern HWND   vhDlgChange;
extern HWND   vhDlgFind;
extern HWND   vhDlgRunningHead;
extern HWND   hParentWw;

    if (hWnd != vhDlgChange && IsWindow(vhDlgChange))
        {
        EnableWindow(vhDlgChange, fEnable);
        }
    if (hWnd != vhDlgFind && IsWindow(vhDlgFind))
        {
        EnableWindow(vhDlgFind, fEnable);
        }
    if (hWnd != vhDlgRunningHead && IsWindow(vhDlgRunningHead))
        {
        EnableWindow(vhDlgRunningHead, fEnable);
        }
    EnableWindow(hParentWw, fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diarepag.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the dialog routines for the repagination code. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "editdefs.h"
#include "printdef.h"
#include "docdefs.h"
#include "dlgdefs.h"
#include "propdefs.h"
#define NOKCCODES
#include "ch.h"
#include "str.h"

#ifndef INEFFLOCKDOWN
BOOL far PASCAL DialogRepaginate(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogSetPage(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogPageMark(HWND, unsigned, WORD, LONG);
#endif

fnRepaginate()
    {
    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
#ifdef INEFFLOCKDOWN    
    extern FARPROC lpDialogRepaginate;
#else
    FARPROC lpDialogRepaginate = MakeProcInstance(DialogRepaginate, hMmwModInstance);
#endif
    extern BOOL vfPrErr;
    extern int vfRepageConfirm;
    extern struct SEL selCur;
    extern int docCur;
    extern int vfSeeSel;
    extern int vfOutOfMemory;

    CHAR rgbDlgBuf[sizeof(BOOL)];
    struct SEL selSave;

#ifndef INEFFLOCKDOWN
    if (!lpDialogRepaginate)
        {
        WinFailure();
        return;
        }
#endif    
    /* Create the repaginate dialog box. */
    vpDlgBuf = &rgbDlgBuf[0];
    switch (OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgRepaginate),
      hParentWw, lpDialogRepaginate))
        {
    case idiOk:
        /* Use the print code to repaginate a document. */
        DispatchPaintMsg();

	/* If memory failure occurred, then punt. */
	if (!vfOutOfMemory)
	    {
	    if (vfRepageConfirm)
		{
		/* Save the selection so we can restore it if an error occurs.
		*/
		bltbyte(&selCur, &selSave, sizeof(struct SEL));

		/* Set up the undo block. */
		SetUndo(uacRepaginate, docCur, cp0, CpMacText(docCur), docNil,
		  cpNil, cpNil, 0);
		}

	    /* Repaginate the document. */
	    PrintDoc(docCur, FALSE);

	    if (vfRepageConfirm && vfPrErr)
		{
		/* An error occurred; therefore, set the world back to the way
		we found it. */
		CmdUndo();

		/* Reset the selection. */
		ClearInsertLine();
		Select(selSave.cpFirst, selSave.cpLim);
		vfSeeSel = TRUE;

		/* Sorry, but docUndo has been clobbered and there is no way to
		reset it. */
		NoUndo();
		}
	    }
        break;

    case -1:
        /* We didn't even have enough memory to create the dialog box. */
#ifdef WIN30
        WinFailure();
#else
        Error(IDPMTNoMemory);
#endif
        break;
        }
#ifndef INEFFLOCKDOWN
    if (lpDialogRepaginate)
        FreeProcInstance(lpDialogRepaginate);
#endif
    }


BOOL far PASCAL DialogRepaginate(hDlg, code, wParam, lParam)
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
    {
    extern CHAR *vpDlgBuf;
    extern BOOL vfRepageConfirm;
    extern HWND vhWndMsgBoxParent;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;

    BOOL *pfConfirm = (BOOL *)vpDlgBuf;

    switch (code)
        {
    case WM_INITDIALOG:
        EnableOtherModeless(FALSE);
        CheckDlgButton(hDlg, idiRepageConfirm, *pfConfirm = vfRepageConfirm);
        break;

    case WM_SETVISIBLE:
        if (wParam)
	    {
            EndLongOp(vhcArrow);
	    }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
         if (vfCursorVisible)
             {
             ShowCursor(wParam);
             }
         return(FALSE);

    case WM_COMMAND:
        switch (wParam)
            {
        case idiOk:
            vfRepageConfirm = IsDlgButtonChecked(hDlg, idiRepageConfirm);
        case idiCancel:
            OurEndDialog(hDlg, wParam);
            break;

        case idiRepageConfirm:
            CheckDlgButton(hDlg, idiRepageConfirm, *pfConfirm = !*pfConfirm);
            break;

        default:
            return(FALSE);
            break;
            }
        break;

    default:
        return(FALSE);
        }
    return(TRUE);
    }


BOOL FSetPage()
    {
    /* This routine prompts the user for a new position for each page break.
    The variable ipldCur is set to point to the print line the user wants as
    the first line of the next page.  TRUE is returned if the user hits the
    "Confirm" button on the dialog box; FALSE if the "Cancel" button is hit. */

    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
    extern int docCur;
#ifdef INEFFLOCKDOWN
    extern FARPROC lpDialogSetPage;
#else
    FARPROC lpDialogSetPage = MakeProcInstance(DialogSetPage, hMmwModInstance);
#endif
    extern int vfOutOfMemory;
    extern int vfPrErr;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;
    typeCP cp;

#ifndef INEFFLOCKDOWN
    if (!lpDialogSetPage)
        goto LSPErr;
#endif

    /* Show the user where we think the page break should be.  The AdjustCp()
    call is a kludge to force the redisplay of the first line of the page. */
    AdjustCp(docCur, cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp, (typeCP)1,
      (typeCP)1);
    ClearInsertLine();
    Select(cp, CpLimSty(cp, styLine));
    PutCpInWwHz(cp);
    if (vfOutOfMemory)
	{
Abort:
	/* If memory failure occurred, then punt. */
	vfPrErr = TRUE;
        return (FALSE);
        }

    /* Now, we can create the Set Page dialog box. */
    if (DialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgSetPage), hParentWw,
      lpDialogSetPage) == -1)
        {
        /* We didn't even have enough memory to create the dialog box. */
LSPErr:        
        Error(IDPMTPRFAIL);
        goto Abort;
        }

#ifndef INEFFLOCKDOWN
    if (lpDialogSetPage)
        FreeProcInstance(lpDialogSetPage);
#endif
    
    /* Make sure all the windows have been refreshed. */
    DispatchPaintMsg();

    StartLongOp();
    if (vfOutOfMemory)
        {
        goto Abort;
        }

    /* If the user wishes to cancel the repagination, then the flag fCancel was
    set by the routine handling the message for the dialog box. */
    return (!ppdb->fCancel);
    }


BOOL far PASCAL DialogSetPage(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine processes message sent to the Set Page dialog box.  The only
    messages that are processed are up and down buttons, and confirm and cancel
    commands. */

    extern CHAR *vpDlgBuf;
    extern int docCur;
    extern typeCP vcpFirstParaCache;
    extern struct PAP vpapAbs;
    extern HWND hParentWw;
    extern HWND vhWndMsgBoxParent;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;

    register struct PDB *ppdb = (struct PDB *)vpDlgBuf;
    typeCP cp;

    switch (message)
        {
    case WM_COMMAND:
        switch (wParam)
            {
        case idiRepUp:
            /* Move the page mark towards the beginning of the document one
            line, if possible. */
            if (ppdb->ipldCur == 1)
                {
                beep();
                return (TRUE);
                }
            else
                {
                ppdb->ipldCur--;
                goto ShowMove;
                }

        case idiRepDown:
            /* Move the page mark towards the end of the document one line, if
            possible. */
            if (ppdb->ipldCur == ppdb->ipld)
                {
                beep();
                }
            else
                {
                ppdb->ipldCur++;
ShowMove:
                /* Reflect the movement of the page on the screen. */
                cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp;
                Select(cp, CpLimSty(cp, styLine));
                PutCpInWwHz(cp);
                }
            break;

        case idiCancel:
CancelDlg:
            /* Let the repaginate routine know that the user wishes to cancel
            it. */
            ppdb->fCancel = TRUE;

        case idiOk:
            /* Take down the dialog box. */
	    EnableWindow(hParentWw, TRUE);
            EndDialog(hWnd, NULL);
	    EnableWindow(hParentWw, FALSE);
            vhWndMsgBoxParent = (HWND)NULL;
            EndLongOp(vhcArrow);

            /* Save the changes made by the user. */
            if (!ppdb->fCancel && ppdb->ipldCur != ppdb->ipld)
                {
                /* The user has moved the page break; therefore, insert a new
                page break. */
                CHAR rgch[1];

                rgch[0] = chSect;
                CachePara(docCur, cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp++);
                InsertRgch(docCur, cp, rgch, 1, NULL, cp == vcpFirstParaCache ?
                  &vpapAbs : NULL);

                /* Erase the old page mark from the screen. */
                AdjustCp(docCur, (**ppdb->hrgpld)[ppdb->ipld].cp, (typeCP)1,
                  (typeCP)1);

                /* Ensure that the page table is correct. */
                (**ppdb->hpgtb).rgpgd[ppdb->ipgd].cpMin = cp + 1;
                }

            /* Change the selection to an insertion bar. */
            cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp;
            Select(cp, cp);
            break;
            }

    case WM_SETVISIBLE:
        if (wParam)
            {
            EndLongOp(vhcArrow);
            }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hWnd;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_INITDIALOG:
        return (TRUE);

    case WM_CLOSE:
        goto CancelDlg;
        }

    return (FALSE);
    }


BOOL FPromptPgMark(cp)
typeCP cp;
    {
    /* This routine prompts the user to either remove or keep the page mark at
    cp.  The flag fRemove is set to TRUE if the user wishes to remove the mark;
    FALSE if he wishes to keep it.  FALSE is returned if the user decides to
    cancel the repagination; TRUE if he does not. */

    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
    extern int docCur;
#ifdef INEFFLOCKDOWN
    extern FARPROC lpDialogPageMark;
#else
    FARPROC lpDialogPageMark = MakeProcInstance(DialogPageMark, hMmwModInstance);
#endif
    extern int vfOutOfMemory;
    extern int vfPrErr;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;
#ifndef INEFFLOCKDOWN
    if (!lpDialogPageMark)
        goto LPPMErr;
#endif

    /* This is a kludge to remove a possible page indicator on the line after
    the page mark. */
    AdjustCp(docCur, cp + 1, (typeCP)1, (typeCP)1);

    /* Show the user the page mark in question. */
    ClearInsertLine();
    Select(cp, cp + 1);
    PutCpInWwHz(cp);
    if (vfOutOfMemory)
	{
Abort:
	/* If memory failure occurred, then punt. */
	vfPrErr = TRUE;
#ifndef INEFFLOCKDOWN
        if (lpDialogPageMark)
            FreeProcInstance(lpDialogPageMark);
#endif
        return (FALSE);
        }

    /* Now, we can create the Page Mark dialog box. */
    if (DialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgPageMark), hParentWw,
      lpDialogPageMark) == -1)
        {
LPPMErr:        
        /* We didn't even have enough memory to create the dialog box. */
        Error(IDPMTPRFAIL);
	goto Abort;
        }
    StartLongOp();

    /* Make sure all the windows have been refreshed. */
    DispatchPaintMsg();
    if (vfOutOfMemory)
	{
	goto Abort;
        }

    /* Make the change requested by the user. */
    if (!ppdb->fCancel)
        {
        if (ppdb->fRemove)
            {
            /* Remove the page mark as the user has requested. */
            Replace(docCur, cp, (typeCP)1, fnNil, fc0, fc0);
            }
        else
            {
            /* This is a kludge to force the first line after the page mark to
            be redisplayed. */
            AdjustCp(docCur, cp + 1, (typeCP)1, (typeCP)1);

            /* Change the selection to a insertion bar. */
            Select(cp, cp);
            }
        }

#ifndef INEFFLOCKDOWN
    if (lpDialogPageMark)
        FreeProcInstance(lpDialogPageMark);
#endif
    /* If the user wishes to cancel the repagination, then the flag fCancel was
    set by the routine handling the message for the dialog box. */
    return (!ppdb->fCancel);
    }


BOOL far PASCAL DialogPageMark(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* The routine handles messages sent to the Page Mark dialog box.  The only
    meassages of interest are when either the "Cancel", "Keep", or "Remove"
    buttons are hit. */

    extern CHAR *vpDlgBuf;
    extern HWND hParentWw;
    extern HWND vhWndMsgBoxParent;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;

    switch (message)
        {
    case WM_SETVISIBLE:
        if (wParam)
	    {
            EndLongOp(vhcArrow);
	    }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hWnd;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        return(FALSE);

    case WM_INITDIALOG:
        return(TRUE);

    case WM_COMMAND:
        switch (wParam)
            {
        case idiCancel:
            ppdb->fCancel = TRUE;
            break;

        case idiKeepPgMark:
            ppdb->fRemove = FALSE;
            break;

        case idiRemovePgMark:
            ppdb->fRemove = TRUE;
            break;

        default:
            return (FALSE);
            }
        break;

    case WM_CLOSE:
        ppdb->fCancel = TRUE;
        break;

    default:
        return (FALSE);
        }

    /* Take down the dialog box. */
    EnableWindow(hParentWw, TRUE);
    EndDialog(hWnd, NULL);
    EnableWindow(hParentWw, FALSE);
    vhWndMsgBoxParent = (HWND)NULL;
    EndLongOp(vhcArrow);
    return (TRUE);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diaprint.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

/* This file contains the dialog box routines for the print dialog box and the
printer initialization code. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOCLIPBOARD
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOWH
#define NOWNDCLASS
#define NOSOUND
#define NOCOLOR
#define NOSCROLL
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "dlgdefs.h"
#include "str.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "propdefs.h"


fnPrPrinter()
    {
    /* This routine is the outside world's interface to the print code. */

    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
    extern int docCur;
    CHAR rgbDlgBuf[sizeof(int) + 2 * sizeof(BOOL)];
#ifdef INEFFLOCKDOWN    
    extern FARPROC lpDialogPrint;
#else
    BOOL far PASCAL DialogPrint(HWND, unsigned, WORD, LONG);
    FARPROC lpDialogPrint;
    if (!(lpDialogPrint = MakeProcInstance(DialogPrint, hMmwModInstance)))
        {
        WinFailure();
        return;
        }
#endif

    vpDlgBuf = &rgbDlgBuf[0];
    switch (OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgPrint), hParentWw,
      lpDialogPrint))
        {
    case idiOk:
        /* Force all of the windows to clean up their act. */
        DispatchPaintMsg();

        /* At this point, we have the following :
            vfPrPages = true if print page range else print all pages
            vpgnBegin = starting page number (if vfPrPages)
            vpgnEnd   = ending page number (if vfPrPages)
            vcCopies  = number of copies to print */
        PrintDoc(docCur, TRUE);
        break;

    case -1:
        /* We didn't even have enough memory to create the dialog box. */
#ifdef WIN30
        WinFailure();
#else
        Error(IDPMTNoMemory);
#endif
        break;
        }
#ifndef INEFFLOCKDOWN    
    FreeProcInstance(lpDialogPrint);
#endif
    }


BOOL far PASCAL DialogPrint( hDlg, message, wParam, lParam )
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles input to the Print dialog box. */
    extern CHAR *vpDlgBuf;
    extern int vfPrPages;       /* true if print page range */
    extern int vpgnBegin;       /* starting page number to print */
    extern int vpgnEnd;         /* ending page number to print */
    extern int vcCopies;        /* nubmer of copies to print */
    extern BOOL vfPrinterValid;
    extern HDC vhDCPrinter;
    extern int vfDraftMode;
    extern HWND vhWndMsgBoxParent;
    extern ferror;
    extern HCURSOR vhcArrow;
    extern int vfCursorVisible;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];

    int *pidiRBDown = (int *)vpDlgBuf;
    BOOL *pfDraftMode = (BOOL *)(vpDlgBuf + sizeof(int));
    BOOL *pfDraftSupport = (BOOL *)(vpDlgBuf + sizeof(int) + sizeof(BOOL));
    int iEscape;
    CHAR szPrDescrip[cchMaxProfileSz];

    switch (message)
        {
    case WM_INITDIALOG:
        BuildPrSetupSz(szPrDescrip, &(**hszPrinter)[0], &(**hszPrPort)[0]);
        SetDlgItemText(hDlg, idiPrtDest, (LPSTR)szPrDescrip);
        SetDlgItemText(hDlg, idiPrtCopies, (LPSTR)"1");
        SelectIdiText(hDlg, idiPrtCopies);
        if (vfPrPages)
            {
            *pidiRBDown = idiPrtFrom;
            SetDlgItemInt(hDlg, idiPrtPageFrom, vpgnBegin, TRUE);
            SetDlgItemInt(hDlg, idiPrtPageTo, vpgnEnd, TRUE);
            }
        else
            {
            *pidiRBDown = idiPrtAll;
            }

        iEscape = DRAFTMODE;
        if (*pfDraftSupport = vfPrinterValid && vhDCPrinter && 
            Escape(vhDCPrinter, QUERYESCSUPPORT, sizeof(int), 
                   (LPSTR)&iEscape, (LPSTR)NULL))
            {
            CheckDlgButton(hDlg, idiPrtDraft, *pfDraftMode = vfDraftMode);
            }
        else
            {
            EnableWindow(GetDlgItem(hDlg, idiPrtDraft), FALSE);
            if (!vhDCPrinter) /* we've got a timing thing whereby they
                                 managed to get into the print dialog
                                 inbetween the time printer.setup had
                                 unhooked the old printer and the hookup
                                 of the new one!  ..pault */
            EnableWindow(GetDlgItem(hDlg, idiOk), FALSE);
            }

        CheckDlgButton(hDlg, *pidiRBDown, TRUE);
        EnableOtherModeless(FALSE);
        break;

    case WM_SETVISIBLE:
        if (wParam)
            {
            EndLongOp(vhcArrow);
            }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        return (FALSE);

    case WM_COMMAND:
        switch (wParam)
            {
            BOOL fPages;
            int pgnBegin;
            int pgnEnd;
            int cCopies;

        case idiOk:
            if (fPages = (*pidiRBDown == idiPrtFrom))
                {
                /* Get the range of pages to print. */
                if (!WPwFromItW3Id(&pgnBegin, hDlg, idiPrtPageFrom,
                    pgnMin, pgnMax, wNormal, IDPMTNPI))
                    {
                    /* Reset error condition, so as to report any further error.
                    */
                    ferror = FALSE;
                    return(TRUE);
                    }
                if (!WPwFromItW3Id(&pgnEnd, hDlg, idiPrtPageTo,
                    pgnMin, pgnMax, wNormal, IDPMTNPI))
                    {
                    /* Reset error condition, so as to report any further error.
                    */
                    ferror = FALSE;
                    return(TRUE);
                    }
                }

            /* Get the number of copies to print. */
            if (!WPwFromItW3IdFUt(&cCopies, hDlg, idiPrtCopies, 1, 32767,
              wNormal, IDPMTNPI, FALSE, 0
            ))
                {
                /* Reset error condition, so as to report any further error. */
                ferror = FALSE;
                return(TRUE);
                }

        /* If we have gotten this far, then everything must be okey-dokey.
        */
            vfDraftMode = *pfDraftSupport ? *pfDraftMode : FALSE;
            if (vfPrPages = fPages)
                {
                vpgnBegin = pgnBegin;
                vpgnEnd = pgnEnd;
                }
            vcCopies = cCopies;

        case idiCancel:
            OurEndDialog(hDlg, wParam);
            break;

        case idiPrtPageFrom:
        case idiPrtPageTo:
            if (HIWORD(lParam) == EN_CHANGE)
                {
                if (SendMessage(LOWORD(lParam), WM_GETTEXTLENGTH, 0, 0L) &&
                  *pidiRBDown != idiPrtFrom)
                    {
                    CheckDlgButton(hDlg, *pidiRBDown, FALSE);
                    CheckDlgButton(hDlg, *pidiRBDown = idiPrtFrom, TRUE);
                    }
                return(TRUE);
                }
            return(FALSE);

        case idiPrtAll:
        case idiPrtFrom:
            CheckDlgButton(hDlg, *pidiRBDown, FALSE);
            CheckDlgButton(hDlg, *pidiRBDown = wParam, TRUE);

	    // set focus to the edit field automatically

	    if (wParam == idiPrtFrom)
	    	SetFocus(GetDlgItem(hDlg, idiPrtPageFrom));

            break;

        case idiPrtDraft:
            CheckDlgButton(hDlg, wParam, *pfDraftMode = !(*pfDraftMode));
            break;

        default:
            return(FALSE);
            }
        break;

    default:
        return(FALSE);
        }
    return(TRUE);
    }


BOOL FInitHeaderFooter(fHeader, ppgn, phrgpld, pcpld)
BOOL fHeader;
unsigned *ppgn;
struct PLD (***phrgpld)[];
int *pcpld;
    {
    /* This routine initializes the array of print line descriptors used in
    positioning the header/footer on the printed page.  FALSE is returned if an
    error occurs; TRUE otherwise. */

    extern typeCP cpMinHeader;
    extern typeCP cpMacHeader;
    extern typeCP cpMinFooter;
    extern typeCP cpMacFooter;
    extern int docCur;
    extern struct PAP vpapAbs;
    extern struct SEP vsepAbs;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern int dxpPrPage;
    extern int dxaPrPage;
    extern int dypPrPage;
    extern int dyaPrPage;
    extern struct FLI vfli;
    extern int vfOutOfMemory;

    typeCP cpMin;
    typeCP cpMac;

    /* Get the cpMin and the cpMac for the header/footer. */
    if (fHeader)
        {
        cpMin = cpMinHeader;
        cpMac = cpMacHeader;
        }
    else
        {
        cpMin = cpMinFooter;
        cpMac = cpMacFooter;
        }

    /* Is there a header/footer. */
    if (cpMac - cpMin > ccpEol)
        {
        int cpld = 0;
        int cpldReal = 0;
        int cpldMax;
        int xp;
        int yp;
        int ichCp = 0;
        typeCP cpMacDoc = CpMacText(docCur);

        /* Compute the page number of the start of the headers/footers. */
        CacheSect(docCur, cpMin);
        if ((*ppgn = vsepAbs.pgnStart) == pgnNil)
            {
            *ppgn = 1;
            }

        /* Does the header/footer appear on the first page. */
        CachePara(docCur, cpMin);
        if (!(vpapAbs.rhc & RHC_fFirst))
            {
            (*ppgn)++;
            }

        /* Calculate the bounds of the header/footer in pixels. */
        xp = MultDiv(vsepAbs.xaLeft - dxaPrOffset, dxpPrPage, dxaPrPage);
        yp = fHeader ? MultDiv(vsepAbs.yaRH1 - dyaPrOffset, dypPrPage,
          dyaPrPage) : 0;

        /* Initialize the array of print line descriptors for the header/footer.
        */
        if (FNoHeap(*phrgpld = (struct PLD (**)[])HAllocate((cpldMax = cpldRH) *
          cwPLD)))
            {
            *phrgpld = NULL;
            return (FALSE);
            }

        /* We now have to calculate the array of print line descriptors for the
        header/footer. */
        cpMac -= ccpEol;
        while (cpMin < cpMac)
            {
            /* Format this line of the header/footer for the printer. */
            FormatLine(docCur, cpMin, ichCp, cpMacDoc, flmPrinting);

            /* Bail out if an error occurred. */
            if (vfOutOfMemory)
                {
                return (FALSE);
                }

            /* Is the array of print line descriptors big enough? */
            if (cpld >= cpldMax && !FChngSizeH(*phrgpld, (cpldMax += cpldRH) *
              cwPLD, FALSE))
                {
                return (FALSE);
                }

            /* Fill the print line descriptor for this line. */
                {
                register struct PLD *ppld = &(***phrgpld)[cpld++];

                ppld->cp = cpMin;
                ppld->ichCp = ichCp;
                ppld->rc.left = xp + vfli.xpLeft;
                ppld->rc.right = xp + vfli.xpReal;
                ppld->rc.top = yp;
                ppld->rc.bottom = yp + vfli.dypLine;
                }

            /* Keep track of the non-blank lines in the header/footer */
            if ((vfli.ichReal > 0) || vfli.fGraphics)
                {
                cpldReal = cpld;
                }

            /* Bump the counters. */
            cpMin = vfli.cpMac;
            ichCp = vfli.ichCpMac;
            yp += vfli.dypLine;
            }

        /* If this is a footer, then we have to move the positions of the lines
        around so that the footer ends where the user has requested. */
        if (!fHeader && cpldReal > 0)
            {
            register struct PLD *ppld = &(***phrgpld)[cpldReal - 1];
            int dyp = MultDiv(vsepAbs.yaRH2 - dyaPrOffset, dypPrPage, dyaPrPage)
              - ppld->rc.bottom;
            int ipld;

            for (ipld = cpldReal; ipld > 0; ipld--, ppld--)
                {
                ppld->rc.top += dyp;
                ppld->rc.bottom += dyp;
                }
            }

        /* Record the number of non-blank lines in the head/footer. */
        *pcpld = cpldReal;
        }
    else
        {
        /* Indicate there is no header/footer. */
        *ppgn = pgnNil;
        *phrgpld = NULL;
        *pcpld = 0;
        }
    return (TRUE);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diapara.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* DiaPara.c -- Paragraph Format dialog box specific routines */
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#define NOSCROLL
#define NOCOLOR
#define NOBITMAP
#define NOFONT
#define NODRAWTEXT
#define NOMSG
#define NOWNDCLASS
#define NOKEYSTATE
#define NORASTEROPS
#define NOGDI
#define NOBRUSH
#define NOPEN
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "editdefs.h"
#include "dlgdefs.h"
#include "dispdefs.h"
#include "str.h"
#include "wwdefs.h"

extern struct WWD *pwwdCur;
extern HANDLE hParentWw;
extern struct PAP vpapAbs;
extern struct PAP *vppapNormal;
extern int rgval[];
extern typeCP cpMacCur;
extern int utCur;
extern struct SEL selCur; /* Current selection (i.e., sel in current ww */
extern int docCur; /* Document in current ww */
extern CHAR stBuf[];
extern HWND vhWndMsgBoxParent;
extern int vfCursorVisible;
extern HCURSOR vhcArrow;

#ifdef RULERALSO /* enable out because no need to bring ruler up when tab or indents is invoked */
extern int docRulerSprm;
extern struct TBD rgtbdRuler[];
extern HWND vhDlgIndent;
extern BOOL vfDisableMenus;
extern int vfTabsChanged;
extern int vfTempRuler;
extern struct WWD rgwwd[];
#endif


#ifdef CASHMERE
/* D O	F O R M A T  P A R A */
DoFormatPara(rgval)
VAL rgval[];
	/* add para sprms */

	int val, ival;
	int *pval;
	int sprm;
	struct PAP *ppap;
	typeCP dcp;
	typeCP cpFirst, cpLim;
	struct SEL selSave;
/* this temp array is used to assemble sprm values */
	CHAR rgb[cchTBD * itbdMax + 2/* >> cwPAPBase */];
	int rgw[cwPAPBase];
	ppap = (struct PAP *)&rgw[0];

	if (!FWriteCk(fwcNil))
		return; /* Check for munging end mark in footnote window */

	if (docRulerSprm != docNil) ClearRulerSprm();
	ExpandCurSel(&selSave);

	dcp = (cpLim = selCur.cpLim) - (cpFirst = selCur.cpFirst);
	if (cpLim > cpMacCur)
		{
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp - ccpEol, 0);
		InsertEolInsert(docCur, cpMacCur);
		}
	else
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp, 0);
/* reset adjusted selCur */
	selCur.cpFirst = cpFirst;
	selCur.cpLim = cpLim;


/* any gray fields ? */
	for (ival = 0; ival <= 8; ival++)
		if (rgval[ival] == valNil)
			{
/* yes. generate sprms for any that are not gray */
			for (ival = 0; ival <= 8; ival++)
				if ((val = rgval[ival]) != valNil)
					{
					switch(ival)
						{
					case 0:
						sprm = sprmPJc;
						goto LPara1;
					case 1:
						val = !val;
						sprm = sprmPKeep;
						goto LPara1;
					case 2:
						sprm = sprmPLMarg;
						break;
					case 3:
						sprm = sprmPFIndent;
						break;
					case 4:
						sprm = sprmPRMarg;
						break;
					case 5:
						sprm = sprmPDyaLine;
						break;
					case 6:
						sprm = sprmPDyaBefore;
						break;
					case 7:
						sprm = sprmPDyaAfter;
						break;
					case 8:
						val = !val;
						sprm = sprmPKeepFollow;
						goto LPara1;
						}
/* we come here with one word value */
					bltbyte(&val, &rgb[1], cchINT);
					goto LPara2;
/* we come here with one char value */
LPara1: 	    rgb[1] = val;
LPara2: 	    rgb[0] = sprm;
					AddSprm(rgb);
					}
			goto ParaCommon;
			}
/* otherwise generate a sprm that applies all properties except the tabs */
	blt(vppapNormal, ppap, cwPAPBase);
	pval = &rgval[0];
	ppap->jc = *pval++;
	ppap->fKeep = !*pval++;
	ppap->dxaLeft = *pval++;
	ppap->dxaLeft1 = *pval++;
	ppap->dxaRight = *pval++;
	ppap->dyaLine = *pval++;
	ppap->dyaBefore = *pval++;
	ppap->dyaAfter = *pval++;
	ppap->fKeepFollow = !*pval++;
	bltbyte(ppap, &rgb[2], cwPAPBase * cchINT);
	rgb[1] = cwPAPBase * cchINT;
/* we have: sprm, rgb[1 - n] set up */
	rgb[0] = sprmPSame;
	CachePara(docCur, selCur.cpFirst);
	if (CchDiffer(&vpapAbs, ppap, cwPAPBase * cchINT))
		AddSprm(rgb);
ParaCommon: ;
	if (vfTabsChanged)
		{
		int itbd;
		int cchRgtbd;
/* some tab changes were also made in the ruler */
		for (itbd = 0; rgtbdRuler[itbd].dxa != 0; itbd++);
		bltbyte((CHAR *)rgtbdRuler, &rgb[2], cchRgtbd = cwTBD * cchINT * itbd);
		rgb[1] = cchRgtbd;
		rgb[0] = sprmPRgtbd;
		AddSprm(rgb);
		}
	EndLookSel(&selSave, fTrue);
	SetRgvalAgain(rgval, uacFormatPara);
}

#else			      /* MEMO, not CASHMERE */

/* D O	F O R M A T  P A R A */
DoFormatPara(rgval)
VAL rgval[];
{
	/* add para sprms */

	int val, ival;
	int *pval;
	int sprm;
	struct PAP *ppap;
	typeCP dcp;
	typeCP cpFirst, cpLim;
	struct SEL selSave;
/* this temp array is used to assemble sprm values */
	CHAR rgb[cchTBD * itbdMax + 2/* >> cwPAPBase */];
	int rgw[cwPAPBase];
	ppap = (struct PAP *)&rgw[0];

	if (!FWriteOk( fwcNil ))
	    return;

#ifdef ENABLE /* no ClearRulerSprm yet */
	if (docRulerSprm != docNil) ClearRulerSprm();
#endif
	ExpandCurSel(&selSave);

	dcp = (cpLim = selCur.cpLim) - (cpFirst = selCur.cpFirst);
	if (cpLim > cpMacCur)
		{
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp - ccpEol, 0);
		InsertEolInsert(docCur, cpMacCur);
		}
	else
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp, 0);
/* reset adjusted selCur */
	selCur.cpFirst = cpFirst;
	selCur.cpLim = cpLim;

	for (ival = 0; ival <= 2; ival++)
		if ((val = rgval[ival]) != valNil)
			{
			switch(ival)
				{
				case 0:
					sprm = sprmPLMarg;
					break;
				case 1:
					sprm = sprmPFIndent;
					break;
				case 2:
					sprm = sprmPRMarg;
					break;
				}
/* we come here with one word value */
			bltbyte(&val, &rgb[1], cchINT);
			rgb[0] = sprm;
			AddSprm(rgb);
			}

#ifdef RULERALSO /* tabs in format para dialog box */
	if (vfTabsChanged)
		{
		int itbd;
		int cchRgtbd;
/* some tab changes were also made in the ruler */
		for (itbd = 0; rgtbdRuler[itbd].dxa != 0; itbd++);
		bltbyte((CHAR *)rgtbdRuler, &rgb[2], cchRgtbd = cwTBD * cchINT * itbd);
		rgb[1] = cchRgtbd;
		rgb[0] = sprmPRgtbd;
		AddSprm(rgb);
		}
#endif

	EndLookSel(&selSave, fTrue);
#ifdef ENABLE
	SetRgvalAgain(rgval, uacFormatPara);
#endif
} /* end of DoFormatPara */
#endif /* MEMO, not CASHMERE */


/* P U T  P A R A  N U M */
/* convert n according to unit ut, and leave result in stBuf */
PutParaNum(n, ut)
int n, ut;
	{
	CHAR *pch = &stBuf[1];
	stBuf[0] = CchExpZa(&pch, n, ut, cchMaxNum);
	}


BOOL far PASCAL DialogParaFormats( hDlg, message, wParam, lParam )
HWND	hDlg;			/* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
    /* This routine handles input to the Paragraph Formats dialog box. */
    extern struct SEP vsepNormal;
    extern int ferror;
    unsigned dxaText;
    int wLowLim;
    int i;
    TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP */

    switch (message)
		{
		case WM_INITDIALOG:
#ifdef RULERALSO /* enable out because no need to bring ruler up */
			InitSpecialDialog(&vhDlgIndent, hDlg);
#else
			EnableOtherModeless(FALSE);
#endif
			GetRgtsvPapSel(rgtsv);	/* get paragraph properties */

			  /* note the following loop assumes that the
			     itsv Indent codes are in the same order as
			     the idiPar Indent codes */

			for (i = 0; i < 3; i++)
			    if (rgtsv[itsvLIndent + i].fGray == 0)
				{
				PutParaNum(rgtsv[itsvLIndent + i].wTsv, utCur);
				SetDlgItemText(hDlg, (idiParLfIndent + i),
				      (LPSTR)&stBuf[1]);
				}

			SelectIdiText(hDlg, idiParLfIndent);
			break;

	       case WM_SETVISIBLE:
		       if (wParam)
			   EndLongOp(vhcArrow);
		       return(FALSE);

	       case WM_ACTIVATE:
			if (wParam)
			    vhWndMsgBoxParent = hDlg;
			if (vfCursorVisible)
			    ShowCursor(wParam);
			return(FALSE); /* so that we leave the activate message to
			the dialog manager to take care of setting the focus right */

		case WM_COMMAND:
			switch (wParam)
			{
			case idiOk:
			/* Get xaLeft, First line, and xaRight */
				if (!WPdxaFromItDxa2WId(&rgval[0], hDlg, idiParLfIndent, 0, dxaText = vsepNormal.dxaText,
					wBlank | wSpaces, IDPMTNOTDXA))
					{
					ferror = FALSE; /* minor error, stay in dialog */
					break;
					}
				if (rgval[0] == valNil)
					wLowLim = 0;
				else
					wLowLim = (int) -rgval[0];
				if (!WPdxaFromItDxa2WId(&rgval[1], hDlg, idiParFirst, wLowLim, dxaText,
					wBlank | wSpaces, IDPMTNOTDXA) ||
				    !WPdxaFromItDxa2WId(&rgval[2], hDlg, idiParRtIndent, 0, dxaText,
					wBlank | wSpaces, IDPMTNOTDXA))
					{
					ferror = FALSE; /* minor error, stay in dialog */
					break;
					}
/* we have in rgval:
	0	xaLeft
	1	xaLeft1
	2	xaRight */
				DoFormatPara(rgval);
				/* FALL THROUGH */
			case idiCancel:
#ifdef RULERALSO /* enable out because no need to bring up ruler */
				CancelSpecialDialog(&vhDlgIndent);
#else
				OurEndDialog(hDlg, TRUE);
#endif
				break;
			default:
				return(FALSE);
			}
			break;

		case WM_CLOSE:
#ifdef RULERALSO /* enable out because no need to bring up ruler */
			CancelSpecialDialog(&vhDlgIndent);
#else
			OurEndDialog(hDlg, TRUE);
#endif
			break;

		default:
			return(FALSE);
		}
    return(TRUE);
}
/* end of DialogParaFormats */


#ifdef RULERALSO/* no need to bring up ruler when tab or indent dialog box was invoked */
InitSpecialDialog(phDlg, hDlg)
HANDLE *phDlg;
HANDLE hDlg;
{
/* Special dialog box is a modal dialog box that needs to invoke a ruler if
   not already there.  Since the ruler is a child window, the parent has to
   be enabled and other children except the ruler and/or modeless dialog
   boxes has to be disabled.  Top level menu and the system menu have to
   be locked.

   phDlg : address of the global handle to store the special
	   dialog created (ptr to either vhDlgIndent or vhDlgTab)
	   Ruler relies on these global handle to see if need to
	   update any dialog's items when tabs or indents are moved.
   hDlg  : handle to the special dialog box created.
*/

	*phDlg = hDlg;
	EnableOtherModeless(FALSE); /* disable other modeless dialogs */
	EnableWindow(hParentWw, TRUE);
	EnableWindow(wwdCurrentDoc.wwptr, FALSE);
	if (!pwwdCur->fRuler)
		{
		vfTempRuler = TRUE;
		pwwdCur->fRuler = TRUE;
		CreateRuler();
		}
	else
		UpdateRuler();
	vfTabsChanged = FALSE;
	vfDisableMenus = TRUE;
} /* InitSpecialDialog */


CancelSpecialDialog(phDlg)
HANDLE * phDlg;
{
/* Destroy the special dialog box involves destroying the ruler if it is
   invoked by the creation of the dialog box, then enable the children
   and/or any modeless dialogs that were disabled in InitSpecialDialog.
   System menu and the top level menu has to be unlocked.
   The last thing is to reset the global dialog handle (vhDlgTab or
   vhDlgIndent).  Ruler relies on these global handle to see if need to
   update any dialog's items when tabs or indents are moved.

   phDlg : address of the global handle that stores the special
	   dialog created (ptr to either vhDlgIndent or vhDlgTab)
*/
HANDLE hDlg = *phDlg;

	if (vfTempRuler)
		{
		DestroyRuler();
		vfTempRuler = FALSE;
		pwwdCur->fRuler = FALSE;
		}
	else
		UpdateRuler();
	EndDialog(hDlg, TRUE);
	EnableWindow(wwdCurrentDoc.wwptr, TRUE);
	EnableOtherModeless(TRUE); /* enable other modeless dialogs */
	*phDlg = (HANDLE)NULL;
	vfDisableMenus = FALSE;

} /* CancelSpecialDialog */
#endif /* RULERALSO -- no need to bring up ruler when tab or indent dialog box is invoked */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\diasubs.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NORASTEROPS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDI
#define NOSCROLL
#define NOOPENFILE
#define NOWNDCLASS
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOICON
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOPEN
#define NOBRUSH
#define NODRAWTEXT
#define NOFONT
#define NOMETAFILE
#define NOSOUND
#define NOCOLOR
#define NOCOMM

#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "str.h"
#include "editdefs.h"
#define NOKCCODES
#include "ch.h"
#include "dlgdefs.h"

/*extern int		  idstrUndoBase;*/
extern struct UAB	vuab;
extern int		vfCursorVisible;
extern HCURSOR		vhcArrow;


#ifdef BOGUS /* use WPwFromItW3Id */
BOOL FValidIntFromDlg(hDlg, idi, fSigned, wMin, wMax, pw, idpmt)
HANDLE hDlg;	       /* handle to dialog box */
int    idi;	       /* id of control in dialog box */
BOOL   fSigned;        /* check for sign if true */
int    wMin, wMax;     /* range of valid integer value */
int *  pw;	       /* location to put the int */
int    idpmt;	       /* error message number */
{
    REG1 int wVal;
    BOOL fValOk;

    *pw = wVal = GetDlgItemInt(hDlg, idi, (BOOL far *)&fValOk, fSigned);
    if (fValOk)
	{ /* check range */
	if ((wVal < wMin) || (wVal > wMax))
	    fValOk = false;
	}
    if (!fValOk)
	{
	Error(idpmt);
	SelectIdiText(hDlg, idi);
	SetFocus(GetDlgItem(hDlg, idi));
	}
    return fValOk;
} /* FValidIntFromDlg */
#endif


FPwPosIt(pw, hDlg, it)
HWND hDlg; /* handle to desired dialog box */
int *pw;
int it;
{
    /*-------------------------------------------------------------------
	Purpose:    Positive integer dialog item.
    --------------------------------------------------------------mck--*/
    return(WPwFromItW3IdFUt(pw, hDlg, it, 0, 32767, wNormal, IDPMTNPI, fFalse, 0));
}


WPwFromItW3Id(pw, hDlg, it, wMin, wMax, wMask, id)
HWND hDlg;  /* handle to desired dialog box */
int *pw;    /* Return value */
int it;     /* Item number */
int wMin;   /* Smallest and largest allowed values */
int wMax;
int wMask;  /* Bit mask for allowed variations */
int id;     /* Id of error string if bad */
{
    /*-------------------------------------------------------------------
	Purpose:    General integer dialog item.
    --------------------------------------------------------------mck--*/
    return(WPwFromItW3IdFUt(pw, hDlg, it, wMin, wMax, wMask, id, fFalse, 0));
}

FPdxaPosIt(pdxa, hDlg, it)
HWND hDlg; /* handle to desired dialog box */
int *pdxa;
int it;
{
    /*-------------------------------------------------------------------
	Purpose:    Positive dxa dialog item.
    --------------------------------------------------------------mck--*/
    extern int utCur;

    return(WPwFromItW3IdFUt(pdxa, hDlg, it, 0, 32767, wNormal, IDPMTNPDXA, fTrue, utCur));
}

FPdxaPosBIt(pdxa, hDlg, it)
HWND hDlg; /* handle to desired dialog box */
int *pdxa;
int it;
{
    /*-------------------------------------------------------------------
	Purpose:    Positive dxa dialog item (blank allowed).
    --------------------------------------------------------------mck--*/
    extern int utCur;

    return(WPwFromItW3IdFUt(pdxa, hDlg, it, 0, 32767, wBlank | wSpaces, IDPMTNPDXA, fTrue, utCur));
}

WPdxaFromItDxa2WId(pdxa, hDlg, it, dxaMin, dxaMax, wMask, id)
HWND hDlg;    /* handle to desired dialog box */
int *pdxa;    /* Return value */
int it;       /* Dialog item number */
int dxaMin;   /* Range of allowable measurements */
int dxaMax;
int wMask;    /* Bit mask for allowed variations */
int id;       /* Error id */
{
    /*-------------------------------------------------------------------
	Purpose:    General dxa dialog item.
    --------------------------------------------------------------mck--*/
    extern int utCur;

    return(WPwFromItW3IdFUt(pdxa, hDlg, it, dxaMin, dxaMax, wMask, id, fTrue, utCur));
}

WPwFromItW3IdFUt(pw, hDlg, it, wMin, wMax, wMask, id, fDxa, ut)
int *pw;      /* Return value */
HWND hDlg;    /* handle to desired dialog box */
int it;       /* Item number */
int wMin;     /* Smallest and largest allowed values */
int wMax;
int wMask;    /* Bit mask for allowed variations */
int id;       /* Id of error string if out of range */
int fDxa;     /* Parse as dxa (otherwise int) */
int ut;       /* Units to use as default if fDxa */
{
    /*-------------------------------------------------------------------
	Purpose:    Parse the item in the current dialog.  Must be a valid
		    integer or dxa in the given range.
	Method:     - Get the text string.
		    - Try parse as "".
		    - Try parse as string of all spaces
		    - Parse as a int/dxa (generic error if can't).
		    - Test for ".5".
		    - Compare with min and max.
		    - Try parse as "Auto".
		    - If out of bounds, use id to put up specific error
		      (with strings of min and max as parameters).
	Returns:    The return value may be used as a boolean or as a word.
		    fFalse (0) -> not parsed
		    wNormal (1) -> parsed normally
		    wBlank (2) -> parsed a null line
					   (*pw is valNil)
		    wAuto (4) -> parsed as "Auto" (*pw is 0)
		    wSpaces (16) -> parsed a line of all
					   spaces (*pw is valNil)

		    !fDxa only:
		    wDouble (8) -> parsed with ".5" trailing

	Note:	     The interval [wMin..wMax] is closed.
	Note:	     Return value is doubld the parsed value when wDouble.
	Note:	     When wDouble, 2*wMin and 2*wMax must be valid ints.
	Note:	     Numbers ending in .5 may have no trailing spaces.
	History:
	     6/18/86:	 Adapted for trailing kanji spaces --- yxy
	    07/03/85:	 Added wSpaces return
	    10/23/84:	 Fixed wAuto to return with *pw == 0.
	    10/ 5/84:	 Added ut parameter.
	    10/ 5/84:	 Added wMask and combined dxa and w parsing.
	     9/26/84:	 Created.
    --------------------------------------------------------------mck--*/

    CHAR *pch;		/* Parse pointer */
    CHAR *pchEnd;	/* End of buffer */
    CHAR *pchError;	/* Position of parse error */
    int fParsed;	/* Parses as number/dxa */
    int fOverflow = fFalse; /* True if the number is parsed but it overflow */
    int wGood = wNormal;/* return after good range check */
    CHAR stItem[32];
#ifdef AUTO_SPACING
    CHAR szAuto[32];	/* Hold "Auto" string */
#endif

    /* Get the dialog text */
    stItem[0] = GetDlgItemText(hDlg, it, (LPSTR)&stItem[1], sizeof(stItem)-1);

    /* See if blank (null line) */
    if (wMask & wBlank && stItem[0] == 0)
	{
	*pw = valNil;
	return(wBlank);
	}

    pch = &stItem[1];

    /* See if all spaces  */
    if (wMask & wBlank && wMask & wSpaces)
	{
	int fAllSpaces = fTrue;

	while (*pch != 0)
	   if (*pch++ != ' ')
	       {
	       fAllSpaces = fFalse;
	       break;
	       }
	if (fAllSpaces == fTrue)
	    {
	    *pw = valNil;
	    return(wSpaces);
	    }
	}

    pch = &stItem[1];
    pchEnd = pch + stItem[0];

    /* It parses as a number ... */
    fParsed = fDxa ? FZaFromSs(pw, stItem+1, *stItem, ut)
		   : FPwParsePpchPch(pw, &pch, pchEnd, &fOverflow);

    if (!fDxa && wMask & wDouble)
	{
	(*pw) *= 2;
	wMin *= 2;
	wMax *= 2;
	if (!fParsed)
	    {
	    /* Check if ".5" was reason for bad parse. */
	    if (pch != pchEnd && *pch == '.')
	       {
		pch++;
		/* Allow "ddddd.0*" */
		pchError = pch;
		if (FAllZeroPpchPch(&pchError, pchEnd))
		    fParsed = fTrue;
		/* Allow "ddddd.50*" */
		else if (pch != pchEnd && *pch == '5' &&
			 (pch++, FAllZeroPpchPch(&pch, pchEnd)))
		    {
		    (*pw)++;
		    fParsed = fTrue;
		    wGood = wDouble;
		    }
		/* Mark furthest error condition */
		else if (pchError > pch)
		    pch = pchError;
		}
	    }
	}

    if (fParsed && !fOverflow)
	{
	/* ... and in range */
	if (*pw >= wMin && *pw <= wMax)
	    return(wGood);
#ifdef ENABLE
	/* ... but out of range - no matter what, we will use the supplied
	   id for the error message to be consistant */
	else
	    {
	    SelectIdiText(hDlg, it);
	    SetFocus(GetDlgItem(hDlg, it));
	    Error(id);
	    return(fFalse);
	    }
#endif /* ENABLE */
	}

#ifdef AUTO_SPACING
    /* Invariant: Field does not parse as a number */

    /* Try "Auto" */
    if (wMask & wAuto)
	{
	pch = PchFillPchId(szAuto, IDSTRVaries, sizeof(szAuto));
	*pch = '\0';
	stItem[stItem[0]+1] = '\0';
	if (WCompSz(szAuto, &stItem[1]) == 0)
	    {
	    *pw = 0;
	    return(wAuto);
	    }
	}
#endif /* AUTO_SPACING */

    /* All attempts failed - show user where he went wrong vis the attempted
       number parse. */
    {
    unsigned cchStart = fParsed ? 0 : pch - &stItem[1];
    unsigned cchEnd = 32767;
    int idError = fDxa ? IDPMTNOTDXA : IDPMTNOTNUM;

    if (fParsed)
	idError = id; /* reset idError if we just overflow or fail the range test */
    SendDlgItemMessage(hDlg, it, EM_SETSEL, (WORD)NULL, MAKELONG(cchStart, cchEnd));
    SetFocus(GetDlgItem(hDlg, it));
    Error(idError);
    return(fFalse);
    }
}

FAllZeroPpchPch(ppch, pchMax)
CHAR **ppch;	    /* Bound of character buffer */
CHAR *pchMax;
{
    /*-------------------------------------------------------------------
	Purpose:    Make sure all characters in buffer are spaces or 0's.
	Returns:    *ppch contains first bad character if fFalse returned.
	History:
	     6/18/86:	 Adapted for Kanji chars --- yxy
	    10/ 9/84:	 Created.
    --------------------------------------------------------------mck--*/
    CHAR *pch = *ppch;

    while (pch < pchMax) {
	if (*pch == '0' || *pch == ' ')
	    pch++;
	else {
	    *ppch = pch;
	    return(fFalse);
	}
    }
    return(fTrue);
}

FPwParsePpchPch(pw, ppch, pchMax, pfOverflow)
int *pw;
CHAR **ppch;
CHAR *pchMax;
int *pfOverflow;
{
    /*-------------------------------------------------------------------
	Purpose:    Parse a number in the given buffer.
	Method:        Scan for digits and ignore white space.
	Returns:    Character pointer past last one read in *ppch.
		    Number parsed is returned.	Note that if only a prefix is
		    a valid number we return false, with *ppch set to the
		    first offending character.
	Modification History:
	    06/18/86 ---- Adapted for a kanji space char. --- yxy
    --------------------------------------------------------------mck--*/
#define smInit 0
#define smDig 1
#define smBody 2

    CHAR *pch = *ppch;	    /* Local buffer pointer */
    unsigned int ch;	    /* Character being examined */
    int fNeg = fFalse;
    DWORD dwNum = 0L;
    int fError = fFalse;
    int sm = smInit;

    *pfOverflow = fFalse;
    while (!fError && !(*pfOverflow) && pch < pchMax) {
	ch = *pch;
	if (ch == chSpace)
	    pch++;
	else
	    switch (sm) {
	case smInit:
	    if (ch == '-') {
		fNeg = fTrue;
		pch++;
	    }
	    sm = smDig;
	    break;
	case smDig:
	    if (isdigit(ch))
		sm = smBody;
	    else
		fError = fTrue;
	    break;
	case smBody:
	    if (isdigit(ch)) {
		/* Overflow? */
		if ((dwNum = 10*dwNum + WFromCh(ch)) > 0x7FFF)
		    *pfOverflow = fTrue;
		else
		    pch++;
	    }
	    else
		fError = fTrue;
	    break;
	}
    }

    *ppch = pch;
    *pw = (int)(fNeg ? -dwNum : dwNum);
    return(!fError);
}


EnableOtherModeless(fEnable)
BOOL fEnable;
{
extern HWND   vhDlgChange;
extern HWND   vhDlgFind;
extern HWND   vhDlgRunningHead;

/* Disable or enable other modeless dialog boxes according to fEnable */

if (IsWindow(vhDlgFind))
    {
    EnableWindow(vhDlgFind, fEnable);
    }
if (IsWindow(vhDlgChange))
    {
    EnableWindow(vhDlgChange, fEnable);
    }
if (IsWindow(vhDlgRunningHead))
    {
    EnableWindow(vhDlgRunningHead, fEnable);
    }
}


SelectIdiText(hDlg, idi)
HWND hDlg;
int  idi;
{ /* For the dialog box with handle hDlg, highlight the text of the control
     with ID idi */
    unsigned cchStart = 0;
    unsigned cchEnd = 0x7fff;
    SendDlgItemMessage(hDlg, idi, EM_SETSEL, (WORD)NULL, MAKELONG(cchStart, cchEnd));
} /* end of SelectIdiText */


#ifdef ENABLE
SetRgvalAgain(rgvalLocal, uac)
VAL    rgvalLocal[];
int    uac;
    {
    extern VAL rgvalAgain[];

    blt(rgvalLocal, rgvalAgain, ivalMax * cwVal);
    switch (vuab.uac = uac)
	{
    case uacFormatPara:
    case uacFormatChar:
    case uacFormatSection:
/*	  idstrUndoBase = IDSTRUndoBase;*/
/*	  SetUndoMenuStr(IDSTRUndoCom);*/
	SetUndoMenuStr(IDSTRUndoBase);
	break;
	}
    }
#endif


#ifdef CASHMERE
PushRadioButton(hDlg, idiFirst, idiLast, idiPushed)
HWND hDlg;
int idiFirst, idiLast, idiPushed;
{
    /*
    Push radio button idiPushed and unpush all others in the radio group
    bounded by idiFirst and idiLast.
    */
    int idi;

    for (idi = idiFirst; idi <= idiLast; idi++)
	CheckDlgButton(hDlg, idi, idi == idiPushed);
}


SetRadValue(hDlg, idiFirst, idiLast, idiRad)
HWND hDlg;
int  idiFirst, idiLast, idiRad;
{
    /*
    Set the (zero-based) idiRad'th item in the radio group
    bounded by idiFirst and idiLast.
    */
    PushRadioButton(hDlg, idiFirst, idiLast, idiFirst + idiRad);
}

#endif /* CASHMERE */


#ifdef ENABLE
BOOL far PASCAL DialogConfirm(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This is the Dialog function for all dialog boxes with only "Yes", "No",
    and "Cancel" boxes; this includes:	Save Large Scrap */

    extern HWND vhWndMsgBoxParent;

    switch (message)
	{
    case WM_INITDIALOG:
	EnableOtherModeless(FALSE);
	break;

    case WM_SETVISIBLE:
	if (wParam)
	    EndLongOp(vhcArrow);
	return(FALSE);

    case WM_ACTIVATE:
	if (wParam)
	    {
	    vhWndMsgBoxParent = hDlg;
	    }
	if (vfCursorVisible)
	    ShowCursor(wParam);
	return(FALSE); /* so that we leave the activate message to
	the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
	switch (wParam)
	    {
	    /* The default button is NO, make sure the call routine realized
	   that idiOk should be treated as idiNo. */
	case idiOk:
	case idiCancel:
	case idiYes:
	case idiNo:
	    OurEndDialog(hDlg, wParam);
	    break;
	default:
	    Assert(FALSE);
	    break;
	    }
	break;

    default:
	return(FALSE);
	}
    return(TRUE);
    } /* end of DialogConfirm */
#endif /* ENABLE */


#ifndef WIN30
/* DialogBox has been fixed so it automatically brings up the hourglass! */

OurDialogBox(hInst, lpstr, hWndParent, lpProc)
HANDLE hInst;
LPSTR lpstr;
HWND hWndParent;
FARPROC lpProc;
{
StartLongOp();
return(DialogBox(hInst, lpstr, hWndParent, lpProc));
}
#endif


OurEndDialog(hDlg, wParam)
    {
    /* This routine does the same standard things Write does everytime it closes
    a dialog box. */

    extern HWND hParentWw;
    extern long ropErase;
    extern HWND vhWndMsgBoxParent;
    extern HCURSOR vhcIBeam;

    RECT rc;
    POINT pt;

#ifdef NO_NEW_CALL
    /* Close down the dialog box and erase it from the screen.	We tried to let
    Windows do the erasing, but...  Its a long story. */
    GetWindowRect(hDlg, (LPRECT)&rc);
    pt.x = pt.y = 0;
    ClientToScreen(hParentWw, (LPPOINT)&pt);
#endif

    EndDialog(hDlg, wParam);

#ifdef NO_NEW_CALL
    PatBlt(GetDC(hParentWw), rc.left - pt.x, rc.top - pt.y, rc.right - rc.left,
      rc.bottom - rc.top, ropErase);
#endif

    /* Enable any existing dialog boxes and indicate that any error messages
    belong to the document window. */
    EnableOtherModeless(TRUE);
    vhWndMsgBoxParent = (HWND)NULL;
#ifndef WIN30
    EndLongOp(vhcIBeam);    /* See StartLongOp() above */
#endif
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\disp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* disp.c -- MW display routines */

#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
//#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NOWH
#define NOWINOFFSETS
#define NOMETAFILE
#define NOMB
#define NODRAWTEXT
#include <windows.h>

#define NOUAC
#include "mw.h"
#include "debug.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#define NOKCCODES       /* Removes all kc code defines */
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "macro.h"
#include "printdef.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif
#ifdef DBCS
#include "dbcs.h"
#endif

#ifdef CASHMERE     /* No VisiMode in WinMemo */
extern int              vfVisiMode;
#endif /* CASHMERE */

extern int              vcchBlted;
extern int              vidxpInsertCache;
extern int              vdlIns;
extern int              vfInsLast;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern int              rgval[];
extern struct DOD       (**hpdocdod)[];
extern typeCP           cpMacCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur, wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern int              docCur;
extern struct CHP       (**vhgchpFormat)[];
extern int              vichpFormat;
extern typeCP           cpMinCur;
extern typeCP           cpMinDocument;
extern int              vfInsertOn;
extern int              vfTextBltValid;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern unsigned         vpgn;
extern struct SEP       vsepAbs;
extern CHAR             stBuf[];
extern typeCP           CpEdge();
extern typeCP           CpMacText();
extern int              vdocPageCache;
extern int              vfPictSel;
extern int              vfAwfulNoise;
extern int              vfSkipNextBlink;
extern int              dypMax;
extern HDC              vhMDC;
extern HWND             vhWndPageInfo;
extern struct FMI       vfmiScreen;
extern int              docScrap;
extern long             rgbBkgrnd;
extern long             ropErase;
extern BOOL             vfMonochrome;
extern int              dxpbmMDC;
extern int              dypbmMDC;
extern HBITMAP          hbmNull;
extern int              vfOutOfMemory;
extern int              vfSeeSel;
extern int              vfInsEnd;   /* Is insert point at end-of-line? */
extern int              vipgd;
extern typeCP           vcpMinPageCache;
extern typeCP           vcpMacPageCache;
/* actual position of the cursor line */
extern int              vxpCursLine;
extern int              vypCursLine;

extern int              vdypCursLine;
extern int              vfScrollInval; /* means scroll did not take and UpdateWw must be repeated */
extern BOOL             vfDead;
extern HRGN             vhrgnClip;


/* G L O B A L S
int dlsMac = 0;*/
#ifdef DBCS
int donteat = 0;	/* propagate not to eat message */
#endif


/* D I S P L A Y  F L I */
/* Display formatted line in window ww at line dl */


DisplayFli(ww, dl, fDontDisplay)
int ww;
int dl;
int fDontDisplay; /* True if we set up dl info but don't display */
    {
#ifdef	KOREA  // jinwoo: 92, 9, 28
 /* process Subscript separatedly from descent */
#ifdef NODESC
    extern int isSubs;
#endif
#endif
    typeCP dcp;
    typeCP dcpMac;
    struct WWD *pwwd = &rgwwd[ww];
    HDC hDC = pwwd->hDC;
    int xp;                     /* Current xp to write text */
    int yp;                     /* Current yp to write text */
    int xpMin = pwwd->xpMin;    /* Minimum xp in window */
    int xpMac = pwwd->xpMac;    /* Maximum xp in window */
    int ypLine;                 /* Screen yp for current line */
    int dxp;                    /* Width of current run */
    int dyp;                    /* Line height */
    int dxpExtra;               /* Width of pad for each space */
    typeCP cpMin;
    typeCP cpMac;
    int xpSel;                  /* xp of the start of the selection */
    int dxpSel = 0;             /* Width of the selection. */
    CHAR chMark = '\0';         /* style character */
    struct CHP *pchp;
    BOOL fTabsKludge = (vfli.ichLastTab >= 0);
    BOOL fInsertOn = FALSE;
    int cBreakRun;              /* break characters in run (no relation to Dick or Jane) */

#ifdef SMFONT
    RECT rcOpaque;
#endif /* SMFONT */

#ifdef DDISP
    CommSzNumNum("    DisplayFli: dl/fDontDisplay ", dl, fDontDisplay);
#endif
    Assert(ww >= 0 && ww < wwMax);
#ifdef SMFONT
    Assert(!fDontDisplay || vfli.fGraphics)
#endif /* SMFONT */
    Scribble(5,'D');

    /* Fill up EDL and set some useful locals */
        {
        register struct EDL *pedl = &(**pwwd->hdndl)[dl];

        if (dl == vdlIns)
            {
            /* Overwriting chars blted during fast insert; reset blt count */
            vcchBlted = 0;
            vidxpInsertCache = -1;
            }

        pedl->xpLeft = vfli.xpLeft;
        pedl->xpMac = vfli.xpReal;
        cpMin = pedl->cpMin = vfli.cpMin;
        pedl->dcpMac = (cpMac = vfli.cpMac) - cpMin;
        dyp = pedl->dyp = vfli.dypLine;
        pedl->ichCpMin = vfli.ichCpMin;
        pedl->dcpDepend = (cpMin == cpMac) ? 0xff : vfli.dcpDepend;
        pedl->fValid = TRUE;
        pedl->fGraphics = vfli.fGraphics;
        pedl->fSplat = vfli.fSplat;

        /* The position of current line equals the position of the previous line
        + height of this line. */
#ifdef SMFONT
        pedl->yp = rcOpaque.bottom = dyp + (ypLine = rcOpaque.top = (dl == 0 ?
          pwwd->ypMin : (pedl - 1)->yp));
#else /* not SMFONT */
        pedl->yp = dyp + (ypLine = (dl == 0 ? pwwd->ypMin :
          (pedl - 1)->yp));
#endif /* SMFONT */

        if (pedl->fIchCpIncr = (vfli.ichCpMac != 0))
            {
            /* Look at final text column */
            ++cpMac;

            /* Since this is true, we can compress pedl->ichCpMac to 1 bit. */
            Assert(vfli.ichCpMac == pedl->ichCpMin + 1);
            }
        }

    if (vfli.doc == docNil)
        {
        /* This is the space beyond the end mark. */
        PatBlt(hDC, 0, ypLine, xpMac, dyp, ropErase);
        goto Finished;
        }

    /* Is there a character in the "style bar"? */
    if (cpMin != cpMac)
        {

#ifdef CASHMERE
        /* This line is not completely empty (not after the end mark); check for
        painting marks on the style bar. */
        if (cpMin == vcpFirstParaCache && vpapAbs.rhc != 0)
            {
            /* This is a running-head. */
            chMark = chStatRH;
            }
        else if ((**hpdocdod)[vfli.doc].hpgtb != 0)
#else /* not CASHMERE */
        if (vpapAbs.rhc == 0 && (**hpdocdod)[vfli.doc].hpgtb != 0)
#endif /* CASHMERE */

            {
            if (vdocPageCache != vfli.doc || cpMac > vcpMacPageCache || cpMac <=
              vcpMinPageCache)
                {
                CachePage(vfli.doc, cpMac - 1);
                }

            /* We are now guaranteed that cpMac is within the cached page. */
            if (cpMin <= vcpMinPageCache && (!vfli.fGraphics || vfli.ichCpMin ==
              0))
                {
                /* This is the first line of new page; show page mark. */
                chMark = chStatPage;
                }
            }
        }

#ifdef SMFONT
#ifdef DDISP
    /* black out this line to test how efficiently/correctly we
       overwrite pixels from previously-resident lines of text */
    PatBlt(hDC, 0, ypLine, xpMac, dyp, BLACKNESS);
    { long int i; for (i=0; i < 500000; i++) ; }
#endif
    
    /* Calculate dcpMac now, so we might be able to know how much to erase. */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;

    /* Erase any character that might be in the style bar. */
    dxp = xpSelBar + 1;
    if (!vfli.fGraphics)
        {
        dxp = xpMac; // clear the whole line 
        }
    PatBlt(hDC, 0, ypLine, dxp, dyp, ropErase);

    /* If this is graphics then go draw any characters in the style bar. */
    if (vfli.fGraphics)
        {
        goto DrawMark;
        }

    /* If there are no "real" characters on this line then we can skip alot of
    this. */
    if (dcpMac == 0)
        {
        goto EndLine2;
        }
#else /* not SMFONT */
    if (vfli.fGraphics || fDontDisplay)
        {
        /* Erase any character that might be in the style bar. */
        PatBlt(hDC, 0, ypLine, xpSelBar, dyp, ropErase);
        goto DrawMark;
        }
#endif /* SMFONT */

    ValidateMemoryDC();
    if (vhMDC == NULL)
        {
Error:
        /* Notify the user that an error has occured and simply erase this line.
        */
        WinFailure();
        PatBlt(hDC, xpSelBar, ypLine, xpMac - xpSelBar, dyp, ropErase);
        goto Finished;
        }

#ifndef SMFONT
    /* Create a new bitmap for the memory DC if the current bitmap is not big
    enough. */
    if (xpMac > dxpbmMDC || dyp > dypbmMDC)
        {
        HBITMAP hbm;

        /* If there is an old bitmap, then delete it. */
        if (dxpbmMDC != 0 || dypbmMDC != 0)
            {
            DeleteObject(SelectObject(vhMDC, hbmNull));
            }

        /* Create the new bitmap and select it in. */
        if ((hbm = CreateBitmap(dxpbmMDC = xpMac, dypbmMDC = dyp, 1, 1,
          (LPSTR)NULL)) == NULL)
            {
            /* There should be a graceful way to recover if the bitmap is ever
            NULL (e.g we don't have enough memory for it). */
            dxpbmMDC = dypbmMDC = 0;
            goto Error;
            }
        SelectObject(vhMDC, hbm);
        }

    /* Erase the are of the bitmap we are going to use. */
    PatBlt(vhMDC, xpSelBar, 0, xpMac, dyp, vfMonochrome ? ropErase : WHITENESS);
#endif /* not SMFONT */

    /* Initialize some of the variables we'll need. */
    pchp = &(**vhgchpFormat)[0];
#ifdef SMFONT
    xp = rcOpaque.left = rcOpaque.right = vfli.xpLeft + xpSelBar - xpMin + 1;
#else /* not SMFONT */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;
    xp = vfli.xpLeft + xpSelBar - xpMin + 1;
#endif /* SMFONT */
    dxpExtra = fTabsKludge ? 0 : vfli.dxpExtra;

#ifdef SMFONT
    /* If we are horizontally scrolled, then set the clip area to the area
    outside of the selection bar. */
    if (xpMin != 0)
        {
        IntersectClipRect(hDC, xpSelBar, rcOpaque.top, xpMac, rcOpaque.bottom);
        }
#endif /* SMFONT */

    for (dcp = 0; dcp < dcpMac; pchp++)
        {
        /* For all runs do: */
        int ichFirst;   /* First character in the current run */
        int cchRun;     /* Number of characters in the current run */

        dcp = ichFirst = pchp->ichRun;
        dcp += pchp->cchRun;
        if (dcp > dcpMac)
            {
            dcp = dcpMac;
            }
        cchRun = dcp - ichFirst;

        /* Compute dxp = sum of width of characters in current run (formerly
        DxaFromIcpDcp). */
            {
            register int *pdxp;
            register int cchT = cchRun;
            PCH pch = vfli.rgch + ichFirst;

            dxp = cBreakRun = 0;
            pdxp = &vfli.rgdxp[ichFirst];
            while (cchT-- > 0)
                {
                dxp += *pdxp++;
                if (*pch++ == chSpace)
                    ++cBreakRun;
                }
#ifdef DDISP
            CommSzNum("  dxp=",dxp);
#endif
            }

        if (dxp > 0)
            {
            int cchDone;
            PCH pch = &vfli.rgch[ichFirst];

#ifdef	KOREA	//920525 KDLEE;  jinwoo: 92, 9, 28
#ifdef NODESC
	    TEXTMETRIC tm;
#endif
#endif  //KOREA
            LoadFont(vfli.doc, pchp, mdFontScreen);
#ifdef	KOREA	      //KDLEE 920525;  jinwoo: 92, 9, 28
#ifdef NODESC
	    GetTextMetrics (vhMDC, (LPTEXTMETRIC)&tm);

	    if (tm.tmCharSet==HANGEUL_CHARSET)
		yp = dyp - (vfli.dypBase/3) -((pchp->hpsPos != 0 ? (pchp->hpsPos <
			hpsNegMin ? ypSubSuper : -ypSubSuper) : 0)) -
			vfmiScreen.dypBaseline - (isSubs ? ypSubSuper : 0);
	    else
		yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
			hpsNegMin ? ypSubSuper : -ypSubSuper) :  0))) -
			vfmiScreen.dypBaseline - (isSubs ? ypSubSuper : 0);
#else	/* NODESC */
            yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
              hpsNegMin ? ypSubSuper : -ypSubSuper) : 0))) -
              vfmiScreen.dypBaseline;
#endif	/* NODESC */
#else   /* KOREA */

            yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
              hpsNegMin ? ypSubSuper : -ypSubSuper) : 0))) -
              vfmiScreen.dypBaseline;
#endif // KOREA  jinwoo: 92, 9, 28


            /* Note: tabs and other special characters are guaranteed to come at
            the start of a run. */
            SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);
#ifdef SMFONT
            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* SMFONT */
            cchDone = 0;
            while (cchDone < cchRun)
                {
                int cch;

                /* Does the wide-space zone begin in this run? */
                if (vfli.fAdjSpace && (vfli.ichFirstWide < ichFirst + cchRun) &&
                  (ichFirst + cchDone <= vfli.ichFirstWide))
                    {
                    int cchDoneT = cchDone;

                    /* Is this the beginning of the wide-space zone? */
                    if (ichFirst + cchDone == vfli.ichFirstWide)
                        {
                        /* Reset the width of the spaces. */
                        SetTextJustification(vhMDC, ++dxpExtra * cBreakRun, cBreakRun);
#ifdef SMFONT
                        SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* SMFONT */
                        cch = cchRun - cchDone;
                        cchDone = cchRun;
                        }
                    else
                        {
                        cchDone = cch = vfli.ichFirstWide - ichFirst;
                        }

                    /* This run is cut short because of a wide space, so we need
                    to calculate a new width. */
                        {
                        register int *pdxp;
                        register int cchT = cch;
                        PCH pch = &vfli.rgch[ichFirst + cchDoneT];

                        dxp = 0;
                        pdxp = &vfli.rgdxp[ichFirst + cchDoneT];
                        while (cchT-- > 0)
                            {
                            dxp += *pdxp++;
                            if (*pch++ == chSpace)
                                ++cBreakRun;
                            }
                        }
                    }
                else
                    {
                    cchDone = cch = cchRun;
                    }

                while (cch > 0)
                    {
                    switch (*pch)
                        {
                        CHAR ch;
                        int dxpT;

                    case chTab:

#ifdef CASHMERE
                        /* chLeader contains tab leader character (see
                        FormatLine) */
                        if ((ch = pchp->chLeader) != chSpace)
                            {
                            int cxpTab;
                            CHAR rgch[32];
                            int dxpLeader = CharWidth(ch);
                            int xpT = xp;
                            int iLevelT = SaveDC(vhMDC);

                            SetBytes(&rgch[0], ch, 32);
                            dxpT = vfli.rgdxp[ichFirst];
                            cxpTab = ((dxpT + dxpLeader - 1) / dxpLeader + 31)
                              >> 5;

                            xp += dxpT;

                            while (cxpTab-- > 0)
                                {
                                TextOut(vhMDC, xpT, yp, (LPSTR)rgch, 32);
                                xpT += dxpLeader << 5;
                                }
                            RestoreDC(vhMDC, iLevelT);
                            }
                        else
#endif /* CASHMERE */

                            {
#ifdef SMFONT
                            /* Expand the opaque rectangle to include the tab.
                            */
                            rcOpaque.right += vfli.rgdxp[ichFirst];
#endif /* SMFONT */
                            xp += vfli.rgdxp[ichFirst];
                            }

                        if (fTabsKludge && ichFirst >= vfli.ichLastTab)
                            {
                            SetTextJustification(vhMDC, (dxpExtra =
                              vfli.dxpExtra) * cBreakRun, cBreakRun);
#ifdef SMFONT
                            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* SMFONT */
                            fTabsKludge = FALSE;
                            }
                        dxp -= vfli.rgdxp[ichFirst];
                        pch++;
                        cch--;
                        goto EndLoop;

#ifdef CASHMERE
                    case schPage:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpPgn(&stBuf[1], vpgn, vsepAbs.nfcPgn,
                          flmSandMode, ichMaxLine);
                        goto DrawSpecial;

                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpFtn(&stBuf[1], cpMin + ichFirst,
                          flmSandMode, ichMaxLine);
DrawSpecial:
#else /* not CASHMERE */
                    case schPage:
                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = *pch == schPage && (wwdCurrentDoc.fEditHeader
                          || wwdCurrentDoc.fEditFooter) ? CchExpPgn(&stBuf[1],
                          vpgn, 0, flmSandMode, ichMaxLine) :
                          CchExpUnknown(&stBuf[1], flmSandMode, ichMaxLine);
#endif /* not CASHMERE */

#ifdef SMFONT
                        /* Calculate the opaque rectangle. */
                        rcOpaque.right += vfli.rgdxp[ichFirst] +
                          vfmiScreen.dxpOverhang;

                        TextOut(hDC, xp, ypLine+yp, &stBuf[1], stBuf[0]);
#else /* not SMFONT */
                        TextOut(vhMDC, xp, yp, (LPSTR)&stBuf[1], stBuf[0]);
#endif /* SMFONT */
                        break;

                    default:
                        goto EndLoop;
                        }

                    dxp -= vfli.rgdxp[ichFirst];
#ifdef SMFONT
                    /* End the line if no more will fit into the window. */
                    if ((xp += vfli.rgdxp[ichFirst++]) >= xpMac) {
                        goto EndLine;
                    }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
#else /* not SMFONT */
                    xp += vfli.rgdxp[ichFirst++];
#endif /* SMFONT */
                    pch++;
                    cch--;
                    }
EndLoop:

#ifdef SMFONT
                if (cch == 0)
                    {
                    Assert(dxp == 0);
                    }
                else
                    {
                    /* Calculate the opaque rectangle. */
                    rcOpaque.right += dxp + vfmiScreen.dxpOverhang;

#if 0
            {
                char msg[180];
                wsprintf(msg,"putting out %d characters\n\r",cch);
                OutputDebugString(msg);
            }
#endif
                    /* Output cch characters starting at pch */
                    TextOut(hDC, xp, ypLine+yp, pch, cch);

                    /* End the line if no more will fit into the window. */
                    if ((xp += dxp) >= xpMac)
                        {
                        goto EndLine;
                        }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
                    pch += cch;
                    }
#else /* not SMFONT */
                /* Output cch characters starting at pch */
                TextOut(vhMDC, xp, yp, (LPSTR)pch, cch);
                xp += dxp;
                pch += cch;
#endif /* SMFONT */
                } /* end while (cchDone<cchRun) */
            } /* end if (dxp>0) */
        } /* end for dcp=0..dcpMac */

#ifdef SMFONT
EndLine:
    /* Restore the clip region if need be. */
    if (xpMin != 0)
        {
        SelectClipRgn(hDC, NULL);
        }
EndLine2:
#endif /* SMFONT */

#ifdef CASHMERE
    if (vfVisiMode)
        {
        AddVisiSpaces(ww, &(**pwwd->hdndl)[dl], vfli.dypBase, vfli.dypAfter +
          vfli.dypFont);
        }
#endif /* CASHMERE */

    vfTextBltValid = FALSE;

    if ((ww == wwCur) && (pwwd->doc != docScrap) && !vfSelHidden &&
      (selCur.cpLim >= cpMin))
        {
        if (selCur.cpFirst <= cpMac)
            {
            /* Show selection */
            int xpFirst;
            int xpLim;

#ifdef ENABLE
            if (vfli.fSplatNext && selCur.cpFirst == selCur.cpLim &&
                selCur.cpFirst == cpMac)
                {
                vfInsEnd = TRUE;
                ClearInsertLine();
                }
            vfInsertOn = FALSE;
#endif /* ENABLE */

            if (selCur.cpFirst <= cpMin && selCur.cpLim >= cpMac)
                {
                xpFirst = vfli.xpLeft;
                xpLim = vfli.xpReal;
                }
            else if (selCur.cpFirst < cpMac || (selCur.cpLim == cpMac &&
              vfInsEnd))
                {
                typeCP cpBegin = CpMax(cpMin, selCur.cpFirst);
                typeCP cpEnd = CpMin(cpMac, selCur.cpLim);

                dxp = DxpDiff((int)(cpBegin - cpMin), (int)(cpEnd - cpBegin),
                  &xpFirst);
                xpLim = min(xpMin + vfli.xpReal, xpFirst + dxp);
                }
            else
                {
                goto DidntHighlight;
                }

            xpSel = xpSelBar + max(xpFirst - xpMin, 0);
            if (xpLim > xpFirst)
                {
                /* Set highlighting at desired screen position. */
                dxpSel = max(xpLim - max(xpFirst, xpMin), 0);
                }
            else if (selCur.cpFirst == selCur.cpLim && ((selCur.cpLim != cpMac)
              ^ vfInsEnd))
                {
                vfInsertOn = FALSE; /* Because we redisplayed insert pt line */

#ifdef CASHMERE
                vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
                vypCursLine = ypLine + dyp - vfli.dypAfter;
#else /* not CASHMERE */
                vdypCursLine = vfli.dypFont;
                vypCursLine = ypLine + dyp;
#endif /* not CASHMERE */

                vxpCursLine = xpSel;

                /* Start blinking in a while */
                vfSkipNextBlink = TRUE;

                fInsertOn = xpFirst >= xpMin;
                }

DidntHighlight:;
            }
        }

#ifdef SMFONT
    /* Invert the selection */
    if (dxpSel != 0) {
        PatBlt(hDC, xpSel, ypLine, dxpSel, dyp, DSTINVERT);
    }
#else /* not SMFONT */
    /* Blt the line of text onto the screen. */
    PatBlt(vhMDC, 0, 0, xpSelBar, dyp, vfMonochrome ? ropErase : WHITENESS);
    if (dxpSel == 0)
        {
        BitBlt(hDC, 0, ypLine, xpMac, dyp, vhMDC, 0, 0, SRCCOPY);
        }
    else
        {
        BitBlt(hDC, 0, ypLine, xpSel, dyp, vhMDC, 0, 0, SRCCOPY);
        BitBlt(hDC, xpSel, ypLine, dxpSel, dyp, vhMDC, xpSel, 0, NOTSRCCOPY);
        xpSel += dxpSel;
        BitBlt(hDC, xpSel, ypLine, xpMac - xpSel, dyp, vhMDC, xpSel, 0,
          SRCCOPY);
        }
#endif /* SMFONT */

    /* Draw the insertion bar if necessary. */
    if (fInsertOn)
        {
        DrawInsertLine();
        }

DrawMark:
    /* Draw the character in the style bar if necessary. */
    if (chMark != '\0')
        {
#ifdef SYSENDMARK
        struct CHP         chpT;
        extern struct CHP  vchpNormal;

        blt(&vchpNormal, &chpT, cwCHP);
        chpT.ftc     = ftcSystem;
        chpT.ftcXtra = 0;
        chpT.hps     = hpsDefault;

        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, &chpT, mdFontScreen);

        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline, 
                (LPSTR)&chMark, 1);
#else /* ifdef SYSENDMARK */
        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, NULL, mdFontScreen);
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
          (LPSTR)&chMark, 1);
#endif /* if-else-def SYSENDMARK */
        }

    if (vfli.fGraphics)
        {
        DisplayGraphics(ww, dl, fDontDisplay);
        }

Finished:
    Scribble(5,' ');
    }


/* D X P  D I F F */
DxpDiff(dcpFirst, dcp, pdxpFirst)
int dcpFirst;
int dcp;
int *pdxpFirst;
{
#if 1
    register int *pdxp = &vfli.rgdxp[0];
    register int cch;
    int dxp = vfli.xpLeft;
#ifdef ENABLE   /* Not used */
    int ichLim = dcpFirst + dcp;
#endif


    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        //Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    for (cch = 0; cch < dcpFirst; ++cch)
        {
        dxp += *pdxp++;
        }
    *pdxpFirst = dxp;
    dxp = 0;
    for (cch = 0; cch < dcp; ++cch)
        {
        dxp += *pdxp++;
        }
    return dxp;
#else

    int dxp;
    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    /* first get space up to first character */
    *pdxpFirst = LOWORD(GetTextExtent(hDC,vfli.rgch,dcpFirst)) + vfli.xpLeft;

    /* now get space between first and first+dcp */
    dxp = LOWORD(GetTextExtent(hDC,vfli.rgch+dcpFirst,dcp));
    return dxp;
#endif
}


UpdateDisplay(fAbortOK)
int fAbortOK;
{
    int ww;

    if (wwMac <= 0)
        {
        return;
        }

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ww++)
        if ( rgwwd[ww].doc != docScrap )
            {
            UpdateWw(ww, fAbortOK);
            if (rgwwd[ww].fDirty || vfOutOfMemory)
                {
                return; /* update has been interrupted */
                }
            }
#else /* not CASHMERE */
    UpdateWw(wwDocument, fAbortOK);
    if (wwdCurrentDoc.fDirty || vfOutOfMemory)
        {
        /* Update has been interrupted */
        return;
        }
#endif /* not CASHMERE */

    if (wwdCurrentDoc.fRuler)
        {
        UpdateRuler();
        }
}


/* U P D A T E  W W */
UpdateWw(ww, fAbortOK)
int ww, fAbortOK;
{ /* Redisplay ww as necessary */
    extern int vfWholePictInvalid;
    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlOld, dlNew;
    int doc;
    int ichCp;
    struct EDL *pedlNew;
    register struct EDL *pedl;
    struct EDL (**hdndl)[]=pwwd->hdndl;
    int dypDiff;
    int ypTop;
    int ypFirstInval;
    int dr;
    int fLastNotShown;
    typeCP cp, cpMacWw;

    if (!pwwd->fDirty)
        {
        return;
        }

	if (!((**hpdocdod)[pwwd->doc].fDisplayable))
        return;

    if (fAbortOK && FImportantMsgPresent())
        return;

#if 0  // how to get first and last cp's in invalid rect?
#if defined(OLE)
    /* 
        Load visible objects.  Do it now rather than in DisplayGraphics()
        because here it has less chance of disrupting the state variables
        upon which UpdateWw depends.
    */
    ObjEnumInRange(docCur,cpMinCur,cpMacCur,ObjLoadObjectInDoc);
#endif
#endif

    dlMac = pwwd->dlMac;
    ypTop = pwwd->ypMin;

    Assert( ww >= 0 && ww < wwMax );
    vfli.doc = docNil;  /* An aid to Fast Insert */

    UpdateInvalid();    /* InvalBand for what Windows considers to be invalid */
    ypFirstInval = pwwd->ypFirstInval;

#ifndef CASHMERE
    Assert( ww == wwCur );  /* A MEMO-only assumption */
#endif /* CASHMERE */

    Scribble(5, 'U');

    ValidateMemoryDC();      /* to do any update, we need a good memory DC */
    if (vhMDC == NULL)
        {
        WinFailure();
        return;
        }

    doc = pwwd->doc;
    vfli.doc = docNil;

    if (pwwd->fCpBad)
        {
/* cp first displayed has not been blessed */

#ifdef CASHMERE     /* Must do this if ww != wwCur assertion is FALSE */
        int wwT = wwCur;
        if (ww != wwCur && wwCur >= 0)
/* CtrBackTrs cache is only good for wwCur. Treat != case */
            {
            if (pwwdCur->fDirty) /* Do wwCur first, saving cache */
                UpdateWw(wwCur, fAbortOK);

            if (fAbortOK && FImportantMsgPresent())
                return;

            ChangeWw(ww, false);
            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            ChangeWw(wwT, false);
            }
        else
#endif /* CASHMERE */

            {
            if (fAbortOK && FImportantMsgPresent())
                return;

            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            }
        }

/* check for cpMin accessible in this ww */
RestartUpdate:
    vfWholePictInvalid = fTrue; /* Tells DisplayGraphics to
                                   abandon accumulated partial pict rect */
    fLastNotShown = fFalse;
    cp = CpMax(pwwd->cpMin, pwwd->cpFirst);
    cpMacWw = pwwd->cpMac;
    ichCp = pwwd->ichCpFirst;

        /* Note test for dlNew==0 that guarantees that there will be at least
           one dl -- this was added for WRITE because we do not have
           the ability to enforce a minimum window size */

    for (dlNew = dlOld = 0; ypTop < pwwd->ypMac || (dlNew == 0) ; dlNew++)
        /* we have: cp, ichCP: pints to text desired on the coming line dlNew
         ypTop: desired position for top of dlNew -1
         dlOld: next line to be considered for re-use
        */
        /* check for having to extend dndl array */
        {
        if (dlNew >= (int)pwwd->dlMax)
            {
/* extend the array with uninitialized dl's, increment max, break if no space.
We assume that dlMac(Old) was <= dlMax, so the dl's will not be looked at
but used only to store new lines */
#define ddlIncr 5

            if (!FChngSizeH(hdndl, (pwwd->dlMax + ddlIncr) * cwEDL, fFalse))
                break;
            pwwd->dlMax += ddlIncr;
            }
/* discard unusable dl's */
        for (; dlOld < dlMac; dlOld++)
            { /* Set dlOld and pedl to the next good dl */
            int ypTopOld, ypOld;

                /* Re-entrant Heap Movement */
            if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
                goto RetInval;

            pedl = &(**hdndl)[dlOld];
            ypOld = pedl->yp;

/* loop if: invalid, passed over in cp space, passed over in dl space,
passed over in yp space,
in invalid band, passed over in ich space */
            if (!pedl->fValid || dlOld < dlNew || pedl->cpMin < cp
                || (ypTopOld = (ypOld - pedl->dyp)) < ypTop
                || (ypOld >= ypFirstInval && ypTopOld <= pwwd->ypLastInval)
                || (pedl->cpMin == cp && pedl->ichCpMin < ichCp))
                continue;
/* now we have dlOld, an acceptable if not necessarily useful dl.
now compute dlNew either from scratch or by re-using dlOld. To be
re-useable, dlOld must have right cp/ichCp pair, plus be totally on screen
or, if it is a partial line, it must stay still or move down - not up */
            if (pedl->cpMin == cp && pedl->ichCpMin == ichCp &&
                (ypOld <= pwwd->ypMac || ypTopOld <= ypTop))
                {
/* Re-use this dl */
                int yp = ypTop;
                if (fLastNotShown)
                    {
                        /* HEAP MOVEMENT */
                    DisplayFli(ww, dlNew - 1, fLastNotShown = fFalse);
                    pedl = &(**hdndl)[dlOld];
                    }

                cp = pedl->cpMin + pedl->dcpMac;
                ichCp = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                ypTop += pedl->dyp;
                if (dlOld != dlNew || ypTopOld != yp)
                    {
                    DypScroll(ww, dlOld, dlNew - dlOld, yp);
                    if (vfScrollInval)
                        {
                        /* There was a popup; invalid region might have changed */
                        /* fLastNotShown test is for interrupting picture display */
                        /* before we've really displayed it */

                        (**hdndl) [dlOld].fValid = fFalse;
                        goto Restart1;
                        }
                    dlMac += dlNew - dlOld;
                    }
                dlOld = dlNew + 1;
                goto NextDlNew;
                }
            break;
            }
/* cpMin > cp, the line is not anywhere so it will have to be formatted
from scratch */

        if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
            goto RetInval;

        FormatLine(doc, cp, ichCp, cpMacWw, flmSandMode);  /* Creates vfli */

    if (vfOutOfMemory)
            goto RetInval;

        ichCp = vfli.ichCpMac;
        cp = vfli.cpMac;
/* advance invalid band so that update can resume after an interruption */
        pwwd->ypFirstInval = (ypTop += vfli.dypLine);
        pedl = &(**hdndl)[dlOld];
        if (dlOld < dlMac && pedl->cpMin == cp && pedl->ichCpMin == ichCp)
            {
            int dlT = dlOld;

/* line at dlOld is a valid, existing line that will abutt the line just about
to be displayed. */
            if (dlOld == dlNew && pedl->yp - pedl->dyp <= ypTop)
/* the line about to be overwritten will be re-used in the next loop.
Hence, it is worthwhile to save this line and its dl */
                DypScroll(ww, dlOld++, 1, ypTop);
            else
/* Move the next line to its abutting position. We know that it has not yet been
overwritten (yp, dlOld all > than ypTop, dlNew) */
                DypScroll(ww, dlOld, 0, ypTop);

            if (vfScrollInval)
                {
                /* There was a popup; invalid region might have changed */
                /* fLastNotShown test is for interrupting picture display */
                /* before we've really displayed it */

                (**hdndl) [dlT].fValid = fFalse;
Restart1:
                if (fLastNotShown)
                    {
                    pwwd->ypFirstInval = pwwd->ypMin;
                    }

                ypFirstInval = pwwd->ypFirstInval;
                ypTop = pwwd->ypMin;
                goto RestartUpdate;
                }
            }

/* true in 3rd param means put off picture redisplay till later */
/* condition: graphics & not last in picture & not last in y space and
not in front of a invalid or valid transition in the picture */
        DisplayFli(ww, dlNew, fLastNotShown = 
                  (vfli.fGraphics && vfli.ichCpMac!=0 && ypTop < pwwd->ypMac));
NextDlNew:;
        }
Break1:
    pwwd->dlMac = dlNew;

#ifdef CASHMERE
/* condition is here to avoid swapping */
    if (pwwd->fSplit && rgwwd[pwwd->ww].fFtn)
        CalcFtnLimits(pwwd);
#endif /* CASHMERE */

    SetCurWwVScrollPos();    /* Set Scroll bar position */
    vfTextBltValid = false;

/* reset invalid indications */
    pwwd->fDirty = false;
    pwwd->ypFirstInval = ypMaxAll;
    pwwd->ypLastInval = 0; /* so that max in InvalBand will work */
    Scribble(5, ' ');
    goto Validate;

/* Before returning from an interrupt, invalidate lines that were overwritten
within the present update. */
RetInval:
    Scribble(5, ' ');
    for (; dlOld < dlMac; dlOld++)
        {
        pedl = &(**hdndl)[dlOld];
        if ((pedl->yp - pedl->dyp) < ypTop)
            pedl->fValid = fFalse;
        else
            break;
        }
Validate: ;

#ifdef ENABLE   /* We will let UpdateInvalid handle this in case
                   further invalidation occurred during the update */

    {           /* Tell Windows that the part we updated is valid */
    RECT rc;

    rc.left = 0;
    rc.top = pwwd->ypMin;
    rc.right = pwwd->xpMac;
    rc.bottom = imin( pwwd->ypMac, ypTop );
    ValidateRect( pwwd->wwptr, (LPRECT)&rc );
    }
#endif
}




/* D Y P  S C R O L L */
DypScroll(ww, dlFirst, ddl, ypTo)
int ww, dlFirst, ddl, ypTo;
{
/* Scroll dl's in a window, from dlFirst to end, down ddl lines (or up -ddl).
Bitmap is moved from top of dlFirst to ypTo.   The yp's of the dl's are updated.
Returns the amount scrolled. (positive means down). */

    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlT;
    int ypFrom;
    int dypChange;
    int cdlBelow;
    struct EDL *pedl;
    struct EDL *pedlT;

    /* Do not call procedures while dndl is loaded up to avoid heap movement */
    struct EDL *dndl = &(**(pwwd->hdndl))[0];

    Assert( ww >= 0 && ww < wwMax );

    vfScrollInval = fFalse;

    /* Number of dl's below (and including) the first one to be scrolled */
    cdlBelow = pwwd->dlMac - dlFirst;
    pwwd->dlMac = min(pwwd->dlMac + ddl, pwwd->dlMax);
    cdlBelow = max(0, min(cdlBelow, pwwd->dlMac - ddl - dlFirst));

    pedlT = &dndl[dlFirst];
    ypFrom = pedlT->yp - pedlT->dyp;

    /* Length of area to be moved */
    dypChange = ypTo - ypFrom;

    if (cdlBelow > 0)
        {
        int dlTo = dlFirst + ddl;
        int ypMac = pwwd->ypMac;

        pedlT = &dndl[dlTo];
        if (ddl != 0)
            {
            blt(&dndl[dlFirst], pedlT, cwEDL * cdlBelow);
            }

        for (dlT = dlTo; dlT < pwwd->dlMac; ++dlT, ++pedlT)
            {
            if (dypChange < 0 && pedlT->yp > ypMac)
                {
                /* Invalidate dl's that are pulled in from the ozone below ypMac
                */
                pedlT->fValid = fFalse;
                }
            else
                {
                pedlT->yp += dypChange;
                }
            }
        }

    if (dypChange != 0)
        {
        RECT rc;

        SetRect( (LPRECT)&rc, 0, min(ypFrom, ypTo),
                              pwwd->xpMac, pwwd->ypMac );
        Assert( ww == wwCur );      /* A MEMO-only assumption */
        ScrollCurWw( &rc, 0, dypChange );
        }

    return dypChange;
}




FImportantMsgPresent()
{
    /*  If the next message is important enough to interrupt a screen update, we
        return TRUE; if it can wait, we return FALSE */

    BOOL fToggledKey;
    extern MSG vmsgLast;

#ifdef DEBUG
    unsigned wHeapVal = *(pLocalHeap + 1);

    Assert( wHeapVal == 0 );   /* Heap should not be frozen */
#endif

#ifdef DBCS
 if( donteat )
     return TRUE;
#endif

while (PeekMessage((LPMSG) &vmsgLast, NULL, NULL, NULL, PM_NOREMOVE))
    {

    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
    {
        if (vmsgLast.wParam == VK_CONTROL)
        {
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            SetShiftFlags();
        }
        return TRUE;
    }
    /* Filter uninteresting or easily handled events */
    else if (fToggledKey = FCheckToggleKeyMessage(&vmsgLast) || 
       (vmsgLast.message == WM_KEYUP && vmsgLast.hwnd == wwdCurrentDoc.wwptr))
        {

        /* This is so the Windows keyboard interface mechanism will see toggle
        key and key-up transitions */
        GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
#ifdef WIN30        
        /* PeekMessage has been changed in Win 3.0 so that GetKeyState()
           called from FCheckToggleKeyMessage() is really only valid if 
           you've done a PeekMessage(...,PM_REMOVE) or GetMessage() first.
           That is, while the FCheckToggleKeyMessage() call might succeed
           above, it will NOT have set the vfShiftKey/vfCommandKey flags
           correctly -- so we do it here ..pault */
        if (fToggledKey)
            FCheckToggleKeyMessage(&vmsgLast);
#endif
        if (vmsgLast.hwnd != wwdCurrentDoc.wwptr)
            {
            /* Just in case a modeless dialog's window proc cares */
            TranslateMessage((LPMSG)&vmsgLast);
            DispatchMessage((LPMSG)&vmsgLast);
            }
#ifdef DBCS
#ifdef KOREA	      /* 90.12.23 by sangl */	// jinwoo: 92, 9, 28
        if (vmsgLast.message == WM_CHAR || vmsgLast.message == WM_KEYDOWN
                || vmsgLast.message == WM_INTERIM) {
#else  /* KOREA */
        if (vmsgLast.message == WM_CHAR || vmsgLast.message == WM_KEYDOWN ) {
#endif  //KOREA   920525 KDLEE;  jinwoo: 92, 9, 28
            donteat = TRUE;
            return( TRUE );
        } /* else Ok, you are KEYUP message. do normal */
#endif
        }
    else
        {
        switch (vmsgLast.message)
            {
        case WM_MOUSEMOVE:
            /* Process mouse move messages immediately; they are not really
            important.  NOTE: This assumes that we have not captured all mouse
            events; in which case, they are important. */
            DispatchMessage((LPMSG)&vmsgLast);

        case WM_TIMER:
        case WM_SYSTIMER:
            /* Remove timer and mouse move messages from the queue. */
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            break;

        default:
            Assert( *(pLocalHeap+1) == 0 ); /* Heap should still not be frozen */
            return (TRUE);
            }
        }
    }


Assert( *(pLocalHeap + 1) == 0 );   /* Heap should still not be frozen */
return (FALSE);
}


/* C P  B E G I N  L I N E */
typeCP CpBeginLine(pdl, cp)
int *pdl;
typeCP cp;
    { /* return the cp and dl containing cp */
    int dlMin, dlLim;
    typeCP cpGuess;
    struct EDL *dndl;

    do
        {
        UpdateWw(wwCur, false);
        PutCpInWwVert(cp); /* Ensure cp on screen */
        } while (pwwdCur->fDirty && !vfOutOfMemory);

    dndl = &(**(pwwdCur->hdndl))[0];
    dlMin = 0;
    dlLim = pwwdCur->dlMac;
    while (dlMin + 1 < dlLim)
        { /* Binary search the ww */
        int dlGuess = (dlMin + dlLim) >> 1;
        struct EDL *pedl = &dndl[dlGuess];
        if ((cpGuess = pedl->cpMin) <= cp && (cpGuess != cp || pedl->ichCpMin == 0))
            { /* guess is low or right */
            dlMin = dlGuess;
            if (cp == cpGuess && pedl->cpMin + pedl->dcpMac != cp)
                break;  /* Got it right */
            }
        else  /* Guess is high */
            dlLim = dlGuess;
        }
    *pdl = dlMin;
    return dndl[dlMin].cpMin;
}




/* T O G G L E  S E L */
ToggleSel(cpFirst, cpLim, fOn)
typeCP cpFirst, cpLim; /* selection bounds */
int fOn;
{ /* Flip selection highlighting on and off */
    extern int vfPMS;
    struct EDL *pedl;
    int dlT;
    int xpMin;
    int dxpRoom;
    int xpFirst;
    int xpLim;
    int fInsertPoint = (cpFirst == cpLim);

    if (vfSelHidden || cpFirst > cpLim || cpLim < /*cp0*/ cpMinCur || vfDead)
        return;

    if ( vfPictSel && vfPMS &&
         (CachePara( docCur, cpFirst ), vpapAbs.fGraphics) &&
         (vcpLimParaCache == cpLim) )
        {   /* Don't show inversion if we're moving or sizing a picture */
        return;
        }

    dxpRoom = pwwdCur->xpMac - xpSelBar;
    xpMin = pwwdCur->xpMin;

    for (dlT = 0; dlT < pwwdCur->dlMac; dlT++)
        {
        typeCP cpMin, cpMac; /* line bounds */
        pedl = &(**(pwwdCur->hdndl))[dlT];
        if (!pedl->fValid)
            continue;
        cpMin = pedl->cpMin;
        if (cpMin > cpLim || cpMin > cpMacCur || (cpMin == cpLim && cpLim != cpFirst))
            break;
        cpMac = cpMin + pedl->dcpMac;
        if (cpFirst <= cpMin && cpLim >= cpMac)
            {
/* entire line is highlighted */
            xpFirst = pedl->xpLeft;
            if (pedl->fGraphics && cpLim == cpMac && cpMin == cpMac)
                /* Special kludge for graphics paras */
                xpLim = xpFirst;
            else
                xpLim = pedl->xpMac;
            }
        else if (fInsertPoint && cpFirst == cpMac && vfInsEnd)
            { /* Special kludge for an insert point at the end of a line */
            xpLim = xpFirst = pedl->xpMac;
            }
        else if (cpFirst < cpMac)
            {
            /* Bite the bullet */
            int dxp;
            typeCP  cpBegin = CpMax(cpMin, cpFirst);
            typeCP  cpEnd = CpMin(cpMac, cpLim);

            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            dxp = DxpDiff((int) (cpBegin - cpMin),
                (int) (cpEnd - cpBegin), &xpFirst);
            xpLim = xpFirst + dxp;
/* reload pedl because procedures were called */
            pedl = &(**(pwwdCur->hdndl))[dlT];
            }
        else
            continue;
/* now we have: pedl valid, xpFirst, xpLast describe highlight */
         /* xpFirst = max(xpFirst, xpMin); */
        xpLim = min(xpLim, xpMin + pedl->xpMac);
        if (xpLim > xpFirst)
            {
            if (xpLim > xpMin)
                {
                RECT rc;
                rc.top = pedl->yp - pedl->dyp;
                rc.left = xpSelBar + max(xpFirst - xpMin, 0);
                rc.bottom = pedl->yp;
                rc.right = xpSelBar + xpLim - xpMin;
                InvertRect( wwdCurrentDoc.hDC, (LPRECT)&rc);
                }
            }
/* ToggleSel modified 7/28/85 -- added explicit check for fInsertPoint, since
   the xpLim == xpFirst test sometimes succeeded bogusly when a selection
   was extended backwards. BL */
        else if (fInsertPoint && (xpLim == xpFirst))     /* Insertion point */
            {
            /* vfli should usually be cached already, so will be fast. */
            int yp = pedl->yp;
            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            if (fOn ^ vfInsertOn)
                {
                if (!vfInsertOn)
                    {
                    vxpCursLine = xpSelBar + xpFirst - xpMin;
                    vypCursLine = yp - vfli.dypAfter;
                    vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);

                        /* Start blinking in a while */
                    vfSkipNextBlink = TRUE;
                    }
                DrawInsertLine();
                }
            return;
            }
        }
}




/* T R A S H  W W */
TrashWw(ww)
{ /* Invalidate all dl's in ww */
    Assert( ww >= 0 && ww < wwMax );
    InvalBand(&rgwwd[ww], 0, ypMaxAll);
}




/* I N V A L  B A N D */
/* invalidate the band ypFirst, ypLast inclusive */
InvalBand(pwwd, ypFirst, ypLast)
struct WWD *pwwd; int ypFirst, ypLast;
    {
/* this covers some peculiar rects received from update event after a
window resize by 1 pixel. CS */
    if (ypLast < 0 || ypFirst == ypLast) return;

    pwwd->fDirty = true;
    pwwd->ypFirstInval = min(pwwd->ypFirstInval, ypFirst);
    pwwd->ypLastInval = max(ypLast, pwwd->ypLastInval);
    }




/* T R A S H  A L L  W W S */
TrashAllWws()
{ /* trash them all */
    int     ww;

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ++ww)
        TrashWw(ww);
#else
    TrashWw( wwDocument );
#endif
    vfli.doc = docNil;  /* Mark vfli invalid */
}


/* T U R N  O F F  S E L */
TurnOffSel()
{ /* Remove sel highlighting from screen */
/* HideSel has no effect */
    if (!vfSelHidden)
        {
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfSelHidden = true;
        }
}


/* D R A W  I N S E R T  L I N E */
DrawInsertLine()
{       /* Draw (in Xor mode) a vertical bar at screen position v*CursLine */
        /* Toggles both the display and the vfInsertOn flag */
        /* Adjustments in cursor draw must be reflected in DisplayFli, above */

            /* Last-minute correction for a bug: assure that the insert line
               does not extend above ypMin */
        if (!vfInsertOn && vdypCursLine > vypCursLine - wwdCurrentDoc.ypMin)
            vdypCursLine = vypCursLine - wwdCurrentDoc.ypMin;

            /* Tell GDI to invert the caret line */
        PatBlt( wwdCurrentDoc.hDC, vxpCursLine, vypCursLine - vdypCursLine,
                      2, vdypCursLine , DSTINVERT );
        vfInsertOn = 1 - vfInsertOn;
}




/* C L E A R  I N S E R T  L I N E */
ClearInsertLine()
{
 if ( vfInsertOn) DrawInsertLine();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\dlgdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the definition of the numerical indexes to the dialog
items (idi) used by Windows Memo. */
/* IDOK and IDCANCEL are defined in windows.h
   windows dialog manager returns :
   IDOK if the <Return> key is hit
   IDCANCEL if the <ESC> key is hit
   As a rule, the default button should be assigned idiOk
*/

#define idiNil                  -1

#define idiOk                   IDOK
#define idiCancel               IDCANCEL
#define idiYes                  IDYES
#define idiNo                   IDNO

#ifndef NOIDISAVEPRINT      /* Another tool to avoid compiler heap overflow */
#define idiAbort                idiOk
#define idiRetry                3
#define idiIgnore               idiCancel
#define idiMessage              4

#define idiSavDir               3
#define idiSavFile              4
#define idiSavBackup            5
#define idiSavTextOnly          6
#define idiSavWordFmt           7
#define idiSavDirLB             8

#define idiOpenDir              3
#define idiOpenFile             4
#define idiOpenFileLB           5
#define idiOpenDirLB            6

#define idiPrterName            3
#define idiPrterSetup           4
#define idiRepageConfirm        3

#define idiGtoPage              3

#define idiPrtAll               6
#define idiPrtFrom              7
#define idiPrtPageFrom          8
#define idiPrtPageTo            9
#define idiPrtCopies            10
#define idiPrtDraft             11
#define idiPrtDest      12

#define idiPrCancelName    100     /* For the filename in CancelPrint dlg */

/* interactive repaginating */
#define idiKeepPgMark           idiOk
#define idiRemovePgMark         4
#define idiRepUp                5
#define idiRepDown              6

#endif  /* NOIDISAVEPRINT */

#ifndef NOIDIFORMATS
#define idiChrFontName          3
#define idiChrLBFontName        4
#define idiChrFontSize          5
#define idiChrLBFontSize        6

#define idiParLfIndent          3
#define idiParFirst             4
#define idiParRtIndent          5
/*#define idiParLineSp          6
#define idiParSpBefore          7
#define idiParSpAfter           8
#define idiParLeft              9
#define idiParCentered          10
#define idiParRight             11
#define idiParJustified         12
#define idiParKeepNext          13
#define idiParKeepTogether      14 */

#define idiTabClearAll          3
#define idiTabPos0              4
#define idiTabPos1              5
#define idiTabPos2              6
#define idiTabPos3              7
#define idiTabPos4              8
#define idiTabPos5              9
#define idiTabPos6              10
#define idiTabPos7              11
#define idiTabPos8              12
#define idiTabPos9              13
#define idiTabPos10             14
#define idiTabPos11             15
#define idiTabDec0              16
#define idiTabDec1              17
#define idiTabDec2              18
#define idiTabDec3              19
#define idiTabDec4              20
#define idiTabDec5              21
#define idiTabDec6              22
#define idiTabDec7              23
#define idiTabDec8              24
#define idiTabDec9              25
#define idiTabDec10             26
#define idiTabDec11             27

#define idiRHInsertPage         3
#define idiRHClear              4
#define idiRHDx                 5
#define idiRHFirst              6
#define idiRHDxText             7
#define idiRHLines              8

#define idiDivPNStart           3
#define idiDivLMarg             4
#define idiDivRMarg             5
#define idiDivTMarg             6
#define idiDivBMarg             7

#ifdef INTL

#define idiDivInch              8
#define idiDivCm                9

#endif   /* INTERNATIONAL */


#endif  /* NOIDIFORMATS */

#define idiFind                 7
#define idiChangeThenFind       9
#define idiChange               3
#define idiChangeAll            4

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
#define idiDistinguishDandS             10
#endif

#define idiWholeWord            5
#define idiMatchCase            6
#define idiFindNext             idiOk
#define idiChangeTo             8

#define idiHelp                 3
#define idiHelpTopics           3
#define idiHelpNext             4
#define idiHelpPrev             5
#define idiHelpName             6
#define idiMemFree              7
#define idiHelpScroll           8

#define idiBMrgLeft             3
#define idiBMrgRight            4
#define idiBMrgTop              5
#define idiBMrgBottom           6

#define idiConvertPrompt    99

#ifdef JAPAN                  // added  09 Jun. 1992  by Hiraisi
#define idiChangeFont    101
#endif

/* Dialog Box ID's (substitite for Template Name strings) */

#define dlgOpen                 1
#define dlgSaveAs               2
/* #define dlgSaveScrap            3 */

  /* dlgWordCvt takes the position of the commented out Save Scrap box */
#define dlgWordCvt              3

#define dlgHelp                 4
#define dlgHelpInner            22
#define dlgPrint                5
#define dlgCancelPrint          6
#define dlgRepaginate           7
#define dlgCancelRepage         8
#define dlgSetPage              9
#define dlgPageMark             10
#define dlgPrinterSetup         11
#define dlgFind                 12
#define dlgChange               13
#define dlgGoTo                 14
#define dlgCharFormats          15
#define dlgParaFormats          16
#define dlgRunningHead          17
#define dlgFooter               18
#define dlgTabs                 19
#define dlgDivision             20
#define dlgBadMargins           21

#ifdef JAPAN                  // added  09 Jun. 1992  by Hiraisi
#define dlgChangeFont           23
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\dispdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Originally, this file contained nothing but screen constants, but these
constants had to become variables to account for all different display devices.
*/

/* size of lines for dnMax estimation purposes */
extern int dypAveInit;

/* width of the selection bar area to the left of lines */
extern int xpSelBar;

extern int dxpScrlBar;
extern int dypScrlBar;
extern int dxpInfoSize;

#define xaRightMax 31680
extern int xpRightMax;
extern int xpMinScroll;
extern int xpRightLim;

/* these define the initial window size and amount of white space above
the first line */
extern int ypMaxWwInit;

/* should be > than largest window height + height of blank line after
the endmark */
extern int ypMaxAll;            /* used for invalidation */
extern int dypWwInit;

extern int dypBand;             /* formerly dpxyLineSizeMin */

extern int dypRuler;

extern int ypSubSuper;

/* number of quanta in elevator control */
#define drMax           256

#define ctcAuto         10
#define ctrAuto         4

#define cxpAuto         72


/* DL structure revised, 3 Sept KJS, CS */
/*                      14 Nov 89 ..pault  (changed dcpMac from int to 
                                            typeCP because we experienced
                                            wraparound when sizing large
                                            graphics objects) */
struct EDL
        {
        unsigned char           dcpDepend : 8;
        unsigned char           ichCpMin : 8;
        unsigned                fValid : 1;
#ifdef CASHMERE
        unsigned                fStyleInfo : 1;
#else
        unsigned                fSplat: 1;
#endif
        unsigned                fGraphics : 1;
        unsigned                fIchCpIncr : 1;
        unsigned                xpLeft : 12;
        typeCP                  dcpMac;         /* representing cpMac */
        typeCP                  cpMin;
        int                     xpMac;
        int                     dyp;            /* height of the dl */
        int                     yp;             /* position of the dl */
        };

#define cchEDL          (sizeof (struct EDL))
#define cwEDL           (cchEDL / sizeof(int))

#define cedlInit        20

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\doprm.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* doprm.c -- MW Property modifying routines */
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NOATOM
#define NOMETAFILE
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOPEN
#define NOBITMAP
#define NOCOLOR
#define NODRAWTEXT
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NORESOURCE
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "macro.h"
#include "dispdefs.h"
#include "fontdefs.h"

/* E X T E R N A L S */
extern int		rgxaRulerSprm[];
extern struct PAP	*vppapNormal;
extern struct CHP	vchpNormal;
extern CHAR		dnsprm[];
extern struct CHP      vchpNormal;
extern struct SEP      vsepStd;
extern struct SEP      vsepNormal;

#ifdef CASHMERE
extern struct TBD	rgtbdRulerSprm[];
#endif

/* List of approved font sizes, in half points */
#ifdef INTL
int rghps[csizeApprovedMax] = {8, 12, 16, 20, 24, 28, 36, 48, 60, 72, 96, 144, 254};
#else
int rghps[csizeApprovedMax] = {8, 12, 16, 20, 24, 32, 40, 48, 60, 72, 96, 144, 254};
#endif /* if-else-def INTL */

CHAR *PchFromFc();


/* D O	P R M */
DoPrm(struct CHP *pchp, struct PAP *ppap, struct PRM prm)
	{ /* Apply prm to char and para properties */
	if (bPRMNIL(prm))
		return;
	if (((struct PRM *) &prm)->fComplex)
		{
		int	cch;
		CHAR	*pfsprm;
		struct FPRM *pfprm = (struct FPRM *) PchFromFc(fnScratch,
			fcSCRATCHPRM(prm), &cch);

		cch = pfprm->cch;
		pfsprm = pfprm->grpfsprm;

		while (cch > 0)
			{
			int cchT;
			int sprm;

			DoSprm(pchp, ppap, sprm = *pfsprm, pfsprm + 1);
			if ((cchT = (dnsprm[sprm] & ESPRM_cch)) == 0)
				cchT = CchPsprm(pfsprm);
			cch -= cchT;
			pfsprm += cchT;
			}
		}
	else
/* Simple prm; single sprm */
		DoSprm(pchp, ppap, ((struct PRM *) &prm)->sprm,
				&((struct PRM *) &prm)->val);
}

/* D O	S P R M */
/* Apply a single property modifier to para/char prop */
DoSprm(pchp, ppap, sprm, pval)
struct CHP *pchp;
struct PAP *ppap;
int	    sprm;
CHAR	   *pval;
	{
	int *pvalTo;
	int val = *pval;

#ifdef DEBUG
	Assert(sprm > 0 && sprm < sprmMax);
#endif
	if ((dnsprm[sprm] & ESPRM_sgc) != sgcChar)
		{
		if (ppap != 0)
			{
			struct TBD *ptbd;
			int rhc;
			int fGraphics;

			ppap->fStyled = fFalse;
			switch (sprm)
				{
			case sprmPLMarg:
				pvalTo = &ppap->dxaLeft;
				break;
			case sprmPRMarg:
				pvalTo = &ppap->dxaRight;
				break;
			case sprmPFIndent:
				pvalTo = &ppap->dxaLeft1;
				break;
			case sprmPJc:
				ppap->jc = val;
				return;
#ifdef CASHMERE
			case sprmPRuler:
/* Ruler and Ruler1 rely on the fact that rgxaRulerSprm and PAP both
align R, L, L1 in that order.
Ruler: apply the current state of the ruler */
				blt(&rgxaRulerSprm[0], &ppap->dxaRight, 3);
				blt(&rgtbdRulerSprm[0], ppap->rgtbd, itbdMax * cwTBD);
				return;
			case sprmPRuler1:
/* as Ruler, except information is at pval+1 and pval+"7" */
				bltbyte((CHAR *)(pval + 1), &ppap->dxaRight, 3 * cchINT);
/* append terminating 0 word to tab table */
				bltc(bltbyte((CHAR *)(pval + 1 + (3 * cchINT)), ppap->rgtbd,
					val - (3 * cchINT)), 0, cchINT);
				return;
			case sprmPRgtbd:
				bltc(bltbyte(pval + 1, ppap->rgtbd,
					val), 0, cchINT);
				return;
			case sprmPKeep:
				ppap->fKeep = val;
				return;
			case sprmPKeepFollow:
				ppap->fKeepFollow = val;
				return;
#endif
			case sprmPDyaLine:
				pvalTo = &ppap->dyaLine;
				break;
#ifdef CASHMERE
			case sprmPDyaBefore:
				pvalTo = &ppap->dyaBefore;
				break;
			case sprmPDyaAfter:
				pvalTo = &ppap->dyaAfter;
				break;
#endif
			case sprmPRhc:
				ppap->rhc = val;
				return;
			case sprmPRhcNorm:
				/* (int) dxaLeftAdj + (int) dxaRightAdj */
				Assert(*pval == 4);
				pval++; /* skip over cch */
				ppap->dxaLeft = imax( 0,
					 ppap->dxaLeft - *(int *) pval);
				ppap->dxaRight = imax( 0,
					 ppap->dxaRight - *((int *) pval + 1));
				return;
			case sprmPNormal:
				rhc = ppap->rhc;
				fGraphics = ppap->fGraphics;
				blt(vppapNormal, ppap, cwPAPBase);
				goto LSame;
			case sprmPSame:
				rhc = ppap->rhc;
				fGraphics = ppap->fGraphics;
/* note: tab terminating 0 MUST be part of value if tab table is to be changed */
				bltbyte(pval + 1, ppap, val - 1);
LSame:				ppap->rhc = rhc;
				ppap->fGraphics = fGraphics;
				return;
#ifdef CASHMERE
			case sprmPNest:
				if (ppap->rgtbd[0].dxa != 0 &&
				    ppap->rgtbd[0].dxa == ppap->dxaLeft &&
				    ppap->rgtbd[1].dxa == 0)
					ppap->rgtbd[0].dxa += dxaNest;
				ppap->dxaLeft += dxaNest;
				return;
			case sprmPUnNest:
				if (ppap->rgtbd[0].dxa != 0 &&
				    ppap->rgtbd[0].dxa == ppap->dxaLeft &&
				    ppap->rgtbd[1].dxa == 0)
					ppap->rgtbd[0].dxa -= dxaNest;
				ppap->dxaLeft = max(0, (int)(ppap->dxaLeft - dxaNest));
				return;
			case sprmPHang:
				ppap->dxaLeft = umin(ppap->dxaLeft + cxaInch, xaRightMax - cxaInch);
				ppap->dxaLeft1 = -cxaInch;
				ptbd = &ppap->rgtbd[0];
				SetWords(ptbd, 0, cwTBD * 2);
				ptbd->dxa = ppap->dxaLeft;
				/* Inefficient:
				ptbd->tlc = tlcWhite;
				ptbd->jc = jcLeft;
				++ptbd->dxa = 0 */
				return;
#endif
			default:
				Assert(FALSE);
				return;
				}
	/* common portion for those transferring a single word */
			bltbyte(pval, pvalTo, cchINT);
			}
		return;
		}
	else
		{
		if (pchp != 0)
			{
			int fSpecial;
			int ftc, hps;

			pchp->fStyled = fFalse;
			switch (sprm)
				{
			/* CHARACTER sprm's */
			case sprmCBold:
				pchp->fBold = val;
				return;
			case sprmCItalic:
				pchp->fItalic = val;
				return;
			case sprmCUline:
				pchp->fUline = val;
				return;
#ifdef CASHMERE
			case sprmCOutline:
				pchp->fOutline = val;
				return;
			case sprmCShadow:
				pchp->fShadow = val;
				return;
			case sprmCCsm:
				pchp->csm = val;
				return;
#endif
			case sprmCPos:
		/* If going in or out of sub/superscript, alter font size */
				if (pchp->hpsPos == 0 && val != 0)
					pchp->hps = HpsAlter(pchp->hps, -1);
				else if (pchp->hpsPos != 0 && val == 0)
					pchp->hps = HpsAlter(pchp->hps, 1);
				pchp->hpsPos = val;
				return;
			case sprmCFtc:
			case sprmCChgFtc:
				pchp->ftc = val & 0x003f;
				pchp->ftcXtra = (val & 0x00c0) >> 6;
				return;
			case sprmCHps:
				pchp->hps = val;
				return;
			case sprmCChgHps:
				pchp->hps = HpsAlter(pchp->hps,
					val >= 128 ? val - 256 : val); /* sign extend from char to int */
				return;
			case sprmCSame:
				fSpecial = pchp->fSpecial;
				bltbyte(pval, pchp, cchCHP);
				pchp->fSpecial = fSpecial;
				return;
			case sprmCPlain:
				fSpecial = pchp->fSpecial;
				ftc = FtcFromPchp(pchp);
				hps = pchp->hps;
		/* If we used to be sub/superscript, increase font size */
				if (pchp->hpsPos != 0)
					hps = HpsAlter(hps, 1);
				blt(&vchpNormal, pchp, cwCHP);
				pchp->fSpecial = fSpecial;
				pchp->ftc = ftc & 0x003f;
				pchp->ftcXtra = (ftc & 0x00c0) >> 6;
				pchp->hps = hps;
				return;
			case sprmCMapFtc:
				/* val is ftcMac for mapping */
				/* pval+1 points to ftcMac mapping bytes */
				ftc = pchp->ftc + (pchp->ftcXtra << 6);
				Assert(ftc < val);
				ftc = *(pval + 1 + ftc);
				pchp->ftc = ftc & 0x003f;
				pchp->ftcXtra = (ftc & 0x00c0) >> 6;
				return;
			case sprmCOldFtc:
				ftc = pchp->ftc + (pchp->ftcXtra << 6);
				ftc = FtcMapOldFtc(ftc, pval);
				pchp->ftc = ftc & 0x003f;
				pchp->ftcXtra = (ftc & 0x00c0) >> 6;
				return;
			default:
				Assert(FALSE);
				return;
				}
			}
		}
}

/* C C H  P S P R M */
/* returns length of sprm's that are of variable or large size.
(cch = (esprm & ESPRM_cch)) == 0 must be checked before calling.*/
CchPsprm(psprm)
CHAR *psprm;
{
	return (*psprm == sprmCSame ? cchCHP + 1 :
/* PSame, PRgtbd, PRuler1, CMapFtc, COldFtc: */
		*(psprm + 1) + 2);
}

int HpsAlter(hps, ialter)
int	hps, ialter;
{	/* Return the hps of the approved font size that is ialter steps
		away from the given size. I.e.: if ialter is -1, then return
		the next smaller size. If alter is 0, return hps.  */
        /* return 0 if request exceeds limits (11.15.91) v-dougk */
int isize;

if (ialter == 0)
	return hps;

/* Find the size just larger than the given size. */
if (ialter > 0)
	{
	    for (isize = 0; isize < csizeApprovedMax - 1; ++isize)
		    if (rghps[isize] > hps) break;
	    isize = min(csizeApprovedMax - 1, isize + ialter - 1);
	    return max(hps, rghps[isize]);
	}
else
	{
	for (isize = 0; isize < csizeApprovedMax; ++isize)
		if (rghps[isize] >= hps) break;
	isize = max(0, isize + ialter);
	return min(hps, rghps[isize]);
	}
}

BOOL CanChangeFont(int howmuch)
{
    extern struct CHP vchpSel;
    extern struct SEL       selCur;
    int hps;

    if (selCur.cpFirst != selCur.cpLim)
        return TRUE;

    hps = HpsAlter(vchpSel.hps, howmuch);
    return ((hps <= rghps[csizeApprovedMax-1]) && 
            (hps >= rghps[0]));
}

FtcMapOldFtc(ftc, ftctb)
/* maps an old word font code into one of our selection */

int ftc;
CHAR *ftctb;
{
#ifdef WIN30
int iftc = iftcSwiss;   /* Default to SOMEthing! ..pault */
#else
int iftc ;
#endif

if (ftc == 8)
	/* helvetica */
	iftc = iftcSwiss;
else if (ftc < 16)
	iftc = iftcModern;
else if (ftc < 32)
	iftc = iftcRoman;
else if (ftc < 40)
	iftc = iftcScript;
else if (ftc < 48)
	iftc = iftcDecorative;
Assert(iftc < *ftctb);
return(*(ftctb + 1 + iftc));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\doc.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* doc.c -- MW document processing routines (non-resident) */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOHDC
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "editdefs.h"
#include "docdefs.h"
#include "fontdefs.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "str.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#define NOKCCODES
#include "ch.h"
#include "stcdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "macro.h"


extern struct DOD (**hpdocdod)[];
extern int     docMac;
extern int     docScrap;
extern int     docUndo;
#ifdef STYLES
#ifdef SAND
extern CHAR    szSshtEmpty[];
#else
extern CHAR    szSshtEmpty[];
#endif
#endif

/* E X T E R N A L S */
extern int docRulerSprm;
extern int              vfSeeSel;
extern struct SEP       vsepNormal;
extern struct CHP       vchpNormal;
extern int              docCur;
extern struct FLI       vfli;
extern int              vdocParaCache;
extern struct FCB       (**hpfnfcb)[];
extern struct UAB       vuab;
extern typeCP           cpMacCur;
extern struct SEL       selCur;
extern int              vdocExpFetch;
extern CHAR             (**hszSearch)[];
extern typeCP           vcpFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern struct CHP       vchpFetch;
#ifdef STYLES
extern struct PAP       vpapCache;
extern CHAR             mpusgstcBase[];
#endif
extern int              vrefFile;


struct PGTB **HpgtbCreate();


#ifdef ENABLE       /* This is never called */
int DocFromSz(sz, dty)
CHAR sz[];
/* Return doc if one with that name exists already */
{
int doc;
struct DOD *pdod = &(**hpdocdod)[0];
struct DOD *pdodMac = pdod + docMac;

if (sz[0] == 0)
        return docNil;

for (doc = 0; pdod < pdodMac; ++pdod, ++doc)
        if (pdod->hpctb != 0 && pdod->dty == dty &&
            FSzSame(sz, **pdod->hszFile)
#ifdef SAND
                                      && (pdod->vref == vrefFile)
#endif
                                                                  )
                {
                ++pdod->cref;
                return doc;
                }
return docNil;
}
#endif


KillDoc(doc)
int doc;
{ /* Wipe this doc, destroying any changes since last save */
extern int vdocBitmapCache;

if (doc == docScrap)
        return;         /* Can't be killed no-how */

if (--(**hpdocdod)[doc].cref == 0)
        {
        struct FNTB **hfntb;
#ifdef CASHMERE
        struct SETB **hsetb;
#else
        struct SEP **hsep;
#endif
        struct FFNTB **hffntb;
        struct TBD (**hgtbd)[];
        CHAR (**hsz)[];
        int docSsht;

        SmashDocFce( doc );

        /* Kill style sheet doc if there is one. */
        if ((docSsht = (**hpdocdod)[doc].docSsht) != docNil)
                KillDoc(docSsht);

        /* Free piece table, filename, and footnote (or style) table */
        FreeH((**hpdocdod)[doc].hpctb);
        (**hpdocdod)[doc].hpctb = 0; /* To show doc free */
        if ((hsz = (**hpdocdod)[doc].hszFile) != 0)
                FreeH(hsz);
        if ((hfntb = (**hpdocdod)[doc].hfntb) != 0)
                FreeH(hfntb);
#ifdef CASHMERE
        if ((hsetb = (**hpdocdod)[doc].hsetb) != 0)
                FreeH(hsetb);
#else
        if ((hsep = (**hpdocdod)[doc].hsep) != 0)
                FreeH(hsep);
#endif

        if ((hgtbd = (**hpdocdod)[doc].hgtbd) != 0)
                FreeH( hgtbd );
        if ((hffntb = (**hpdocdod)[doc].hffntb) != 0)
                FreeFfntb(hffntb);

        if (doc == vdocBitmapCache)
            FreeBitmapCache();

        InvalidateCaches(doc);
        if (docCur == doc)
                docCur = docNil;
        if (docRulerSprm == doc)
                docRulerSprm = docNil;
        if (vuab.doc == doc || vuab.doc2 == doc)
                NoUndo();
        }
}



#ifdef STYLES
struct SYTB **HsytbCreate(doc)
int doc;
{ /* Create a map from stc to cp for a style sheet */
typeCP cp, *pcp;
struct SYTB **hsytb;
typeCP cpMac;
int stc, usg, stcBase, stcMin;
int ch, cch, cchT;
int *pbchFprop, *mpstcbchFprop;
CHAR *pchFprop, *grpchFprop;
int iakd, iakdT, cakd, cakdBase;
struct AKD *rgakd, *pakd;
#ifdef DEBUG
int cakdTotal;
#endif

CHAR    rgch[3];
CHAR    mpchcakc[chMaxAscii];
typeCP  mpstccp[stcMax];

/* First, clear out the stc-->cp map by filling with cpNil. */
for (stc = 0, pcp = &mpstccp[0]; stc < stcMax; stc++, pcp++)
        *pcp = cpNil;
bltbc(mpchcakc, 0, chMaxAscii);

/* Now go through all entries in the style sheet.  In this pass,
    check for duplicates (and return 0 if in gallery mode), fill
    mpstccp with appropriate entries for all defined stc's, and
    count the length of all the styles so we can allocate the heap
    block later. */
cpMac = (**hpdocdod)[doc].cpMac;
for (cp = 0, cch = 0, cakd = 1, cakdBase = 1; cp < cpMac; cp += ccpSshtEntry)
        {
        FetchRgch(&cchT, rgch, doc, cp, cpMac, 3);
        stc = rgch[0]; /* stc is first cp of entry */
#ifdef DEBUG
        Assert(stc < stcMax);
#endif
        if (mpstccp[stc] != cpNil && doc == docCur)
                { /* Repeated entry */
                Error(IDPMTStcRepeat);
                goto ErrRet;
                }
        mpstccp[stc] = cp;
        if (stc < stcSectMin)
                {
                FetchCp(doc, cp, 0, fcmProps);
                cch += CchDiffer(&vchpFetch, &vchpNormal, cchCHP) + 1;
                }
        if (stc >= stcParaMin)
                {
                CachePara(doc, cp);
                if (stc >= stcSectMin)
                        cch += CchDiffer(&vpapCache, &vsepNormal, cchSEP) + 1;
                else
                        cch += CchDiffer(&vpapCache, &vpapStd, cchPAP) + 1;
                }
        ch = rgch[1];
        if (ch != ' ')
                { /* Define an alt-key code for this style */
                ++cakd;
                if (rgch[2] == ' ')
                        {
                        if (mpchcakc[ch]-- != 0)
                                {
                                Error(IDPMTAkcRepeat);
                                goto ErrRet;
                                }
                        ++cakdBase;
                        }
                else
                        {
                        ++mpchcakc[ch];  /* increment before switch to avoid
                                                the increment being taken
                                                as for an int. */
                        switch (mpchcakc[ch])
                                {
                        case 0:
                                Error(IDPMTAkcRepeat);
                                goto ErrRet;
                        case 1:
                                ++cakdBase;
                                ++cakd;
                                }
                        }
                }
        }

/* Now allocate the heap block, using the total we got above. */
/* HEAP MOVEMENT */
hsytb = (struct SYTB **) HAllocate(cwSYTBBase + cwAKD * cakd +
    CwFromCch(cch));

if (FNoHeap(hsytb))
        return hOverflow;

/* Now go through the stc-->cp map, filling in the stc-->fprop map
    in the sytb.  For each stc that isn't defined, determine which
    stc to alias it to (either the first of the usage or, if that
    one isn't defined, the first one of the first usage). Copy the
    actual CHP's, PAP's, and SEP's into grpchFprop. */
mpstcbchFprop = (**hsytb).mpstcbchFprop;
rgakd = (struct AKD *) (grpchFprop = (**hsytb).grpchFprop);
pchFprop = (CHAR *) &rgakd[cakd];
pcp = &mpstccp[0];
pbchFprop = &mpstcbchFprop[0];
*pbchFprop = bNil;
#ifdef DEBUG
cakdTotal = cakd;
#endif
for (stc = 0, usg = 0, stcBase = 0, stcMin = 0, iakd = 0;
   stc < stcMax;
      stc++, pcp++, pbchFprop++)
        {
        if (stc >= mpusgstcBase[usg + 1])
                { /* Crossed a usage or class boundary */
                *pbchFprop = bNil;
                stcBase = mpusgstcBase[++usg];
                if (stcBase == stcParaMin || stcBase == stcSectMin)
                        { /* Update the base; make std if none defined */
                        stcMin = stcBase;
                        }
                }
        if ((cp = *pcp) == cpNil)
                { /* No style defined; take first for usg or, failing
                     that, first style of this class. */
                if ((*pbchFprop = mpstcbchFprop[stcBase]) == bNil)
                        *pbchFprop = mpstcbchFprop[stcMin];
                }
        else
                { /* New style; copy the looks and bump the pointers */
                /* Char stc's have just FCHP; para has FPAP followed by
                        FCHP; sect has FSEP. */
                *pbchFprop = pchFprop - grpchFprop;
                if (stc >= stcParaMin)
                        { /* Para or sect */
                        CachePara(doc, cp);
                        if (stc >= stcSectMin)
                                cchT = CchDiffer(&vpapCache, &vsepNormal, cchSEP);
                        else
                                cchT = CchDiffer(&vpapCache, &vpapStd, cchPAP);
                        if ((*pchFprop++ = cchT) != 0)
                                bltbyte(&vpapCache, pchFprop, cchT);
                        pchFprop += cchT;
                        }
                if (stc < stcSectMin)
                        { /* Char or para */
                        FetchCp(doc, cp, 0, fcmProps);
                        cchT = CchDiffer(&vchpFetch, &vchpNormal, cchCHP);
                        if ((*pchFprop++ = cchT) != 0)
                                bltbyte(&vchpFetch, pchFprop, cchT);
                        pchFprop += cchT;
                        }
                /* Insert element in akd table */
                FetchRgch(&cchT, rgch, doc, cp, cpMac, 3);
                if ((ch = rgch[1]) == ' ')
                        continue;
                if (rgch[2] == ' ')
                        { /* Single-key akc */
                        pakd = &rgakd[iakd++];
                        pakd->ch = ch;
                        pakd->fMore = false;
                        pakd->ustciakd = stc;
                        }
                else
                        { /* Two-char akc */
                        for (iakdT = 0; iakdT < iakd; iakdT++)
                                if (rgakd[iakdT].ch == ch)
                                        {
                                        pakd = &rgakd[rgakd[iakdT].ustciakd +
                                            --mpchcakc[ch]];
                                        pakd->ch = rgch[2];
                                        pakd->fMore = true;
                                        pakd->ustciakd = stc;
                                        do
                                                if ((++pakd)->ch == rgch[2])
                                                        {
                                                        Error(IDPMTAkcRepeat);
                                                        FreeH(hsytb);
                                                        goto ErrRet;
                                                        }
                                            while (pakd->fMore);
                                        goto NextStc;
                                        }
                        pakd = &rgakd[iakd++];
                        pakd->ch = ch;
                        pakd->fMore = true;
                        pakd->ustciakd = (cakd -= mpchcakc[ch]);
                        pakd = &rgakd[cakd + --mpchcakc[ch]];
                        pakd->ch = rgch[2];
                        pakd->fMore = false;
                        pakd->ustciakd = stc;
                        }
                }
NextStc: ;
        }

pakd = &rgakd[iakd++];
pakd->ch = ' ';
pakd->fMore = false;
pakd->ustciakd = stcNormal;

#ifdef DEBUG
Assert(grpchFprop + cchAKD * cakdTotal + cch == pchFprop && iakd == cakd);
#endif
return hsytb;

ErrRet:
Select(cp, cp + ccpSshtEntry);
vfSeeSel = true;
return 0;
}
#endif /* STYLES */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\doslib.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*  Include file with headers for functions in DOSLIB.ASM */

typedef unsigned DOSHND;        /* DOS handle */
typedef DOSHND typeOSFN;        /* General WRITE type for OS file handle */
struct TIM {                    /* Time structure returned by OsTime */
    CHAR minutes, hour, hsec, sec;
    };

int CchCurSzPath( CHAR *, CHAR );

#ifdef ENABLE   /* We are not currently using these */
int FFirst( CHAR near *, PSTR, int );
int FNext( CHAR near * );
DOSHND  WOpenSzFfname( CHAR *, int );
#endif

WORD    DaGetFileModeSz(CHAR *);
void    OsTime( struct TIM * );     /* NOTE: function moved to lib.asm */
DOSHND  WCreateNewSzFfname( CHAR *, int );
DOSHND  WCreateSzFfname( CHAR *, int );
int     CchReadDoshnd( DOSHND, CHAR FAR *, int );
int     CchWriteDoshnd( DOSHND, CHAR FAR *, int );
int     FCloseDoshnd( DOSHND );
WORD    WDosVersion( void );
int     DosxError( void );
long    DwSeekDw( DOSHND, long, int );
int     FpeDeleteSzFfname( CHAR * );
int     FpeRenameSzFfname( CHAR *, CHAR * );


#define DA_NORMAL       0x00    /* DOS File Attribute */
#define DA_READONLY     0x01    /* DOS File Attribute for read-only file */
#define DA_NIL          0xFFFF  /* Error DA */
#define dosxSharing     32      /* Extended error code for sharing viol. */
#define nErrNoAcc       5       /* OpenFile error code for Access Denied */
#define nErrFnf         2       /* OpenFile error code for File Not Found */
#define bSHARE_DENYRDWR 0x10    /* Sharing Open mode for exclusive use */

/* Error condition returned by "CCH" returning DOS functions, e.g. read */

#define FIsErrCchDisk(cch)   ((int)(cch) < 0)

#define cchDiskHardError    -1      /* Bogus error code, not returned by DOS */
#define fpeHardError        -1      /* also */

/* Error condition returned by functions that return DOS handles */

#define FIsErrDoshnd(doshnd)        ((int)(doshnd) < 0)

/* DOS Error codes */
/* These are the negative of the codes returned in AX by DOS functions */
#define fpeFnfError      -2      /* File Not Found */
#define fpeBadPathError  -3      /* Bad Path (path not found) */
#define fpeNoHndError    -4      /* No Handles Available */
#define fpeNoAccError    -5      /* Access Denied */
#define fpeBadHndError   -6      /* Bad handle passed in */
#define fpeNoDriveError  -15     /* Non-existent drive passed in */
#define fpeExistError    -80     /* File exists */

/* Seek-from type codes passed to DOS function 42H */

#define SF_BEGINNING    0       /* Seek from beginning of file */
#define SF_CURRENT      1       /* Seek from current file pointer */
#define SF_END          2       /* Seek from end of file */

/* Error test for seek position */

#define FIsErrDwSeek(dw)    ((long)(dw) < (long)0)

/* Error test for fpe-returning functions */

#define FIsErrFpe(fpe)     ((int)(fpe) < 0)

/* Tests whether an error is a hardware error.  Hardware errors are caught
   and prompted for by Windows, so we should not duplicate those prompts.
   Chrisp says these DOS 3.0 error codes are generated by Windows for all
   supported versions of DOS
   fpe is WRITE's error type; ofe is the unadulturated error returned by
   DOS or OpenFile */

#define ofeCaughtFirst      19
#define ofeCaughtLast       27

#define FIsCaughtOfe(ofe)   (((ofe)>=ofeCaughtFirst)&&((ofe)<=ofeCaughtLast))
#define FIsCaughtFpe(fpe)   FIsCaughtOfe(-(fpe))
#define FIsCaughtDwSeekErr(dw)  FIsCaughtFpe((int)(dw))

#define FpeFromCchDisk(cch) (cch)

#define fpeNoErr            0

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\docdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

//#define prmNil	0
#define docNil	(-1)
#define cpNil	((typeCP) -1)
#define cpMax	((typeCP) 2147483647)
#define fcNil	((typeFC) -1)
#define cp0	((typeCP) 0)
#define fnNil	(32767)
#define fc0	((typeFC) 0)
#define tcMax	255

#ifdef SAND
#define xaMax	9500
#endif

#define pn0	((typePN) 0)

#define cdocInit	4
#define cwExpand	256
#define cchMaxExpand	(cwExpand * sizeof (int))

/* FetchCp Modes */
#define fcmChars	1
#define fcmProps	2
#define fcmBoth 	(fcmChars + fcmProps)
#define fcmNoExpand	4
#define fcmParseCaps	8	/* Return separate runs for U&lc if sm. caps*/

/* Document types -- two bits only */
#define dtyNormal	0
#define dtyBuffer	1
#define dtySsht 	2
#define dtyPrd		3
#define dtySystem	4	/* Never written; smashed to dtyNormal */
#define dtyHlp		5	/* Never written */
#define dtyNormNoExt	6   /* Never written */

#ifdef INTL  /* international version */
#define dtyWordDoc	6	/* when saving in Word format */
#endif	/* international version */

#define dtyNetwork	7	/* Never written; smashed to dtyNormal */

#define dtyAny		0


struct DOD
	{ /* Document descriptor */
	struct PCTB	**hpctb;	/* Piece table */
	typeCP		cpMac;		/* Number of lexemes in doc */

	unsigned       fFormatted : 1; /* Default save is formatted */
	unsigned       fDirty : 1;     /* Document has been edited */
	unsigned       fAbsLooks : 1;  /* Absolute looks applied */
	unsigned       fBackup : 1;    /* Make auto backup of file? */
	unsigned       fReadOnly: 1;   /* Read only doc (no edits allowed)? */
	unsigned       fDisplayable : 1;
	unsigned       : 4;
	unsigned       dty : 2;        /* Document type */
	unsigned       cref : 4;       /* Reference count */

	CHAR		(**hszFile)[];	/* Document name */
	struct FNTB	**hfntb;	/* Footnote table */
#ifdef CASHMERE
	struct SETB	**hsetb;	/* Section table */
#else
	struct SEP	**hsep; 	/* Section properties */
#endif
	int		docSsht;	/* Style sheet if dty == dtySsht */
	struct PGTB	**hpgtb;	/* Page table (for Jump Page) */
	struct FFNTB	**hffntb;	/* font name table */

	struct TBD	(**hgtbd)[];	/* Table of tab stops */

#ifdef SAND
	int		vref;		/* Volume that this document is on */
#endif /* SAND */
	};

#define cwDOD (sizeof (struct DOD) / sizeof (int))
#define cbDOD (sizeof (struct DOD))

struct FNTB **HfntbGet();

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\d_disp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* disp.c -- MW display routines */

#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
//#define NOVIRTUALKEYCODES

#ifndef DBCS
#define NOSYSMETRICS
#endif

#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NOWH
#define NOWINOFFSETS
#define NOMETAFILE

#ifndef DBCS
#define NOMB
#endif

#define NODRAWTEXT
#include <windows.h>

#define NOUAC
#include "mw.h"
#include "debug.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#define NOKCCODES       /* Removes all kc code defines */
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "macro.h"
#include "printdef.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef DBCS
#include "dbcs.h"
#include "kanji.h"
#endif

#ifdef  DBCS_IME
#include    <ime.h>

#ifdef  JAPAN
#include "prmdefs.h"    //IME3.1J
BOOL    ConvertEnable = FALSE;
BOOL    bClearCall = TRUE;
#endif      /* JAPAN */
#endif      /* DBCS_IME */

#ifdef CASHMERE     /* No VisiMode in WinMemo */
extern int              vfVisiMode;
#endif /* CASHMERE */

extern int              vcchBlted;
extern int              vidxpInsertCache;
extern int              vdlIns;
extern int              vfInsLast;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern int              rgval[];
extern struct DOD       (**hpdocdod)[];
extern typeCP           cpMacCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur, wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern int              docCur;
extern struct CHP       (**vhgchpFormat)[];
extern int              vichpFormat;
extern typeCP           cpMinCur;
extern typeCP           cpMinDocument;
extern int              vfInsertOn;
extern int              vfTextBltValid;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern unsigned         vpgn;
extern struct SEP       vsepAbs;
extern CHAR             stBuf[];
extern typeCP           CpEdge();
extern typeCP           CpMacText();
extern int              vdocPageCache;
extern int              vfPictSel;
extern int              vfAwfulNoise;
extern int              vfSkipNextBlink;
extern int              dypMax;
extern HDC              vhMDC;
extern HWND             vhWndPageInfo;
extern struct FMI       vfmiScreen;
extern int              docScrap;
extern long             rgbBkgrnd;
extern long             ropErase;
extern BOOL             vfMonochrome;
extern int              dxpbmMDC;
extern int              dypbmMDC;
extern HBITMAP          hbmNull;
extern int              vfOutOfMemory;
extern int              vfSeeSel;
extern int              vfInsEnd;   /* Is insert point at end-of-line? */
extern int              vipgd;
extern typeCP           vcpMinPageCache;
extern typeCP           vcpMacPageCache;
/* actual position of the cursor line */
extern int              vxpCursLine;
extern int              vypCursLine;

extern int              vdypCursLine;
extern int              vfScrollInval; /* means scroll did not take and UpdateWw must be repeated */
extern BOOL             vfDead;
extern HRGN             vhrgnClip;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
extern typeCP selUncpFirst;
extern typeCP selUncpLim;
extern HANDLE hImeUnAttrib;
extern int    vfImeHidden;

int     HiddenTextTop = 0;
int     HiddenTextBottom = 0;
//if TRUE we are managing IR_UNDETERMINE
BOOL    whileUndetermine = FALSE;   //12/28/92
LPSTR   Attrib;
WORD    AttribPos = 0;

#define IMEDEFCOLORS         6     // IME Define colors
#define IMESPOT              0     // IME Spot background color
#define IMESPOTTEXT          1     // IME Spot text color
#define IMEINPUT             2     // IME Input background color
#define IMEINPUTTEXT         3     // IME Input text color
#define IMEOTHER             4     // IME Other background color
#define IMEOTHERTEXT         5     // IME Other text color

COLORREF   rgbIMEHidden[IMEDEFCOLORS] = {0L,0L,0L,0L,0L,0L};

#endif


/* G L O B A L S
int dlsMac = 0;*/
#ifdef DBCS
int donteat = 0;    /* propagate not to eat message */
#endif


#if defined(TAIWAN) || defined(PRC)    //Daniel/MSTC, 1993/02/25, for jcBoth
#define FKana(_ch) FALSE
#endif


/* D I S P L A Y  F L I */
/* Display formatted line in window ww at line dl */


DisplayFli(ww, dl, fDontDisplay)
int ww;
int dl;
int fDontDisplay; /* True if we set up dl info but don't display */
    {
    typeCP dcp;
    typeCP dcpMac;
    struct WWD *pwwd = &rgwwd[ww];
    HDC hDC = pwwd->hDC;
    int xp;                     /* Current xp to write text */
    int yp;                     /* Current yp to write text */
    int xpMin = pwwd->xpMin;    /* Minimum xp in window */
    int xpMac = pwwd->xpMac;    /* Maximum xp in window */
    int ypLine;                 /* Screen yp for current line */
    int dxp;                    /* Width of current run */
    int dyp;                    /* Line height */
    int dxpExtra;               /* Width of pad for each space */
    typeCP cpMin;
    typeCP cpMac;
    int xpSel;                  /* xp of the start of the selection */
    int dxpSel = 0;             /* Width of the selection. */
    CHAR chMark = '\0';         /* style character */
    struct CHP *pchp;
    BOOL fTabsKludge = (vfli.ichLastTab >= 0);
    BOOL fInsertOn = FALSE;
    int cBreakRun;              /* break characters in run (no relation to Dick or Jane) */

#ifdef SMFONT
    RECT rcOpaque;
#endif /* SMFONT */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
    extern int vfWordWrap;    /* WordWrap flag : TRUE=ON, FALSE=OFF */
    extern int iNonWideSpaces;
    int iRun;
    typeCP RealcpFirst;

#elif defined(TAIWAN) || defined(PRC)
    extern int vfWordWrap;    /* WordWrap flag : TRUE=ON, FALSE=OFF */
    extern int iNonWideSpaces;
    int iRun;
    typeCP RealcpFirst;
#endif

#ifdef DDISP
    CommSzNumNum("    DisplayFli: dl/fDontDisplay ", dl, fDontDisplay);
#endif
    Assert(ww >= 0 && ww < wwMax);
#ifdef SMFONT
    Assert(!fDontDisplay || vfli.fGraphics)
#endif /* SMFONT */
    Scribble(5,'D');

    /* Fill up EDL and set some useful locals */
        {
        register struct EDL *pedl = &(**pwwd->hdndl)[dl];

        if (dl == vdlIns)
            {
            /* Overwriting chars blted during fast insert; reset blt count */
            vcchBlted = 0;
            vidxpInsertCache = -1;
            }

        pedl->xpLeft = vfli.xpLeft;
        pedl->xpMac = vfli.xpReal;
        cpMin = pedl->cpMin = vfli.cpMin;
#ifdef JAPAN
        RealcpFirst = cpMin;
#endif
        pedl->dcpMac = (cpMac = vfli.cpMac) - cpMin;
        dyp = pedl->dyp = vfli.dypLine;
        pedl->ichCpMin = vfli.ichCpMin;
        pedl->dcpDepend = (cpMin == cpMac) ? 0xff : vfli.dcpDepend;
        pedl->fValid = TRUE;
        pedl->fGraphics = vfli.fGraphics;
        pedl->fSplat = vfli.fSplat;

        /* The position of current line equals the position of the previous line
        + height of this line. */
#ifdef SMFONT
        pedl->yp = rcOpaque.bottom = dyp + (ypLine = rcOpaque.top = (dl == 0 ?
          pwwd->ypMin : (pedl - 1)->yp));
#else /* not SMFONT */
        pedl->yp = dyp + (ypLine = (dl == 0 ? pwwd->ypMin :
          (pedl - 1)->yp));
#endif /* SMFONT */

        if (pedl->fIchCpIncr = (vfli.ichCpMac != 0))
            {
            /* Look at final text column */
            ++cpMac;

            /* Since this is true, we can compress pedl->ichCpMac to 1 bit. */
            Assert(vfli.ichCpMac == pedl->ichCpMin + 1);
            }
        }

    if (vfli.doc == docNil)
        {
        /* This is the space beyond the end mark. */
        PatBlt(hDC, 0, ypLine, xpMac, dyp, ropErase);
        goto Finished;
        }

    /* Is there a character in the "style bar"? */
    if (cpMin != cpMac)
        {

#ifdef CASHMERE
        /* This line is not completely empty (not after the end mark); check for
        painting marks on the style bar. */
        if (cpMin == vcpFirstParaCache && vpapAbs.rhc != 0)
            {
            /* This is a running-head. */
            chMark = chStatRH;
            }
        else if ((**hpdocdod)[vfli.doc].hpgtb != 0)
#else /* not CASHMERE */
        if (vpapAbs.rhc == 0 && (**hpdocdod)[vfli.doc].hpgtb != 0)
#endif /* CASHMERE */

            {
            if (vdocPageCache != vfli.doc || cpMac > vcpMacPageCache || cpMac <=
              vcpMinPageCache)
                {
                CachePage(vfli.doc, cpMac - 1);
                }

            /* We are now guaranteed that cpMac is within the cached page. */
            if (cpMin <= vcpMinPageCache && (!vfli.fGraphics || vfli.ichCpMin ==
              0))
                {
                /* This is the first line of new page; show page mark. */
                chMark = chStatPage;
                }
            }
        }

#ifdef SMFONT
#ifdef DDISP
    /* black out this line to test how efficiently/correctly we
       overwrite pixels from previously-resident lines of text */
    PatBlt(hDC, 0, ypLine, xpMac, dyp, BLACKNESS);
    { long int i; for (i=0; i < 500000; i++) ; }
#endif

    /* Calculate dcpMac now, so we might be able to know how much to erase. */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;

    /* Erase any character that might be in the style bar. */
    dxp = xpSelBar + 1;
    if (!vfli.fGraphics)
        {
        dxp = xpMac; // clear the whole line
        }
    PatBlt(hDC, 0, ypLine, dxp, dyp, ropErase);

    /* If this is graphics then go draw any characters in the style bar. */
    if (vfli.fGraphics)
        {
        goto DrawMark;
        }

    /* If there are no "real" characters on this line then we can skip alot of
    this. */
    if (dcpMac == 0)
        {
        goto EndLine2;
        }
#else /* not SMFONT */
    if (vfli.fGraphics || fDontDisplay)
        {
        /* Erase any character that might be in the style bar. */
        PatBlt(hDC, 0, ypLine, xpSelBar, dyp, ropErase);
        goto DrawMark;
        }
#endif /* SMFONT */

    ValidateMemoryDC();
    if (vhMDC == NULL)
        {
Error:
        /* Notify the user that an error has occured and simply erase this line.
        */
        WinFailure();
        PatBlt(hDC, xpSelBar, ypLine, xpMac - xpSelBar, dyp, ropErase);
        goto Finished;
        }

#ifndef SMFONT
    /* Create a new bitmap for the memory DC if the current bitmap is not big
    enough. */
    if (xpMac > dxpbmMDC || dyp > dypbmMDC)
        {
        HBITMAP hbm;

        /* If there is an old bitmap, then delete it. */
        if (dxpbmMDC != 0 || dypbmMDC != 0)
            {
            DeleteObject(SelectObject(vhMDC, hbmNull));
            }

        /* Create the new bitmap and select it in. */
        if ((hbm = CreateBitmap(dxpbmMDC = xpMac, dypbmMDC = dyp, 1, 1,
          (LPSTR)NULL)) == NULL)
            {
            /* There should be a graceful way to recover if the bitmap is ever
            NULL (e.g we don't have enough memory for it). */
            dxpbmMDC = dypbmMDC = 0;
            goto Error;
            }
        SelectObject(vhMDC, hbm);
        }

    /* Erase the are of the bitmap we are going to use. */
    PatBlt(vhMDC, xpSelBar, 0, xpMac, dyp, vfMonochrome ? ropErase : WHITENESS);
#endif /* not SMFONT */

    /* Initialize some of the variables we'll need. */
    pchp = &(**vhgchpFormat)[0];
#ifdef SMFONT
    xp = rcOpaque.left = rcOpaque.right = vfli.xpLeft + xpSelBar - xpMin + 1;
#else /* not SMFONT */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;
    xp = vfli.xpLeft + xpSelBar - xpMin + 1;
#endif /* SMFONT */
    dxpExtra = fTabsKludge ? 0 : vfli.dxpExtra;

#ifdef SMFONT
    /* If we are horizontally scrolled, then set the clip area to the area
    outside of the selection bar. */
    if (xpMin != 0)
        {
        IntersectClipRect(hDC, xpSelBar, rcOpaque.top, xpMac, rcOpaque.bottom);
        }
#endif /* SMFONT */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
    iRun = 0;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
    iRun = 0;
#endif

    for (dcp = 0; dcp < dcpMac; pchp++)
        {
        /* For all runs do: */
        int ichFirst;   /* First character in the current run */
        int cchRun;     /* Number of characters in the current run */

        dcp = ichFirst = pchp->ichRun;
        dcp += pchp->cchRun;
        if (dcp > dcpMac)
            {
            dcp = dcpMac;
            }
        cchRun = dcp - ichFirst;

        /* Compute dxp = sum of width of characters in current run (formerly
        DxaFromIcpDcp). */
            {
            register int *pdxp;
            register int cchT = cchRun;
            PCH pch = vfli.rgch + ichFirst;

            dxp = cBreakRun = 0;
            pdxp = &vfli.rgdxp[ichFirst];
            while (cchT-- > 0)
                {
                dxp += *pdxp++;
                if (*pch++ == chSpace)
                    ++cBreakRun;
                }

#ifdef DDISP
            CommSzNum("  dxp=",dxp);
#endif
            }

        if (dxp > 0)
            {
            int cchDone;
            PCH pch = &vfli.rgch[ichFirst];
#ifdef JAPAN                  //  added  08 Jul. 1992  by Hiraisi
            int *pdxpT = &vfli.rgdxp[ichFirst];
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
            int *pdxpT = &vfli.rgdxp[ichFirst];
#endif

            LoadFont(vfli.doc, pchp, mdFontScreen);
            yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
              hpsNegMin ? ypSubSuper : -ypSubSuper) : 0))) -
              vfmiScreen.dypBaseline;

            /* Note: tabs and other special characters are guaranteed to come at
            the start of a run. */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
            if( vpapAbs.jc != jcBoth || fTabsKludge )
                SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);

#elif defined(TAIWAN) || defined(PRC) // Daniel/MSTC, 1993/02/25, for jcBoth
            if( vpapAbs.jc != jcBoth)
                SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);

#else
            SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */

#ifdef SMFONT
#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
            if( vpapAbs.jc != jcBoth || fTabsKludge )
                SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
            if( vpapAbs.jc != jcBoth)
                SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#else
            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
#endif /* SMFONT */

            cchDone = 0;
            while (cchDone < cchRun)
                {
                int cch;

                /* Does the wide-space zone begin in this run? */
                if (vfli.fAdjSpace && (vfli.ichFirstWide < ichFirst + cchRun) &&
                  (ichFirst + cchDone <= vfli.ichFirstWide))
                    {
                    int cchDoneT = cchDone;

                    /* Is this the beginning of the wide-space zone? */
                    if (ichFirst + cchDone == vfli.ichFirstWide)
                        {
                        /* Reset the width of the spaces. */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(vhMDC, ++dxpExtra * cBreakRun,
                                                 cBreakRun);
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(vhMDC, ++dxpExtra * cBreakRun,
                                                 cBreakRun);

#else
                        SetTextJustification(vhMDC, ++dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */

#ifdef SMFONT
#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                 cBreakRun);

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        if( vpapAbs.jc != jcBoth)
                            SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                 cBreakRun);


#else
                        SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
#endif /* SMFONT */

                        cch = cchRun - cchDone;
                        cchDone = cchRun;
                        }
                    else
                        {
                        cchDone = cch = vfli.ichFirstWide - ichFirst;
                        }

                    /* This run is cut short because of a wide space, so we need
                    to calculate a new width. */
                        {
                        register int *pdxp;
                        register int cchT = cch;
                        PCH pch = &vfli.rgch[ichFirst + cchDoneT];

                        dxp = 0;
                        pdxp = &vfli.rgdxp[ichFirst + cchDoneT];
                        while (cchT-- > 0)
                            {
                            dxp += *pdxp++;
                            if (*pch++ == chSpace)
                                ++cBreakRun;
                            }
                        }
                    }
                else
                    {
                    cchDone = cch = cchRun;
                    }

                while (cch > 0)
                    {
                    switch (*pch)
                        {
                        CHAR ch;
                        int dxpT;

                    case chTab:

#ifdef CASHMERE
                        /* chLeader contains tab leader character (see
                        FormatLine) */
                        if ((ch = pchp->chLeader) != chSpace)
                            {
                            int cxpTab;
                            CHAR rgch[32];
                            int dxpLeader = CharWidth(ch);
                            int xpT = xp;
                            int iLevelT = SaveDC(vhMDC);

                            SetBytes(&rgch[0], ch, 32);
                            dxpT = vfli.rgdxp[ichFirst];
                            cxpTab = ((dxpT + dxpLeader - 1) / dxpLeader + 31)
                              >> 5;

                            xp += dxpT;

                            while (cxpTab-- > 0)
                                {
                                TextOut(vhMDC, xpT, yp, (LPSTR)rgch, 32);
                                xpT += dxpLeader << 5;
                                }
                            RestoreDC(vhMDC, iLevelT);
                            }
                        else
#endif /* CASHMERE */

                            {
#ifdef SMFONT
                            /* Expand the opaque rectangle to include the tab.
                            */
                            rcOpaque.right += vfli.rgdxp[ichFirst];
#endif /* SMFONT */
                            xp += vfli.rgdxp[ichFirst];
                            }

                        if (fTabsKludge && ichFirst >= vfli.ichLastTab)
                            {

#ifdef JAPAN                 //  added  19 Jun. 1992  by Hiraisi
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(vhMDC, (dxpExtra =
                                  vfli.dxpExtra) * cBreakRun, cBreakRun);
                            else
                                dxpExtra = vfli.dxpExtra;

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(vhMDC, (dxpExtra =
                                  vfli.dxpExtra) * cBreakRun, cBreakRun);
                            else
                                dxpExtra = vfli.dxpExtra;

#else
                            SetTextJustification(vhMDC, (dxpExtra =
                              vfli.dxpExtra) * cBreakRun, cBreakRun);
#endif /* JAPAN */

#ifdef SMFONT
#ifdef JAPAN                 //  added  19 Jun. 1992  by Hiraisi
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                     cBreakRun);

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                     cBreakRun);
#else
                            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
#endif /* SMFONT */

                            fTabsKludge = FALSE;
                            }
                        dxp -= vfli.rgdxp[ichFirst];
                        pch++;
                        cch--;
#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                        iRun++;
                        pdxpT++;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        iRun++;
                        pdxpT++;
#endif
                        goto EndLoop;

#ifdef CASHMERE
                    case schPage:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpPgn(&stBuf[1], vpgn, vsepAbs.nfcPgn,
                          flmSandMode, ichMaxLine);
                        goto DrawSpecial;

                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpFtn(&stBuf[1], cpMin + ichFirst,
                          flmSandMode, ichMaxLine);
DrawSpecial:
#else /* not CASHMERE */
                    case schPage:
                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = *pch == schPage && (wwdCurrentDoc.fEditHeader
                          || wwdCurrentDoc.fEditFooter) ? CchExpPgn(&stBuf[1],
                          vpgn, 0, flmSandMode, ichMaxLine) :
                          CchExpUnknown(&stBuf[1], flmSandMode, ichMaxLine);
#endif /* not CASHMERE */

#ifdef SMFONT
                        /* Calculate the opaque rectangle. */
                        rcOpaque.right += vfli.rgdxp[ichFirst] +
                          vfmiScreen.dxpOverhang;

                        TextOut(hDC, xp, ypLine+yp, &stBuf[1], stBuf[0]);
#else /* not SMFONT */
                        TextOut(vhMDC, xp, yp, (LPSTR)&stBuf[1], stBuf[0]);
#endif /* SMFONT */
                        break;

#ifdef  DBCS
#if !defined(JAPAN) && !defined(KOREA)
/* Write ver3.1j endmark is 1charcter t-yoshio May 26,92*/
            case chMark1:
            if(*(pch+1) == chEMark)
            {   /* This run only contains EndMark */
                        rcOpaque.right += dxp + vfmiScreen.dxpOverhang;
#if defined (TAIWAN) || defined(PRC)  // solve italic font overhang truncation problem, MSTC - pisuih, 2/19/93
            TextOut(hDC, xp, (yp>0?(ypLine+yp):ypLine), (LPSTR)pch, cch );
#else
            ExtTextOut(hDC, xp, (yp>0?(ypLine+yp):ypLine),
                   2, (LPRECT)&rcOpaque,(LPSTR)pch, cch, (LPSTR)NULL);
#endif
            pch += cch;
            cch = 0;
            xp += dxp;
                        rcOpaque.left
                        = (rcOpaque.right = xp) + vfmiScreen.dxpOverhang;
            }
              /* else fall through */
#endif /*JAPAN*/
#endif
                    default:
                        goto EndLoop;
                        }

                    dxp -= vfli.rgdxp[ichFirst];
#ifdef SMFONT
                    /* End the line if no more will fit into the window. */
                    if ((xp += vfli.rgdxp[ichFirst++]) >= xpMac) {
                        goto EndLine;
                    }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
#else /* not SMFONT */
                    xp += vfli.rgdxp[ichFirst++];
#endif /* SMFONT */
                    pch++;
                    cch--;
#ifdef JAPAN                  //  added  09 Jul. 1992  by Hiraisi
                    pdxpT++;
#endif
                    }
EndLoop:

#ifdef SMFONT
                if (cch == 0)
                    {
                    Assert(dxp == 0);
                    }
                else
                    {
                    /* Calculate the opaque rectangle. */
                    rcOpaque.right += dxp + vfmiScreen.dxpOverhang;

#if 0
            {
                char msg[180];
                wsprintf(msg,"putting out %d characters\n\r",cch);
                OutputDebugString(msg);
            }
#endif

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                    if( vpapAbs.jc == jcBoth&&!fTabsKludge ) {
                        CHAR *ptr1, *ptr2;
                        int  len,   cnt;
                        int  iExtra, iSpace, iWid;
                        BOOL bFlag;

                        typeCP RealcpEnd;

                        ptr2 = pch;

                        for( cnt=0 ; cnt < cch ; ) {
                            ptr1 = ptr2;
                            iExtra = dxpExtra;
                            iWid = len = 0;
                            bFlag = TRUE;
                            if( IsDBCSLeadByte(*ptr2) ) {
                                for( ; cnt < cch ; ) {
                                    iWid += *pdxpT;
                                    pdxpT += 2;
                                    cnt += 2;
                                    len += 2;
                                    iRun += 2;
                                    ptr2 += 2;
                                    if( --iNonWideSpaces == 0 ) {
                                        dxpExtra++;
                                        break;
                                    }
                                    if( iRun == dcp - 2 )
                                        break;
                                    if( iRun == dcp ) { /* lastDBC(maybe) */
                                        iExtra = 0;
                                        break;
                                    }
                                    if( !IsDBCSLeadByte(*ptr2) )
                                        break;
                                }
                            }
                            else {
                                if( FKana( (int)*ptr2) ) {
                                    for( ; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        ptr2++;
                                        if( --iNonWideSpaces == 0 ) {
                                            dxpExtra++;
                                            break;
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* last SBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( !FKana( (int)*ptr2) )
                                            break;
                                    }
                                }
                                else {
                                    for( bFlag = FALSE,iSpace = 0; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        if( *ptr2++ == chSpace || !vfWordWrap ) {
                                            iSpace++;
                                            if( --iNonWideSpaces == 0 ) {
                                                dxpExtra++;
                                                break;
                                            }
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* lastSBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( IsDBCSLeadByte(*ptr2 ) ||
                                            FKana((int)*ptr2) )
                                            break;
                                    }
                                }
                            }
                            if( vfWordWrap && !bFlag ) {
                                SetTextCharacterExtra( hDC, 0 );
                                SetTextJustification( hDC,
                                                      iExtra*iSpace,iSpace);
                            }
                            else {
                                SetTextJustification(hDC,0,0);
                                SetTextCharacterExtra(hDC,iExtra);
                            }
                        /*-TextOut-*/
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                             /*Undetermine*/
                             if( (selUncpFirst != selUncpLim) &&
                                 *ptr1 != chEMark) {
                                 RealcpEnd = RealcpFirst + len;
                                 UndetermineString(hDC, xp, ypLine+yp, ptr1,
                                  len, RealcpFirst, RealcpEnd);
                             } else
                                 TextOut(hDC,xp,ypLine+yp,ptr1,len);
#else
                             TextOut(hDC,xp,ypLine+yp,ptr1,len);
#endif
                             RealcpFirst+=len;
                             xp+=iWid;
                         }
                    }
                    else{
                        iRun += cch;
                        SetTextCharacterExtra( hDC, 0 );
                        /*Undetermine*/
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                        if((selUncpFirst != selUncpLim) && *pch != chEMark)
                           UndetermineString( hDC, xp, ypLine+yp,
                           pch, cch, RealcpFirst, RealcpFirst+cch );
                        else
                        /* Output cch characters starting at pch */
                            TextOut(hDC, xp, ypLine+yp, pch, cch);
#else
                        /* Output cch characters starting at pch */
                        TextOut(hDC, xp, ypLine+yp, pch, cch);
#endif
                        /* End the line if no more will fit into the window. */
                        xp += dxp;
                        RealcpFirst+=cch;
                    }
                    if (xp >= xpMac)


#elif defined(TAIWAN)  || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                    if( vpapAbs.jc == jcBoth) { //&& !fTabsKludge ) {
                        CHAR *ptr1, *ptr2;
                        int  len,   cnt;
                        int  iExtra, iSpace, iWid;
                        BOOL bFlag;

                        typeCP RealcpEnd;

                        ptr2 = pch;

                        for( cnt=0 ; cnt < cch ; ) {
                            ptr1 = ptr2;
                            iExtra = dxpExtra;
                            iWid = len = 0;
                            bFlag = TRUE;
                            if( IsDBCSLeadByte(*ptr2) ) {
                                for( ; cnt < cch ; ) {
                                    iWid += *pdxpT;
                                    pdxpT += 2;
                                    cnt += 2;
                                    len += 2;
                                    iRun += 2;
                                    ptr2 += 2;
                                    if( --iNonWideSpaces == 0 ) {
                                        dxpExtra++;
                                        break;
                                    }
                                    if( iRun == dcp - 2 )
                                        break;
                                    if( iRun == dcp ) { /* lastDBC(maybe) */
                                        iExtra = 0;
                                        break;
                                    }
                                    if( !IsDBCSLeadByte(*ptr2) )
                                        break;
                                }
                            }
                            else {
                                if( FKana( (int)*ptr2) ) {
                                    for( ; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        ptr2++;
                                        if( --iNonWideSpaces == 0 ) {
                                            dxpExtra++;
                                            break;
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* last SBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( !FKana( (int)*ptr2) )
                                            break;
                                    }
                                }
                                else {
                                    for( bFlag = FALSE,iSpace = 0; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        if( *ptr2++ == chSpace || !vfWordWrap ) {
                                            iSpace++;
                                            if( --iNonWideSpaces == 0 ) {
                                                dxpExtra++;
                                                break;
                                            }
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* lastSBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( IsDBCSLeadByte(*ptr2 ) ||
                                            FKana((int)*ptr2) )
                                            break;
                                    }
                                }
                            }
                            if( vfWordWrap && !bFlag ) {
                                SetTextCharacterExtra( hDC, 0 );
                                SetTextJustification( hDC,
                                                      iExtra*iSpace,iSpace);
                            }
                            else {
                                SetTextJustification(hDC,0,0);
                                SetTextCharacterExtra(hDC,iExtra);
                            }
                        /*-TextOut-*/
//#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//                             /*Undetermine*/
//                             if( (selUncpFirst != selUncpLim) &&
//                                 *ptr1 != chEMark) {
//                                 RealcpEnd = RealcpFirst + len;
//                                 UndetermineString(hDC, xp, ypLine+yp, ptr1,
//                                  len, RealcpFirst, RealcpEnd);
//                             } else
//                                 TextOut(hDC,xp,ypLine+yp,ptr1,len);
//#else
                             TextOut(hDC,xp,ypLine+yp,ptr1,len);
//#endif
                             RealcpFirst+=len;
                             xp+=iWid;
                         }
                    }
                    else{
                        iRun += cch;
                        SetTextCharacterExtra( hDC, 0 );
                        /*Undetermine*/
//#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//                        if((selUncpFirst != selUncpLim) && *pch != chEMark)
//                           UndetermineString( hDC, xp, ypLine+yp,
//                           pch, cch, RealcpFirst, RealcpFirst+cch );
//                        else
//                        /* Output cch characters starting at pch */
//                            TextOut(hDC, xp, ypLine+yp, pch, cch);
//#else
                        /* Output cch characters starting at pch */
                        TextOut(hDC, xp, ypLine+yp, pch, cch);
//#endif
                        /* End the line if no more will fit into the window. */
                        xp += dxp;
                        RealcpFirst+=cch;
                    }
                    if (xp >= xpMac)

#else
                    /* Output cch characters starting at pch */
#if defined(KOREA)
            if ((cch == 1) && (pch[0] == chEMark))
            {
                int iPrevBkMode;
                iPrevBkMode = SetBkMode(hDC, OPAQUE);
                TextOut(hDC, xp, ypLine+yp, pch, cch);
                SetBkMode(hDC, iPrevBkMode);
            }
            else
                TextOut(hDC, xp, ypLine+yp, pch, cch);
#else
                    TextOut(hDC, xp, ypLine+yp, pch, cch);
#endif
                    /* End the line if no more will fit into the window. */
                    if ((xp += dxp) >= xpMac)
#endif    // JAPAN

                        {
                        goto EndLine;
                        }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
                    pch += cch;
                    }
#else /* not SMFONT */
                /* Output cch characters starting at pch */
                TextOut(vhMDC, xp, yp, (LPSTR)pch, cch);
                xp += dxp;
                pch += cch;
#endif /* SMFONT */
                } /* end while (cchDone<cchRun) */
            } /* end if (dxp>0) */
        } /* end for dcp=0..dcpMac */

#ifdef SMFONT
EndLine:
    /* Restore the clip region if need be. */
    if (xpMin != 0)
        {
        SelectClipRgn(hDC, NULL);
        }
EndLine2:
#endif /* SMFONT */

#ifdef CASHMERE
    if (vfVisiMode)
        {
        AddVisiSpaces(ww, &(**pwwd->hdndl)[dl], vfli.dypBase, vfli.dypAfter +
          vfli.dypFont);
        }
#endif /* CASHMERE */

    vfTextBltValid = FALSE;

    if ((ww == wwCur) && (pwwd->doc != docScrap) && !vfSelHidden &&
      (selCur.cpLim >= cpMin))
        {
        if (selCur.cpFirst <= cpMac)
            {
            /* Show selection */
            int xpFirst;
            int xpLim;

#ifdef ENABLE
            if (vfli.fSplatNext && selCur.cpFirst == selCur.cpLim &&
                selCur.cpFirst == cpMac)
                {
                vfInsEnd = TRUE;
                ClearInsertLine();
                }
            vfInsertOn = FALSE;
#endif /* ENABLE */

            if (selCur.cpFirst <= cpMin && selCur.cpLim >= cpMac)
                {
                xpFirst = vfli.xpLeft;
                xpLim = vfli.xpReal;
                }
            else if (selCur.cpFirst < cpMac || (selCur.cpLim == cpMac &&
              vfInsEnd))
                {
                typeCP cpBegin = CpMax(cpMin, selCur.cpFirst);
                typeCP cpEnd = CpMin(cpMac, selCur.cpLim);

                dxp = DxpDiff((int)(cpBegin - cpMin), (int)(cpEnd - cpBegin),
                  &xpFirst);
                xpLim = min(xpMin + vfli.xpReal, xpFirst + dxp);
                }
            else
                {
                goto DidntHighlight;
                }

            xpSel = xpSelBar + max(xpFirst - xpMin, 0);
            if (xpLim > xpFirst)
                {
                /* Set highlighting at desired screen position. */
                dxpSel = max(xpLim - max(xpFirst, xpMin), 0);
                }
            else if (selCur.cpFirst == selCur.cpLim && ((selCur.cpLim != cpMac)
              ^ vfInsEnd))
                {
                vfInsertOn = FALSE; /* Because we redisplayed insert pt line */

#ifdef CASHMERE
                vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
                vypCursLine = ypLine + dyp - vfli.dypAfter;
#else /* not CASHMERE */

#ifdef  DBCS    // Some double byte fonts have bigger character
                // face than the line hight.
                vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
#else
                vdypCursLine = vfli.dypFont;
#endif

                vypCursLine = ypLine + dyp;
#endif /* not CASHMERE */

                vxpCursLine = xpSel;

                /* Start blinking in a while */
                vfSkipNextBlink = TRUE;

                fInsertOn = xpFirst >= xpMin;
                }

DidntHighlight:;
            }
        }

#ifdef SMFONT
    /* Invert the selection */
    if (dxpSel != 0) {
        PatBlt(hDC, xpSel, ypLine, dxpSel, dyp, DSTINVERT);
    }
#else /* not SMFONT */
    /* Blt the line of text onto the screen. */
    PatBlt(vhMDC, 0, 0, xpSelBar, dyp, vfMonochrome ? ropErase : WHITENESS);
    if (dxpSel == 0)
        {
        BitBlt(hDC, 0, ypLine, xpMac, dyp, vhMDC, 0, 0, SRCCOPY);
        }
    else
        {
        BitBlt(hDC, 0, ypLine, xpSel, dyp, vhMDC, 0, 0, SRCCOPY);
        BitBlt(hDC, xpSel, ypLine, dxpSel, dyp, vhMDC, xpSel, 0, NOTSRCCOPY);
        xpSel += dxpSel;
        BitBlt(hDC, xpSel, ypLine, xpMac - xpSel, dyp, vhMDC, xpSel, 0,
          SRCCOPY);
        }
#endif /* SMFONT */

    /* Draw the insertion bar if necessary. */
    if (fInsertOn)
        {
        DrawInsertLine();
        }
#if defined(JAPAN) & defined(DBCS_IME)    // Set a flag for IME management.
    else
    {
        bClearCall = TRUE;
    }
#endif

DrawMark:
    /* Draw the character in the style bar if necessary. */
    if (chMark != '\0')
        {
#ifdef SYSENDMARK

#ifdef  DBCS    // prepare buf for double-byte end mark.
        CHAR               rgch[cchKanji];
#endif

        struct CHP         chpT;
        extern struct CHP  vchpNormal;

        blt(&vchpNormal, &chpT, cwCHP);
        chpT.ftc     = ftcSystem;
        chpT.ftcXtra = 0;
        chpT.hps     = hpsDefault;

        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, &chpT, mdFontScreen);

#ifdef  DBCS    // we use double byte end mark.
#if defined(JAPAN) || defined(KOREA)  /*t-yoshio May 26,92*/
#if defined(KOREA)
            {
                int iPrevBkMode;
                iPrevBkMode = SetBkMode(hDC, OPAQUE);
                TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
                        (LPSTR)&chMark, 1);
                SetBkMode(hDC, iPrevBkMode);
            }
#else
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
                (LPSTR)&chMark, 1);
#endif
#else
        rgch[0] = chMark1;
        rgch[1] = chMark;

    rcOpaque.left = 0;
    rcOpaque.right = DxpFromCh(chMark1,FALSE);
    rcOpaque.top = ypLine;
    rcOpaque.bottom = ypLine+dyp;

    /* When this line string is lower than system font,it remains dust,
        so we must clip this mark. */
    ExtTextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
            ETO_CLIPPED, (LPRECT)&rcOpaque,(LPSTR)rgch, cchKanji, (LPSTR)NULL);
#endif /*JAPAN*/
#else

        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
                (LPSTR)&chMark, 1);
#endif  /* DBCS */

#else /* ifdef SYSENDMARK */

/*T-HIROYN sync 3.0 disp.c */
#if 0
        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, NULL, mdFontScreen);
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
          (LPSTR)&chMark, 1);
#endif
#if defined(JAPAN) || defined(KOREA)     /* KenjiK '90-10-26 */
        /* Draw the style character in the standard font. */
        {
        CHAR    rgch[cchKanji];

            LoadFont(vfli.doc, NULL, mdFontScreen);
            rgch[0] = chMark1;
            rgch[1] = chMark;
#if defined(KOREA)
            {
                int iPrevBkMode;
                iPrevBkMode = SetBkMode(hDC, OPAQUE);
        ExtTextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,ETO_CLIPPED, (LPRECT)&rcOpaque,(LPSTR)rgch, cchKanji, (LPSTR)NULL);
                SetBkMode(hDC, iPrevBkMode);
            }
#else
        ExtTextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,ETO_CLIPPED, (LPRECT)&rcOpaque,(LPSTR)rgch, cchKanji, (LPSTR)NULL);
#endif
    }
#else   /* JAPAN */
        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, NULL, mdFontScreen);
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
          (LPSTR)&chMark, 1);
#endif  /* JAPAN */

#endif /* if-else-def SYSENDMARK */
        }

    if (vfli.fGraphics)
        {
        DisplayGraphics(ww, dl, fDontDisplay);
        }

Finished:
    Scribble(5,' ');
    }


/* D X P  D I F F */
DxpDiff(dcpFirst, dcp, pdxpFirst)
int dcpFirst;
int dcp;
int *pdxpFirst;
{
#if 1
    register int *pdxp = &vfli.rgdxp[0];
    register int cch;
    int dxp = vfli.xpLeft;
#ifdef ENABLE   /* Not used */
    int ichLim = dcpFirst + dcp;
#endif

    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        //Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    for (cch = 0; cch < dcpFirst; ++cch)
        {
        dxp += *pdxp++;
        }
    *pdxpFirst = dxp;
    dxp = 0;
    for (cch = 0; cch < dcp; ++cch)
        {
        dxp += *pdxp++;
        }
    return dxp;
#else

    int dxp;
    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    /* first get space up to first character */
    *pdxpFirst = LOWORD(GetTextExtent(hDC,vfli.rgch,dcpFirst)) + vfli.xpLeft;

    /* now get space between first and first+dcp */
    dxp = LOWORD(GetTextExtent(hDC,vfli.rgch+dcpFirst,dcp));
    return dxp;
#endif
}


UpdateDisplay(fAbortOK)
int fAbortOK;
{
    int ww;

    if (wwMac <= 0)
        {
        return;
        }

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ww++)
        if ( rgwwd[ww].doc != docScrap )
            {
            UpdateWw(ww, fAbortOK);
            if (rgwwd[ww].fDirty || vfOutOfMemory)
                {
                return; /* update has been interrupted */
                }
            }
#else /* not CASHMERE */
    UpdateWw(wwDocument, fAbortOK);
    if (wwdCurrentDoc.fDirty || vfOutOfMemory)
        {
        /* Update has been interrupted */
        return;
        }
#endif /* not CASHMERE */

    if (wwdCurrentDoc.fRuler)
        {
        UpdateRuler();
        }
}


/* U P D A T E  W W */
UpdateWw(ww, fAbortOK)
int ww, fAbortOK;
{ /* Redisplay ww as necessary */
    extern int vfWholePictInvalid;
    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlOld, dlNew;
    int doc;
    int ichCp;
    struct EDL *pedlNew;
    register struct EDL *pedl;
    struct EDL (**hdndl)[]=pwwd->hdndl;
    int dypDiff;
    int ypTop;
    int ypFirstInval;
    int dr;
    int fLastNotShown;
    typeCP cp, cpMacWw;

    if (!pwwd->fDirty)
        {
        return;
        }

    if (!((**hpdocdod)[pwwd->doc].fDisplayable))
        return;

    if (fAbortOK && FImportantMsgPresent())
        return;

#if 0  // how to get first and last cp's in invalid rect?
#if defined(OLE)
    /*
        Load visible objects.  Do it now rather than in DisplayGraphics()
        because here it has less chance of disrupting the state variables
        upon which UpdateWw depends.
    */
    ObjEnumInRange(docCur,cpMinCur,cpMacCur,ObjLoadObjectInDoc);
#endif
#endif

    dlMac = pwwd->dlMac;
    ypTop = pwwd->ypMin;

    Assert( ww >= 0 && ww < wwMax );
    vfli.doc = docNil;  /* An aid to Fast Insert */

    UpdateInvalid();    /* InvalBand for what Windows considers to be invalid */
    ypFirstInval = pwwd->ypFirstInval;

#ifndef CASHMERE
    Assert( ww == wwCur );  /* A MEMO-only assumption */
#endif /* CASHMERE */

    Scribble(5, 'U');

    ValidateMemoryDC();      /* to do any update, we need a good memory DC */
    if (vhMDC == NULL)
        {
        WinFailure();
        return;
        }

    doc = pwwd->doc;
    vfli.doc = docNil;

    if (pwwd->fCpBad)
        {
/* cp first displayed has not been blessed */

#ifdef CASHMERE     /* Must do this if ww != wwCur assertion is FALSE */
        int wwT = wwCur;
        if (ww != wwCur && wwCur >= 0)
/* CtrBackTrs cache is only good for wwCur. Treat != case */
            {
            if (pwwdCur->fDirty) /* Do wwCur first, saving cache */
                UpdateWw(wwCur, fAbortOK);

            if (fAbortOK && FImportantMsgPresent())
                return;

            ChangeWw(ww, false);
            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            ChangeWw(wwT, false);
            }
        else
#endif /* CASHMERE */

            {
            if (fAbortOK && FImportantMsgPresent())
                return;

            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            }
        }

/* check for cpMin accessible in this ww */
RestartUpdate:
    vfWholePictInvalid = fTrue; /* Tells DisplayGraphics to
                                   abandon accumulated partial pict rect */
    fLastNotShown = fFalse;
    cp = CpMax(pwwd->cpMin, pwwd->cpFirst);
    cpMacWw = pwwd->cpMac;
    ichCp = pwwd->ichCpFirst;

        /* Note test for dlNew==0 that guarantees that there will be at least
           one dl -- this was added for WRITE because we do not have
           the ability to enforce a minimum window size */

    for (dlNew = dlOld = 0; ypTop < pwwd->ypMac || (dlNew == 0) ; dlNew++)
        /* we have: cp, ichCP: pints to text desired on the coming line dlNew
         ypTop: desired position for top of dlNew -1
         dlOld: next line to be considered for re-use
        */
        /* check for having to extend dndl array */
        {
        if (dlNew >= (int)pwwd->dlMax)
            {
/* extend the array with uninitialized dl's, increment max, break if no space.
We assume that dlMac(Old) was <= dlMax, so the dl's will not be looked at
but used only to store new lines */
#define ddlIncr 5

            if (!FChngSizeH(hdndl, (pwwd->dlMax + ddlIncr) * cwEDL, fFalse))
                break;
            pwwd->dlMax += ddlIncr;
            }
/* discard unusable dl's */
        for (; dlOld < dlMac; dlOld++)
            { /* Set dlOld and pedl to the next good dl */
            int ypTopOld, ypOld;

                /* Re-entrant Heap Movement */
            if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
                goto RetInval;

            pedl = &(**hdndl)[dlOld];
            ypOld = pedl->yp;

/* loop if: invalid, passed over in cp space, passed over in dl space,
passed over in yp space,
in invalid band, passed over in ich space */
            if (!pedl->fValid || dlOld < dlNew || pedl->cpMin < cp
                || (ypTopOld = (ypOld - pedl->dyp)) < ypTop
                || (ypOld >= ypFirstInval && ypTopOld <= pwwd->ypLastInval)
                || (pedl->cpMin == cp && pedl->ichCpMin < ichCp))
                continue;
/* now we have dlOld, an acceptable if not necessarily useful dl.
now compute dlNew either from scratch or by re-using dlOld. To be
re-useable, dlOld must have right cp/ichCp pair, plus be totally on screen
or, if it is a partial line, it must stay still or move down - not up */
            if (pedl->cpMin == cp && pedl->ichCpMin == ichCp &&
                (ypOld <= pwwd->ypMac || ypTopOld <= ypTop))
                {
/* Re-use this dl */
                int yp = ypTop;
                if (fLastNotShown)
                    {
                        /* HEAP MOVEMENT */
                    DisplayFli(ww, dlNew - 1, fLastNotShown = fFalse);
                    pedl = &(**hdndl)[dlOld];
                    }

                cp = pedl->cpMin + pedl->dcpMac;
                ichCp = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                ypTop += pedl->dyp;
                if (dlOld != dlNew || ypTopOld != yp)
                    {
                    DypScroll(ww, dlOld, dlNew - dlOld, yp);
                    if (vfScrollInval)
                        {
                        /* There was a popup; invalid region might have changed */
                        /* fLastNotShown test is for interrupting picture display */
                        /* before we've really displayed it */

                        (**hdndl) [dlOld].fValid = fFalse;
                        goto Restart1;
                        }
                    dlMac += dlNew - dlOld;
                    }
                dlOld = dlNew + 1;
                goto NextDlNew;
                }
            break;
            }
/* cpMin > cp, the line is not anywhere so it will have to be formatted
from scratch */

        if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
            goto RetInval;

        FormatLine(doc, cp, ichCp, cpMacWw, flmSandMode);  /* Creates vfli */

    if (vfOutOfMemory)
            goto RetInval;

        ichCp = vfli.ichCpMac;
        cp = vfli.cpMac;
/* advance invalid band so that update can resume after an interruption */
        pwwd->ypFirstInval = (ypTop += vfli.dypLine);
        pedl = &(**hdndl)[dlOld];
        if (dlOld < dlMac && pedl->cpMin == cp && pedl->ichCpMin == ichCp)
            {
            int dlT = dlOld;

/* line at dlOld is a valid, existing line that will abutt the line just about
to be displayed. */
            if (dlOld == dlNew && pedl->yp - pedl->dyp <= ypTop)
/* the line about to be overwritten will be re-used in the next loop.
Hence, it is worthwhile to save this line and its dl */
                DypScroll(ww, dlOld++, 1, ypTop);
            else
/* Move the next line to its abutting position. We know that it has not yet been
overwritten (yp, dlOld all > than ypTop, dlNew) */
                DypScroll(ww, dlOld, 0, ypTop);

            if (vfScrollInval)
                {
                /* There was a popup; invalid region might have changed */
                /* fLastNotShown test is for interrupting picture display */
                /* before we've really displayed it */

                (**hdndl) [dlT].fValid = fFalse;
Restart1:
                if (fLastNotShown)
                    {
                    pwwd->ypFirstInval = pwwd->ypMin;
                    }

                ypFirstInval = pwwd->ypFirstInval;
                ypTop = pwwd->ypMin;
                goto RestartUpdate;
                }
            }

/* true in 3rd param means put off picture redisplay till later */
/* condition: graphics & not last in picture & not last in y space and
not in front of a invalid or valid transition in the picture */
        DisplayFli(ww, dlNew, fLastNotShown =
                  (vfli.fGraphics && vfli.ichCpMac!=0 && ypTop < pwwd->ypMac));
NextDlNew:;
        }
Break1:
    pwwd->dlMac = dlNew;

#ifdef CASHMERE
/* condition is here to avoid swapping */
    if (pwwd->fSplit && rgwwd[pwwd->ww].fFtn)
        CalcFtnLimits(pwwd);
#endif /* CASHMERE */

    SetCurWwVScrollPos();    /* Set Scroll bar position */
    vfTextBltValid = false;

/* reset invalid indications */
    pwwd->fDirty = false;
    pwwd->ypFirstInval = ypMaxAll;
    pwwd->ypLastInval = 0; /* so that max in InvalBand will work */
    Scribble(5, ' ');
    goto Validate;

/* Before returning from an interrupt, invalidate lines that were overwritten
within the present update. */
RetInval:
    Scribble(5, ' ');
    for (; dlOld < dlMac; dlOld++)
        {
        pedl = &(**hdndl)[dlOld];
        if ((pedl->yp - pedl->dyp) < ypTop)
            pedl->fValid = fFalse;
        else
            break;
        }
Validate: ;

#ifdef ENABLE   /* We will let UpdateInvalid handle this in case
                   further invalidation occurred during the update */

    {           /* Tell Windows that the part we updated is valid */
    RECT rc;

    rc.left = 0;
    rc.top = pwwd->ypMin;
    rc.right = pwwd->xpMac;
    rc.bottom = imin( pwwd->ypMac, ypTop );
    ValidateRect( pwwd->wwptr, (LPRECT)&rc );
    }
#endif
}




/* D Y P  S C R O L L */
DypScroll(ww, dlFirst, ddl, ypTo)
int ww, dlFirst, ddl, ypTo;
{
/* Scroll dl's in a window, from dlFirst to end, down ddl lines (or up -ddl).
Bitmap is moved from top of dlFirst to ypTo.   The yp's of the dl's are updated.
Returns the amount scrolled. (positive means down). */

    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlT;
    int ypFrom;
    int dypChange;
    int cdlBelow;
    struct EDL *pedl;
    struct EDL *pedlT;

    /* Do not call procedures while dndl is loaded up to avoid heap movement */
    struct EDL *dndl = &(**(pwwd->hdndl))[0];

    Assert( ww >= 0 && ww < wwMax );

    vfScrollInval = fFalse;

    /* Number of dl's below (and including) the first one to be scrolled */
    cdlBelow = pwwd->dlMac - dlFirst;
    pwwd->dlMac = min(pwwd->dlMac + ddl, pwwd->dlMax);
    cdlBelow = max(0, min(cdlBelow, pwwd->dlMac - ddl - dlFirst));

    pedlT = &dndl[dlFirst];
    ypFrom = pedlT->yp - pedlT->dyp;

    /* Length of area to be moved */
    dypChange = ypTo - ypFrom;

    if (cdlBelow > 0)
        {
        int dlTo = dlFirst + ddl;
        int ypMac = pwwd->ypMac;

        pedlT = &dndl[dlTo];
        if (ddl != 0)
            {
            blt(&dndl[dlFirst], pedlT, cwEDL * cdlBelow);
            }

        for (dlT = dlTo; dlT < pwwd->dlMac; ++dlT, ++pedlT)
            {
            if (dypChange < 0 && pedlT->yp > ypMac)
                {
                /* Invalidate dl's that are pulled in from the ozone below ypMac
                */
                pedlT->fValid = fFalse;
                }
            else
                {
                pedlT->yp += dypChange;
                }
            }
        }

    if (dypChange != 0)
        {
        RECT rc;

        SetRect( (LPRECT)&rc, 0, min(ypFrom, ypTo),
                              pwwd->xpMac, pwwd->ypMac );
        Assert( ww == wwCur );      /* A MEMO-only assumption */
        ScrollCurWw( &rc, 0, dypChange );
        }

    return dypChange;
}




FImportantMsgPresent()
{
/* If the next message is important enough to interrupt a screen update, we
   return TRUE; if it can wait, we return FALSE */

    BOOL fToggledKey;
    extern MSG vmsgLast;

#ifdef DEBUG
    unsigned wHeapVal = *(pLocalHeap + 1);

    Assert( wHeapVal == 0 );   /* Heap should not be frozen */
#endif

#ifdef DBCS
 if( donteat )
     return TRUE;
#endif

while (PeekMessage((LPMSG) &vmsgLast, NULL, NULL, NULL, PM_NOREMOVE))
    {
#if defined(JAPAN) & defined(DBCS_IME)
/*  If IME Cnv window open,we have to avoid ourselves to get into AlphaMode.
** So we do getmessage here to fill vmsgLast with app queue message.
*/
    extern BOOL bImeCnvOpen;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    if( bImeCnvOpen || vfImeHidden) {
#else
    if( bImeCnvOpen ) {
#endif  //JAPAN & IME_HIDDEN
        GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
        donteat = TRUE;
        return  TRUE;
    }
#endif

/*T-HIROYN sync 3.1 disp.c */
#if 0
    /* Filter uninteresting or easily handled events */
    if (fToggledKey = FCheckToggleKeyMessage(&vmsgLast) ||
       (vmsgLast.message == WM_KEYUP && vmsgLast.hwnd == wwdCurrentDoc.wwptr))
        {

    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
            return TRUE;
#endif

#ifdef JAPAN  // 03/22/93
#ifdef PENWIN // 03/22/93
    if (((vmsgLast.message == WM_KEYDOWN) || (vmsgLast.message == WM_KEYUP)
        || (vmsgLast.message == WM_SYSKEYDOWN) || (vmsgLast.message == WM_SYSKEYUP))
        && ((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
#else //PENWIN
    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
#endif
#elif defined(KOREA)
#define VK_PROCESSKEY 0xE5 // New finalize message. bklee.
// bug #3191, In HWin3.1, WM_NCLBUTTONDOWN message is reached this if statement. 
// Because HTBOTTOMDOWN's value is same with VK_CONTROL's, we can't resize write window
    if (((vmsgLast.message == WM_KEYDOWN) || (vmsgLast.message == WM_KEYUP)
        || (vmsgLast.message == WM_SYSKEYDOWN) || (vmsgLast.message == WM_SYSKEYUP))
        && ((vmsgLast.wParam == VK_MENU) ||
            (vmsgLast.wParam == VK_CONTROL) ||
            (vmsgLast.wParam == VK_PROCESSKEY) ))
#else //JAPAN
    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
#endif
    {
        if (vmsgLast.wParam == VK_CONTROL)
        {
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            SetShiftFlags();
        }
        return TRUE;
    }
    /* Filter uninteresting or easily handled events */
    else if (fToggledKey = FCheckToggleKeyMessage(&vmsgLast) ||
       (vmsgLast.message == WM_KEYUP && vmsgLast.hwnd == wwdCurrentDoc.wwptr))
        {

        /* This is so the Windows keyboard interface mechanism will see toggle
        key and key-up transitions */
        GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
#ifdef WIN30
        /* PeekMessage has been changed in Win 3.0 so that GetKeyState()
           called from FCheckToggleKeyMessage() is really only valid if
           you've done a PeekMessage(...,PM_REMOVE) or GetMessage() first.
           That is, while the FCheckToggleKeyMessage() call might succeed
           above, it will NOT have set the vfShiftKey/vfCommandKey flags
           correctly -- so we do it here ..pault */
        if (fToggledKey)
            FCheckToggleKeyMessage(&vmsgLast);
#endif
        if (vmsgLast.hwnd != wwdCurrentDoc.wwptr)
            {
            /* Just in case a modeless dialog's window proc cares */
            TranslateMessage((LPMSG)&vmsgLast);
            DispatchMessage((LPMSG)&vmsgLast);
            }
#ifdef DBCS /* I hate it */
    if (vmsgLast.message == WM_CHAR
#ifdef  JAPAN
        //  We've been reported by one of OEM about LED not disapearing
        // problem.
        //  they know it is bug of write. So I added this code from win2.x
        // write source.    27 sep 91 Yutakan
       ||  (vmsgLast.message == WM_KEYUP && vmsgLast.wParam == VK_KANA)
#endif
#ifdef  KOREA
       || vmsgLast.message == WM_INTERIM
#endif
       || vmsgLast.message == WM_KEYDOWN) {

            donteat = TRUE;
            return( TRUE );
        } /* else Ok, you are KEYUP message. do normal */
#endif
        }
    else
        {
        switch (vmsgLast.message)
            {
        case WM_MOUSEMOVE:
#ifdef  KOREA
    case WM_NCMOUSEMOVE:
#endif
            /* Process mouse move messages immediately; they are not really
            important.  NOTE: This assumes that we have not captured all mouse
            events; in which case, they are important. */
            DispatchMessage((LPMSG)&vmsgLast);

        case WM_TIMER:
        case WM_SYSTIMER:
            /* Remove timer and mouse move messages from the queue. */
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            break;

        default:
            Assert( *(pLocalHeap+1) == 0 ); /* Heap should still not be frozen */
            return (TRUE);
            }
        }
    }


Assert( *(pLocalHeap + 1) == 0 );   /* Heap should still not be frozen */
return (FALSE);
}


/* C P  B E G I N  L I N E */
typeCP CpBeginLine(pdl, cp)
int *pdl;
typeCP cp;
    { /* return the cp and dl containing cp */
    int dlMin, dlLim;
    typeCP cpGuess;
    struct EDL *dndl;

    do
        {
        UpdateWw(wwCur, false);
        PutCpInWwVert(cp); /* Ensure cp on screen */
        } while (pwwdCur->fDirty && !vfOutOfMemory);

    dndl = &(**(pwwdCur->hdndl))[0];
    dlMin = 0;
    dlLim = pwwdCur->dlMac;
    while (dlMin + 1 < dlLim)
        { /* Binary search the ww */
        int dlGuess = (dlMin + dlLim) >> 1;
        struct EDL *pedl = &dndl[dlGuess];
        if ((cpGuess = pedl->cpMin) <= cp && (cpGuess != cp || pedl->ichCpMin == 0))
            { /* guess is low or right */
            dlMin = dlGuess;
            if (cp == cpGuess && pedl->cpMin + pedl->dcpMac != cp)
                break;  /* Got it right */
            }
        else  /* Guess is high */
            dlLim = dlGuess;
        }
    *pdl = dlMin;
    return dndl[dlMin].cpMin;
}




/* T O G G L E  S E L */
ToggleSel(cpFirst, cpLim, fOn)
typeCP cpFirst, cpLim; /* selection bounds */
int fOn;
{ /* Flip selection highlighting on and off */
    extern int vfPMS;
    struct EDL *pedl;
    int dlT;
    int xpMin;
    int dxpRoom;
    int xpFirst;
    int xpLim;
    int fInsertPoint = (cpFirst == cpLim);

    if (vfSelHidden || cpFirst > cpLim || cpLim < /*cp0*/ cpMinCur || vfDead)
        return;

    if ( vfPictSel && vfPMS &&
         (CachePara( docCur, cpFirst ), vpapAbs.fGraphics) &&
         (vcpLimParaCache == cpLim) )
        {   /* Don't show inversion if we're moving or sizing a picture */
        return;
        }

    dxpRoom = pwwdCur->xpMac - xpSelBar;
    xpMin = pwwdCur->xpMin;


    for (dlT = 0; dlT < pwwdCur->dlMac; dlT++)
        {
        typeCP cpMin, cpMac; /* line bounds */
        pedl = &(**(pwwdCur->hdndl))[dlT];
        if (!pedl->fValid)
            continue;
        cpMin = pedl->cpMin;
        if (cpMin > cpLim || cpMin > cpMacCur || (cpMin == cpLim && cpLim != cpFirst))
            break;
        cpMac = cpMin + pedl->dcpMac;
        if (cpFirst <= cpMin && cpLim >= cpMac)
            {
/* entire line is highlighted */
            xpFirst = pedl->xpLeft;
            if (pedl->fGraphics && cpLim == cpMac && cpMin == cpMac)
                /* Special kludge for graphics paras */
                xpLim = xpFirst;
            else
                xpLim = pedl->xpMac;
            }
        else if (fInsertPoint && cpFirst == cpMac && vfInsEnd)
            { /* Special kludge for an insert point at the end of a line */
            xpLim = xpFirst = pedl->xpMac;
            }
        else if (cpFirst < cpMac)
            {
            /* Bite the bullet */
            int dxp;
            typeCP  cpBegin = CpMax(cpMin, cpFirst);
            typeCP  cpEnd = CpMin(cpMac, cpLim);

            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            dxp = DxpDiff((int) (cpBegin - cpMin),
                (int) (cpEnd - cpBegin), &xpFirst);
            xpLim = xpFirst + dxp;
/* reload pedl because procedures were called */
            pedl = &(**(pwwdCur->hdndl))[dlT];
            }
        else
            continue;
/* now we have: pedl valid, xpFirst, xpLast describe highlight */
         /* xpFirst = max(xpFirst, xpMin); */
        xpLim = min(xpLim, xpMin + pedl->xpMac);
        if (xpLim > xpFirst)
            {
            if (xpLim > xpMin)
                {
                RECT rc;
                rc.top = pedl->yp - pedl->dyp;
                rc.left = xpSelBar + max(xpFirst - xpMin, 0);
                rc.bottom = pedl->yp;
                rc.right = xpSelBar + xpLim - xpMin;
                InvertRect( wwdCurrentDoc.hDC, (LPRECT)&rc);
                }
            }
/* ToggleSel modified 7/28/85 -- added explicit check for fInsertPoint, since
   the xpLim == xpFirst test sometimes succeeded bogusly when a selection
   was extended backwards. BL */
        else if (fInsertPoint && (xpLim == xpFirst))     /* Insertion point */
            {
            /* vfli should usually be cached already, so will be fast. */
            int yp = pedl->yp;

            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            if (fOn ^ vfInsertOn)
                {
                if (!vfInsertOn)
                    {
                    vxpCursLine = xpSelBar + xpFirst - xpMin;
                    vypCursLine = yp - vfli.dypAfter;
                    vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
                        /* Start blinking in a while */
                    vfSkipNextBlink = TRUE;
                    }
                DrawInsertLine();
                }
            return;
            }
        }
}




/* T R A S H  W W */
TrashWw(ww)
{ /* Invalidate all dl's in ww */
    Assert( ww >= 0 && ww < wwMax );
    InvalBand(&rgwwd[ww], 0, ypMaxAll);
}




/* I N V A L  B A N D */
/* invalidate the band ypFirst, ypLast inclusive */
InvalBand(pwwd, ypFirst, ypLast)
struct WWD *pwwd; int ypFirst, ypLast;
    {
/* this covers some peculiar rects received from update event after a
window resize by 1 pixel. CS */
    if (ypLast < 0 || ypFirst == ypLast) return;

    pwwd->fDirty = true;
    pwwd->ypFirstInval = min(pwwd->ypFirstInval, ypFirst);
    pwwd->ypLastInval = max(ypLast, pwwd->ypLastInval);
    }




/* T R A S H  A L L  W W S */
TrashAllWws()
{ /* trash them all */
    int     ww;

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ++ww)
        TrashWw(ww);
#else
    TrashWw( wwDocument );
#endif
    vfli.doc = docNil;  /* Mark vfli invalid */
}


/* T U R N  O F F  S E L */
TurnOffSel()
{ /* Remove sel highlighting from screen */
/* HideSel has no effect */
    if (!vfSelHidden)
        {
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfSelHidden = true;
        }
}

#ifdef  JAPAN

/* We handle IME convert window. */

//int FontHeight = 0; 01/19/93
// 03/29/93 int ImePosSize = 0; //01/19/93
int ImePosSize = 256; //03/29/93 #5484
BOOL    bGetFocus = FALSE;
// Handle to the IME communication block - 061491 Yukini
HANDLE  hImeMem = NULL;

// to prevent unwanted caret traveling - 061591 Yukini
BOOL    bForceBlock = FALSE;
// To avoid ilreagal setting for IME rectangle
static  BOOL bResetIMERect=FALSE;
static  BOOL bDefaultBlock = FALSE; //IME3.1J t-hiroyn

/*
 * ForceImeBlock controls IME input display to the screen.
 * When Write program is writing string to the screen, the caret
 * doesn't move with string. After completing text display,
 * then caret is moved to appropriate position. During this
 * period, if user type something by using IME, char is displayed on the
 * screen. This makes mixing ugly result. This routine will
 * prevent this. Yukini
 */
void ForceImeBlock( hWnd, bFlag )
HWND hWnd;
BOOL bFlag;
{
    WORD x, y;
    LPIMESTRUCT lpmem;

    if (bForceBlock = bFlag) {
        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            /* Move bounding rectangle to out of the world */
            lpmem->fnc = IME_MOVECONVERTWINDOW;
            x = GetSystemMetrics(SM_CXSCREEN);
            y = GetSystemMetrics(SM_CYSCREEN);
            lpmem->wParam = MCW_SCREEN | MCW_RECT;
#if 1 //01/19/93
            lpmem->lParam1 = (DWORD)MAKELONG(x+x/2,y+y/2);
            lpmem->lParam2 = (DWORD)MAKELONG(x+x/2,y+y/2);
            lpmem->lParam3 = (DWORD)MAKELONG(x*2,y*2);
#else
            lpmem->lParam1 = (DWORD)MAKELONG(x+1,y+1);
            lpmem->lParam2 = (DWORD)MAKELONG(x+1,y+1);
            lpmem->lParam3 = (DWORD)MAKELONG(x*2,y*2);
#endif
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
            bResetIMERect = FALSE;
        }
    }
}

void DefaultImeBlock(hWnd)
HWND hWnd;
{
    LPIMESTRUCT lpmem;

    if (bDefaultBlock == FALSE) {
        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            /* Move bounding rectangle to default */
            lpmem->fnc = IME_MOVECONVERTWINDOW;
            lpmem->wParam = MCW_DEFAULT;
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
            bResetIMERect = FALSE;
        }
    }
}

/* use these veriables to optimize IME call. This will prevent task switching
 * overhead. - Yukini
 */
static RECT rcOldRect = {-1, -1, -1, -1};
static DWORD dwCurpos = -1;
static WORD      wModeMCW = MCW_DEFAULT;

void    SetIMEConvertWindow(hWnd,x,y,bFlag)
HWND    hWnd;
int     x,y;
BOOL    bFlag;
{
    LPIMESTRUCT lpmem;
    //Yukini:HANDLE hIMEBlock;
    DWORD dwXY = MAKELONG(x,y);
    BOOL  bRetSendIme;
    RECT rcRect;
    extern BOOL bImeCnvOpen;    // Yutakan:08/06/91

    /* Do nothing if in text drawing to the screen */
    if (bForceBlock)
        return;

    /* we allocate the Ime communication area. freeing of this
     * area will be done by wrap up routine MmwDestroy() of Quit.C.
     * This will improve the performance than previous code. - Yukini
     */
    if (hImeMem == NULL) {
        if ((hImeMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE|GMEM_LOWER,
                (DWORD)sizeof(IMESTRUCT))) == NULL)
            return; // something wrong
    }
//Yukini:   /* Get comunication area with IME */
//Yukini:   hIMEBlock=GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
//Yukini:           (DWORD)sizeof(IMESTRUCT));
//Yukini:   if(!hIMEBlock)  return;

    if(!bGetFocus)
        bFlag = FALSE;

    GetWindowRect(hWnd,&rcRect);

// [yutakan:08/06/91]   IF out of Window Rect, force MCW_DEFAULT.
//  if(rcRect.top > y || rcRect.bottom < y) bFlag = TRUE;
//
    if (bFlag) {

/*   Add ResetIMERect check . If we've not done MOVECONVERTWINDOW after
**  ForceIMEblock(), don't pass by SendIMEMessage to avoid ilreagal setting
**  for bounding rectangle. [Yutakan.]
*/
        // bResetIMERect FALSE when just after ForceImeBlock()
        if ( bResetIMERect == TRUE
            && dwCurpos == dwXY && EqualRect(&rcRect, &rcOldRect)){
            //OutputDebugString("Write:optimized\r\n");
            return;
        }
    } else
        dwCurpos = -1;  // invalidate cache

//Yukini:   lpmem       = (LPIMESTRUCT)GlobalLock(hIMEBlock);
//Yukini:   lpmem->fnc  = IME_MOVECONVERTWINDOW;
//Yukini:   lpmem->wParam   = bFlag?MCW_WINDOW:MCW_DEFAULT;
//Yukini:   lpmem->lParam1  = (DWORD)MAKELONG(x,y);
//Yukini:   GlobalUnlock(hIMEBlock);
//Yukini:   SendIMEMessage(hWnd,MAKELONG(hIMEBlock,NULL));
//Yukini:   GlobalFree(hIMEBlock);

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    if(vfImeHidden) {
        DWORD dwXY1, dwXY2, dwXY3;
        int     x1,x2,x3,y1,y2,y3;
        RECT hiRect;

        //12/28/92
        if(whileUndetermine == TRUE) // we are managing IR_UNDETERMINE
            return;

        CopyRect(&hiRect, &rcRect);

        if(x < 0) x = 0;

        x1 = x + hiRect.left;
        y1 = (vypCursLine - vdypCursLine) + hiRect.top;

        if(y1 < 0) y1 = 0;

        x2 = hiRect.left;

        if(HiddenTextTop == 0)
            y2 = y1;
        else
            y2 = hiRect.top + HiddenTextTop;

        x3 = hiRect.right;
        if(vdypCursLine <= 0)
            y3 = y1 + (19+1);
        else {
            if(HiddenTextBottom == 0)
                y3 = y1 + (vdypCursLine+1);
            else
                y3 = hiRect.top + HiddenTextBottom + 1;

            if(y3 < (y1 + (vdypCursLine+1)))
                y3 = y1 + (vdypCursLine+1);
        }

        if(y2 > y1)
            y2 = y1;

        if(x3 <= x1 || y3 <= y1)
            goto dontHidden;
        if(x3 <= x2 || y3 <= y2)
            goto dontHidden;

        dwXY1 = MAKELONG(x1, y1);
        dwXY2 = MAKELONG(x2, y2);
        dwXY3 = MAKELONG(x3, y3);

        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            lpmem->fnc = IME_MOVECONVERTWINDOW;
            lpmem->wParam = MCW_HIDDEN;
            dwCurpos = dwXY;
            CopyRect(&rcOldRect, &rcRect);
            lpmem->lParam1 = dwXY1;
            lpmem->lParam2 = dwXY2;
            lpmem->lParam3 = dwXY3;
            GlobalUnlock(hImeMem);
            bResetIMERect = TRUE;
            if(MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL))) {
                vfImeHidden = 1; //Hidden OK
                return;
            } else {
                vfImeHidden = 0; //Hidden ERR we set MCW_WINDOW
            }
        }
    }

dontHidden:
    if(selUncpLim > selUncpFirst) {
        return;
    }
#endif

    if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
        lpmem->fnc = IME_MOVECONVERTWINDOW;
        if ((lpmem->wParam = bFlag ? MCW_WINDOW : MCW_DEFAULT) == MCW_WINDOW) {
            /* update previous state */
            dwCurpos = dwXY;
            CopyRect(&rcOldRect, &rcRect);
            lpmem->lParam1 = dwXY;
                        wModeMCW = MCW_WINDOW;  //01/25/93
        } else {
                        wModeMCW = MCW_DEFAULT; //01/25/93
                }
        GlobalUnlock(hImeMem);
        if(FALSE == MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL)))
                        wModeMCW = MCW_DEFAULT; //01/25/93

        bResetIMERect = TRUE;   // yutakan:08/06/91
    }
}

HANDLE hImeSetFont = NULL;
BOOL	bImeFontEx = FALSE; //T-HIROYN 02/25/93
SetImeFont(HWND hWnd)
{
    LPIMESTRUCT lpmem;
    HANDLE      hImeLogfont;
    LOGFONT     lf;
    LPLOGFONT   lpLogfont;
    HANDLE      hfont;

    void IMEManage(BOOL);

    //Get IME use LOGFONT
    if (FALSE == GetLogfontImeFont((LPLOGFONT)(&lf)))
        return;

    if(TRUE == bImeFontEx) {
        if ((hImeLogfont = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
                     (DWORD)sizeof(LOGFONT))) == NULL)
            return; // something wrong

        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            lpmem->fnc = IME_SETCONVERSIONFONTEX;
            lpmem->lParam1 = 0L;
            if (lpLogfont = (LPLOGFONT)GlobalLock(hImeLogfont)) {
                bltbx((LPLOGFONT)(&lf), lpLogfont, sizeof(LOGFONT));
                lpmem->lParam1 = MAKELONG(hImeLogfont,NULL);
                GlobalUnlock(hImeLogfont);
            }
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
        }

        GlobalFree(hImeLogfont);

    } else {

        hfont = CreateFontIndirect(&lf);
        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            lpmem->fnc = IME_SETCONVERSIONFONT;
            lpmem->wParam = hfont;
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
        }

        // prev font deleate;
        if(hImeSetFont != NULL) {
            HDC hdc;
            HANDLE oldhfont;

            hdc = GetDC(NULL);
            oldhfont = SelectObject(hdc,hImeSetFont);
            SelectObject(hdc,oldhfont);
            DeleteObject(hImeSetFont);
            ReleaseDC(NULL, hdc);
        }
        hImeSetFont = hfont;
    }

    //display:
    bResetIMERect = FALSE;
    IMEManage( FALSE );
}

int GetLogfontImeFont(lplf)
LPLOGFONT lplf;
{
        extern struct FCE *vpfceScreen;
    extern struct CHP vchpSel;
    struct CHP chp;

    blt(&vchpSel, &chp, cwCHP);  /* CHP for use in comparisons */

    //change CHARSET to KANJI_CHARSET
    {
                int ftc;
        if( ftcNil != (ftc = GetKanjiFtc(&chp))) {
                ApplyCLooks(&chp, sprmCFtc, ftc);
        }
    }

        LoadFont(docCur, &chp, mdFontJam);
    bltbcx(lplf, 0, sizeof(LOGFONT));
        GetObject(vpfceScreen->hfont, sizeof(LOGFONT), lplf);

        //Ime SETCONVERSIONWINDOW set point (vypCursLine - ImePosSize)
        ImePosSize = vfmiScreen.dypBaseline + vfli.dypBase;

        if(chp.hpsPos != 0 ) {
                if (chp.hpsPos < hpsNegMin)
                        ImePosSize += ypSubSuper;
                else
                        ImePosSize -= ypSubSuper;
        }
    return TRUE;
}

void
IMEManage( bFlag )
BOOL bFlag; /* Flag to indicate real default or virtual default in case
           of requesting IME convert line to be default. Real default
           (value TRUE) is selected when I am loosing the focus. In
           this case, IME convert line will be default. Virtual
           default (value FALSE) is selected when I lost a caret
           position. In this case, IME convert line will be out of
           the screen. You can type characters, but not displayed
           to the screen correctly. Yukini
        */
{
int x,y;
BOOL    bCE = ConvertEnable;

/*IME3.1J
        if(!FontHeight)
        {
        TEXTMETRIC  tm;
            GetTextMetrics(wwdCurrentDoc.hDC,&tm);
            FontHeight = tm.tmHeight;
        }
*/
        x = vxpCursLine;
//        y = vypCursLine-(vdypCursLine+FontHeight)/2; IME3.1J
//        y = vypCursLine - FontHeight;

        if(ImePosSize > vdypCursLine)
            y = vypCursLine - vdypCursLine;
        else
            y = vypCursLine - ImePosSize;

        if (x < 0 || y < 0)
            bCE = FALSE;    /* Sometime caret position will be
                       less than zero. Do no set IME
                       window in this case. Yukini */

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
        if (bCE == FALSE && bFlag == FALSE && bForceBlock == FALSE
            && 0 == vfImeHidden) {
#else
        if (bCE == FALSE && bFlag == FALSE && bForceBlock == FALSE) {
#endif
            // get out of the world, babe.
//IME3.1J
            if( vypCursLine > 0 && ImePosSize > vypCursLine ) {
                DefaultImeBlock( wwdCurrentDoc.wwptr);  //t-hiroyn
                bDefaultBlock = TRUE; //IME3.1J
            } else {
                ForceImeBlock( wwdCurrentDoc.wwptr, TRUE );
                bForceBlock = FALSE;
                bDefaultBlock = FALSE; //IME3.1J
            }
// yutakan:08/16/91         dwCurpos = 1;  // invalidate optimize cache
            dwCurpos = -1;
        } else {
            SetIMEConvertWindow(wwdCurrentDoc.wwptr, x, y, bCE);
            bDefaultBlock = FALSE; //IME3.1J
        }
}
#endif  // JAPAN

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J call by MENU selecting.
ChangeImeConversionMode()
{
    extern BOOL bImeCnvOpen;

    vfImeHidden = (vfImeHidden ? 0 : 1);

// 12/28/92   if(vfImeHidden)
//        bImeCnvOpen = TRUE;

    bResetIMERect = FALSE;
    IMEManage( FALSE );
}
#endif

/* D R A W  I N S E R T  L I N E */
DrawInsertLine()
{
#if defined(JAPAN) & defined(DBCS_IME)
    extern BOOL bImeCnvOpen;
#if defined(IME_HIDDEN)
    extern BOOL ImeClearInsert;
#endif
#endif

        /* Draw (in Xor mode) a vertical bar at screen position v*CursLine */
        /* Toggles both the display and the vfInsertOn flag */
        /* Adjustments in cursor draw must be reflected in DisplayFli, above */

            /* Last-minute correction for a bug: assure that the insert line
               does not extend above ypMin */
        if (!vfInsertOn && vdypCursLine > vypCursLine - wwdCurrentDoc.ypMin)
            vdypCursLine = vypCursLine - wwdCurrentDoc.ypMin;

            /* Tell GDI to invert the caret line */

//#3221 01/25/93
#if defined(JAPAN) & defined(DBCS_IME)
#if defined(IME_HIDDEN)
        if(ImeClearInsert || (bImeCnvOpen && wModeMCW == MCW_WINDOW) ) {
#else
        if(bImeCnvOpen && wModeMCW == MCW_WINDOW) {
#endif
            if(vfInsertOn) {
                PatBlt( wwdCurrentDoc.hDC, vxpCursLine,
                 vypCursLine - vdypCursLine, 2, vdypCursLine , DSTINVERT );
                vfInsertOn = 1 - vfInsertOn;
            }
        } else {
            PatBlt( wwdCurrentDoc.hDC, vxpCursLine,
                 vypCursLine - vdypCursLine, 2, vdypCursLine , DSTINVERT );
            vfInsertOn = 1 - vfInsertOn;
        }
#else
        PatBlt( wwdCurrentDoc.hDC, vxpCursLine, vypCursLine - vdypCursLine,
                      2, vdypCursLine , DSTINVERT );
        vfInsertOn = 1 - vfInsertOn;
#endif

/*T-HIROYN sync 3.0 disp.c */
#ifdef  JAPAN   /* KenjiK '90-10-30 */
    if(bClearCall)
    {
        if((vxpCursLine>=0) && (vxpCursLine<=wwdCurrentDoc.xpMac)
        && (vypCursLine>=0) && (vypCursLine<=wwdCurrentDoc.ypMac))
            ConvertEnable = TRUE;

    }
    IMEManage( FALSE );
#endif
}




/* C L E A R  I N S E R T  L I N E */
ClearInsertLine()
{
#if defined(JAPAN) & defined(DBCS_IME)
/* So we do some IME manage when clearning the line */

    if((vxpCursLine<0) || (vxpCursLine>=wwdCurrentDoc.xpMac)
    || (vypCursLine<0) || (vypCursLine>=wwdCurrentDoc.ypMac)) {
        ConvertEnable = FALSE;
        //OutputDebugString("ClearInsertLine\r\n");
    }

    bClearCall = FALSE;

    if ( vfInsertOn)    DrawInsertLine();
    else            IMEManage( FALSE );

    bClearCall = TRUE;

#else
 if ( vfInsertOn) DrawInsertLine();
#endif
}



#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
UndetermineTextOut(HDC hDC, int xp, int yp, PCH ptr, int cch, LPSTR Attrib)
{
    int Length;
    long rgbBack;
    long rgbText;
    int  bkMode;
    PCH ptr1 = ptr;
    TEXTMETRIC tm;

    GetTextMetrics(hDC, &tm);

    bkMode = SetBkMode(hDC, OPAQUE);

    rgbBack = GetBkColor(hDC);
    rgbText = GetTextColor(hDC);
    while( cch ) {
        switch((*Attrib) & 0x03)
        {
            case 1:
                SetBkColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMESPOT]));
                SetTextColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMESPOTTEXT]));
// 12/28/92
                if(HiddenTextTop == 0)
                    HiddenTextTop = yp;

                if(HiddenTextTop > yp)
                    HiddenTextTop = yp;

                if(HiddenTextBottom == 0)
                    HiddenTextBottom = yp + tm.tmHeight;

                if(HiddenTextBottom > (yp + tm.tmHeight))
                    HiddenTextBottom = yp + tm.tmHeight;
                break;
            case 0:
                SetBkColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEINPUT]));
                SetTextColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEINPUTTEXT]));
                break;

            case 2:
            default:
                SetBkColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEOTHER]));
                SetTextColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEOTHERTEXT]));
                break;
        }
        Length = ( (IsDBCSLeadByte((BYTE)(*ptr1)) ) ? 2 : 1 );
        TextOut(hDC, xp, yp, ptr1, Length);
        xp += LOWORD(GetTextExtent(hDC, ptr1, Length));
        xp-=tm.tmOverhang;
        ptr1+=Length;
        Attrib+=Length;
        AttribPos+=Length;
        cch-=Length;
    }
    SetBkColor(hDC,rgbBack);
    SetTextColor(hDC,rgbText);
    SetBkMode(hDC, bkMode);
}
UndetermineString(HDC hDC, int xp, int yp, PCH ptr, int cch, typeCP cpFirst,
                  typeCP cpEnd)
{
    int Length;
    int len = cch;
    PCH ptr1;
    TEXTMETRIC tm;

    GetTextMetrics(hDC, &tm);
    ptr1 = ptr;

    if((cpEnd <= selUncpFirst) || (cpFirst >= selUncpLim))
        TextOut(hDC, xp, yp, ptr1, len);
    else {
        Attrib = GlobalLock(hImeUnAttrib);

        if(cpFirst < selUncpFirst) {
            Length = selUncpFirst - cpFirst;
            TextOut(hDC, xp, yp, ptr1, Length);
            xp+=LOWORD(GetTextExtent(hDC, ptr1, Length));
            xp-=tm.tmOverhang;
            len-=Length;
            ptr1+=Length;
        }
        if(selUncpLim <= cpEnd) {
            if(cpFirst > selUncpFirst) {
                Length = (int)(selUncpLim - cpFirst);
                Attrib += (cpFirst-selUncpFirst);
            }
            else {
                Length = (int)(selUncpLim - selUncpFirst);
            }
            UndetermineTextOut(hDC, xp, yp, ptr1, Length, Attrib);

            AttribPos = 0;
            xp+=LOWORD(GetTextExtent(hDC, ptr1, Length));
            xp-=tm.tmOverhang;
            ptr1+=Length;
            len-=Length;

            if ( Length = (int)(cpEnd - selUncpLim) ) {
                 TextOut(hDC, xp, yp, ptr1, Length);
            }
        }
        else if(Attrib) {
            if(cpFirst > selUncpFirst) {
                Attrib += (cpFirst-selUncpFirst);
            }
            UndetermineTextOut(hDC, xp, yp, ptr1,len, Attrib);
        }
        GlobalUnlock(hImeUnAttrib);
        Attrib = NULL;
   }
}

DoHiddenRectSend()
{
    bResetIMERect = FALSE;
    IMEManage( FALSE );
}

GetImeHiddenTextColors()
{
    COLORREF NEAR PASCAL GetIMEColor(WORD);
    int i;

    for (i = 0; i < IMEDEFCOLORS; i++)
      rgbIMEHidden[i] = GetIMEColor(i);
}

/*
    GetIMEColor -

    Retrieve IME color scheme from [colors] in win.ini
*/
#define MAX_SCHEMESIZE 190

COLORREF NEAR PASCAL GetIMEColor(WORD wIndex)
{

static char  *pszWinStrings[IMEDEFCOLORS] = {
                         "IMESpot",
                         "IMESpotText",
                         "IMEInput",
                         "IMEInputText",
                         "IMEOther",
                         "IMEOtherText"};

  BYTE szTemp[MAX_SCHEMESIZE];
  LPBYTE szLP;
  COLORREF colRGB;
  int i, v;

  if (wIndex >= IMEDEFCOLORS)
      return RGB(0,0,0);

  GetProfileString("colors",
                   pszWinStrings[wIndex],
                   "",
                   szTemp,
                   MAX_SCHEMESIZE);

  if (!lstrlen(szTemp)) {
      switch(wIndex) {
          case IMESPOT:
              return GetSysColor(COLOR_HIGHLIGHTTEXT);
          case IMESPOTTEXT:
              return GetSysColor(COLOR_HIGHLIGHT);
          case IMEINPUT:
              return GetSysColor(COLOR_WINDOW);
          case IMEINPUTTEXT:
              return GetSysColor(COLOR_HIGHLIGHT);
          case IMEOTHER:
              return GetSysColor(COLOR_WINDOW);
          case IMEOTHERTEXT:
              return GetSysColor(COLOR_HIGHLIGHT);
      }
  }

  colRGB = RGB(0,0,0);
  szLP = szTemp;
  for (i = 0; i < 3; i++) {
      v = 0;
      while(*szLP < '0' || *szLP > '9') szLP++;
      while(*szLP >= '0' && *szLP <= '9') v = v * 10 + (*szLP++ - '0');
      switch(i) {
        case 0:
            colRGB |= RGB(v,0,0);
            break;
        case 1:
            colRGB |= RGB(0,v,0);
            break;
        case 2:
            colRGB |= RGB(0,0,v);
            break;
      }
  }
  return colRGB;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\doslib.asm ===
TITLE   doslib - DOS access library routines

; Windows Write, Copyright 1985-1992 Microsoft Corporation
; =====================================================================
;   This file contains DOS access routines.
;   These routines are general, simple calls to DOS and
;   are likely to be generally useful.  They assume /PLM calling
;   is used.
;   FAR calls are used throughout
;
;
;   NOTE: DOSLIB.H CONTAINS A C HEADER DEFINING THE FUNCTIONS IN THIS
;   MODULE.  IT MUST BE UPDATED WHENEVER A FUNCTION IS ADDED OR AN INTERFACE
;   CHANGES
; =====================================================================


; =====================================================================
;   cmacros2.inc is a special version of cmacros.inc in which the only
;   difference is that it defines the segment for assembly code to
;   be FILE_TEXT instead of _TEXT.
;   This is done so that functions in FILE.C will
;   not call intermodule and subject themselves to possible file closure
;   when calling DOS functions.
; =====================================================================
include cmacros2.inc

sBegin  DATA
ifdef DEBUG
EXTRN   vfCommDebug:WORD
endif
sEnd    DATA


cchMaxFile  EQU     128
EXTRN   ANSITOOEM:FAR

sBegin      CODE
            assumes CS,CODE

; ---------------------------------------------------------------------
; int FAR CchCurSzPath( szPath, bDrive )
; PSTR szPath;
; int bDrive;
;
; Copy the current path name for the current drive into szPath
; szPath must have 67 bytes of storage
;
; bDrive is 0=default, 1=A, 2=B,...
;
; Returned cch includes the terminating '\0'
; Form of returned string is e.g. "C:\WINDOWS\BIN\" (0-terminated)
; String is guaranteed to: (1) Include the drive letter, colon, and leading "\"
;                          (2) End with a backslash
;
; 0 = an error occurred, nonzero = success
; the path string will be NULL if an error occurred
; An error should really not be possible, since the default drive ought to be
; valid
; ---------------------------------------------------------------------

cProc       CchCurSzPath, <FAR, PUBLIC>, <SI>
parmDP      <szPath>
parmB       <bDrive>
cBegin      CchCurSzPath

            mov     al,bDrive
            mov     dl,al
            cmp     al,0
            jz      cspDFLTDRV  ; default drive
            dec     al
            jmp     cspGOTDRV   ; not default drive

cspDFLTDRV:
            mov     ah,19h      ; Get current drive
            int     21h

            ; now we have al: 0=A, 1=B, ....
            ;             dl: 0=default, 1=A, 2=B

cspGOTDRV:                      ; Put "X:\" at front of szPath
            add     al,'A'
            mov     si,szPath
            mov     [si],al
            mov     BYTE PTR [si+1],':'
            mov     BYTE PTR [si+2],'\'  ; Leave si pointing at szPath

            add     si,3        ; Rest of path goes at SzPath+3
            mov     ah,47h
            int     21h
            mov     si,szPath
            jc      cspERR      ; error -- return negative of err code in AX

            dec     si          ; Path was OK - find null terminator
cspLOOP:    inc     si
            cmp     al,[si]
            jnz     cspLOOP

            cmp     BYTE PTR [si-1],'\' ; Append backslash if needed
            jz      cspSTROK            ; not needed, string is already OK
            mov     BYTE PTR [si],'\'
            inc     si
            mov     BYTE PTR [si],0
cspSTROK:                               ; now we are guaranteed a good string
            mov     ax,si               ; determine string length
            sub     ax,szPath
            inc     ax
            jmp     cspRET

cspERR:     mov     BYTE PTR [si],0         ;  error -- NULL path string
            neg     ax
cspRET:
cEnd        CchCurSzPath


ifdef ENABLE
;-----------------------------------------------------------------------------
; DOSHND FAR WCreateNewSzFfname( szFfname, attrib )
;
; Create specified file, leave open for read/write, return handle
; filename is an ffname, with drive and path. Uses the NEW
; DOS 3.0 CREATE call which fails if the file exists. Caller has
; responsibility for assuring DOS version number sufficiently high
;
; returned handle is negative if there was an error
; the value will be the negative of the error code returned in AX
;-----------------------------------------------------------------------------

cProc WCreateNewSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>
parmW   <attrib>
cBegin WCreateNewSzFfname

    mov     dx,szFfname
    mov     cx,attrib
    mov     ah,5bh
    int     21h
    jnc     cnsfdone
    neg     ax          ; error - return the negative of the error code
cnsfdone:
cEnd WCreateNewSzFfname

;-----------------------------------------------------------------------------
; DOSHND FAR WCreateSzFfname( szFfname, attrib )
;
; Create specified file, leave open for read/write, return handle
; filename is an ffname, with drive and path
;
; returned handle is negative if there was an error
; the value will be the negative of the error code returned in AX
;-----------------------------------------------------------------------------

cProc WCreateSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>
parmW   <attrib>
cBegin WCreateSzFfname

    mov     dx,szFfname
    mov     cx,attrib
    mov     ah,3ch
    int     21h
    jnc     csfdone
    neg     ax          ; error - return the negative of the error code
csfdone:
cEnd WCreateSzFfname
endif

;-----------------------------------------------------------------------------
; int DosxError()
;
; Return a DOS extended error code
;-----------------------------------------------------------------------------

cProc DosxError, <FAR, PUBLIC>
cBegin DosxError
    mov     ah,59h
    mov     bx,0    ; bug fix, 10/2/86, BryanL
    int     21h
cEnd DosxError


;-----------------------------------------------------------------------------
; WORD WDosVersion()
;
; Return a word indicating DOS version, major in low 8 bits, minor in high 8
;-----------------------------------------------------------------------------

cProc WDosVersion, <FAR, PUBLIC>
cBegin WDosVersion
    mov     ah,30h
    int     21h
cEnd WDosVersion


;-----------------------------------------------------------------------------
; WORD DaGetFileModeSz(sz)
;
; Return a word indicating attributes of file sz (EXPECTED IN ANSI);
; 0xFFFF if it fails.
;-----------------------------------------------------------------------------

cProc DaGetFileModeSz, <FAR, PUBLIC>
parmDP  <sz>
localV  <szOem>,cchMaxFile

cBegin DaGetFileModeSz
    ; Convert filename from ANSI set to OEM Set

    push    ds
    push    sz
    push    ds
    lea     ax,szOem
    push    ax
    call    ANSITOOEM

    lea     dx,szOem
    mov     ax,4300h

    int     21h
    mov     ax, cx
    jnc     daNoErr
    mov     ax, 0ffffh      ; error -- return 0xFFFF
daNoErr:
cEnd DaGetFileModeSz

; WRITE uses OpenFile instead
ifdef ENABLE
;-----------------------------------------------------------------------------
; DOSHND FAR WOpenSzFfname( szFfname, openmode )
;
; Open specified file in specified mode, return a handle or
; the negative of an error code if the open failed
;-----------------------------------------------------------------------------

cProc WOpenSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>
parmB   <openmode>
cBegin WOpenSzFfname

    mov     dx,szFfname
    mov     al,openmode
    mov     ah,3dh

    int     21h
    jnc     osfdone
    neg     ax          ; error - return the negative of the error code
osfdone:
cEnd WOpenSzFfname

endif

;-----------------------------------------------------------------------------
; int FAR FCloseDoshnd( doshnd )
;
; Close file given DOS handle, return 0 = error, nonzero = no error
;-----------------------------------------------------------------------------

cProc FCloseDoshnd, <FAR, PUBLIC>
parmW   <doshnd>
cBegin FCloseDoshnd

    mov     bx,doshnd
    mov     ah,3eh

    int     21h
    mov     ax,0000
    jc      cdhskip     ; error, leave a zero in ax
    inc     ax
cdhskip:
cEnd FCloseDoshnd

;-----------------------------------------------------------------------------
; int FAR FpeDeleteSzFfname( szFfname )
;
; Delete specified file, return < 0=failure, 0=success
;-----------------------------------------------------------------------------

cProc FpeDeleteSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>

localV  <szOem>,cchMaxFile

cBegin FpeDeleteSzFfname

    ; Convert filename from ANSI set to OEM Set

    push    ds
    push    szFfname
    push    ds
    lea     ax,szOem
    push    ax
    call    ANSITOOEM

    lea     dx,szOem
    mov     ah,41h

    int     21h
    jc      dsfskip     ; error - return the negative of the error code
    mov     ax,0ffffh
dsfskip:
    neg     ax
cEnd FpeDeleteSzFfname

;-----------------------------------------------------------------------------
; int FAR FpeRenameSzFfname( szCur, szNew )
;
; Rename file szCur to szNew, return < 0=failure, 0=success
;-----------------------------------------------------------------------------

cProc FpeRenameSzFfname, <FAR, PUBLIC>, <ES,DI>
parmDP  <szCur>
parmDP  <szNew>

localV  <szCurOem>,cchMaxFile
localV  <szNewOem>,cchMaxFile

cBegin FpeRenameSzFfname

    ; Convert filenames to Oem char set

    push    ds
    push    szCur
    push    ds
    lea     ax,szCurOem
    push    ax
    call    ANSITOOEM
    push    ds
    push    szNew
    push    ds
    lea     ax, szNewOem
    push    ax
    call    ANSITOOEM

    lea     dx,szCurOem   ; old filename in ds:dx
    push    ds            ; new filename in es:di
    pop     es
    lea     di,szNewOem
    mov     ah,56h

    int     21h
    jc      rnfskip     ; error - return the negative of the error code
    mov     ax,0ffffh
rnfskip:
    neg     ax
cEnd FpeRenameSzFfname

;-----------------------------------------------------------------------------
; int CchReadDoshnd ( doshnd, lpchBuffer, bytes )
;
; Read bytes from an open file, place into buffer
; Returns # of bytes read (should be == bytes unless EOF or error)
; If an error occurs, returns the negative of the error code
;-----------------------------------------------------------------------------

cProc CchReadDoshnd, <FAR, PUBLIC>, <DS>
parmW   <doshnd>
parmD   <lpchBuffer>
parmW   <bytes>
cBegin CchReadDoshnd

    mov     bx,doshnd
    lds     dx,lpchBuffer
    mov     cx,bytes
    mov     ah,3fh

    int     21h
    jnc     crdone

    neg     ax          ; error - return value is the negative of the error code
crdone:
cEnd CchReadDoshnd




;-----------------------------------------------------------------------------
; int CchWriteDoshnd ( doshnd, lpchBuffer, bytes )
;
; Write bytes from an open file, place into buffer
; Returns # of bytes read (should be == bytes unless EOF or error)
; If an error occurs, returns the negative of the error code
; Disk full is not an "error"; detect it by return code != bytes
;-----------------------------------------------------------------------------

cProc CchWriteDoshnd, <FAR, PUBLIC>,<DS>
parmW   <doshnd>
parmD   <lpchBuffer>
parmW   <bytes>
cBegin CchWriteDoshnd

    mov     bx,doshnd
    lds     dx,lpchBuffer
    mov     cx,bytes
    mov     ah,40h

    int     21h
    jnc     cwdone

    neg     ax              ; error: return the negative of the error code
cwdone:

cEnd CchWriteDoshnd




;-----------------------------------------------------------------------------
; long DwSeekDw ( doshnd, dwSeekpos, bSeekfrom )
;
; Seek to requested position in file
; bSeekfrom is:  0 = seek relative to beginning of file
;                1 = seek relative to current pointer location
;                2 = seek relative to end of file
;
; Returns the new location of the read/write pointer (a long)
; If an error occurs, returns the negative of the error code (long)
;-----------------------------------------------------------------------------

cProc DwSeekDw, <FAR, PUBLIC>
parmW   <doshnd>
parmD   <dwSeekpos>
parmB   <bSeekfrom>
cBegin DwSeekDw

    mov     bx,doshnd
    mov     cx,SEG_dwSeekpos
    mov     dx,OFF_dwSeekpos
    mov     al,bSeekfrom
    mov     ah,42h

    int     21h
    jnc     seekdone

    neg     ax              ; Error: return the negative of the error code
    mov     dx,0ffffH

seekdone:

cEnd DwSeekDw


; WRITE does not use these currently

ifdef ENABLE
;-----------------------------------------------------------------------------
; int FAR FFirst(pb, szFileSpec, attrib)
; Get first directory entry, place in buffer at pb. (buffer must contain
;                                                    43 bytes of storage)
; attrib specifies attribute per MSDOS spec.
; szFileSpec is filename specification
; Returns 0=no error, nonzero = error
;-----------------------------------------------------------------------------

cProc FFirst, <FAR, PUBLIC>, <SI, DI>
parmDP  <pb, szFileSpec>
parmW   <attrib>
cBegin FFirst

    mov     dx,pb       ; set dta to pb
    mov     ah,1ah
    int     21h

    mov     cx,attrib   ; get first directory record, place in *pb
    mov     dx,szFileSpec
    mov     ah,4eh
    int     21h
    jc     ffdone
    xor     ax,ax

ffdone:
cEnd FFirst


;-----------------------------------------------------------------------------
; int FAR FNext(pb)
; Get next directory entry, place in buffer at pb.
; Return 0= found match OK, nonzero = error or no more matches
;-----------------------------------------------------------------------------

cProc FNext, <FAR, PUBLIC>, <SI, DI>
parmDP  <pb>
cBegin FFirst

    mov     dx,pb       ; set dta to pb
    mov     ah,1ah
    int     21h

    mov     ah,4fh
    int     21h
    jc     fndone
    xor     ax,ax

fndone:
cEnd FNext

endif

ifdef OLDDEBUG
  /* This method isn't quite working under Win 3.0 ..pault */
;-----------------------------------------------------------------------------
; void CommSz( sz ) - put out string to AUX device
;
; For debugging
;-----------------------------------------------------------------------------

cProc CommSz, <FAR, PUBLIC>
parmDP  <sz>
cBegin CommSz

CommSz1:
    mov     bx, sz          ; if ((dl = *(sz++)) == 0)  goto CommSz2
    inc     sz
    mov     dl, [bx]
    cmp     dl, 0
    jz      CommSz2

    call    DebugOutput     ; Output dl to AUX or LPT device

    jmp     CommSz1

CommSz2:

cEnd CommSz

;-----------------------------------------------------------------------------
; static void DebugOutput - put character to AUX or LPT device
;                   if (vfCommDebug)
;                        output to AUX port
;                   else output to LPT port
;   input:  dl = character
;   output: none. Uses ah
;
;-----------------------------------------------------------------------------

            assumes ds,DATA
DebugOutput PROC    NEAR

    mov     ah,4            ; Assume AUX device
    test    vfCommDebug,0ffh
    jnz     DebugOut1
    inc     ah              ; Change to LPT device
DebugOut1:
    int     21h             ; Output character
    ret

DebugOutput ENDP

endif ;DEBUG

sEnd        CODE



            END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\d_form1.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*--- Module not really used, just the idea behind FORMAT.ASM ---*/


#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOCLIPBOARD
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#include <windows.h>
/* #include "wwsmall.h" */

#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "ch.h"
#include "docdefs.h"
#include "ffdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "dispdefs.h"
#include "scrndefs.h"
#include "macro.h"
#include "debug.h"
#include "fontdefs.h"
#include "str.h"
#include "wwdefs.h"
#ifdef DBCS
#include "dbcs.h"
/* We move several hard code Kanji code table from this source file
   to kanji.h as external variables. Define CODE_TABLE will define
   those variables */
#define CODE_TABLE

#include "kanji.h"
#endif

#if defined(TAIWAN) || defined(PRC)
int WINAPI GetFontAssocStatus(HDC);
#endif

#ifdef DFLI
#define Dfli(x) x  /* Enable debug-format-line info */
#else
#define Dfli(x)
#endif

#ifdef CASHMERE
#define                 cchSmcapMax     16
#endif /* CASHMERE */

static int              ichpFormat;

#ifdef CASHMERE
static CHAR             mptlcch[] = " .-_";
#endif /* CASHMERE */

#if defined(JAPAN) || defined(KOREA)                  //  added  22 Jun. 1992  by Hiraisi
int iWidenChar;     /* counter for widened characters except (KANJI) space */
                    /*   Ex.) DBCS, Japanese KANA */
int iNonWideSpaces;

#elif defined(TAIWAN) || defined(PRC)//  Daniel/MSTC, 1993/02/25, for jcBoth
int iWidenChar;     /* counter for widened characters except (KANJI) space */
                    /*   Ex.) DBCS, Japanese KANA */
int iNonWideSpaces;
extern int vfWordWrap;
#define FKana(_ch)      FALSE
#endif

/* T-HIROYN sync format.asm */
/*extern int              docHelp;*/
extern struct FLI       vfli;
extern struct CHP       (**vhgchpFormat)[];
extern int              ichpMacFormat;
extern struct CHP       vchpAbs;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct CHP       vchpNormal;
extern struct DOD       (**hpdocdod)[];
extern typeCP           vcpLimSectCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern typeCP           vcpFetch;
extern int              vichFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern int              vcchFetch;
extern int              vftc;
extern int              ypSubSuper;
extern int              ypSubSuperPr;
extern HDC              vhMDC;
extern HDC              vhDCPrinter;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern int              dypMax;
extern struct FMI       vfmiScreen, vfmiPrint;
extern int              vfOutOfMemory;
extern CHAR             vchDecimal;  /* "decimal point" character */
extern int              vzaTabDflt;  /* width of default tab */
#if defined(JAPAN) || defined(KOREA)
extern int              vfWordWrap; /*t-Yoshio WordWrap flag*/
#endif

#ifdef CASHMERE
extern int              vfVisiMode;
#endif /* CASHMERE */


/* F O R M A T  L I N E */
FormatLine(doc, cp, ichCp, cpMac, flm)
int doc;
typeCP cp;
int ichCp;
typeCP cpMac;
int flm;
    {
    /* Fills up vfli with a line of text */

    int near Justify(struct IFI *, unsigned, int);
    int near FGrowFormatHeap(void);
    int near FFirstIch(int);

#ifdef DBCS
    BOOL near FAdmitCh1(CHAR);
    BOOL near FAdmitCh2(CHAR, CHAR);
    BOOL near FOptAdmitCh1(CHAR);
    BOOL near FOptAdmitCh2(CHAR, CHAR);
    int DBCSDxpFromCh(int,int,int);
#endif

    struct IFI ifi;
    struct TBD *ptbd;
    struct CHP chpLocal;
    int xpTab;

#ifdef CASHMERE
    int dypBefore;
#endif /* CASHMERE */

    int dypAscent;
    int dypDescent;
    int dypAscentMac;
    int dypDescentMac;
    unsigned xaLeft;
    unsigned xaRight;
    struct PAP *ppap;
    struct SEP *psep;
    int fFlmPrinting = flm & flmPrinting;
    int dxaFormat;
    int dyaFormat;
    int dxpFormat;
    int dypFormat;
    int ypSubSuperFormat;
    int fTruncated = false;     /* if the run was truncated */
    int ichpNRH;

#ifdef DBCS
    int dichSpaceAdjust;
    int             dypLeading;
    int             dypIntLeading;
    int             dypPAscent;         /* Pure Ascent */
    int             dypLeadingMac;
    int             dypIntLeadingMac;
    int             dypPAscentMac;
    BOOL            fKanjiBreakOppr = false;
    BOOL            fKanjiPrevious = false;
    /* true iff we already have a hanging character on the line. */
    BOOL            fKanjiHanging = false;
    /* true iff the first and second bytes of a kanji character
       were in two different runs. */
    BOOL            fOddBoundary = false;
    typeCP          cpFetchSave;
    typeCP          cpSeqFetch;
    int             ichFetchSave;
    int             cchUsedSave;

    extern int      utCur;
    extern int      dxaAdjustPer5Ch;
    extern unsigned cxaCh;
#endif /* ifdef DBCS */


#ifdef CASHMERE
    struct FNTB **hfntb;
    int fVisiMode;
#endif /* CASHMERE */

    /* Check for fli current */
    if (vfli.doc == doc && vfli.cpMin == cp && vfli.ichCpMin == ichCp &&
      vfli.flm == flm)
        {
        /* Just did this one */
        return;
        }

#ifdef JAPAN   // added by Hiraisi
//   When printing, WRITE doesn't redraw the screen.
{
    extern BOOL fPrinting;
    if( fPrinting && !fFlmPrinting )
        return;
}
#endif

    Scribble(5, 'F');
    bltc(&vfli, 0, cwFLIBase);
    /* This means:
        vfli.fSplat = false;
        vfli.dcpDepend = 0;
        vfli.ichCpMac = 0;
        vfli.dypLine = 0;
        vfli.dypAfter = 0;
        vfli.dypFont = 0;
        vfli.dypBase = 0;
    */

    /* vfSplatNext = FALSE; No longer used. */

    /* Rest of format loads up cache with current data */
    vfli.doc = doc;
    vfli.cpMin = cp;
    vfli.ichCpMin = ichCp;
    vfli.flm = flm;

    if (cp > cpMac)
        {
        /* Space after the endmark.  Reset the cache because the footnotes come
        at the same cp in the footnote window */
        vfli.doc = docNil;
        vfli.cpMac = cp;
        vfli.rgdxp[0] = 0;

        /* Line after end mark is taller than screen */

#ifdef CASHMERE
        vfli.dypBase = vfli.dypFont = vfli.dypAfter = ((vfli.dypLine = dypMax)
          >> 1);
#else /* not CASHMERE */
        vfli.dypBase = vfli.dypFont = ((vfli.dypLine = dypMax) >> 1);
#endif /* not CASHMERE */

        Scribble(5, ' ');
        return;
        }

    /* Initialize run tables */
    ichpFormat = 0;

    /* Cache section and paragraph properties */

#ifdef CASHMERE
    hfntb = (**hpdocdod)[doc].hfntb;
    if (hfntb == 0 || cp < (**hfntb).rgfnd[0].cpFtn)
        {
        /* Normal text */
        CacheSect(doc, cp);
        }
    else
        {
        /* Footnote section properties come from the section of the footnote
        reference. */
        CacheSect(doc, CpRefFromFtn(doc, cp));
        }
#else /* not CASHMERE */
    CacheSect(doc, cp);
#endif /* not CASHMERE */

    psep = &vsepAbs;

    CachePara(doc, cp);
    ppap = &vpapAbs;

    /* Now we have:
        ppap    paragraph properties
        psep    division properties
    */

    if (ppap->fGraphics)
        {
        /* Format a picture paragraph in a special way (see picture.c) */
        FormatGraphics(doc, cp, ichCp, cpMac, flm);
        Scribble(5, ' ');
        return;
        }

    /* Assure we have a good memory DC for font stuff */
    ValidateMemoryDC();
    if (vhMDC == NULL || vhDCPrinter == NULL)
        {
        Scribble(5, ' ');
        return;
        }

#ifdef CASHMERE
    /* When printing, don't show visible characters */
    fVisiMode = vfVisiMode && !fFlmPrinting;
#endif /* CASHMERE */

    bltc(&ifi, 0, cwIFI);
    /* This means:
        ifi.ich = 0;
        ifi.ichPrev = 0;
        ifi.ichFetch = 0;
        ifi.cchSpace = 0;
        ifi.ichLeft = 0;
    */

    ifi.jc = jcTabLeft;
    ifi.fPrevSpace = true;

    /* Set up some variables that have different value depending on whether we
    are printing or not. */
    if (fFlmPrinting)
        {
        dxaFormat = dxaPrPage;
        dyaFormat = dyaPrPage;
        dxpFormat = dxpPrPage;
        dypFormat = dypPrPage;
        ypSubSuperFormat = ypSubSuperPr;
        }
    else
        {
        dxaFormat = dyaFormat = czaInch;
        dxpFormat = dxpLogInch;
        dypFormat = dypLogInch;
        ypSubSuperFormat = ypSubSuper;
        }

    /* Calculate line height and width measures.  Compute
        xaLeft          left indent 0 means at left margin
        xaRight         width of column measured from left margin (not from left
                        indent).
    */
    xaLeft = ppap->dxaLeft;

    /* If this is the first line of a paragraph, adjust xaLeft for the first
    line indent.  (Also, set dypBefore, since its handy.) */
    if (cp == vcpFirstParaCache)
        {
        xaLeft += ppap->dxaLeft1;

#ifdef CASHMERE
        dypBefore = MultDiv(ppap->dyaBefore, dypLogInch, czaInch);
#endif /* CASHMERE */

        }

#ifdef CASHMERE
    else
        {
        dypBefore = 0;
        }
#endif /* CASHMERE */

    /* Now, set xaRight (width measured in twips). */

#ifdef CASHMERE
    xaRight = (ppap->rhc ? vsepPage.xaMac - vsepPage.dxaGutter :
      psep->dxaText) - ppap->dxaRight;
#else /* not CASHMERE */
    xaRight = psep->dxaText - ppap->dxaRight;
#endif /* not CASHMERE */


    /* Do necessary checks on xaLeft and xaRight */
    if (xaRight > xaRightMax)
        {
        xaRight = xaRightMax;
        }
    if (xaLeft > xaRightMax)
        {
        xaLeft = xaRightMax;
        }
    if (xaLeft < 0)
        {
        xaLeft = 0;
        }
    if (xaRight < xaLeft)
        {
        xaRight = xaLeft + 1;
        }

    vfli.xpLeft = ifi.xp = ifi.xpLeft = MultDiv(xaLeft, dxpFormat, dxaFormat);
    vfli.xpMarg = ifi.xpRight = MultDiv(xaRight, dxpFormat, dxaFormat);
    ifi.xpPr = MultDiv(xaLeft, dxpPrPage, dxaPrPage);
    ifi.xpPrRight = MultDiv(xaRight, dxpPrPage, dxaPrPage);

#ifndef JAPAN       // added by Hiraisi (BUG#3542)
#ifdef  DBCS                /* was in JAPAN */
/* at least one kanji is displayed */
/* DxpFromCh() --> DBCSDxpFromCh()   03 Oct 1991 YutakaN */
    {
       int dxpPr;
    if ( ifi.xpPrRight - ifi.xpPr < (dxpPr = DBCSDxpFromCh(bKanjiSpace1,bKanjiSpace2, TRUE) ) )
    {
    ifi.xpPrRight = ifi.xpPr + dxpPr + 1;
    }
    }
#endif
#endif

    /* Get a pointer to the tab-stop table. */
    ptbd = ppap->rgtbd;

    /* Turn off justification. */
    SetTextJustification(fFlmPrinting ? vhDCPrinter : vhMDC, 0, 0);

    /* Initialize the line height information. */
    dypAscentMac = dypDescentMac = 0;

/*T-HIROYN add from 3.0*/
#if defined(JAPAN) || defined(KOREA)
    dypLeadingMac = dypIntLeadingMac = dypPAscentMac = 0;
#endif /* JAPAN */

    /* To tell if there were any tabs */
    ifi.ichLeft = -1;

#if defined(JAPAN) || defined(KOREA)                  //  added  22 Jun. 1992  by Hiraisi
    iWidenChar=0;
#elif defined(TAIWAN) || defined(PRC) // Daniel/MSTC, 1993/02/25, for jcBoth
    iWidenChar=0;
#endif

    /* Get the first run, and away we go... */
    FetchCp(doc, cp, ichCp, fcmBoth + fcmParseCaps);
    goto FirstCps;

    for ( ; ; )
        {
        int iichNew;
        int xpPrev;
        int dxp;
        int dxpPr;

        /* The number of characters to process (usually vcchFetch) */
        int cch;

        /* The number of characters in current run already used */
        int cchUsed;

        /* A pointer to the current list of characters (usually vpchFetch) */
        CHAR *pch;

#ifdef CASHMERE
        CHAR rgchSmcap[cchSmcapMax];
#endif /* CASHMERE */

        if (ifi.ichFetch == cch)
            {
            /* End of a run */
            int dich;
            BOOL fSizeChanged;

            if (ifi.ich >= ichMaxLine )
            /* End of run because of line length limit has been reached. */
                {
                goto DoBreak;
                }

            if (fTruncated)
                {
                cchUsed += cch;
                pch = vpchFetch + cchUsed;
                cch = vcchFetch - cchUsed;
                fTruncated = false;
                goto OldRun;    /* use the rest of the old run  */
                }

NullRun:
#ifdef DBCS
            if (!fOddBoundary)
                {
                /* The last fetch did not mess up a sequential access. */
                FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
                }
            else
                {
                /* Previous fetch was an odd one.  Set it up again. */
                FetchCp(doc, cpSeqFetch, 0, fcmBoth + fcmParseCaps);
                }
            fOddBoundary = false;
#else
            FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
#endif

FirstCps:

            cchUsed = 0;

            /* Continue fetching runs until a run is found with a nonzero
            length. */
            if ((cch = vcchFetch) == 0)
                {
                goto NullRun;
                }

            pch = vpchFetch;
            if (vcpFetch >= cpMac || (!fFlmPrinting && *pch == chSect))
                {
#ifdef SYSENDMARK
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = ftcSystem;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#else
#ifdef REVIEW
                /* The following comment is absolutely misleading!  Ftc==0
                   doesn't give you a system font.  It gives you the first
                   entry in the font table. */
#endif /* REVIEW */
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = 0;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#endif /* if-else-def KANJI */
                }

#ifdef CASHMERE
            /* Adjust the size of the font for "small capitals". */
            if (vchpAbs.csm == csmSmallCaps)
                {
                vchpAbs.hps = HpsAlter(vchpAbs.hps, -1);
                }
#endif /* CASHMERE */

            /* Now we have:
                ichpFormat     index into gchp table
                vcpFetch        first cp of current run
                vfli.cpMin      first cp of line
                ifi.ich         ???
            */

           /* since LoadFont could change vchpAbs, and we don't want
              that to happen, we copy vchpAbs into vchpLocal and use
              vchpLocal in place of vchpAbs hereafter. Note that vchpAbs
              is intentionally used above for handling the endmark. */

                blt(&vchpAbs, &chpLocal, cwCHP);


            if (fFlmPrinting)
                {
                LoadFont(doc, &chpLocal, mdFontPrint);
                dypAscent = vfmiPrint.dypAscent + vfmiPrint.dypLeading;
                dypDescent = vfmiPrint.dypDescent;
#ifdef DBCS            /* was in JAPAN */
                dypPAscent = vfmiPrint.dypAscent;
                dypLeading = vfmiPrint.dypLeading;
                dypIntLeading = vfmiPrint.dypIntLeading;
#endif
                }
            else
                {
                LoadFont(doc, &chpLocal, mdFontJam);
                dypAscent = vfmiScreen.dypAscent + vfmiScreen.dypLeading;
                dypDescent = vfmiScreen.dypDescent;
#ifdef DBCS            /* was in JAPAN */
                dypPAscent = vfmiScreen.dypAscent;
                dypLeading = vfmiScreen.dypLeading;
                dypIntLeading = vfmiScreen.dypIntLeading;
#endif
                }
#ifdef ENABLE   /* BRYANL 8/27/87: New philosophy for handling
                   font selection failures is: font selection
                   ALWAYS succeeds. This prevents FormatLine
                   returns that do not advance. */
            /* Bail out if there is a memory failure. */
            if (vfOutOfMemory)
                {
                goto DoBreak;
                }
#endif  /* ENABLE */

            /* Floating line size algorithm */
            if (chpLocal.hpsPos != 0)
                {
                /* Modify font for subscript/superscript */
                if (chpLocal.hpsPos < hpsNegMin)
                    {
                    dypAscent += ypSubSuperFormat;
#ifdef DBCS            /* was in JAPAN */
                    dypPAscent += ypSubSuperFormat;
#endif
                    }
                else
                    {
                    dypDescent += ypSubSuperFormat;
                    }
                }

            /* Update the maximum ascent and descent of the line. */
            fSizeChanged = FALSE;
            if (dypDescentMac < dypDescent)
                {
                dypDescentMac = dypDescent;
                fSizeChanged = TRUE;
                }
            if (dypAscentMac < dypAscent)
                {
                dypAscentMac = dypAscent;
                fSizeChanged = TRUE;
                }

#ifdef DBCS                /* was in JAPAN */
            if (dypPAscentMac < dypPAscent)
                {
                dypPAscentMac = dypPAscent;
                fSizeChanged = TRUE;
                }
            if (dypIntLeadingMac < dypIntLeading)
                {
                dypIntLeadingMac = dypIntLeading;
                fSizeChanged = TRUE;
                }
            if (dypLeadingMac < dypLeading)
                {
                dypLeadingMac = dypLeading;
                fSizeChanged = TRUE;
                }
#endif

            if (fSizeChanged)
                {

#ifdef AUTO_SPACING
                /* This is the original Mac Word code that assumed line spacing
                of 0 in a PAP meant auto line spacing.  PC Word defaults to 1
                line invalidating this assumption. */
                if (ppap->dyaLine == 0)
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = dypDescentMac + dypAscentMac + dypBefore;
#else /* not CASHMERE */
                    ifi.dypLineSize = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    }
                else
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat), 1);
#endif /* not CASHMERE */

                    }
#else /* not AUTO_SPACING */
                /* This code forces auto line spacing except in the case where
                the user specifies a line spacing greater than the auto line
                spacing. */
                    {
#ifdef DBCS                /* was in JAPAN */
#if defined(TAIWAN) || defined(PRC)
            register int dypAuto = dypDescentMac + dypAscentMac;
            if (ppap->dyaLine > czaLine)
            {
            register int dypUser = imax(MultDiv(ppap->dyaLine,
              dypFormat, dyaFormat), 1);

            ifi.dypLineSize = max(dypAuto, dypUser);
            }
            else
            {
            ifi.dypLineSize = dypAuto;
            }
#else   /* TAIWAN */
                    register int dypAuto = dypDescentMac + dypAscentMac;
                             int cHalfLine;
                             int dypSingle = dypPAscentMac + dypDescentMac;

                    cHalfLine = (ppap->dyaLine + (czaLine / 4)) / (czaLine / 2);
                    ifi.dypLineSize = (cHalfLine == 3) ? (dypSingle*3)/2  :
                                           ((cHalfLine <= 2) ?
                                                dypSingle :
                                                (dypSingle * 2));
#endif      /* TAIWAN */
#else // DBCS
#ifdef CASHMERE
                    register int dypAuto = dypDescentMac + dypAscentMac +
                      dypBefore;
#else /* not CASHMERE */
                    register int dypAuto = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    if (ppap->dyaLine > czaLine)
                        {
#ifdef CASHMERE
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat), 1);
#endif /* not CASHMERE */

                        ifi.dypLineSize = max(dypAuto, dypUser);
                        }
                    else
                        {
                        ifi.dypLineSize = dypAuto;
                        }
#endif      /* DBCS */
                    }
#endif /* not AUTO_SPACING */

                }

OldRun:
            /* Calculate length of the run but no greater than 256 */
            iichNew = (int)(vcpFetch - vfli.cpMin);
            if (iichNew >= ichMaxLine)
                {
                iichNew = ichMaxLine - 1;
                }
            dich = iichNew - ifi.ich;

            /* Ensure that all tab and non-required hyphen characters start at
            beginning of run */
            if (ichpFormat <= 0  || dich > 0 || CchDiffer(&chpLocal,
              &(**vhgchpFormat)[ichpFormat - 1], cchCHPUsed) != 0 || *pch ==
              chTab || *pch == chNRHFile)
                {
#ifdef DFLI
                if (*pch == chNRHFile)
                    CommSz("CHNRHFILE at beginning of run");
#endif
                if (ichpFormat != ichpMacFormat || FGrowFormatHeap())
                    {
                    register struct CHP *pchp = &(**vhgchpFormat)[ichpFormat -
                      1];

                    if (ichpFormat > 0)
                        {
                        pchp->cchRun = ifi.ich - ifi.ichPrev;
                        pchp->ichRun = ifi.ichPrev;
                        }
                    blt(&chpLocal, ++pchp, cwCHP);

#ifdef ENABLE   /* font codes */
                    pchp->ftc = vftc;
                    pchp->ftcXtra = (vftc & 0x01c0) >> 6;
                    pchp->hps = vhps;
#endif /* ENABLE */

                    pchp->cchRun = ichMaxLine;
                    if (dich <= 0)
                        {
                        pchp->ichRun = ifi.ich;
                        }
                    else
                        {
                        /* Q&D insert */
                        bltc(&vfli.rgdxp[ifi.ich], 0, dich);
                        bltbc(&vfli.rgch[ifi.ich], 0, dich);
                        pchp->ichRun = ifi.ich = iichNew;
                        }
                    ifi.ichPrev = ifi.ich;
                    ichpFormat++;
                    }
                }

            if (vcpFetch >= cpMac)
                {
                /* End of doc reached */
                if (!ifi.fPrevSpace || vcpFetch == cp)
                    {
                    vfli.ichReal = ifi.ich;
                    vfli.xpReal = ifi.xpReal = ifi.xp;
                    }
/* T-HIROYN sync fromat.asm */
/*              if (!fFlmPrinting && (doc != docHelp))*/
                if (!fFlmPrinting)
                    {
/*
 * Write 3.1j endmark is 1-bytecharcter
 *                       t-Yoshio May 26,92
 */
#if defined(JAPAN) || defined(KOREA)
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chEMark,
                      false));
#else
#ifdef  DBCS                    /* was in JAPAN */
        /* We use Double byte character to chEMark in Japan */
                    if (ifi.ich + cchKanji > ichMaxLine) {
                        /* vfli.rgch has no room for the two-byte
                           end mark.  Too bad do the break and
                           wait for the next time around. */
                        goto DoBreak;
                        }
                    vfli.rgch[ifi.ich] = chMark1;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chMark1,
                      false));
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.rgdxp[ifi.ich++] = 0;

#if !defined(TAIWAN) && !defined(PRC)
            ifi.dypLineSize += 2;
#endif

#else    /* DBCS */
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chEMark,
                      false));
#endif
#endif /*JAPAN*/
                    }
                vfli.dypLine = ifi.dypLineSize;
                vfli.dypBase = dypDescentMac;
                vfli.dypFont = dypAscentMac + dypDescentMac;
                vfli.ichMac = vfli.ichReal = ifi.ich;
                vfli.cpMac = cpMac + 1;
                goto JustEol;   /* dcpDepend == 0 */
                }

            /* Here we have ifi.ich, cch */
            if (ifi.ich + cch > ichMaxLine)
            /* If this run would put the line over 255, truncate it and set a
            flag. */
                  {
                  cch = ichMaxLine - ifi.ich;
                  fTruncated = true;
                  }

            ifi.ichFetch = 0;

#ifdef CASHMERE
            if (chpLocal.csm != csmNormal)
                {
                int ich;
                CHAR *pchT = &rgchSmcap[0];

                /* We can handle only a run of cchSmcapMax small capital
                characters.  If the run is larger then truncate. */
                if (cch > cchSmcapMax)
                    {
                    cch = cchSmcapMax;
                    fTruncated = true;
                    }

                /* Raise the case of the characters. */
                for (ich = 0 ; ich < cch ; ich++)
                    {
                    *pchT++ = ChUpper(*pch++);
                    }
                pch = &rgchSmcap[0];
                }
#endif /* CASHMERE */

            /* Do "special" characters here */
            if (chpLocal.fSpecial)
                {
                if (!FFormatSpecials(&ifi, flm, vsepAbs.nfcPgn))
                    {
                    if (ifi.chBreak == 0 )   /* No breaks in this line */
                        {
                        goto Unbroken;
                        }
                    else
                        {
                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
                        goto JustBreak;
                        }
                    }
                }

            continue;
            }

        /* End of new run treatment.  We are back in the "for every character"
        section. */
            {
            register int ch = pch[ifi.ichFetch++];

NormChar:
#ifdef  DBCS
            /* Unless it is a kanji space, we only need to adjust
               by 1 byte. */
            dichSpaceAdjust = 1;
#endif
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            if (ch == chSpace && vfWordWrap)
#else
            if (ch == chSpace)
#endif

                {
                /* Speed kludge for spaces */
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp =
                    fFlmPrinting ? vfmiPrint.dxpSpace : vfmiScreen.dxpSpace);
                ifi.xpPr += (dxpPr = vfmiPrint.dxpSpace);
                vfli.rgch[ifi.ich++] = chSpace;
#ifdef DFLI
                {
                char rgch[100];

                wsprintf(rgch,"  chSpace     , xp==%d/%d, xpPr==%d/%d",
                    ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                CommSz(rgch);
                }
#endif
                goto BreakOppr;
                }

#ifndef TEMP_KOREA
            /* If the printer width is not in the printer width table, then get
            it. */
            if (ch < chFmiMin || ch >= chFmiMax || (dxpPr =
              vfmiPrint.mpchdxp[ch]) == dxpNil)
                {
#ifdef  DBCS
                /*  Don't pass to DxpFromCh() DBCS LeadByte except for '8140H'.
                ** Because the function can make elleagal ShiftJIS and pass it
                ** to GetTextExtent(). GetTextExtent might return SBC space
                ** when the code is undefined. this will cause win-hang-up at
                ** formatting line.       yutakan
                */
#if defined(TAIWAN) || defined(PRC)  //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
                dxpPr=DBCSDxpFromCh(ch, ( ((cp + ifi.ich) < cpMac) ?
                                pch[ifi.ichFetch] : 0 ), TRUE);
#else
                dxpPr=DBCSDxpFromCh(ch,pch[ifi.ichFetch],TRUE);
#endif  //TAIWAN
#else
                dxpPr = DxpFromCh(ch, TRUE);
#endif
                }

            if (fFlmPrinting)
                {
                /* If we are printing, then there is no need to bother with the
                screen width. */
                dxp = dxpPr;
                }
            else if (ch < chFmiMin || ch >= chFmiMax ||
                (dxp = vfmiScreen.mpchdxp[ch]) == dxpNil)
#ifdef DBCS
#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
            dxp = DBCSDxpFromCh(ch, ( ((cp + ifi.ich) < cpMac) ?
                                pch[ifi.ichFetch] : 0 ), FALSE);
#else
// yutakan:
            dxp = DBCSDxpFromCh(ch,pch[ifi.ichFetch],FALSE);
#endif  //TAIWAN
#else
                    dxp = DxpFromCh(ch, FALSE);
#endif      /* ifdef DBCS */

#endif      /* ifndef KOREA */
#ifdef DBCS             /* was in JAPAN */

//solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
//#ifdef  TAIWAN
//            if (IsDBCSLeadByte(ch) && !pch[ifi.ichFetch]) {
//                ifi.xp += (vfli.rgdxp[ifi.ich] = (dxp/2));
//                ifi.xpPr += (dxpPr/2);
//                vfli.rgch[ifi.ich++] = ch;
//                vfli.rgch[ifi.ich] = NULL;
//                goto OnlyDBCSPaste;
//            }
//#endif

/*T-HIROYN add from 3.0*/
            ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
            ifi.xpPr += dxpPr;
            vfli.rgch[ifi.ich++] = ch;
#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
            // BUG 5477: Echen: add NON FA font, LeadByte + 2nd byte checking
            if (((cp + ifi.ich) < cpMac) && IsDBCSLeadByte(ch) &&
                GetFontAssocStatus(vhMDC)) {
#else
            if (IsDBCSLeadByte(ch)) {
#endif  //TAIWAN
                CHAR ch2;

                if (ifi.ich + 1 >= ichMaxLine) {
                    /* It's full.  Do the break without this kanji character. */
#ifndef TEMP_KOREA
                    ifi.ich--;
#endif
                    ifi.ichFetch--; /* We don't want to skip the first byte. */
#ifndef TEMP_KOREA
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
#endif
lblFull2:   /* new label of line full case ( for kanji and kana ) */

                    goto DoBreak;
                    }

                /* Now all is well.  Get the second byte of the kanji
                   character of interest from the current run. */
                /* Get the second byte of the kanji character from
                   the current run.  If we run of the current run,
                   use FetchRgch() to staple us over. */
#ifdef  TEMP_KOREA       /* for variable width, 90.12.26 by sangl */
                vfli.rgch[ifi.ich++] = ch;
#endif
                if (ifi.ichFetch == cch)
                    {
                    if (fTruncated)
                        {
                        cchUsed += cch;
                        pch = vpchFetch + cchUsed;
                        cch = vcchFetch - cchUsed;
                        fTruncated = false;
                        ch2 = vfli.rgch[ifi.ich] = pch[ifi.ichFetch++];
                        }
                    else {
                        int     cchFetch;

                        /* Save parameters needed for the re-fetch. */
                        cpFetchSave = vcpFetch;
                        ichFetchSave = vichFetch;
                        cchUsedSave = cchUsed;
                        cpSeqFetch = vcpFetch + cch + 1;

                        FetchRgch(&cchFetch, &ch2, docNil, cpNil,
                                  vcpFetch + cch + 1, 1);
                        fOddBoundary = true;
                        Assert(cchFetch != 0); /* Better fetched something for us. */

#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
                        if ( !cchFetch )  goto SingleDBCS;
#endif  //TAIWAN

                        /* Now, let's settle related parameters. */
                        pch = &ch2;
                        cch = cchFetch;
                        ifi.ichFetch = 1; /* == cch */
                        cchUsed = 0;

                        vfli.rgch[ifi.ich] = ch2;

#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
                //adjust DBCS char width by the new fetched 2nd byte
                        {
                          int       dxpPr2, dxp2;

                          dxpPr2 = DBCSDxpFromCh(ch, ch2, TRUE);
                          if (fFlmPrinting)   dxp2 = dxpPr2;
                          else                dxp2 = DBCSDxpFromCh(ch, ch2, FALSE);
                          vfli.rgdxp[ifi.ich - 1] += (dxp2 - dxp);
                          ifi.xp += (dxp2 - dxp);
                          ifi.xpPr += (dxpPr2 - dxpPr);
                        }
#endif  //TAIWAN

                        }
                    }
                else
                    {
                    ch2 = vfli.rgch[ifi.ich] = pch[ifi.ichFetch++];
                    }
#ifdef  TEMP_KOREA       /* For variable width, 90.12.26 by sangl */
                { unsigned int wd;
                  wd = (ch<<8) + ch2;
                  dxpPr = DxpFromCh(wd, TRUE);
                  if (fFlmPrinting)    /* if we are printing, then there is */
                                       /* no need to bother with the screen width */
                        dxp = dxpPr;
                  else
                        dxp = DxpFromCh(wd, FALSE);
                  ifi.xp += (vfli.rgdxp[ifi.ich-1] = dxp);
                  ifi.xpPr += dxpPr;
                  vfli.rgdxp[ifi.ich++] = 0;
                }
#else
                vfli.rgdxp[ifi.ich++] = 0;   /* The second byte has 0 width. */
#endif  /* KOREA */
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if (FKanjiSpace(ch, ch2) && vfWordWrap)
#else
                if (FKanjiSpace(ch, ch2))
#endif
                    {
                    fKanjiPrevious = true;
                    fKanjiBreakOppr = false; /* Treat it like a regular space. */
                    dichSpaceAdjust = cchKanji;

                    goto BreakOppr;
                    }
                if (ifi.xpPr > ifi.xpPrRight )  {
                    fKanjiBreakOppr = false; /* Reset the flag */
                    if (FAdmitCh2(ch, ch2) ||
                        (fKanjiPrevious && FOptAdmitCh2(ch, ch2))) {
                        /* We do a line break including this odd character. */
                        /* Make sure non-printables won't start a new line. */
                        /* If we already have a hanging character on the    */
                        /* line, we don't want to treat this character as   */
                        /* a hanging one.                                   */
                        if (!fKanjiHanging )
                            {
                            fKanjiHanging = TRUE;
                            ch = chHyphen;
                            goto BreakOppr;
                            }
                        }

#ifndef JAPAN       // added by Hiraisi (BUG#3542)
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                    if(vfWordWrap)
#endif
                        ifi.ich--;
#endif
                    /* If this run was the result of an odd boundary run,
                       re-fetch. */
                    if (fOddBoundary && ifi.ichFetch == 1 )
                        {
                        FetchCp(doc, cpFetchSave, ichFetchSave,
                                fcmBoth + fcmParseCaps);
                        /* This fetch is guaranteed to result to non-null run. */
                        fOddBoundary = false;
                        pch = vpchFetch;
                        ifi.ichFetch = cch = vcchFetch;
#ifdef JAPAN        // added by Hiraisi (BUG#3542)
                        ifi.ichFetch++;
#endif
                        cchUsed = cchUsedSave;
                        }
#ifndef JAPAN       // added by Hiraisi (BUG#3542)
                    else
                        {
#if defined(JAPAN) || defined(KOREA)  /*t-Yoshio*/

                        if(vfWordWrap)
#endif
                            ifi.ichFetch--;

                        }
#endif
                    /* ifi.xp and ifi.xpPr hasn't changed yet. */
            goto lblFull2;
#ifdef  TEMP_KOREA   /* 90.12.26 : For variable width, 90.12.26 by sangl */
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
#endif  /* KOREA */
                    }

#if defined(JAPAN) || defined(KOREA)                  //  added  26 Jun. 1992  by Hiraisi
                iWidenChar++;
#elif defined(TAIWAN) || defined(PRC)//Daniel/MSTC, 1993/02/25 , for jcBoth
                iWidenChar++;
#endif

                /* Record the line break opportunity while processing
                   it as a regular character at the same time. */
                fKanjiBreakOppr = true;
                fKanjiPrevious  = true;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if(!vfWordWrap)
                    goto DefaultCh;

#endif
                goto BreakOppr;
                }
            else {
#if defined(JAPAN) || defined(KOREA)  /*t-Yoshio add WordWrap flag*/
                if (FKana(ch) && vfWordWrap) {
                    /* If it is a 1-byte kana letter, we want to treat it
                       in the same way as a kanji letter. */
                    if (ifi.xpPr > ifi.xpPrRight) {
                        fKanjiBreakOppr = false; /* Reset the flag */
                        if (FAdmitCh1(ch)) {
                            /* Make sure non-printables won't start a new line. */
                            /* If we already have a hanging character on the    */
                            /* line, we don't want to treat this character as   */
                            /* a hanging one.                                   */
                            if (!fKanjiHanging) {
                                fKanjiHanging = TRUE;
                                ch = chHyphen;
                                goto BreakOppr;
                                }
                            }
                        goto lblFull2;
                        }

#if defined(JAPAN) || defined(KOREA)                  //  added  22 Jun. 1992  by Hiraisi

                    iWidenChar++;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25 , for jcBoth
                    iWidenChar++;
#endif

                    fKanjiPrevious  = true;
                    fKanjiBreakOppr = true;
                    /* Go through the break opprotunity processing, then the
                       default character processing. */
                    goto BreakOppr;
                    }
        else {
#endif     /* JAPAN */
#ifdef  TEMP_KOREA       /* For variable width by sangl 90.12.26 */
                    if (ch < chFmiMin || ch >= chFmiMax || (dxpPr =
                        vfmiPrint.mpchdxp[ch]) == dxpNil)
                          {
                          dxpPr = DxpFromCh(ch, TRUE);
                          }
                    if (fFlmPrinting)
                        {
                        /* If we are printing, then there is no need to bother
                           with the screen width */
                        dxp = dxpPr;
                        }
                    else if (ch < chFmiMin || ch >= chFmiMax ||
                                (dxp = vfmiScreen.mpchdxp[ch]) == dxpNil)
                                dxp = dxpFromCh(ch, FALSE);

                    ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                    ifi.xpPr += dxpPr;
                    vfli.rgch[ifi.ich++] = ch;
#endif  /* KOREA */

#if defined(TAIWAN) || defined(PRC)  //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
SingleDBCS:
#endif  //TAIWAN

                    if (fKanjiPrevious && FOptAdmitCh1(ch)) {
                        fKanjiPrevious = false;
                        if (ifi.xpPr > ifi.xpPrRight) {
                            fKanjiBreakOppr = false;
                            /* If we already have a hanging character past the
                               margin, we don't want to treat this as a
                               hanging character. */
                            if (!fKanjiHanging) {
                                fKanjiHanging = true;
                                ch = chHyphen;
                                goto BreakOppr;
                                }
                            }
                        else {
                            /* We can treat this character as though a Kanji
                               punctuation, as far as line breaking is
                               is concerned. */
                            fKanjiBreakOppr = true;
                            goto BreakOppr;
                            }
                        }
                    else {
                        /* Just go on with a regular English formatting. */
                        fKanjiBreakOppr = false;
                        fKanjiPrevious = false;
                        }
                    }
#if defined(JAPAN) || defined(KOREA)
        }
#endif

#else   /* DBCS */
            ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
            ifi.xpPr += dxpPr;
            vfli.rgch[ifi.ich++] = ch;
#endif

#if defined (TAIWAN)
OnlyDBCSPaste:
#endif
             /* special case "normal characters" above hyphen */
            if (ch > chHyphen)
                goto DefaultCh;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            /*Non Word wrap Not Hyphen break*/
            if(!vfWordWrap) {
                if (ch == chHyphen)
                    goto DefaultCh;
            }
#endif
            switch (ch)
                {

#ifdef CRLF
                case chReturn:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
                    continue;
#endif /* CRLF */

                case chNRHFile:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    ichpNRH = ichpFormat - 1;
#ifdef DFLI
                    {
                    char rgch[100];

                    wsprintf(rgch,"  OptHyph: width==%d, xpPr==%d/%d\n\r",
                        DxpFromCh(chHyphen,true), ifi.xpPr,ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif
                    if (ifi.xpPr + DxpFromCh(chHyphen, true) > ifi.xpPrRight)
                        {
                        /* Won't fit, force a break */
                        goto DoBreak;
                        }

#ifdef CASHMERE
                    else if (fVisiMode)
                        {
                        /* Treat just like a normal hyphen */
                        ch = chHyphen;
                        goto NormChar;
                        }
#endif /* CASHMERE */

                    xpPrev = ifi.xp;
                    vfli.rgch[ifi.ich] = chTab;
                    goto Tab0;

                case chSect:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    vfli.dypFont = vfli.dypLine = (dypAscentMac + (vfli.dypBase
                      = dypDescentMac));
                    vfli.cpMac = vcpFetch + ifi.ichFetch;
                    if (FFirstIch(ifi.ich))
                        {
                        /* Beginning of line; return a splat */
                        vfli.fSplat = true;

                        if (!fFlmPrinting)
                            {

#ifdef CASHMERE
                            int chT = vfli.cpMac == vcpLimSectCache ?
                              chSectSplat : chSplat;
#else /* not CASHMERE */
                            int chT = chSplat;
#endif /* not CASHMERE */

                            int dxpCh = DxpFromCh(chT, false);

                            /* Set the width of the splat to be about 8.5" */
                            int cch = min((dxpLogInch * 17 / 2) / dxpCh,
                              ichMaxLine - 32);

                            bltbc(&vfli.rgch[ifi.ich], chT, cch);
                            bltc(&vfli.rgdxp[ifi.ich], dxpCh, cch);
                            vfli.ichMac = cch + ifi.ich;
                            vfli.xpReal = LOWORD(GetTextExtent(vhMDC,
                              (LPSTR)vfli.rgch, cch));
                            vfli.xpLeft = 0;
                            }
                        else
                            {
                            vfli.ichMac = 0;
                            }
                        goto EndFormat;
                        }

                    /* The section character is in the middle of a line, the
                    line will terminate in front of the character. */
                    /* vfSplatNext = TRUE; No longer used*/
                    vfli.cpMac += cchUsed - 1;
                    vfli.dcpDepend = 1;
                    if (!ifi.fPrevSpace)
                        {
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    goto JustBreak;

                case chTab:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    if (ifi.xpPr < ifi.xpPrRight)
                        {
                        register struct CHP *pchp;
                        unsigned xaPr;
                        unsigned xaTab;

                        if (!ifi.fPrevSpace)
                            {
                            /* Remember number of spaces to left and number of
                            real chars in line for justification */
                            ifi.cBreak = ifi.cchSpace;
                            vfli.ichReal = ifi.ich;
                            ifi.xpReal =  ifi.xp;
                            }

                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        xpPrev = ifi.xp;

                        /* Now get info about this tab */
                        xaPr = MultDiv(ifi.xpPr, dxaPrPage, dxpPrPage);
                        while ((xaTab = ptbd->dxa) != 0)
                            {
#ifdef DBCS             /* was in JAPAN */
                            if (xaTab >= xaRight)
#else
                            if (xaTab > xaRight)
#endif
                                {
                                /* Don't let tabs extend past right margin. */
#ifdef DBCS             /* was in JAPAN */
                break; // Stop to examin next tab-stop
#else
                                xaTab = xaRight;
#endif
                                }

                            if (xaTab >= xaPr)
                                {
                                /* Use tab stop information */

#ifdef CASHMERE
                                ifi.tlc = ptbd->tlc;
#endif /* CASHMERE */

                                ifi.jc = jcTabMin + (ptbd++)->jc;

#ifdef ENABLE /* we do the mapping in HgtbdCreate */
                                if (ifi.jc != jcTabDecimal)
                                    {
                                    ifi.jc = jcTabLeft;
                                    }
#endif
                                goto TabFound;
                                }
                            ptbd++;
                            }

                        /* Out of set tabs; go to next nth column */
                        xaTab = (xaPr / (vzaTabDflt) + 1) * (vzaTabDflt);

#ifdef CASHMERE
                        ifi.tlc = tlcWhite;
#endif /* CASHMERE */

                        ifi.jc = jcTabLeft;

TabFound:
                        xpTab = imax(MultDiv(xaTab, dxpFormat, dxaFormat),
                          ifi.xp);

                        /* Do left-justified tabs immediately */
                        if (ifi.jc == jcTabLeft)
                            {
                            ifi.xp = xpTab;
                            ifi.xpPr = MultDiv(xaTab, dxpPrPage, dxaPrPage);
                            }
                        ifi.xpLeft = ifi.xp;
                        ifi.ichLeft = ifi.ich;
                        ifi.cchSpace = 0;
                        ifi.chBreak = 0;
#if defined(JAPAN) || defined(KOREA)                  //  added  02 Jul. 1992  by Hiraisi
                        iWidenChar=0;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        iWidenChar=0;
#endif

Tab0:
                        ifi.fPrevSpace = false;
                        vfli.ichMac = ifi.ich;
                        vfli.xpReal = ifi.xp;
                        vfli.dypLine = ifi.dypLineSize;
                        vfli.dypBase = dypDescentMac;
                        vfli.dypFont = dypAscentMac + dypDescentMac;

                        if (ifi.ichFetch != 1 && (ichpFormat != ichpMacFormat
                          || FGrowFormatHeap()))
                            {
                            /* Probably in real trouble if FGrowFormatHeap fails
                            at this point */
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            if (ichpFormat > 0)
                                {
                                /* Finish off previous run */
                                pchp->ichRun = ifi.ichPrev;
                                pchp->cchRun = ifi.ich - ifi.ichPrev;
                                }

                            blt(&chpLocal, ++pchp, cwCHP);
                            ichpFormat++;
                            }
                        else
                            {
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            }
                        pchp->ichRun = ifi.ich;
                        pchp->cchRun = ichMaxLine;

#ifdef CASHMERE
                        pchp->chLeader = mptlcch[ifi.tlc];
#endif /* CASHMERE */

                        vfli.rgdxp[ifi.ichPrev = ifi.ich++] = ifi.xp - xpPrev;

                        if (ch != chTab)
                            {
                            /* This character is a non-required hyphen. */
                            Dfli(CommSz("ch is really OptHyph "));
                            goto BreakOppr;
                            }

                        continue;
                        }

                    else
                        {
                        ch = chNBSFile;
                        goto NormChar;
                        }

                case chHyphen:
                    if (ifi.xpPr > ifi.xpPrRight)
                        {
                        goto DoBreak;
                        }

BreakOppr:
                Dfli(CommSz(" BKOPPR\n\r"));
                /*    this case never used in switch - always goto here */
                /* case chSpace:  */
                    if (ifi.ich >= ichMaxLine)
                        {
                        Dfli(CommSzNum("  Unbroken, ich>ichMaxLine\n\r"));
                        goto Unbroken;
                        }

                case chEol:
                case chNewLine:
                    ifi.chBreak = ch;
                    vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch;
                    vfli.xpReal = ifi.xp;
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    vfli.dypFont = dypAscentMac + (vfli.dypBase =
                      dypDescentMac);
                    Dfli(CommSzNumNum("    vfli.xpReal, ichMac ",vfli.xpReal,vfli.ichMac));

#ifdef  DBCS                /* was in JAPAN */
                    /* We recorded the kanji break opportunity, go default
                       character processing. */
                    if (fKanjiBreakOppr)
                        {
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        goto DefaultCh;
                        }
#endif
                    if (ch == chHyphen || ch == chNRHFile)
                        {
                        Dfli(CommSz("    chHyph/OptHyph catch \n\r"));
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    else
                        {
                        if (!ifi.fPrevSpace)
                            {
                            Dfli(CommSz("!fPrevSpace \n\r"));
                            ifi.cBreak = ifi.cchSpace;
#ifdef DBCS         /* was in JAPAN */
                            vfli.ichReal = ifi.ich - dichSpaceAdjust;
                            dichSpaceAdjust = 1;
#else
                            vfli.ichReal = ifi.ich - 1;
#endif
                            ifi.xpReal = (vfli.xpReal = ifi.xp) - dxp;
                            }
                        if (ch == chEol || ch == chNewLine)
                            {

#ifdef CASHMERE
                            if (hfntb != 0 && vfli.cpMac ==
                              (**hfntb).rgfnd[0].cpFtn)
                                {
                                /* End of footnote */
                                if (!fFlmPrinting)
                                    {
                                    vfli.rgch[ifi.ich - 1] = chEMark;
                                    vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                      DxpFromCh(chEMark, false)) - dxp;
                                    vfli.ichReal++;     /* show this guy */
                                    }
                                }
                            else
#endif /* CASHMERE */
                                {

#ifdef CASHMERE
                                int chT = fVisiMode ? ChVisible(ch) : chSpace;
#else /* not CASHMERE */
                                int chT = chSpace;
#endif /* not CASHMERE */

                                int dxpNew = DxpFromCh(chT, fFlmPrinting);

                                vfli.rgch[ifi.ich - 1] = chT;
                                vfli.rgdxp[ifi.ich - 1] = dxpNew;

                                vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                    dxpNew) - dxp;


                                if (!ifi.fPrevSpace)
                                    {
                                    vfli.xpReal += dxpNew - dxp;
#ifdef CASHMERE
                                    vfli.ichReal =
                                         fVisiMode ? ifi.ich : ifi.ich - 1;
#else /* not CASHMERE */
                                    vfli.ichReal = ifi.ich - 1;
#endif /* not CASHMERE */
                                    }
                                }


                            if (ch == chEol)
                                {
JustEol:
                                if (fFlmPrinting)
                                    {
                                    vfli.ichMac = vfli.ichReal;
                                    }
                                if (ifi.jc != jcTabLeft)
                                    {
                                    /* Handle last tab's text */
                                    Justify(&ifi, xpTab, flm);
                                    }
                                else if ((ifi.jc = ppap->jc) != jcBoth &&
                                  ifi.jc != jcLeft)
                                    {
                                    /* Do line justification */
                                    Justify(&ifi, ifi.xpRight, flm);
                                    }
                                vfli.xpRight = ifi.xpRight;
                                goto EndFormat;
                                }
                            else
                                {
                                /* Handle a line break */
                                goto JustBreak;
                                }
                            }
                        ++ifi.cchSpace;
                        ifi.fPrevSpace = true;
                        }
                    break;

DefaultCh:

                default:

#ifdef DFLI
                    {
                    char rgch[100];
                    wsprintf(rgch,"  DefaultCh: %c, xp==%d/%d, xpPr==%d/%d\n\r",
                        ch, ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif /* ifdef DFLI */
#ifdef DBCS         /* was in JAPAN */
                    /* Reset the flag for the next character. */
                    fKanjiBreakOppr = false;
#endif

                    if (ifi.xpPr > ifi.xpPrRight)
DoBreak:
                        {
                        Dfli(CommSz("    BREAK!\n\r"));
                        if (ifi.chBreak == 0)
Unbroken:
                            {
                            /* Admit first character to the line, even if margin
                            is crossed.  First character at ifi.ich - 1 may be
                            preceded by 0 width characters. */
#ifdef DBCS
                            if (IsDBCSLeadByte(ch))
                                {
                                if (FFirstIch(ifi.ich-2) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-2;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 2;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
#ifdef KKBUGFIX /*t-Yoshio*/
                                vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
#else
                                vfli.xpReal = ifi.xpReal = ifi.xp - (dxp * 2);
#endif
                                }
                            else
                                {
                                if (FFirstIch(ifi.ich-1) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-1;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
                                vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
                                }
#else
                            if (FFirstIch(ifi.ich - 1) && ifi.ich < ichMaxLine)
                                {
                                goto PChar;
                                }
                            vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch - 1;
                            vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                            vfli.dypLine = ifi.dypLineSize;
                            vfli.dypFont = dypAscentMac + (vfli.dypBase =
                              dypDescentMac);
                            vfli.dcpDepend = 1;
                            vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
#endif
                            goto DoJustify;
                            }

                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
JustBreak:
                        if (ifi.chBreak == chNRHFile)
                            {
                            /* Append a non-required hyphen to the end of the
                            line. (Replace zero length tab previously
                            inserted)  */

                            Dfli(CommSz("    Breaking line at OptHyphen\n\r"));
                            ifi.xpReal += (vfli.rgdxp[vfli.ichReal - 1] =
                              DxpFromCh(chHyphen, fFlmPrinting));
                            vfli.xpRight = vfli.xpReal = ifi.xpReal;
                            vfli.rgch[vfli.ichReal - 1] = chHyphen;
                            vfli.ichMac = vfli.ichReal;
                            if (ichpNRH < ichpFormat - 1)
                                {
                                register struct CHP *pchp =
                                  &(**vhgchpFormat)[ichpNRH];

                                pchp->cchRun++;
                                if (pchp->ichRun >= vfli.ichMac)
                                    {
                                    pchp->ichRun = vfli.ichMac - 1;
                                    }
                                }
                            }

                        if (fFlmPrinting)
                            {
                            vfli.ichMac = vfli.ichReal;
                            }
                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        else
                            {
DoJustify:
                            if ((ifi.jc = ppap->jc) != jcLeft)
                                {
                                Dfli(CommSzNum("    DoJustify: xpRight ",ifi.xpRight));
                                Justify(&ifi, ifi.xpRight, flm);
                                }
                            }
                        vfli.xpRight = ifi.xpRight;
EndFormat:
                        vfli.ichLastTab = ifi.ichLeft;

#ifdef CASHMERE
                        if (vfli.cpMac == vcpLimParaCache)
                            {
                            vfli.dypAfter = vpapAbs.dyaAfter / DyaPerPixFormat;
                            vfli.dypLine += vfli.dypAfter;
                            vfli.dypBase += vfli.dypAfter;
                            }
#endif /* CASHMERE */

                        Scribble(5, ' ');
                        return;
                        }
                    else
                        {
PChar:
                        /* A printing character */
                        ifi.fPrevSpace = false;
                        }
                    break;

                }       /* Switch */
#ifdef DBCS             /* was in KKBUGFIX */
//
// [yutakan:04/02/91]
//
                if(vfOutOfMemory == TRUE)
                    return;
#endif
            }
        }       /* for ( ; ; ) */

    Scribble(5, ' ');
    }


/* J U S T I F Y */
near Justify(pifi, xpTab, flm)
struct IFI *pifi;
unsigned xpTab;
int flm;
    {
    int dxp;
    int ichT;
    int xpLeft;

//  justified paragraph is restored in Windows 3.1J          by Hiraisi
//#ifdef JAPAN
//    /* In the Kanji Write, there is no justified paragraph. */
//    if (pifi->jc == jcBoth)
//        {
//        /* Assert(FALSE); */
//        pifi->jc = jcLeft;
//      dxp = 0;                /* by yutakan / 08/03/91 */
//        }
//#endif /* ifdef JAPAN */


    xpLeft = pifi->xpLeft;
    switch (pifi->jc)
        {
        CHAR *pch;
        unsigned *pdxp;

#ifdef CASHMERE
        case jcTabLeft:
        case jcLeft:
            return;

        case jcTabRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcTabCenter:
            dxp = (xpTab - xpLeft) - ((pifi->xpReal - xpLeft + 1) >> 1);
            break;
#endif /* CASHMERE */

        case jcTabDecimal:
            dxp = xpTab - xpLeft;
            for (ichT = pifi->ichLeft + 1; ichT < vfli.ichReal &&
              vfli.rgch[ichT] != vchDecimal; ichT++)
                {
                dxp -= vfli.rgdxp[ichT];
                }
            break;

        case jcCenter:
            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                return;
                }
            dxp = dxp >> 1;
            break;

        case jcRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcBoth:
//#if !defined(JAPAN)                  //  added  22 Jun. 1992  by Hiraisi
#if !defined(JAPAN) && !defined(TAIWAN) && !defined(PRC) // Daniel/MSTC, 1993/02/25, for jcBoth

            if (pifi->cBreak == 0)
                {
                /* Ragged edge forced */
                return;
                }

#endif

            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                /* There is nothing to do. */
                return;
                }

//#if !defined(JAPAN)                  //  added  22 Jun. 1992  by Hiraisi
#if !defined(JAPAN) && !defined(TAIWAN) && !defined(PRC)//Daniel/MSTC, 1992,02,25, for jcBoth
            pifi->xp += dxp;
            vfli.xpReal += dxp;
            vfli.dxpExtra = dxp / pifi->cBreak;
#endif

            /* Rounding becomes a non-existant issue due to brilliant
            re-thinking.
                "What a piece of work is man
                How noble in reason
                In form and movement,
                how abject and admirable..."

                        Bill "Shake" Spear [describing Sand Word] */
                {
#ifdef JAPAN                   //  added  22 Jun. 1992  by Hiraisi
          /*
           *  In Japan, we examine the buffer from the beginning of the line.
           *  We find some NULLs in the buffer when a char is deleted,
           * but we can ignore all of them.
          */
                register CHAR *pch;
                register int *pdxp;
                CHAR *endPt;
                int dxpT = dxp;
                int cxpQuotient;
                int cNonWideSpaces;
                int ichLeft;

                if( pifi->ichLeft >= 0 )     /* including some tabs in line */
                    ichLeft = pifi->ichLeft;
                else
                    ichLeft = 0;
                pch = &vfli.rgch[ichLeft];
                pdxp = &vfli.rgdxp[ichLeft];
                endPt = &vfli.rgch[vfli.ichReal];

                if( vfWordWrap ){       /* Word Wrap ON */
                /*
                 *  We examine whether there is no break between a non-Japanese
                 * char and a following Japanese char. The reason is that we
                 * need to widen the non-Japanese char (except tab and space)
                 * if we can find no break there.
                */
                    for( ; pch<endPt ; ){
                        if( IsDBCSLeadByte( *pch ) ){
                            pch+=2;
                        }
                        else{
                            if( *pch != chSpace && *pch != chTab &&
                                !FKana( *pch ) && *pch != NULL ){
                                CHAR *ptr;

                                for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
                                if( IsDBCSLeadByte(*ptr) ){
                                    iWidenChar++;
                                    pch+=2;
                                }
                                else{
                                    if( FKana(*ptr) ){
                                        iWidenChar++;
                                        pch++;
                                    }
                                }
                            }
                            pch++;
                        }
                    }
                    /*
                     *  We decrease iWidenChar if last char of the current line
                     * is Japanese, because it needs not to be widened.
                    */
                    if( *(endPt-1) == NULL ){
                        for( endPt-- ; *endPt==NULL ; endPt-- );
                        endPt++;
                    }
                    if( IsDBCSLeadByte(*(endPt-2)) ){
                        iWidenChar--;
                    }
                    else{
                        if( FKana(*(endPt-1)) )
                            iWidenChar--;
                    }
                    iWidenChar += pifi->cBreak;
                }
                else{                   /* Word Wrap OFF */
                    /*  We widen all chars except last char in the line.  */
                    int iDBCS, ichReal;
                    for( iDBCS=0, ichReal=vfli.ichReal ; pch<endPt ; pch++ ){
                        if( IsDBCSLeadByte( *pch ) ){
                            pch++;
                            iDBCS++;
                        }
                        else{
                            if( *pch == NULL )
                                ichReal--;
                        }
                    }
                    iWidenChar = ichReal - ichLeft - iDBCS - 1;
                }
                if( iWidenChar == 0 )
                    return;

                pifi->xp += dxp;
                vfli.xpReal += dxp;
                vfli.dxpExtra = dxp / iWidenChar;
                cNonWideSpaces = iWidenChar - (dxp % iWidenChar);
                cxpQuotient = vfli.dxpExtra;
                iNonWideSpaces = cNonWideSpaces;

                vfli.ichFirstWide = 0;
                vfli.fAdjSpace = fTrue;

                pch = &vfli.rgch[ichLeft];    /* Reset pch */
                for( ; ; ){
                   if( IsDBCSLeadByte(*pch) ){
                      if( vfli.ichFirstWide == 0 ){
                         int *pdxpT = pdxp;
                         vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                      }
                      *pdxp += cxpQuotient;
                      if( --iWidenChar == 0 )
                         return;
                      if( --cNonWideSpaces == 0 )
                         cxpQuotient++;
                      pch++;
                      pdxp++;
                   }
                   else{
                      if( vfWordWrap ){           /* Word Wrap ON */
                         if( *pch == chSpace || FKana(*pch) ){
                            if( vfli.ichFirstWide == 0 ){
                               int *pdxpT = pdxp;
                               vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            }
                            *pdxp += cxpQuotient;
                            if( --iWidenChar == 0 )
                               return;
                            if( --cNonWideSpaces == 0 )
                                cxpQuotient++;
                         }
                         else{
                            if( *pch != chTab && *pch != NULL ){
                               CHAR *ptr;

                               /*
                                *  We examine whether the following char of
                                * non-Japanese char is Japanese.
                               */
                               for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
                               if( IsDBCSLeadByte(*ptr) || FKana(*ptr) ){
                                  if( vfli.ichFirstWide == 0 ){
                                     int *pdxpT = pdxp;
                                     vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                  }
                                  *pdxp += cxpQuotient;
                                  if( --iWidenChar == 0 )
                                     return;
                                  if( --cNonWideSpaces == 0 )
                                      cxpQuotient++;
                               }
                            }
                         }
                      }
                      else{                       /* Word Wrap OFF */
                         if( *pch != NULL ){
                            if( vfli.ichFirstWide == 0 ){
                               int *pdxpT = pdxp;
                               vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            }
                            *pdxp += cxpQuotient;
                            if( --iWidenChar == 0 )
                               return;
                            if( --cNonWideSpaces == 0 )
                               cxpQuotient++;
                         }
                      }
                   }
                   pch++;
                   pdxp++;
                }

#elif defined(TAIWAN) || defined(PRC)//Daniel/MSTC, 1992/02/25, for jcBoth
          /*
           *  In Japan, we examine the buffer from the beginning of the line.
           *  We find some NULLs in the buffer when a char is deleted,
           * but we can ignore all of them.
          */
      register CHAR *pch;
      register int *pdxp;
      CHAR *endPt;
      int dxpT = dxp;
      int cxpQuotient;
      int cNonWideSpaces;
      int ichLeft;

      if( pifi->ichLeft >= 0 )     /* including some tabs in line */
          ichLeft = pifi->ichLeft;
      else ichLeft = 0;

      pch = &vfli.rgch[ichLeft];
      pdxp = &vfli.rgdxp[ichLeft];
      endPt = &vfli.rgch[vfli.ichReal];

//      if( vfWordWrap ){       /* Word Wrap ON */
      /*
       *  We examine whether there is no break between a non-Japanese
       * char and a following Japanese char. The reason is that we
       * need to widen the non-Japanese char (except tab and space)
       * if we can find no break there.
      */
    for( ; pch<endPt ; )
                {
      if( IsDBCSLeadByte( *pch ) )  pch+=2;
      else
                        {
         if( *pch != chSpace && *pch != chTab && !FKana( *pch ) && *pch != NULL )
                                { CHAR *ptr;
            for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
            if( IsDBCSLeadByte(*ptr) )
                                        {
                                        iWidenChar++;
               pch+=2;
               }
                 else
                                        {
               if( FKana(*ptr) )
                                                {
                  iWidenChar++;
                  pch++;
                  }
               }
            }
            pch++;
         }
      }// for
      /*
       *  We decrease iWidenChar if last char of the current line
       * is Japanese, because it needs not to be widened.
       */
    if( *(endPt-1) == NULL )
                {
      for( endPt-- ; *endPt==NULL ; endPt-- );
      endPt++;
      }
    if( IsDBCSLeadByte(*(endPt-2)) ) iWidenChar--;
    else
                {
      if( FKana(*(endPt-1)) ) iWidenChar--;
      }
    iWidenChar += pifi->cBreak;
//      } // vfWordWrap

    if( iWidenChar == 0 )
                 return;

      pifi->xp += dxp;
      vfli.xpReal += dxp;
      vfli.dxpExtra = dxp / iWidenChar;
      cNonWideSpaces = iWidenChar - (dxp % iWidenChar);
      cxpQuotient = vfli.dxpExtra;
      iNonWideSpaces = cNonWideSpaces;

      vfli.ichFirstWide = 0;
      vfli.fAdjSpace = fTrue;

      pch = &vfli.rgch[ichLeft];    /* Reset pch */
      for( ; ; )
                        {
         if( IsDBCSLeadByte(*pch) )
                                {
            if( vfli.ichFirstWide == 0 )
                                        {
               int *pdxpT = pdxp;
               vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                }
            *pdxp += cxpQuotient;
            if( --iWidenChar == 0 )  return;
            if( --cNonWideSpaces == 0 ) cxpQuotient++;
            pch++;
            pdxp++;
                }
         else
                                {
           // if( vfWordWrap )
                                 if( 1 )
                                        {           /* Word Wrap ON */
               if( *pch == chSpace || FKana(*pch) )
                                                {
                  if( vfli.ichFirstWide == 0 )
                                                        {
                     int *pdxpT = pdxp;
                     vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                        }
                  *pdxp += cxpQuotient;
                  if( --iWidenChar == 0 ) return;
                  if( --cNonWideSpaces == 0 ) cxpQuotient++;
                }
               else
                                                {
                  if( *pch != chTab && *pch != NULL )
                                                        {
                     CHAR *ptr;

                     /*
                      *  We examine whether the following char of
                      * non-Japanese char is Japanese.
                     */
                     for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
                     if( IsDBCSLeadByte(*ptr) || FKana(*ptr) )
                                                                {
                        if( vfli.ichFirstWide == 0 )
                                                                        {
                           int *pdxpT = pdxp;
                           vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                }
                        *pdxp += cxpQuotient;
                        if( --iWidenChar == 0 ) return;
                        if( --cNonWideSpaces == 0 ) cxpQuotient++;
                        }
                        }
                } //else : ==chSpace || FKana()
                    } //Word Wrap On
                 }
         pch++;
         pdxp++;
              }//for
#else     // not JAPAN
                register CHAR *pch = &vfli.rgch[vfli.ichReal];
                register int *pdxp = &vfli.rgdxp[vfli.ichReal];
                int dxpT = dxp;
                int cBreak = pifi->cBreak;
                int cxpQuotient = (dxpT / cBreak) + 1;
                int cWideSpaces = dxpT % cBreak;

                vfli.fAdjSpace = fTrue;

                for ( ; ; )
                    {
                    /* Widen blanks */
                    --pch;
                    --pdxp;
#if defined(KOREA)
                    if ((*pch == chSpace) || FKanjiSpace(*pch, *(pch-1)))
                        {
                        if (FKanjiSpace(*pch, *(pch-1)))
                            --pch;
#else
                    if (*pch == chSpace)
                        {
#endif
                        if (cWideSpaces-- == 0)
                            {
                            int *pdxpT = pdxp + 1;

                            while (*pdxpT == 0)
                                {
                                pdxpT++;
                                }
                            vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            cxpQuotient--;
                            }
                        *pdxp += cxpQuotient;
                        if ((dxpT -= cxpQuotient) <= 0)
                            {
                            if (pifi->cBreak > 1)
                                {
                                int *pdxpT = pdxp + 1;

                                while (*pdxpT == 0)
                                    {
                                    pdxpT++;
                                    }
                                vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                }
                            return;
                            }
                        pifi->cBreak--;
                        }
                    }
#endif    // JAPAN
                }
        }       /* Switch */

    if (dxp <= 0)
        {
        /* Nothing to do */
        return;
        }

    pifi->xp += dxp;

    if (flm & flmPrinting)
        {
        pifi->xpPr += dxp;
        }
    else
        {
        /* This statememt might introduce rounding errors in pifi->xpPr, but
        with luck, they will be small. */
        pifi->xpPr += MultDiv(MultDiv(dxp, czaInch, dxpLogInch), dxpPrPage,
          dxaPrPage);
        }

    if (pifi->ichLeft < 0)
        {
        /* Normal justification */
        vfli.xpLeft += dxp;
        }
    else
        {
        /* Tab justification */
        vfli.rgdxp[pifi->ichLeft] += dxp;
        }
    vfli.xpReal += dxp;
    }


/* F  G R O W  F O R M A T  H E A P */
int near FGrowFormatHeap()
    {
    /* Grow vhgchpFormat by 20% */
    int cchpIncr = ichpMacFormat / 5 + 1;

#ifdef WINHEAP
    if (!LocalReAlloc((HANDLE)vhgchpFormat, (ichpMacFormat + cchpIncr) * cchCHP,
      NONZEROLHND))
#else /* not WINHEAP */
    if (!FChngSizeH(vhgchpFormat, (ichpMacFormat + cchpIncr) * cwCHP, false))
#endif /* not WINHEAP */

        {
        /* Sorry, charlie */
        return false;
        }
    ichpMacFormat += cchpIncr;
    return true;
    }


/* #define DBEMG */
/* D X P  F R O M  C H */
#ifdef DBCS
/* DxpFromCh() assumes that ch passed is the first byte of a DBCS character
   if it is a part of such character. */
#endif
int DxpFromCh(ch, fPrinter)
int ch;
int fPrinter;
    {
    int               *pdxp; // changed to int (7.23.91) v-dougk
    int               dxpDummy; // changed to int (7.23.91) v-dougk

    extern int        dxpLogCh;
    extern struct FCE *vpfceScreen;

    /* If the width is not in the width table, then get it. */
    if (ch < chFmiMin)
        {
        switch (ch)
            {
        case chTab:
        case chEol:
        case chReturn:
        case chSect:
        case chNewLine:
        case chNRHFile:
            /* the width for these characters aren't really important */
        pdxp = (CHAR *)(fPrinter ? &vfmiPrint.dxpSpace : &vfmiScreen.dxpSpace);
            break;
        default:
            pdxp = &dxpDummy;
            *pdxp = dxpNil;
            break;
            }
        }
    else if (ch >= chFmiMax)
        {
        /* outside the range we hold in our table - kludge it */
        pdxp = &dxpDummy;
        *pdxp = dxpNil;
        }
    else
        {
        /* inside our table */
        pdxp = (fPrinter ? vfmiPrint.mpchdxp : vfmiScreen.mpchdxp) + ch;
        }

#ifdef DBCS
#ifdef KOREA
    if (*pdxp == dxpNil && IsDBCSLeadByte(HIBYTE(ch)) )
#else
    if (*pdxp == dxpNil && IsDBCSLeadByte(ch) )
#endif
        {
        int dxp;
#else
    if (*pdxp == dxpNil)
        {
        int dxp;
#endif

#ifdef DBCS
        struct FMI *pfmi;
#if 0 /*T-HIROYN*/
        int        rgchT[cchDBCS]; // changed to int (7.23.91) v-dougk
#endif
        CHAR       rgchT[cchDBCS]; // changed to int (7.23.91) v-dougk
        int        dxpT;
        int        dxpDBCS;

        pfmi = fPrinter ? (&vfmiPrint) : (&vfmiScreen);
        Assert(pfmi->bDummy == dxpNil);
        if (pfmi->dxpDBCS == dxpNil)
            {
#ifdef  KOREA   /* 90.12.26  For variable width by sangl */
            rgchT[0] = HIBYTE(ch);
            rgchT[1] = LOBYTE(ch);
#else
            /* Get the width from GDI. */
            rgchT[0] = rgchT[1] = ch;
#endif
            dxpDBCS = (fPrinter ?
                            LOWORD(GetTextExtent(vhDCPrinter,
                                                 (LPSTR) rgchT, cchDBCS)) :
                            LOWORD(GetTextExtent(vhMDC,
                                                 (LPSTR) rgchT, cchDBCS)));
#ifndef  TEMP_KOREA   /* For variable width by sangl 90.12.26 */
            /* Store in fmi, if it fits. */
            if (0 <= dxpDBCS && dxpDBCS < dxpNil)
#if defined(JAPAN) || defined(KOREA) || defined(TAIWAN) || defined(PRC)    //Win3.1 BYTE-->WORD
                pfmi->dxpDBCS = (WORD) dxpDBCS;
#else
                pfmi->dxpDBCS = (BYTE) dxpDBCS;
#endif
#endif
            return (dxpDBCS - pfmi->dxpOverhang);
            }
        else
            return (pfmi->dxpDBCS - pfmi->dxpOverhang);
        }
#if defined(KOREA)
    else if (*pdxp == dxpNil)  {
#else
    else {
#endif
        int dxp;
#endif /* DBCS */
        /* get width from GDI */
        dxp = fPrinter ? LOWORD(GetTextExtent(vhDCPrinter, (LPSTR)&ch, 1)) -
          vfmiPrint.dxpOverhang : LOWORD(GetTextExtent(vhMDC, (LPSTR)&ch, 1)) -
          vfmiScreen.dxpOverhang;
#ifdef DBEMG
            CommSzNum("Get this.... ", dxp);
#endif
        //(7.24.91) v-dougk if (dxp >= 0 && dxp < dxpNil)
            {
            /* only store dxp's that fit in a byte */
            *pdxp = dxp;
            }

#ifdef DBEMG
        {
        char szT[10];
        CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
        if (ch == 0x0D) {
            szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
            }
        else if (ch == 0x0A) {
            szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
            }
        else if (32 <= ch && ch <= 126) {
            szT[0] = ch; szT[1] ='\0';
            }
        else if (FKanji1(ch)) {
            szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
            szT[4] = 'I'; szT[5] = '\0';
            }
        else {
            szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
            }
        CommSzSz("Character: ", szT);
        CommSzNum("Dxp:      ", (int) dxp);
        CommSzNum("OverHang: ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
        }
#endif
        return(dxp);
        }

#ifdef DBEMG
    {
    char szT[10];
    CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
    if (ch == 0x0D) {
        szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
        }
    else if (ch == 0x0A) {
        szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
        }
    else if (32 <= ch && ch <= 126) {
        szT[0] = ch; szT[1] ='\0';
        }
    else if (FKanji1(ch)) {
        szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
        szT[4] = 'I'; szT[5] = '\0';
        }
    else {
        szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
        }
    CommSzSz("Character: ", szT);
    CommSzNum("Dxp:       ", (int) *pdxp);
    CommSzNum("OverHang:  ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
    }
#endif
    return(*pdxp);
    }

#ifdef DBCS
//
//   DxpFromCh for DBCS
//                                           yutakan, 03 Oct 1991

int DBCSDxpFromCh(ch, ch2, fPrinter)
int ch;
int ch2;
int fPrinter;
{
   /* T-HIROYN sync us 3.1*/
    int               *pdxp; // changed to int (7.23.91) v-dougk
    int               dxpDummy; // changed to int (7.23.91) v-dougk

    extern int        dxpLogCh;
    extern struct FCE *vpfceScreen;
    /* If the width is not in the width table, then get it. */
    if (ch < chFmiMin)
        {
        switch (ch)
            {
        case chTab:
        case chEol:
        case chReturn:
        case chSect:
        case chNewLine:
        case chNRHFile:
            /* the width for these characters aren't really important */
        pdxp = (CHAR *)(fPrinter ? &vfmiPrint.dxpSpace : &vfmiScreen.dxpSpace);
            break;
        default:
            pdxp = &dxpDummy;
            *pdxp = dxpNil;
            break;
            }
        }
    else if (ch >= chFmiMax)
        {
        /* outside the range we hold in our table - kludge it */
        pdxp = &dxpDummy;
        *pdxp = dxpNil;
        }
    else
        {
        /* inside our table */
        pdxp = (fPrinter ? vfmiPrint.mpchdxp : vfmiScreen.mpchdxp) + ch;
        }


    if (*pdxp == dxpNil )
       {
       int dxp;

#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
       // BUG 5477: Echen: add NON FA font, LeadByte + 2nd byte checking
       if( ch2 != 0 && IsDBCSLeadByte(ch) && GetFontAssocStatus(vhMDC))
#else
       if( IsDBCSLeadByte(ch) )
#endif  //TAIWAN
           {

           struct FMI *pfmi;
#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //for Bug# 3362, MSTC - pisuih, 2/10/93
           CHAR       rgchT[cchDBCS << 1];
           int        dxpOverhang;
#else
           CHAR       rgchT[cchDBCS];
#endif //TAIWAN
           int        dxpT;
           int        dxpDBCS;

           pfmi = fPrinter ? (&vfmiPrint) : (&vfmiScreen);
           Assert(pfmi->bDummy == dxpNil);

#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //fix Italic position error while SBCS's overhang != DBCS's overhang
                //for Bug# 3362, MSTC - pisuih, 3/4/93

           //fix Go To page too slow, pisuih, 3/4/93
           if ( (!pfmi->dxpDBCS) || (pfmi->dxpDBCS == dxpNil) )
           {
               rgchT[0] = rgchT[2] = ch;
               rgchT[1] = rgchT[3] = ch2;
               dxpDBCS = LOWORD(GetTextExtent( (fPrinter ? vhDCPrinter : vhMDC),
                                                     (LPSTR) rgchT, cchDBCS ));
               dxpOverhang = (dxpDBCS << 1) - LOWORD( GetTextExtent(
                  (fPrinter ? vhDCPrinter : vhMDC), (LPSTR) rgchT, cchDBCS << 1 ));

               //for compatible with SBCS's overhang
               dxpDBCS += (pfmi->dxpOverhang - dxpOverhang);

               /* Store in fmi, if it fits. */
               if (0 <= dxpDBCS && dxpDBCS < dxpNil)
                       pfmi->dxpDBCS = (WORD) dxpDBCS;

               return (dxpDBCS - pfmi->dxpOverhang);
           }
           else
               return (pfmi->dxpDBCS - pfmi->dxpOverhang);
#else
           if(pfmi->dxpDBCS == dxpNil)
               {
               /* Get the width from GDI. */
           rgchT[0] = ch;
           rgchT[1] = ch2;
               dxpDBCS = (fPrinter ?
                            LOWORD(GetTextExtent(vhDCPrinter,
                                                 (LPSTR) rgchT, cchDBCS)) :
                            LOWORD(GetTextExtent(vhMDC,
                                                 (LPSTR) rgchT, cchDBCS)));
               /* Store in fmi, if it fits. */
               if (0 <= dxpDBCS && dxpDBCS < dxpNil)
#if defined(JAPAN) || defined(KOREA)    //Win3.1 BYTE-->WORD
                   pfmi->dxpDBCS = (WORD) dxpDBCS;
#else
                   pfmi->dxpDBCS = (BYTE) dxpDBCS;
#endif
               return (dxpDBCS - pfmi->dxpOverhang);
               }
           else
               return (pfmi->dxpDBCS - pfmi->dxpOverhang);
#endif //TAIWAN
           }
       else
           {
           /* get width from GDI */
           dxp = fPrinter ? LOWORD(GetTextExtent(vhDCPrinter, (LPSTR)&ch, 1)) -
          vfmiPrint.dxpOverhang : LOWORD(GetTextExtent(vhMDC, (LPSTR)&ch, 1)) -
          vfmiScreen.dxpOverhang;
           }
   /*T-HIROYN sync us 3.1*/
        //(7.24.91) v-dougk if (dxp >= 0 && dxp < dxpNil)
           {
           /* only store dxp's that fit in a byte */
           *pdxp = dxp;
           }

       return(dxp);
       }


   return(*pdxp);
   }

#endif


/* F  F I R S T  I C H */
int near FFirstIch(ich)
int ich;
    {
    /* Returns true iff ich is 0 or preceded only by 0 width characters */
    register int ichT;
    register int *pdxp = &vfli.rgdxp[0];

    for (ichT = 0; ichT < ich; ichT++)
        {
        if (*pdxp++)
            {
            return false;
            }
        }
    return true;
    }


ValidateMemoryDC()
    {
    /* Attempt to assure that vhMDC and vhDCPrinter are valid.  If we have not
    already run out of memory, then vhDCPrinter is guaranteed, but vhMDC may
    fail due to out of memory -- it is the callers responsibility to check for
    vhMDC == NULL. */

    extern int vfOutOfMemory;
    extern HDC vhMDC;
    extern BOOL vfMonochrome;
    extern long rgbText;
    extern struct WWD *pwwdCur;

    /* If we are out of memory, then we shouldn't try to gobble it up by getting
    DC's. */
    if (!vfOutOfMemory)
        {
        if (vhMDC == NULL)
            {
            /* Create a memory DC compatible with the screen if necessary. */
            vhMDC = CreateCompatibleDC(pwwdCur->hDC);

            /* Callers are responsible for checking for vhMDC == NULL case */
            if (vhMDC != NULL)
                {
                /* Put the memory DC in transparent mode. */
                SetBkMode(vhMDC, TRANSPARENT);

                /* If the display is a monochrome device, then set the text
                color for the memory DC.  Monochrome bitmaps will not be
                converted to the foreground and background colors in this case,
                we must do the conversion. */
                if (vfMonochrome = (GetDeviceCaps(pwwdCur->hDC, NUMCOLORS) ==
                  2))
                    {
                    SetTextColor(vhMDC, rgbText);
                    }
                }
            }

        /* If the printer DC is NULL then we need to reestablish it. */
        if (vhDCPrinter == NULL)
            {
            GetPrinterDC(FALSE);
            /* GetPrinterDC has already called SetMapperFlags() on vhDCPrinter. */
            }
        }
    }

#ifdef DBCS
/* The following two functions are used to determine if a given kanji
   (two byte) character (or 1 byte kana letters) should be admitted
   to the current line without causing the line break though it is
   passed the right margin.

   The table below shows which letters are admitted as a hanging character
   on a line.  The table below should be updated in sync with the code
   itself.

   Kanji (2-byte) characters

            letter           first byte  second byte       half width
        hiragana small a        82          9F
                       i        82          A1
                       u        82          A3
                       e        82          A5
                       o        82          A7
                       tsu      82          C1
                       ya       82          E1
                       yu       82          E3
                       yo       82          E5
        katakana small a        83          40              85 A5
                       i        83          42              85 A6
                       u        83          44              85 A7
                       e        83          46              85 A8
                       o        83          48              85 A9
                       tsu      83          62              85 AD
                       ya       83          83              85 AA
                       yu       83          85              85 AB
                       yo       83          87              85 AC
                       wa       83          8E
                       ka       83          95
                       ke       83          96
                    blank       81          40
        horizontal bar (long)   81          5B              85 AE
                       (med)    81          5C
                       (short)  81          5D
        touten
          (Japanese comma)      81          41              85 A2
        kuten
          (Japanese period)     81          42              85 9F
        handakuten              81          4B              85 DD
        dakuten                 81          4A              85 DC
        kagikakko
          (closing Japanese parenthesis)
                                81          76              85 A1
        " (2-byte)              81          68              85 41
        ' (2-byte)              81          66              85 46
        } (2-byte)              81          70              85 9D
        ] (2-byte)              81          6E              85 7C
        ) (2-byte)              81          6A              85 48
        . (at the center)       81          45              85 A3
        ...                     81          63
        ..                      81          64
        closing angle bracket   81          72
        closing double angled bracket
                                81          74
        closing double kagikakko
                                81          78
        closing inversed )      81          7A
        closing half angled bracket
                                81          6C
        thinner '               81          8C
        thinner "               81          8D

   1-byte kana characters

            letter             byte
        katakana small a        A7
                       i        A8
                       u        A9
                       e        AA
                       o        AB
                     tsu        AF
                      ya        AC
                      yu        AD
                      yo        AE
        touten
          (Japanese comma)      A4
        kuten
          (Japanese period)     A1
        handakuten              DF
        dakuten                 DE
        kagikakko
          (closing Japanese parenthesis)
                                A3
        . (at the center)       A5

   The following 1 or 2 byte characters are treated as a hanging character
   if the previous character is a 2-byte kanji character.

                      letter    byte
                        "        22
                        '        27
                        }        7D
                        ]        5D
                        )        29
                        .        2E
                        ,        2C
                        ;        3B
                        :        3A
                        ?        3F
                        !        21

                                byte 1      byte 2
                        .        81          44
                        ,        81          43
                        ;        81          47
                        :        81          46
                        ?        81          48
                        !        81          49


                        .        85          4D
                        ,        85          4B
                        ;        85          4A
                        :        85          49
                        ?        85          5E
                        !        85          40

*/

BOOL near FSearchChRgch(ch, rgch, ichLim)
    CHAR    ch;
    CHAR    *rgch;
    int     ichLim;
{
    int   ichMin;
    BOOL  fFound;

    fFound  = FALSE;
    ichMin  = 0;

    while (!fFound && ichMin <= ichLim) {
        int     ichMid;
        CHAR    chMid;

        /* Save on the dereferencing. */
        chMid = rgch[ichMid = (ichMin + ichLim) >> 1];
        if (ch == chMid) {
            fFound = TRUE;
            }
        else if (ch < chMid) {
            ichLim = ichMid - 1;
            }
        else {
            ichMin = ichMid + 1;
            }
        }
    return (fFound);
}

/* FAdmitCh1() returns true if and only if the given ch is a one-byte
   kana code for those letters that can appear beyond the right margin. */

BOOL near FAdmitCh1(ch)
    CHAR    ch;
{
#ifdef JAPAN
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
    return (
        (ch == 0xA1) ||
        ((0xA3 <= ch) && (ch <= 0xA5)) ||
        ((0xA7 <= ch) && (ch <= 0xAF)) ||
        ((0xDE <= ch) && (ch <= 0xDF))
        );
#else
    return(FALSE);
#endif
}

/* FOptAdmitCh1() returns true if and only if the given ch is a
   one-byte character that can be admitted to the end of a line
   beyond the right margin, if it appears after a kanji character. */

BOOL near FOptAdmitCh1(ch)
    CHAR    ch;
{
    static CHAR rgchOptAdmit1[]
                    = {0x21, 0x22, 0x27, 0x29, 0x2C, 0x2E, 0x3A, 0x3B,
                       0x3F, 0x5D, 0x7D};
#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    return (FSearchChRgch(ch, rgchOptAdmit1,
                          (sizeof(rgchOptAdmit1) / sizeof(CHAR)) - 1));
}

/* FAdmitCh2() returns true if and only if the given (ch1, ch2) combination
   represents a kanji (2-byte) letter that can appear beyond the right
   margin. */

BOOL near FAdmitCh2(ch1, ch2)
    CHAR    ch1, ch2;
{
    int   dch=0;

#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    while((dch < MPDCHRGCHIDX_MAC) && (ch1 != mpdchrgchIdx[dch]))
    dch++;
    if (dch < MPDCHRGCHIDX_MAC) {
        return (FSearchChRgch(ch2, mpdchrgch[dch], mpdchichMax[dch] - 1));
        }
    else {
        return (FALSE);
        }
}

/* FOptAdmitCh2() returns true if and only if the given (ch1, ch2) is a
   two-byte character combination that can be admitted to the end of a line
   beyond the right margin, provided it appears after a kanji character. */

BOOL near FOptAdmitCh2(ch1, ch2)
    CHAR    ch1, ch2;
{
    int i=0;
#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    while ((i < OPTADMIT2IDX_MAC) && (ch1 != OptAdmit2Idx[i]))
    i++;
    if (i < OPTADMIT2IDX_MAC){
    return (FSearchChRgch(ch2, mpdchrgchOptAdmit2[i], OptAdmit2ichMax[i]));
        }
    else {
        return (FALSE);
        }
}


/* FOptAdmitCh() returns TRUE if and only if the given (ch1, ch2) can
   be a hanging letter at the end of a line.  Otherwise, FALSE.  If ch1
   is equal to '\0', ch2 is treated as a 1-byte character code. */

BOOL FOptAdmitCh(ch1, ch2)
    CHAR ch1, ch2;
{
#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    if (ch1 == '\0') {
        return ((ch2 == chSpace) || FAdmitCh1(ch2) || FOptAdmitCh1(ch2));
        }
    else {
        return (FKanjiSpace(ch1, ch2) || FAdmitCh2(ch1, ch2) ||
                FOptAdmitCh2(ch1, ch2));
        }
}
#endif /* ifdef DBCS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\d_selec2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Select2.c -- Less-frequently-used selection routines */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "toolbox.h"
#include "docdefs.h"
#include "editdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "fmtdefs.h"
#include "propdefs.h"

#ifdef	DBCS
#include "kanji.h"
#endif

extern int		vfSeeSel;
extern typeCP		vcpFirstParaCache;
extern typeCP		vcpLimParaCache;
extern typeCP		vcpFetch;
extern CHAR		*vpchFetch;
extern int		vccpFetch;
extern typeCP		cpMinCur;
extern typeCP		cpMacCur;
extern struct SEL	selCur;
extern int		docCur;
extern struct FLI	vfli;
extern struct WWD	rgwwd[];
extern int		vfSelHidden;
extern int		wwCur;
extern struct CHP	vchpFetch;
extern struct PAP	vpapAbs;
extern struct WWD	*pwwdCur;
extern int		vfInsEnd;
extern typeCP		CpBeginLine();
extern int		vfPictSel;
extern int		vfSizeMode;
extern struct CHP	vchpNormal;
extern int		vfInsertOn;
extern struct CHP	vchpSel;	/* Holds the props when the selection
						is an insert point */
extern int vfMakeInsEnd;
extern typeCP vcpSelect;
extern int vfSelAtPara;
/* true iff the last selection was made by an Up/Down cursor key */
extern int vfLastCursor;


#ifndef DBCS	/* US version */
/* C P	L I M  S T Y  S P E C I A L */
typeCP CpLimStySpecial(cp, sty)
typeCP cp;
int sty;
{    /* Return the first cp which is not part of the same sty unit */
	int wb, ch, ich;
	struct EDL *pedl;

	/* Other cases covered in CpLimSty, our only caller */

	Assert( cp < cpMacCur );
	Assert( cp >= cpMinCur );
	Assert( sty == styWord || sty == stySent );

/* Special kludge for picture paragraphs */
	CachePara(docCur, cp);
	if (vpapAbs.fGraphics)
		return vcpLimParaCache;

	FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);

	Assert(vccpFetch != 0);

	/* Must be word or sentence */
	wb = WbFromCh(ch = vpchFetch[ich = 0]);
#ifdef CRLF
	if (ch == chReturn)
		return vcpFetch + 2;
#endif
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab)
		/* EOL is its own unit */
		return vcpFetch + 1;

	if (wb == wbWhite && sty == stySent)
		{ /* Might be between sentences; go back to text */
		FetchCp(docCur, CpFirstSty(cp, styWord), 0, fcmChars + fcmNoExpand);
		wb = WbFromCh(ch = vpchFetch[ich = 0]);
		}

	for (;;)
		{
		if (++ich >= vccpFetch)
			{ /* Get next line and set up */
			FetchCp(docNil, cpNil, 0, fcmChars);
			if (vcpFetch == cpMacCur)
				return cpMacCur; /* End of doc */
			ich = 0;
			}
		if (sty == stySent)
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				sty = styWord;
				wb = wbPunct;
				}
		switch (ch = vpchFetch[ich])
			{
		case chTab:
		case chEol:
		case chSect:
		case chNewLine:
#ifdef CRLF
		case chReturn:
#endif
			goto BreakFor;
			}
		if (sty == styWord)
			{ /* Word ends after white space or on text/punct break */
			int wbT = WbFromCh(ch);
			if (wb != wbT && (wb = wbT) != wbWhite)
				break;
			}
		}
	BreakFor:
	return vcpFetch + ich;
}



/* C P	F I R S T  S T Y  S P E C I A L */
typeCP CpFirstStySpecial(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
	typeCP cpBegin;
	int wb, ch, dcpChunk;
	typeCP cpSent;
	CHAR rgch[dcpAvgSent];
	int ich;
	typeCP cpT;

	/* Other cases were covered by CpFirstSty, our only caller */

	Assert( cp > cpMinCur );
	Assert( sty == stySent || sty == styWord );

	if (cp >= cpMacCur)
	    cpT = cp = cpMacCur;
	else
	    cpT = cp++;

	CachePara(docCur, cpT );
	if ((vcpFirstParaCache == cpT) || vpapAbs.fGraphics)
	    return vcpFirstParaCache;

	dcpChunk = (sty == styWord) ? dcpAvgWord : dcpAvgSent;
	cpBegin = (cp > dcpChunk) ? cp - dcpChunk : cp0;

	FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
	wb = WbFromCh(ch = rgch[--ich]);

#ifdef CRLF
	if(cpBegin + ich == 0)
	    return cp0;

	if (ch == chEol && rgch[ich-1] == chReturn) /* EOL is its own unit */
	    return cpBegin + ich - 1;
	if (ch == chEol || ch == chReturn || ch == chSect || ch == chNewLine || ch == chTab)
	    return cpBegin + ich;
#else /* not CRLF */
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab) /* EOL is its own unit */
	    return cpBegin + ich;
#endif /* CRLF */

	if (wb == wbText)
		cpSent = cpBegin + ich;
	else
		cpSent = cpNil;

	for (;;)
		{
		if (ich == 0)
			{
			if (cpBegin == cpMinCur)
				return cpMinCur; /* beginning of doc */
			cpBegin = (cpBegin > dcpChunk) ? cpBegin - dcpChunk : cp0;
			FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
			}
		ch = rgch[--ich];
		CachePara( docCur, cpBegin + ich ); /* Needed for pictures */
		if (ch == chEol || ch == chSect || ch == chNewLine ||
				   ch == chTab || vpapAbs.fGraphics )
			break; /* EOL Always ends a unit */
		if (sty == styWord)
			{
			if (wb != wbWhite)
				{
				if (WbFromCh(ch) != wb)
					break;
				}
			else
				wb = WbFromCh(ch);
			}
		else
			{ /* Test for sentence. */
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				if (cpSent != cpNil)
					return cpSent;
				}
			switch (WbFromCh(ch))
				{
			case wbText:
				cpSent = cpBegin + ich;
				wb = wbText;
				break;
			case wbPunct:
				switch (wb)
					{
				case wbWhite:
					wb = wbPunct;
					break;
				case wbText:
					cpSent = cpBegin + ich;
					}
				break;
			case wbWhite:
				if (wb == wbPunct)
					cpSent = cpBegin + ich + 1;
				wb = wbWhite;
				break;
				}
			}
		}
	return cpBegin + ich + 1;
}

#else		/* DBCS version */

typeCP CpLimStySpecial(cp, sty)
    typeCP	cp;
    int 	sty;
{
    CHAR	rgch[cchKanji];
    int 	ch, ch2;
    int 	ich, wb;
    typeCP	cpLim, cpT;

    /* Other cases covered in CpLimSty, our only caller */
    Assert(cp < cpMacCur);
    Assert(cp >= cpMinCur);
    Assert(sty == styWord || sty == stySent);

    /* Picture paragraph? */
    CachePara(docCur, cp);
    if (vpapAbs.fGraphics) {
	return vcpLimParaCache;
	}

    cpLim = vcpLimParaCache;
    if (vcpLimParaCache > cpMacCur) {
	/* No EOL at end of doc */
	cpLim = cpMacCur;
	}

    FetchRgch(&ich, rgch, docCur, cp,
	      ((cpT = cp + cchKanji) < cpLim) ? cpT : cpLim, cchKanji);
    ch = rgch[0];
#ifdef CRLF
    if (ch == chReturn) {
	return (cp + 2);
	}
#endif /* CRLF */
    if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab) {
	/* EOL is its own unit. */
	return (cp + 1);
	}
#ifdef	KOREA
	wb=WbFromCh(ch);
#else

    if (FKanji1(ch)) {
	wb = WbFromKanjiChCh(ch, (int) rgch[1]);
	if (sty == styWord && wb == wbKanjiText) {
	    return (CpLimSty(cp, styChar));
	    }
	else {
	    if (wb == wbKanjiText) {
		wb = wbKanjiTextFirst;
		}
	    }
	}
    else {
	if (sty == styWord && FKanaText(ch)) {
	    return (CpLimSty(cp, styChar));
	    }
	wb = WbFromCh(ch);
	}
#endif

    for (; cp < cpLim;) {
	int	    wbT;

	if (sty == stySent) {
	    if (FKanji1(ch)) {
		CHAR ch2;

		ch2 = rgch[1];
		if (FKanjiKuten(ch, ch2)  ||
		    FKanjiQMark(ch, ch2)  ||
		    FKanjiBang(ch, ch2)   ||
		    FKanjiPeriod(ch, ch2)) {
			sty = styWord;
			wb = wbPunct;
			goto lblNextFetch;
		    }
		}
	    else {
		switch (ch) {
#ifndef  KOREA
		    case bKanjiKuten:
#endif
		    case chDot:
		    case chBang:
		    case chQMark:
			sty = styWord;
			wb = wbPunct;
			goto lblNextFetch;
		    }
		}
	    }

	switch (ch) {
	    case chTab:
	    case chEol:
	    case chSect:
	    case chNewLine:
#ifdef CRLF
	    case chReturn:
#endif /* CRLF */
		return cp;
	    }

	if (sty == styWord) {
#ifdef	KOREA
	    wbT = WbFromCh(ch);
#else
	    if (FKanji1(ch)) {
		wbT = WbFromKanjiChCh(ch, (int) rgch[1]);
		}
	    else {
		wbT = WbFromCh(ch);
		}
#endif

	    if (wb != wbT && (wb = wbT) != wbWhite) {
		return (cp);
		}
	    }

lblNextFetch:
	cp = CpLimSty(cp, styChar);
	if (cp < cpLim) {
	    /* Save some time and an untimely demise.... */
	    FetchRgch(&ich, rgch, docCur, cp,
		      ((cpT = cp + cchKanji) < cpLim) ? cpT : cpLim, cchKanji);
	    ch = rgch[0];
	    }
	}
    return (cpLim);
}

typeCP CpFirstStySpecial(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
    typeCP	cpT, cpLim, cpFirstPara,
		cpFirstLastSent; /* cpFirst of the last possible sentence boundary */
    CHAR	rgch[cchKanji];
    int 	ch;
    int 	wb;
    int 	ich;

    /* Other cases were covered by CpFirstSty, our only caller */

    Assert( cp > cpMinCur );
    Assert(CpFirstSty(cp, styChar) == cp); /* cp is on a char boundary */
    Assert( sty == stySent || sty == styWord );

    cpT = cp;
    if (cp >= cpMacCur) {
	cpT = cp = cpMacCur;
	}

    CachePara(docCur, cpT );
    cpFirstPara = vcpFirstParaCache;
    if ((vcpFirstParaCache == cpT) || vpapAbs.fGraphics) {
	return vcpFirstParaCache;
	}


#ifdef CRLF
    /* CR-LF is assumed. */
    Assert(TRUE);
#else
    Assert(FALSE);
#endif /* CRLF */
    FetchRgch(&ich, rgch, docCur, cp,
	      ((cpT = cp + cchKanji) < cpMacCur) ? cpT : cpMacCur, cchKanji);
    ch = rgch[0];
    if (ich == cchKanji && ch == chReturn && rgch[1] == chEol) {
	/* EOL is its own unit */
	return cp;
	}
    if (ch == chEol	|| ch == chReturn || ch == chSect ||
	ch == chNewLine || ch == chTab) {
	    return cp;
	    }

    cpFirstLastSent = cpNil;

#ifdef	KOREA
    wb = WbFromCh(ch);
#else
    if (FKanji1(ch)) {
	wb = WbFromKanjiChCh(ch, (int) rgch[1]);
	if (sty == styWord && wb == wbKanjiText) {
	    return (CpFirstSty(cp, styChar));
	    }
	else {
	    if (wb == wbKanjiText) {
		wb = wbKanjiTextFirst;
		}
	    }
	}
    else {
	if (sty == styWord && FKanaText(ch)) {
	    return (CpFirstSty(cp, styChar));
	    }
	wb = WbFromCh(ch);
	}
#endif

    for (; cpFirstPara < cp; ) {
	typeCP	cpTemp;
	int	wbT;

	cpTemp = CpFirstSty(cp - 1, styChar);
	FetchRgch(&ich, rgch, docCur, cpTemp,
		  ((cpT = cpTemp + cchKanji) < cpMacCur) ? cpT : cpMacCur, cchKanji);
	ch = rgch[0];
#ifdef	KOREA
	wbT = WbFromCh(ch);
#else
	if (FKanji1(ch)) {
	    wbT = WbFromKanjiChCh(ch, (int) rgch[1]);
	    }
	else {
	    wbT = WbFromCh(ch);
	    }
#endif
	if (wb == wbWhite) {
#ifdef	KOREA
	    wb=wbT;
#else
	    wb = (wbT == wbKanjiText) ? wbKanjiTextFirst : wbT;
#endif
	    }
	else if (wb != wbT) {
	    if (sty == styWord) {
		return (cp);
		}
	    else /* sty == stySent */ {
		 /* wb	!= wbWhite */
		 /* wb	!= wbT	   */
		if (wbT == wbWhite || wbT == wbPunct) {
		    cpFirstLastSent = cp;
		    wb = wbWhite;
		    }
		}
	    }

	if (sty == stySent) { /* for the sentence */
	    if (FKanji1(ch)) {
		int	ch2;
		ch2 = rgch[1];
		if (FKanjiKuten(ch, ch2) ||
		    FKanjiQMark(ch, ch2) ||
		    FKanjiBang(ch, ch2)  ||
		    FKanjiPeriod(ch, ch2)) {
			if (cpFirstLastSent != cpNil) {
			    return (cpFirstLastSent);
			    }
			else {
			    cpFirstLastSent = cp;
			    }
			}
		}
	    else {
		switch(ch) {
#ifndef KOREA
		    case bKanjiKuten:
#endif
		    case chDot:
		    case chBang:
		    case chQMark:
			if (cpFirstLastSent != cpNil) {
			    return (cpFirstLastSent);
			    }
			else {
			    cpFirstLastSent = cp;
			    }
		    }
		}

	    }

	cp = cpTemp;
	}
    return (cpFirstPara);
}
#endif		/* DBCS */

/* W B	F R O M  C H */
int WbFromCh(ch)
int ch;
{ /* Return word-breakness of ch */

#if defined(DBCS) & !defined(KOREA)    /* was in JAPAN; KenjiK '90-10-29 */
	/* Brought from WIN2 source. */
	if (FKanaPunct(ch)) {
	    return wbPunct;
	    }
	else if (FKanaText(ch)) {
	    return wbKanjiText;
	    }
#endif

	switch (ch)
		{
	case chSpace:
	case chEol:
#ifdef CRLF
	case chReturn:
#endif
	case chSect:
	case chTab:
	case chNewLine:
	case chNBSFile:
		return wbWhite;
	case chNRHFile:
		return wbText;
	default: /* we are using the ANSI char set that windows used */
#ifdef	KOREA
		return ((isalpha(ch) || isdigit(ch) || ((ch>0x81)&&(ch<0xfe)))? wbText : wbPunct);
#else
		return ((isalpha(ch) || isdigit(ch))? wbText : wbPunct);
#endif
		}
}

#ifdef	DBCS	/* was in JAPAN; KenjiK '90-10-29 */
	/* Brought from WIN2 source. */
int WbFromKanjiChCh(ch1, ch2)
    int ch1, ch2;
{
    if (ch1 == chReturn && ch2 == chEol) {
	return wbWhite;
	}
    else if (FKanjiSpace(ch1, ch2)) {
	return wbWhite;
	}
    else

#ifdef	JAPAN
	 {
	switch (ch1) {
	    case 0x81:
		if (0x57 <= ch2 && ch2 <= 0x59) {
		    return wbKanjiText;
		    }
		else {
		    return wbPunct;
		    }
	    case 0x85:
		if ((0x40 <= ch2 && ch2 <= 0x4E) ||
		    (0x59 <= ch2 && ch2 <= 0x5F) ||
		    (0x7A <= ch2 && ch2 <= 0x7E) ||
		    (0x9B <= ch2 && ch2 <= 0xA3) ||
		    (0xDC <= ch2 && ch2 <= 0xDD)) {
			return wbPunct;
			}
		else {
		    return wbKanjiText;
		    }
	    case 0x86:
		return wbPunct;
	    case 0x87:
		return ((ch2 >= 0x90) ? wbPunct : wbKanjiText);
	    default:
		return wbKanjiText;
	    }
	}
#endif
#ifdef	KOREA
	{
        switch (ch1) {
	    case 0xa2:
		if (0xde <= ch2 && ch2 <= 0xe5) {
		    return wbText; // wbKanjiText; MSCH bklee 01/26/95
		    }
		else {
		    return wbPunct;
		    }
	    case 0xa3:
		if ((0xa1 <= ch2 && ch2 <= 0xaf) ||
		    (0xba <= ch2 && ch2 <= 0xc0) ||
		    (0xdb <= ch2 && ch2 <= 0xe0) ||
		    (0xfb <= ch2 && ch2 <= 0xfe)) {
			return wbPunct;
			}
		else {
		    return wbText; //wbKanjiText;  MSCH bklee 01/26/95
		    }
	    default:
		return wbText; //wbKanjiText; MSCH bklee 01/26/95
	    }
	}
#endif

#ifdef PRC   // brucere 11/16/95
	{
      switch (ch1) {
      case 0xA1:
         return wbPunct;

      case 0xA3:
         if ((0xA1 <= ch2 && ch2 <= 0xAF) ||
             (0xBA <= ch2 && ch2 <= 0xC0) || 
             (0xDB <= ch2 && ch2 <= 0xE0) ||
             (0xFB <= ch2 && ch2 <= 0xFE)) 
            return wbPunct;
         else 
            return wbKanjiText;

      case 0xA4:
         if (ch2 == 0x92)
            return wbPunct;
         else 
            return wbKanjiText;

      default:
   		return wbKanjiText;
      }
	}
#elif	TAIWAN
	{
	switch (ch1) {
	    case 0xA1:
		if (0x41 <= ch2 && ch2 <= 0xAC) 
		    return wbPunct;
		else 
		    return wbKanjiText;

	    default:
		return wbKanjiText;
	    }
	}
#endif

}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\editdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define ipcdNil         -1  /* Error return from IpcdSplit */

#define cpcdChunk       5
#define cpcdInit        5
#define cpcdMaxIncr     10

#define dcpAvgWord      10
#define dcpAvgSent      100

#include "prmdefs.h"

struct PCD
        {
        typeCP          cpMin;
        unsigned        fNoParaLast     : 1;
        unsigned        fn              : 15;
        typeFC          fc;
        struct PRM      prm;
        };

#define cwPCD   (sizeof (struct PCD) / sizeof (int))
#define cbPCD   (sizeof (struct PCD))
#define bcpPCD  0

struct PCTB
        {
        unsigned        ipcdMax;
        unsigned        ipcdMac;
        struct PCD      rgpcd[cpcdInit];
        };

#define cwPCTBInit     (sizeof (struct PCTB) / sizeof (int))
#define cbPCTBInit     (sizeof (struct PCTB))

struct UAB
        { /* UNDO Action Block */
        int             uac;    /* UNDO Action Code (see cmddefs.h) */
        int             doc;
        typeCP          cp;
        typeCP          dcp;
        int             doc2;
        typeCP          cp2;
        typeCP          dcp2;
        short         itxb;
        };


struct PCD *PpcdFromCp();

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\edit.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* edit.c -- MW editing routines */

#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
//#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "debug.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "printdef.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

/* E X T E R N A L S */
extern int vfOutOfMemory;
extern struct DOD       (**hpdocdod)[];
extern typeCP           vcpFirstSectCache;
extern struct UAB       vuab;
extern typeCP           cpMinCur;
extern typeCP           cpMacCur;
extern struct SEL       selCur;
extern int              docCur;
extern struct WWD       rgwwd[];
extern int              wwMac;
extern int              wwCur;
extern typeCP           vcpLimSectCache;
/*extern int idstrUndoBase;*/
extern int              docScrap;
extern int              docUndo;
extern int              vfSeeSel;
extern struct PAP       vpapAbs;
extern int              vfPictSel;
extern int              ferror;

/* the following used to be defined here */
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
/* this is a global parameter to AdjustCp; if false, no invalidation will
take place */
extern BOOL             vfInvalid;

#ifdef ENABLE
extern struct SEL       selRulerSprm;
#endif

extern int              docRulerSprm;
extern struct EDL       *vpedlAdjustCp;

struct PCD *PpcdOpen();




/* R E P L A C E */
Replace(doc, cp, dcp, fn, fc, dfc)
int doc, fn;
typeCP cp, dcp;
typeFC fc, dfc;
{ /* Replace cp through (cp+dcp-1) in doc by fc through (fc+dfc-1) in fn */

        if (ferror) return;
#ifdef ENABLE
        if (docRulerSprm != docNil) ClearRulerSprm();
#endif
        /* if (fn == fnNil) we are infact deleting text by replacing text
           with nil.  Thus, the memory space check is unnecessary.*/
#ifdef BOGUS    /* No longer have cwHeapFree available */
        if ((fn != fnNil) && (cwHeapFree < 3 * cpcdMaxIncr * cwPCD))
                {
#ifdef DEBUG
                ErrorWithMsg(IDPMTNoMemory, " edit#1");
#else
                Error(IDPMTNoMemory);
#endif
                return;
                }
#else
        if (vfOutOfMemory)
            {
            ferror = 1;
            return;
            }
#endif

        if (dcp != cp0)
                {
                AdjParas(doc, cp, doc, cp, dcp, fTrue); /* Check for del EOL */
                DelFtns(doc, cp, cp + dcp);     /* Delete any footnotes */
                }

        Repl1(doc, cp, dcp, fn, fc, dfc);
        if (ferror)
            return;
        AdjustCp(doc, cp, dcp, dfc);

        /* Special kludge for graphics paragraphs */
        if (dfc != dcp)
                CheckGraphic(doc, cp + dfc);

}




/* C H E C K  G R A P H I C */
CheckGraphic(doc, cp)
int doc; typeCP cp;
{
#if defined(OLE)
extern  BOOL             bNoEol;
#endif

#ifdef CASHMERE /* No docBuffer in MEMO */
extern int docBuffer; /* Don't need extra paragraph mark in txb document */
        if (cp == ((**hpdocdod)[doc]).cpMac || doc == docBuffer)
                return;
#else
        if (cp == ((**hpdocdod)[doc]).cpMac)
            return;
        CachePara(doc, cp);
        /* !!! this has a bug.  There are cases when you don't want to insert
           EOL.  Ex1:  place cursor in front of bitmap and press
           backspace.  Ex2:  OleSaveObjectToDoc deletes an object and
           insert new one (Eol gets inserted too). (4.10.91) v-dougk
        */
        if (vpapAbs.fGraphics && vcpFirstParaCache != cp)
#if defined(OLE)
            if (!bNoEol)
#endif
                InsertEolInsert(doc, cp);
#endif
}




int IpcdSplit(hpctb, cp)
struct PCTB **hpctb;
typeCP cp;
{ /* Ensure cp is the beginning of a piece.  Return index of that piece.
     return ipcdNil on error (extern int ferror will be set in that case) */
register struct PCD *ppcd = &(**hpctb).rgpcd[IpcdFromCp(*hpctb, cp)];
typeCP dcp = cp - ppcd->cpMin;

if (dcp != cp0)
        {
        ppcd = PpcdOpen(hpctb, ppcd + 1, 1);      /* Insert a new piece */
        if (ppcd == NULL)
            return ipcdNil;
        ppcd->cpMin = cp;
        ppcd->fn = (ppcd - 1)->fn;
        ppcd->fc = (ppcd - 1)->fc + dcp;
        ppcd->prm = (ppcd - 1)->prm;
        ppcd->fNoParaLast = (ppcd - 1)->fNoParaLast;
        }
/* NOTE CASTS: For piece tables with rgpcd > 32Kbytes */
/* return ppcd - (*hpctb)->rgpcd; */

return ((unsigned)ppcd - (unsigned)((*hpctb)->rgpcd)) / sizeof (struct PCD);
}




/* P P C D  O P E N */
struct PCD *PpcdOpen(hpctb, ppcd, cpcd)
struct PCTB **hpctb;
struct PCD *ppcd;
int cpcd;
{ /* Insert or delete cpcd pieces */
register struct PCTB *ppctb = *hpctb;

/* NOTE CASTS: For piece tables with rgpcd > 32Kbytes */
/* int ipcd = ppcd - ppctb->rgpcd; */
int ipcd = ((unsigned)ppcd - (unsigned)(ppctb->rgpcd)) / sizeof (struct PCD);
int ipcdMac, ipcdMax;

ipcdMac = ppctb->ipcdMac + cpcd;
ipcdMax = ppctb->ipcdMax;

if (cpcd > 0)
        { /* Inserting pieces; check for pctb too small */
        if (ipcdMac > ipcdMax)
                { /* Enlarge piece table */
                int cpcdIncr = umin(cpcdMaxIncr, ipcdMac / cpcdChunk);

                if (!FChngSizeH((int **) hpctb, (int) (cwPCTBInit + cwPCD *
                    ((ipcdMax = ipcdMac + cpcdIncr) - cpcdInit)), false))
                    {
#ifdef DEBUG
                    ErrorWithMsg(IDPMTNoMemory, " edit#3");
#else
                    Error(IDPMTNoMemory);
#endif
                    return (struct PCD *)NULL;
                    }

                /* Successfully expanded piece table */

                ppctb = *hpctb;
                ppcd = &ppctb->rgpcd [ipcd];
                ppctb->ipcdMax = ipcdMax;
                }
        ppctb->ipcdMac = ipcdMac;
        blt(ppcd, ppcd + cpcd, cwPCD * (ipcdMac - (ipcd + cpcd)));
        }
else if (cpcd < 0)
        { /* Deleting pieces; check for pctb obscenely large */
        ppctb->ipcdMac = ipcdMac;
        blt(ppcd - cpcd, ppcd, cwPCD * (ipcdMac - ipcd));
        if (ipcdMax > cpcdInit && ipcdMac * 2 < ipcdMax)
                { /* Shrink piece table */
#ifdef DEBUG
                int f =
#endif
                FChngSizeH((int **) hpctb, (int) (cwPCTBInit + cwPCD *
                    ((ppctb->ipcdMax = umax(cpcdInit,
                      ipcdMac + ipcdMac / cpcdChunk)) - cpcdInit)), true);

                Assert( f );

                return &(**hpctb).rgpcd[ipcd];
                }
        }
return ppcd;
}




/* R E P L 1 */
/* core of replace except for checking and Adjust */
Repl1(doc, cp, dcp, fn, fc, dfc)
int doc, fn;
typeCP cp, dcp;
typeFC fc, dfc;
{ /* Replace pieces with an optional new piece */
        struct PCTB **hpctb;
        int ipcdFirst;
        int cpcd;
        typeCP dcpAdj = dfc - dcp;
        register struct PCD *ppcd;
        struct PCD *ppcdMac;
        struct PCTB *ppctb;
        struct PCD *ppcdPrev;
        struct PCD *ppcdLim=NULL;

        hpctb = (**hpdocdod)[doc].hpctb;
        ipcdFirst = IpcdSplit(hpctb, cp);

        if (dcp == cp0)
            cpcd = 0;
        else
            cpcd = IpcdSplit( hpctb, cp + dcp ) - ipcdFirst;

        if (ferror)
            return;

        ppctb = *hpctb;
        ppcdPrev = &ppctb->rgpcd[ipcdFirst - 1];

        if ( dfc == fc0 ||
             (ipcdFirst > 0 && ppcdPrev->fn == fn && bPRMNIL(ppcdPrev->prm) &&
                     ppcdPrev->fc + (cp - ppcdPrev->cpMin) == fc) ||
             ((ppcdLim=ppcdPrev + (cpcd + 1))->fn == fn &&
                      bPRMNIL(ppcdLim->prm) && (ppcdLim->fc == fc + dfc)))
            {   /* Cases: (1) No insertion,
                          (2) Insertion is appended to previous piece
                          (3) Insertion is prepended to this piece */

            ppcd = PpcdOpen( hpctb, ppcdPrev + 1, -cpcd );
            if (ppcd == NULL)
                return;

            if (dfc != fc0)
                {   /* Cases 2 & 3 */
                if (ppcdLim != NULL)
                        /* Case 3 */
                    (ppcd++)->fc = fc;

                    /* If extending, say we might have inserted EOL */
                (ppcd - 1)->fNoParaLast = false;
                }
            }
        else
            { /* Insertion */
            ppcd = PpcdOpen( hpctb, ppcdPrev + 1, 1 - cpcd );
            if (ppcd == NULL)
                return;
            ppcd->cpMin = cp;
            ppcd->fn = fn;
            ppcd->fc = fc;
            SETPRMNIL(ppcd->prm);
            ppcd->fNoParaLast = false;       /* Don't know yet */
            ++ppcd;
            }
        ppcdMac = &(*hpctb)->rgpcd[(*hpctb)->ipcdMac];
        if (dcpAdj !=0)
            while (ppcd < ppcdMac)
                (ppcd++)->cpMin += dcpAdj;
}




/* A D J U S T  C P */
/* note global parameter vfInvalid */
/* sets global vpedlAdjustCp to pedl of line containing cpFirst, if any */
AdjustCp(doc, cpFirst, dcpDel, dcpIns)
int doc;
typeCP cpFirst, dcpDel, dcpIns;
{
        /* Adjust all cp references in doc to conform to the deletion of
           dcpDel chars and the insertion of dcpIns chars at cpFirst.
           Mark display lines (dl's) dirty for all lines in all windows
           displaying doc that are affected by the insertion & deletion
        */
extern int vdocBitmapCache;
extern typeCP vcpBitmapCache;
int ww;
typeCP cpLim = cpFirst + dcpDel;
typeCP dcpAdj = dcpIns - dcpDel;
#ifdef DEBUG
Scribble(2,'A');
#endif

{   /* Range in which pdod belongs in a register */
register struct DOD *pdod = &(**hpdocdod)[doc];

#ifdef STYLES
/* If inserting or deleting in style sheet, invalidates rest of doc */
if (pdod->dty == dtySsht && dcpAdj != cp0)
        cpLim = pdod->cpMac;
#endif
pdod->cpMac += dcpAdj;
/* Change for sand to support separate footnote windows: Make sure that edit
                was within the current cpMacCur */
/* note <= (CS) */
if (doc == docCur && cpFirst <= cpMacCur)
        cpMacCur += dcpAdj;

#ifdef STYLES
if (dcpAdj != cp0 && pdod->dty != dtySsht)
#else
if (dcpAdj != cp0)
#endif
        {
#ifdef FOOTNOTES
        if (pdod->hfntb != 0)
                { /* Adjust footnotes */
                struct FNTB *pfntb = *pdod->hfntb;
                int cfnd = pfntb->cfnd;
                struct FND *pfnd = &pfntb->rgfnd[cfnd];
                AdjRg(pfnd, cchFND, bcpRefFND, cfnd, cpFirst, dcpAdj);
                AdjRg(pfnd, cchFND, bcpFtnFND, cfnd, cpFirst + 1, dcpAdj);
                }
#endif
#ifdef CASHMERE
        if (pdod->hsetb != 0)
                { /* Adjust sections */
                struct SETB *psetb = *pdod->hsetb;
                int csed = psetb->csed;
                AdjRg(&psetb->rgsed[csed], cchSED, bcpSED, csed, cpFirst + 1,
                    dcpAdj);
                }
#endif
        if (pdod->dty == dtyNormal && pdod->hpgtb != 0)
                { /* Adjust page table */
                struct PGTB *ppgtb = *pdod->hpgtb;
                int cpgd = ppgtb->cpgd;
                AdjRg(&ppgtb->rgpgd[cpgd], cchPGD, bcpPGD, cpgd, cpFirst + 1,
                    dcpAdj);
                }
        }

#ifdef ENABLE
/* invalidate selection which contains the sprm Ruler1. When AdjustCp is
called in behalf of DragTabs, this invalidation will be undone by the caller
*/
if (doc == docRulerSprm && cpFirst >= selRulerSprm.cpFirst)
        docRulerSprm = docNil;
#endif
}       /* End of pdod belongs in a register */

/* Adjust or invalidate bitmap cache as appropriate */

if (doc == vdocBitmapCache)
    {
    if (vcpBitmapCache >= cpFirst)
        {
        if (vcpBitmapCache < cpFirst + dcpDel)
            FreeBitmapCache();
        else
            vcpBitmapCache += dcpAdj;
        }
    }

for (ww = 0; ww < wwMac; ww++)
        {
        register struct WWD *pwwd;
        if ((pwwd = &rgwwd[ww])->doc == doc)
                { /* This window may be affected */
                int dlFirst = 0;
                int dlLim = pwwd->dlMac;
                struct EDL *pedlFirst;
                struct EDL *pedlLast;
                register struct EDL *pedl;
                typeCP cpFirstWw = pwwd->cpFirst;
                struct SEL *psel = (ww == wwCur) ? &selCur : &pwwd->sel;

                if (pwwd->cpMac >= cpLim)
                        {
                        pwwd->cpMac += dcpAdj;
                        if (pwwd->cpMin > cpLim || pwwd->cpMac < pwwd->cpMin)
                                {
                                pwwd->cpMin += dcpAdj;
                                if (ww == wwCur)
                                        cpMinCur = pwwd->cpMin;
                                }
                        }

#ifndef BOGUSCS
                if (dcpAdj != cp0 && psel->cpLim >= cpFirst)
#else
                if (dcpAdj != cp0 && psel->cpLim > cpFirst)
#endif
                        { /* Adjust selection */
                        if (psel->cpFirst >= cpLim)
                                { /* Whole sel is after edit */
                                psel->cpFirst += dcpAdj;
                                psel->cpLim += dcpAdj;
                                }
                        else
                                { /* Part of sel is in edit */
                                typeCP cpLimNew = (dcpIns == 0) ?
                                    CpFirstSty( cpFirst, styChar ) :
                                    cpFirst + dcpIns;
#ifdef BOGUSCS
                                if (ww == wwCur)
                                        TurnOffSel();
#endif
                                psel->cpFirst = cpFirst;
                                psel->cpLim = cpLimNew;
                                }
                        }

                pedlFirst = &(**(pwwd->hdndl))[0];
                pedl = pedlLast = &pedlFirst[ dlLim - 1];

                while (pedl >= pedlFirst && (pedl->cpMin > cpLim
                        /* || (dcpAdj < 0 && pedl->cpMin == cpLim) */))
                        { /* Adjust dl's after edit */
                        pedl->cpMin += dcpAdj;
                        pedl--;
                        }

                /* Invalidate dl's containing edit */
                while (pedl >= pedlFirst && (pedl->cpMin + pedl->dcpMac > cpFirst ||
                        (pedl->cpMin + pedl->dcpMac == cpFirst && pedl->fIchCpIncr)))
                        {
                        if (vfInvalid)
                                pedl->fValid = false;
                        if (ww == wwCur) vpedlAdjustCp = pedl;
                        pedl--;
                        }

                if (pedl == pedlLast)
                        continue;       /* Entire edit below ww */

                if (vfInvalid)
                        pwwd->fDirty = fTrue; /* Say ww needs updating */

                if (pedl < pedlFirst)
                        { /* Check for possible cpFirstWw change */
                        if (cpFirstWw > cpLim) /* Edit above ww */
                                pwwd->cpFirst = cpFirstWw + dcpAdj;
                        else if (cpFirstWw + pwwd->dcpDepend > cpFirst)
                                /* Edit includes hot spot at top of ww */
                                {
                                if (cpFirst + dcpIns < cpFirstWw)
                                        {
                                        pwwd->cpFirst = cpFirst;
                                        pwwd->ichCpFirst = 0;
                                        }
                                }
                        else /* Edit doesn't affect cpFirstWw */
                                continue;

                        pwwd->fCpBad = true; /* Say cpFirst inaccurate */
                        DirtyCache(cpFirst); /* Say cache inaccurate */
                        }
                else do
                        { /* Invalidate previous line if necessary */
                        if (pedl->cpMin + pedl->dcpMac + pedl->dcpDepend > cpFirst)
                                {
                                pedl->fValid = fFalse;
                                pwwd->fDirty = fTrue;
                                }
                        else
                                break;
                        } while (pedl-- > pedlFirst);
                }
        }   /* end for */

#if defined(OLE)
    ObjAdjustCps(doc,cpLim,dcpAdj);
#endif

    InvalidateCaches(doc);
    Scribble(2,' ');
}




ReplaceCps(docDest, cpDel, dcpDel, docSrc, cpIns, dcpIns)
int docDest, docSrc;
typeCP cpDel, dcpDel, cpIns, dcpIns;
{ /* General replace routine */
/* Replace dcpDel cp's starting at cpDel in docDest with
        dcpIns cp's starting at cpIns in docSrc. */
register struct PCTB **hpctbDest;
struct PCTB **hpctbSrc;
int ipcdFirst, ipcdLim, ipcdInsFirst, ipcdInsLast;
register struct PCD *ppcdDest;
struct PCD *ppcdIns, *ppcdMac;
typeCP dcpFile, dcpAdj;
int cpcd;

if (ferror) return;
#ifdef ENABLE
if (docRulerSprm != docNil) ClearRulerSprm();
#endif

if (dcpIns == cp0)  /* This is just too easy . . . */
        {
        Replace(docDest, cpDel, dcpDel, fnNil, fc0, fc0);
        return;
        }

#ifdef DEBUG
Assert(docDest != docSrc);
#endif /* DEBUG */

/* Keep the heap handles, because IpcdSplit & PpcdOpen move heap */
hpctbDest = (**hpdocdod)[docDest].hpctb;
hpctbSrc = (**hpdocdod)[docSrc].hpctb;

/* Get the first and last pieces for insertion */
ipcdInsFirst = IpcdFromCp(*hpctbSrc, cpIns);
ipcdInsLast = IpcdFromCp(*hpctbSrc, cpIns + dcpIns - 1);

#ifdef BOGUS        /* No longer have cwHeapFree */
if (cwHeapFree < (ipcdInsLast - ipcdInsFirst + cpcdMaxIncr + 1) * cwPCD + 10)
        {
#ifdef DEBUG
                ErrorWithMsg(IDPMTNoMemory, " edit#2");
#else
                Error(IDPMTNoMemory);
#endif
        return;
        }
#else
if (vfOutOfMemory)
    {
    ferror = TRUE;
    return;
    }
#endif

if (docDest == docCur)
        HideSel();      /* Take down sel before we mess with cp's */

if (dcpDel != cp0)
        { /* Check for deleting EOL */
        AdjParas(docDest, cpDel, docDest, cpDel, dcpDel, fTrue);
        DelFtns(docDest, cpDel, cpDel + dcpDel);  /* Remove footnotes */
        }

if (dcpIns != cp0)
        AdjParas(docDest, cpDel, docSrc, cpIns, dcpIns, fFalse);

/* Get the limiting pieces for deletion (indices because hp moves ) */
ipcdFirst = IpcdSplit(hpctbDest, cpDel);
ipcdLim = (dcpDel == cp0) ? ipcdFirst : IpcdSplit(hpctbDest, cpDel + dcpDel);
if (ferror)
    return;

/* Adjust pctb size; get pointer to the first new piece, ppcdDest, and to the
        first piece we are inserting.  No more heap movement! */
ppcdDest = PpcdOpen(hpctbDest, &(**hpctbDest).rgpcd[ipcdFirst],
    ipcdFirst - ipcdLim + ipcdInsLast - ipcdInsFirst + 1);
ppcdIns = &(**hpctbSrc).rgpcd[ipcdInsFirst];

if (ferror)
        /* Ran out of memory expanding piece table */
    return;

/* Fill first new piece */
blt(ppcdIns, ppcdDest, cwPCD);
ppcdDest->cpMin = cpDel;
ppcdDest->fc += (cpIns - ppcdIns->cpMin);

dcpFile = cpDel - cpIns;
dcpAdj = dcpIns - dcpDel;

/* Fill in rest of inserted pieces */
if ((cpcd = ipcdInsLast - ipcdInsFirst) != 0)
        {
        blt((ppcdIns + 1), (ppcdDest + 1), cwPCD * cpcd);
        while (cpcd--)
                (++ppcdDest)->cpMin += dcpFile;
        }

/* Adjust rest of pieces in destination doc */
ppcdMac = &(**hpctbDest).rgpcd[(**hpctbDest).ipcdMac];
while (++ppcdDest < ppcdMac)
        ppcdDest->cpMin += dcpAdj;
#ifdef DEBUG
/* ShowDocPcd("From ReplaceCps: ", docDest); */
#endif

/* And inform anyone else who cares */
AdjustCp(docDest, cpDel, dcpDel, dcpIns);
/* Copy any footnotes along with their reference marks */

#ifdef FOOTNOTES
{
/* If there are any footnotes call AddFtns */
struct FNTB **hfntbSrc;
if ((hfntbSrc = HfntbGet(docSrc)) != 0)
        AddFtns(docDest, cpDel, docSrc, cpIns, cpIns + dcpIns, hfntbSrc);
}
#endif  /* FOOTNOTES */

#ifdef CASHMERE
{
/* If there are any sections call AddSects */
struct SETB **hsetbSrc;
if ((hsetbSrc = HsetbGet(docSrc)) != 0)
        AddSects(docDest, cpDel, docSrc, cpIns, cpIns + dcpIns, hsetbSrc);
}
#endif

/* Special kludge for graphics paragraphs */
if (dcpIns != dcpDel)
        CheckGraphic(docDest, cpDel + dcpIns);

if (dcpIns != cp0)
        {
        /* may have to merge in font tables */
        MergeFfntb(docSrc, docDest, cpDel, cpDel + dcpIns);
        }

#ifdef DEBUG
/* ShowDocPcd("From ReplaceCps End: ", docDest); */
#endif
}




/* A D J  P A R A S */
AdjParas(docDest, cpDest, docSrc, cpFirstSrc, dcpLimSrc, fDel)
int docDest, docSrc, fDel;
typeCP cpDest, cpFirstSrc, dcpLimSrc;
{   /* Mark display lines showing the section/paragraph containing cpDest
       in docDest as invalid if the range cpFirstSrc through cpLimSrc-1
       in docSrc contains end-of-section/end-of-paragraph marks */


        typeCP cpFirstPara, cpFirstSect;
        typeCP cpLimSrc = cpFirstSrc + dcpLimSrc;

#ifdef CASHMERE     /* In WRITE, the document is one big section */
        CacheSect(docSrc, cpFirstSrc);
        if (cpLimSrc >= vcpLimSectCache)
                { /* Sel includes sect mark */
                typeCP dcp;
                CacheSect(docDest, cpDest);
                dcp = cpDest - vcpFirstSectCache;
                AdjustCp(docDest, vcpFirstSectCache, dcp, dcp);
                }
#endif

        CachePara(docSrc, cpFirstSrc);
        if (cpLimSrc >= vcpLimParaCache)
                { /* Diddling with a para return */
                typeCP dcp, cpLim;
                typeCP cpMacT = (**hpdocdod)[docDest].cpMac;
                typeCP cpFirst;

                if ((cpDest == cpMacT) && (cpMacT != cp0))
                        {
                        CachePara(docDest, cpDest-1);
                        cpLim = cpMacT + 1;
                        }
                else
                        {
                        CachePara(docDest, cpLim = cpDest);
                        }
                cpFirst = vcpFirstParaCache;
/* invalidate at least from cpFirst to cpLim */

/* cpFirst is start of disturbed para in destination doc */
/* next few lines check for effect of the edit on the semi-paragraph after
the last paragraph mark in the document.
Note: cpLimSrc is redefined as the point of insertion if !fDel.
If fDel, Src and Dest documents are the same.
*/
                if (!fDel)
                        cpLimSrc = cpFirstSrc;
                if (cpLimSrc <= cpMacT)
                        {
/* if a paragraph exists at the end of the disturbance, is it the last
semi-paragraph? */
                        CachePara(docDest, cpLimSrc);
                        if (vcpLimParaCache > cpMacT)
/* yes, extend invalidation over the semi-para */
                                cpLim = cpMacT + 1;
                        }
                else
                        cpLim = cpMacT + 1;
                dcp = cpLim - cpFirst;
                AdjustCp(docDest, cpFirst, dcp, dcp);
                }
}






int IcpSearch(cp, rgfoo, cchFoo, bcp, ifooLim)
typeCP cp;
CHAR rgfoo[];
unsigned cchFoo;
unsigned bcp;
unsigned ifooLim;
{ /* Binary search a table for cp; return index of 1st >= cp */
unsigned ifooMin = 0;

while (ifooMin + 1 < ifooLim)
        {
        int ifooGuess = (ifooMin + ifooLim - 1) >> 1;
        typeCP cpGuess;
        if ((cpGuess = *(typeCP *) &rgfoo[cchFoo * ifooGuess + bcp]) < cp)
                ifooMin = ifooGuess + 1;
        else if (cpGuess > cp)
                ifooLim = ifooGuess + 1;
        else
                return ifooGuess;
        }
return ifooMin;
} /* end of  I c p S e a r c h  */





DelFtns(doc, cpFirst, cpLim)
typeCP cpFirst, cpLim;
int doc;
{ /* Delete all footnote text corresponding to refs in [cpFirst:cpLim) */
/* Also delete SED's for section marks. */
struct FNTB **hfntb;

struct SETB **hsetb;

struct PGTB **hpgtb;

struct DOD *pdod;

#ifdef FOOTNOTES
if ((hfntb = HfntbGet(doc)) != 0)
        RemoveDelFtnText(doc, cpFirst, cpLim, hfntb);
#endif  /* FOOTNOTES */

#ifdef CASHMERE
if ((hsetb = HsetbGet(doc)) != 0)
        RemoveDelSeds(doc, cpFirst, cpLim, hsetb);
#endif

pdod = &(**hpdocdod)[doc];
if (pdod->dty == dtyNormal && (hpgtb = pdod->hpgtb) != 0)
        RemoveDelPgd(doc, cpFirst, cpLim, hpgtb);

}



AdjRg(pfoo, cchFoo, bcp, ccp, cp, dcpAdj)
register CHAR *pfoo;
int cchFoo, bcp, ccp;
typeCP cp, dcpAdj;
{ /* Adjust cp's in an array */
pfoo += bcp;
while (ccp-- && *(typeCP *)((pfoo -= cchFoo)) >= cp)
        *(typeCP *)(pfoo) += dcpAdj;
}




DeleteSel()
{ /* Delete a selection */
typeCP cpFirst;
typeCP cpLim;
typeCP dcp;

cpFirst = selCur.cpFirst;
cpLim = selCur.cpLim;

NoUndo();   /* We don't want any combining of adjacents for this operation */
SetUndo(uacDelNS, docCur, cpFirst, dcp = cpLim - cpFirst,
    docNil, cpNil, cp0, 0);
Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
vfSeeSel = true;
vfPictSel = false;
return ferror;
}




FWriteOk( fwc )
int fwc;
{   /* Test whether the edit operation specified by fwc is acceptable.
       Assume the operation is to be performed on selCur in docCur.
       Return TRUE if the operation is acceptable; FALSE otherwise */
extern int vfOutOfMemory;

return !vfOutOfMemory;
}




/* S E T  U N D O */
SetUndo(uac, doc, cp, dcp, doc2, cp2, dcp2, itxb)
int uac, doc, doc2;
typeCP cp, dcp, cp2, dcp2;
short itxb;
{/* Set up the UNDO structure, vuab, in response to an editing operation */
        struct DOD *pdod, *pdodUndo;

       /* Group delete operations together with adjacent deletes or replaces */
       /* WRITE needs the replace case since AlphaMode is treated as a big */
       /* replace operation */

        if (uac == uacDelNS && doc == vuab.doc)
            {
            if ((vuab.uac == uacDelNS) || (vuab.uac == uacReplNS))
                {
                typeCP cpUndoAdd;

                if (cp == vuab.cp)
                    {
                    cpUndoAdd = CpMacText( docUndo  );
                    goto UndoAdd;
                    }
                else if (cp + dcp == vuab.cp)
                    {
                    cpUndoAdd = cp0;
UndoAdd:            ReplaceCps( docUndo, cpUndoAdd, cp0, doc, cp, dcp );
                    if (vuab.uac == uacDelNS)
                        vuab.dcp += dcp;
                    else
                        vuab.dcp2 += dcp;
                    goto SURet;
                    }
                else if (vuab.uac == uacReplNS && cp == vuab.cp + vuab.dcp)
                    {   /* Special case for combining insertions --
                           do not start a new undo operation if a null
                           deletion is done at the end of an existing replace */
                    if (dcp == cp0)
                        return;
                    }
                }
            }

        /* Group insertions together with adjacent ins's and replaces */

        if (uac == uacInsert && doc == vuab.doc)
                {/* check for adjacent inserts */
                /* Because we can be popped out of Alpha Mode so easily
                   in WRITE, we try to be smarter about combining adjacent
                   insert operations */
                if (vuab.uac == uacInsert || vuab.uac == uacReplNS)
                    {
                    if (cp == vuab.cp + vuab.dcp)
                        {
                        vuab.dcp += dcp;
                        goto SURet;
                        }
                    }
                else if (cp == vuab.cp)
                        switch(vuab.uac)
                                {
                        default:
                                break;
                        case uacDelNS:
                                vuab.dcp2 = vuab.dcp;
                                vuab.uac = uacReplNS;
                                goto repl;
                        case uacDelBuf:
                                vuab.uac = uacReplBuf;
                                goto repl;
                        case uacDelScrap:
                                vuab.uac = uacReplScrap;
            repl:
                                vuab.dcp = dcp;
                                SetUndoMenuStr(IDSTRUndoEdit);
                                goto SURet;
                                }
                }

#ifndef CASHMERE
        /* The use of vuab.itxb is a kludge to determine if the undo block is
        for a ruler change or an undone ruler change. */
        if (uac == uacRulerChange && vuab.uac == uacRulerChange && doc ==
          vuab.doc && cp == vuab.cp && vuab.itxb == 0)
                {
                /* The undo action block for the ruler change is already set. */
                vuab.dcp = CpMax(dcp, vuab.dcp);
                goto SURet;
                }
#endif /* not CASHMERE */

        vuab.doc = doc;
        vuab.cp = cp;
        vuab.dcp = dcp;
        vuab.doc2 = doc2;
        vuab.cp2 = cp2;
        vuab.dcp2 = dcp2;
        vuab.itxb = itxb;
        /*idstrUndoBase = IDSTRUndoBase;*/
        switch (vuab.uac = uac)
                { /* Save deleted text if necessary */
        default:
                SetUndoMenuStr(IDSTRUndoEdit);
                break;
        case uacDelScrap:
        case uacReplScrap:
                /* Two-level edit; save scrap */
                {
                extern int vfOwnClipboard;

                if ( vfOwnClipboard )
                    {
                    ClobberDoc( docUndo, docScrap, cp0,
                                CpMacText( docScrap ) );
                    }
                else
                    ClobberDoc(docUndo, docNil, cp0, cp0);

                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(uac == uacDelScrap ? IDSTRUndoCut :*/
/*                                                  IDSTRUndoPaste);*/
                break;
                }
        case uacDelNS:
                /* One-level edit; save deleted text */
                ClobberDoc(docUndo, doc, cp, dcp);
                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(IDSTRUndoCut);*/
                break;
        case uacReplNS:
                /* One-level edit; save deleted text */
                ClobberDoc(docUndo, doc, cp, dcp2);
                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(IDSTRUndoPaste);*/
                break;
        case uacPictSel:
                ClobberDoc(docUndo, doc, cp, dcp);
                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(IDSTRUndoPict);*/
                break;
        case uacChLook:
        case uacChLookSect:
                SetUndoMenuStr(IDSTRUndoLook);
                break;

#ifndef CASHMERE
        case uacFormatTabs:
                ClobberDoc(docUndo, doc, cp, dcp);
                SetUndoMenuStr(IDSTRUndoBase);
                break;
        case uacRepaginate:
        case uacFormatSection:
                ClobberDoc(docUndo, doc, cp, dcp);
                if ((**hpdocdod)[doc].hpgtb)
                    { /* copy page table over if there is one */
                    int cw = cwPgtbBase + (**(**hpdocdod)[doc].hpgtb).cpgdMax * cwPGD;
                    CopyHeapTableHandle(hpdocdod,
                        (sizeof(struct DOD) * doc) + BStructMember(DOD, hpgtb),
                        (sizeof(struct DOD) * docUndo) + BStructMember(DOD, hpgtb),
                        cw);
                    }
                SetUndoMenuStr(IDSTRUndoBase);
                break;
        case uacRulerChange:
                ClobberDoc(docUndo, doc, cp, dcp2);
                SetUndoMenuStr(IDSTRUndoLook);
/*              SetUndoMenuStr(IDSTRUndoRuler);*/
                break;
#endif /* not CASHMERE */

#ifdef UPDATE_UNDO
#if defined(OLE)
        case uacObjUpdate:
            ClobberDoc(docUndo, docNil, cp0, cp0);
            SetUndoMenuStr(IDSTRObjUndo);
        break;
#endif
#endif
                }

        if (doc != docNil)
                {
                pdod = &(**hpdocdod)[doc];
                pdodUndo = &(**hpdocdod)[docUndo];
                pdodUndo->fDirty = pdod->fDirty;
                pdodUndo->fFormatted = pdod->fFormatted;
                if (uac != uacReplScrap)
                /* If SetUndo is called with uacReplScrap, = COPY SCRAP */
                        pdod->fDirty = true;
                }
#ifdef BOGUSCS
        if (uac == uacMove)
                CheckMove();
#endif
SURet:
        if (ferror) NoUndo();

        return;
}




/* C L O B B E R  D O C */
ClobberDoc(docDest, docSrc, cp, dcp)
int docDest, docSrc;
typeCP cp, dcp;
{ /* Replace contents of docDest with docSrc[cp:dcp] */

extern int docScrap;
extern int vfOwnClipboard;
struct FFNTB **hffntb;
struct SEP **hsep;
struct TBD (**hgtbd)[];

register int bdodDest=sizeof(struct DOD)*docDest;
register int bdodSrc=sizeof(struct DOD)*docSrc;

#define dodDest (*((struct DOD *)(((CHAR *)(*hpdocdod))+bdodDest)))
#define dodSrc  (*((struct DOD *)(((CHAR *)(*hpdocdod))+bdodSrc)))

        /* clear out dest doc's font table - it will get a copy of source's */
        hffntb = HffntbGet(docDest);
        dodDest.hffntb = 0;

        /* this does nothing if hffntb is NULL (5.15.91) v-dougk */
        FreeFfntb(hffntb);

        SmashDocFce(docDest);   /* font cache entries can't refer to it by doc
                                   any more */

        /* this does nothing (code stubbed out) (5.15.91) v-dougk */
        ZeroFtns(docDest); /* So ReplaceCps doesn't worry about them */

        ReplaceCps(docDest, cp0, dodDest.cpMac, docSrc, cp, dcp);

        /* Copy section properties and tab table, both of which are
           document properties in MEMO */
        CopyHeapTableHandle( hpdocdod,
                             ((docSrc == docNil) ? -1 :
                                 bdodSrc + BStructMember( DOD, hsep )),
                             bdodDest + BStructMember( DOD, hsep ),
                             cwSEP );
        CopyHeapTableHandle( hpdocdod,
                             ((docSrc == docNil) ? -1 :
                                 bdodSrc + BStructMember( DOD, hgtbd )),
                             bdodDest + BStructMember( DOD, hgtbd ),
                             cwTBD * itbdMax );
}




CopyHeapTableHandle( hBase, bhSrc, bhDest, cwHandle )
CHAR **hBase;
register int bhSrc;
register int bhDest;
int cwHandle;
{       /* Copy cwHandle words of contents from a handle located at
           offset (in bytes) bhSrc from the beginning of heap object
           hBase to a handle located at bhDest from the same base. If the
           destination handle is non-NULL, free it first.
           If bhSrc is negative, free the destination, but do not copy */

int **hT;

#define hSrc    (*((int ***) ((*hBase)+bhSrc)))
#define hDest   (*((int ***) ((*hBase)+bhDest)))

if (hDest != NULL)
    {
    FreeH( hDest );
    hDest = NULL;
    }

if ( (bhSrc >= 0) && (hSrc != NULL) &&
                     !FNoHeap( hT = (int **)HAllocate( cwHandle )))
     {
     blt( *hSrc, *hT, cwHandle );
     hDest = hT;
     }

#undef hSrc
#undef hDest
}



ZeroFtns(doc)
{ /* Remove all footnote & section references from doc */
struct FNTB **hfntb;
struct SETB **hsetb;

#ifdef FOOTNOTES
        if ((hfntb = HfntbGet(doc)) != 0)
                {
                FreeH(hfntb);
                (**hpdocdod)[doc].hfntb = 0;
                }
#endif  /* FOOTNOTES */
#ifdef CASHMERE
        if ((hsetb = HsetbGet(doc)) != 0)
                {
                FreeH(hsetb);
                (**hpdocdod)[doc].hsetb = 0;
                }
#endif
}



fnClearEdit(int nInsertingOver)

{   /* CLEAR command entry point: Delete the current selection */

/** 
    NOTE: as of this comment, this is used:
    1)  when typing over a selection (AlphaMode() in insert.c)
    2)  when Pasting over a selection (fnPasteEdit in clipboard.c)
    3)  when pressing the delete key
    4)  for InsertObject (obj3.c)
    5)  for DragDrop (obj3.c)
    6)  Clear header/footer (running.c)

    A similar sequence occurs when cutting to the clipboard
    (fnCutEdit in clipbord.c).

    Also see copying to clipboard (fnCopyEdit in clipbord.c).

    (8.29.91) v-dougk
**/

    if (!FWriteOk( fwcDelete ))
        return TRUE;

    if (selCur.cpFirst < selCur.cpLim)
    {
#if defined(OLE)

        /* this'll prevent us from deleting open embeds */
        if (!ObjDeletionOK(nInsertingOver))
            return TRUE;

         /* close open links */
        ObjEnumInRange(docCur,selCur.cpFirst,selCur.cpLim,ObjCloseObjectInDoc);
#endif

        return DeleteSel();
    }
    return FALSE;
}



MergeFfntb(docSrc, docDest, cpMin, cpLim)
/* determines if the two docs font tables differ to the extent that we need
   to apply a mapping sprm to the specified cp's */

int docSrc, docDest;
typeCP cpMin, cpLim;
{
struct FFNTB **hffntb;
int cftcDiffer, ftc, iffn;
struct FFN *pffn;
CHAR rgbSprm[2 + 256];
CHAR rgbFfn[ibFfnMax];

hffntb = HffntbGet(docSrc);
if (hffntb != 0)
        {
        cftcDiffer = 0;
        for (iffn = 0; iffn < (*hffntb)->iffnMac; iffn++)
                {
                pffn = *(*hffntb)->mpftchffn[iffn];
                bltbyte(pffn, rgbFfn, CbFromPffn(pffn));
                ftc = FtcChkDocFfn(docDest, rgbFfn);
                if (ftc != iffn)
                        cftcDiffer++;
                rgbSprm[2+iffn] = ftc;
                if (ftc == ftcNil)
                        /* we're stuck! */
                        return;
                }

        if (cftcDiffer == 0)
                /* new font table is a superset, & all the old font table's
                   ftc's matched exactly - no need to do anything */
                return;

        rgbSprm[0] = sprmCMapFtc;
        rgbSprm[1] = (*hffntb)->iffnMac;

        /* here goes - apply the mapping */
        AddSprmCps(rgbSprm, docDest, cpMin, cpLim);
        }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\editpgtb.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NOHDC
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "str.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "debug.h"

extern struct FCB       (**hpfnfcb)[];
int                     **HAllocate();




RemoveDelPgd(doc, cpFirst, cpLim, hpgtb)
int doc;
typeCP cpFirst, cpLim;
struct PGTB **hpgtb;
{
struct PGTB *ppgtb;
struct PGD *ppgd, *ppgdT;
int ipgd, cpgd, cpgdDel;

        {
        ppgtb = *hpgtb;
        ppgd = &ppgtb->rgpgd[0];
        ppgd += (ipgd =
            IcpSearch(cpFirst + 1, ppgd, cwPGD * sizeof(int),
                         bcpPGD, cpgd = ppgtb->cpgd));

        if (ppgd->cpMin > cpFirst) /* Ensure not past last page */
                { /* Find all page breaks in deleted area. */
                for (ppgdT = ppgd, cpgdDel = 0;
                    ipgd + cpgdDel < cpgd && ppgdT->cpMin <= cpLim;
                      ppgdT++, cpgdDel++)
                        continue;

                if (cpgdDel != 0)
                        { /* Close up pgtb. */
                        blt(ppgdT, ppgd, cwPGD * ((cpgd -= cpgdDel) - ipgd));
                        (*hpgtb)->cpgd = cpgd;
                        }
                }
        }
} /* end of  R e m o v e D e l P g d  */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fetch.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fetch.c -- MW routines for obtaining attributes associated with cp's */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NOATOM
#define NOMETAFILE
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOPEN
#define NOBITMAP
#define NOCOLOR
#define NODRAWTEXT
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NORESOURCE
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "editdefs.h"
#include "propdefs.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "filedefs.h"
/*
#include "code.h"
*/
#include "ch.h"
#include "fkpdefs.h"
#include "prmdefs.h"
/*
#include "stcdefs.h"
*/

static SetChp(struct CHP *pchp, int *pcfcChp, int fn, typeFC fc, struct PRM prm);

extern typeCP          vcpFetch;
extern int             vichFetch;
extern int             vdocFetch;
extern int             vccpFetch;
extern int             vcchFetch;
extern CHAR            *vpchFetch;
extern struct CHP      vchpFetch;
extern CHAR            (**hgchExpand)[];
extern int             vdocExpFetch;
extern struct CHP      vchpAbs;


extern int vfDiskError;
#ifdef CASHMERE
extern int docBuffer;
#endif
extern struct PAP       vpapAbs;
extern struct CHP vchpNormal;
extern struct DOD (**hpdocdod)[];
extern CHAR     rgchInsert[];
extern int      ichInsert;
extern struct CHP vchpInsert;
extern typeCP   vcpFirstParaCache;
extern typeCP   vcpLimParaCache;
extern struct PAP       vpapCache;
extern struct FCB    (**hpfnfcb)[];
extern struct FKPD   vfkpdCharIns;
extern typeFC        fcMacChpIns;

typePN PnFkpFromFcScr();
CHAR *PchFromFc();

#ifdef BOGUS
#ifdef DEBUG
typeCP   cpExpFetch;
CHAR     *pchExpFetch;
int      cchExpFetch;
int      ccpExpFetch;
#endif /* DEBUG */
#endif


FetchCp(doc, cp, ich, fcm)
int doc, ich, fcm;
typeCP cp;
{       /*
        Inputs:
                doc
                Starting cp
                ich within cp (for cp's which can cross line boundaries)
                fcm tells whether to get chars, props, or both
        Outputs:
                (in vcpFetch) starting cp
                (in vichFetch) starting ich within expanded cp
                (in vdocFetch) doc
                (in vccpFetch) number of cp's fetched (0 if expanded cp)
                (in vcchFetch) number of ch's fetched
                (in vpchFetch) characters fetched
                (in vchpFetch) char prop of fetched chars
        */
struct PCD *ppcd;

static int fn;
static typeFC fc;
static struct PRM prm;
static typeCP ccpChp, ccpPcd, ccpFile;
static int ipcd;
static typeCP   cpExpFetch;
static CHAR     *pchExpFetch;
static int      cchExpFetch;
static int      ccpExpFetch;



if (doc == docNil)
        { /* Sequential call to FetchCp */
        /* If last piece was Q&D insert, skip remainder of piece */
        if (fn == fnInsert && (fc + vccpFetch) >= ichInsert)
                vccpFetch = ccpPcd; /* Use whole piece */
        vcpFetch += vccpFetch;  /* Go to where we left off */
        if (vccpFetch == 0)
                vichFetch += vcchFetch;
        else
                vichFetch = 0;
        fc += vccpFetch;
        }
else
        { /* Random-access call */
        vcpFetch = cp;
        vichFetch = ich;
        vdocFetch = doc;
        ccpChp = ccpPcd = ccpFile = 0;
        }

if (vcpFetch >= (**hpdocdod)[vdocFetch].cpMac)
        { /* Use std looks for end mark */
        vccpFetch = 0;

        /* vcchFetch == 0 should not be used for endmark indications because of
        empty QD runs. */
        vcchFetch = 1;

        if (fcm & fcmProps)
                {
                blt(&vchpNormal, &vchpFetch, cwCHP);
                blt(&vchpNormal, &vchpAbs, cwCHP);
                }
        return;
        }

#ifdef STYLES
if ((fcm & (fcmChars + fcmNoExpand)) == fcmChars &&
    (**hpdocdod)[vdocFetch].dty == dtySsht)
        { /* Style sheet; expand encoded text */
        if (fcm & fcmProps)
                {
                blt(&vchpNormal, &vchpFetch, cwCHP);
                blt(&vchpNormal, &vchpAbs, cwCHP);
                }
        if (vdocExpFetch == vdocFetch && vcpFetch == cpExpFetch + ccpExpFetch)
                { /* Give back the last EOL in the expansion */
                vccpFetch = vcchFetch = 1;
                vpchFetch = &(**hgchExpand)[cchExpFetch];
                return;
                }
        else if (vdocExpFetch != vdocFetch || cpExpFetch != vcpFetch)
                { /* New expansion */
                int ich = vichFetch;

                vdocExpFetch = vdocFetch;
                cpExpFetch = vcpFetch;
                pchExpFetch = PchExpStyle(&cchExpFetch, &ccpExpFetch, vdocFetch,
                    vcpFetch);  /* Uses FetchCp, so better save v's */
                vcpFetch = cpExpFetch;  /* Got changed by PchExpStyle */
                vichFetch = ich;        /* Ditto */
                if (fcm & fcmProps)     /* Ditto */
                        {
                        blt(&vchpNormal, &vchpFetch, cwCHP);
                        blt(&vchpNormal, &vchpAbs, cwCHP);
                        }
                }
        if (vichFetch >= cchExpFetch)
                { /* End of expansion; skip cp's */
                vccpFetch = ccpExpFetch;
                vcchFetch = 0;
                ccpPcd = ccpFile = ccpChp = 0;
                }
        else
                {
                vccpFetch = 0;
                vcchFetch = cchExpFetch - vichFetch;
                }
        vpchFetch = pchExpFetch + vichFetch;
        return;
        }
#endif /* STYLES */


if (ccpPcd > vccpFetch)
        ccpPcd -= vccpFetch;
else
        {
        struct PCTB *ppctb = *(**hpdocdod)[vdocFetch].hpctb;

        if (doc == docNil)
                ++ipcd; /* Save some work on sequential call */
        else
                { /* Search for piece and remember index for next time */
                ipcd = IpcdFromCp(ppctb, vcpFetch);
                }

        ppcd = &ppctb->rgpcd[ipcd];
        ccpPcd = (ppcd + 1)->cpMin - vcpFetch;
        ccpChp = ccpFile = 0;   /* Invalidate everything; new piece */
        fc = ppcd->fc + vcpFetch - ppcd->cpMin;
        if ((fn = ppcd->fn) == fnInsert)
                { /* Special quick and dirty insert mode */
                vpchFetch = rgchInsert + fc;
                ccpChp = ccpFile = vccpFetch = max(0, ichInsert - (int) fc);
                if (fcm & fcmProps)
                        {
                        ccpChp = vccpFetch;
                        blt(&vchpInsert, &vchpFetch, cwCHP);
#ifdef STYLES
                        blt(PpropXlate(vdocFetch, &vchpFetch, &vpapAbs), &vchpAbs,
                            cwCHP);
#else
                        blt(&vchpFetch, &vchpAbs, cwCHP);
#endif
                        goto ParseCaps;
                        }
                return;
                }
        prm = ppcd->prm;
        }

/* No monkeying with files after this statement, or we may page out */
if (fcm & fcmChars)
        {
#ifdef ENABLE   /* In WRITE, we cannot assume that vpchFetch will remain
                   valid, because we do our reading in multi-page chunks;
                   also, rgbp can move */

        if (ccpFile > vccpFetch)
                {
                ccpFile -= vccpFetch;
                vpchFetch += vccpFetch;
                }
        else
#endif
                {
                int ccpT;
                vpchFetch = PchFromFc(fn, fc, &ccpT); /* Read in buffer */
                ccpFile = ccpT;
                }
        }

if (fcm & fcmProps)
        { /* There must be enough page buffers so that this will not
                page out vpchFetch! */
        if (ccpChp > vccpFetch)
                ccpChp -= vccpFetch;
        else
                { /* CachePara must have been called prior to FetchCp */
                int ccpT;
                SetChp(&vchpFetch, &ccpT, fn, fc, prm);
                ccpChp = ccpT;
#ifdef CASHMERE /* no docBuffer in WRITE */
                if(vdocFetch != docBuffer)
#endif
#ifdef STYLES
                    blt(PpropXlate(vdocFetch, &vchpFetch, &vpapAbs), &vchpAbs,
                        cwCHP);
#else
                    blt(&vchpFetch, &vchpAbs, cwCHP);
#endif
                }
        }

/* Set vccpFetch to minimum of various restraining ccp's */
vccpFetch = (ccpPcd >= 32767) ? 32767 : ccpPcd;
if ((fcm & fcmChars) && ccpFile < vccpFetch) vccpFetch = ccpFile;
if ((fcm & fcmProps) && ccpChp < vccpFetch) vccpFetch = ccpChp;

ParseCaps:

#ifdef CASHMERE
if ((fcm & fcmParseCaps) != 0)
    {
    CHAR *pch;
    int cch;

        /* Brodie says this will not work for style sheet */
    if (vchpFetch.csm == csmSmallCaps)
        { /* Parse small caps into runs */
        pch = &vpchFetch[0];
        cch = vccpFetch - 1;
        /* This either */
        blt(&vchpFetch, &vchpAbs, cwCHP); /* because vchpAbs could be modified */
        if (islower(*pch++))
                {
                while ((islower(*pch) || *pch == chSpace)
                    && cch-- != 0)
                        pch++;
#ifndef SAND
                vchpAbs.hps =
                    max(1, (vchpAbs.hps * 4  + 2) / 5);
#endif
                }
        else
                {
                while (!islower(*pch) && cch-- != 0)
                        pch++;
                vchpAbs.csm = csmNormal;
                }
        vccpFetch = min((int)ccpChp, pch - vpchFetch);
        }
    }
#endif /* CASHMERE */

vcchFetch = vccpFetch;
} /* end of  F e t c h C p  */


FetchRgch(pcch, pch, doc, cp, cpMac, cchMax)
int *pcch, doc, cchMax;
CHAR *pch;
typeCP cp, cpMac;
{
int cch = 0;

FetchCp(doc, cp, 0, fcmChars + fcmNoExpand);

while (cch < cchMax && vcpFetch < cpMac)
        {
#ifdef INEFFICIENT
        int ccp = (int) CpMin((typeCP) min(cchMax - cch, vccpFetch),
            cpMac - vcpFetch);
#endif
        int ccp = cchMax - cch;
        if (ccp > vccpFetch)
                ccp = vccpFetch;
        if (ccp > cpMac - vcpFetch)
                ccp = cpMac - vcpFetch;

        bltbyte(vpchFetch, pch, ccp);
        pch += ccp;
        cch += ccp;

        if (ccp < vccpFetch)
                break; /* Save some work */
        FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand);
        }
*pcch = cch;
} /* end of  F e t c h R g c h  */


int IpcdFromCp(ppctb, cp)
struct PCTB *ppctb;
typeCP cp;
{ /* Binary search piece table for cp; return index */
int ipcdLim = ppctb->ipcdMac;
int ipcdMin = 0;
struct PCD *rgpcd = ppctb->rgpcd;

while (ipcdMin + 1 < ipcdLim)
        {
        int ipcdGuess = (ipcdMin + ipcdLim) >> 1;
        typeCP cpGuess;
        if ((cpGuess = rgpcd[ipcdGuess].cpMin) <= cp)
                {
                ipcdMin = ipcdGuess;
                if (cp == cpGuess)
                        break;     /* Hit it on the nose! */
                }
        else
                ipcdLim = ipcdGuess;
        }
return ipcdMin;
} /* end of  I p c d F r o m C p  */


static SetChp(struct CHP *pchp, int *pcfcChp, int fn, typeFC fc, struct PRM prm)
{ /* Fill pchp with char props; return length of run in *pcfcChp */
struct FKP *pfkp;
struct FCHP *pfchp;
typeFC cfcChp;
struct FCB *pfcb;

pfcb = &(**hpfnfcb)[fn];
cfcChp = pfcb->fcMac - fc;
FreezeHp();

if (fn == fnScratch && fc >= fcMacChpIns)
        {
        blt(&vchpInsert, pchp, cwCHP);
        }
else
        {
        if (pfcb->fFormatted)
                { /* Copy necessary amt of formatting info over std CHP */
                typeFC fcMac;
                int cchT;
                int bfchp;

                blt(&vchpNormal, pchp, cwCHP);
                pfkp = (struct FKP *) PchGetPn(fn, fn == fnScratch ?
                    PnFkpFromFcScr(&vfkpdCharIns, fc) :
                      pfcb->pnChar + IFromFc(**pfcb->hgfcChp, fc),
                       &cchT, false);
                if (vfDiskError)
                        /* Serious disk error -- use default props */
                    goto DefaultCHP;

                {   /* In-line, fast substitute for BFromFc */
                register struct RUN *prun = (struct RUN *) pfkp->rgb;

                while (prun->fcLim <= fc)
                    prun++;

                fcMac = prun->fcLim;
                bfchp = prun->b;
                }

                if (bfchp != bNil)
                        {
                        pfchp = (struct FCHP *) &pfkp->rgb[bfchp];
                        bltbyte(pfchp->rgchChp, pchp, pfchp->cch);
                        }
                cfcChp = fcMac - fc;
                }
        else
                {
DefaultCHP:
                blt(&vchpNormal, pchp, cwCHP);
                /* in case default size is different "normal" (which is
                   used for encoding our bin files */
                pchp->hps = hpsDefault;
                }
        }

if (!bPRMNIL(prm))
        DoPrm(pchp, (struct PAP *) 0, prm);
if (cfcChp > 32767)
        *pcfcChp = 32767;
else
        *pcfcChp = cfcChp;
MeltHp();
} /* end of  S e t C h p  */


typePN PnFkpFromFcScr(pfkpd, fc)
struct FKPD *pfkpd;
typeFC fc;
{ /* Return page number in scratch file with props for char at fc. */
struct BTE *pbte = **pfkpd->hgbte;
int ibte = pfkpd->ibteMac;

/* A short table, linear search? */
while (ibte--)
        if (pbte->fcLim > fc)
                return pbte->pn;
        else
                pbte++;

return pfkpd->pn;       /* On current page. */
} /* end of  P n F k p F r o m F c S c r  */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\editsect.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM

#include <windows.h>

/*#include "toolbox.h"*/
#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "str.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "debug.h"

extern int              docMode;
extern struct FCB       (**hpfnfcb)[];

int                     **HAllocate();



#ifdef CASHMERE     /* Only if we support multiple sections */
AddSects(docDest, cpDest, docSrc, cpFirst, cpLim, hsetbSrc)
int docDest, docSrc;
typeCP cpDest, cpFirst, cpLim;
struct SETB **hsetbSrc;
{ /* Add SED's to correspond with inserted section marks */
/* Called after inserting docSrc[cpFirst:cpLim) into docDest@cpDest */
struct SETB *psetbSrc, **hsetbDest, *psetbDest;
struct SED *psedSrc, *psedDest;
int csedDest, isedSrc, csedIns, isedDest;


psedSrc = &(psetbSrc = *hsetbSrc)->rgsed[0];
psedSrc += (isedSrc = IcpSearch(cpFirst + 1, psedSrc,
    cchSED, bcpSED, psetbSrc->csed));

/* Find all section marks in inserted area. */
for (csedIns = 0; psedSrc->cp <= cpLim; psedSrc++, csedIns++)
        ;

if (csedIns != 0)
        { /* Insert sed's. */
        /* Ensure destination setb large enough */
        /* HEAP MOVEMENT */
        if (FNoHeap(hsetbDest = HsetbEnsure(docDest, csedIns)))
                return;
        psedDest = &(psetbDest = *hsetbDest)->rgsed[0];

        /* Find ised to insert new sed's */
        psedDest += (isedDest = IcpSearch(cpDest + 1, psedDest,
              cchSED, bcpSED, csedDest = psetbDest->csed));

        /* Insert new sed's */
        psedSrc = &(psetbSrc = *hsetbSrc)->rgsed[isedSrc];
        psetbDest->csed += csedIns;     /* Update sed count */
        blt(psedDest, psedDest + csedIns,
            cwSED * (csedDest - isedDest)); /* Open up setb */
        blt(psedSrc, psedDest, cwSED * csedIns);
        while (csedIns--)
                (psedDest++)->cp = cpDest + (psedSrc++)->cp - cpFirst;
        }
} /* end of  A d d S e c t s  */
#endif  /* CASHMERE */



#ifdef CASHMERE     /* Only if we support separate sections */
RemoveDelSeds(doc, cpFirst, cpLim, hsetb)
int doc;
typeCP cpFirst, cpLim;
struct SETB **hsetb;
{
struct SETB *psetb;
struct SED *psed, *psedT;
int ised, csed, csedDel;

        {
        psetb = *hsetb;
        psed = &psetb->rgsed[0];
        psed += (ised =
            IcpSearch(cpFirst + 1, psed, cchSED, bcpSED, csed = psetb->csed));

        /* Find all section marks in deleted area. */
        for (psedT = psed, csedDel = 0; psedT->cp <= cpLim; psedT++, csedDel++)
                ;

        Assert(ised + csedDel < csed);

        if (csedDel != 0)
                { /* Close up setb. */
                blt(psedT, psed, cwSED * ((csed -= csedDel) - ised));
                (*hsetb)->csed = csed;
                docMode = docNil;
                }
        }
} /* end of  R e m o v e D e l S e d s  */
#endif      /* CASHMERE */



#ifdef CASHMERE     /* This loads a complete section table */
struct SETB **HsetbCreate(fn)
int fn;
{ /* Create a section table from a formatted file */

struct SETB *psetbFile;
typePN pn;
int cchT;
int csed, ised;
struct SETB **hsetb;
int *pwSetb;
int cw;
struct SED *psed;

Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);

if ((pn = (**hpfnfcb)[fn].pnSetb) == (**hpfnfcb)[fn].pnBftb)
        return (struct SETB **) 0;
psetbFile = (struct SETB *) PchGetPn(fn, pn, &cchT, false);
if ((csed = psetbFile->csed) == 0)
        return (struct SETB **)0;

hsetb = (struct SETB **) HAllocate(cw = cwSETBBase + csed * cwSED);
if (FNoHeap(hsetb))
        return (struct SETB **)hOverflow;
pwSetb = (int *) *hsetb;

blt(psetbFile, pwSetb, min(cwSector, cw));

while ((cw -= cwSector) > 0)
        { /* Copy the sed's to heap */
        blt(PchGetPn(fn, ++pn, &cchT, false), pwSetb += cwSector,
            min(cwSector, cw));
        }

for (ised = 0, psed = &(**hsetb).rgsed[0]; ised < csed; ised++, psed++)
        psed->fn = fn;

(**hsetb).csedMax = csed;
return hsetb;
} /* end of  H s e t b C r e a t e  */
#endif  /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\editftn.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

/*#include "toolbox.h"*/
#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "str.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "debug.h"

extern struct DOD (**hpdocdod)[];
extern struct FCB       (**hpfnfcb)[];
extern int      wwMac;
extern struct WWD rgwwd[];
extern struct WWD *pwwdCur;
extern int **HAllocate();
extern int docCur;
extern typeCP cpMacCur;
extern struct SEL selCur;
extern int ferror;





#ifdef FOOTNOTES
AddFtns(docDest, cpDest, docSrc, cpFirst, cpLim, hfntbSrc)
int docDest, docSrc;
typeCP cpDest, cpFirst, cpLim;
struct FNTB **hfntbSrc;
{ /* Add footnote text to coppespond with inserted references */
/* Called after inserting docSrc[cpFirst:cpLim) into docDest@cpDest */
struct FNTB *pfntbSrc, **hfntbDest, *pfntbDest;
struct FND *pfndSrc, *pfndDest;
int cfndDest, ifndSrc, cfndIns, ifndDest;
typeCP cpFtnSrc, dcpFtn, cpFtnDest;
typeCP dcp;

if ((pfndSrc = &(pfntbSrc = *hfntbSrc)->rgfnd[0])->cpFtn <= cpFirst)
        return; /* No footnotes or source text is inside ftns */

pfndSrc += (ifndSrc = IcpSearch(cpFirst, pfndSrc,
    cchFND, bcpRefFND, pfntbSrc->cfnd));
cpFtnSrc = pfndSrc->cpFtn;

/* Find all references in inserted area. */
for (cfndIns = 0; pfndSrc->cpRef < cpLim; pfndSrc++, cfndIns++)
        ;

if (cfndIns != 0)
        { /* Insert footnote text and fnd's. */
        dcpFtn = pfndSrc->cpFtn - cpFtnSrc; /* Length of ftn texts */

        /* Ensure destination fntb large enough */
        /* HEAP MOVEMENT */
        if (FNoHeap(hfntbDest = HfntbEnsure(docDest, cfndIns)))
                return;
        if ((pfndDest = &(pfntbDest = *hfntbDest)->rgfnd[0])->cpFtn <= cpDest)
                { /* Inserting refs inside footnotes? No way! */
                Error(IDPMTFtnLoad);
                return;
                }

        /* Find ifnd to insert new fnd's */
        ifndDest = IcpSearch(cpDest, pfndDest,
              cchFND, bcpRefFND, cfndDest = pfntbDest->cfnd);

        /* Insert new footnote text */
        /* HEAP MOVEMENT */
        ReplaceCps(docDest, cpFtnDest = (pfndDest + ifndDest)->cpFtn, cp0,
            docSrc, cpFtnSrc, dcpFtn);
        if (ferror)
            return;

        /* Insert new fnd's */
        pfndSrc = &(pfntbSrc = *hfntbSrc)->rgfnd[ifndSrc];
        pfndDest = &(pfntbDest = *hfntbDest)->rgfnd[ifndDest];
        pfntbDest->cfnd += cfndIns;     /* Update fnd count */
        pfndDest->cpFtn += dcpFtn; /* AdjustCp considers the insertion to be
                                        part of this footnote; correct it. */
        blt(pfndDest, pfndDest + cfndIns,
            cwFND * (cfndDest - ifndDest)); /* Open up fntb */
        while (cfndIns--)
                { /* Copy fnd's */
                pfndDest->cpRef = cpDest + pfndSrc->cpRef - cpFirst;
                (pfndDest++)->cpFtn =
                    cpFtnDest + (pfndSrc++)->cpFtn - cpFtnSrc;
                }
        /* Invalidate dl's of later ftn refs */
        dcp = (**hfntbDest).rgfnd[0].cpFtn - ccpEol - cpDest;
        AdjustCp(docDest, cpDest, dcp, dcp);
        RecalcWwCps();
        }
}
#endif  /* FOOTNOTES */




#ifdef FOOTNOTES
/* R E M O V E  D E L  F T N  T E X T */
RemoveDelFtnText(doc, cpFirst, cpLim, hfntb)
int doc;
typeCP cpFirst,cpLim;
struct FNTB **hfntb;
/* Remove the text of footnotes that are contained in the selection that is
    delimited by cpFirst and CpLim  */
{
        struct FNTB *pfntb;
        struct FND *pfnd, *pfndT;
        int cfnd, ifnd, cfndDel;

        if  ((pfnd = &(pfntb = *hfntb)->rgfnd[0])->cpFtn > cpFirst)
                {
                pfnd += (ifnd =
                     IcpSearch(cpFirst, pfnd, cchFND, bcpRefFND, cfnd = pfntb->cfnd));

                /* Find all references in deleted area. */
                for (pfndT = pfnd, cfndDel = 0; pfndT->cpRef < cpLim; pfndT++, cfndDel++)
                        ;

#ifdef DEBUG
                Assert(ifnd + cfndDel < cfnd);
#endif

                if (cfndDel != 0)
                        { /* Delete footnote text and close up fntb. */
                        typeCP cpDel = pfnd->cpFtn;
                        blt(pfndT, pfnd, cwFND * ((cfnd -= cfndDel) - ifnd));
                        (*hfntb)->cfnd = cfnd;
                        /* HEAP MOVEMENT */
                        Replace(doc, cpDel, pfnd->cpFtn - cpDel, fnNil, fc0, fc0);
                        if (cfnd == 1)
                                {

                                Replace(doc,  (**hpdocdod)[doc].cpMac - ccpEol,
                                    (typeCP) ccpEol, fnNil, fc0, fc0);
                                FreeH((**hpdocdod)[doc].hfntb);
                                (**hpdocdod)[doc].hfntb = 0;
/* fix selCur twisted by AdjustCp. Another AdjustCp still pending. */
                                if (doc == docCur && !pwwdCur->fFtn)
                                        {
                                        selCur.cpFirst = selCur.cpLim = cpLim;
                                        cpMacCur = (**hpdocdod)[doc].cpMac;
                                        }
                                }
                        else
                                { /* Invalidate dl's of later ftn refs */
                                typeCP dcp = (**hfntb).rgfnd[0].cpFtn -
                                    ccpEol - cpLim;
                                AdjustCp(doc, cpLim, dcp, dcp);
                                }
                        }
                }
}
#endif  /* FOOTNOTES */



#ifdef FOOTNOTES
struct FNTB **HfntbCreate(fn)
int fn;
{ /* Create a footnote table from a formatted file */
struct FNTB *pfntbFile;
typePN pn;
int cchT;

int cfnd;
struct FNTB **hfntb;
int *pwFntb;
int cw;

#ifdef DEBUG
Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);
#endif
if ((pn = (**hpfnfcb)[fn].pnFntb) == (**hpfnfcb)[fn].pnSep)
        return 0;
pfntbFile = (struct FNTB *) PchGetPn(fn, pn, &cchT, false);
if ((cfnd = pfntbFile->cfnd) == 0)
        return (struct FNTB **)0;

hfntb = (struct FNTB **) HAllocate(cw = cwFNTBBase + cfnd * cwFND);
if (FNoHeap(hfntb))
        return (struct FNTB **)hOverflow;

pwFntb = (int *) *hfntb;

blt(pfntbFile, pwFntb, min(cwSector, cw));

while ((cw -= cwSector) > 0)
        { /* Copy the fnd's to heap */
        blt(PchGetPn(fn, ++pn, &cchT, false), pwFntb += cwSector,
            min(cwSector, cw));
        }

(*hfntb)->cfndMax = cfnd;
return hfntb;
}
#endif  /* FOOTNOTES */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\ffdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

struct IFI
	{
	int             xp;
	int             xpLeft;
	int             xpRight;
	int             xpReal;
	int		xpPr;
	int		xpPrRight;
	int             ich;
	int             ichLeft;
	int             ichPrev;
	int             ichFetch;
	int             dypLineSize;
	int             cchSpace;
	int             cBreak;
	int             chBreak;
	int             jc;

#ifdef CASHMERE
	int             tlc;
#endif /* CASHMERE */

	int             fPrevSpace;
	};

#define cwIFI   (sizeof (struct IFI) / sizeof (int))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\filedefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#include "machdefs.h"

#define cfcPage         ((typeFC)cbSector)
#define ibpNil          255
#define lruMax          ((unsigned) 65535)
#define fnMax           5
#define fnInsert        (fnNil - 1)
#define fnScratch       0
#define osfnNil         (-1)
#define rfnNil          rfnMax /* Stored in 7 bits */
#define rfnFree         (rfnMax + 1)
#define wMW             ('M' + ('W' << 8))
#define wSY             ('S' + ('Y' << 8))
#define wHP             ('H' + ('P' << 8))
#define cwSector        (cbSector / sizeof (int))
#define cbpMustKeep     6       /* assume no bp will be dislodged for this
                                   many calls to IbpEnsureValid */
#define cbOpenFileBuf   128

#ifdef SAND
#define wMagic          0177062
#define wMagicOld       0137061
#else /* not SAND */
#define wMagic          0137061
#endif /* not SAND */

#define wMagicTool      ((0253 << 8) + 0)

#define fcMax           ((typeFC) 2147483647)

#define fpeNoSuch       (-5)
#define fpeDiskFull     (-7)

struct BPS
        {
        typePN     pn;
        int        fn;
        typeTS     ts;          /* time stamp - used in LRU algorithm */
        unsigned   fDirty : 1;
        unsigned   cch : 15;
        CHAR       ibpHashNext; /* link for external chained hashing
                                                        collision resolution */
        };


struct FCB
        {
        typeFC    fcMac;          /* includes FIB, but not FKP's */
        unsigned char fFormatted : 1;
        unsigned char fDelete : 1;
        unsigned char fReferenced : 1;
        unsigned char dty : 4;
        unsigned char fOpened: 1;   /* Whether file has been opened before */
        unsigned char rfn : 7;
        unsigned char fSearchPath: 1; /* Search path when first opened */
        int       mdExt;
        int       mdFile;
        typePN    pnChar;
        typePN    pnPara;
        typePN    pnFntb;
        typePN    pnSep;
        typePN    pnSetb;
        typePN    pnBftb;
        typePN    pnFfntb;      /* font family name table offset */
        typePN    pnMac;  /* # of pages actually in existence */
        typeFC    (**hgfcChp)[];
        typeFC    (**hgfcPap)[];
        CHAR      (**hszFile)[];
        CHAR      (**hszSsht)[];
        CHAR      rgbOpenFileBuf[ cbOpenFileBuf ]; /* OpenFile's work space */

#ifdef SAND
        int       version;      /* version byte */
        int       vref;         /* volume reference number */
#endif /* SAND */

        unsigned int fDisableRead: 1; /* disable reading of file */
        };

#define cbFCB   (sizeof (struct FCB))
#define cwFCB   (sizeof (struct FCB) / sizeof (int))

struct ERFN
        { /* Real file (opened in os) */
        int     osfn;
        int     fn;
        typeTS  ts;     /* time stamp - used in LRU algorithm */
        };


#define cchToolHeader   14

struct FIB
        {
        int             wIdent; /* Word-specific magic number */
        int             dty;
        int             wTool;
        int             cReceipts; /* Number of external receipts allowed */
        int             cbReceipt; /* Length of each receipt */
        int             bReceipts; /* One word offset from beginning of file
                                        to beginning of receipts */
        int             isgMac;    /* Number of code segments included */
        /* End of Multi-Tool standard header */
        typeFC          fcMac;
        typePN          pnPara;
        typePN          pnFntb;
        typePN          pnSep;
        typePN          pnSetb;
        typePN          pnBftb; /* Also pnPgtb */
        typePN          pnFfntb;        /* font family name table */
        CHAR            szSsht[66]; /* Style sheet name */
        typePN          pnMac;
        CHAR            rgbJunk[cbSector - (cchToolHeader + sizeof (typeFC)
                             + 7 * sizeof (typePN) + 66)];
        };

#define cchFIB  (sizeof (struct FIB))

#define CONVFROMWORD (TRUE + 2)  /* used by FWriteFn to convert Word file
                                  characters to Write ANSI set */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fileres.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fileres.c -- functions from file.c that are usually resident */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOATOM
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMETAFILE
#define NOMSG
#define NOHDC
#define NOGDI
#define NOMB
#define NOFONT
#define NOPEN
#define NOBRUSH
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#define NOUAC
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "str.h"
#include "debug.h"


extern int                      vfDiskFull;
extern int                      vfSysFull;
extern int                      vfnWriting;
extern CHAR                     (*rgbp)[cbSector];
extern typeTS                   tsMruRfn;
extern struct BPS               *mpibpbps;
extern int                      ibpMax;
extern struct FCB               (**hpfnfcb)[];
extern typeTS                   tsMruBps;
extern struct ERFN              dnrfn[rfnMax];
extern int                      iibpHashMax;
extern CHAR                     *rgibpHash;
extern int                      rfnMac;
extern int                      ferror;
extern CHAR                     szWriteDocPrompt[];
extern CHAR                     szScratchFilePrompt[];
extern CHAR                     szSaveFilePrompt[];


#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax


#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#define ErrorWithMsg( idpmt, szModule )         Error( idpmt )
#define DiskErrorWithMsg( idpmt, szModule )     DiskError( idpmt )
#endif

#define osfnNil (-1)


CHAR *PchFromFc(fn, fc, pcch)
int fn;
typeFC fc;
int *pcch;
{ /*
        Description:    Reads from a file, starting at virtual character
                        position fc.  Reads until end of buffer page.
        Returns:        Pointer to char buffer starting at fc.
                        The number of characters read is returned in *pcch.
  */
int dfc;
CHAR *pch;
typePN pn;
int ibp;
struct BPS *pbps;

        dfc = (int) (fc % cfcPage);
        pn = (typePN) (fc / cfcPage);

        ibp = IbpEnsureValid(fn, pn);
        pbps = &mpibpbps[ibp];
        *pcch = pbps->cch - dfc;
        return &rgbp[ibp][dfc];
}
/* end of  P c h F r o m F c  */




/***        PchGetPn - Assure file page loaded, return pointer
 *
 */

CHAR *PchGetPn(fn, pn, pcch, fWrite)
int fn;
typePN pn;
int *pcch;
BOOL fWrite; // missing before?? (2.11.91) D. Kent
{ /*
        Description:    Get char pointer to page buffer, option to mark
                        page as dirty.
        Returns:        Pointer to buffer.
                        cch in *pcch
  */

        int ibp = IbpEnsureValid(fn, pn);
        struct BPS *pbps = &mpibpbps[ibp];

        *pcch = pbps->cch;
        pbps->fDirty |= fWrite;
        return rgbp[ibp];
} /* end of  P c h G e t P n  */




int IbpEnsureValid(fn, pn)
int fn;
typePN pn;
{ /*
        Description:    Get page pn of file fn into memory.
                        If already in memory, return.
        Returns:        Bp index (buffer slot #) where the page resides
                        in memory.
  */

int ibp;
register struct BPS *pbps;

#ifdef DEBUG
 CheckIbp();
#endif /* DEBUG */

/* Is the page currently in memory? */
 ibp = rgibpHash[IibpHash(fn,pn)];
 /* ibp is the first in a linked list of possible matches */
 /* resident in memory */

 Scribble(3,'V');

 while (ibp != ibpNil)    /* while not end of linked list */
    {                   /* check if any buffers in memory match */
    pbps = &mpibpbps[ibp];
    if (pbps->fn == fn && pbps->pn == pn)
        { /* Found it */
        pbps->ts = ++tsMruBps;      /* mark page as MRUsed */
        Scribble(3,' ');
        return ibp;
        }
    ibp = pbps->ibpHashNext;
    }

/* page is not currently in memory */

 return IbpMakeValid( fn, pn );
} /* end of I b p E n s u r e V a l i d  */




CloseEveryRfn( fHardToo )
{   /* Close all files we have open. Close only files on removable media
       if fHardToo is FALSE; ALL files if fHardToo is TRUE */
int rfn;

for (rfn = 0; rfn < rfnMac; rfn++)
    {
    int fn = dnrfn [rfn].fn;

    if (fn != fnNil)
        if ( fHardToo ||
             !((POFSTRUCT)((**hpfnfcb)[fn].rgbOpenFileBuf))->fFixedDisk )
            {
            CloseRfn( rfn );
            }
    }
}



typeFC FcWScratch(pch, cch)
CHAR *pch;
int cch;
{ /*
        Description:    Write chars at end of scratch file.
        Returns:        first fc written.
 */
        typeFC fc = (**hpfnfcb)[fnScratch].fcMac;
#if 0
        extern BOOL  bNo64KLimit;

        if ((!bNo64KLimit) && (((long) fc) + ((long) cch) > 65536L))  /* scratch file to big */
        {
        DiskErrorWithMsg(IDPMTSFER, " FcWScratch"); /* session too long */

        vfSysFull = fTrue;
                /* recovery is accomplished: all that happens is that a few
                   characters do not get written to the scratch file - the
                   user loses only a little bit of his work. */
        }
        else
#endif
                WriteRgch(fnScratch, pch, cch);
        return fc;
}




WriteRgch(fn, pch, cch)
int fn;
CHAR *pch;
int cch;
{ /*
        Description:    Writes char string pch, length cch, to end of
                        file fn.
        Returns:        nothing
 */
 extern vfDiskError;
 struct FCB *pfcb = &(**hpfnfcb)[fn];
 typePN pn = (typePN) (pfcb->fcMac / cfcPage);
#ifdef WIN30
 /* Error checking was horrendous in these early days, right?
    Ha.  It still is.  In any case, don't know WHAT we can do
    if the page number has gotten too large, so just fake a 
    disk error so that IbpEnsureValid() doesn't go off into 
    never-never land!  This catch effectively limits us to 
    4M files ..pault 11/1/89 */

 if (pn > pgnMax)
#ifdef DEBUG
    DiskErrorWithMsg(IDPMTSDE2, "writergch");
#else    
    DiskError(IDPMTSDE2);
#endif
 else
#endif

        while (cch > 0)
                { /* One page at a time */
                int ibp = IbpEnsureValid(fn, pn++);
                struct BPS *pbps = &mpibpbps[ibp];
                int cchBp = pbps->cch;
                int cchBlt = min((int)cfcPage - cchBp, cch);

                Assert( vfDiskError ||
                        cchBp == pfcb->fcMac - (pn - 1) * cfcPage);

                bltbyte(pch, &rgbp[ibp][cchBp], cchBlt);
                pbps->cch += cchBlt;
                pbps->fDirty = true;
                pfcb->fcMac += cchBlt;
                pfcb->pnMac = pn;
                pch += cchBlt;
                cch -= cchBlt;
                }
} /* end of  W r i t e R g c h  */




CloseRfn( rfn )
int rfn;
{/*
        Description:    Close a file and delete its Rfn entry
        Returns:        nothing
 */
        struct ERFN *perfn = &dnrfn[rfn];
        int fn = perfn->fn;

        Assert (rfn >= 0 &&
                rfn < rfnMac &&
                perfn->osfn != osfnNil &&
                fn != fnNil);

#ifdef DEBUG
#ifdef DFILE
        CommSzSz( "Closing file: ", &(**(**hpfnfcb)[fn].hszFile)[0] );
#endif
#endif
        /* Close may fail if windows already closed the file for us,
           but that's OK */
        FCloseDoshnd( perfn->osfn );

        {   /* Just like the statement below, but 28 bytes less
               under CMERGE V13 */
        REG1    struct FCB *pfcb = &(**hpfnfcb) [fn];
        pfcb->rfn = rfnNil;
        }
        /* (**hpfnfcb)[fn].rfn = rfnNil; */


        perfn->fn = fnNil;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\file.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* file.c -- WRITE file interface functions */
/* It is important that the external interface to this module be entirely
   at the level of "fn's", not "osfn's" and/or "rfn's".  An intermodule call
   may cause our files to be closed, and this is the only module internally
   capable of compensating for this */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSMETRICS
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOHDC
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMSG
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "docdefs.h"
#include "filedefs.h"
#define NOSTRUNDO
#include "str.h"
#include "debug.h"


extern int						vfDiskFull;
extern int						vfSysFull;
extern int						vfnWriting;
extern CHAR						(*rgbp)[cbSector];
extern typeTS					tsMruRfn;
extern struct BPS				*mpibpbps;
extern int						ibpMax;
extern struct FCB				(**hpfnfcb)[];
extern typeTS					tsMruBps;
extern struct ERFN				dnrfn[rfnMax];
extern int						iibpHashMax;
extern CHAR						*rgibpHash;
extern int						rfnMac;
extern int						ferror;
extern CHAR						szWriteDocPrompt[];
extern CHAR						szScratchFilePrompt[];
extern CHAR						szSaveFilePrompt[];


#ifdef CKSM
#ifdef DEBUG
extern unsigned					(**hpibpcksm) [];
extern int						ibpCksmMax;
#endif
#endif


#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax


#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#define ErrorWithMsg( idpmt, szModule )			Error( idpmt )
#define DiskErrorWithMsg( idpmt, szModule )		DiskError( idpmt )
#endif


#define osfnNil (-1)

STATIC int near  RfnGrab( void );
STATIC int near  FpeSeekFnPn( int, typePN );
STATIC typeOSFN near  OsfnEnsureValid( int );
STATIC typeOSFN near  OsfnReopenFn( int );
STATIC CHAR *(near SzPromptFromFn( int ));

/* The following debug flags are used to initiate, during debug, specific
   low-level disk errors */

#ifdef DEBUG
int vfFakeReadErr = 0;
int vfFakeWriteErr = 0;
int vfFakeOpenErr = 0;
#endif


#ifdef CKSM
#ifdef DEBUG
unsigned CksmFromIbp( ibp )
int ibp;
{
 int cb = mpibpbps [ibp].cch;
 unsigned cksm = 0;
 CHAR *pb;

 Assert( ibp >= 0 && ibp < ibpCksmMax );
 Assert( mpibpbps [ibp].fn != fnNil );
 Assert( !mpibpbps [ibp].fDirty );

 pb = rgbp [ibp];
 while (cb-- > 0)
	cksm += *(pb++);

 return cksm;
}
#endif
#endif



typeFC FcMacFromUnformattedFn( fn )
int fn;
{	/* Obtain fcMac for passed unformatted fn by seeking to the file's end.
       If it fails, return -1
       If it succeeds, return the fcMac */
 typeFC fcMac;
 typeOSFN osfn;

 Assert( (fn != fnNil) && (!(**hpfnfcb) [fn].fFormatted) );

 if ((osfn = OsfnEnsureValid( fn )) == osfnNil)
	return (typeFC) -1;
 else
	{
	if ( FIsErrDwSeek( fcMac=DwSeekDw( osfn, 0L, SF_END )))
		{
		if (fcMac == fpeBadHndError)
			{	/* Windows closed the file for us */
			if ( ((osfn = OsfnReopenFn( fn )) != osfnNil) &&
                 !FIsErrDwSeek( fcMac = DwSeekDw( osfn, 0L, SF_END )) )
					/* Successfully re-opened file */
				return fcMac;
			}
		if (FIsCaughtDwSeekErr( fcMac ))
				/* Suppress reporting of error -- Windows did it */
			ferror = TRUE;
		DiskErrorWithMsg(IDPMTSDE, " FcMacFromUnformattedFn");
		return (typeFC) -1;
		}
	}

return fcMac;
}




IbpLru(ibpStarting)
int ibpStarting;
/*
		Description:	Find least recently used BPS (Buffer page) starting
						at slot ibpStarting.
		Returns:		Number of the least recently used buffer slot.
*/
{
		int ibp, ibpLru = 0;
		typeTS ts, tsLru;
		struct BPS *pbps = &mpibpbps[ibpStarting];

		tsLru = -1;		/* Since time stamps are unsigned ints, -1 */
						/* is largest time stamp. */
		for(ibp = ibpStarting; ibp < ibpMax; ibp++, pbps++)
				{
				ts = pbps->ts - (tsMruBps + 1);
				/* The time stamp can conceivably wrap around and thus a */
				/* simple < or > comparison between time stamps cannot be */
				/* used to determine which is more or less recently used. */
				/* The above statement normalizes time stamps so that the */
				/* most recently used is FFFF and the others fall between */
				/* 0 and FFFE.	This method makes the assumption that */
				/* time stamps older than 2^16 clicks of the time stamp */
				/* counter have long since disappeared.  Otherwise, such */
				/* ancients would appear to be what they are not. */
				if (ts <= tsLru) {tsLru = ts; ibpLru = ibp;}
				}
		return(ibpLru);
}




int IbpMakeValid(fn, pn)
int fn;
typePN pn;
{ /*
		Description:	Get page pn of file fn into memory.
						Assume not already in memory.
		Returns:		Bp index (buffer slot #) where the page resides
						in memory.
  */
#define cbpClump		4

#define cpnAlign		4
#define ALIGN

int ibpT, cbpRead;
int ibp, iibpHash, ibpPrev;
typePN pnT;
register struct BPS *pbps;
int ibpNew;
int cch;
int fFileFlushed;
#ifdef ALIGN
int dibpAlign;
#endif

#ifdef DEBUG
 int cbpReadT;
 CheckIbp();
#endif /* DEBUG */
 Assert(fn != fnNil);

/* page is not currently in memory */

/* We will try to read in cbpClump Buffer Pages beginning with the
   least recently used */

 /* Pick best starting slot for read based on a least-recently-used scheme */

 if (vfnWriting != fnNil)
		/* Currently saving file, favor adjacent slots for fn being written  */
	ibpNew = IbpWriting( fn );
 else
		/* If reading from the scratch file, do not use the first
           cpbMustKeep slots. This is necessary to prevent a disk full
           condition from being catastrophic. */
	ibpNew = IbpLru( (fn == fnScratch) ? cbpMustKeep : 0 );


 /* Empty the slots by flushing out ALL buffers holding pieces of their fn's */
 /* Compute cbpRead */
 pbps = &mpibpbps[ ibpNew ];
 for ( cbpRead = 0;  cbpRead < min( cbpClump, ibpMax - ibpNew );
                                                       cbpRead++, pbps++ )
	{
#ifdef CKSM
#ifdef DEBUG
	int ibpT = pbps - mpibpbps;

	if (!pbps->fDirty && pbps->fn != fnNil)
		Assert( (**hpibpcksm) [ibpT] == CksmFromIbp( ibpT ) );
#endif
#endif
	if (pbps->fDirty && pbps->fn != fnNil)
		if (!FFlushFn( pbps->fn ))
			break;
	}

 /* If a flush failed, cbpRead was reduced. If it was reduced to 0, this
	is serious. If the file was not fnScratch, we can consider it flushed
	even though the flush failed, because upper-level procedures will detect
	the error and cancel the operation. If it was fnScratch, we must obtain
	a new slot for the page we are trying to read */
 if (cbpRead == 0)
	{
	if (pbps->fn == fnScratch)
		ibpNew = IbpFindSlot( fn );
	cbpRead++;
	}
 else
	{	/* Restrict cbpRead according to the following:
				(1) If we are reading in the text area, we don't want to
					free pages for stuff past the end of the text area
					that we know CchPageIn won't give us
				(2) If we are reading in the properties area, we only want to
					read one page, because FetchCp depends on us not trashing
					the MRU page */
	struct FCB *pfcb = &(**hpfnfcb)[fn];

	if (pfcb->fFormatted && fn != fnScratch && pn >= pfcb->pnChar)
		cbpRead = 1;
	else
		{
		typePN cbpValid = (pfcb->fcMac - (pn * cfcPage)) / cfcPage;

		cbpRead = min( cbpRead, max( 1, cbpValid ) );
		}
	}

#ifdef ALIGN
     /* Align the read request on an even sector boundary, for speed */
 dibpAlign = (pn % cpnAlign);
 if (cbpRead > dibpAlign)
		/* We are reading enough pages to cover the desired one */
	pn -= dibpAlign;
 else
	dibpAlign = 0;
#endif

	/* Remove flushed slots from their hash chains */
 for ( pbps = &mpibpbps[ ibpT = ibpNew + cbpRead - 1 ];
       ibpT >= ibpNew;
       ibpT--, pbps-- )
	if (pbps->fn != fnNil)
		FreeBufferPage( pbps->fn, pbps->pn );

	/* Free slots holding any existing copies of pages to be read */
#ifdef	DBCS				/* was in KKBUGFIX */
/*	In #else code ,If pn= 8000H(= -32768), pnT can not be littler than pn */
 for ( pnT = pn + cbpRead; pnT > pn; pnT-- )		// Assume cbpRead > 0
	FreeBufferPage( fn, pnT-1 );
#else
 for ( pnT = pn + cbpRead - 1; (int)pnT >= (int)pn; pnT-- )
	FreeBufferPage( fn, pnT );
#endif


	/* Read contents of file page(s) into buffer slot(s) */
 cch = CchPageIn( fn, pn, rgbp[ibpNew], cbpRead );

#ifdef DEBUG
 cbpReadT = cbpRead;
#endif

	/* Fill in bps records for as many bytes as were read, but always
       at least one record (to support PnAlloc). If we reached the end of the
       file, the unfilled bps slots are left free */
 pbps = &mpibpbps[ ibpT = ibpNew ];
 do
	{
	pbps->fn = fn;
	pbps->pn = pn;
	pbps->ts = ++tsMruBps; /* mark page as MRUsed */
	pbps->fDirty = false;
	pbps->cch = min( cch, cbSector );
	pbps->ibpHashNext = ibpNil;

	cch = max( cch - cbSector, 0 );

	/* put in new hash table entry for fn,pn */
	iibpHash = IibpHash(fn, pn);
	ibp = rgibpHash[iibpHash];
	ibpPrev = ibpNil;
	while (ibp != ibpNil)
		{
		ibpPrev = ibp;
		ibp = mpibpbps[ibp].ibpHashNext;
		}
	if (ibpPrev == ibpNil)
		rgibpHash[iibpHash] = ibpT;
	else
		mpibpbps[ibpPrev].ibpHashNext = ibpT;

	pn++;  ibpT++;	pbps++;

	}	while ( (--cbpRead > 0) && (cch > 0) );

#ifdef CKSM
#ifdef DEBUG
	/* Compute checksums for newly read pages */

 {
 int ibp;

 for ( ibp = ibpNew; ibp < ibpNew + cbpReadT; ibp++ )
	if (mpibpbps [ibp].fn != fnNil && !mpibpbps [ibp].fDirty)
		(**hpibpcksm) [ibp] = CksmFromIbp( ibp );
 }
	CheckIbp();
#endif /* DEBUG */
#endif

#ifdef ALIGN
	return (ibpNew + dibpAlign);
#else
	return (ibpNew);
#endif
} /* end of I b p M a k e V a l i d  */




FreeBufferPage( fn, pn )
int fn;
int pn;
{		/* Free buffer page holding page pn of file fn if there is one */
		/* Flushes fn if page is dirty */
 int iibp = IibpHash( fn, pn );
 int ibp = rgibpHash[ iibp ];
 int ibpPrev = ibpNil;

 Assert( fn != fnNil );
 while (ibp != ibpNil)
	{
	struct BPS *pbps=&mpibpbps[ ibp ];

	if ( (pbps->fn == fn) && (pbps->pn == pn ) )
		{	/* Found it. Remove this page from the chain & mark it free */

		if (pbps->fDirty)
			FFlushFn( fn );
#ifdef CKSM
#ifdef DEBUG
		else	/* Page has not been trashed while in memory */
			{
			Assert( (**hpibpcksm) [ibp] == CksmFromIbp( ibp ) );
			}
#endif
#endif

		if (ibpPrev == ibpNil)
				/* First entry in hash chain */
			rgibpHash [ iibp ] = pbps->ibpHashNext;
		else
			mpibpbps[ ibpPrev ].ibpHashNext = pbps->ibpHashNext;

		pbps->fn = fnNil;
		pbps->fDirty = FALSE;
			/* Mark the page not recently used */
		pbps->ts = tsMruBps - (ibpMax * 4);
			/* Mark pages that are on even clump boundaries a bit less recently
               used so they are favored in new allocations */
		if (ibp % cbpClump == 0)
			--(pbps->ts);
		pbps->ibpHashNext = ibpNil;
		}
	ibpPrev = ibp;
	ibp = pbps->ibpHashNext;
	}
#ifdef DEBUG
	CheckIbp();
#endif
}




int CchPageIn(fn, pn, rgbBuf, cpnRead)
int fn;
typePN pn;
CHAR rgbBuf[];
int cpnRead;
{ /*
		Description:	Read a cpnRead pages of file fn from disk into rgbBuf.
						Have already determined that page is not resident
						in the buffer.
		Returns:		Number of valid chars read (zero or positive #).
 */
		struct FCB *pfcb = &(**hpfnfcb)[fn];
		typeFC fcMac = pfcb->fcMac;
		typeFC fcPage = pn * cfcPage;
		int dfc;
		int fCharFormatInfo;			/* if reading Format info part of */
										/* file then = TRUE, text part of */
										/* file then = FALSE; */

			/* No reads > 32767 bytes, so dfc can be int */
		Assert( cpnRead <= 32767 / cbSector );

			/* Don't try to read beyond pnMac */
		if (cpnRead > pfcb->pnMac - pn)
			cpnRead = pfcb->pnMac - pn;

		dfc = cpnRead * (int)cfcPage;

		if (pn >= pfcb->pnMac)	/* are we trying to read beyond eof? */
				{
				return 0;		/* Nothing to read */
				}
		else if (pfcb->fFormatted && fn != fnScratch
                 && fn != vfnWriting	/* Since pnChar is zero in this case */
                 && pn >= pfcb->pnChar)
				{ /* reading character format info portion of file */
				fCharFormatInfo = TRUE;
				}
		else /* reading text portion of file */
				{ /* get dfc (cch) from fcMac */
				typeFC dfcT = fcMac - fcPage;

				fCharFormatInfo = FALSE;
				if (dfcT < dfc)
					dfc = (int) dfcT;
				else if (dfc <= fc0)	/* Nothing to read, so let's avoid disk access. */
						{
						return 0;
						}
				}

		return CchReadAtPage( fn, pn, rgbBuf, (int)dfc, fCharFormatInfo );
}




CchReadAtPage( fn, pn, rgb, dfc, fSeriousErr )
int fn;
typePN pn;
CHAR rgb[];
int dfc;
int fSeriousErr;
{ /*
		Description:	Read dfc bytes of file fn starting at page pn
						into rgb
		Returns:		Number of valid chars read (zero or positive #)
		Errors:			Returns # of chars read; ferror & vfDiskFull are
						set (in DiskError) if an error occurs.
		Notes:			Caller is responsible for assuring that the page
						range read is reasonable wrt the fn
  */

 typeOSFN osfn;
 int fpeSeek;
 int fpeRead;
 int fCaught;		/* Whether error was reported by DOS */

#ifdef DEBUG

 if (vfFakeReadErr)
	{
	dfc = 0;
	goto ReportErr;
	}
#endif

 if (!FIsErrFpe( fpeSeek = FpeSeekFnPn( fn, pn )))
	{
	osfn = OsfnEnsureValid( fn );

#ifdef DEBUG
#ifdef DFILE
	CommSzSz( "Read from file: ", &(**(**hpfnfcb)[fn].hszFile)[0] );
#endif
#endif

	if ((fpeRead = CchReadDoshnd( osfn, (CHAR FAR *)rgb, dfc )) == dfc)
		{	/* Read succeeded */
		return dfc;
		}
	else
		{
			/* Should be guaranteed that file was not closed because of seek */
		Assert( fpeRead != fpeBadHndError );

		fCaught = FIsCaughtFpe( fpeRead );
		}
	}
 else
	fCaught = FIsCaughtFpe( fpeSeek );

	/* unable to set position or read */
 if ((fn == fnScratch) || (fSeriousErr))
	{    /* unrecoverable error: either can't read from scratch */
         /* file or unable to read format info (FIB or format pages) part of */
         /* of some file. */
	dfc = 0;
	goto ReportErr;
	}
 else                    /* serious disk error on file (recoverable).*/
	{
	int cchRead = (FIsErrFpe(fpeSeek) || FIsErrFpe(fpeRead)) ? 0 : fpeRead;
	CHAR *pch = &rgb[cchRead];
	int cch = dfc - cchRead;

	/* If the positioning failed or the read failed
       for a reason other than disk full, completely
       fill the buffer with 'X's.  Otherwise, just
       fill the disputed portion (diff between #char
       requested and #char read) with 'X's */

	while (cch-- > 0)
		*pch++ = 'X';

ReportErr:
	if (fCaught)
			/* Suppress reporting of the error -- Windows reported it */
		ferror = TRUE;

	if	(pn != 0)
			/* Report error if not reading FIB */
		DiskErrorWithMsg(IDPMTSDE, " CchReadAtPage");

	return (int)dfc;
	/* recovery is accomplished: 1) Upper level procedures do not
       see any change in the world, 2) the worst thing that
       happens is that the user sees some 'X's on the screen. */
	}
}




AlignFn(fn, cch, fEven)
int fn, cch;
{ /* Make sure we have cch contiguous chars in fn */
/* if fEven, make sure fcMac is even */
		struct FCB *pfcb = &(**hpfnfcb)[fn];
		typeFC fcMac = pfcb->fcMac;
		typePN pn;
		typeFC fcFirstPage;

		pn = fcMac / cfcPage;
		fcFirstPage = (pn + 1) * cfcPage;

		Assert(cch <= cfcPage);

		if (fEven && (fcMac & 1) != 0)
				++cch;

		if (fcFirstPage - fcMac < cch)
				{
				struct BPS *pbps = &mpibpbps[IbpEnsureValid(fn, pn++)];
				pbps->cch = cfcPage;
				pbps->fDirty = true;
				fcMac = pfcb->fcMac = fcFirstPage;
				}

		if (fEven && (fcMac & 1) != 0)
				{
				struct BPS *pbps = &mpibpbps[IbpEnsureValid(fn, pn)];
				pbps->cch++;
				pbps->fDirty = true;
				pfcb->fcMac++;
				}
} /* end of  A l i g n F n	*/




/***	OsfnEnsureValid - ensure that file fn is open
 *
 *
 */

STATIC typeOSFN near OsfnEnsureValid(fn)
int fn;
{ /*
		Description:	Ensure that file fn is open (really)
		Returns:		operating system file number (osfnNil if error)
 */
		struct FCB *pfcb = &(**hpfnfcb)[fn];
		int rfn = pfcb->rfn;

		if (rfn == rfnNil)
			{ /* file doesn't have a rfn - ie. it is not opened */
#ifdef DEBUG
#ifdef DFILE
			CommSzSz( pfcb->fOpened ? "Re-opening file " :
                                      "Opening file", **pfcb->hszFile );
#endif
			if (vfFakeOpenErr || !FAccessFn( fn, dtyNormal ))
#else
			if (!FAccessFn( fn, dtyNormal ))
#endif
				{  /* unrecoverable error - unable to open file */
				DiskErrorWithMsg(IDPMTSDE, " OsfnEnsureValid");
				return osfnNil;
				}
			rfn = pfcb->rfn;
			Assert( (rfn >= 0) && (rfn < rfnMac) );
			}
		return dnrfn[rfn].osfn;
}
/* end of  O s F n E n s u r e V a l i d  */




STATIC int near FpeSeekFnPn( fn, pn )
int fn;
typePN	pn;
{	/* Seek to page pn of file fn
       return err code on failure, fpeNoErr on success
       Leaves file open (if no error occurs)
       Recovers from the case in which windows closed the file for us
     */
 typeOSFN osfn;
 long dwSeekReq;
 long dwSeekAct;

#ifdef DEBUG
#ifdef DFILE
 CommSzSz( "Seeking within file ", **(**hpfnfcb)[fn].hszFile );
#endif
#endif

 //osfn = OsfnEnsureValid( fn );
 if ((osfn = OsfnEnsureValid( fn )) == osfnNil)
	return fpeNoAccError;
 dwSeekReq = (long) pn * (long) cbSector;
 dwSeekAct = DwSeekDw( osfn, dwSeekReq, SF_BEGINNING);

 if ( ((int) dwSeekAct) == fpeBadHndError )
	{	/* Windows closed the file for us -- must reopen it */
	if ((osfn = OsfnReopenFn( fn )) == osfnNil)
		return fpeNoAccError;
	else
		dwSeekAct = DwSeekDw( osfn, dwSeekReq, SF_BEGINNING );
	}

 return (dwSeekAct >= 0) ? fpeNoErr : (int) dwSeekAct;
}




int FFlushFn(fn)
int fn;
{ /*
		Description:	Write all dirty pages of fn to disk.
						Sets vfSysFull = TRUE if disk full error occurred
						while flushing fnScratch.  Otherwise, a disk full
						error causes vfDiskFull = TRUE.
						Serious disk errors cause vfDiskError = TRUE
						Only the pages which actually made it to disk are
						marked as non-dirty.
		Returns:		TRUE if successful, FALSE if Disk full error
						while writing pages to disk.  Any other error
						is unrecoverable, ie. go back to main loop.
						To avoid extraneous error messages, the following
						two entry conditions cause FFlush to immediately
						return FALSE:
                         - If vfSysFull = TRUE and fn = fnScratch
                         - If vfDiskFull = TRUE and fn = vfnWriting
 */
int ibp;
typeOSFN osfn;
int fpe;
int cchWritten;
int cchAskWrite;
struct BPS *pbps;

Assert( fn != fnNil );

if ((vfSysFull) && (fn == fnScratch)) return (FALSE);
if ((vfDiskFull) && (fn == vfnWriting)) return (FALSE);

for (ibp = 0, pbps = mpibpbps; ibp < ibpMax; )
	{
	if (pbps->fn == fn && pbps->fDirty)
		{
		typePN pn = pbps->pn;
		int cbp = 0;
		CHAR *pch = (CHAR *)rgbp[ibp];
		struct BPS *pbpsStart = &mpibpbps[ibp];


		/* Coalesce all consecutive pages for a single write */
		do
			{
			/* taken out 11/7/84 - can't mark scratch file
               page as non dirty if chance that it will never
               get written out (write fails - disk full)
               pbps->fDirty = false;  mark page as clean */
			++ibp, ++cbp, ++pbps;
			}  while (ibp < ibpMax && pbps->fn == fn && pbps->pn == pn + cbp);

		/* Now do the write, checking for out of disk space */
		Scribble(3, 'W');

		cchAskWrite = (int)cbSector * (cbp - 1) + (pbps - 1)->cch;
		cchWritten = cchDiskHardError;	/* assure hard error if seek fails */

#ifdef DEBUG
		if (vfFakeWriteErr)
			goto SeriousError;
		else
#endif
		if ( FIsErrFpe( FpeSeekFnPn( fn, pn )) ||
             ((osfn = OsfnEnsureValid( fn )) == osfnNil) ||
#ifdef DEBUG
#ifdef DFILE
             (CommSzSz( "Writing to file: ", &(**(**hpfnfcb)[fn].hszFile)[0] ),
#endif
#endif
             (( cchWritten = CchWriteDoshnd( osfn, (CHAR FAR *)pch,
                                             cchAskWrite )) != cchAskWrite))
#ifdef DEBUG
#ifdef DFILE
                                                                             )
#endif
#endif
			{
				/* Should be guaranteed that windows did not close the file
                   since we have not called intermodule since the seek */
			Assert( cchWritten != fpeBadHndError );

			/* Seek or Write error */
			if ( !FIsErrCchDisk(cchWritten) )
				{    /* serious but recoverable disk error */
                     /* Ran out of disk space; write failed */
				if (fn == fnScratch)
					vfSysFull = fTrue;
				vfDiskFull = fTrue;
				DiskErrorWithMsg(IDPMTDFULL, " FFlushFn");
				return(FALSE);
				}
			else	/* cause of error is not disk full */
				{  /* unrecov. disk error */
#ifdef DEBUG
SeriousError:
#endif
				DiskErrorWithMsg(IDPMTSDE2, " FFlushFn");
				return FALSE;
				}
			}
		Diag(CommSzNumNum("      cchWritten, cchAskWrite ",cchWritten,cchAskWrite));

			/* ---- write was successful ---- */
			Scribble(3, ' ');
			while (cbp-- > 0)
				{    /* mark pages actually copied to disk as non dirty */
				(pbpsStart++)->fDirty = false;
#ifdef CKSM
#ifdef DEBUG
				{
				int ibpT = pbpsStart - 1  - mpibpbps;
					/* Recompute checksums for pages which are now clean */
				(**hpibpcksm) [ibpT] = CksmFromIbp( ibpT );
				}
#endif
#endif
				}
			}
		else
			{
			++ibp;
			++pbps;
			}
	}
return (TRUE);
}


#ifdef DEBUG
CheckIbp()
	{
	/* Walk through the rgibpHash and the mpibpbps structure to make sure all of
	the links are right. */

	/* 10/11/85 - Added extra Assert ( FALSE ) so we get the messages instead
                  of a freeze-up on systems not connected to a COM port.
                  Ignoring the assertion will produce the RIP with the ibp info */
	extern int fIbpCheck;
	int rgfibp[255];
	int ibp;
	int ibpHash;
	int iibp;
	static BOOL bAsserted=FALSE;

	if (fIbpCheck && !bAsserted)
		{
		if (!(ibpMax < 256))
		{
			Assert(0);
			bAsserted=TRUE;
			return;
		}

		bltc(rgfibp, false, ibpMax);

		/* Are there any circular links in mpibpbps? */
		for (iibp = 0; iibp < iibpHashMax; iibp++)
			{
			if ((ibpHash = rgibpHash[iibp]) != ibpNil)
				{
				if (!(ibpHash < ibpMax))
				{
					Assert(0);
					bAsserted=TRUE;
					return;
				}
				if (rgfibp[ibpHash])
					{
					/* Each entry in rgibpHash should point to an unique chain.
					*/
					Assert(0);
					bAsserted=TRUE;
#if DUGSTUB
					FatalExit(0x100 | ibp);
#endif
					return;
					}
				else
					{
					rgfibp[ibpHash] = true;
					while ((ibpHash = mpibpbps[ibpHash].ibpHashNext) != ibpNil)
						{
						if (!(ibpHash < ibpMax))
						{
							Assert(0);
							bAsserted=TRUE;
							return;
						}
						if (rgfibp[ibpHash])
							{
							/* The chain should be non-circular and unique. */
							Assert( FALSE );
							bAsserted=TRUE;
#if DUGSTUB
							FatalExit(0x200 | ibpHash);
#endif
							return;
							}
						rgfibp[ibpHash] = true;
						}
					}
				}
			}

		/* All chains not pointed to by rgibpHash should be nil. */
		for (ibp = 0; ibp < ibpMax; ibp++)
			{
			if (!rgfibp[ibp])
				{
				if (mpibpbps[ibp].fn != fnNil)
					{
					Assert( FALSE );
					bAsserted=TRUE;
#if DUGSTUB
					FatalExit(0x400 | mpibpbps[ibp].fn);
#endif
					return;
					}
				if (mpibpbps[ibp].ibpHashNext != ibpNil)
					{
					Assert( FALSE );
					bAsserted=TRUE;
#if DUGSTUB
					FatalExit(0x300 | ibp);
#endif
					return;
					}
				}
			}
		}
	}
#endif /* DEBUG */


/* Formerly fileOC.c -- file open and close routines */


/***		SetRfnMac - set usable # of rfn slots
 *
 *	ENTRY: crfn - desired # of rfn slots
 *	EXIT:  (global) rfnMac - set to crfn, if possible
 *
 *	The ability to adjust the usable # of rfn slots is a new addition in
 *	Windows Word.  The two things that it accomplishes are:
 *
 *			(1) Gives the ability for Word to scale back its need for
 *				DOS file handles if not enough are available
 *			(2) Permits Word to attempt to grab more file handles than usual
 *				when this would help performance (in particular, during
 *				Transfer Save, when the original, scratch, and write files
 *				are most commonly open)
 *
 */

SetRfnMac( crfn )
int crfn;
{
 int rfn;

 Assert( (crfn > 0) && (crfn <= rfnMax) );
 Assert( (sizeof (struct ERFN) & 1) == 0);	/* ERFN must be even for blt */

 if (crfn > rfnMac)
	{	/* Add rfn slots */

	for ( rfn = rfnMac; rfn < crfn; rfn++ )
		dnrfn [rfn].fn = fnNil;		/* These will get used next (see RfnGrab)*/
	rfnMac = crfn;
	}

 else	/* Lose Rfn slots (keep the most recently used one(s)) */
	while ( rfnMac > crfn )
		{
		int rfnLru=RfnGrab();
		int fn;

		if ( (rfnLru != --rfnMac) && ((fn = dnrfn [rfnMac].fn) != fnNil) )
			{
			extern int fnMac;

			Assert( fn >= 0 && fn < fnMac );
			(**hpfnfcb) [fn].rfn = rfnLru;
			blt( &dnrfn [rfnMac], &dnrfn [rfnLru],
                                     sizeof(struct ERFN)/sizeof(int) );
			}
		}
}





/*========================================================*/
STATIC int near RfnGrab()
{ /*
		Description:	Allocate the least recently used rfn (real file #)
						slot for a new file.
		Returns:		rfn slot number. */

 int rfn = 0, rfnLru = 0;
 typeTS ts, tsLru;
 struct ERFN *perfn = &dnrfn[rfn];

 /* Time stamp algorithm akin to method used with Bps. */
 /* See IbpLru in file.c for comments. */

 tsLru = -1;     /* max unsigned number */
 for ( rfn = 0; rfn < rfnMac ; rfn++, perfn++ )
	{
	ts = perfn->ts - (tsMruRfn + 1);
	if (perfn->fn == fnNil)
		ts = ts - rfnMac;

		/* cluge: If slot is unused, give it a lower ts. */
		/* This ensures that an occupied slot can never be */
		/* swapped out if a empty one exists. */
	if (ts <= tsLru)
		{
		tsLru = ts;
		rfnLru = rfn;
		}
	}

 if (dnrfn [rfnLru].fn != fnNil)
	CloseRfn( rfnLru );
 return rfnLru;
}




CloseFn( fn )
int fn;
{	/* Close file fn if it is currently open */
 int rfn;

 if (fn == fnNil)
	return;

 if (((rfn = (**hpfnfcb)[fn].rfn) != rfnNil) && (rfn != rfnFree))
	CloseRfn( rfn );
}




OpenEveryHardFn()
{	/* For each fn representing a file on nonremoveable media,
       try to open it.	It is not guaranteed that any or all such files
       will be open on return from this routine -- we are merely attempting
       to assert our ownership of these files on a network by keeping them open */

 extern int fnMac;
 int fn;
 struct FCB *pfcb;

#ifdef DFILE
extern int docCur;
CommSzNum("OpenEveryHardFn: docCur ", docCur);
#endif

 for ( fn = 0, pfcb = &(**hpfnfcb) [0] ; fn < fnMac; fn++, pfcb++ )
	{
/* Bryanl 3/26/87: only call FAccessFn if rfn == rfnNil, to prevent
   multiple opens of the same file, which fail if the sharer is loaded */
#ifdef DFILE
	{
	char rgch[100];
	if (pfcb->rfn == rfnNil && ((POFSTRUCT)(pfcb->rgbOpenFileBuf))->fFixedDisk)
		{
		wsprintf(rgch,"					fn %d, hszFile %s \n\r",fn,(LPSTR)(**pfcb->hszFile));
		CommSz(rgch);
		wsprintf(rgch,"                        OFSTR   %s \n\r", (LPSTR)(((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName));
		CommSz(rgch);
		}
	else
		{
		wsprintf(rgch,"					fn %d, not accessing, sz %s\n\r", fn, (LPSTR) (LPSTR)(**pfcb->hszFile));
		CommSz(rgch);
		wsprintf(rgch,"                        OFSTR   %s \n\r", (LPSTR)(((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName));
		CommSz(rgch);
		}
	}
#endif
	if (pfcb->rfn == rfnNil && ((POFSTRUCT)(pfcb->rgbOpenFileBuf))->fFixedDisk)
		{	/* fn refers to a file on nonremoveable media */
		FAccessFn( fn, dtyNormal );
		}
	}
}




STATIC typeOSFN near OsfnReopenFn( fn )
int fn;
{	/* Reopen file fn after it was automatically closed by Windows due
       to disk swap. State is: fn has an rfn but rfn's osfn has been
       made a "bad handle" */

 struct FCB *pfcb = &(**hpfnfcb) [fn];
 int rfn = pfcb->rfn;
 typeOSFN osfn;
 WORD wOpen;

 Assert( fn != fnNil );
 Assert( rfn != rfnNil );
 Assert( pfcb->fOpened);

	/* Only files on floppies are automatically closed */
 Assert( ! ((POFSTRUCT)(pfcb->rgbOpenFileBuf))->fFixedDisk );

#ifdef DEBUG
#ifdef DFILE
 CommSzSz( "Opening after WINDOWS close: ", **pfcb->hszFile );
#endif
#endif

 wOpen = OF_REOPEN | OF_PROMPT | OF_CANCEL | OF_SHARE_DENY_WRITE |
              ((pfcb->mdFile == mdBinary) ? OF_READWRITE : OF_READ );

 SetErrorMode(1);
 osfn = OpenFile( (LPSTR) SzPromptFromFn( fn ),
                  (LPOFSTRUCT) pfcb->rgbOpenFileBuf, wOpen );
 SetErrorMode(0);

 if (osfn == -1)
	return osfnNil;
 else
	{
	dnrfn[ rfn ].osfn = osfn;
	}
 return osfn;
}




FAccessFn( fn, dty)
int fn;
int  dty;
{ /*	Description:	Access file which is not currently opened.
						Open file and make an appropriate entry in the
						rfn table.	Put the rfn into (**hpfnfcb)[fn].rfn.
		Returns:		TRUE on success, FALSE on failure
  */
extern int vwDosVersion;
extern HANDLE hParentWw;
extern HWND vhWndMsgBoxParent;

int rfn;
register struct FCB *pfcb = &(**hpfnfcb)[fn];
typeOSFN osfn;
int wOpen;

#ifdef DEBUG
int junk;

 Assert(FValidFile(**pfcb->hszFile, CchSz(**pfcb->hszFile)-1, &junk));

#ifdef DFILE
 {
 char rgch[100];

 CommSzSz("FAccessFn: ", pfcb->fOpened ? SzPromptFromFn( fn ) : &(**pfcb->hszFile)[0]);
 wsprintf(rgch, "  * OFSTR before %s \n\r", (LPSTR)(((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName));
 CommSz(rgch);
 }
#endif
#endif /*DEBUG*/

 if ((**pfcb->hszFile)[0] == 0)  /* if file name field is blank, */
	return FALSE;			/* unable to open file */

 wOpen = /*OF_PROMPT + OF_CANCEL + (6.21.91) v-dougk bug #6910 */
						(((pfcb->mdFile == mdBinary) ? 
							OF_READWRITE : OF_READ) | 
								OF_SHARE_DENY_WRITE);
 if (pfcb->fOpened)
	wOpen += OF_REOPEN;
 else if (pfcb->fSearchPath)
	wOpen += OF_VERIFY;

 if ((vwDosVersion & 0x7F) >= 2)
	{
	WORD da;

	if ((vwDosVersion & 0x7F) >= 3)
			/* Above DOS 3, set attributes to deny access if the sharer is in */
		wOpen += bSHARE_DENYRDWR;

	if ( ( (pfcb->mdFile == mdBinary) && (!pfcb->fOpened)) &&
         ((da = DaGetFileModeSz( &(**pfcb->hszFile) [0] )) != DA_NIL) &&
         (da & DA_READONLY) )
		{	/* This is here because the Novell net does not allow us to test
               for read-only files by opening in read/write mode -- it lets
               us open them anyway! */
		goto TryReadOnly;
		}
	}

 for ( ;; )
	{
			/* OpenFile's first parm is a filename when opening for the
               first time, a prompt on successive occasions (OF_REOPEN) */

	SetErrorMode(1);
	osfn = OpenFile( pfcb->fOpened ?
                           (LPSTR) SzPromptFromFn( fn ) :
                           (LPSTR) &(**pfcb->hszFile)[0],
                     (LPOFSTRUCT) &pfcb->rgbOpenFileBuf[0],
                     wOpen );
	SetErrorMode(0);

	if (osfn != -1)		/* Note != -1: osfn is unsigned */
		{    /* Opened file OK */
#ifdef DFILE		
		{
		char rgch[100];
		wsprintf(rgch, "  * OFSTR now  %s \n\r", (LPSTR)(((POFSTRUCT)(**hpfnfcb) [fn].rgbOpenFileBuf)->szPathName));
		CommSz(rgch);
		}
#endif

		if (!pfcb->fOpened)
			{	/* First time through: OpenFile may have given us a
                   different name for the file */

			CHAR szT [cchMaxFile];
			CHAR (**hsz) [];

#if WINVER >= 0x300            
			/* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                                      *RETURNS*  an ANSI sz ..pault */
#endif

			if (FNormSzFile( szT, ((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName,
                             dty ) &&
                       WCompSz( szT, &(**pfcb->hszFile) [0] ) != 0 &&
                       FnFromSz( szT ) == fnNil &&
                       !FNoHeap( hsz = HszCreate( szT )))
				{
					/* Yes, indeed, the name OpenFile gave us was different.
                       Put the normalized version into the fcb entry */

				FreeH( (**hpfnfcb) [fn].hszFile );	/* HEAP MOVEMENT */
				(**hpfnfcb) [fn].hszFile = hsz;
				}
			}
		break;	/* We succeeded; break out of the loop */
		}
	else
		{	/* Open failed -- try read-only; don't prompt this time */
		if ( (pfcb->mdFile == mdBinary) && (!pfcb->fOpened) )
			{	/* Failed as read/write; try read-only */

			/* Check for sharing violation */

			if (((vwDosVersion & 0x7F) >= 3) &&
				(((POFSTRUCT) pfcb->rgbOpenFileBuf)->nErrCode == nErrNoAcc))
				{
				if ( DosxError() == dosxSharing )
                  {
                  extern int vfInitializing;
                  int fT = vfInitializing;

                  vfInitializing = FALSE;	/* Report this err, even during inz */
				{
					char szMsg[cchMaxSz];
					MergeStrings (IDPMTCantShare, **pfcb->hszFile, szMsg);
					IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw, szMsg, MB_OK|MB_ICONEXCLAMATION);
				}
                  vfInitializing = fT;
                  return FALSE;
                  }
				}

TryReadOnly:
			pfcb->mdFile = mdBinRO;
			wOpen = OF_READ;
			if (pfcb->fOpened)
				wOpen += OF_REOPEN;
#ifdef ENABLE
			else if (pfcb->fSearchPath)
               wOpen += OF_VERIFY;
#endif
			}
		else
			{
				if ((**hpfnfcb)[fn].fDisableRead)
				/* already reported */
				{
					ferror = TRUE;
					return FALSE;
				}
				else
				{	/* Could not find file in place specified */
				char szMsg[cchMaxSz];
				extern int ferror;
				extern int vfInitializing;
				int fT = vfInitializing;
				BOOL bRetry=TRUE;
				extern struct DOD      (**hpdocdod)[];
				extern int         docCur;

				/* get user to put file back */
				MergeStrings (IDPMTFileNotFound, **pfcb->hszFile, szMsg);

				vfInitializing = FALSE;   /* Report this err, even during inz */

				/* 
					This is frippin insidious.	MessageBox yields and allows us to get
					into here again before it has even been issued!
				*/

				(**hpdocdod)[docCur].fDisplayable = FALSE; // block redraws

				/* if we're being called from a message box, then use it
                   as the parent window, otherwise use main write window */
				if (IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw, 
                              szMsg, MB_OKCANCEL | MB_ICONEXCLAMATION | MB_APPLMODAL)
                      == IDCANCEL)
				{
					vfInitializing = fT;
					(**hpfnfcb)[fn].fDisableRead = TRUE;
					ferror = TRUE; /* need to flag */
					bRetry = FALSE;
				}

				(**hpdocdod)[docCur].fDisplayable = TRUE; // unblock redraws

				vfInitializing = fT;

				if (!bRetry)
					return FALSE;
				}
			}
		}
	}

 pfcb->fOpened = TRUE;

 rfn = RfnGrab();
 {
 struct ERFN *perfn = &dnrfn [rfn];

 perfn->osfn = osfn;
 perfn->fn   =	fn;
 perfn->ts   = ++tsMruRfn;     /* mark Rfn as MRused */
 }
 (**hpfnfcb) [fn].rfn = rfn;
 (**hpfnfcb) [fn].fDisableRead = FALSE;
 return TRUE;
}



FCreateFile( szFile, fn )	/* returns szFile in ANSI ..pault */
CHAR *szFile;
int fn;
{		/*	Create a new, unique file.
			Return the name in szFile.
			Returns TRUE on success, FALSE on failure.
			Leaves the filename in (**hpfnfcb)[fn].hszFile (if successful),
			the rfn in (**hpfnfcb)[fn].rfn.
			If szFile begins "X:...", creates the file on the specified drive;
			otherwise, creates the file on a drive of Windows' choice */

	extern CHAR szExtDoc[];
	CHAR (**hsz)[];
	CHAR szFileT [cchMaxFile];

	if (!GetTempFileName(szFile[0] | ((szFile[1] == ':') ? TF_FORCEDRIVE : 0),
                         (LPSTR)(szExtDoc+1), 0, (LPSTR)szFileT) )
		{    /* can't create file */
		DiskErrorWithMsg( IDPMTSDE, " RfnCreate" );

		/* recovery is accomplished: only FnCreateSz calls FCreateFile.
           FnCreateSz returns nil if FCreateFile returns FALSE.  All of
               FnCreateSz's callers check for nil */
		return FALSE;

		}

	/* Succeeded in creating file */

	FNormSzFile( szFile, szFileT, dtyNormal );

	if ( FNoHeap( hsz = HszCreate( (PCH)szFile )))
		return FALSE;

	(**hpfnfcb) [fn].hszFile = hsz;

	if ( !FAccessFn( fn, dtyNormal ) )
		return FALSE;

	return TRUE;
} /* end of  F C r e a t e F i l e	*/



FEnsureOnLineFn( fn )
int fn;
{		/* Ensure that file fn is on line (i.e. on a disk that is accessible).
           Return TRUE if we were able to guarantee this, FALSE if not */
 int rfn;

 Assert( fn != fnNil );

 if ( ((POFSTRUCT)(**hpfnfcb) [fn].rgbOpenFileBuf)->fFixedDisk )
		/* If it's on nonremovable media, we know it's on line */
	return TRUE;

 /* If it's open, must close and re-open, cause windows might have closed it */
 if ((rfn = (**hpfnfcb) [fn].rfn) != rfnNil)
	CloseRfn( rfn );

 return FAccessFn( fn, dtyNormal );
}




typePN PnAlloc(fn)
int fn;
{ /* Allocate the next page of file fn */
		typePN pn;
		struct BPS *pbps;
		struct FCB *pfcb = &(**hpfnfcb)[fn];

		AlignFn(fn, (int)cfcPage, false);
		pn = pfcb->fcMac / cfcPage;
		pbps = &mpibpbps[IbpEnsureValid(fn, pn)];
		pbps->cch = cfcPage;
		pbps->fDirty = true;
		pfcb->fcMac += cfcPage;
		pfcb->pnMac = pn + 1;
		return pn;
}




STATIC CHAR  *(near SzPromptFromFn( fn ))
int fn;
{
 extern int vfnSaving;
 CHAR *pch;

 Assert( fn != fnNil );

 if (fn == vfnSaving)
	pch = szSaveFilePrompt;
 else if (fn == fnScratch)
	pch = szScratchFilePrompt;
 else
	pch = szWriteDocPrompt;

 return pch;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fileutil.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fileutil.c -- WRITE file-related utilities */
#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "str.h"
#include "machdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "debug.h"
#include "editdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"



/***        FNormSzFile - Normalize MSDOS filename
 *
 *  Converts a MSDOS filename into an unambiguous representation
 *
 *  ENTRY:  szFile - a filename; drive, path, and extension
 *           are optional
 *      dty - the type of the document file (used to determine
 *            extensions)
 *  EXIT:   szNormal - A normalized filename
 *  RETURNS: FALSE - Errors found in filename     (szNormal left undefined)
 *       TRUE  - No errors found in filename  ( but there may be some
 *                          that we didn't find )
 *
 *  The form of the filename on entry is:
 *
 *  { <drive-letter>: }{ <amb-path> }<filename>{.<extension>}
 *
 *  The form of the normalized filename is:
 *
 *  <drive-letter>:<unamb-path><filename>.<extension>
 *
 *  Where all alphabetics in the normalized name are in upper case
 *  and <unamb-path> contains no "." or ".." uses nor any forward
 *  slashes.
 *
 *  All attributes required in the normalized filename and not
 *  provided in the szFile are taken from the defaults:
 *      drive - current (DOS)
 *      path - current (DOS)
 *      extension - derived from the passed dty
 *
 *  It is permissible to call this routine with szFile containing a path
 *  name instead of a filename.  The resulting szNormal will be backslash
 *  terminated if szFile was, not if szFile was not.
 *  "" is converted into the current path
 *
 *  WARNING:  The paths "." and ".." will produce errors
 *        (but ".\" and "..\" are OK)
 *
 ******
 *NOTE*   szFile is expected in OEM; szNormal is returned as ANSI!
 ******
 *
 */

FNormSzFile( szNormal, szFile, dty )
CHAR *szNormal;
CHAR *szFile;
int  dty;
{
/* Treat separators like terminators */

#define FIsTermCh( ch )     ((ch) == '\0' || (ch) == ',' || (ch == ' ') || \
                 (ch) == '+' || (ch) == '\011')
extern CHAR *mpdtyszExt [];

 CHAR szPath [cchMaxFile];
 CHAR szFileT[cchMaxFile];

 int  cchPath;
 CHAR *pchFileEye=&szFileT[0];      /* We read szFile with the Eye */
 CHAR *pchNormPen;          /* and write szNormal with the Pen */
 CHAR *pchNormPath;
 CHAR *pchPath;

/* Assert( CchSz( szFile ) <= cchMaxFile );*/
 if (CchSz(szFile) > cchMaxFile)
     return(FALSE);

#if WINVER >= 0x300
 /* Convert input filename, which is passed in OEM,
    to ANSI so entire return pathname will be ANSI */
 OemToAnsi((LPSTR) szFile, (LPSTR) szFileT);
#endif

#ifdef DBCS
    /* Get current (DOS) path: "X:\...\...\" */
 if( IsDBCSLeadByte(*szFileT) )
     cchPath = CchCurSzPath(szPath, 0 );
 else
     cchPath = CchCurSzPath(szPath, szFileT [1]==':' ?
                     (pchFileEye+=2,(ChUpper(szFileT [0])-('A'-1))):0 );
 if( cchPath < 3 )
#else
    /* Get current (DOS) path: "X:\...\...\" */
 if ((cchPath = CchCurSzPath(&szPath [0], szFileT [1]==':' ?
                     (pchFileEye+=2,(ChUpper(szFileT [0])-('A'-1))):0 )) < 3)
#endif
    {   /* Hardcore error -- could not get path */
    extern int ferror;

    if (FpeFromCchDisk(cchPath) == fpeNoDriveError)
    Error( IDPMTNoPath );

    ferror = TRUE;  /* Windows already reported this one */
    return FALSE;
    }

#ifdef DBCS //T-HIROYN 1992.07.14
/* CchCurSzPath() [doslib.asm] don't support DBCS code */
    {
        char *pchDb;
        char *pch;
        pchDb = szPath;
        do {
            pch = pchDb;
            pchDb = AnsiNext(pchDb);
        } while(*pchDb);
        if(*pch != '\\') {
            *pchDb++ = '\\';
            *pchDb = 0x00;
            cchPath++;
        }
    }
#endif

#if WINVER >= 0x300
 {
 CHAR szT[cchMaxFile];

 /* CchCurSzPath returns OEM; we should only be dealing
    with ANSI filenames at this level! ..pault 1/11/90 */

 bltsz(szPath, szT);
 OemToAnsi((LPSTR) szT, (LPSTR) szPath);
 }
#endif

    /* Write Drive Letter and colon */
 CopyChUpper( &szPath [0], &szNormal [0], 2 );

 pchNormPen = pchNormPath = &szNormal [2];
 pchPath = &szPath [2];
 cchPath -= 2;

 /* Now we have pchNormPen, pchPath, pchFileEye pointing at their path names */

    /* Write path name */
 if ( (*pchFileEye == '\\') || (*pchFileEye =='/') )
    {   /* "\....." -- basis is root */
    *pchFileEye++;
    *(pchNormPen++) = '\\';
    }
 else
    {   /* ".\" OR "..\" OR <text> -- basis is current path */
    CopyChUpper( pchPath, pchNormPen, cchPath );
    pchNormPen += cchPath - 1;
    }

  for ( ;; )
    {       /* Loop until we have built the whole szNormal */
    register CHAR ch=*(pchFileEye++);
    register int  cch;

    Assert( *(pchNormPen - 1) == '\\' );
    Assert( (pchNormPen > pchNormPath) &&
                  (pchNormPen <= &szNormal [cchMaxFile]));

    if ( FIsTermCh( ch ) )
        /* We get here if there is no filename portion  */
        /* This means we have produced a path name */
    {
    *pchNormPen = '\0';
    break;
    }

    if ( ch == '.' )
    if ( ((ch = *(pchFileEye++)) == '\\') || (ch == '/') )
        /* .\ and ./ do nothing */
        continue;
    else if ( ch == '.' )
        if ( ((ch = *(pchFileEye++)) == '\\') || (ch == '/') )
        {   /* ..\ and ../ back up by one directory */
        for ( pchNormPen-- ; *(pchNormPen-1) != '\\' ; pchNormPen-- )
            if ( pchNormPen <= pchNormPath )
                /* Can't back up, already at root */
            return FALSE;
        continue;
        }
        else
            /* ERROR: .. not followed by slash */
        return FALSE;
    else
        /* Legal file and path names do not begin with periods */
        return FALSE;

    /* Filename or Path -- copy ONE directory or file name */

    for ( cch = 1; !FIsTermCh(ch) && ( ch != '\\') && ( ch != '/' ) ; cch++ )
#ifdef  DBCS
    {
    if(IsDBCSLeadByte(ch))
    {
        pchFileEye++;
        cch++;
    }
    ch = *(pchFileEye++);
    }
#else
    ch = *(pchFileEye++);
#endif

    /* Check if filename too long or if full pathname will be too long ..pt */
    if ( cch > cchMaxLeaf || cch+cchPath >= cchMaxFile)
        /* Directory or file name too long */
    return FALSE;

    CopyChUpper( pchFileEye - cch, pchNormPen, cch );
    pchNormPen += cch;
    if ( ch == '/' )
    *(pchNormPen-1) = '\\';
    else if ( FIsTermCh( ch ) )
    {    /* Filename looks good, add extension & exit */
    *(pchNormPen-1) = '\0';

    /* kludge alert: if dtyNormNoExt then don't add extension unless 
        there's one already there to be overwritten. (6.21.91) v-dougk */
    if ((dty != dtyNormNoExt) ||
         index(szNormal,'.'))
            AppendSzExt( &szNormal [0],
                mpdtyszExt [ (dty == dtyNormNoExt) ? dtyNormal : dty ],
                FALSE );
    break;
    }
    }   /* Endfor (loop to build szNormal) */

 /* If there is anything but whitespace after the filename, then it is illegal */

 pchFileEye--;  /* Point at the terminator */
 Assert( FIsTermCh( *pchFileEye ));

 for ( ;; )
    {
#ifdef DBCS
    CHAR ch = *(pchFileEye=AnsiNext(pchFileEye));
#else
    CHAR ch = *(pchFileEye++);
#endif

    if (ch == '\0')
    break;
    else if ((ch != ' ') && (ch != '\011'))
        /* Non-whitespace after filename; return failure */
    return FALSE;
    }

 Assert( CchSz(szNormal) <= cchMaxFile );
 return TRUE;
}



/* Parses the cch chars stored in rgch.  Returns true if string is a valid
filename.  If the string is not a valid name, pichError is updated to have
ich of first illegal Char in the name. */
/* NOTE: this routine is tuned for ASCII on MS-DOS */

BOOL
FValidFile(rgch, ichMax, pichError)     /* filename presumed to be ANSI */
register char rgch[];
int ichMax;
int *pichError;
    {
    int ich;
    register int ichStart;
    CHAR ch;
    int cchBase;
    int ichDot = iNil;

    for (ichStart = 0; ichStart < ichMax;)
    {
    /* Does the file name begin with ".\" or "..\"? */
    if (rgch[ichStart] == '.' &&
      (rgch[ichStart + 1] == '\\' || rgch[ichStart + 1] == '/'))
        {
        ichStart += 2;
        }
    else if (rgch[ichStart] == '.' && rgch[ichStart + 1] == '.' &&
      (rgch[ichStart + 2] == '\\' || rgch[ichStart + 2] == '/'))
        {
        ichStart += 3;
        }
    else
        {
        break;
        }
    }

    cchBase = ichStart;

    if (ichStart >= ichMax)
        {
        ich = ichStart;
        goto badchar;
        }

    /* Are all characters legal? */
    for(ich = ichStart; ich < ichMax; ich++)
    {
    ch = rgch[ich];
    /* range check */

#ifndef DBCS
    if ((unsigned char)ch >= 0x80)
        /* To allow international filenames, pass everything above 128 */
        continue;
    if (ch < '!' || ch > '~')
        goto badchar;
#endif
    switch(ch)
        {
        default:
#ifdef  DBCS
        goto CheckDBCS;
#else
        continue;
#endif
        case '.':
        if (ichDot != iNil || ich == cchBase)
            /* More than  one dot in the name */
            /* Or null filename */
            goto badchar;
        ichDot = ich;
#ifdef DBCS
        goto CheckDBCS;
#else
        continue;
#endif
        case ':':
        if ( ich != 1 || !(isalpha(rgch[0])))
            goto badchar;
        /* fall through */
        case '\\':
        case '/':
        /* note end of the drive or path */
        if (ich + 1 == ichMax)
            goto badchar;
        cchBase = ich+1;
        ichDot = iNil;
#ifdef DBCS
        goto CheckDBCS;
#else
        continue;
#endif
        case '"':
#ifdef WRONG
        /* This IS a legal filename char! ..pault 10/26/89 */
        case '#':
#endif
        case '*':
        case '+':
        case ',':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
        case '[':
        case ']':
        case '|':
        goto badchar;
        }
#ifdef DBCS
CheckDBCS:
    if(IsDBCSLeadByte(ch))  ich++;
#endif  /* DBCS */
    }

    /* Are there no more than eight chars before the '.'? */
    if(((ichDot == -1) ? ichMax : ichDot) - cchBase > 8)
        {
        ich = 8+cchBase;
        goto badchar;
        }
    /* If there is no '.' we are fine */
    if(ichDot == iNil)
        return true;
    /* Are there no more than three chars after the '.'? */
    if(ichMax - ichDot - 1 > 3)
        {
        ich = ichDot + 3 + 1;
        goto badchar;
        }
    return true;

badchar:
    *pichError += ich;
    return false;
    }







#ifdef DBCS
CopyChUpper( szSource, szDest, cch )
register CHAR *szSource;
register CHAR *szDest;
int cch;
{
 while(cch){
    if( IsDBCSLeadByte( *szSource ) ){
        *szDest++ = *szSource++;
        *szDest++ = *szSource++;
        cch--;
    } else
        *szDest++ = ChUpper( *szSource++ );
    cch--;
 }
}
#else
CopyChUpper( szSource, szDest, cch )
CHAR *szSource;
CHAR *szDest;
register int cch;
{
 register CHAR ch;

 while (cch--)
    {
    ch = *(szSource++);
    *(szDest++) = ChUpper( ch );
    }
}
#endif


/***        AppendSzExt - append extension to filename
 *
 *  Append extension (assumed to contain the ".") to passed filename.
 *  Assumes call allocated enough string space for the append
 *  if fOverride is TRUE, overrides any existing extension
 *  if fOverride is FALSE, appends extension only if szFile has
 *      no current extension
 */

AppendSzExt( szFile, szExt, fOverride )
CHAR *szFile;
CHAR *szExt;
int fOverride;
{
#define cchMaxExt   3
 CHAR *pch=NULL;
 int cch;
 register int cchT;
 register int chT;

 /* pch <-- pointer to the '.' for szFile's extension (if any) */
 cch = cchT = CchSz( szFile ) - 1;
 while (--cchT > cch - (cchMaxExt + 2))
    if ((chT=szFile[ cchT ]) == '.')
    {
    pch = &szFile[ cchT ];
    break;
    }
    else if ((chT == '\\') || (chT == '/'))
        /* Catches the weird case: szFile == "C:\X.Y\J" */
    break;

 if (pch == NULL)
    /* No explicit extension: APPEND */
    CchCopySz( szExt, szFile + CchSz( szFile ) - 1 );

 else if ( fOverride )
    /* Override explicit extension */
    CchCopySz( szExt, pch );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fkpdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fkpdefs.h -- mw formatted disk page definitions */
/* #include filedefs.h, propdefs.h first */


#define ifcMacInit      10

#define cbFkp           (cbSector - sizeof (typeFC) - 1)

#define cchMaxGrpfsprm  cbSector
#define cchMaxFsprm     2

struct FKP
	{ /* Formatted disK Page */
	typeFC  fcFirst;        /* First fc which has formatting info here */
	CHAR    rgb[cbFkp];
	CHAR    crun;
	};


struct RUN
	{ /* Char or para run descriptor */
	typeFC  fcLim;  /* last fc of run */
	int     b; /* Byte offset from page start; if -1, standard props */
	};

#define cchRUN  (sizeof (struct RUN))
#define bfcRUN  0

struct FCHP
	{ /* File CHaracter Properties */
	CHAR    cch;    /* Number of bytes stored in chp (rest are vchpStd) */
			/* Must not be 0. */
	CHAR    rgchChp[sizeof (struct CHP)];
	};


struct FPAP
	{ /* File ParagrAph Properties */
	CHAR    cch;    /* Number of bytes stored in pap (rest are vpapStd) */
			/* Must not be 0. */
	CHAR    rgchPap[sizeof (struct PAP)];
	};



struct FPRM
	{ /* File PropeRty Modifiers (stored in scratch file) */
	CHAR    cch;
	CHAR    grpfsprm[cchMaxGrpfsprm + cchMaxFsprm]; /* + for overflow */
	};


struct FKPD
	{ /* FKP Descriptor (used for maintaining insert properties) */
	int     brun;   /* offset to next run to add */
	int     bchFprop;       /* offset to byte after last unused byte */
	typePN  pn;     /* pn of working FKP in scratch file */
	struct BTE (**hgbte)[]; /* pointer to bin table */
	int     ibteMac;        /* Number of bin table entries */
	};


struct BTE
	{ /* Bin Table Entry */
	typeFC          fcLim;
	typePN          pn;
	};
#define cwBTE (sizeof(struct BTE)/sizeof(int))

struct FND
	{ /* Footnote descriptor */
	typeCP          cpRef;          /* Or fcRef (cp of ftn reference) */
	typeCP          cpFtn;          /* Or fc... (first cp of text) */
	};

#define cchFND  (sizeof (struct FND))
#define cwFND   (cchFND / sizeof (int))
#define bcpRefFND       0
#define bcpFtnFND       (sizeof (typeCP))
#define cwFNTBBase      2
#define ifndMaxFile     ((cbSector - cwFNTBBase * sizeof (int)) / cchFND)

struct FNTB
	{ /* Footnote table */
	int             cfnd;   /* Number of entries (sorted ascending) */
	int             cfndMax; /* Heap space allocated */
	struct FND      rgfnd[ifndMaxFile]; /* Size varies */
	};



struct FNTB **HfntbEnsure(), **HfntbGet();

#define HsetbGet(doc) ((**hpdocdod)[doc].hsetb)

struct SED
	{ /* Section descriptor */
	typeCP          cp;
	int             fn;
	typeFC          fc;
	};

#define cchSED  (sizeof (struct SED))
#define cwSED   (cchSED / sizeof (int))
#define bcpSED          0
#define cwSETBBase      2
#define isedMaxFile     ((cbSector - cwSETBBase * sizeof (int)) / cchSED)


struct SETB
	{ /* Section table */
	int             csed;
	int             csedMax;
	struct SED      rgsed[isedMaxFile]; /* Size varies */
	};


struct SETB **HsetbCreate(), **HsetbEnsure();

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fontdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fontdefs.h -- MW definitions for fonts */

#ifdef PRDFILES
struct PRDD
        { /* printer description file descriptor */
        int     cfcdMac,        /* count of fonts defined for this printer */
                cxInch,         /* pixels per inch, horizontal */
                dyaMin,         /*    "       "      "      "     y   "    */
                pid,            /* printer identification number */
                pe,             /* print element */
                fNoMSJ,         /* microspace justification flag */
                fSpecial,       /* special flags */
                pn,             /* serial interface word */
                bfcdBase,       /* byte address of start of FCDs */
                cttBase,        /* byte address of start of CTT  */
                bpcdBase,       /* byte address of start of PCDs */
                bpcsBase,       /* byte address of start of PCSs */
                bprdMax;        /* end of PRD file */

        CHAR    (**hrgbprdf)[]; /* block that contains the FCDs and WTs */
        int     (**hmpiftcfcd)[]; /* double entry table: consists of 2 word
                                   entries, 1st is the font code of this font,
                                   2nd is heap offset to FCD for this font.
                                   There are exactly cfcdMac sets of these */
        CHAR    (**hrgbctt)[];  /* character translation table */
        CHAR    (**hprcc)[];    /* printer control sequences */
/*      CHAR    szFile[cchMaxFile]; /* file name for printer desc. file */
        };

#define cchPRDDFile     26
#define cwPRDD  (sizeof (struct PRDD) / sizeof(int))

/* prd file byte offsets */
#define bPrdData1 (typeFC)64
#define bPrdData2 (typeFC)128

#define cpsMax          10
#define dxaDefault ((unsigned) 144)

#ifdef SAND
#define wpcPica         0       /* Daisy wheel pitch codes */
#define wpcElite        1
#define wpcMicron       2
#define wpcProportional 3

#define wpPica          10      /* Pitches */
#define wpElite         12
#define wpMicron        15
#define wpProportional  10      /* Bogus */

#define psPica          12      /* point Sizes */
#define psElite         10
#define psMicron        8
#define psProportional  12      /* Bogus */

#define convWpPs        120     /* conversion between wheel pitch and
                                   Point Size */

/* IMPORTANT-- the following font codes (20, 21, 22, 23) random numbers
   we will have to be assigned permanent font codes by Apple */

#define ftcPrintFONT    20
#define ftcPrintFWID    21
#define ftcPrintPSFONT  22
#define ftcPrintPSFWID  23
#endif /* SAND */

struct FAD
        {               /* Font Address Descriptor              */
        unsigned wtp;   /* multi purpose word                   */
        };

struct PCSD1
        { /* printer control sequence descriptor */
        int     bprcc;  /* byte offset of start of control sequence */
        CHAR    bMod;   /* modification byte */
        CHAR    cch;    /* length of control sequence */
        };

#define cwPCSD1  (sizeof(struct PCSD1) / sizeof(int))

struct PSD
        {               /* Printer Size Descriptor              */
        int     hps;    /* size available in half points        */
        struct FAD      fad,
                        fadI,
                        fadB,
                        fadIB;
        struct PCSD1    pcsdBegin,
                        pcsdEnd;
        };

struct FCD
        {               /* Font Code Description                */
        int     ctp;    /* character translation table pointer (a la wtp) */
        int     cpsd;   /* count of sizes available             */
        struct PSD      rgpsd[cpsMax];  /* psds for each size available */
        CHAR            rgchFntName[32];/* font name (null terminated)  */
        };

#define pnfSerial       0100000
#define pnfETX          040000
#define pnfXON          020000

#define MSJ_fNone       1
#define MSJ_fChars      2
#define MSJ_fPSCorrect  4

#define SPC_fNoBSCtt    1

#ifdef GENERIC_MSDOS
#ifdef HP150
#define cPortMac        3
#define cchPort         4
#else /* not HP150 */
#define cPortMac        2
#define cchPort         4
#endif /* not HP150 */
#else /* not GENERIC_MSDOS */
#define cPortMac        5
#define cchPort         5
#endif /* GENERIC_MSDOS */

#define fntMax 6

struct PCSD
        { /* printer control sequence descriptor */
        int     bprcc;  /* byte offset of start of control sequence */
        CHAR    bMod;   /* modification byte */
        CHAR    cch;    /* length of control sequence */
        CHAR    bMagic; /* magic number */
        CHAR    bMax;   /* max value of parameter */
        };
#endif /* PRDFILES */

#define hpsMin 8
#define hpsMax 256
#define cchFontSize 4
#define iszSizeMax 32
#define iffnEnumMax 64
#define psFontMin 4
#define psFontMax 127

/* macros used to get/put pitch and font family info in windows data structs */
#define bitPitch        0x01
#define grpbitFamily    0xf0

typedef CHAR FFID;      /* font family ID */

#define iftcRoman       0
#define iftcModern      1
#define iftcScript      2
#define iftcDecorative  3
#define iftcSwiss       4

#ifdef SYSENDMARK
#define ftcSystem 0x3E
#define bitFtcChp 0x3E
#endif /* KANJI */
#define ftcNil    255
#define cchFfnMin 1
#define chGhost '\003'

#define iffnProfMax 5   /* # of fonts described in win.ini list */

#define LocalFaceSize 32
#ifndef LF_FACESIZE
/* this is gross, but so's our compiler! */
#define LF_FACESIZE LocalFaceSize
#endif

#ifdef NEWFONTENUM
#define ibFfnMax (LF_FACESIZE + sizeof(FFID) + sizeof(BYTE) + 1 /* to make it a max */)
#else
#define ibFfnMax (LF_FACESIZE + sizeof(FFID) + 1)
#endif
#define CbFfn(cch) (sizeof(struct FFN) - cchFfnMin + (cch))

/* Added 5/5/89: insure we only touch memory to which we're entitled ..pault */
#define CbFromPffn(pffn)    (sizeof(FFID)+sizeof(BYTE)+CchSz((pffn)->szFfn))

/* NOTE: If this structure is changed, CbFromPffn() above must be updated! */
typedef struct FFN      /* Font Family Name */
        {
#ifdef NEWFONTENUM
        BYTE chs;       /* The charset associated with this facename
                           (ANSI, OEM, Symbol, etc).  We've kludged the
                           way that FFN's are written out in documents
                           so see HffntbForNewDoc() ..pault */
#endif
        FFID ffid;
        /* really a variable length string */
        CHAR szFfn[cchFfnMin];
        };

/* 255 ffn's lets us map ftc's in a single byte, with one nil value */
#define iffnMax 255
#define cffnMin 1
typedef struct FFNTB    /* font table */
        {
        unsigned int iffnMac: 15;
        unsigned int fFontMenuValid: 1; /* Used for names on CHAR dropdown */
        struct FFN **mpftchffn[cffnMin];
        };

struct FFNTB **HffntbCreateForFn();
struct FFNTB **HffntbNewDoc();
struct FFNTB **HffntbAlloc();
struct FFN *PffnDefault();
#define HffntbGet(doc) ((**hpdocdod)[(doc)].hffntb)

/* following structures support font information caching */

#define fcidNil 0xffffffffL

typedef union FCID /* font cache identifier */
        {
        long lFcid;
        struct
                {
                unsigned ftc : 8;
                unsigned hps : 8;
                unsigned doc : 4;
                unsigned wFcid : 12;
                } strFcid;
        };

/* bits set in wFcid */
#define grpbitPsWidthFcid       0x007f
#define bitFixedPitchFcid       0x0080
#define bitUlineFcid            0x0100
#define bitBoldFcid             0x0200
#define bitItalicFcid           0x0400
#define bitPrintFcid            0x0800

#define psWidthMax              127

typedef struct FMI      /* font metric information */
        {
        int *mpchdxp;          /* pointer to width table */
                                /* NOTE - we actually point chDxpMin entries
                                          before the start of the table, so
                                          that the valid range begins at the
                                          start of the actual table */
        int dxpSpace;           /* width of a space */
        int dxpOverhang;        /* overhang for italic/bold chars */
        int dypAscent;          /* ascent */
        int dypDescent;         /* descent */
        int dypBaseline;        /* difference from top of cell to baseline */
        int dypLeading;         /* accent space plus recommended leading */
#ifdef DBCS
        int dypIntLeading;      /* internal leading */
#if defined(JAPAN) || defined(KOREA) || defined(TAIWAN) || defined(PRC)
        WORD dxpDBCS;           /* Win3.1 T-HIROYN change BYTE--> WORD*/
#else
        BYTE dxpDBCS;           /* width of a DBCS character. */
                                /* WARNING - This assumes a kanji character
                                             is fixed pitch. */
        BYTE bDummy;            /* To guarantee that this addition
                                   increases the amount by 1 word. */
#endif /* JAPAN */
#endif /* DBCS */
        };

#define chFmiMin 0x20
#ifdef WIN30
   /* Why are we not asking for widths of all characters?  We should. */
#ifdef  KOREA
#define chFmiMax 0x80
#elif defined(TAIWAN)
#define chFmiMax 0x80
#elif defined(PRC)
#define chFmiMax 0x80
#else
#define chFmiMax 0x100
#endif

#else
#define chFmiMax 0x80
#endif

#define dxpNil 0xFFFF

typedef struct FCE      /* font cache entry */
        {
        struct FCE *pfceNext;   /* next entry in lru list */
        struct FCE *pfcePrev;   /* prev entry in lru list */
        union FCID fcidRequest; /* request this entry satisfied */
        union FCID fcidActual;  /* what this entry really contains */
        struct FFN **hffn;      /* font family name */
        struct FMI fmi;         /* helpful metric information for this entry */
        HFONT hfont;            /* windows' font object */
        int rgdxp[chFmiMax - chFmiMin]; /* width table proper */
        };

#define ifceMax 16
struct FCE *PfceLruGet();
struct FCE *PfceFcidScan();

/* values to be passed to LoadFont() directing it's actions */
#define mdFontScreen 0          /* sets font for random screen chars */
#define mdFontChk 1             /* sets font as constrained by printer avail */
#define mdFontJam 2             /* like mdFontChk, but jams props into chp */
#define mdFontPrint 3           /* like mdFontScreen, but for the printer */

#ifdef SAND
typedef struct  {       /* structure of a Macintosh font. See Font Manager */
        int     frFontType;     /* fr was prepended to each element to     */
        int     frFirstChar;    /* prevent "name collision" with the       */
        int     frLastChar;     /* elements of FONTINFO                    */
        int     frWidMax;
        int     frKernMax;
        int     frNDescent;
        int     frFRectMax;
        int     frChHeight;
        int     frOwTLoc;
        int     frAscent;
        int     frDescent;
        int     frLeading;
        int     frRowWords;
        } FONTREC;

#define woFrOwTLoc 8 /* The word offset of the owTLoc from the beginning */
#define wdthTabFrOwTLoc 4       /* The frOwTLoc for a width table       */

typedef struct {
        int     family;
        int     size;
        int     face;
        int     needBits;
        int     device;
        POINT   numer;
        POINT   denom;
        } FMINPUT;

typedef struct {
        int     errNum;
        HANDLE  fontHandle;
        CHAR    bold;
        CHAR    italic;
        CHAR    ulOffset;
        CHAR    ulShadow;
        CHAR    ulThick;
        CHAR    shadow;
        CHAR    extra;
        CHAR    ascent;
        CHAR    descent;
        CHAR    widMax;
        CHAR    leading;
        CHAR    unused;
        POINT   numer;
        POINT   denom;
        } FMOUTPUT;

#define qFMOUTPUT ((FMOUTPUT far *) 0x998)
#endif /* SAND */

#define enumFaceNames 0
#define enumFindAspectRatio 1
#define enumSizeList 2
#define enumCheckFont 3
#define enumQuickFaces 4

#ifdef JAPAN
#define enumFaceNameJapan 128   // T-HIROYN Win3.1 use FontFaceEnum JAPAN only
#endif

#ifdef NEWFONTENUM
#define psApprovedMax 48  /* don't know why we don't go up to 64 here; spose
                             that's for "the big boy word processors" ..pault */
#endif

/* Used in DOPRM.C and FONTENUM.C */
#define csizeApprovedMax 13
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fmtdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define ichMaxLine	255
#define cpMaxTl 	(ichMaxLine + cchInsBlock)
#define ichpMacInitFormat 10	 /* Initial mac of char runs in a line */
#define dypBaselineMin	 2

#define wbWhite 	0	/* Word break types */
#define wbText		1
#define wbPunct 	2
#define wbAny		3	/* used when searching with wildcards */

#ifdef	DBCS		    /* was in JAPAN, changed it to DBCS */
	/* brought from WIN2. */
#define wbKanjiText	 4
#define wbKanjiTextFirst 5
#endif	/* DBCS */

#define dxpTab		40

/* Formatted line structure.
   Reorganized KJS, CS Sept 3
   Shuffled for word alignment bz, 6/11/85 */

/* booleans in bytes to simplify machine code */
struct FLI
	{
	typeCP		cpMin;
	int		ichCpMin;
	typeCP		cpMac;
	int		ichCpMac;
	int		ichMac;
	int		dcpDepend;
	unsigned	fSplat : 8;
/* First character in region where spaces have additional pixel */
	unsigned	ichFirstWide : 8;
/* ichMac, with trailing blanks excluded */
	int		ichReal;
	int		doc;

	int		xpLeft;
	int		xpRight;
/* xpRight, with trailing blanks excluded */
	int		xpReal;
/* the right margin where insert will have to break the line */
	int		xpMarg;

	unsigned	fGraphics : 8;
	unsigned	fAdjSpace : 8;	/* Whether you adjust the spaces */

	unsigned	dxpExtra;
/* the interesting positions in order from top to bottom are:
	top:		      yp+dypLine
	top of ascenders:     yp+dypAfter+dypFont
	base line:	      yp+dypBase
	bottom of descenders: yp+dypAfter
	bottom of line:       yp
distances between the points can be determined by algebraic subtraction.
e.g. space before = yp+dypLine - (yp+dypAfter+dypFont)
*/
	int		dypLine;
	int		dypAfter;
	int		dypFont;
	int		dypBase;
	int		fSplatNext; /* Splat on following line? */

	int		ichLastTab;
	int		flm;
	int		rgdxp[ichMaxLine];      /* NOTE this differs from fce.rgdxp==CHAR! */
	CHAR		rgch[ichMaxLine];
	};



#define cwFLI	(sizeof(struct FLI) / sizeof(int))
#define cwFLIBase (cwFLI - ichMaxLine - (ichMaxLine / sizeof (int)))


#define flmPrinting	1
#define flmCharMode	2
#define flmNoMSJ	4
#define flmSandMode	8

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fontenum.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Fonts.c -- WRITE font routines */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dlgdefs.h"
#include "propdefs.h"
#include "fontdefs.h"
#include "prmdefs.h"
#include "str.h"
#include "docdefs.h"

#ifdef DBCS
#include "kanji.h"
#endif

#ifdef JAPAN
CHAR    szDefFFN0[10];
CHAR    szDefFFN1[10];
#endif

extern struct DOD     (**hpdocdod)[];
extern HANDLE         hMmwModInstance;
extern HANDLE         hParentWw;
extern int            vfSeeSel;
extern int            docCur;
extern HWND           vhWndMsgBoxParent;
extern int            vfCursorVisible;
extern HCURSOR        vhcArrow;


int iszSizeEnum;
int iszSizeEnumMac;
int iszSizeEnumMax;
extern CHAR szSystem[];

#ifdef DBCS_VERT
extern CHAR szAtSystem[]; // Use for '@' fontface checking.
#endif

int iffnEnum;
int vfFontEnumFail;
struct FFNTB **hffntbEnum = NULL;

#ifdef NEWFONTENUM
/* Changed because it is INCORRECT to filter out all non-ANSI
   character sets.  Also we've removed this aspect-ratio checking 
   stuff ..pault */

#define FCheckFont(lptm) (1)
#else
BOOL FCheckFont(lptm)
LPTEXTMETRIC lptm;
    {
    /* This routine returns TRUE iff the character set for this font is the
    ANSI set and either this is a vector font or the aspect ratio is correct. */

    extern int aspectXFont;
    extern int aspectYFont;

    return (
#ifdef  DBCS
      lptm->tmCharSet == NATIVE_CHARSET
#else
      lptm->tmCharSet == ANSI_CHARSET
#endif
      && ((lptm->tmPitchAndFamily & 0x6) == 0x2
      || (lptm->tmDigitizedAspectX == aspectXFont
      && lptm->tmDigitizedAspectY == aspectYFont)));
    }
#endif /* else-def-NEWFONTENUM */



/* FontFaceEnum used to be called for a number of reasons so it used
   rg[] to pass in parameters to get it to do different things including
   aspect-ratio filtering.  I've simplified this a great deal so Write
   will allow more things (this can be good or bad) ..pault */

BOOL far PASCAL FontFaceEnum(lplf, lptm, fty, lParam)
LPLOGFONT lplf;
LPTEXTMETRIC lptm;
int fty;            /* font type, passed through from the EnumFonts call: */
                    /*         fty & RASTER_FONTTYPE == fRasterFont       */
                    /*         fty & DEVICE_FONTTYPE == fDeviceFont       */
long lParam;
    {
    /* Callback routine to record all of the appropriate face names for the
       current printer.  "appropriate" is based on the params as follows:

           * rgw[0]=0 normal mode,
                   =enumQuickFaces indicates "streamlined mode"
                    (i.e. ignore all the following params in this case), and
                   =
           * rgw[1]=RASTER_FONTTYPE if only raster fonts are to be enumerated,
           *       =DEVICE_FONTTYPE if only device fonts are to be enumerated,
           *       =TRUETYPE_FONTTYPE if only TRUE_TYPE fonts are to be enumerated,
           * rgw[2]=desired font family code (e.g. we start out
                    only wanting swiss, and later expand that)
           * rgw[3] indicates whether or not we must match rgw[2]
           * rgw[4]=max number of fonts we have room for

    ..pault 10/12/89*/

    int *rgw = (int *)LOWORD(lParam);

    /* Stop enumerating if we have enough fonts */

    if ((*hffntbEnum)->iffnMac >= rgw[4])
        /* we have all we need */
        return(FALSE);
#ifdef DENUMF
    {
    char rgch[100];
    wsprintf(rgch,"FFEn: %s, devicebit %d rasterbit %d ",lplf->lfFaceName,
                fty&DEVICE_FONTTYPE, fty&RASTER_FONTTYPE);
    CommSz(rgch);
    }
#endif

#ifdef JAPAN //T-HIROYN Win3.1
    if (rgw[0] == enumQuickFaces)
        goto addenumj;
    if (rgw[0] == enumFaceNameJapan)
        {
        if (lplf->lfCharSet == NATIVE_CHARSET)
            {
            if (rgw[1] == 0 && (fty & DEVICE_FONTTYPE) &&
             !(CchDiffer(lplf->lfFaceName,szDefFFN0,lstrlen(szDefFFN0))))
                goto addenumj;
// 12/15/92
#if 1
            if (rgw[1] == 3 && (fty & TRUETYPE_FONTTYPE) &&
             (lplf->lfPitchAndFamily & 0xf0) == FF_ROMAN )
                goto addenumj;

            if (rgw[1] == 4 && (fty & TRUETYPE_FONTTYPE))
                goto addenumj;
#endif
            if (rgw[1] == 1 &&
             !(CchDiffer(lplf->lfFaceName,szDefFFN1,lstrlen(szDefFFN1))))
                goto addenumj;
            if (rgw[1] == 2 &&
             (lplf->lfPitchAndFamily & 0xf0) == FF_ROMAN &&
             (lplf->lfPitchAndFamily & 0x0f) == FIXED_PITCH)
                goto addenumj;
        /* Is this the right type of font? */
            }
        goto retenumj;
        }
    if (rgw[0] == enumFaceNames && (fty & rgw[1]))
        {
        if( (rgw[3] == 0) ||
            ( (lptm->tmPitchAndFamily&grpbitFamily) == rgw[2] ) )
            goto addenumj;
        }
    goto retenumj;

addenumj:
        {
#else
    if ((rgw[0] == enumQuickFaces) ||
        /* Is this the right type of font? */
        ((fty & rgw[1]) &&
            /* Does this font belong to the correct family?  Well
               when rgw[3] says: NEEDN'T MATCH then of course it does, and
               when rgw[3] says: MATCH then we check to see! */
            ((rgw[3] == 0)||((lptm->tmPitchAndFamily&grpbitFamily) == rgw[2]))))        {

#endif //JAPAN

        CHAR rgb[ibFfnMax];
        struct FFN *pffn = (struct FFN *)rgb;

        bltbx(lplf->lfFaceName, (LPSTR)pffn->szFfn,
              umin(LF_FACESIZE, IchIndexLp((LPCH)lplf->lfFaceName, '\0')+1));
        pffn->chs = lplf->lfCharSet;    /* save this setting */

        /* We're interested in this one */
        if (FCheckFont(lptm) && (*hffntbEnum)->iffnMac < iffnEnumMax)
            {
            pffn->ffid = lplf->lfPitchAndFamily & grpbitFamily;
#ifdef DENUMF
            CommSz("(adding)");
#endif

            if (!FAddEnumFont(pffn))
                {
                /* Couldn't add it to the table. */
                vfFontEnumFail = TRUE;
                return(FALSE);
                }
            }
        }
#ifdef DENUMF
        CommSz("\n\r");
#endif

#ifdef JAPAN //T-HIROYN Win3.1
retenumj:
#endif

    return(TRUE);
    }

FInitFontEnum(doc, cffnInteresting, fOrder)
/* sets up for a font enumeration, where caller cares about
   'cffnInteresting' fonts, and special stuff is done iff 'fOrder'
   (to help us pick good default font(s) on startup */

int doc, cffnInteresting, fOrder;
    {
    extern HDC vhDCPrinter;
#ifdef INEFFLOCKDOWN
    extern FARPROC lpFontFaceEnum;
#else
    FARPROC lpFontFaceEnum = NULL;
#endif

    int iffn, iffnMac;
    struct FFNTB **hffntb;
    struct FFN *pffn, **hffn;
    struct FFN ffn;
    CHAR rgb[ibFfnMax];
    int rgw[5];

    vfFontEnumFail = FALSE;

    if (hffntbEnum != NULL)
        {
        return(FALSE);
        }

    if (FNoHeap(hffntbEnum = HffntbAlloc()))
        {
        hffntbEnum = NULL;
        return(FALSE);
        }

    /* First we list all the fonts used in the current doc's ffntb */

#ifdef DENUMF
    CommSzNumNum("FINITFONTENUM: cffnInteresting,fOrder ",cffnInteresting,fOrder);
#endif

#ifdef JAPAN    //T-HIROYN  Win3.1J
//Clear defalut KanjiFtc <-- use menu.c GetKanjiFtc();
{
    extern  int KanjiFtc;
    KanjiFtc = ftcNil;
}
#endif

    if (doc != docNil)
        {
        hffntb = HffntbGet(doc);
        iffnMac = imin((*hffntb)->iffnMac, iffnEnumMax);
        pffn = (struct FFN *)rgb;
        for (iffn = 0; iffn < iffnMac; iffn++)
            {
            hffn = (*hffntb)->mpftchffn[iffn];
            bltbyte((*hffn), pffn, CbFromPffn(*hffn));
            if (!FAddEnumFont(pffn))
                goto InitFailure;
            }
        if ((*hffntbEnum)->iffnMac >= cffnInteresting)
            {
            goto HaveCffnInteresting;
            }
        }

#if 0
    /* Include the fonts from WIN.INI in the enumeration */
    if (!FAddProfileFonts())
        {
        goto InitFailure;
        }
#endif

    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;

    if (vhDCPrinter == NULL)
        {
        GetPrinterDC(FALSE);
        Assert(vhDCPrinter);
        }

#ifndef INEFFLOCKDOWN
    if (!(lpFontFaceEnum = MakeProcInstance(FontFaceEnum, hMmwModInstance)))
        {
        WinFailure();
        goto InitFailure;
        }
#endif

    /* See what the system knows about!
       If order ISN'T significant, we'll examine all fonts at once. */

    if (!fOrder)
        {
#ifdef DENUMF
        CommSz("FINITFONTENUM: EnumFonts(all) \n\r");
#endif
        rgw[0] = enumQuickFaces;  // means igonre the rest
#if 0
        rgw[1] = RASTER_FONTTYPE; // ignored, why set?
        rgw[2] = FF_SWISS;        // ignored, why set?
        rgw[3] = TRUE;            // ignored, why set?
        rgw[4] = cffnInteresting; // ignored, why set?
#endif
        EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
        if (vfFontEnumFail)
            goto InitFailure;
        else
            goto HaveCffnInteresting;   /* got what we needed */
        }

#ifdef JAPAN //T-HIROYN Win3.1
    /* japanens write try in steps first
        #1 KANJI_CHARSET device_fonttype mincho
//12/15/92
	add KANJI_CHARSET TRUETYPE FF_ROMAN
	add KANJI_CHARSET TRUETYPE
        #2 KANJI_CHARSET hyoujyun mincho
        #3 KANJI_CHARSET all font FF_ROMAN FIXED_PITCH
    */

    rgw[0] = enumFaceNameJapan;   /* #define in FONTDEFS.H */
    rgw[1] = 0;
    rgw[2] = rgw[3] = 0;   /* dummy */
    rgw[4] = 32767;

    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

// 12/15/92
#if 1
    rgw[1] = 3;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */
    rgw[1] = 4;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */
#endif

    rgw[1] = 1;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

    rgw[1] = 2;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#endif  /* JAPAN */

    /* Ahh... but since we now know order IS significant, i.e. we are
       trying  to pick good default fonts for startup, we'll try in steps:

          #1--any good TrueType fonts in the Swiss font family?
          #2--any good TrueType fonts in the non-Swiss?
          #3--any good device-based fonts in the Swiss font family?
          #4-- "   "        "         "      non-Swiss?
          #5--any  non device-based fonts in the Swiss font family?
          #6-- "   "        "         "      non-Swiss? */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss truetype) \n\r");
#endif
    rgw[0] = enumFaceNames;
    rgw[1] = TRUETYPE_FONTTYPE;
    rgw[2] = FF_SWISS;
    rgw[3] = TRUE;  /* match swiss! */
    rgw[4] = 32767;

    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(nonSwiss truetype) \n\r");
#endif
    rgw[3] = FALSE;  /* need not match swiss! */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss device) \n\r");
#endif
    rgw[1] = DEVICE_FONTTYPE;
    rgw[3] = TRUE;  /* match swiss! */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(nonSwiss device) \n\r");
#endif
    rgw[3] = FALSE; /* need not match swiss */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss nondevice) \n\r");
#endif
    rgw[1] = RASTER_FONTTYPE;
    rgw[3] = TRUE;  /* match swiss! */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss nondevice) \n\r");
#endif
    rgw[3] = FALSE; /* need not match swiss */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;

HaveCffnInteresting:
    iffnEnum = 0;
#ifndef INEFFLOCKDOWN
    if (lpFontFaceEnum)
        FreeProcInstance(lpFontFaceEnum);
#endif

#ifdef JAPAN //T-HIROYN Win3.1
    if(docNil == doc && fOrder)
        SaveKanjiFfn();
#endif

    return(TRUE);

InitFailure:
    FreeFfntb(hffntbEnum);
    hffntbEnum = NULL;
#ifndef INEFFLOCKDOWN
    if (lpFontFaceEnum)
        FreeProcInstance(lpFontFaceEnum);
#endif
    return(FALSE);
    }

void ResetFontTables(void)
{
    /*
        Free the pfce's.  LoadFont will reallocate them with new information
        obtained below.
     */

    FreeFonts(TRUE,TRUE);

    /*  This is a clumsy method that takes advantage of side effect of
        resetting the data stored in the font tables */
    FInitFontEnum(docNil, 32767, FALSE);

#ifdef JAPAN    //T-HIROYN 92.08.18 Win3.1
//Printer Change ?
//Sync FontFaceName and CharSet
{
    int iffn, iffnMac;
    int Eiffn, EiffnMac;
    struct FFNTB **hffntb;
    struct FFN ***mpftchffn;
    struct FFN ***Empftchffn;
    char    msg[30];

    hffntb = HffntbGet(docCur);
    if (hffntb != 0) {
        mpftchffn = (*hffntb)->mpftchffn;
        iffnMac = (*hffntb)->iffnMac;

        Empftchffn = (*hffntbEnum)->mpftchffn;
        EiffnMac = (*hffntbEnum)->iffnMac;

        for (iffn = 0; iffn < iffnMac; iffn++) {
            for (Eiffn = 0; Eiffn < EiffnMac; Eiffn++) {
                if (WCompSz((*mpftchffn[iffn])->szFfn,
                            (*Empftchffn[Eiffn])->szFfn) == 0)
                {
                    (*mpftchffn[iffn])->chs = (*Empftchffn[Eiffn])->chs;
                    break;
                }
            }
        }
    }
}
#endif

    EndFontEnum();
}

CHAR * (NEAR PchSkipSpacesPch( CHAR * ));

int WFromSzNumber( ppch )
CHAR **ppch;
{   /* Given an ASCII string containing a (base 10) number, return the number
       represented.  Ignores leading and trailing spaces.
       Does not accept negative numbers. */
    /* 10/12/89 ..pault
        Now increments the pointer to just past last digit converted */

 unsigned w = 0;
 CHAR ch;

 *ppch = PchSkipSpacesPch( *ppch );
 while ( ((ch = (*(*ppch)++)) >= '0') && (ch <= '9') )
    {
    w = (w * 10) + (ch - '0');
    }

 (*ppch)--; /* bumped one too far */
 return w;
}


CHAR * (NEAR PchSkipSpacesPch( pch ))
CHAR *pch;
{   /* Return a pointer to the first character in the string
       at pch that is either null or non-whitespace */

 for ( ;; ) {
#ifdef DBCS
        /* DB Char space must be checked */
    if (FKanjiSpace(*pch, *(pch + 1))) {
        pch += cchKanji;
        continue;
    }
#endif  /* DBCS */
        switch (*pch) {
            default:
                return pch;
            case ' ':
            case 0x09:
                pch++;
                break;
            }
    }
}


BOOL FEnumFont(pffn)
/* returns the next font entry through pffn.  Returns FALSE if no more */

struct FFN *pffn;
    {
    int cb;
    struct FFN **hffn;

    if (iffnEnum >= (*hffntbEnum)->iffnMac)
        {
        return(FALSE);
        }

    hffn = (*hffntbEnum)->mpftchffn[iffnEnum];
#ifdef DEBUG
    cb = CchSz( (*hffn)->szFfn );
    Assert( cb <= LF_FACESIZE );
    cb = CbFfn( cb );
#else
    cb = CbFfn(CchSz((*hffn)->szFfn));
#endif
    bltbyte(*hffn, pffn, cb);
    iffnEnum++;
    return(TRUE);
    }


EndFontEnum()
/* cleans up after a font enumeration */
    {
    FreeFfntb(hffntbEnum);
    hffntbEnum = NULL;
    }


FAddEnumFont(pffn)
/* code factoring for adding described font to enumeration table - filters
   out "ghost fonts" and system font */

struct FFN *pffn;
    {
#ifdef JAPAN
// It is required to do vertical writing with system font in JAPAN.
    if ( pffn->szFfn[0] == chGhost)
#else
    if (WCompSz(pffn->szFfn, szSystem) == 0 || pffn->szFfn[0] == chGhost)
#endif
        return(TRUE);
    return(FEnsurePffn(hffntbEnum, pffn));
    }

#ifdef JAPAN    //T-HIROYN 92.08.18 Win3.1
BYTE scrFontChs;
//I want to get true Charset
BOOL far PASCAL _export NFontFaceEnum(lplf, lptm, fty, lParam)
LPLOGFONT lplf;
LPTEXTMETRIC lptm;
int fty;
long lParam;
{
        if (LOWORD(lParam) == 0)
        {
            scrFontChs = lplf->lfCharSet;
            return(FALSE);
        }
        return(TRUE);
}
#endif

#ifdef NEWFONTENUM
/* This stuff added for Win3 because we have to be able to determine
   with which character set a font in a particular document is associated,
   since our file format does not store it.  Naturally, WinWord added that
   to their file format!  ..pault */

/* Look through the list of fonts sitting out there [i.e. FInitFontEnum
   must have been called, and it is from HffntbForFn()] and make our best
   guess as to what CharSet it's  supposed to have, since we don't store
   these in the doc font table! */

int ChsInferred( pffn )
struct FFN *pffn;
    {
    struct FFN *pffnCheck;
    char *sz = pffn->szFfn;
#ifdef  DBCS
    int chs = NATIVE_CHARSET;
#else
    int chs = 0;
#endif
    int i, iMac = (*hffntbEnum)->iffnMac;

    for (i = 0; i < iMac; i++)
        {
        pffnCheck = *(struct FFN **) ((*hffntbEnum)->mpftchffn[i]);
        if (WCompSz(pffnCheck->szFfn, sz) == 0)
            {
#ifdef DIAG
            if (pffnCheck->ffid != pffn->ffid)
                {
                CommSzSz("ChsInferred: matched fontname ",sz);
                CommSzNumNum("   but enum->ffid / doc->ffid", pffnCheck->ffid,pffn->ffid);
                }
#endif
            Assert(pffnCheck->ffid == pffn->ffid);
            chs = pffnCheck->chs;
            break;
            }
        }

#ifdef JAPAN    //T-HIROYN 92.08.18 Win3.1
//I want to get true Charset
{
    extern HDC vhMDC;   /* memory DC compatible with the screen */
    FARPROC NlpFontFaceEnum;

    if(i == iMac) {
        if(vhMDC != NULL) {
           if (NlpFontFaceEnum =
                MakeProcInstance(NFontFaceEnum, hMmwModInstance))
           {
                scrFontChs = chs;
                EnumFonts(vhMDC,(LPSTR)sz,NlpFontFaceEnum,(LPSTR) NULL);
                FreeProcInstance(NlpFontFaceEnum);
                if(chs != scrFontChs)
                    chs = scrFontChs;
           }
        }
    }
}
#endif

    return(chs);
    }
#endif /* NEWFONTENUM */

#ifdef JAPAN //T-HIROYN Win3.1
CHAR saveKanjiDefFfn[ibFfnMax];

SaveKanjiFfn()
{
    int i, iMac = (*hffntbEnum)->iffnMac;

    struct FFN *pffn = (struct FFN *)saveKanjiDefFfn;
    struct FFN *hffn;

    for (i = 0; i < iMac; i++)
    {
        hffn = *(struct FFN **) ((*hffntbEnum)->mpftchffn[i]);
        if (NATIVE_CHARSET  == hffn->chs)
        {
            lstrcpy(pffn->szFfn, hffn->szFfn);
            pffn->ffid = hffn->ffid;
            pffn->chs  = hffn->chs;
            break;
        }
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\form1.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*--- Module not really used, just the idea behind FORMAT.ASM ---*/


#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOCLIPBOARD
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#include <windows.h>
/* #include "wwsmall.h" */

#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "ch.h"
#include "docdefs.h"
#include "ffdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "dispdefs.h"
#include "scrndefs.h"
#include "macro.h"
#include "debug.h"
#include "fontdefs.h"
#include "str.h"
#include "wwdefs.h"
#ifdef DBCS
#include "dbcs.h"
#endif

#ifdef DFLI
#define Dfli(x) x  /* Enable debug-format-line info */
#else
#define Dfli(x)
#endif

#ifdef CASHMERE
#define                 cchSmcapMax     16
#endif /* CASHMERE */

static int              ichpFormat;

#ifdef CASHMERE
static CHAR             mptlcch[] = " .-_";
#endif /* CASHMERE */

extern int              docHelp;
extern struct FLI       vfli;
extern struct CHP       (**vhgchpFormat)[];
extern int              ichpMacFormat;
extern struct CHP       vchpAbs;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct CHP       vchpNormal;
extern struct DOD       (**hpdocdod)[];
extern typeCP           vcpLimSectCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern typeCP           vcpFetch;
extern int              vichFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern int              vcchFetch;
extern int              vftc;
extern int              ypSubSuper;
extern int              ypSubSuperPr;
extern HDC              vhMDC;
extern HDC              vhDCPrinter;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern int              dypMax;
extern struct FMI       vfmiScreen, vfmiPrint;
extern int              vfOutOfMemory;
extern CHAR             vchDecimal;  /* "decimal point" character */
extern int              vzaTabDflt;  /* width of default tab */
#ifdef CASHMERE
extern int              vfVisiMode;
#endif /* CASHMERE */


/* F O R M A T  L I N E */
FormatLine(doc, cp, ichCp, cpMac, flm)
int doc;
typeCP cp;
int ichCp;
typeCP cpMac;
int flm;
    {
    /* Fills up vfli with a line of text */

    int near Justify(struct IFI *, unsigned, int);
    int near FGrowFormatHeap(void);
    int near FFirstIch(int);

    struct IFI ifi;
    struct TBD *ptbd;
    struct CHP chpLocal;
    int xpTab;

#ifdef CASHMERE
    int dypBefore;
#endif /* CASHMERE */

    int dypAscent;
    int dypDescent;
    int dypAscentMac;
    int dypDescentMac;
    unsigned xaLeft;
    unsigned xaRight;
    struct PAP *ppap;
    struct SEP *psep;
    int fFlmPrinting = flm & flmPrinting;
    int dxaFormat;
    int dyaFormat;
    int dxpFormat;
    int dypFormat;
    int ypSubSuperFormat;
    int fTruncated = false;     /* if the run was truncated */
    int ichpNRH;



#ifdef CASHMERE
    struct FNTB **hfntb;
    int fVisiMode;
#endif /* CASHMERE */

    /* Check for fli current */
    if (vfli.doc == doc && vfli.cpMin == cp && vfli.ichCpMin == ichCp &&
      vfli.flm == flm)
        {
        /* Just did this one */
        return;
        }

    Scribble(5, 'F');
    bltc(&vfli, 0, cwFLIBase);
    /* This means:
        vfli.fSplat = false;
        vfli.dcpDepend = 0;
        vfli.ichCpMac = 0;
        vfli.dypLine = 0;
        vfli.dypAfter = 0;
        vfli.dypFont = 0;
        vfli.dypBase = 0;
    */

    /* vfSplatNext = FALSE; No longer used. */

    /* Rest of format loads up cache with current data */
    vfli.doc = doc;
    vfli.cpMin = cp;
    vfli.ichCpMin = ichCp;
    vfli.flm = flm;

    if (cp > cpMac)
        {
        /* Space after the endmark.  Reset the cache because the footnotes come
        at the same cp in the footnote window */
        vfli.doc = docNil;
        vfli.cpMac = cp;
        vfli.rgdxp[0] = 0;

        /* Line after end mark is taller than screen */

#ifdef CASHMERE
        vfli.dypBase = vfli.dypFont = vfli.dypAfter = ((vfli.dypLine = dypMax)
          >> 1);
#else /* not CASHMERE */
        vfli.dypBase = vfli.dypFont = ((vfli.dypLine = dypMax) >> 1);
#endif /* not CASHMERE */

        Scribble(5, ' ');
        return;
        }

    /* Initialize run tables */
    ichpFormat = 0;

    /* Cache section and paragraph properties */

#ifdef CASHMERE
    hfntb = (**hpdocdod)[doc].hfntb;
    if (hfntb == 0 || cp < (**hfntb).rgfnd[0].cpFtn)
        {
        /* Normal text */
        CacheSect(doc, cp);
        }
    else
        {
        /* Footnote section properties come from the section of the footnote
        reference. */
        CacheSect(doc, CpRefFromFtn(doc, cp));
        }
#else /* not CASHMERE */
    CacheSect(doc, cp);
#endif /* not CASHMERE */

    psep = &vsepAbs;

    CachePara(doc, cp);
    ppap = &vpapAbs;

    /* Now we have:
        ppap    paragraph properties
        psep    division properties
    */

    if (ppap->fGraphics)
        {
        /* Format a picture paragraph in a special way (see picture.c) */
        FormatGraphics(doc, cp, ichCp, cpMac, flm);
        Scribble(5, ' ');
        return;
        }

    /* Assure we have a good memory DC for font stuff */
    ValidateMemoryDC();
    if (vhMDC == NULL || vhDCPrinter == NULL)
        {
        Scribble(5, ' ');
        return;
        }

#ifdef CASHMERE
    /* When printing, don't show visible characters */
    fVisiMode = vfVisiMode && !fFlmPrinting;
#endif /* CASHMERE */

    bltc(&ifi, 0, cwIFI);
    /* This means:
        ifi.ich = 0;
        ifi.ichPrev = 0;
        ifi.ichFetch = 0;
        ifi.cchSpace = 0;
        ifi.ichLeft = 0;
    */

    ifi.jc = jcTabLeft;
    ifi.fPrevSpace = true;

    /* Set up some variables that have different value depending on whether we
    are printing or not. */
    if (fFlmPrinting)
        {
        dxaFormat = dxaPrPage;
        dyaFormat = dyaPrPage;
        dxpFormat = dxpPrPage;
        dypFormat = dypPrPage;
        ypSubSuperFormat = ypSubSuperPr;
        }
    else
        {
        dxaFormat = dyaFormat = czaInch;
        dxpFormat = dxpLogInch;
        dypFormat = dypLogInch;
        ypSubSuperFormat = ypSubSuper;
        }

    /* Calculate line height and width measures.  Compute
        xaLeft          left indent 0 means at left margin
        xaRight         width of column measured from left margin (not from left
                        indent).
    */
    xaLeft = ppap->dxaLeft;

    /* If this is the first line of a paragraph, adjust xaLeft for the first
    line indent.  (Also, set dypBefore, since its handy.) */
    if (cp == vcpFirstParaCache)
        {
        xaLeft += ppap->dxaLeft1;

#ifdef CASHMERE
        dypBefore = MultDiv(ppap->dyaBefore, dypLogInch, czaInch);
#endif /* CASHMERE */

        }

#ifdef CASHMERE
    else
        {
        dypBefore = 0;
        }
#endif /* CASHMERE */

    /* Now, set xaRight (width measured in twips). */

#ifdef CASHMERE
    xaRight = (ppap->rhc ? vsepPage.xaMac - vsepPage.dxaGutter :
      psep->dxaText) - ppap->dxaRight;
#else /* not CASHMERE */
    xaRight = psep->dxaText - ppap->dxaRight;
#endif /* not CASHMERE */


    /* Do necessary checks on xaLeft and xaRight */
    if (xaRight > xaRightMax)
        {
        xaRight = xaRightMax;
        }
    if (xaLeft > xaRightMax)
        {
        xaLeft = xaRightMax;
        }
    if (xaLeft < 0)
        {
        xaLeft = 0;
        }
    if (xaRight < xaLeft)
        {
        xaRight = xaLeft + 1;
        }

    vfli.xpLeft = ifi.xp = ifi.xpLeft = MultDiv(xaLeft, dxpFormat, dxaFormat);
    vfli.xpMarg = ifi.xpRight = MultDiv(xaRight, dxpFormat, dxaFormat);
    ifi.xpPr = MultDiv(xaLeft, dxpPrPage, dxaPrPage);
    ifi.xpPrRight = MultDiv(xaRight, dxpPrPage, dxaPrPage);

    /* Get a pointer to the tab-stop table. */
    ptbd = ppap->rgtbd;

    /* Turn off justification. */
    SetTextJustification(fFlmPrinting ? vhDCPrinter : vhMDC, 0, 0);

    /* Initialize the line height information. */
    dypAscentMac = dypDescentMac = 0;

    /* To tell if there were any tabs */
    ifi.ichLeft = -1;

    /* Get the first run, and away we go... */
    FetchCp(doc, cp, ichCp, fcmBoth + fcmParseCaps);
    goto FirstCps;

    for ( ; ; )
        {
        int iichNew;
        int xpPrev;
        int dxp;
        int dxpPr;

        /* The number of characters to process (usually vcchFetch) */
        int cch;

        /* The number of characters in current run already used */
        int cchUsed;

        /* A pointer to the current list of characters (usually vpchFetch) */
        CHAR *pch;

#ifdef CASHMERE
        CHAR rgchSmcap[cchSmcapMax];
#endif /* CASHMERE */

        if (ifi.ichFetch == cch)
            {
            /* End of a run */
            int dich;
            BOOL fSizeChanged;

            if (ifi.ich >= ichMaxLine)
            /* End of run because of line length limit has been reached. */
                {
                goto DoBreak;
                }

            if (fTruncated)
                {
                cchUsed += cch;
                pch = vpchFetch + cchUsed;
                cch = vcchFetch - cchUsed;
                fTruncated = false;
                goto OldRun;    /* use the rest of the old run  */
                }

NullRun:
            FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
FirstCps:

            cchUsed = 0;

            /* Continue fetching runs until a run is found with a nonzero
            length. */
            if ((cch = vcchFetch) == 0)
                {
                goto NullRun;
                }

            pch = vpchFetch;
            if (vcpFetch >= cpMac || (!fFlmPrinting && *pch == chSect))
                {
#ifdef SYSENDMARK
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = ftcSystem;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#else
#ifdef REVIEW
                /* The following comment is absolutely misleading!  Ftc==0
                   doesn't give you a system font.  It gives you the first
                   entry in the font table. */
#endif /* REVIEW */
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = 0;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#endif /* if-else-def KANJI */
                }

#ifdef CASHMERE
            /* Adjust the size of the font for "small capitals". */
            if (vchpAbs.csm == csmSmallCaps)
                {
                vchpAbs.hps = HpsAlter(vchpAbs.hps, -1);
                }
#endif /* CASHMERE */

            /* Now we have:
                ichpFormat     index into gchp table
                vcpFetch        first cp of current run
                vfli.cpMin      first cp of line
                ifi.ich         ???
            */

           /* since LoadFont could change vchpAbs, and we don't want
              that to happen, we copy vchpAbs into vchpLocal and use
              vchpLocal in place of vchpAbs hereafter. Note that vchpAbs
              is intentionally used above for handling the endmark. */

                blt(&vchpAbs, &chpLocal, cwCHP);


            if (fFlmPrinting)
                {
                LoadFont(doc, &chpLocal, mdFontPrint);
                dypAscent = vfmiPrint.dypAscent + vfmiPrint.dypLeading;
                dypDescent = vfmiPrint.dypDescent;
                }
            else
                {
                LoadFont(doc, &chpLocal, mdFontJam);
                dypAscent = vfmiScreen.dypAscent + vfmiScreen.dypLeading;
                dypDescent = vfmiScreen.dypDescent;
                }

#ifdef ENABLE   /* BRYANL 8/27/87: New philosophy for handling
                   font selection failures is: font selection
                   ALWAYS succeeds. This prevents FormatLine
                   returns that do not advance. */
            /* Bail out if there is a memory failure. */
            if (vfOutOfMemory)
                {
                goto DoBreak;
                }
#endif  /* ENABLE */

            /* Floating line size algorithm */
            if (chpLocal.hpsPos != 0)
                {
                /* Modify font for subscript/superscript */
                if (chpLocal.hpsPos < hpsNegMin)
                    {
                    dypAscent += ypSubSuperFormat;
                    }
                else
                    {
                    dypDescent += ypSubSuperFormat;
                    }
                }

            /* Update the maximum ascent and descent of the line. */
            fSizeChanged = FALSE;
            if (dypDescentMac < dypDescent)
                {
                dypDescentMac = dypDescent;
                fSizeChanged = TRUE;
                }
            if (dypAscentMac < dypAscent)
                {
                dypAscentMac = dypAscent;
                fSizeChanged = TRUE;
                }


            if (fSizeChanged)
                {

#ifdef AUTO_SPACING
                /* This is the original Mac Word code that assumed line spacing
                of 0 in a PAP meant auto line spacing.  PC Word defaults to 1
                line invalidating this assumption. */
                if (ppap->dyaLine == 0)
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = dypDescentMac + dypAscentMac + dypBefore;
#else /* not CASHMERE */
                    ifi.dypLineSize = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    }
                else
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat), 1);
#endif /* not CASHMERE */

                    }
#else /* not AUTO_SPACING */
                /* This code forces auto line spacing except in the case where
                the user specifies a line spacing greater than the auto line
                spacing. */
                    {
#ifdef CASHMERE
                    register int dypAuto = dypDescentMac + dypAscentMac +
                      dypBefore;
#else /* not CASHMERE */
                    register int dypAuto = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    if (ppap->dyaLine > czaLine)
                        {

#ifdef CASHMERE
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat), 1);
#endif /* not CASHMERE */

                        ifi.dypLineSize = max(dypAuto, dypUser);
                        }
                    else
                        {
                        ifi.dypLineSize = dypAuto;
                        }
                    }
#endif /* not AUTO_SPACING */

                }

OldRun:
            /* Calculate length of the run but no greater than 256 */
            iichNew = (int)(vcpFetch - vfli.cpMin);
            if (iichNew >= ichMaxLine)
                {
                iichNew = ichMaxLine - 1;
                }
            dich = iichNew - ifi.ich;

            /* Ensure that all tab and non-required hyphen characters start at
            beginning of run */
            if (ichpFormat <= 0  || dich > 0 || CchDiffer(&chpLocal,
              &(**vhgchpFormat)[ichpFormat - 1], cchCHPUsed) != 0 || *pch ==
              chTab || *pch == chNRHFile)
                {
#ifdef DFLI
                if (*pch == chNRHFile)
                    CommSz("CHNRHFILE at beginning of run");
#endif                
                if (ichpFormat != ichpMacFormat || FGrowFormatHeap())
                    {
                    register struct CHP *pchp = &(**vhgchpFormat)[ichpFormat -
                      1];

                    if (ichpFormat > 0)
                        {
                        pchp->cchRun = ifi.ich - ifi.ichPrev;
                        pchp->ichRun = ifi.ichPrev;
                        }
                    blt(&chpLocal, ++pchp, cwCHP);

#ifdef ENABLE   /* font codes */
                    pchp->ftc = vftc;
                    pchp->ftcXtra = (vftc & 0x01c0) >> 6;
                    pchp->hps = vhps;
#endif /* ENABLE */

                    pchp->cchRun = ichMaxLine;
                    if (dich <= 0)
                        {
                        pchp->ichRun = ifi.ich;
                        }
                    else
                        {
                        /* Q&D insert */
                        bltc(&vfli.rgdxp[ifi.ich], 0, dich);
                        bltbc(&vfli.rgch[ifi.ich], 0, dich);
                        pchp->ichRun = ifi.ich = iichNew;
                        }
                    ifi.ichPrev = ifi.ich;
                    ichpFormat++;
                    }
                }

            if (vcpFetch >= cpMac)
                {
                /* End of doc reached */
                if (!ifi.fPrevSpace || vcpFetch == cp)
                    {
                    vfli.ichReal = ifi.ich;
                    vfli.xpReal = ifi.xpReal = ifi.xp;
                    }
                if (!fFlmPrinting && (doc != docHelp))
                    {
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chEMark,
                      false));
                    }
                vfli.dypLine = ifi.dypLineSize;
                vfli.dypBase = dypDescentMac;
                vfli.dypFont = dypAscentMac + dypDescentMac;
                vfli.ichMac = vfli.ichReal = ifi.ich;
                vfli.cpMac = cpMac + 1;
                goto JustEol;   /* dcpDepend == 0 */
                }

            /* Here we have ifi.ich, cch */
            if (ifi.ich + cch > ichMaxLine)
            /* If this run would put the line over 255, truncate it and set a
            flag. */
                  {
                  cch = ichMaxLine - ifi.ich;
                  fTruncated = true;
                  }

            ifi.ichFetch = 0;

#ifdef CASHMERE
            if (chpLocal.csm != csmNormal)
                {
                int ich;
                CHAR *pchT = &rgchSmcap[0];

                /* We can handle only a run of cchSmcapMax small capital
                characters.  If the run is larger then truncate. */
                if (cch > cchSmcapMax)
                    {
                    cch = cchSmcapMax;
                    fTruncated = true;
                    }

                /* Raise the case of the characters. */
                for (ich = 0 ; ich < cch ; ich++)
                    {
                    *pchT++ = ChUpper(*pch++);
                    }
                pch = &rgchSmcap[0];
                }
#endif /* CASHMERE */

            /* Do "special" characters here */
            if (chpLocal.fSpecial)
                {
                if (!FFormatSpecials(&ifi, flm, vsepAbs.nfcPgn))
                    {
                    if (ifi.chBreak == 0)   /* No breaks in this line */
                        {
                        goto Unbroken;
                        }
                    else
                        {
                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
                        goto JustBreak;
                        }
                    }
                }

            continue;
            }

        /* End of new run treatment.  We are back in the "for every character"
        section. */
            {
            register int ch = pch[ifi.ichFetch++];

NormChar:

            if (ch == chSpace)
                {
                /* Speed kludge for spaces */
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp =
                    fFlmPrinting ? vfmiPrint.dxpSpace : vfmiScreen.dxpSpace);
                ifi.xpPr += (dxpPr = vfmiPrint.dxpSpace);
                vfli.rgch[ifi.ich++] = chSpace;
#ifdef DFLI                
                {
                char rgch[100];
                
                wsprintf(rgch,"  chSpace     , xp==%d/%d, xpPr==%d/%d", 
                    ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                CommSz(rgch);
                }
#endif
                goto BreakOppr;
                }

            /* If the printer width is not in the printer width table, then get
            it. */
            if (ch < chFmiMin || ch >= chFmiMax || (dxpPr =
              vfmiPrint.mpchdxp[ch]) == dxpNil)
                {
                dxpPr = DxpFromCh(ch, TRUE);
                }

            if (fFlmPrinting)
                {
                /* If we are printing, then there is no need to bother with the
                screen width. */
                dxp = dxpPr;
                }
            else if (ch < chFmiMin || ch >= chFmiMax ||
                (dxp = vfmiScreen.mpchdxp[ch]) == dxpNil)
                    dxp = DxpFromCh(ch, FALSE);

#ifdef DBCS
            if (IsDBCSLeadByte(ch))
                {
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                ifi.xpPr += dxpPr;
                vfli.rgch[ifi.ich++] = ch;
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                ifi.xpPr += dxpPr;
                vfli.rgch[ifi.ich++] = pch[ifi.ichFetch++];
                }
            else
                {
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                ifi.xpPr += dxpPr;
                vfli.rgch[ifi.ich++] = ch;
                }
#else
            ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
            ifi.xpPr += dxpPr;
            vfli.rgch[ifi.ich++] = ch;
#endif

             /* special case "normal characters" above hyphen */

            if (ch > chHyphen)
                goto DefaultCh;

            switch (ch)
                {

#ifdef CRLF
                case chReturn:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
                    continue;
#endif /* CRLF */

                case chNRHFile:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    ichpNRH = ichpFormat - 1;
#ifdef DFLI
                    {
                    char rgch[100];
                    
                    wsprintf(rgch,"  OptHyph: width==%d, xpPr==%d/%d\n\r", 
                        DxpFromCh(chHyphen,true), ifi.xpPr,ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif
                    if (ifi.xpPr + DxpFromCh(chHyphen, true) > ifi.xpPrRight)
                        {
                        /* Won't fit, force a break */
                        goto DoBreak;
                        }

#ifdef CASHMERE
                    else if (fVisiMode)
                        {
                        /* Treat just like a normal hyphen */
                        ch = chHyphen;
                        goto NormChar;
                        }
#endif /* CASHMERE */

                    xpPrev = ifi.xp;
                    vfli.rgch[ifi.ich] = chTab;
                    goto Tab0;

                case chSect:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    vfli.dypFont = vfli.dypLine = (dypAscentMac + (vfli.dypBase
                      = dypDescentMac));
                    vfli.cpMac = vcpFetch + ifi.ichFetch;
                    if (FFirstIch(ifi.ich))
                        {
                        /* Beginning of line; return a splat */
                        vfli.fSplat = true;

                        if (!fFlmPrinting)
                            {

#ifdef CASHMERE
                            int chT = vfli.cpMac == vcpLimSectCache ?
                              chSectSplat : chSplat;
#else /* not CASHMERE */
                            int chT = chSplat;
#endif /* not CASHMERE */

                            int dxpCh = DxpFromCh(chT, false);

                            /* Set the width of the splat to be about 8.5" */
                            int cch = min((dxpLogInch * 17 / 2) / dxpCh,
                              ichMaxLine - 32);

                            bltbc(&vfli.rgch[ifi.ich], chT, cch);
                            bltc(&vfli.rgdxp[ifi.ich], dxpCh, cch);
                            vfli.ichMac = cch + ifi.ich;
                            vfli.xpReal = LOWORD(GetTextExtent(vhMDC,
                              (LPSTR)vfli.rgch, cch));
                            vfli.xpLeft = 0;
                            }
                        else
                            {
                            vfli.ichMac = 0;
                            }
                        goto EndFormat;
                        }

                    /* The section character is in the middle of a line, the
                    line will terminate in front of the character. */
                    /* vfSplatNext = TRUE; No longer used*/
                    vfli.cpMac += cchUsed - 1;
                    vfli.dcpDepend = 1;
                    if (!ifi.fPrevSpace)
                        {
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    goto JustBreak;

                case chTab:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    if (ifi.xpPr < ifi.xpPrRight)
                        {
                        register struct CHP *pchp;
                        unsigned xaPr;
                        unsigned xaTab;

                        if (!ifi.fPrevSpace)
                            {
                            /* Remember number of spaces to left and number of
                            real chars in line for justification */
                            ifi.cBreak = ifi.cchSpace;
                            vfli.ichReal = ifi.ich;
                            ifi.xpReal =  ifi.xp;
                            }

                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        xpPrev = ifi.xp;

                        /* Now get info about this tab */
                        xaPr = MultDiv(ifi.xpPr, dxaPrPage, dxpPrPage);
                        while ((xaTab = ptbd->dxa) != 0)
                            {
                            if (xaTab > xaRight)
                                {
                                /* Don't let tabs extend past right margin. */
                                xaTab = xaRight;
                                }

                            if (xaTab >= xaPr)
                                {
                                /* Use tab stop information */

#ifdef CASHMERE
                                ifi.tlc = ptbd->tlc;
#endif /* CASHMERE */

                                ifi.jc = jcTabMin + (ptbd++)->jc;

#ifdef ENABLE /* we do the mapping in HgtbdCreate */
                                if (ifi.jc != jcTabDecimal)
                                    {
                                    ifi.jc = jcTabLeft;
                                    }
#endif
                                goto TabFound;
                                }
                            ptbd++;
                            }

                        /* Out of set tabs; go to next nth column */
                        xaTab = (xaPr / (vzaTabDflt) + 1) * (vzaTabDflt);

#ifdef CASHMERE
                        ifi.tlc = tlcWhite;
#endif /* CASHMERE */

                        ifi.jc = jcTabLeft;

TabFound:
                        xpTab = imax(MultDiv(xaTab, dxpFormat, dxaFormat),
                          ifi.xp);

                        /* Do left-justified tabs immediately */
                        if (ifi.jc == jcTabLeft)
                            {
                            ifi.xp = xpTab;
                            ifi.xpPr = MultDiv(xaTab, dxpPrPage, dxaPrPage);
                            }
                        ifi.xpLeft = ifi.xp;
                        ifi.ichLeft = ifi.ich;
                        ifi.cchSpace = 0;
                        ifi.chBreak = 0;
Tab0:
                        ifi.fPrevSpace = false;
                        vfli.ichMac = ifi.ich;
                        vfli.xpReal = ifi.xp;
                        vfli.dypLine = ifi.dypLineSize;
                        vfli.dypBase = dypDescentMac;
                        vfli.dypFont = dypAscentMac + dypDescentMac;

                        if (ifi.ichFetch != 1 && (ichpFormat != ichpMacFormat
                          || FGrowFormatHeap()))
                            {
                            /* Probably in real trouble if FGrowFormatHeap fails
                            at this point */
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            if (ichpFormat > 0)
                                {
                                /* Finish off previous run */
                                pchp->ichRun = ifi.ichPrev;
                                pchp->cchRun = ifi.ich - ifi.ichPrev;
                                }

                            blt(&chpLocal, ++pchp, cwCHP);
                            ichpFormat++;
                            }
                        else
                            {
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            }
                        pchp->ichRun = ifi.ich;
                        pchp->cchRun = ichMaxLine;

#ifdef CASHMERE
                        pchp->chLeader = mptlcch[ifi.tlc];
#endif /* CASHMERE */

                        vfli.rgdxp[ifi.ichPrev = ifi.ich++] = ifi.xp - xpPrev;

                        if (ch != chTab)
                            {
                            /* This character is a non-required hyphen. */
                            Dfli(CommSz("ch is really OptHyph "));
                            goto BreakOppr;
                            }

                        continue;
                        }
                    else
                        {
                        ch = chNBSFile;
                        goto NormChar;
                        }

                case chHyphen:
                    if (ifi.xpPr > ifi.xpPrRight)
                        {
                        goto DoBreak;
                        }

BreakOppr:
                Dfli(CommSz(" BKOPPR\n\r"));
                /*    this case never used in switch - always goto here */
                /* case chSpace:  */
                    if (ifi.ich >= ichMaxLine)
                        {
                        Dfli(CommSzNum("  Unbroken, ich>ichMaxLine\n\r"));
                        goto Unbroken;
                        }

                case chEol:
                case chNewLine:
                    ifi.chBreak = ch;
                    vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch;
                    vfli.xpReal = ifi.xp;
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    vfli.dypFont = dypAscentMac + (vfli.dypBase =
                      dypDescentMac);
                    Dfli(CommSzNumNum("    vfli.xpReal, ichMac ",vfli.xpReal,vfli.ichMac));


                    if (ch == chHyphen || ch == chNRHFile)
                        {
                        Dfli(CommSz("    chHyph/OptHyph catch \n\r"));
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    else
                        {
                        if (!ifi.fPrevSpace)
                            {
                            Dfli(CommSz("!fPrevSpace \n\r"));
                            ifi.cBreak = ifi.cchSpace;
                            vfli.ichReal = ifi.ich - 1;
                            ifi.xpReal = (vfli.xpReal = ifi.xp) - dxp;
                            }
                        if (ch == chEol || ch == chNewLine)
                            {

#ifdef CASHMERE
                            if (hfntb != 0 && vfli.cpMac ==
                              (**hfntb).rgfnd[0].cpFtn)
                                {
                                /* End of footnote */
                                if (!fFlmPrinting)
                                    {
                                    vfli.rgch[ifi.ich - 1] = chEMark;
                                    vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                      DxpFromCh(chEMark, false)) - dxp;
                                    vfli.ichReal++;     /* show this guy */
                                    }
                                }
                            else
#endif /* CASHMERE */
                                {

#ifdef CASHMERE
                                int chT = fVisiMode ? ChVisible(ch) : chSpace;
#else /* not CASHMERE */
                                int chT = chSpace;
#endif /* not CASHMERE */

                                int dxpNew = DxpFromCh(chT, fFlmPrinting);

                                vfli.rgch[ifi.ich - 1] = chT;
                                vfli.rgdxp[ifi.ich - 1] = dxpNew;

                                vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                    dxpNew) - dxp;


                                if (!ifi.fPrevSpace)
                                    {
                                    vfli.xpReal += dxpNew - dxp;
#ifdef CASHMERE
                                    vfli.ichReal =
                                         fVisiMode ? ifi.ich : ifi.ich - 1;
#else /* not CASHMERE */
                                    vfli.ichReal = ifi.ich - 1;
#endif /* not CASHMERE */
                                    }
                                }


                            if (ch == chEol)
                                {
JustEol:
                                if (fFlmPrinting)
                                    {
                                    vfli.ichMac = vfli.ichReal;
                                    }
                                if (ifi.jc != jcTabLeft)
                                    {
                                    /* Handle last tab's text */
                                    Justify(&ifi, xpTab, flm);
                                    }
                                else if ((ifi.jc = ppap->jc) != jcBoth &&
                                  ifi.jc != jcLeft)
                                    {
                                    /* Do line justification */
                                    Justify(&ifi, ifi.xpRight, flm);
                                    }
                                vfli.xpRight = ifi.xpRight;
                                goto EndFormat;
                                }
                            else
                                {
                                /* Handle a line break */
                                goto JustBreak;
                                }
                            }
                        ++ifi.cchSpace;
                        ifi.fPrevSpace = true;
                        }
                    break;

DefaultCh:

                default:

#ifdef DFLI                    
                    {
                    char rgch[100];
                    wsprintf(rgch,"  DefaultCh: %c, xp==%d/%d, xpPr==%d/%d\n\r", 
                        ch, ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif /* ifdef DFLI */
                    
                    if (ifi.xpPr > ifi.xpPrRight)
DoBreak:
                        {
                        Dfli(CommSz("    BREAK!\n\r"));
                        if (ifi.chBreak == 0)
Unbroken:
                            {
                            /* Admit first character to the line, even if margin
                            is crossed.  First character at ifi.ich - 1 may be
                            preceded by 0 width characters. */
#ifdef DBCS
                            if (IsDBCSLeadByte(ch))
                                {
                                if (FFirstIch(ifi.ich-2) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-2;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 2;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
                                vfli.xpReal = ifi.xpReal = ifi.xp - (dxp * 2);
                                }
                            else
                                {
                                if (FFirstIch(ifi.ich-1) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-1;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
                                vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
                                }
#else
                            if (FFirstIch(ifi.ich - 1) && ifi.ich < ichMaxLine)
                                {
                                goto PChar;
                                }
                            vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch - 1;
                            vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                            vfli.dypLine = ifi.dypLineSize;
                            vfli.dypFont = dypAscentMac + (vfli.dypBase =
                              dypDescentMac);
                            vfli.dcpDepend = 1;
                            vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
#endif
                            goto DoJustify;
                            }

                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
JustBreak:
                        if (ifi.chBreak == chNRHFile)
                            {
                            /* Append a non-required hyphen to the end of the
                            line. (Replace zero length tab previously
                            inserted)  */

                            Dfli(CommSz("    Breaking line at OptHyphen\n\r"));
                            ifi.xpReal += (vfli.rgdxp[vfli.ichReal - 1] =
                              DxpFromCh(chHyphen, fFlmPrinting));
                            vfli.xpRight = vfli.xpReal = ifi.xpReal;
                            vfli.rgch[vfli.ichReal - 1] = chHyphen;
                            vfli.ichMac = vfli.ichReal;
                            if (ichpNRH < ichpFormat - 1)
                                {
                                register struct CHP *pchp =
                                  &(**vhgchpFormat)[ichpNRH];

                                pchp->cchRun++;
                                if (pchp->ichRun >= vfli.ichMac)
                                    {
                                    pchp->ichRun = vfli.ichMac - 1;
                                    }
                                }
                            }

                        if (fFlmPrinting)
                            {
                            vfli.ichMac = vfli.ichReal;
                            }
                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        else
                            {
DoJustify:
                            if ((ifi.jc = ppap->jc) != jcLeft)
                                {
                                Dfli(CommSzNum("    DoJustify: xpRight ",ifi.xpRight));
                                Justify(&ifi, ifi.xpRight, flm);
                                }
                            }
                        vfli.xpRight = ifi.xpRight;
EndFormat:
                        vfli.ichLastTab = ifi.ichLeft;

#ifdef CASHMERE
                        if (vfli.cpMac == vcpLimParaCache)
                            {
                            vfli.dypAfter = vpapAbs.dyaAfter / DyaPerPixFormat;
                            vfli.dypLine += vfli.dypAfter;
                            vfli.dypBase += vfli.dypAfter;
                            }
#endif /* CASHMERE */

                        Scribble(5, ' ');
                        return;
                        }
                    else
                        {
PChar:
                        /* A printing character */
                        ifi.fPrevSpace = false;
                        }
                    break;

                }       /* Switch */
            }
        }       /* for ( ; ; ) */

    Scribble(5, ' ');
    }


/* J U S T I F Y */
near Justify(pifi, xpTab, flm)
struct IFI *pifi;
unsigned xpTab;
int flm;
    {
    int dxp;
    int ichT;
    int xpLeft;


    xpLeft = pifi->xpLeft;
    switch (pifi->jc)
        {
        CHAR *pch;
        unsigned *pdxp;

#ifdef CASHMERE
        case jcTabLeft:
        case jcLeft:
            return;

        case jcTabRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcTabCenter:
            dxp = (xpTab - xpLeft) - ((pifi->xpReal - xpLeft + 1) >> 1);
            break;
#endif /* CASHMERE */

        case jcTabDecimal:
            dxp = xpTab - xpLeft;
            for (ichT = pifi->ichLeft + 1; ichT < vfli.ichReal &&
              vfli.rgch[ichT] != vchDecimal; ichT++)
                {
                dxp -= vfli.rgdxp[ichT];
                }
            break;

        case jcCenter:
            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                return;
                }
            dxp = dxp >> 1;
            break;

        case jcRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcBoth:
            if (pifi->cBreak == 0)
                {
                /* Ragged edge forced */
                return;
                }

            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                /* There is nothing to do. */
                return;
                }

            pifi->xp += dxp;
            vfli.xpReal += dxp;
            vfli.dxpExtra = dxp / pifi->cBreak;

            /* Rounding becomes a non-existant issue due to brilliant
            re-thinking.
                "What a piece of work is man
                How noble in reason
                In form and movement,
                how abject and admirable..."

                        Bill "Shake" Spear [describing Sand Word] */
                {
                register CHAR *pch = &vfli.rgch[vfli.ichReal];
                register int *pdxp = &vfli.rgdxp[vfli.ichReal];
                int dxpT = dxp;
                int cBreak = pifi->cBreak;
                int cxpQuotient = (dxpT / cBreak) + 1;
                int cWideSpaces = dxpT % cBreak;

                vfli.fAdjSpace = fTrue;

                for ( ; ; )
                    {
                    /* Widen blanks */
                    --pch;
                    --pdxp;
                    if (*pch == chSpace)
                        {
                        if (cWideSpaces-- == 0)
                            {
                            int *pdxpT = pdxp + 1;

                            while (*pdxpT == 0)
                                {
                                pdxpT++;
                                }
                            vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            cxpQuotient--;
                            }
                        *pdxp += cxpQuotient;
                        if ((dxpT -= cxpQuotient) <= 0)
                            {
                            if (pifi->cBreak > 1)
                                {
                                int *pdxpT = pdxp + 1;

                                while (*pdxpT == 0)
                                    {
                                    pdxpT++;
                                    }
                                vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                }
                            return;
                            }
                        pifi->cBreak--;
                        }
                    }
                }
        }       /* Switch */

    if (dxp <= 0)
        {
        /* Nothing to do */
        return;
        }

    pifi->xp += dxp;

    if (flm & flmPrinting)
        {
        pifi->xpPr += dxp;
        }
    else
        {
        /* This statememt might introduce rounding errors in pifi->xpPr, but
        with luck, they will be small. */
        pifi->xpPr += MultDiv(MultDiv(dxp, czaInch, dxpLogInch), dxpPrPage,
          dxaPrPage);
        }

    if (pifi->ichLeft < 0)
        {
        /* Normal justification */
        vfli.xpLeft += dxp;
        }
    else
        {
        /* Tab justification */
        vfli.rgdxp[pifi->ichLeft] += dxp;
        }
    vfli.xpReal += dxp;
    }


/* F  G R O W  F O R M A T  H E A P */
int near FGrowFormatHeap()
    {
    /* Grow vhgchpFormat by 20% */
    int cchpIncr = ichpMacFormat / 5 + 1;

#ifdef WINHEAP
    if (!LocalReAlloc((HANDLE)vhgchpFormat, (ichpMacFormat + cchpIncr) * cchCHP,
      NONZEROLHND))
#else /* not WINHEAP */
    if (!FChngSizeH(vhgchpFormat, (ichpMacFormat + cchpIncr) * cwCHP, false))
#endif /* not WINHEAP */

        {
        /* Sorry, charlie */
        return false;
        }
    ichpMacFormat += cchpIncr;
    return true;
    }


/* #define DBEMG */
/* D X P  F R O M  C H */
#ifdef DBCS
/* DxpFromCh() assumes that ch passed is the first byte of a DBCS character
   if it is a part of such character. */
#endif
int DxpFromCh(ch, fPrinter)
int ch;
int fPrinter;
    {
    int               *pdxp; // changed to int (7.23.91) v-dougk
    int               dxpDummy; // changed to int (7.23.91) v-dougk

    extern int        dxpLogCh;
    extern struct FCE *vpfceScreen;

    /* If the width is not in the width table, then get it. */
    if (ch < chFmiMin)
        {
        switch (ch)
            {
        case chTab:
        case chEol:
        case chReturn:
        case chSect:
        case chNewLine:
        case chNRHFile:
            /* the width for these characters aren't really important */
	    pdxp = (CHAR *)(fPrinter ? &vfmiPrint.dxpSpace : &vfmiScreen.dxpSpace);
            break;
        default:
            pdxp = &dxpDummy;
            *pdxp = dxpNil;
            break;
            }
        }
    else if (ch >= chFmiMax)
        {
        /* outside the range we hold in our table - kludge it */
        pdxp = &dxpDummy;
        *pdxp = dxpNil;
        }
    else
        {
        /* inside our table */
        pdxp = (fPrinter ? vfmiPrint.mpchdxp : vfmiScreen.mpchdxp) + ch;
        }

#ifdef DBCS
    if (*pdxp == dxpNil && IsDBCSLeadByte(ch) )
        {
        int dxp;
#else
    if (*pdxp == dxpNil)
        {
        int dxp;
#endif

#ifdef DBCS
        struct FMI *pfmi;
        int        rgchT[cchDBCS]; // changed to int (7.23.91) v-dougk
        int        dxpT;
        int        dxpDBCS;

        pfmi = fPrinter ? (&vfmiPrint) : (&vfmiScreen);
        Assert(pfmi->bDummy == dxpNil);
        if (pfmi->dxpDBCS == dxpNil)
            {
            /* Get the width from GDI. */
            rgchT[0] = rgchT[1] = ch;
            dxpDBCS = (fPrinter ?
                            LOWORD(GetTextExtent(vhDCPrinter,
                                                 (LPSTR) rgchT, cchDBCS)) :
                            LOWORD(GetTextExtent(vhMDC,
                                                 (LPSTR) rgchT, cchDBCS)));
            /* Store in fmi, if it fits. */
            if (0 <= dxpDBCS && dxpDBCS < dxpNil)
                pfmi->dxpDBCS = (BYTE) dxpDBCS;
            return (dxpDBCS - pfmi->dxpOverhang);
            }
        else
            return (pfmi->dxpDBCS - pfmi->dxpOverhang);
        }
    else {
        int dxp;
#endif /* DBCS */
        /* get width from GDI */
        dxp = fPrinter ? LOWORD(GetTextExtent(vhDCPrinter, (LPSTR)&ch, 1)) -
          vfmiPrint.dxpOverhang : LOWORD(GetTextExtent(vhMDC, (LPSTR)&ch, 1)) -
          vfmiScreen.dxpOverhang;
#ifdef DBEMG
            CommSzNum("Get this.... ", dxp);
#endif
        //(7.24.91) v-dougk if (dxp >= 0 && dxp < dxpNil)
            {
            /* only store dxp's that fit in a byte */
            *pdxp = dxp;
            }

#ifdef DBEMG
        {
        char szT[10];
        CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
        if (ch == 0x0D) {
            szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
            }
        else if (ch == 0x0A) {
            szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
            }
        else if (32 <= ch && ch <= 126) {
            szT[0] = ch; szT[1] ='\0';
            }
        else if (FKanji1(ch)) {
            szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
            szT[4] = 'I'; szT[5] = '\0';
            }
        else {
            szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
            }
        CommSzSz("Character: ", szT);
        CommSzNum("Dxp:      ", (int) dxp);
        CommSzNum("OverHang: ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
        }
#endif
        return(dxp);
        }

#ifdef DBEMG
    {
    char szT[10];
    CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
    if (ch == 0x0D) {
        szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
        }
    else if (ch == 0x0A) {
        szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
        }
    else if (32 <= ch && ch <= 126) {
        szT[0] = ch; szT[1] ='\0';
        }
    else if (FKanji1(ch)) {
        szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
        szT[4] = 'I'; szT[5] = '\0';
        }
    else {
        szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
        }
    CommSzSz("Character: ", szT);
    CommSzNum("Dxp:       ", (int) *pdxp);
    CommSzNum("OverHang:  ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
    }
#endif
    return(*pdxp);
    }


/* F  F I R S T  I C H */
int near FFirstIch(ich)
int ich;
    {
    /* Returns true iff ich is 0 or preceded only by 0 width characters */
    register int ichT;
    register int *pdxp = &vfli.rgdxp[0];

    for (ichT = 0; ichT < ich; ichT++)
        {
        if (*pdxp++)
            {
            return false;
            }
        }
    return true;
    }


ValidateMemoryDC()
    {
    /* Attempt to assure that vhMDC and vhDCPrinter are valid.  If we have not
    already run out of memory, then vhDCPrinter is guaranteed, but vhMDC may
    fail due to out of memory -- it is the callers responsibility to check for
    vhMDC == NULL. */

    extern int vfOutOfMemory;
    extern HDC vhMDC;
    extern BOOL vfMonochrome;
    extern long rgbText;
    extern struct WWD *pwwdCur;

    /* If we are out of memory, then we shouldn't try to gobble it up by getting
    DC's. */
    if (!vfOutOfMemory)
        {
        if (vhMDC == NULL)
            {
            /* Create a memory DC compatible with the screen if necessary. */
            vhMDC = CreateCompatibleDC(pwwdCur->hDC);

            /* Callers are responsible for checking for vhMDC == NULL case */
            if (vhMDC != NULL)
                {
                /* Put the memory DC in transparent mode. */
                SetBkMode(vhMDC, TRANSPARENT);

                /* If the display is a monochrome device, then set the text
                color for the memory DC.  Monochrome bitmaps will not be
                converted to the foreground and background colors in this case,
                we must do the conversion. */
                if (vfMonochrome = (GetDeviceCaps(pwwdCur->hDC, NUMCOLORS) ==
                  2))
                    {
                    SetTextColor(vhMDC, rgbText);
                    }
                }
            }

        /* If the printer DC is NULL then we need to reestablish it. */
        if (vhDCPrinter == NULL)
            {
            GetPrinterDC(FALSE);
            /* GetPrinterDC has already called SetMapperFlags() on vhDCPrinter. */
            }
        }
    }




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fontdlg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Fontdlg.c -- WRITE font dialog routines */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"

#ifndef JAPAN //T-HIROYN Win3.1
#define NOUAC
#endif

#include "cmddefs.h"
#include "dlgdefs.h"
#include "propdefs.h"
#include "fontdefs.h"
#include "prmdefs.h"
#include "str.h"
#include "docdefs.h"
#include <commdlg.h>

#ifdef JAPAN //T-HIROYN Win3.1 and added  02 Jun. 1992  by Hiraisi
#include <dlgs.h>
#include <ctype.h>
#include "kanji.h"
BOOL FAR PASCAL _export DeleteFacename( HWND , UINT , WPARAM , LPARAM );
static BOOL NEAR PASCAL KanjiCheckAddSprm(HWND, int, int);
extern int ferror;	//01/21/93
#elif defined(KOREA)  // jinwoo : 10/14/92  : remove @Facename
#include <dlgs.h>
BOOL FAR PASCAL _export DeleteFacename( HWND , UINT , WPARAM , LPARAM );
#endif

extern HDC              vhDCPrinter;
extern struct DOD     (**hpdocdod)[];
extern HANDLE         hMmwModInstance;
extern HANDLE         hParentWw;
extern int            vfSeeSel;
extern int            docCur;
extern HWND           vhWndMsgBoxParent;
extern int            vfCursorVisible;
extern HCURSOR        vhcArrow;

extern int iszSizeEnum;
extern int iszSizeEnumMac;
extern int iszSizeEnumMax;
extern int iffnEnum;
extern int vfFontEnumFail;
extern struct FFNTB **hffntbEnum;


BOOL NEAR FValidateEnumFfid(struct FFN *);

int FAR PASCAL NewFont(HWND hwnd)
{
    TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP */
    int ftc;
    int fSetUndo;
    CHAR rgb[2];
    CHOOSEFONT cf;
    LOGFONT lf;
    HDC hdc;

#if defined(JAPAN) || defined(KOREA) // added  02 Jun. 1992  by Hiraisi : jinwoo 11/10/92
    FARPROC lpfnDeleteFacename;
    int Result;
#endif

    if (!vhDCPrinter)
            return FALSE;

    GetRgtsvChpSel(rgtsv);

    bltbc(&lf, 0, sizeof(LOGFONT));
    bltbc(&cf, 0, sizeof(CHOOSEFONT));

    cf.lStructSize    = sizeof(cf);
    cf.hwndOwner      = hwnd;
    cf.lpLogFont      = &lf;
    cf.hDC        = vhDCPrinter;
    cf.nSizeMin   = 4;
    cf.nSizeMax   = 127;
#ifdef JAPAN	//#3902 T-HIROYN
    cf.Flags      = CF_PRINTERFONTS | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
#elif defined(KOREA)                                 // MSCH bklee 01/26/95
    cf.Flags      = CF_NOSIMULATIONS| CF_PRINTERFONTS /*| CF_ANSIONLY*/ | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
#else
    cf.Flags      = CF_NOSIMULATIONS| CF_PRINTERFONTS | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
#endif

#if defined(JAPAN) || defined(KOREA)   // added  02 Jun. 1992  by Hiraisi : jinwoo 11/10/92
    cf.Flags |= CF_ENABLEHOOK;
    lpfnDeleteFacename = MakeProcInstance( DeleteFacename, hMmwModInstance );
    cf.lpfnHook = (FARPROC)lpfnDeleteFacename;
#endif

    // check for multiple sizes selected
    if (rgtsv[itsvSize].fGray) {
        cf.Flags |= CF_NOSIZESEL;
    } else {
        hdc = GetDC(NULL);
        lf.lfHeight = -MulDiv(rgtsv[itsvSize].wTsv / 2, GetDeviceCaps(hdc, LOGPIXELSY), 72);
        ReleaseDC(NULL, hdc);
    }

    // check for multiple faces selected
    if (rgtsv[itsvFfn].fGray) {
        cf.Flags |= CF_NOFACESEL;
        lf.lfFaceName[0] = 0;
    } else {
        struct FFN **hffn;
        /* then, font name */

        /* note that the value stored in rgtsv[itsvFfn].wTsv
            is the font name handle, rather than the ftc */

        hffn = (struct FFN **)rgtsv[itsvFfn].wTsv;
        lstrcpy(lf.lfFaceName, (*hffn)->szFfn);
    }

    // check for multiple styles selected
        if (rgtsv[itsvBold].fGray || rgtsv[itsvItalic].fGray) {
        cf.Flags |= CF_NOSTYLESEL;
    } else {
            lf.lfWeight = rgtsv[itsvBold].wTsv ? FW_BOLD : FW_NORMAL;
        lf.lfItalic = rgtsv[itsvItalic].wTsv;
    }

#if defined(JAPAN) || defined(KOREA)   // added  02 Jun. 1992  by Hiraisi : jinwoo 11/10/92
    Result = ChooseFont(&cf);
    FreeProcInstance( lpfnDeleteFacename );
    if (!Result)
        return FALSE;
#else
    if (!ChooseFont(&cf))
        return FALSE;
#endif    // JAPAN

    fSetUndo = TRUE;

    if (!(cf.Flags & CF_NOFACESEL))
        {
            CHAR rgbFfn[ibFfnMax];
        struct FFN *pffn = (struct FFN *)rgbFfn;

        lstrcpy(pffn->szFfn, lf.lfFaceName);
            pffn->ffid = lf.lfPitchAndFamily & grpbitFamily;
            pffn->chs  = lf.lfCharSet;

        FValidateEnumFfid(pffn);

            ftc = FtcChkDocFfn(docCur, pffn);

            if (ftc != ftcNil) {
#ifdef JAPAN //T-HIROYN Win3.1
                if ( pffn->chs == NATIVE_CHARSET ||
                    FALSE == KanjiCheckAddSprm(hwnd, ftc, fSetUndo) ) {
                    rgb[0] = sprmCFtc;
                rgb[1] = ftc;
            AddOneSprm(rgb, fSetUndo);
                }
                fSetUndo = FALSE;
				if(ferror)		//01/21/93
					return TRUE;
#else
        rgb[0] = sprmCFtc;
        rgb[1] = ftc;
        AddOneSprm(rgb, fSetUndo);
#ifdef KKBUGFIX
// when font name was changed we can't undo
                fSetUndo = FALSE;
#endif
#endif
            }
    }

    if (!(cf.Flags & CF_NOSIZESEL)) {
            /* we got a value */
            rgb[0] = sprmCHps;
            rgb[1] = cf.iPointSize / 10 * 2; /* KLUDGE alert */
            AddOneSprm(rgb, fSetUndo);
            fSetUndo = FALSE;
    }

    if (!(cf.Flags & CF_NOSTYLESEL)) {
#ifdef KKBUGFIX //T-HIROYN Win3.1
// when font name was changed we can't undo
        ApplyCLooksUndo(sprmCBold, lf.lfWeight > FW_NORMAL, fSetUndo);
            fSetUndo = FALSE;
        ApplyCLooksUndo(sprmCItalic, lf.lfItalic ? 1 : 0, fSetUndo);
#else
        ApplyCLooks(0, sprmCBold, lf.lfWeight > FW_NORMAL);
        ApplyCLooks(0, sprmCItalic, lf.lfItalic ? 1 : 0);
#endif
        }

        return TRUE;
}

BOOL NEAR FValidateEnumFfid(pffn)
/* if the described ffn is in the enumeration table, then make sure we have
   a good family number for it */

struct FFN *pffn;
    {
    int ftc;
    struct FFN *pffnAlready;

    ftc = FtcScanFfn(hffntbEnum, pffn);
    if (ftc != ftcNil)
        {
        pffnAlready = *((*hffntbEnum)->mpftchffn[ftc]);
#ifdef JAPAN
        // Few fonts would be enumnrated with FF_DONTCARE in JAPAN
        // we won't check ffid here.
#else
        if (pffnAlready->ffid != FF_DONTCARE)
#endif
            {
            pffn->ffid = pffnAlready->ffid;
#ifdef NEWFONTENUM
            pffn->chs = pffnAlready->chs;
#endif
            return(TRUE);
            }
        }
    return(FALSE);
    }

#ifdef JAPAN //T-HIROYN Win3.1
/*  When you want to change font name,
    if include japanese string in select string
    then don't change only japanese string
    but change alpha string
*/

extern CHAR szAppName[];
extern struct SEL   selCur;
extern struct CHP   vchpFetch;
extern int          vcchFetch;
extern int          vccpFetch;
extern  CHAR        *vpchFetch;
extern typeCP       vcpFetch;
BOOL	FontChangeDBCS = FALSE; //01/21/93

static BOOL NEAR PASCAL KanjiCheckAddSprm(hwnd, alphaftc, fSetUndo)
HWND hwnd;
int  alphaftc;                    //Not KANJI_CHARSET
int  fSetUndo;
{
    typeCP CpLimNoSpaces(typeCP, typeCP);
    static BOOL NEAR KanjiCheckSelect();
    static BOOL NEAR PASCAL GetSelCur(typeCP *, typeCP *, typeCP);

    CHAR    rgb[2];
    struct  SEL selSave;
    typeCP  cpLim, cpFirst, dcp, cpSt, cpEnd;

    if (selCur.cpFirst == selCur.cpLim)
        return(FALSE);

    /* include japanese string ? */
    if( KanjiCheckSelect() ) {   // Yes
        char szMsg[cchMaxSz];
        PchFillPchId( szMsg, IDPMTNotKanjiFont, sizeof(szMsg) );
        MessageBox(hwnd, (LPSTR)szMsg, (LPSTR)szAppName,
                            MB_OK | MB_ICONEXCLAMATION);
    }
    else
        return(FALSE);

    selSave = selCur;

    cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);

    cpFirst = selCur.cpFirst;

    dcp = cpLim - cpFirst;

    if (fSetUndo) {
        SetUndo(uacReplNS, docCur, cpFirst, dcp, docNil, cpNil, dcp, 0);
        fSetUndo = FALSE;
    }

    cpEnd = cpFirst;

	FontChangeDBCS = TRUE;	//01/21/93

    while(TRUE) {
        cpSt = cpEnd;
        if( FALSE == GetSelCur(&cpSt, &cpEnd, cpLim))
            break;
        rgb[0] = sprmCFtc;
        rgb[1] = alphaftc;

        selCur.cpFirst = cpSt;
        selCur.cpLim = cpEnd;

        AddOneSprm(rgb, fSetUndo);

		if (ferror) //01/21/93
			break;
    }

	FontChangeDBCS = FALSE;	//01/21/93

	if(ferror) {            //01/21/93
	    vfSeeSel = TRUE;
		selCur.cpFirst = selCur.cpLim = cpSt;
	} else {
	    selCur = selSave;
	}

    return(TRUE);
}

static BOOL NEAR PASCAL GetSelCur(cpSt,cpEnd,cpLim)
typeCP  *cpSt, *cpEnd, cpLim;
{
    static BOOL NEAR PASCAL GetSelCurStart(typeCP *, typeCP);
    static void NEAR PASCAL GetSelCurEnd(typeCP *,typeCP *, typeCP);

    if(FALSE == GetSelCurStart(cpSt,cpLim))
        return(FALSE);

    GetSelCurEnd(cpSt,cpEnd,cpLim);

    return(TRUE);
}

static BOOL NEAR PASCAL GetSelCurStart(cpSt,cpLim)
typeCP *cpSt, cpLim;
{
    int cch;
    CHAR *cp;
    CHAR ch;
	BOOL DBCSbundan = FALSE; // 02/12/93 bug fix

    if(*cpSt == cpLim)
        return(FALSE);

    FetchCp(docCur, *cpSt, 0, fcmChars);

    while(TRUE) {
        for(cch = 0,cp = vpchFetch; cch < vccpFetch; cch++,cp++) {

            if((vcpFetch + (typeCP)cch) >= cpLim)
                return(FALSE);

            ch = *cp;

            if( FKana(ch))
                 ;
            else if( IsDBCSLeadByte(ch) ) {
                cp++; cch++;
				if(cch >= vccpFetch) {  // 02/12/93 bug fix
					DBCSbundan = TRUE;
					break;
				}
            } else if (isprint(ch)) {
                *cpSt = vcpFetch + (typeCP)cch;
                return(TRUE);
            }
        }

        if((vcpFetch + (typeCP)cch) >= cpLim)
            return(FALSE);

		if(DBCSbundan) {	// 02/12/93 bug fix
		    FetchCp(docCur, vcpFetch + (typeCP)(cch+1), 0, fcmChars);
			DBCSbundan = FALSE;
		} else
    	    FetchCp(docNil, cpNil, 0, fcmChars);
    }
}

static void NEAR PASCAL GetSelCurEnd(cpSt,cpEnd,cpLim)
typeCP *cpSt, *cpEnd, cpLim;
{
    int cch;
    CHAR *cp;
    CHAR ch;

    FetchCp(docCur, *cpSt, 0, fcmChars);

    while(TRUE) {
        for(cch = 0,cp = vpchFetch; cch < vccpFetch; cch++,cp++) {

            if((vcpFetch + (typeCP)cch) >= cpLim) {
                *cpEnd = cpLim;
                return;
            }

            ch = *cp;
            if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                *cpEnd = vcpFetch + (typeCP)cch;
                return;
            }
        }

        if((vcpFetch + (typeCP)cch) >= cpLim) {
            *cpEnd = cpLim;
            return;
        }

        FetchCp(docNil, cpNil, 0, fcmChars);
    }
}

static BOOL NEAR KanjiCheckSelect()
{
    typeCP  CpLimNoSpaces(typeCP, typeCP);
    typeCP  cpLim;
    CHAR    *cp;
    CHAR    ch;
    int     cch;

    cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);
//    FetchCp(docCur, selCur.cpFirst, 0, fcmChars);
    FetchCp(docCur, selCur.cpFirst, 0,fcmBoth + fcmParseCaps);

    while(TRUE) {
        if(NATIVE_CHARSET == GetCharSetFromChp(&vchpFetch)) {
            for(cch = 0,cp = vpchFetch; cch < vccpFetch; cch++,cp++) {

                if((vcpFetch + (typeCP)cch) >= cpLim)
                    return(FALSE);

                ch = *cp;
                if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                    return(TRUE);
                }
            }
        }

        if((vcpFetch + (typeCP)vccpFetch) >= cpLim)
            return(FALSE);

        FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
    }

}

int FAR PASCAL GetKanjiStringLen(cch, cchF, cp)
int     cch, cchF;
CHAR    *cp;
{
    int cblen = 0;

    for (; cch+cblen < cchF; cp++ ){
        if( FKana(*cp) )
            cblen++;
        else if( IsDBCSLeadByte(*cp) ) {
            cblen += 2;
            cp++;
        } else
            break;
    }
    return(cblen);
}

int FAR PASCAL GetAlphaStringLen(cch, cchF, cp)
int     cch, cchF;
CHAR    *cp;
{
    int cblen = 0;

    for (; cch+cblen < cchF; cp++ ) {
        if( FKana(*cp) || IsDBCSLeadByte(*cp))
            break;
        else
            cblen++;
    }
    return(cblen);
}
// 02/15/93 add T-HIROYN 2 function
int FAR PASCAL GetFtcFromPchp(pchp)
struct CHP *pchp;
{
	int ftc;
	ftc = pchp->ftc + (pchp->ftcXtra << 6);
	return ftc;
}

int FAR PASCAL SetFtcToPchp(pchp, ftc)
struct CHP *pchp;
int	ftc;
{
	pchp->ftc = ftc & 0x003f;
	pchp->ftcXtra = (ftc & 0x00c0) >> 6;
}


// added  02 Jun. 1992  by Hiraisi
/*
 *  This function deletes facename(s) with @-prefix
 * from FONT combobox(cmb1) of the CHOOSEFONT dialog.
*/
BOOL FAR PASCAL _export DeleteFacename( hDlg, uMsg, wParam, lParam )
HWND hDlg;
UINT uMsg;
WPARAM wParam;
LPARAM lParam;
{
    char str[50], sel[50];
    int ix;
    int cnt;

    if( uMsg != WM_INITDIALOG )
        return FALSE;

    cnt = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCOUNT, 0, 0L );
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCURSEL, 0, 0L );
    SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)sel );
    for( ix = 0 ; ix < cnt ; ){
        SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)str );
        if( str[0] == '@' )
            cnt = (int)SendDlgItemMessage( hDlg,cmb1,CB_DELETESTRING,ix,NULL );
        else
            ix++;
    }
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_FINDSTRING, -1, (DWORD)sel );
    SendDlgItemMessage( hDlg, cmb1, CB_SETCURSEL, ix, 0L );

    return  TRUE;
}
#elif defined(KOREA)     // jinwoo : 10/14/92
// added  02 Jun. 1992  by Hiraisi
/*
 *  This function deletes facename(s) with @-prefix
 * from FONT combobox(cmb1) of the CHOOSEFONT dialog.
*/
BOOL FAR PASCAL _export DeleteFacename( hDlg, uMsg, wParam, lParam )
HWND hDlg;
UINT uMsg;
WPARAM wParam;
LPARAM lParam;
{
    char str[50], sel[50];
    int ix;
    int cnt;

    if( uMsg != WM_INITDIALOG )
        return FALSE;

    cnt = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCOUNT, 0, 0L );
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_GETCURSEL, 0, 0L );
    SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)sel );
    for( ix = 0 ; ix < cnt ; ){
        SendDlgItemMessage( hDlg, cmb1, CB_GETLBTEXT, ix, (DWORD)str );
        if( str[0] == '@' )
            cnt = (int)SendDlgItemMessage( hDlg,cmb1,CB_DELETESTRING,ix,NULL );
        else
            ix++;
    }
    ix = (int)SendDlgItemMessage( hDlg, cmb1, CB_FINDSTRING, -1, (DWORD)sel );
    SendDlgItemMessage( hDlg, cmb1, CB_SETCURSEL, ix, 0L );

    return  TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\fontutil.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* FontUtil.c -- font table management routines */

#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "debug.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "printdef.h"
#include "fontdefs.h"

extern struct DOD       (**hpdocdod)[];


struct FFNTB **HffntbAlloc()
/* returns empty ffntb */
{
struct FFNTB **hffntb;
int cwAlc;

cwAlc = CwFromCch(sizeof(struct FFNTB) - cffnMin * sizeof(struct FFN **));
if (!FNoHeap(hffntb = (struct FFNTB **)HAllocate(cwAlc)))
        {
        (*hffntb)->iffnMac = 0;
        (*hffntb)->fFontMenuValid = FALSE;
        }
return(hffntb);
}



FtcAddDocFfn(doc, pffn)
/* adds the described ffn to the ffntb for this doc - returns ftcNil if the
   allocation failed */

int doc;
struct FFN *pffn;
{
struct FFNTB **hffntb;

hffntb = HffntbGet(doc);
if (hffntb == 0)
        {
        hffntb = HffntbAlloc();
        if (FNoHeap(hffntb))
                return(ftcNil);
        (**hpdocdod)[doc].hffntb = hffntb;
        }

return(FtcAddFfn(hffntb, pffn));
}



int FtcAddFfn(hffntb, pffn)
/* adds the described ffn to hffntb.  returns ftcNil if it fails */
struct FFNTB **hffntb;
struct FFN *pffn;

{
unsigned cb;
int cwAlloc, iffnMac, ftc;
FFID ffid;
struct FFN **hffn;

(*hffntb)->fFontMenuValid = FALSE;  /* so fonts on char dropdown get updated */
ftc = ftcNil;
ffid = pffn->ffid;

cb = CchSz( pffn->szFfn );
if (cb > LF_FACESIZE)
    {
    Assert( FALSE );    /* If we get here, the doc's font tables are prob. bad */
    cb = LF_FACESIZE;
    }
Assert( cb > 0 );

cwAlloc = CwFromCch( CbFfn( cb ) );
if (!FNoHeap(hffn = (struct FFN **)HAllocate(cwAlloc)))
        {
        blt(pffn, *hffn, cwAlloc);
        (*hffn)->szFfn[ cb - 1 ] = '\0';   /* In case of font name too big */

        iffnMac = (*hffntb)->iffnMac + 1;
        cwAlloc = CwFromCch(sizeof(struct FFNTB) +
                        (iffnMac - cffnMin) * sizeof(struct FFN **));
        if (FChngSizeH(hffntb, cwAlloc, FALSE))
                {
                ftc = iffnMac - 1; /* ?! pault */
                (*hffntb)->mpftchffn[ftc] = hffn;
                (*hffntb)->iffnMac = iffnMac;
                }
        else
                {
                FreeH(hffn);
                }
        }

return(ftc);
}



FEnsurePffn(hffntb, pffn)
/* return TRUE if we were able to add the described font to the table - this
   routine is just a convenience, the other pieces aren't that complex to
   call. */

struct FFNTB **hffntb;
struct FFN *pffn;
{
if (FtcScanFfn(hffntb, pffn) != ftcNil ||
    FtcAddFfn(hffntb, pffn) != ftcNil)
        return(TRUE);
return(FALSE);
}



FtcScanDocFfn(doc, pffn)
/* looks for described font in docs ffntb - returns ftcNil if not found */

int doc;
struct FFN *pffn;
{
int ftc;
struct FFNTB **hffntb;

ftc = ftcNil;
hffntb = HffntbGet(doc);
if (hffntb != 0)
        ftc = FtcScanFfn(hffntb, pffn);

return(ftc);
}



FtcScanFfn(hffntb, pffn)
struct FFNTB **hffntb;
struct FFN *pffn;

{
int iffn, iffnMac;
struct FFN ***mpftchffn;

mpftchffn = (*hffntb)->mpftchffn;
iffnMac = (*hffntb)->iffnMac;
for (iffn = 0; iffn < iffnMac; iffn++)
        {
        if (WCompSz(pffn->szFfn, (*mpftchffn[iffn])->szFfn) == 0)
                {
                /* found it */
                if (pffn->ffid != FF_DONTCARE)
                {
                    /* maybe we discovered a family for this font? */
                    (*mpftchffn[iffn])->ffid = pffn->ffid;
                    (*mpftchffn[iffn])->chs  = pffn->chs;
                }
                return(iffn);
                }
        }
return(ftcNil);
}



FtcChkDocFfn(doc, pffn)
/* Adds described font to doc's ffntb if it's not already there - ftcNil is
   returned if it wasn't there and couldn't be added */

int doc;
struct FFN *pffn;
{
int ftc;

ftc = FtcScanDocFfn(doc, pffn);
if (ftc == ftcNil)
        ftc = FtcAddDocFfn(doc, pffn);

return(ftc);
}



FreeFfntb(hffntb)
struct FFNTB **hffntb;
{
int iffn, iffnMac;

if ((hffntb == 0) || FNoHeap(hffntb))
        /* nothing to do */
        return;

iffnMac = (*hffntb)->iffnMac;
for (iffn = 0; iffn < iffnMac; iffn++)
        FreeH((*hffntb)->mpftchffn[iffn]);
FreeH(hffntb);
}



SmashDocFce(doc)
/* the font table for this doc has scrambled, so we need to disassociate
   the corresponding cache entries from the doc */
int doc;

    {
    extern int vifceMac;
    extern union FCID vfcidScreen;
    extern union FCID vfcidPrint;
    extern struct FCE rgfce[ifceMax];
    int ifce;

    for (ifce = 0; ifce < vifceMac; ifce++)
        if (rgfce[ifce].fcidRequest.strFcid.doc == doc)
            rgfce[ifce].fcidRequest.strFcid.ftc = ftcNil;
    vfcidScreen.strFcid.ftc = ftcNil;
    vfcidPrint.strFcid.ftc = ftcNil;
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\format.asm ===
;* ****************************************************************************
;*
;*      COPYRIGHT (C) 1985-1992 MICROSOFT
;*
;* ****************************************************************************
;
        TITLE    Format.asm line formatting routines for windows Write
;  Module: format.asm
;     contains native code versions of FormatLine, Justify, FGrowFormatHeap,
;         FFirstIch, DxpFromCh, and ValidateMemoryDC
;
;*
;* REVISION HISTORY
;*
;* Date         Who Rel Ver     Remarks
;* 5/23/85      bz              initial translation from c
;* 6/21/85      bl              Set ?WIN == 0 for windows header
;* 7/09/85      pnt             Call WinFailure() if vhMDC == NULL
;* 7/16/85      pnt             Truncate tabs at right margin
;* 7/21/85      pnt             Treat running heads like normal paragraphs
;* 7/30/85      bl              Fixed bug in FFirstIch -- change scasb to scasw
;* 8/05/85      pnt             Added ValidateMemoryDC()
;* 8/05/85      pnt             DxpFromCh returns dxpSpace if ch < space
;* 8/07/85      pnt             cchCHPUsed changed from 9 to 7
;* 8/09/85      pnt             Ensure there tabs don't back up on the screen
;* 8/14/85      pnt             Map center and right tabs to left tabs
;* 8/27/85	pnt		Single spacing changed to font leading only
;* 8/29/85	pnt		Lines with no breaks can be right, center flush
;* 10/01/85	pnt		Forced section mark to be in stardard font
;* 10/07/85	pnt		DxpFromCh returns dxpSpace iff width unimportant
;* 10/10/85	pnt		Validity of vfli cache depends on flm
;* 10/10/85	pnt		fPrevSpace not set for null runs
;* 10/30/89 pault   set code to use SYSENDMARK code in FORM1.C
;* (7.23.91)    v-dougk         changed dxp char arrays to int arrays
SYSENDMARK EQU 1
;*
;* ************************************************************************* */

;* ************************************************************************* */
;          Naming conventions used here
;
;       rxx_name   register variable - reg is xx. This may be a temporary naming
;                       of a register (e.g. rax_ichT)
;       c_name     defined constant in c program (e.g. c_false)
;
;* ************************************************************************* */
        subttl Conditional variables and cmacros
        page

; *************** Conditional variables *************************
; ***** These variables should be defined using the -D command line
; ***** option in masm. They are only checked for being defined, not
; ***** for a particular value
;
; DEBUG   define with   -DDEBUG ; ** controls ASSERT code **
; SCRIBBLE  define with -DSCRIBBLE ; ** controls SCRIBBLE code **
; CASHMERE ; ** code taken out for Write, to be used for Cashmere **
;
; ***************  End conditional variables *************************

        memM =   1     ; medium model for cmacros
        ?WIN    = 1    ; windows header used here
        .xlist
        include cmacros.inc
        page
        .list
        ;.sall
        createSeg FORM1_TEXT,FORM1_TEXT,BYTE,PUBLIC,CODE

        ASSUME  CS: FORM1_TEXT, DS: DGROUP, SS: DGROUP, ES: DGROUP

        subttl Public definitions
        page
;
;   Public definitions for this module
;
PUBLIC  DxpFromCh
PUBLIC  FormatLine
PUBLIC  Justify
PUBLIC  FGrowFormatHeap
PUBLIC  FFirstIch
PUBLIC  ValidateMemoryDC

;
;   External procedures referenced from this module
;

EXTRN   IMAX:FAR
EXTRN   CCHDIFFER:FAR
EXTRN   CACHESECT:FAR
EXTRN   FCHNGSIZEH:FAR
EXTRN   CACHEPARA:FAR
EXTRN   FORMATGRAPHICS:FAR
EXTRN   FFORMATSPECIALS:FAR
EXTRN   MULTDIV:FAR
EXTRN   FETCHCP:FAR
EXTRN   SETTEXTJUSTIFICATION:FAR
EXTRN   GETTEXTEXTENT:FAR
EXTRN   LOADFONT:FAR
EXTRN   WINFAILURE:FAR
EXTRN   GETDEVICECAPS:FAR
EXTRN   SETBKMODE:FAR
EXTRN   SETTEXTCOLOR:FAR
EXTRN   CREATECOMPATIBLEDC:FAR
EXTRN	GETPRINTERDC:FAR

        ; **** Debugging code **********
IFDEF DEBUG
IFDEF SCRIBBLE
EXTRN   FNSCRIBBLE:FAR
ENDIF
ENDIF


        subttl External definitions
        page
;
;   External definitions referenced from this module
;
        sBegin DATA

EXTRN   PLOCALHEAP:WORD
;EXTRN   DOCHELP:WORD
EXTRN   VFLI:BYTE
EXTRN   VHGCHPFORMAT:WORD
EXTRN   ICHPMACFORMAT:WORD
EXTRN   VCHPABS:BYTE
EXTRN   VPAPABS:BYTE
EXTRN   VSEPABS:BYTE
EXTRN   VSEPPAGE:BYTE
EXTRN   VCHPNORMAL:BYTE
EXTRN   VCPFIRSTPARACACHE:DWORD
EXTRN   VCPFETCH:DWORD
EXTRN   YPSUBSUPER:WORD
EXTRN   VPCHFETCH:WORD
EXTRN   VCCHFETCH:WORD
EXTRN   YPSUBSUPERPR:WORD
EXTRN   VHMDC:WORD
EXTRN   VHDCPRINTER:WORD
EXTRN   DXPLOGINCH:WORD
EXTRN   DYPLOGINCH:WORD
EXTRN   DXAPRPAGE:WORD
EXTRN   DYAPRPAGE:WORD
EXTRN   DXPPRPAGE:WORD
EXTRN   DYPPRPAGE:WORD
EXTRN   DYPMAX:WORD
EXTRN   VFMISCREEN:BYTE
EXTRN   VFMIPRINT:BYTE
EXTRN   VFOUTOFMEMORY:WORD
EXTRN   VFMONOCHROME:WORD
EXTRN   RGBTEXT:DWORD
EXTRN   PWWDCUR:WORD
EXTRN   VCHDECIMAL:BYTE
EXTRN   VZATABDFLT:BYTE
        sEnd DATA

        ;sBegin BSS
        sBegin DATA
$S784_ichpFormat        DB 02H DUP (?)
        EVEN
        sEnd DAT
        ;sEnd BSS

        subttl Macros
        page
; ********************************************************************
; macros done here for speed, rather than doing far procedure call

;-----------------------------------------------------------------------------
; bltc (pTo, wFill, cw) - fills cw words of memory starting at pTo with wFill.
;-----------------------------------------------------------------------------
;  macro bltc destroys ax,es,cx

bltc    MACRO pTo,wFill,cw
        push    di
        mov     ax,ds               ; we are filling in the data segment
        mov     es,ax
        mov     di,pTo              ; get the destination, constant, and count
        mov     ax,wFill
        mov     cx,cw
        cld                         ; the operation is forward
        rep     stosw               ; fill memory
        pop     di
        ENDM

;-----------------------------------------------------------------------------
; bltbc (pTo, bFill, cb) - fills cb bytes of memory starting at pTo with
; bFill.
;-----------------------------------------------------------------------------

;  macro bltbc destroys ax,es,cx

bltbc   MACRO pTo,bFill,cb
        push    di
        mov     ax,ds               ; we are filling in the data segment
        mov     es,ax
        mov     di,pTo              ; get the destination, constant, and count
        mov     al,bFill
        mov     cx,cb
        cld                         ; the operation is forward
        rep     stosb               ; fill memory
        pop     di
        ENDM

;------------------------------------------------------------------------------
; blt (pFrom, pTo, cw) - a block transfer of wFills from pFrom to pTo;
; The size of the block is cw wFills.  This blt() handles the case of
; overlapping source and destination.  blt() returns a pointer to the
; end of the destination buffer (pTo + cw).  NOTE - use this blt() to
; to transfer within the current DS only--use the bltx for FAR blts.
;-----------------------------------------------------------------------------

;  macro blt destroys ax,bx,cx,es

blt     MACRO pFrom,pTo,cw
        local   blt1
        push    si
        push    di
        mov     si,pFrom            ; get pointers and length of blt
        mov     di,pTo
        mov     cx,cw
        mov     ax,ds               ; set up segment registers
        mov     es,ax
        mov     ax,di               ; calculate return value
        mov     bx,cx
        shl     bx,1
        add     ax,bx
        cmp     si,di               ; reverse direction of the blt if
        jae     blt1                ;  necessary

        dec     bx
        dec     bx
        add     si,bx
        add     di,bx
        std
blt1:
        rep     movsw
        cld
        pop     di
        pop     si
        ENDM


        subttl C structures Used in this module
        page
;
;       *** The following structure definitions were used when this module
;       *** was being developed:
;
;struct IFI
        ;{
        ;int             xp;
        ;int             xpLeft;
        ;int             xpRight;
        ;int             xpReal;
        ;int            xpPr;
        ;int            xpPrRight;
        ;int             ich;
        ;int             ichLeft;
        ;int             ichPrev;
        ;int             ichFetch;
        ;int             dypLineSize;
        ;int             cchSpace;
        ;int             cBreak;
        ;int             chBreak;
        ;int             jc;

;#ifdef CASHMERE
        ;int             tlc;
;#endif /* CASHMERE */

        ;int             fPrevSpace;
        ;};
; ***************************************************************************
; ***** Equates for IFI structure ifi offsets ****************

        IFI_STRUC       STRUC
        xp              DW      ?
        xpLeft_Ifi      DW      ?
        xpRight_Ifi     DW      ?
        xpReal_Ifi      DW      ?
        xpPr            DW      ?
        xpPrRight       DW      ?
        ich_Ifi         DW      ?
        ichLeft         DW      ?
        ichPrev         DW      ?
        ichFetch        DW      ?
        dypLineSize     DW      ?
        cchSpace        DW      ?
        cBreak_Ifi      DW      ?
        chBreak         DW      ?
        _jc             DW      ? ; (2.27.91) D. Kent
        fPrevSpace      DW      ?
        IFI_STRUC       ENDS

        oIfi_xp         EQU 0
        oIfi_xpLeft     EQU 2
        oIfi_xpRight    EQU 4
        oIfi_xpReal     EQU 6
        oIfi_xpPr       EQU 8
        oIfi_xpPrRight  EQU 10
        oIfi_ich        EQU 12
        oIfi_ichLeft    EQU 14
        oIfi_ichPrev    EQU 16
        oIfi_ichFetch   EQU 18
        oIfi_dypLineSize        EQU 20
        oIfi_cchSpace   EQU 22
        oIfi_cBreak     EQU 24
        oIfi_chBreak    EQU 26
        oIfi_jc         EQU 28
        oIfi_fPrevSpace EQU 30

        page
; ***************************************************************************

;/* Formatted line structure.
;Reorganized KJS, CS Sept 3 */
;/* booleans in bytes to simplify machine code */
;struct FLI
        ;{
        ;typeCP          cpMin;
        ;int             ichCpMin;
        ;typeCP          cpMac;
        ;int             ichCpMac;
        ;int             ichMac;
        ;int             dcpDepend;
        ;unsigned        fSplat : 8;
;/* First character in region where spaces have additional pixel */
        ;unsigned        ichFirstWide : 8;
;/* ichMac, with trailing blanks excluded */
        ;int             ichReal;
        ;int             doc;

        ;int             xpLeft;
        ;int             xpRight;
;/* xpRight, with trailing blanks excluded */
        ;int             xpReal;
;/* the right margin where insert will have to break the line */
        ;int             xpMarg;
;
        ;unsigned        fGraphics : 8;
        ;unsigned        fAdjSpace : 8;  /* Whether you adjust the spaces */

        ;unsigned        dxpExtra;
;/* the interesting positions in order from top to bottom are:
        ;top:                  yp+dypLine
        ;top of ascenders:     yp+dypAfter+dypFont
        ;base line:            yp+dypBase
        ;bottom of descenders: yp+dypAfter
        ;bottom of line:       yp
;distances between the points can be determined by algebraic subtraction.
;e.g. space before = yp+dypLine - (yp+dypAfter+dypFont)
;*/
        ;int             dypLine;
        ;int             dypAfter;
        ;int             dypFont;
        ;int             dypBase;

        ;int            ichLastTab;
        ;int             rgdxp[ichMaxLine];
        ;CHAR            rgch[ichMaxLine];
        ;};
; ***************************************************************************
ichMaxLine EQU  255
dxpNil     EQU  0FFFFH

        FLI STRUC
        cpMin_OFF       DW      ?
        cpMin_SEG       DW      ?
        ichCpMin        DW      ?
        cpMac_OFF       DW      ?
        cpMac_SEG       DW      ?
        ichCpMac        DW      ?
        ichMac          DW      ?
        dcpDepend       DW      ?
        fSplat          DB      ?
        ichFirstWide    DB      ?
        ichReal         DW      ?
        doc_Fli         DW      ?
        xpLeft_Fli      DW      ?
        xpRight         DW      ?
        xpReal_Fli      DW      ?
        xpMarg          DW      ?
        fGraphics_Fli   DB      ?
        fAdjSpace       DB      ?
        dxpExtra        DW      ?
        dypLine         DW      ?
        dypAfter        DW      ?
        dypFont         DW      ?
        dypBase         DW      ?
        fSplatNext      DW      ?
        ichLastTab      DW      ?
	flm_Fli		DW	?
        rgdxp           DW ichMaxLine DUP (?)
        rgch            DB ichMaxLine DUP (?)
        FLI     ENDS

        page

; **************************************************************************
;struct TBD      /* Tab Descriptor */
        ;{
        ;unsigned        dxa;        /* distance from left margin of tab stop */
        ;unsigned char   jc : 3;     /* justification code */
        ;unsigned char   tlc : 3;    /* leader dot code */
        ;unsigned char   opcode : 2; /* operation code for Format Tabs */
        ;CHAR            chAlign;    /* ASCII code of char to align on
                                       ;if jcTab=3, or 0 to align on '.' */
        ;};
; ***************************************************************************
; ***** Equates for TBD structure offsets ****************
        TBD     STRUC
        dxa     DW      ?
        jc_Tbd  DB      ?  ; 3 bits
        chAlign DB      ?  ;char
        TBD     ENDS

            ;/* bit field equates in TBD structure */
        tlc     EQU jc_Tbd  ; 3 bits
        opcode  EQU jc_Tbd  ; 2 bits

        page
; **************************************************************************
;struct PAP      /* Paragraph properties */
        ;{
        ;unsigned        fStyled : 1;                            /* BYTE 0 */
        ;unsigned        stc : 7;
        ;unsigned        jc : 2;                                 /* BYTE 1 */
        ;unsigned        fKeep : 1;
        ;unsigned        fKeepFollow : 1;
        ;unsigned        : 4;
        ;unsigned        stcNormChp : 7;                         /* BYTE 2 */
        ;unsigned        : 9;                                    /* BYTE 3 */
        ;unsigned        dxaRight;                               /* BYTE 4-5 */
        ;unsigned        dxaLeft;                                /* BYTE 6-7 */
        ;unsigned        dxaLeft1;                               /* BYTE 8-9 */
        ;unsigned        dyaLine;                                /* 10-11 */
        ;unsigned        dyaBefore;                              /* 12-13 */
        ;unsigned        dyaAfter;                               /* 14-15 */
        ;unsigned        rhc : 4;        /* Running hd code */
        ;unsigned        fGraphics : 1; /* Graphics bit */
        ;unsigned        wUnused1 : 11;
        ;int             wUnused2;
        ;int             wUnused3;
        ;struct TBD      rgtbd[itbdMaxWord];
        ;};

; ***************************************************************************
; ***** Equates for PAP structure offsets ****************

        PAP     STRUC
        fStyled         DB      ?       ;1 bit         /* BYTE 0 */
        jc_Pap          DB      ?       ;2 bits        /* BYTE 1 */
        rmChp           DB      ?       ;7 bits          /* BYTE 2 */
        unused9         DB      ?       ;9 bits          /* BYTE 3 */
        dxaRight        DW      ?       ;/* BYTE 4-5 */
        dxaLeft         DW      ?       ;/* BYTE 6-7 */
        dxaLeft1        DW      ?       ;/* BYTE 8-9 */
        dyaLine         DW      ?       ;/* 10-11 */
        dyaBefore       DW      ?       ;/* 12-13 */
        dyaAfter        DW      ?       ;/* 14-15 */
                                        ;/* BYTE 16-17 */
        rhc             DW      ?       ;4 bits        /* Running hd code */
        wUnused2        DW      ?       ;/* BYTE 18-19 */
        wUnused3        DW      ?       ;/* BYTE 20-21 */
        rgtbd           DW      ?       ;/* BYTE 23-23 */
        PAP     ENDS
            ;/* bit field equates in PAP structure */
        stc_Pap     EQU fStyled         ;7 bits
        fKeep       EQU jc_Pap          ;1 bit
        fKeepFollow EQU jc_Pap          ;1 bit
        unused4     EQU jc_Pap          ;4 bits
        fGraphics_Pap   EQU rhc         ;1 bits /* Graphics bit */
        wUnused1    EQU rhc             ;11 bits
        page

; **************************************************************************
;struct SEP
;       { /* Section properties */
;       unsigned        fStyled : 1;                            /* BYTE 0 */
;       unsigned        stc : 7;
;       unsigned        bkc : 3;        /* Break code */        /* BYTE 1 */
;       unsigned        nfcPgn : 3;     /* Pgn format code */
;       unsigned        :2;
;       unsigned        yaMac;          /* Page height */       /* BYTE 2-3 */
;       unsigned        xaMac;          /* Page width */        /* BYTE 4-5 */
;       unsigned        pgnStart;       /* Starting pgn */      /* BYTE 6-7 */
;       unsigned        yaTop;          /* Start of text */     /* BYTE 8-9 */
;       unsigned        dyaText;        /* Height of text */    /* 10-11 */
;       unsigned        xaLeft;         /* Left text margin */  /* 12-13 */
;       unsigned        dxaText;        /* Width of text */     /* 14-15 */
;       unsigned        rhc : 4;        /* *** RESERVED *** */  /* 16 */
;                                       /* (Must be same as PAP) */
;       unsigned        : 2;
;       unsigned        fAutoPgn : 1;   /* Print pgns without hdr */
;       unsigned        fEndFtns : 1;   /* Footnotes at end of doc */
;       unsigned        cColumns : 8;   /* # of columns */      /* BYTE 17 */
;       unsigned        yaRH1;          /* Pos of top hdr */    /* 18-19 */
;       unsigned        yaRH2;          /* Pos of bottom hdr */ /* 20-21 */
;       unsigned        dxaColumns;     /* Intercolumn gap */   /* 22-23 */
;       unsigned        dxaGutter;      /* Gutter width */      /* 24-25 */
;       unsigned        yaPgn;          /* Y pos of page nos */ /* 26-27 */
;       unsigned        xaPgn;          /* X pos of page nos */ /* 28-29 */
;       CHAR            rgbJunk[cchPAP - 30]; /* Pad to cchPAP */
;       };

; ***************************************************************************
; ***** Equates for SEP structure offsets ****************
        SEP     STRUC
        fStyled_Sep     DB      ?       ;1 bit          /* BYTE 0 */
        bkc             DB      ?       ;3 bits /* BYTE 1 */
        yaMac           DW      ?       ; /* Page height */ /* BYTE 2-3 */
        xaMac           DW      ?       ;/* Page width */  /* BYTE 4-5 */
        pgnStart        DW      ?       ; /* Starting pgn */      /* BYTE 6-7 */
        yaTop           DW      ?       ; /* Start of text */     /* BYTE 8-9 */
        dyaText         DW      ?       ; /* Height of text */    /* 10-11 */
        xaLeft_Sep      DW      ?       ; /* Left text margin */  /* 12-13 */
        dxaText         DW      ?       ; /* Width of text */     /* 14-15 */
        rhc_Sep         DB      ?       ;4 bits   /* 16 */
        ;                                       /* (Must be same as PAP) */
        cColumns        DB      ?       ; /* # of columns */      /* BYTE 17 */
        yaRH1           DW      ?       ; /* Pos of top hdr */    /* 18-19 */
        yaRH2           DW      ?       ; /* Pos of bottom hdr */ /* 20-21 */
        dxaColumns      DW      ?       ;/* Intercolumn gap */   /* 22-23 */
        dxaGutter       DW      ?       ; /* Gutter width */      /* 24-25 */
        yaPgn           DW      ?       ; /* Y pos of page nos */ /* 26-27 */
        xaPgn           DW      ?       ; /* X pos of page nos */ /* 28-29 */
        rgbJunk         DW      ?       ; /* Pad to cchPAP */
        SEP     ENDS

            ;/* bit field equates in SEP structure */

        stc_Sep EQU fStyled_Sep     ;7 bits
        nfcPgn EQU bkc  ; 3 bits     /* Pgn format code */
        junk1_Sep  EQU bkc  ; 2 bits
        junk2_Sep  EQU rhc_Sep  ;2 bits
        fAutoPgn EQU rhc_Sep    ;1 bit   /* Print pgns without hdr */
        fEndFtns EQU rhc_Sep    ;1 bit   /* Footnotes at end of doc */


        page

; **************************************************************************
;typedef struct FMI     /* font metric information */
        ;{
        ;int *mpchdxp;         /* pointer to width table */
                                ;/* NOTE - we actually point chDxpMin entries
                                          ;before the start of the table, so
                                          ;that the valid range begins at the
                                          ;start of the actual table */
        ;int dxpSpace;          /* width of a space */
        ;int dxpOverhang;       /* overhang for italic/bold chars */
        ;int dypAscent;         /* ascent */
        ;int dypDescent;                /* descent */
        ;int dypBaseline;       /* difference from top of cell to baseline */
        ;int dypLeading;        /* accent space plus recommended leading */
        ;};

; ***************************************************************************
; ***** Equates for FMI  structure offsets ****************
        FMI     STRUC
        mpchdxp         DW      ?
        dxpSpace        DW      ?
        dxpOverhang     DW      ?
        dypAscent_Fmi   DW      ?
        dypDescent_Fmi  DW      ?
        dypBaseline     DW      ?
        dypLeading      DW      ?
        FMI     ENDS
        page

; **************************************************************************
;struct CHP      /* Character properties */
        ;{
        ;unsigned       fStyled : 1;                            /* BYTE 0 */
        ;unsigned       stc : 7;        /* style */
        ;unsigned       fBold : 1;                              /* BYTE 1 */
        ;unsigned       fItalic : 1;
        ;unsigned       ftc : 6;        /* Font code */
        ;unsigned       hps : 8;        /* Size in half pts */  /* BYTE 2 */
        ;unsigned       fUline : 1;                             /* BYTE 3 */
        ;unsigned       fStrike : 1;
        ;unsigned       fDline: 1;
        ;unsigned       fOverset : 1;
        ;unsigned       csm : 2;        /* Case modifier */
        ;unsigned       fSpecial : 1;
        ;unsigned       : 1;
        ;unsigned       ftcXtra : 3;                            /* BYTE 4 */
        ;unsigned       fOutline : 1;
        ;unsigned       fShadow : 1;
        ;unsigned       : 3;
        ;unsigned       hpsPos : 8;                             /* BYTE 5 */
        ;unsigned       fFixedPitch : 8;        /* used internally only */
        ;unsigned       chLeader : 8;
        ;unsigned       ichRun : 8;
        ;unsigned       cchRun : 8;
        ;};

; ***************************************************************************
; ***** Equates for CHP structure offsets ****************
        CHP     STRUC
        fStyled_Chp     DB      ?       ;1 bit   /* BYTE 0 */
        fBold           DB      ?       ;1 bit   /* BYTE 1 */
        hps             DB      ?       ;8 bits  /* BYTE 2 */
        fUline          DB      ?       ;1 bit   /* BYTE 3 */
        ftcXtra         DB      ?       ;3 bits  /* BYTE 4 */
        hpsPos          DB      ?       ;8 bits  /* BYTE 5 */
        fFixedPitch     DB      ?       ;8 bits  /* BYTE 6 */
        chLeader        DB      ?       ;8 bits  /* BYTE 7 */
        ichRun          DB      ?       ;8 bits  /* BYTE 8 */
        cchRun          DB      ?       ;8 bits  /* BYTE 9 */
        CHP     ENDS

            ;/* bit field equates in CHP structure */
        stc_Chp         EQU fStyled_Chp ;7 bits        /* style */
        fItalic         EQU fBold       ;1 bit
        ftc             EQU fBold       ;6 bits
        fStrike         EQU fUline      ;1 bit
        fDline          EQU fUline      ;1 bit
        fOverset        EQU fUline      ;1 bit
        csm             EQU fUline      ;2 bits        /* Case modifier */
        fSpecial        EQU fUline      ;1 bit
        chp_unused1     EQU fUline      ;1 bit
        fOutline        EQU ftcXtra     ;1 bit
        fShadow         EQU ftcXtra     ;1 bit
        chp_unused2     EQU ftcXtra     ;3 bits

; **************************************************************************
        subttl  Bit masks
        page

        mask_0001       EQU 1
        mask_0010       EQU 2
        mask_0011       EQU 3
        mask_0100       EQU 4
        mask_0101       EQU 5
        mask_0110       EQU 6
        mask_0111       EQU 7
        mask_1000       EQU 8
        mask_1001       EQU 9
        mask_1010       EQU 10
        mask_1011       EQU 11
        mask_1100       EQU 12
        mask_1101       EQU 13
        mask_1110       EQU 14
        mask_1111       EQU 15
        mask_0001_0000  EQU 16
        mask_1111_1111  EQU 65535
        mask_0100_0000  EQU 64

        subttl Defined C Constants

        c_True          EQU     1
        c_False         EQU     0
        c_hpsDefault    EQU     20
        c_cwFLIBase     EQU     22
        c_cwIFI         EQU     16
        c_cwCHP         EQU     5
        c_docNil        EQU     -1
        c_cpNil         EQU     -1
        c_czaInch       EQU     1440
	c_czaLine	EQU	240
        c_xaRightMax    EQU     31680
        c_hpsNegMin     EQU     128
                ;/* Justification codes: must agree with menu.mod */
        c_jcLeft        EQU     0
        c_jcCenter      EQU     1
        c_jcRight       EQU     2
        c_jcBoth        EQU     3

        c_jcTabMin      EQU     4
        c_jcTabLeft     EQU     4
        c_jcTabCenter   EQU     5
        c_jcTabRight    EQU     6
        c_jcTabDecimal  EQU     7

                ;/* Tab leader codes: must agree with menu.mod */
        c_tlcWhite      EQU     0
        c_tlcDot        EQU     1
        c_tlcHyphen     EQU     2
        c_tlcUline      EQU     3

        c_chEmark       EQU     164

        c_chNil         EQU     -1
        c_chDelPrev     EQU     8
        c_chTab         EQU     9
        c_chEol         EQU     10
        c_chNewLine     EQU     11
        c_chSect        EQU     12
        c_chReturn      EQU     13
        c_chNRHFile     EQU     31
        c_chSpace       EQU     32
        c_chSplat       EQU     46
        c_chHyphen      EQU     45


        subttl FormatLine()
        page
; **************************************************************************
        sBegin FORM1_TEXT
;***
;
; FormatLine(doc, cp, ichCp, cpMac, flm)
;   int doc;
;   typeCP cp;
;   int ichCp;
;   typeCP cpMac;
;   int flm;
;
;  This procedure fills up vfli with a line of text. It is very large
;   and called often - each time a character is typed, at least.
;
;***
        cProc FormatLine,<PUBLIC,FAR>,<di,si>
                parmW   doc
                parmD   cp
                parmW   ichCp
                parmD   cpMac
                parmW   flm
; Line 79

                localW  dyaFormat
                localW  fFlmPrinting
                localDP psep
                localW  xaRight
                localW  dypAscentMac
                localW  ichpNRH
                localW  ypSubSuperFormat
                localW  dxpFormat
                localW  dypFormat
                localDP ppap
                localW  dypAscent

                localV  ifi,%(size IFI_STRUC)

                localW  xpTab
                localW  fTruncated
                localW  xaLeft
                localW  dypDescentMac
                localDP ptbd
                localW  dypDescent
                localW  dxaFormat
                localW  dxp
                localW  cch
                localDP pch
                localW  xpPrev
                localW  iichNew
                localW  dxpPr
                localW  cchUsed
                localW  dich
                localW  fSizeChanged
                localW  chT
                localW  cch2
                localW  dxpCh
                localW  xaTab
                localW  xaPr
                localW  chT2
                localW  dxpNew

                localV  chpLocal,%(size CHP)

        cBegin FormatLine

; Line 107
        mov     ax,flm
        and     ax,1
        mov     fFlmPrinting,ax
; Line 113
        mov     fTruncated,0

    ;** Check for fli current */
; Line 122
        mov     ax,WORD PTR VFLI.doc_Fli
        cmp     doc,ax
        jne     $I845
        mov     ax,WORD PTR VFLI.cpMin_OFF
        mov     dx,WORD PTR VFLI.cpMin_SEG
        cmp     SEG_cp,dx
        jne     $I845
        cmp     OFF_cp,ax
        jne     $I845
        mov     ax,WORD PTR VFLI.ichCpMin
        cmp     ichCp,ax
        jne     $I845
	mov	ax,WORD PTR VFLI.flm_Fli
	cmp	flm,ax
	jne	$I845

        ;* Just did this one */

        jmp     $RetFormat    ; *** return ****
; Line 125
$I845:
IFDEF DEBUG
IFDEF SCRIBBLE
        mov     ax,5
        push    ax
        mov     ax,70
        push    ax
        call    FAR PTR FNSCRIBBLE
ENDIF
ENDIF
; Line 129
    ;*
    ;* This means:
    ;*  vfli.fSplat = false;
    ;*  vfli.dcpDepend = 0;
    ;*  vfli.ichCpMac = 0;
    ;*  vfli.dypLine = 0;
    ;*  vfli.dypAfter = 0;
    ;*  vfli.dypFont = 0;
    ;*  vfli.dypBase = 0;
    ;*
    ;                         *** macro bltc destroys ax,es,cx
        bltc    <OFFSET VFLI>,0,c_cwFLIBase
        mov     WORD PTR VFLI.fSplatNext, 0
; Line 141
     ;* Rest of FormatLine loads up cache with current data *****

        mov     ax,doc
        mov     WORD PTR VFLI.doc_Fli,ax
	mov	ax,flm
	mov	WORD PTR VFLI.flm_Fli,ax
; Line 142
; *********** Register variables ********************
        rax_OFF_cp      EQU     ax
        rdx_SEG_cp      EQU     dx
; ****************************************************
        mov     rax_OFF_cp,OFF_cp
        mov     rdx_SEG_cp,SEG_cp
        mov     WORD PTR VFLI.cpMin_OFF,rax_OFF_cp
        mov     WORD PTR VFLI.cpMin_SEG,rdx_SEG_cp
; Line 143
        mov     cx,ichCp
        mov     WORD PTR VFLI.ichCpMin,cx
; Line 145
               ; *** if (cp > cpMac)
        cmp     rdx_SEG_cp,SEG_cpMac
        jl      $initRunTbl
        jg      $spAftEnd
        cmp     rax_OFF_cp,OFF_cpMac
        jbe     $initRunTbl
$spAftEnd:
        ;/* Space after the endmark. Reset the cache because the footnotes come
        ;at the same cp in the footnote window */
; Line 149
        mov     WORD PTR VFLI.doc_Fli,c_docNil
; Line 150
        mov     WORD PTR VFLI.cpMac_OFF,rax_OFF_cp
        mov     WORD PTR VFLI.cpMac_SEG,rdx_SEG_cp
; Line 151
        mov     WORD PTR VFLI.rgdxp,0
; Line 159
        ;  /* Line after end mark is taller than screen */
        mov     ax,DYPMAX
        mov     WORD PTR VFLI.dypLine,ax
        sar     ax,1
        mov     WORD PTR VFLI.dypFont,ax
        mov     WORD PTR VFLI.dypBase,ax
        jmp     $ScribRet       ; Scribble and return
;
; *************** EXIT POINT **********************************************
;


$initRunTbl:
                ;/* Initialize run tables */
        mov     WORD PTR $S784_ichpFormat,0
; Line 185
                ;/* Cache section and paragraph properties */
        push    doc
        push    SEG_cp
        push    OFF_cp
        call    FAR PTR CACHESECT
; Line 188
        mov     psep,OFFSET VSEPABS
; Line 190
        push    doc
        push    SEG_cp
        push    OFF_cp
        call    FAR PTR CACHEPARA
; Line 191
        mov     ppap,OFFSET VPAPABS

                ;/* Now we have:
                        ;ppap    paragraph properties
                        ;psep    division properties
                ;*/

; Line 198
                ; *** if (ppap->fGraphics)
        mov     bx,ppap
        test    WORD PTR [bx].fGraphics_Pap,mask_0001_0000
        je      $I851
; Line 201
                ;*** Format a picture paragraph in a special way (see picture.c)
        push    doc
        push    SEG_cp
        push    OFF_cp
        push    ichCp
        push    SEG_cpMac
        push    OFF_cpMac
        push    flm
        call    FAR PTR FORMATGRAPHICS
        jmp     $ScribRet       ; Scribble and return
;
; *************** EXIT POINT **********************************************
;
$I851:
                ; *** /* Assure we have a good memory DC for font stuff */
        call    FAR PTR VALIDATEMEMORYDC
        cmp     VHMDC,0
        je      $L20000
        cmp     VHDCPRINTER,0
        jne     $L20001
$L20000:
        call    FAR PTR WINFAILURE
        jmp     $ScribRet       ; Scribble and return
;
; *************** EXIT POINT **********************************************
;
$L20001:

; Line 216
        ; *** bltc(&ifi, 0, cwIFI);
        ; ***/* This means:
                ; ***ifi.ich = 0;
                ; ***ifi.ichPrev = 0;
                ; ***ifi.ichFetch = 0;
                ; ***ifi.cchSpace = 0;
                ; ***ifi.ichLeft = 0;
        ; ****/

    ;                         *** macro bltc destroys ax,es,cx
        lea     dx,ifi
        bltc    dx,0,c_cwIFI
; Line 225
        mov     ifi._jc,c_jcTabLeft
; Line 226
        mov     ifi.fPrevSpace,c_True
; Line 230
        ; *** /* Set up some variables that have different value depending on
        ; *** whether we are printing or not */

        ; ***   if (fFlmPrinting)

        cmp     fFlmPrinting,0
        je      $NoPrint
; Line 232
        mov     ax,DXAPRPAGE
        mov     dxaFormat,ax
; Line 233
        mov     ax,DYAPRPAGE
        mov     dyaFormat,ax
; Line 234
        mov     ax,DXPPRPAGE
        mov     dxpFormat,ax
; Line 235
        mov     ax,DYPPRPAGE
        mov     dypFormat,ax
; Line 236
        mov     ax,YPSUBSUPERPR
        jmp     SHORT $CalcHgt

$NoPrint:
; Line 240
        mov     ax,c_czaInch
        mov     dyaFormat,ax
        mov     dxaFormat,ax
; Line 241
        mov     ax,DXPLOGINCH
        mov     dxpFormat,ax
; Line 242
        mov     ax,DYPLOGINCH
        mov     dypFormat,ax
; Line 243
        mov     ax,YPSUBSUPER

$CalcHgt:
        mov     ypSubSuperFormat,ax

        ; *** /* Calculate line height and width measures.  Compute
                ; *** xaLeft    left indent 0 means at left margin
                ; *** xaRight   width of column measured from left
                ; ***           margin (not from left indent).
        ; *** */
        ; *** xaLeft = ppap->dxaLeft;

; Line 251
; *********** Register variables ********************
        rbx_ppap EQU    bx
; ****************************************************
        mov     rbx_ppap,ppap
        mov     ax,[rbx_ppap].dxaLeft
        mov     xaLeft,ax
; Line 255

        ; *** /* If this is the first line of a paragraph,
        ; ***      adjust xaLeft for the first
        ; *** line indent.  (Also, set dypBefore, since its handy.) */
        ; *** if (cp == vcpFirstParaCache)

        mov     ax,WORD PTR VCPFIRSTPARACACHE
        mov     dx,WORD PTR VCPFIRSTPARACACHE+2
        cmp     SEG_cp,dx
        jne     $setMargins
        cmp     OFF_cp,ax
        jne     $setMargins
; Line 257
        mov     ax,[rbx_ppap].dxaLeft1
        add     xaLeft,ax
; Line 273
$setMargins:
; Line 274
        ; *** /* Now, set xaRight (width measured in twips). */

IFDEF CASHMERE
        test    WORD PTR [rbx_ppap].rhc,15
        je      $L20005
        mov     ax,WORD PTR VSEPPAGE.xaMac
        sub     ax,WORD PTR VSEPPAGE.dxaGutter
        jmp     SHORT $L20006
$L20005:
ENDIF

        mov     si,psep
        mov     ax,[si].dxaText
$L20006:
        sub     ax,[rbx_ppap].dxaRight
        mov     xaRight,ax
; Line 277
        ; *** /* Do necessary checks on xaLeft and xaRight */

; *********** Register variables ********************
        rcx_xaRightMax EQU      cx
; ****************************************************
        mov     rcx_xaRightMax,c_xaRightMax
        cmp     ax,rcx_xaRightMax
        jbe     $I859
; Line 279
        mov     xaRight,rcx_xaRightMax
; Line 281
$I859:
; *********** Register variables ********************
        rax_xaLeft EQU  ax
; ****************************************************
        mov     rax_xaLeft,xaLeft
        cmp     rax_xaLeft,rcx_xaRightMax
        jbe     $I861
; Line 283
        mov     xaLeft,rcx_xaRightMax
; Line 285
$I861:
        cmp     rax_xaLeft,0
        jge     $I863
; Line 287
        xor     rax_xaLeft,rax_xaLeft
        mov     xaLeft,rax_xaLeft
; Line 289
$I863:
        cmp     xaRight,rax_xaLeft
        jae     $I865
; Line 291
        inc     rax_xaLeft
        mov     xaRight,rax_xaLeft
; Line 294
$I865:
        push    xaLeft
        push    dxpFormat
        push    dxaFormat
        call    FAR PTR MULTDIV
        mov     ifi.xpLeft_Ifi,ax
        mov     ifi.xp,ax
        mov     WORD PTR VFLI.xpLeft_Fli,ax
; Line 295
        push    xaLeft
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV
        mov     ifi.xpPr,ax
; Line 296
        push    xaRight
        push    dxpFormat
        push    dxaFormat
        call    FAR PTR MULTDIV
        mov     ifi.xpRight_Ifi,ax
        mov     WORD PTR VFLI.xpMarg,ax
; Line 297
        push    xaRight
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV
        mov     ifi.xpPrRight,ax
; Line 300
        ; *** /* Get a pointer to the tab-stop table. */
        mov     ax,ppap
        add     ax,rgtbd
        mov     ptbd,ax
; Line 303
        ; *** /* Turn off justification. */
        cmp     fFlmPrinting,0
        je      $L20007
        mov     ax,VHDCPRINTER
        jmp     SHORT $L20008
$L20007:
        mov     ax,VHMDC
$L20008:
        push    ax
        xor     ax,ax
        push    ax
        push    ax
        call    FAR PTR SETTEXTJUSTIFICATION
; Line 306
        ; *** /* Initialize the line height information. */
        xor     ax,ax
        mov     dypDescentMac,ax
        mov     dypAscentMac,ax
; Line 309
        ; ***   /* To tell if there were any tabs */
        mov     ifi.ichLeft,65535
; Line 312
        ; *** /* Get the first run, and away we go... */
        push    doc
        push    SEG_cp
        push    OFF_cp
        push    ichCp
        jmp     SHORT $L20037

$NullRun:
; Line 357
        mov     ax,c_cpNil
        push    ax
        push    ax   ; high word of cpNil
        push    ax
        xor     ax,ax
        push    ax
$L20037:
        mov     ax,11
        push    ax
        call    FAR PTR FETCHCP
$FirstCps:
; Line 360
        mov     cchUsed,0
; Line 364
        ; *** /* Continue fetching runs until a run is found with a nonzero
        ; ***    length */
        mov     ax,VCCHFETCH
        mov     cch,ax
        or      ax,ax
        je      $NullRun
        mov     ax,VPCHFETCH
        mov     pch,ax
; Line 371
        mov     ax,WORD PTR VCPFETCH
        mov     dx,WORD PTR VCPFETCH+2
        cmp     SEG_cpMac,dx
        jg      $I886
        jl      $L20009
        cmp     OFF_cpMac,ax
        jbe     $L20009
	cmp	fFlmPrinting,0
	jne	$I886
	mov	bx,pch
	cmp	BYTE PTR [bx],c_chSect
	jne	$I886
$L20009:
; Line 374
        ; *** /* Force end mark to be in standard system font */
;                   *** macro blt destroys ax,bx,cx,es
        blt     <OFFSET VCHPNORMAL>,<OFFSET VCHPABS>,c_cwCHP
; Line 375
IFDEF SYSENDMARK
                ; *** vchpAbs.ftc = ftcSystem;
        mov     BYTE PTR VCHPABS.ftc,248       ; 0x3e << 2 == 0xF8 == 248
ELSE
                ; *** vchpAbs.ftc = 0;
        and     BYTE PTR VCHPABS.ftc,3
ENDIF
; Line 376
                ; *** vchpAbs.ftcXtra = 0;
        and     BYTE PTR VCHPABS.ftcXtra,248

                ; *** vchpAbs.hps = hpsDefault;
        mov     BYTE PTR VCHPABS.hps,c_hpsDefault
; Line 394
$I886:
              ; *** not from original c code: copy VCHPABS into chpLocal
              ; *** and use chpLocal hereafter ***********
;                   *** macro blt destroys ax,bx,cx,es
        lea     dx,chpLocal
        blt     <OFFSET VCHPABS>,dx,c_cwCHP
; Line 375
                ; *** vchpAbs.ftc = 0;
        cmp     fFlmPrinting,0
        je      $I888
; Line 396
        push    doc
        lea     ax,chpLocal
        push    ax
        mov     ax,3
        push    ax
        call    FAR PTR LOADFONT
; Line 397
        mov     ax,WORD PTR VFMIPRINT.dypAscent_Fmi
        add     ax,WORD PTR VFMIPRINT.dypLeading
        mov     dypAscent,ax
; Line 398
        mov     ax,WORD PTR VFMIPRINT.dypDescent_Fmi
        jmp     SHORT $L20038
$I888:
; Line 402
        push    doc
        lea     ax,chpLocal
        push    ax
        mov     ax,2
        push    ax
        call    FAR PTR LOADFONT
; Line 403
        mov     ax,WORD PTR VFMISCREEN.dypAscent_Fmi
        add     ax,WORD PTR VFMISCREEN.dypLeading
        mov     dypAscent,ax
; Line 404
        mov     ax,WORD PTR VFMISCREEN.dypDescent_Fmi
$L20038:
        mov     dypDescent,ax

ifdef ENABLE    /* BRYANL 8/27/27; see comment in C source */
        ; *** /* Bail out if there is a memory failure. */
        cmp     VFOUTOFMEMORY,0
        je      $I889
        jmp     $DoBreak
$I889:
endif   ; ENABLE 

; Line 408
        ; lines 408-417 removed
; Line 418
        ; ***   /* Floating line size algorithm */
        ; ***      if (chpLocal.hpsPos != 0)

        test    BYTE PTR chpLocal.hpsPos,-1
        je      $I895
; Line 421
                   ; *** /* Modify font for subscript/superscript */
        ; ***      if (chpLocal.hpsPos < hpsNegMin)

        mov     al,BYTE PTR chpLocal.hpsPos
        cmp     al,c_hpsNegMin
        jae     $I894
; Line 423
        mov     ax,ypSubSuperFormat
        add     dypAscent,ax
; Line 425
        jmp     SHORT $I895
$I894:
; Line 427
        mov     ax,ypSubSuperFormat
        add     dypDescent,ax
; Line 428
$I895:
                ; *** /* Update the maximum ascent and descent of the line. */
; Line 432
        mov     fSizeChanged,0
; Line 433
        mov     ax,dypDescent
        cmp     dypDescentMac,ax
        jge     $I896
; Line 435
        mov     dypDescentMac,ax
; Line 436
        mov     fSizeChanged,1
; Line 438
$I896:
        mov     ax,dypAscent
        cmp     dypAscentMac,ax
        jge     $I897
; Line 440
        mov     dypAscentMac,ax
; Line 441
        mov     fSizeChanged,1
; Line 444
;       dypUser EQU bp-88
;       dypAuto EQU bp-90
; *********** Register variables ********************
        rsi_dypAuto EQU si
        rdi_dypUser EQU di
; ****************************************************
$I897:
        cmp     fSizeChanged,0
        je      $OldRun
; Line 485
        mov     rsi_dypAuto,dypDescentMac
        add     rsi_dypAuto,dypAscentMac
; Line 487
        mov     bx,ppap
        mov	ax,WORD PTR [bx].dyaLine
	cmp	ax,c_czaLine
	jle	$I898
	push	ax
        push    dypFormat
        push    dyaFormat
        call    FAR PTR MULTDIV
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR IMAX
        mov     rdi_dypUser,ax
; Line 490
        cmp     rsi_dypAuto,rdi_dypUser
        jle     $L20011
$I898:
        mov     ifi.dypLineSize,rsi_dypAuto
        jmp     SHORT $L20012
$L20011:
        mov     ifi.dypLineSize,rdi_dypUser
$L20012:
; Line 496
$OldRun:
; Line 498
            ; *** /* Calculate length of the run but no greater than 256 */
        mov     ax,WORD PTR VCPFETCH
        sub     ax,WORD PTR VFLI
; Line 499
        cmp     ax,255
        jl      $I902
; Line 501
        mov     ax,254
; Line 503
$I902:
        mov     iichNew,ax
        sub     ax,ifi.ich_Ifi
        mov     dich,ax
; Line 509
                ; *** /* Ensure that all tab and non-required
                ; ***        hyphen characters start at
                ; *** beginning of run */
        cmp     WORD PTR $S784_ichpFormat,0
        jle     $L20013
        or      ax,ax
        jg      $L20013
        lea     ax,chpLocal
        push    ax
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     bx,VHGCHPFORMAT
        add     ax,[bx]
        sub     ax,10
        push    ax
        mov     ax,7
        push    ax
        call    FAR PTR CCHDIFFER
        or      ax,ax
        jne     $L20013
        mov     bx,pch
        cmp     BYTE PTR [bx],9
        je      $L20013
        cmp     BYTE PTR [bx],31
        je      $+5
        jmp     $I905
;       pchp EQU bp-92
;       register si=pchp
$L20013:
; Line 511
        mov     ax,ICHPMACFORMAT
        cmp     WORD PTR $S784_ichpFormat,ax
        jne     $L20014
        call    FGrowFormatHeap
        or      ax,ax
        jne     $+5
        jmp     $I905
$L20014:
; Line 514
; *********** Register variables ********************
        rsi_pchp EQU    si
; ****************************************************
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     rsi_pchp,ax
        sub     rsi_pchp,10
        mov     bx,VHGCHPFORMAT
        add     rsi_pchp,[bx]    ; si = pch
; Line 516
        cmp     WORD PTR $S784_ichpFormat,0
        jle     $I907
; Line 518
        mov     ax,ifi.ich_Ifi
        sub     ax,ifi.ichPrev
        mov     BYTE PTR [rsi_pchp].cchRun,al
; Line 519
        mov     al,BYTE PTR (ifi.ichPrev)
        mov     BYTE PTR [rsi_pchp].ichRun,al
; Line 521
$I907:
        add     rsi_pchp,10
;                   *** macro blt destroys ax,bx,cx,es
        mov     dx,rsi_pchp
        lea     ax,chpLocal  ; ax not destroyed in blt until after value used
        blt     ax,dx,c_cwCHP

; Line 529
        or      BYTE PTR [rsi_pchp].cchRun,255
; Line 530
        cmp     dich,0
        jg      $I908
; Line 532
        mov     al,BYTE PTR (ifi.ich_Ifi)
        jmp     SHORT $L20048
$I908:
; Line 537
                ; *** bltc (&vfli.rgdxp[ifi.ich],0,dich)

        mov     dx,ifi.ich_Ifi
        shl     dx,1
        add     dx,OFFSET VFLI.rgdxp
    ;                         *** macro bltc destroys ax,es,cx
        bltc    dx,0,dich
; Line 538
                ; *** bltbc (&vfli.rgch[ifi.ich],0,dich)
        mov     dx,ifi.ich_Ifi
        add     dx,OFFSET VFLI.rgch
                ;***  macro bltbc destroys ax,es,cx
        bltbc   dx,0,dich

; Line 539
        mov     ax,iichNew
        mov     ifi.ich_Ifi,ax
$L20048:
        mov     BYTE PTR [rsi_pchp].ichRun,al
; Line 541
        mov     ax,ifi.ich_Ifi
        mov     ifi.ichPrev,ax
; Line 542
        inc     WORD PTR $S784_ichpFormat
; Line 544
$I905:
; Line 546
        mov     ax,WORD PTR VCPFETCH
        mov     dx,WORD PTR VCPFETCH+2
        cmp     SEG_cpMac,dx
        jle     $+5
        jmp     $I911
        jl      $L20016
        cmp     OFF_cpMac,ax
        jbe     $+5
        jmp     $I911
$L20016:
; Line 549
        cmp     ifi.fPrevSpace,0
        je      $L20015
                        ; *** note ax:dx still holds vcpFetch
        cmp     SEG_cp,dx
        jne     $I912
        cmp     OFF_cp,ax
        jne     $I912
$L20015:
; Line 551
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 552
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 554
$I912:
        cmp     fFlmPrinting,0
        jne     $I913
        ;mov     ax,DOCHELP
        ;cmp     doc,ax
        ;je      $I913
; Line 556
        mov     bx,ifi.ich_Ifi
        mov     BYTE PTR VFLI.rgch[bx],c_chEmark
; Line 558
        mov     ax,c_chEmark
        push    ax
        xor     ax,ax
        push    ax
        call    FAR PTR DxpFromCh
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        shl     bx,1
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     WORD PTR VFLI.xpReal_Fli,ax
; Line 560
$I913:
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 561
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
; Line 562
        mov     ax,dypAscentMac
        add     ax,dypDescentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 563
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
        mov     WORD PTR VFLI.ichMac,ax
; Line 564
        mov     ax,OFF_cpMac
        mov     dx,SEG_cpMac
        add     ax,1
        adc     dx,0
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 565
        jmp     $JustEol
$I911:
        mov     ax,ifi.ich_Ifi
        add     ax,cch
        cmp     ax,255
        jle     $I916
; Line 573
        mov     ax,255
        sub     ax,ifi.ich_Ifi
        mov     cch,ax
; Line 574
        mov     fTruncated,1
; Line 577
$I916:
        mov     ifi.ichFetch,0
; Line 603
                ; *** if (chpLocal.fSpecial)
        test    BYTE PTR chpLocal.fSpecial,mask_0100_0000
        jne     $+5
        jmp     $GetCh
; Line 605
        lea     ax,ifi
        push    ax
        push    flm
        mov     ax,WORD PTR VSEPABS
        mov     cl,11
        shr     ax,cl
        and     ax,7
        push    ax
        call    FAR PTR FFORMATSPECIALS
        or      ax,ax
        je      $+5
        jmp     $GetCh
; Line 607
        cmp     ifi.chBreak,0
        jne     $+5
        jmp     $Unbroken
$I986:
        mov     ax,ifi.ichFetch
        sub     ax,WORD PTR VFLI.cpMac_OFF
        add     ax,WORD PTR VCPFETCH
        mov     WORD PTR VFLI.dcpDepend,ax
; Line 1026
$JustBreak:
; Line 1027
        cmp     WORD PTR ifi.chBreak,31
        je      $+5
        jmp     $I992
; Line 1032
        mov     ax,45
        push    ax
        push    fFlmPrinting
        call    FAR PTR DxpFromCh  ; *** ax will have width of hyphen

                 ; **** up to line 1036 rearranged bz
        mov     bx,WORD PTR VFLI.ichReal
; Line 1035
        mov     WORD PTR VFLI.ichMac,bx  ; ** ichMac = ichReal

        dec     bx    ; ichReal - 1
        mov     BYTE PTR VFLI.rgch[bx],45 ; ** rgch[ichReal-1] = "-

        shl     bx,1
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     ifi.xpReal_Ifi,ax
; Line 1033
        mov     ax,ifi.xpReal_Ifi
        mov     WORD PTR VFLI.xpReal_Fli,ax
        mov     WORD PTR VFLI.xpRight,ax


; Line 1036
        mov     ax,WORD PTR $S784_ichpFormat
        dec     ax
        cmp     ichpNRH,ax
        jge     $I992
;       pchp EQU bp-112
; *********** Register variables ********************
        rdi_pchp EQU    di
; ****************************************************
;       register di=pchp
;       =-114
;       =-116
; Line 1039
                ; ** register struct CHP *pchp=&(**vhgchpFormat)[ichpNRH]
        mov     ax,10
        imul    ichpNRH
        mov     rdi_pchp,ax
        mov     bx,VHGCHPFORMAT
        add     rdi_pchp,[bx]
; Line 1041
                ; ** pchp->cchRun++;
        inc     BYTE PTR [rdi_pchp].cchRun
; Line 1042
                ; ** if (pchp->ichRun >= vfli.ichMac)
        mov     dx,WORD PTR VFLI.ichMac
        cmp     BYTE PTR [rdi_pchp].ichRun,dl
        jb      $I992
; Line 1044
                ; ** pchp->ichRun = vfli.ichMac - 1;
        dec     dx
        mov     BYTE PTR [rdi_pchp].ichRun,dl
; Line 1046
$I992:
; Line 1049
        cmp     fFlmPrinting,0
        je      $I993
; Line 1051
        mov     ax,WORD PTR VFLI.ichReal
        mov     WORD PTR VFLI.ichMac,ax
; Line 1057
$I993:
        cmp     ifi._jc,c_jcTabLeft
        jne     $+5
        jmp     $I994
; Line 1061
$L20051:
        lea     ax,ifi
        push    ax
        push    xpTab
        jmp     $L20046
;       ch=-94
; *********** Register variables ********************
        rsi_ch EQU      si
; ****************************************************
;       register si=ch
$I877:
; Line 625
        mov     bx,ifi.ichFetch
        inc     ifi.ichFetch
        mov     di,pch
        mov     al,[bx][di]
        sub     ah,ah
        mov     rsi_ch,ax
; Line 627
$NormChar:
; Line 628
        cmp     rsi_ch,c_chSpace
        jne     $NotSpace
; Line 632
        cmp     fFlmPrinting,0
        je      $L20017
        mov     ax,WORD PTR VFMIPRINT+2
        jmp     SHORT $L20018
$L20017:
        mov     ax,WORD PTR VFMISCREEN+2
$L20018:
        mov     dxp,ax
        mov     bx,ifi.ich_Ifi
        shl     bx,1
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     ifi.xp,ax
; Line 633
        mov     ax,WORD PTR VFMIPRINT+2
        mov     dxpPr,ax
        add     ifi.xpPr,ax
; Line 634
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        mov     BYTE PTR VFLI.rgch[bx],c_chSpace

; Line 635
        jmp     $BreakOppr

$NotSpace:
; Line 641
        cmp     rsi_ch,c_chSpace
        jl      $L20019
        cmp     rsi_ch,128
        jge     $L20019
        mov     bx,WORD PTR VFMIPRINT
        shl     rsi_ch,1
        mov     ax,WORD PTR [bx][rsi_ch]
        shr     rsi_ch,1
        mov     dxpPr,ax
        cmp     ax,dxpNil
        jne     $I928
$L20019:
; Line 643
        push    rsi_ch
        mov     ax,1
        push    ax
        call    FAR PTR DxpFromCh
        mov     dxpPr,ax
; Line 646
$I928:
        cmp     fFlmPrinting,0
        je      $I929
; Line 650
        mov     ax,dxpPr
        jmp     SHORT $L20045
$I929:
; Line 653
        cmp     rsi_ch,c_chSpace
        jl      $L20020
        cmp     rsi_ch,128
        jge     $L20020
        mov     bx,WORD PTR VFMISCREEN
        shl     rsi_ch,1
        mov     ax,WORD PTR [bx][rsi_ch]
        shr     rsi_ch,1
        mov     dxp,ax
        cmp     ax,dxpNil
        jne     $I931
$L20020:
; Line 654
        push    rsi_ch
        xor     ax,ax
        push    ax
        call    FAR PTR DxpFromCh
$L20045:
        mov     dxp,ax
; Line 656
$I931:
        mov     bx,ifi.ich_Ifi
        shl     bx,1
                ; *** here ax = dxp from above
        mov     WORD PTR VFLI.rgdxp[bx],ax
        add     ifi.xp,ax
; Line 657
        mov     ax,dxpPr
        add     ifi.xpPr,ax
; Line 658
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        mov     ax,rsi_ch
        mov     BYTE PTR VFLI.rgch[bx],al
; Line 662
        cmp     rsi_ch,45
        jle     $SwitchCh
; Line 1001
$DefaultCh:
; Line 1002
        mov     ax,ifi.xpPrRight
        cmp     ifi.xpPr,ax
        jle     $PChar
; Line 1003
$DoBreak:
; Line 1005
        cmp     ifi.chBreak,0
        je      $+5
        jmp     $I986
; Line 1006
$Unbroken:
; Line 1011
        mov     ax,ifi.ich_Ifi
        dec     ax
        push    ax
        call    FFirstIch
        or      ax,ax
        jne     $+5
        jmp     $I987
        cmp     ifi.ich_Ifi,255
        jl      $+5
        jmp     $I987
; Line 1013
$PChar:
; Line 1087
        mov     ifi.fPrevSpace,0
; Line 1089
        jmp     SHORT $GetCh

                ; ***** end for default case **************
$SwitchCh:
        mov     ax,rsi_ch
        cmp     ax,c_chSect
        jne     $+5
        jmp     $SC942
        jle     $+5
        jmp     $L20028
        cmp     ax,c_chTab
        jne     $+5
        jmp     $SC951
        cmp     ax,c_chEol
        jl      $DefaultCh
        cmp     ax,c_chNewLine
        jg      $+5
        jmp     $SC971
        jmp     SHORT $DefaultCh
$SC938:
; Line 671
        dec     ifi.ich_Ifi
; Line 672
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 673
        mov     ax,dxpPr
        sub     ifi.xpPr,ax

        page
; Line 674
$GetCh:         ; ****** START of main FOR loop ********************
; Line 335
        mov     ax,cch
        cmp     ifi.ichFetch,ax
        je      $+5
        jmp     $I877
; Line 341
        cmp     ifi.ich_Ifi,255
        jge     $DoBreak
; Line 344
        cmp     fTruncated,0
        jne     $+5
        jmp     $NullRun
; Line 349
        add     cchUsed,ax
; Line 350
        mov     ax,cchUsed
        add     ax,VPCHFETCH
        mov     pch,ax
; Line 351
        mov     ax,VCCHFETCH
        sub     ax,cchUsed
        mov     cch,ax
; Line 352
        mov     fTruncated,0
; Line 353
        jmp     $OldRun
$SC939:
; Line 679
        dec     ifi.ich_Ifi
; Line 680
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 681
        mov     ax,dxpPr
        sub     ifi.xpPr,ax
; Line 683
        mov     ax,WORD PTR $S784_ichpFormat
        dec     ax
        mov     ichpNRH,ax
; Line 684
        mov     ax,c_chHyphen
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR DxpFromCh
        add     ax,ifi.xpPr
        cmp     ax,ifi.xpPrRight
        jle     $+5
        jmp     $DoBreak
; Line 687
        mov     ax,ifi.xp
        mov     xpPrev,ax
; Line 700
        mov     bx,ifi.ich_Ifi
        mov     BYTE PTR VFLI.rgch[bx],c_chTab
; Line 701
        jmp     $Tab0
$SC942:
; Line 705
        dec     ifi.ich_Ifi
; Line 706
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 707
        mov     ax,dxpPr
        sub     ifi.xpPr,ax
; Line 710
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
        add     ax,dypAscentMac
        mov     WORD PTR VFLI.dypLine,ax
        mov     WORD PTR VFLI.dypFont,ax
; Line 711
        mov     ax,ifi.ichFetch
        cwd
        add     ax,WORD PTR VCPFETCH
        adc     dx,WORD PTR VCPFETCH+2
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 712
        push    ifi.ich_Ifi
        call    FFirstIch
        or      ax,ax
        jne     $+5
        jmp     $I943
; Line 715
        mov     ax,WORD PTR VFLI.fSplat
        mov     al,1
        mov     WORD PTR VFLI.fSplat,ax
; Line 716
        cmp     fFlmPrinting,0
        je      $+5
        jmp     $I944
        ;chT EQU bp-96
        ;cch EQU bp-98
        ;dxpCh EQU bp-100
; Line 723
        mov     chT,c_chSplat
; Line 726
        push    chT
        xor     ax,ax
        push    ax
        call    FAR PTR DxpFromCh
        mov     dxpCh,ax
; Line 730
        mov     ax,17
        imul    DXPLOGINCH
        cwd
        sub     ax,dx
        sar     ax,1
        cwd
        mov     cx,dxpCh
        idiv    cx
        cmp     ax,223
        jge     $L20021
        jmp     SHORT $L20022
$L20021:
        mov     ax,223
$L20022:
        mov     cch2,ax
; Line 732
               ; ***             bltbc(&vfli.rgch[ifi.ich], chT, cch);
        mov     dx,ifi.ich_Ifi
        add     dx,OFFSET VFLI.rgch
                 ;***  macro bltbc destroys ax,es,cx
        bltbc   dx,<BYTE PTR (chT)>,cch2
; Line 733
               ; ***             bltc(&vfli.rgdxp[ifi.ich], dxpCh, cch);
        mov     dx,ifi.ich_Ifi
        shl     dx,1
        add     dx,OFFSET VFLI.rgdxp
    ;                         *** macro bltc destroys ax,es,cx
        bltc    dx,dxpCH,cch2
; Line 734
        mov     ax,ifi.ich_Ifi
        add     ax,cch2
        mov     WORD PTR VFLI.ichMac,ax
; Line 736
        push    VHMDC
        mov     ax,OFFSET VFLI.rgch
        push    ds
        push    ax
        push    cch2
        call    FAR PTR GETTEXTEXTENT
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 737
        mov     WORD PTR VFLI.xpLeft_Fli,0
; Line 739
        jmp     $EndFormat
$I944:
; Line 741
        mov     WORD PTR VFLI.ichMac,0
; Line 743
        jmp     $EndFormat
$I943:
        mov     WORD PTR VFLI.fSplatNext, 1

        mov     ax,cchUsed
        dec     ax
        cwd
        add     WORD PTR VFLI.cpMac_OFF,ax
        adc     WORD PTR VFLI.cpMac_SEG,dx
; Line 749
        mov     WORD PTR VFLI.dcpDepend,1
; Line 750
        cmp     ifi.fPrevSpace,0
        jne     $I950
; Line 752
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 753
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 754
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 756
$I950:
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichMac,ax
; Line 757
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 758
        jmp     $JustBreak
$SC951:
; Line 762
        dec     ifi.ich_Ifi
; Line 763
        mov     ax,dxp
        sub     ifi.xp,ax
; Line 764
        mov     ax,dxpPr
        sub     ifi.xpPr,ax
        ;xaTab EQU bp-102
        ;xaPr EQU bp-104
;       pchp EQU bp-106
;       register di=pchp
; Line 766
        mov     ax,ifi.xpPrRight
        cmp     ifi.xpPr,ax
        jl      $+5
        jmp     $I952
; Line 772
        cmp     ifi.fPrevSpace,0
        jne     $I956
; Line 776
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 777
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 778
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
; Line 781
$I956:
        cmp     ifi._jc,c_jcTabLeft
        je      $I957
; Line 783
        lea     ax,ifi
        push    ax
        push    xpTab
        push    flm
        call    Justify
; Line 785
$I957:
        mov     ax,ifi.xp
        mov     xpPrev,ax
; Line 788
        push    ifi.xpPr
        push    DXAPRPAGE
        push    DXPPRPAGE
        call    FAR PTR MULTDIV
        mov     xaPr,ax
; Line 789
        jmp     SHORT $L20041
$WC958:
        mov     ax,xaRight
        cmp     xaTab,ax
        jb      $I959
        mov     xaTab,ax
$I959:
; Line 791
        mov     ax,xaPr
        cmp     xaTab,ax
        jb      $I960
; Line 799
        add     ptbd,4
        mov     al, [bx].jc_Tbd
        sub     ah,ah
        and     ax,7
        add     ax,c_jcTabMin
;#ifdef ENABLE /* we do the mapping in HgtbdCreate */
;        cmp    ax,c_jcTabDecimal
;        je     $I1958
;        mov    ax,c_jcTabLeft
;#endif
$I1958:
        mov     ifi._jc,ax
; Line 800
        jmp     SHORT $TabFound
$I960:
        add     ptbd,4
; Line 803
$L20041:
        mov     bx,ptbd
        mov     ax,[bx]
        mov     xaTab,ax
        or      ax,ax
        jne     $WC958
; Line 806
        mov     ax,xaPr
        sub     dx,dx
        mov     cx,WORD PTR VZATABDFLT
        div     cx
        mul     cx
        add     ax,cx
        mov     xaTab,ax
; Line 812
        mov     ifi._jc,c_jcTabLeft
; Line 814
$TabFound:
; Line 815
        push    xaTab
        push    dxpFormat
        push    dxaFormat
        call    FAR PTR MULTDIV
        cmp     ifi.xp,ax
        jle     $I1961
        mov     ax,ifi.xp
$I1961:
        mov     xpTab,ax
; Line 822
        cmp     ifi._jc,c_jcTabLeft
        jne     $I962
; Line 825
        mov     ifi.xp,ax
; Line 826
        push    xaTab
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV
        mov     ifi.xpPr,ax
; Line 828
$I962:
        mov     ax,ifi.xp
        mov     ifi.xpLeft_Ifi,ax
; Line 829
        mov     ax,ifi.ich_Ifi
        mov     ifi.ichLeft,ax
; Line 830
        mov     ifi.cchSpace,0
; Line 831
        mov     ifi.chBreak,0
; Line 832
$Tab0:
; Line 833
        mov     ifi.fPrevSpace,0
; Line 834
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichMac,ax
; Line 835
        mov     ax,ifi.xp
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 836
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 837
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
; Line 838
        mov     ax,dypAscentMac
        add     ax,dypDescentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 841
        cmp     ifi.ichFetch,1
        je      $I963
        mov     ax,ICHPMACFORMAT
        cmp     WORD PTR $S784_ichpFormat,ax
        jne     $L20023
        call    FGrowFormatHeap
        or      ax,ax
        je      $I963
$L20023:
; Line 845
; *********** Register variables ********************
;       rdi_pchp EQU    di
; ****************************************************
;       register di=pchp
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     rdi_pchp,ax
        sub     rdi_pchp,10
        mov     bx,VHGCHPFORMAT
        add     rdi_pchp,[bx]
; Line 846
        cmp     WORD PTR $S784_ichpFormat,0
        jle     $I964
; Line 849
        mov     al,BYTE PTR (ifi.ichPrev)
        mov     BYTE PTR [rdi_pchp].ichRun,al
; Line 850
        mov     ax,ifi.ich_Ifi
        sub     ax,ifi.ichPrev
        mov     BYTE PTR [rdi_pchp].cchRun,al
; Line 853
$I964:
        add     rdi_pchp,10     ; ** ++pchp
        lea     ax,chpLocal  ; ax not destroyed in blt until after value used
                   ;*** macro blt destroys ax,bx,cx,es
        blt     ax,rdi_pchp,c_cwCHP

; Line 854
        inc     WORD PTR $S784_ichpFormat
; Line 856
        jmp     SHORT $I965
$I963:
; Line 858
        mov     ax,10
        imul    WORD PTR $S784_ichpFormat
        mov     rdi_pchp,ax
        sub     rdi_pchp,10
        mov     bx,VHGCHPFORMAT
        add     rdi_pchp,[bx]
; Line 859
$I965:
; Line 860
        mov     al,BYTE PTR (ifi.ich_Ifi)
        mov     BYTE PTR [rdi_pchp].ichRun,al
; Line 861
        or      BYTE PTR [rdi_pchp].cchRun,255

; Line 867
        mov     bx,ifi.ich_Ifi
        inc     ifi.ich_Ifi
        mov     ifi.ichPrev,bx
        shl     bx,1
        mov     ax,ifi.xp
        sub     ax,xpPrev
        mov     WORD PTR VFLI.rgdxp[bx],ax
; Line 869
        cmp     rsi_ch,c_chTab
        jne     $BreakOppr
        jmp     $GetCh
$I952:
; Line 878
        mov     rsi_ch,160
; Line 879
        jmp     $NormChar
$SC968:
; Line 883
        mov     ax,ifi.xpPrRight
        cmp     ifi.xpPr,ax
        jle     $+5
        jmp     $DoBreak
; Line 885
$BreakOppr:
; Line 891
        cmp     ifi.ich_Ifi,255
        jl      $+5
        jmp     $Unbroken
; Line 893
$SC971:
; Line 898
        mov     ifi.chBreak,rsi_ch
; Line 899
        mov     ax,ifi.ichFetch
        add     ax,cchUsed
        cwd
        add     ax,WORD PTR VCPFETCH
        adc     dx,WORD PTR VCPFETCH+2
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 900
        mov     ax,ifi.xp
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 901
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichMac,ax
; Line 902
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 904
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
        add     ax,dypAscentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 906
        cmp     rsi_ch,45
        je      $L20024
        cmp     rsi_ch,31
        jne     $I972
$L20024:
; Line 908
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 909
        mov     ax,ifi.ich_Ifi
        mov     WORD PTR VFLI.ichReal,ax
; Line 910
        mov     ax,ifi.xp
        mov     ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
; Line 912
        jmp     $GetCh
$I972:
; Line 914
        cmp     ifi.fPrevSpace,0
        jne     $I974
; Line 916
        mov     ax,ifi.cchSpace
        mov     ifi.cBreak_Ifi,ax
; Line 917
        mov     ax,ifi.ich_Ifi
        dec     ax
        mov     WORD PTR VFLI.ichReal,ax
; Line 918
        mov     ax,ifi.xp
        mov     WORD PTR VFLI.xpReal_Fli,ax
        sub     ax,dxp
        mov     ifi.xpReal_Ifi,ax
; Line 920
        ;chT EQU bp-108
        ;dxpNew EQU bp-110
$I974:
        cmp     rsi_ch,10
        je      $L20025
        cmp     rsi_ch,11
        jne     $I975
$L20025:
; Line 943
        mov     chT2,c_chSpace
; Line 946
        push    chT2
        push    fFlmPrinting
        call    FAR PTR DxpFromCh
                ; *** ax will contain dxpNew at this point ****
; Line 948
        mov     bx,ifi.ich_Ifi
        mov     dl,BYTE PTR (chT2)
        mov     BYTE PTR VFLI.rgch[bx-1],dl
; Line 950
        shl     bx,1
                ;** difference was -1 in c - shifted to get -2
        mov     WORD PTR VFLI.rgdxp[bx-2],ax   ; ax has dxpNew

        cmp     ifi.fPrevSpace,0   ; only reset vfli.xp/ich real if not prev sp
        jne     $TestEol

        sub     ax,dxp
        add     WORD PTR VFLI.xpReal_Fli,ax
; Line 956
        mov     ax,ifi.ich_Ifi
        dec     ax
        mov     WORD PTR VFLI.ichReal,ax
; Line 961
$TestEol:
        cmp     rsi_ch,10
        je      $+5
        jmp     $JustBreak
; Line 963
$JustEol:
; Line 964
        cmp     fFlmPrinting,0
        je      $I979
; Line 966
        mov     ax,WORD PTR VFLI.ichReal
        mov     WORD PTR VFLI.ichMac,ax
; Line 972
$I979:
        cmp     ifi._jc,c_jcTabLeft
        je      $+5
        jmp     $L20051
; Line 980
        mov     bx,ppap
        mov     al,BYTE PTR [bx].jc_Pap
        and     ax,3        ; pick up low 2 bits in ax
        mov     ifi._jc,ax
        cmp     ax,3
        je      $I996
        jmp     SHORT $L20050
$I975:
        inc     ifi.cchSpace
; Line 995
        mov     ifi.fPrevSpace,1
; Line 1093
        jmp     $GetCh
$I987:
        mov     ax,ifi.ichFetch
        add     ax,cchUsed
        cwd
        add     ax,WORD PTR VCPFETCH
        adc     dx,WORD PTR VCPFETCH+2
        sub     ax,1
        sbb     dx,0
        mov     WORD PTR VFLI.cpMac_OFF,ax
        mov     WORD PTR VFLI.cpMac_SEG,dx
; Line 1016
        mov     ax,ifi.ich_Ifi
        dec     ax
        mov     WORD PTR VFLI.ichMac,ax
        mov     WORD PTR VFLI.ichReal,ax
; Line 1017
        mov     ax,ifi.dypLineSize
        mov     WORD PTR VFLI.dypLine,ax
; Line 1019
        mov     ax,dypDescentMac
        mov     WORD PTR VFLI.dypBase,ax
        add     ax,dypAscentMac
        mov     WORD PTR VFLI.dypFont,ax
; Line 1020
        mov     WORD PTR VFLI.dcpDepend,1
; Line 1021
        mov     ax,ifi.xp
        sub     ax,dxp
	mov	ifi.xpReal_Ifi,ax
        mov     WORD PTR VFLI.xpReal_Fli,ax
$I994:
        mov     bx,ppap
        mov     al,BYTE PTR [bx].jc_Pap
        and     ax,3
        mov     ifi._jc,ax
$L20050:
        or      ax,ax
        je      $I996
; Line 1065
        lea     ax,ifi
        push    ax
        push    ifi.xpRight_Ifi
$L20046:
        push    flm
        call    Justify
; Line 1067
$I996:
        mov     ax,ifi.xpRight_Ifi
$L20043:
        mov     WORD PTR VFLI.xpRight,ax
; Line 1068
$EndFormat:
; Line 1069
        mov     ax,ifi.ichLeft
        mov     WORD PTR VFLI.ichLastTab,ax
        jmp     SHORT $ScribRet ; Scribble and return
$L20028:
        cmp     ax,13
        jne     $+5
        jmp     $SC938
        cmp     ax,31
        jne     $+5
        jmp     $SC939
        cmp     ax,45
        jne     $+5
        jmp     $SC968
        jmp     $DefaultCh
$ScribRet:
IFDEF DEBUG
IFDEF SCRIBBLE
        mov     ax,5
        push    ax
        mov     ax,c_chSpace
        push    ax
        call    FAR PTR FNSCRIBBLE
ENDIF
ENDIF
; Line 1096
$RetFormat:
        cEnd FormatLine

        subttl Justify()
        page
; ***
;  Function Justify
;
;  near Justify(pifi, xpTab, flm)
;  struct IFI *pifi;
;  unsigned xpTab;
;  int flm;
;
; ***

; Line 1101
        cProc Justify,<PUBLIC,NEAR>,<di,si>
                parmDP  pifi
                parmW   xpTab
                parmW   flm

                LocalW  cWideSpaces
                LocalW  cxpQuotient
; *********** Register variables ********************
        rbx_pifi        EQU     bx
        rdx_dxp         EQU     dx
; ****************************************************
        cBegin Justify
; Line 1109
        mov     rbx_pifi,pifi
; Line 1110
        mov     ax,[rbx_pifi]._jc
        cmp     ax,c_jcBoth
        je      $JcBothCase
        cmp     ax,c_jcCenter
        je      $JcCenterCase
        cmp     ax,c_jcRight
        je      $JcRightCase
        cmp     ax,c_jcTabDecimal
        jne     $JustCaseBrk
; Line 1130
JcTabDecCase:
; *********** Register variables ********************
        rsi_ichT        EQU     si
; ****************************************************
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpLeft_Ifi
; Line 1132
        mov     rsi_ichT,[rbx_pifi].ichLeft
        inc     rsi_ichT
$TabDecFor:
        cmp     rsi_ichT,WORD PTR VFLI.ichReal
        jge     $JustCaseBrk
	mov     al,VCHDECIMAL
        cmp     BYTE PTR VFLI.rgch[rsi_ichT],al
        je      $JustCaseBrk
; Line 1134
        shl     rsi_ichT,1
        sub     rdx_dxp,WORD PTR VFLI.rgdxp[rsi_ichT]
        shr     rsi_ichT,1
; Line 1135
        inc     rsi_ichT
        jmp     SHORT $TabDecFor

$JcCenterCase:
; Line 1139
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpReal_Ifi
        or      rdx_dxp,rdx_dxp
        jg      $+5
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1141
        sar     rdx_dxp,1
; Line 1144

$JustCaseBrk:
; Line 1212
        cmp     rdx_dxp,0
        jle     $+5
        jmp     $JustCleanup
; Line 1215
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************

$JcRightCase:
; Line 1147
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpReal_Ifi
; Line 1148
        jmp     SHORT $JustCaseBrk

$JcBothCase:
; *********** Register variables ********************
        rdi_pch         EQU     di
        rsi_pdxp        EQU     si
; ***************************************************
                ; **** NOTE: the only way out of this section of code
                ; **** is through a RETURN of function Justify
; Line 1151
        cmp     WORD PTR [rbx_pifi].cBreak_Ifi,0
        jne     $+5
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1154
        mov     rdx_dxp,xpTab
        sub     rdx_dxp,[rbx_pifi].xpReal_Ifi
        or      rdx_dxp,rdx_dxp
        jg      $+5
        jmp     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1160
        add     [rbx_pifi].xp,rdx_dxp
; Line 1164
        add     WORD PTR VFLI.xpReal_Fli,rdx_dxp
; Line 1165
; Line 1176
                ; register CHAR *pch = &vfli.rgch[vfli.ichReal]
                ; register int *pdxp = &vfli.rgdxp[vfli.ichReal]

        mov     rdi_pch,WORD PTR VFLI.ichReal
        mov     rsi_pdxp,rdi_pch

        add     rdi_pch,OFFSET VFLI.rgch

        shl     rsi_pdxp,1
        add     rsi_pdxp,OFFSET VFLI.rgdxp

   ; ************ dx /(dxp) will be wiped out and restored here !!!!!!!!!!!!!!!
        push    dx              ; save for use as dxpT

        mov     ax,dx          ; ** set up division
        cwd
        mov     cx,[rbx_pifi].cBreak_Ifi
        idiv    cx
        mov     WORD PTR VFLI.dxpExtra,ax
                ; ** at this point:
                ; **  ax = quotient, dx = remainder, cx = cbreak
        inc     ax

; *********** Register variables ********************
        rdx_dxpT        EQU     dx
; ***************************************************

        mov     cxpQuotient,ax
        mov     cWideSpaces,dx

        pop     dx              ; restore for use as dxpT

; Line 1183
        mov     BYTE PTR VFLI.fAdjSpace,c_True
; Line 1185
        ; ***** NOTE: the only way out of this loop is via a RETURN out of
        ; *****       function Justify
        ; * the immediately following loop accomplishes about the same thing as
; ** Loop:
        ;   dec rdi_pch
        ;   sub rsi_pdxp,2
        ;   cmp BYTE PTR [rdi_pch],c_chSpace
        ;   jne Loop
        ; * it should be faster for strings of > 2 characters.

        dec     rdi_pch  ; since predecrement to start pch correctly
        mov     ax,ds
        mov     es,ax   ; set up for string instruction
        std             ; use reverse direction for decrementing di
$JstForLoop:
        mov     cx,-1   ; counter set up 1 below (trick)
        mov     al,c_chSpace    ; comparison value
        repnz   scasb           ; dec di while not = space
        inc     cx              ; restore from original -1
        shl     cx,1            ; si is a word ptr  - double offset
        add     rsi_pdxp,cx
                                ; at this point, pch points 1 below
                                ; the character containing the space,
                                ; pdxp points to the entry for the space char
; Line 1192
        mov     ax,cWideSpaces
        dec     cWideSpaces
        or      ax,ax
        jne     $I1032
; Line 1194
        dec     cxpQuotient
; Line 1195
	push	rsi_pdxp	; find first nonzero ich after pch
	cld
$FindIch1:
	inc	rsi_pdxp
	inc	rsi_pdxp
	cmp	WORD PTR [rsi_pdxp],0
	je	$FindIch1
        mov     ax,rsi_pdxp
        sub     ax,OFFSET VFLI + rgdxp
	shr	ax,1
	std
	pop	rsi_pdxp

        mov     BYTE PTR VFLI.ichFirstWide,al

; Line 1197
$I1032:
        mov     ax,cxpQuotient
        add     [rsi_pdxp],ax
; Line 1198
        sub     rdx_dxpT,ax
        cmp     rdx_dxpT,0
        jg      $I1033
; Line 1200
        cmp     WORD PTR [rbx_pifi].cBreak_Ifi,1
        jle     $JustifyRet
                ; **** EXIT POINT *****************************
; Line 1202
	push	rsi_pdxp	; find first nonzero ich after pch
	cld
$FindIch2:
	inc	rsi_pdxp
	inc	rsi_pdxp
	cmp	WORD PTR [rsi_pdxp],0
	je	$FindIch2
        mov     ax,rsi_pdxp
        sub     ax,OFFSET VFLI + rgdxp
	shr	ax,1
	pop	rsi_pdxp

        mov     BYTE PTR VFLI.ichFirstWide,al
; Line 1204
        jmp     SHORT $JustifyRet
                ; **** EXIT POINT *****************************
$I1033:
        dec     WORD PTR [rbx_pifi].cBreak_Ifi
; Line 1208
        jmp     SHORT $JstForLoop  ; *** end of for loop **********


; *********** Register variables ********************
        rbx_pifi        EQU     bx
        rdx_dxp         EQU     dx
; ****************************************************

$JustCleanup:
        add     [rbx_pifi],rdx_dxp
        mov     ax,rdx_dxp
; Line 1220
        test    flm,1   ;* if (flm & flmPrinting)
        jne     $L20052
; Line 1228
        push    rdx_dxp     ; save - wiped out by multiply

        push    rdx_dxp
        mov     ax,c_czaInch
        push    ax
        push    DXPLOGINCH
        call    FAR PTR MULTDIV
        push    ax
        push    DXPPRPAGE
        push    DXAPRPAGE
        call    FAR PTR MULTDIV

        mov     rbx_pifi,pifi   ; restore in case multdiv wipes out bx
        pop     rdx_dxp     ; restore - wiped out by multdiv
$L20052:
        add     [rbx_pifi].xpPr,ax
; Line 1231
        cmp     WORD PTR [rbx_pifi].ichLeft,0
        jge     $I1038
; Line 1234
        add     WORD PTR VFLI.xpLeft_Fli,rdx_dxp
; Line 1236
        jmp     SHORT $I1039
$I1038:
; Line 1239
        mov     bx,[rbx_pifi].ichLeft ; *** here, bx is no longer pifi ****
        shl     bx,1
        add     WORD PTR VFLI.rgdxp[bx],rdx_dxp
; Line 1240
$I1039:
; Line 1241
        add     WORD PTR VFLI.xpReal_Fli,rdx_dxp
; Line 1242
$JustifyRet:
        cld     ; reset to be nice to later routines
        cEnd Justify


; Line 1247
        subttl FGrowFormatHeap()
        page

; ***
;  Function FGrowFormatHeap
;
;  int near FGrowFormatHeap()
;      /* Grow vhgchpFormat by 20% */
;
; ***

        cProc FGrowFormatHeap,<PUBLIC,NEAR>
        cBegin FGrowFormatHeap

; *********** Register variables ********************
        rsi_cchpIncr    EQU     si
; ****************************************************

; Line 1249
        mov     ax,ICHPMACFORMAT
        cwd
        mov     cx,5
        idiv    cx
        inc     ax
        mov     rsi_cchpIncr,ax
; Line 1255
        push    VHGCHPFORMAT
        add     ax,ICHPMACFORMAT
        imul    cx
        push    ax
        xor     ax,ax
        push    ax
        call    FAR PTR FCHNGSIZEH
        or      ax,ax
        jne     $I1043
; Line 1260
        xor     ax,ax
        jmp     SHORT $EX1040
$I1043:
        add     ICHPMACFORMAT,rsi_cchpIncr
; Line 1263
        mov     ax,1
$EX1040:
        cEnd    FGrowFormatHeap


; Line 1269
        subttl DxpFromCh()
        page

; ***
;  Function DxpFromCh
;
;  int DxpFromCh(ch, fPrinter)
;  int ch;
;  int fPrinter;
;
; ***


        cProc DxpFromCh,<PUBLIC,FAR>
                parmW   chIn
                parmW   fPrinter

                LocalW  dxpDummy
                LocalW  dxp
        cBegin DxpFromCh

; *********** Register variables ********************
        rbx_pdxp        EQU     bx
; ****************************************************

; Line 1276
        cmp     chIn,c_chSpace
        jg      $L20029
	cmp	chIn,c_chNRHFile
	jge	$L20026
	cmp	chIn,c_chTab
	jl	$L2029A
	cmp	chIn,c_chReturn
	jg	$L2029A
$L20026:
        cmp     fPrinter,0
        je      $L20027
        mov     rbx_pdxp,OFFSET VFMIPRINT+2
        jmp     SHORT $I1050
$L20027:
        mov     rbx_pdxp,OFFSET VFMISCREEN+2
        jmp     SHORT $I1050
$L20029:
        cmp     chIn,256    ; prev 128 (chFmiMax)  ..pault 
                            ; We now make sure the whole character set width 
                            ; table is queried initially via GetCharWidth()
        jl      $I1049
; Line 1279
$L2029A:
        lea     rbx_pdxp,dxpDummy
; Line 1280
        mov     WORD PTR [rbx_pdxp],dxpNil
; Line 1282
        jmp     SHORT $I1050
$I1049:
; Line 1285
        cmp     fPrinter,0
        je      $L20030
        mov     rbx_pdxp,WORD PTR VFMIPRINT
        jmp     SHORT $L20031
$L20030:
        mov     rbx_pdxp,WORD PTR VFMISCREEN
$L20031:
        mov     ax,chIn
        shl     ax,1
        add     rbx_pdxp,ax
; Line 1286
$I1050:
; Line 1288
        cmp     WORD PTR [rbx_pdxp],dxpNil
        jne     $I1051
; Line 1295
        push    bx              ; save pdxp

        cmp     fPrinter,0
        je      $L20032
        push    VHDCPRINTER
        lea     ax,chIn
        push    ss
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR GETTEXTEXTENT
        sub     ax,WORD PTR VFMIPRINT+4
        jmp     SHORT $L20033
$L20032:
        push    VHMDC
        lea     ax,chIn
        push    ss
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR GETTEXTEXTENT
        sub     ax,WORD PTR VFMISCREEN+4
$L20033:
        pop     bx              ; restore pdxp
; Line 1297
        ;or      ax,ax   ; ax == dxp
        ;jl      $I1053
        ;cmp     ax,dxpNil
        ;jge     $I1053
; Line 1300
        mov     [rbx_pdxp],ax
; Line 1303
$I1053:
        jmp     SHORT $DxpRet
$I1051:
        mov     ax,WORD PTR [rbx_pdxp]
$DxpRet:
        cEnd    DxpFromCh

        subttl FFirstIch()
        page
; Line 1312

; ***
;  Function FFirstIch
;
;  int near FFirstIch(ich)
;  int ich;
;    {
;      /* Returns true iff ich is 0 or preceded only by 0 width characters */
;
;   REGISTER USAGE ******************************
;      uses and restores: di
;      uses and destroys: ax, cx, es
;      ax = temp, return
;      cx = ich
;      di = pdxp
;
;  Note: this implements, in a different manner, the c code:
;
;     for (ichT = 0; ichT < ich; ichT++)
;        {
;          if (*pdxp++)
;             return false
;         }
;    return true;
; ***

        cProc FFirstIch,<PUBLIC,NEAR>,<di>
                parmW   ich

        cBegin FFirstIch

; *********** Register variables ********************
        rdi_pdxp        EQU     di
        rcx_ich EQU     cx
; ****************************************************
; Line 1316
        mov     ax,ds   ; set es=ds for string ops
        mov     es,ax

        mov     rdi_pdxp,OFFSET VFLI.rgdxp
        mov     rcx_ich,ich     ; loop count in cx
        cld

        xor     ax,ax         ; this does 3 things:
                                ;  - sets up the compare value for scasb
                                ;  - sets a 0 (false) default return value
                                ;  - sets the zero flag on. This will allow
                                ; a zero value of ich to correctly return
                                ; true. This instruction MUST immediately
                                ; precede the repz scasw instruction.
        repz    scasw           ; test *pdxp = 0
        jnz     $FFRet          ; non zero char found - return false
        inc     ax              ; return TRUE if all 0 or ich = 0
$FFRet:
        cEnd    FFirstIch


        subttl ValidateMemoryDC()
        page

;       ValidateMemoryDC()

        cProc ValidateMemoryDC,<PUBLIC,FAR>
        cBegin ValidateMemoryDC

; /* Attempt to assure that vhMDC and vhDCPrinter are valid.  If we have not
; already run out of memory, then vhDCPrinter is guaranteed, but vhMDC may
; fail due to out of memory -- it is the callers responsibility to check for
; vhMDC == NULL. */

; /* If we are out of memory, then we shouldn't try to gobble it up by getting
; DC's. */
        cmp     VFOUTOFMEMORY,0
        jne     $I862
        cmp     VHMDC,0
        jne     $I858
        mov     bx,PWWDCUR
        push    WORD PTR [bx+50]
        call    FAR PTR CREATECOMPATIBLEDC
        mov     VHMDC,ax
; /* Callers are responsible for checking for vhMDC == NULL case */
        or      ax,ax
        je      $I858
; /* Put the memory DC in transparent mode. */
        push    ax
        mov     ax,1
        push    ax
        call    FAR PTR SETBKMODE
; /* If the display is a monochrome device, then set the text color for the
; memory DC.  Monochrome bitmaps will not be converted to the foreground and
; background colors in this case, we must do the conversion. */
        mov     bx,PWWDCUR
        push    WORD PTR [bx+50]
        mov     ax,24
        push    ax
        call    FAR PTR GETDEVICECAPS
        cmp     ax,2
        jne     $I854
        mov     ax,1
        jmp     SHORT $I856
$I854:
        xor     ax,ax
$I856:
        mov     VFMONOCHROME,ax
        or      ax,ax
        je      $I858
        push    VHMDC
        push    WORD PTR RGBTEXT+2
        push    WORD PTR RGBTEXT
        call    FAR PTR SETTEXTCOLOR
$I858:
; /* If the printer DC is NULL then we need to restablish it. */
	cmp	VHDCPRINTER,0
	jne	$I862
	xor	ax,ax
	push	ax
	call	FAR PTR GETPRINTERDC
$I862:
        cEnd ValidateMemoryDC

        sEnd FORM1_TEXT
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\heapdata.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef OURHEAP
/*
	heapData.h - include file for the share data of the heap modules.
*/

extern HH      *phhMac;      
extern int     *pHeapFirst;  
extern FGR     *rgfgr;      
extern FGR     *pfgrMac;    
extern FGR     *pfgrFree; 
extern HH      *phhFree; 
extern int     *pmemMax;
#ifdef DEBUG
extern int fStoreCheck, fNoShake;
#endif
		/* CONSTANTS */
#define bhh             (-1)        /* finds hunk given hh  */
#define cfgrBlock	10
#define ifgrInit        60          /* defines the initial number of finger
				       pointers. */
#define cwHunkMin       cwof(HH)    /* minimum number of words in a hunk */
				    /* including the header (1 word) */
#define cwReqMin	(cwHunkMin - 1) /* how small a request can be */

extern int     cwHeapMac;   
extern unsigned cbTot, cbTotQuotient, cwHeapFree;
#endif /* OURHEAP */
extern int     *memory; 


#define cwSaveAlloc     (128)   /* A buffer (vhrgbSave) of this size is */
				/* allocated off of */
				/* the heap in init.  It is freed during */
				/* the save operation so we have enough */
				/* heap space to complete the save */
				/* operation.  After the save is complete, */
				/* we try to reclaim this space so the next */
				/* save operation will have a fighting */
				/* chance to complete. */
#define cwHeapMinPerWindow  50  /* We expand the vhrgbSave buffer by this */
				/* amount every time we open a new window. */
				/* The theory is that for every additional */
				/* window, we can conceivable require an */
				/* additional save operation which may eat */
				/* up space.  A save operation may require */
				/* space for an fcb and new run table. */
				/* On the other hand, the save operation */
				/* reduces the size of the piece table and*/
				/* thus frees some space.  Whether this will*/
				/* free enough space for the save operation */
				/* is impossible to tell at the time we */
				/* open the window.*/


#define cwHeapSpaceMin  (60)    /* once heap space is below this amount,
				   the main loop will disable all menu
				   commands except save, saveas, and quit. */


#define ibpMaxSmall (30)  /* pages in rgbp if we were in a tight memory environment */
#define ibpMaxBig   (60)  /* pages in rgbp if we were in a bigger memory environment */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\globdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* ****************************************************************************
**
**      COPYRIGHT (C) 1985 MICROSOFT
**
** ****************************************************************************
*
*  Module: globdefs.h - text for static arrays and other uses. Change this
*                      module when internationalizing.
*
*  Functions included: none
*
**
** REVISIONS
**
** Date         Who Rel Ver     Remarks
** 10/20/89     fgd             Win 3.0. Some defines have been moved to write.rc
** 07/08/86     yy              addition of reverse string for unit parsing.
** 11/20/85     bz              initial version
**
** ***************************************************************************/

/* NOTE NOTE NOTE
Win 3.0.  In order to easy the localization of Write, some string defines
have been removed from here and placed into write.rc
*/

#define utDefault utCm  /* used to set utCur - may be utInch or utCm */
#define vzaTabDfltDef (czaInch / 2) /* width of default tab in twips */
                                   /* note that czaCm is also available */



#define szExtWordDocDef  ".DOC"
#define szExtWordBakDef  ".BAK"
#define szExtDrvDef  ".drv"
#define szExtGlsDef  ".GLS"


#ifdef KINTL
#define szExtDocDef  ".WRI"    /* this and next extension should be the same */
#define szExtSearchDef  "\\*.WRI"    /* store default search spec */
#define szExtBackupDef  ".BKP"
#else
#define szExtDocDef  ".DOC"   /* This and next extension should be the same */
#define szExtSearchDef "\\*.DOC"  /* Store default search spec. */
#define szExtBackupDef ".BAK"
#endif /* if-else-def INTL */


#define szWriteProductDef  "MSWrite"   /* WIN.INI: our app entry */
#define szFontEntryDef  "Fontx"        /* WIN.INI: our font list */
#define szSepNameDef  " - "  /* Separates AppName from file name in header */

#ifdef STYLES
#define szSshtEmpty "NORMAL.STY"
#endif /* STYLES */


/* Strings for parsing the user profile. */
#define szWindowsDef  "windows"
#define szDeviceDef  "Device"
#define szDevicesDef  "devices"
#define szBackupDef  "Backup"

#if defined(JAPAN) || defined(KOREA) //Win3.1J
#define szWordWrapDef  "WordWrap"
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
#define szImeHiddenDef "IMEHidden"
#endif

  /* used to get decimal point character from user profile */
#define szIntlDef "intl"
#define szsDecimalDef "sDecimal"
#define szsDecimalDefaultDef "."
#define sziCountryDef "iCountry"
                  /* see msdos manual for meaning of codes */

/* Strings for our window classes (MUST BE < 39 CHARS) */

#define szParentClassDef  "MSWRITE_MENU"
#define szDocClassDef  "MSWRITE_DOC"
#define szRulerClassDef  "MSWRITE_RULER"
#define szPageInfoClassDef  "MSWRITE_PAGEINFO"

#ifdef ONLINEHELP
#define szHelpDocClassDef  "MSWRITE_HELPDOC"
#endif

  /* used in fileutil.c  - name of temp file */
#ifdef INTL
#define szMWTempDef "~WRI0000.TMP"
#else
#define szMWTempDef "~DOC0000.TMP"
#endif

  /* used in fontenum.c  */
#define szSystemDef "System"

#ifdef  DBCS_VERT       /* was in JAPAN, changed it to DBCS */
// Vertical orientation systemfont facename [yutakan:08/09/91]
#define szAtSystemDef "@System"
#endif

  /* used in initwin.c  */

#define szMw_acctbDef "mw_acctb"
#define szNullPortDef "NullPort"
#define szMwloresDef "mwlores"
#define szMwhiresDef "mwhires"
#define szMw_iconDef "mw_icon"
#define szMw_menuDef "mw_menu"
#define szScrollBarDef "ScrollBar"

  /* used in pictdrag.c  */
#define szPmsCurDef "pmscur"


  /* used in screen.c  - available font family names */
#define szModernDef "Modern"
#define szRomanDef "Roman"
#define szSwissDef "Swiss"
#define szScriptDef "Script"
#define szDecorativeDef "Decorative"

  /* used in util2.c  abbreviations for units */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\heapdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*
	heapDefs.h - include file for the storage allocator.

*/

#if 0
	Storage allocation
    NULL
      |
      |    pHeapFirst
      |    ________________
      |    |_____cw________| hh
      |    |     block     | *Fgr <----------------------\
      |    |       of      |                             |
      |    |     words     |                             |
      |    |_______________|                             |
 phhFree---->______cw______| hh                          |
      |--|------phhNext____|                             |
	 | |____phhPrev--------------|                   |
	 | |               |         |                   |
	 | |               |         |                   |
	 | |               |         |                   |
	 | |    block      |         |                   |
	 | |      of       |         |                   |
	 | |    words      |         |                   |
	 | |_______________|         |                   |
	 | |_____cw________|         |                   |
	 | |     .         | *Fgr<---|-------------------|-\
	 | |---------------|         |                   | |
	 | |_____cw________|<--------/                   | |
	 |-----phhNext_____|                             | |
	   |   phhPrev---------|                         | |
	   |               |   |                         | |
	   |               |  NULL                       | |
	   |_______________|                             | |
	   |___shake_word__| (if needed) <-----phhMac    | |
  rgfgr--->|_____________--|-----------------------------/ |
 pfgrFree->|___________----|--\                            |
	   |_____________--|--|----------------------------/
	/--|--_____________|<-/
	\->|_____________--|-->NULL



 rgfgr can be indexed as an array with ifgrMac elements.
 The finger table slots are each one word in size.
 Putting the finger table at the high end of memory relies on the coding of
    of the CompactHeap routine; it moves the allocated blocks to low memory.
 The free list is threaded with addresses, NOT indexes.
 cw for a hunk includes size of header
 cw for a free hunk is negative the size of the hunk
 pfgr user's pointer to finger
 fgr pointer to hunk of whatever
 phh pointer to hunk header
 phhPrevs move toward the bottom of the free list
 phhNexts move toward the top
 phhFree should always have a phhNext of NULL (i.e. the list is just double,
    not circular).
				_________________
				|______cw_______|
     pph  -----> ph ----------->|      .        |
     (FGR *)    (FGR)           |      .        |
				|      .        |
				|_______________|


				_________________
		      phh ----->|______cw_______|
				|___phhNext_____|
				|___phhPrev_____|
				|      .        |
				|      .        |
				|      .        |
				|_______________|

#endif

typedef int *FGR;       /* definitions for finger-related stuff. */
typedef int **PFGR;

/* storage allocator related stuff */
struct _HH
	{
	int             cw;
	struct  _HH     *phhNext;
	struct  _HH     *phhPrev;
	};
typedef struct _HH HH;


#ifdef OURHEAP
		/* MACROS */
#define CwOfPfgr(pFgr)       (*(*(pFgr) + bhh))
#define CwOfPhh(phh)         ((phh)->cw)
#ifdef DEBUG
#define fPointsFgrTbl(pfgr)  (((FGR *)(pfgr) >= rgfgr) && ((FGR *)(pfgr) < pfgrMac))
#endif

FGR  	*PfgrAllocate();
FGR	*PfgrCopy();
extern ENV envMem;
#define cwof(i)         ((sizeof(i)+sizeof(int)-1)/sizeof(int))

#endif /* OURHEAP */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\heapmain.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCTLMGR
#define NOCLIPBOARD
#define NOMSG
#define NOGDI
#define NOMB
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
/*
    HeapManage.c - several routines to manage the heap, including changing
            the finger table, compacting the heap in general, and checking the
            heap for consistency.
            It also contains the routines which were once in heapNew.
*/
#include "code.h"
#include "heapDefs.h"
#include "heapData.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "filedefs.h"
#include "docdefs.h"


extern CHAR       (*rgbp)[cbSector];
extern CHAR       *rgibpHash;
extern struct BPS *mpibpbps;
extern int        ibpMax;
extern int        iibpHashMax;
extern int        cwInitStorage;
extern typeTS     tsMruBps;


FTryGrow(unsigned);


PFGR  HAllocate(cwRequest)
unsigned cwRequest;
{
unsigned cb = cwRequest * sizeof(int);
HANDLE hTemp;

    Assert(*(pLocalHeap+1) == 0);

    if (cwRequest >= 0x8000)
        {
#ifdef DEBUG
        Assert(0);
        ErrorWithMsg(IDPMTRottenFile, " heapMan#1");
#else
        Error(IDPMTRottenFile);
#endif
        return((PFGR)hOverflow);
        }

    hTemp = LocalAlloc(LHND, cb);
    if (hTemp != NULL)
        return((PFGR)hTemp);
    else if (FTryGrow(cb))
        {
        return((PFGR)LocalAlloc(LHND, cb));
        }
    else
        {
#ifdef DEBUG
        ErrorWithMsg(IDPMTNoMemory, " heapMan#1");
#else
        Error(IDPMTNoMemory);
#endif
        return((PFGR)hOverflow);
        }
}

FChngSizeH(pfgrChng, cwRequest, fShrink)
PFGR pfgrChng;
int  cwRequest, fShrink;
{
unsigned cb = cwRequest * sizeof(int);
#ifdef DEBUG
PFGR pfgrNew;
#endif

    Assert(*(pLocalHeap+1) == 0);   /* Check for frozen heap */
    Assert(cwRequest >= 0);

    if ((
#ifdef DEBUG
    pfgrNew =
#endif
    (PFGR)LocalReAlloc( (HANDLE)pfgrChng, cb, LHND)) != NULL)
        {
        Assert( pfgrNew == pfgrChng );  /* Windows guarantees this for
                                           movable objects */
        return( TRUE );
        }
    else if (FTryGrow(cb))
        {
#ifdef DEBUG
        pfgrNew = 
#endif
        (PFGR)LocalReAlloc( (HANDLE)pfgrChng, cb, LHND);
        Assert( pfgrNew != (PFGR)NULL );
        Assert( pfgrNew == pfgrChng );
        return( TRUE );
        }
    else
        {
#ifdef DEBUG
        ErrorWithMsg( IDPMTNoMemory, " heapMan#2" );
#else
        Error( IDPMTNoMemory );
#endif
        return( FALSE );
        }
}



CHAR (**HszCreate(sz))[]
CHAR sz[];
{ /* Creates a heap block containing sz */
CHAR (**hsz)[];
int cch = CchSz(sz);
hsz = (CHAR (**)[]) HAllocate(CwFromCch(cch));
if (FNoHeap(hsz))
        return (CHAR (**)[])hOverflow;
bltbyte(sz, **hsz, cch);
return hsz;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\heapinit.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCTLMGR
#define NOCLIPBOARD
#define NOMSG
#define NOGDI
#define NOMB
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>
#include "mw.h"

#ifdef OURHEAP
/*
        heapInit.c - one routine to calculate the proper information for
            heap management.
*/

#include "code.h"
#include "heapDefs.h"
#include "heapData.h"
#include "str.h"
#ifdef ENABLE
#include "memDefs.h"
#endif

/* heap specific data */
HH      *phhMac;      /* May change if grow heap */
int     cwHeapMac;    /*  "    "     "  "     "     "      "      "   */
int     *pHeapFirst;  /* change if the finger table rgfgr expands */
FGR     *rgfgr;       /* Declared as a pointer, but also used as an array. */
FGR     *pfgrMac;      /* Initially equal to &rgfgr[ifgrInit]; */
FGR     *pfgrFree;     /* Singly linked with a trailing NULL pointer. */
HH      *phhFree;     /* May be NULL along the way. */
ENV     envMem;
int     fMemFailed;
int     cwInitStorage;




FExpandFgrTbl()

/* Will expand the finger table.  This routines depends upon the fact
that the CompactHeap routine moves the allocated blocks to the
low end of memory.  The new space from the finger table comes from
the tail end of the (only) free block left after a compaction.
The finger is expanded by at most 'cfgrNewMax' and at least 1.
If there is no room to expand the finger table, then nothing is
changed.  To expand the table, several pointers and integers are
decreamented to reflect the reallocation of the storage.  Then
we recalculate the memory totals so the user
will have an acurate display of the percent free and total bytes
available.  The new fingers are linked so that the finger at the
low end of the table is at the end of the list.
(To expand the finger table there must be no fingers available.)
*/

{
FGR *pfgr;
int cfgrNew = cfgrBlock;
register HH *phhNew;

#ifdef DEBUG
    if (pfgrFree != NULL)
        panicH(34);
#endif

    if (!FCwInMem(cfgrNew + cwReqMin + 1))
        {
        /* couldn't get a block's worth - could we get one? */
        cfgrNew = 1;
        if (!FCwInMem(cfgrNew))
            /* no way to help this guy */
            return(FALSE);
        }
            
    phhNew = (HH *)pHeapFirst;
    if (phhNew->cw > 0 || !FHhFound(phhNew, cfgrNew))
        {
        /* we tried but failed to find an adequate free
           block at start of heap */
        CompactHeap();
        MoveFreeBlock(pHeapFirst);
        }

    if (!FPhhDoAssign(phhNew, cfgrNew))
        return(FALSE);

/* we have a block which is FIRST in the heap - let's steal it */
    cfgrNew = phhNew->cw; /* in case it was more than we
                             asked for */
    pHeapFirst = pHeapFirst + cfgrNew;
    pfgrMac += cfgrNew;
    cwHeapMac -= cfgrNew;

/* do some initialization if pfgrFree is not NULL and you
want the new fingers at the very end of the free finger list */
    for (pfgr = pfgrMac - cfgrNew; pfgr < pfgrMac; pfgr++)
        {
        *pfgr = (FGR)pfgrFree;
        pfgrFree = pfgr;
        }

/*  do we need this anymore? (cwInitStorage = cwHeapMac - cwHeapFree)
        cbTot = (cwHeapMac - cwInitStorage) * sizeof(int);
        cbTotQuotient = (cbTot>>1)/100;
*/
        return(TRUE);

} /* End of FExpandFgrTbl () */



CompactHeap()
        /* moves all allocated hunks  */
        /* toward beginning of pHeapFirst. Free hunks   */
        {
        HH      *phh, *phhSrc, *phhDest;   /* are combined into one hunk */
        FGR     *pfgr;
        int     cwActual;

#ifdef DEBUG
        StoreCheck();
#endif

        /* set up for compaction by placing cw of hunk in rgfgr and an
           index into rgfgr in the hunk                            */
        for (pfgr = rgfgr; pfgr < pfgrMac; pfgr++)
                {
                if (FPointsHeap(*pfgr))
                        /* if rgfgr[ifgr] points to heap... */
                        {
                        phh = (HH *)(*pfgr + bhh);
                                /* find header */
                        *pfgr = (FGR)phh->cw;
                        /* coerce so it fits, force the shift */
                        phh->cw = (int)(((unsigned)pfgr - (unsigned)rgfgr)/2);
                        }
                }
                /* now we have cw in rgfgr and ifgr in phh */
        phhSrc = (HH *) pHeapFirst;
        phhDest = phhSrc;
        while (phhSrc < phhMac)
                {
                if (phhSrc->cw < 0)
                        /* free hunk, don't recopy */
                        phhSrc = (HH *)((int *) phhSrc - phhSrc->cw);
                 else
                        {
                        pfgr = &rgfgr[phhSrc->cw];
                                /* find h */
                        cwActual = phhSrc->cw = (int) *pfgr;
                                /* restore cw */
                        *pfgr = ((FGR) phhDest - bhh);
                                /* update ha */
                        blt((int *)phhSrc, (int *)phhDest, (unsigned)cwActual);
                                /* unless ptrs are = */
                        phhDest = (HH *) ((int *) phhDest + cwActual);
                        phhSrc = (HH *) ((int *) phhSrc + cwActual);
                        }
                }

#ifdef DEBUG
        if ((int *)phhDest + cwHeapFree - cwHunkMin >= (int *)phhMac)
                panicH(35);
#endif
        phhFree = phhDest;
        phhFree->cw = -cwHeapFree;
        phhFree->phhNext = phhFree->phhPrev = phhFree;
#ifdef DEBUG
        StoreCheck();
#endif
        }

#endif /* NOT WINHEAP */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\format2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* format2.c -- MW formatting routines */
/* Less used subroutines */


#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "ffdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "printdef.h"
#include "str.h"
#include "wwdefs.h"

extern struct FLI	vfli;
extern struct SEP	vsepAbs;
extern typeCP		vcpFirstSectCache;
extern typeCP		vcpFetch;
extern int		vcchFetch;
extern CHAR		*vpchFetch;
extern int		vpgn;
extern CHAR		stBuf[];
extern struct DOD	(**hpdocdod)[];
extern struct WWD	rgwwd[];
extern typeCP		cpMinDocument;


int CchExpPgn(pch, pgn, nfc, flm, cchMax)
CHAR *pch;
unsigned pgn, cchMax;
int nfc, flm;
{

#ifdef CASHMERE
static CHAR rgchUCRoman[] = "IVIIIXLXXXCDCCCMMM???";
static CHAR rgchLCRoman[] = "iviiixlxxxcdcccmmm???";
#define cchRgchDigit 5
#endif /* CASMERE */

if (flm & flmPrinting)
	{

#ifdef CASHMERE
	switch (nfc)
		{
		int cch, ich, chLetter;
	case nfcArabic:
		if (cchMax < cchMaxNum)
			return 0;
		return ncvtu(pgn, &pch);
	case nfcUCRoman:
		return CchStuffRoman(&pch, pgn, rgchUCRoman, cchMax);
	case nfcLCRoman:
		return CchStuffRoman(&pch, pgn, rgchLCRoman, cchMax);
	case nfcUCLetter:
	case nfcLCLetter:
		if ((cch = (pgn - 1) / 26 + 1) > cchMax)
			return 0;
		chLetter = (pgn - 1) % 26 + (nfc == nfcUCLetter ? 'A' : 'a');
		for (ich = 0; ich < cch; ich++)
			pch[ich] = chLetter;
		return cch;
		}
#else /* not CASHMERE */
	if (cchMax < cchMaxNum)
		return 0;
	return ncvtu(pgn, &pch);
	}
#endif /* not CASHMERE */

else
	{
	int cch;
	cch = CchChStuff(&pch, chLParen, cchMax);
	cch += CchStuffIdstr(&pch, IDSTRChPage, cchMax - cch);
	cch += CchChStuff(&pch, chRParen, cchMax - cch);
	return cch;
	}
}


/* C C H  S T U F F  I D S T R */
int CchStuffIdstr(ppch, idstr, cchMax)
CHAR **ppch;
IDSTR idstr;
int cchMax;
{
	int cch;
	CHAR st[cchMaxExpand]; /* note: we assume no individual idstr
				will have a length > cchMaxExpand */

	FillStId(st, idstr, sizeof(st));
	cch = max(0, min(cchMax, st[0]));
	bltbyte(&st[1], *ppch, cch);
	(*ppch) += cch;
	return cch;
}

/* C C H  C H  S T U F F */
int CchChStuff(ppch, ch, cchMax)
CHAR **ppch;
CHAR ch;
int cchMax;
{
	if(cchMax > 0)
		{
		**ppch = ch;
		(*ppch)++;
		return 1;
		}
	else
		return 0;
}


#ifdef CASHMERE
int CchStuffRoman(ppch, u, rgch, cchMax)
CHAR **ppch, *rgch;
unsigned u, cchMax;
    {
    static CHAR mpdgcch[10] =
	    { 0, 1, 2, 3, 2, 1, 2, 3, 4, 2 };
    static CHAR mpdgich[10] =
	    { 0, 0, 2, 2, 0, 1, 1, 1, 1, 4 };
    int cch, cchDone;

    cchDone = 0;
    if (u >= 10)
	    {
	    cchDone = CchStuffRoman(ppch, u / 10, rgch + cchRgchDigit, cchMax);
	    cchMax -= cchDone;
	    u %= 10;
	    }

    cch = mpdgcch[u];
    if (cch > cchMax || cch == 0)
	    return cchDone;
    bltbyte(&rgch[mpdgich[u]], *ppch, cch);
    *ppch += cch;
    return cch + cchDone;
    }
#endif /* CASHMERE */


int FFormatSpecials(pifi, flm, nfc)
struct IFI *pifi;
int flm;
int nfc;
{ /* A run of special characters was encountered; format it */
/* Return true unless wordwrap required */
int cch;
int cchPr;
int ich;
int dxp;
int dxpPr;
int sch;
CHAR *pchPr;

while (pifi->ichFetch < vcchFetch && pifi->xpPr <= pifi->xpPrRight)
	{

#ifdef CASHMERE
	switch (sch = vpchFetch[pifi->ichFetch++])
		{
	case schPage:
		cch = CchExpPgn(&vfli.rgch[pifi->ich], vpgn, nfc, flm,
		  ichMaxLine - pifi->ich);
		break;

	case schFootnote:
		cch = CchExpFtn(&vfli.rgch[pifi->ich], vcpFetch +
		  pifi->ichFetch - 1, flm, ichMaxLine - pifi->ich);
		break;

	default:
		cch = CchExpUnknown(&vfli.rgch[pifi->ich], flm, ichMaxLine -
		  pifi->ich);
		break;
		}
#else /* not CASHMERE */
	pchPr = &vfli.rgch[pifi->ich];
	if ((sch = vpchFetch[pifi->ichFetch]) == schPage &&
	  (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter || ((flm &
	  flmPrinting) && vcpFetch + (typeCP)pifi->ichFetch < cpMinDocument)))
	    {
	    cch = CchExpPgn(pchPr, vpgn, nfc, flm, ichMaxLine - pifi->ich);
	    if (flm & flmPrinting)
		{
		cchPr = cch;
		}
	    else
		{
		/* Assume that vsepAbs has been set up by FormatLine(). */
		cchPr = CchExpPgn(pchPr = &stBuf[0], vsepAbs.pgnStart == pgnNil
		  ? 1 : vsepAbs.pgnStart, nfc, flmPrinting, ichMaxLine -
		  pifi->ich);
		}
	    }
	else
	    {
	    cch = cchPr = CchExpUnknown(pchPr, flm, ichMaxLine - pifi->ich);
	    }
	pifi->ichFetch++;
#endif /* not CASHMERE */

	dxpPr = 0;
	for (ich = 0; ich < cchPr; ++ich, ++pchPr)
	    {
	    dxpPr += DxpFromCh(*pchPr, true);
	    }
	pifi->xpPr += dxpPr;
	if (flm & flmPrinting)
	    {
	    dxp = dxpPr;
	    }
	else
	    {
	    dxp = 0;
	    for (ich = pifi->ich; ich < pifi->ich + cch; ++ich)
		{
		dxp += DxpFromCh(vfli.rgch[ich], false);
		}
	    }
	vfli.rgch[pifi->ich] = sch;
	pifi->xp += (vfli.rgdxp[pifi->ich++] = dxp);

	if (pifi->xpPr > pifi->xpPrRight)
	    {
	    return (vcpFetch == vfli.cpMin);
	    }
	}

pifi->fPrevSpace = false;
return true;
}


int CchExpUnknown(pch, flm, cchMax)
CHAR *pch;
int flm, cchMax;
{
int cch;

#ifdef CASHMERE
cch = CchChStuff(&pch, chLParen, cchMax);
cch += CchChStuff(&pch, chQMark, cchMax - cch);
cch += CchChStuff(&pch, chRParen, cchMax - cch);
#else /* not CASHMERE */
cch = CchChStuff(&pch, chStar, cchMax);
#endif /* not CASHMERE */

return cch;
}


#ifdef CASHMERE
int CchExpFtn(pch, cp, flm, cchMax)
CHAR *pch;
typeCP cp;
int flm, cchMax;
{
int doc = vfli.doc;
if (cchMax < cchMaxNum)
	return 0;
if (cp >= CpMacText(doc))
	cp = CpRefFromFtn(doc, cp);
CacheSect(doc, cp);
return ncvtu(IfndFromCp(doc, cp) - IfndFromCp(doc, vcpFirstSectCache) + 1,
    &pch);
}
#endif /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\heaprare.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCTLMGR
#define NOCLIPBOARD
#define NOMSG
#define NOGDI
#define NOMB
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
/*
    HeapManage.c - several routines to manage the heap, including changing
            the finger table, compacting the heap in general, and checking the
            heap for consistency.
            It also contains the routines which were once in heapNew.
*/
#include "code.h"
#include "heapDefs.h"
#include "heapData.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "filedefs.h"
#include "docdefs.h"

#ifdef DEBUG
int cPageMinReq = 15;
#else
#define cPageMinReq       (15)
#endif


/* the following statics are used when growing both heap and rgbp etc. */
static int cwRealRequest; /* heap is grow in blocks, this is the actual request */
static int cPageIncr;     /* count of page buffers to increase */
static int cwRgbpIncr;    /* cw in rgbp to be increment */
static int cwHashIncr;    /* cw in rgibpHash to be increment */
static int cwBPSIncr;     /* cw in mpibpbps to be increment */
static int cwHeapIncr;    /* cw in heap increment */


extern CHAR       (*rgbp)[cbSector];
extern CHAR       *rgibpHash;
extern struct BPS *mpibpbps;
extern int        ibpMax;
extern int        iibpHashMax;
extern int        cwInitStorage;
extern typeTS     tsMruBps;

NEAR FGiveupFreeBps(unsigned, int *);
NEAR FThrowPages(int);
NEAR GivePages(int);
NEAR CompressRgbp();

FTryGrow(cb)
unsigned cb;
{
int cPage;

#define cPageRemain (int)(ibpMax - cPage)

    if (FGiveupFreeBps(cb, &cPage) &&
        (cPageRemain >= cPageMinReq))
        {
        /* we have enough free pages to give */
        GivePages(cPage);
        }
    else if ((cPageRemain >= cPageMinReq) && FThrowPages(cPage))
        {
        GivePages(cPage);
        }
    else
        {
        return(FALSE);
        }

    return(TRUE);
}


NEAR FGiveupFreeBps(cb, pCPage)
unsigned cb;
int *pCPage;
{
/* Return true if we can simply give up certain free pages from rgbp to
   the heap.  Return false if all free pages from rgbp still cannot satisfy
   the request
   In any case, pCPage contains the count of pages required */

register struct BPS *pbps;
register int cPage = 0;
int ibp;

#define cbTotalFreed ((cPage*cbSector)+(2*cPage*sizeof(CHAR))+(cPage*sizeof(struct BPS)))

    for (ibp = 0, pbps = &mpibpbps[0]; ibp < ibpMax; ibp++, pbps++)
        {
        if (pbps->fn == fnNil)
            cPage++;
        }

    if (cb > cbTotalFreed )
        {
        /* free pages are not enough, find out exactly how many
        pages do we need */
        cPage++;
        while (cb > cbTotalFreed)
            cPage++;
        *pCPage = cPage;
        return(FALSE);
        }

/* there are enough free pages to give, find out exactly how many */
    while (cb <= cbTotalFreed)
        cPage--;
    cPage++;
    *pCPage = cPage;
    return(TRUE);
} /* end of FGiveupFreeBps */


NEAR FThrowPages(cPage)
int cPage;
{
int i;
register struct BPS *pbps;

    Assert(cPage > 0);

    for (i = 0; i < cPage; i++)
        {
        pbps = &mpibpbps[IbpLru(0)];
        if (pbps->fn != fnNil)
            {
            if (pbps->fDirty && !FFlushFn(pbps->fn))
                return(FALSE);

            /* delete references to old bps in hash table */
            FreeBufferPage(pbps->fn, pbps->pn);
            }
        pbps->ts = ++tsMruBps; /* so that it would not be picked up again as the LRUsed */
        }
    return(TRUE);
} /* end of FThrowPages */


NEAR GivePages(cPage)
int cPage;
{
register struct BPS *pbpsCur = &mpibpbps[0];
struct BPS *pbpsUsable = pbpsCur;
int ibp;
unsigned cbBps;
unsigned cbRgbp;
unsigned cbTotalNew;

    for (ibp = 0; ibp < ibpMax; pbpsCur++, ibp++)
        {
/* compressed so that non empty bps are at the low end,
store ibp in ibpHashNext field (this is important for
CompressRgbp relies on that), since ibpHashNext is invalid
after the compress anyway */
        if (pbpsCur->fn != fnNil)
            {
            if (pbpsCur != pbpsUsable)
                {
                bltbyte((CHAR *)pbpsCur, (CHAR *)pbpsUsable,
                        sizeof(struct BPS));
                /* reinitialized */
                SetBytes((CHAR*)pbpsCur, 0, sizeof(struct BPS));
                         pbpsCur->fn = fnNil;
                         pbpsCur->ibpHashNext = ibpNil;
                }
            pbpsUsable->ibpHashNext = ibp;
            pbpsUsable++;
            }
        } /* end of for */

    /* compressed rgbp, result -- all used pages at the low end */
    CompressRgbp();

    /* decrease the size of the hash table */
    ibpMax -= cPage;
    iibpHashMax = ibpMax * 2 + 1;
    cbRgbp = ibpMax * cbSector;

    rgibpHash = (CHAR *)((unsigned)rgbp + cbRgbp);
    /* contents of rgibpHash should be all ibpNil, that is
    taken care in RehashRgibpHash */

    cbBps = (ibpMax * sizeof(struct BPS) + 1) & ~1;
    bltbyte((CHAR *)mpibpbps, (CHAR *)(mpibpbps = (struct BPS *)
            (((unsigned)rgibpHash + iibpHashMax + 1) & ~1)), cbBps);

    RehashRgibpHash();

    cbTotalNew = cbRgbp + cbBps + ((iibpHashMax + 1) & ~1);

    LocalReAlloc((HANDLE)rgbp, cbTotalNew, LPTR);

    Assert(rgbp != NULL);

} /* end of GivePages */


NEAR CompressRgbp()
{
/* compressed so that all non empty pages are moved towards the low end of
   rgbp */

register struct BPS *pbps = &mpibpbps[0];
struct BPS *pbpsLim = &mpibpbps[ibpMax];
int ibp;

    for (ibp = 0; pbps < pbpsLim; ibp++, pbps++)
        {
        if (pbps->fn == fnNil)
            continue;
        if (pbps->ibpHashNext != ibp)
            {
        /* find out the location of pages (stored in ibpHashNext field) */
            bltbyte((CHAR *)rgbp[pbps->ibpHashNext], (CHAR *)rgbp[ibp], cbSector);
            }
        pbps->ibpHashNext = ibpNil;
        }
} /* end of CompressRgbp */


#ifdef DEBUG
cPageUnused()
{
int ibp;
struct BPS *pbps;
int cPage = 0;

    for (ibp = 0, pbps = &mpibpbps[0]; ibp < ibpMax; ibp++, pbps++)
        {
        if (pbps->fn == fnNil)
            cPage++;
        }
    return(cPage);
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\help.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* help.c -- MEMO Help handler */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#define NOMINMAX
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "stdlib.h"
#include "docdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "dispdefs.h"
#include "fmtdefs.h"
#include "bitmaps.h"

#define NOIDISAVEPRINT
#define NOIDIFORMATS
#include "dlgdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"
#define NOSTRMERGE
#define NOSTRUNDO
#include "str.h"

extern HWND vhWndMsgBoxParent;
extern struct WWD rgwwd[];
extern struct DOD (**hpdocdod)[];
extern int vcchFetch;
extern int vccpFetch;
extern CHAR *vpchFetch;
extern typeCP vcpLimParaCache;
extern int vfCursorVisible;
extern HCURSOR vhcArrow;
extern struct FLI vfli;

int docHelp=docNil; /* this can be taken out if no online help */

#ifndef ONLINEHELP
#if 0
BOOL far PASCAL DialogHelp( hDlg, code, wParam, lParam )
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
{
    switch(code)
        {
        case WM_INITDIALOG:
            EnableOtherModeless(FALSE);
            return(TRUE);

#if WINVER >= 0x300
        case WM_PAINT:
            if (vfli.rgdxp[1] == 0xFFFD)
                FnSpecial(hDlg);
            break;
#endif
    
        case WM_COMMAND:
            if ((wParam == idiOk) || (wParam == idiCancel))
                {
                OurEndDialog(hDlg, TRUE);
#if WINVER >= 0x300            
                if (vfli.rgdxp[1] == 0xFFFD)
                    vfli.rgdxp[1] = NULL;
#endif
                return(TRUE);
                }
            break;
    
        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
            if (vfCursorVisible)
                ShowCursor(wParam);
            break;
    
        case WM_SETVISIBLE:
            if (wParam)
                EndLongOp(vhcArrow);
        }
    return(FALSE);
}

FnSpecial(hDlg)
{
#define randTo(x) (rand() / (32767/x))

    HDC hDC = NULL;
    HDC hMDC = NULL;
    HFONT hFont, hFontPrev;
    int c, cmode;
    int x, y, x2, y2, s;
    HPEN hPen, hPenPrev;
    PAINTSTRUCT ps;
    RECT rc;
    BITMAPINFO DIBInfo;

    srand((int) GetMessageTime());
    cmode = randTo(3);
    GetClientRect(hDlg, &rc);
    if ((hDC = BeginPaint(hDlg, &ps)) == NULL)
        goto LDone;
    if ((hMDC = CreateCompatibleDC(hDC)) == NULL)
        goto LDone;
    
    for (c = 1; c < 100; c++)
        {
        int r, g, b, x, y;
        x = randTo(rc.right)+50;
        y = randTo(rc.bottom)+50;
        switch(cmode)
            {
            case 0:
                r = randTo(255);
                g = randTo(100)+100;
                b = 0;
                break;
            case 1:
                g = randTo(255);
                b = randTo(100)+100;
                r = 0;
                break;
            default:
                b = randTo(255);
                r = randTo(100)+100;
                g = 0;
                break;
            }

        s = 3 + 4*randTo(10);
        if ((hPen = CreatePen(PS_SOLID, s, RGB(r,g,b))) == NULL)
            hPen = GetStockObject(BLACK_PEN);
        hPenPrev = SelectObject(hDC, hPen);
        Ellipse(hDC, x-50, y-50, x-50+s, y-50+s);
        SelectObject(hDC, hPenPrev);
        DeleteObject(hPen);
        }
    SetTextColor(hDC, RGB(255,255,255));
    switch (cmode)
        {
        case 0:
            SetBkColor(hDC, RGB(255,0,0));
            break;
        case 1:
            SetBkColor(hDC, RGB(0,255,0));
            break;
        default:
            SetBkColor(hDC, RGB(0,0,255));
            break;
        }
    hFont = GetStockObject(ANSI_VAR_FONT);
    hFontPrev = SelectObject(hDC, hFont);
    if (vfli.rgch[2] == 0x30)
        for (c = vfli.rgch[1]-1; c >= 0; c--)
            vfli.rgch[c+2] -= 0x10;
    TextOut(hDC, 6, rc.bottom-15, &vfli.rgch[2], vfli.rgch[1]);
    SelectObject(hDC, hFontPrev);

    DeleteDC(hMDC);
LDone:            
    EndPaint(hDlg, &ps);
}
#endif

#else /* ONLINE HELP */

#define cchMaxTopicName 80

#ifndef DEBUG
#define STATIC static
#else
#define STATIC
#endif

STATIC int fnHelpFile;
STATIC int iTopicChoice=-1;
STATIC int cTopic;
STATIC struct PGTB **hpgtbHelp=0;
STATIC HWND hwndHelpDoc;


NEAR CleanUpHelpPopUp( void );
NEAR CloseHelpDoc( void );
NEAR FOpenHelpDoc( void );
NEAR MoveHelpCtl( HWND, int, int, int, int, int );

fnHelp()
{
extern HANDLE hMmwModInstance;
extern HWND hParentWw;
extern FARPROC lpDialogHelp;
extern FARPROC lpDialogHelpInner;
int idi;

Assert( hpgtbHelp == 0 );

/* Loop until the user exits the "Help on this topic/Return to Topics" loop */

ClearInsertLine();  /* Because we use MdocSize, which sets vfInsertOn */

if (!FOpenHelpDoc())
    {
    CloseHelpDoc();
    Error( IDPMTNoHelpFile );
    return;
    }
while (TRUE)
    {

    idi = DialogBox( hMmwModInstance, MAKEINTRESOURCE(dlgHelp), hParentWw,
                     lpDialogHelp );
    if (idi == -1)
        {
        Error(IDPMTNoMemory);
        return;
        }

    if ((idi == idiOk) && (iTopicChoice >= 0))
        {   /* Help file was read OK & user chose a topic */
        Assert( hpgtbHelp != 0);
        if ( iTopicChoice + 1 < (**hpgtbHelp).cpgd )
            {
            idi = DialogBox( hMmwModInstance, MAKEINTRESOURCE(dlgHelpInner),
                             hParentWw, lpDialogHelpInner );
            if (idi == -1)
                {
                Error(IDPMTNoMemory);
                break;
                }
            if ( idi != idiHelpTopics )
                break;

            }
            /* Not Enough Topics supplied in the help file */
        else
            {
            Error( IDPMTNoHelpFile );
            CloseHelpDoc();
            break;
            }
        }
    else
        break;
    }
iTopicChoice = -1;
DrawInsertLine();
CloseHelpDoc();
}




FInzHelpPopUp( hDlg )
HWND hDlg;
{   /* Build the Help popup Window */
extern CHAR szHelpDocClass[];
extern HANDLE hMmwModInstance;
extern int dxpScrlBar;

typedef struct {  int yp, dyp;  }  VD;       /* Vertical Dimension */
typedef struct {  int xp, dxp;  }  HD;       /* Horizontal Dimension */

 HD hdUsable;
 HD hdPopUp;
 VD vdPopUp, vdTopic, vdHelpDoc, vdButton;

 HDC hdcPopUp=NULL;

#define RectToHdVd( rc, hd, vd )    (hd.dxp=(rc.right - (hd.xp=rc.left)), \
                                     vd.dyp=(rc.bottom - (vd.yp=rc.top)))
 RECT rcPopUp;
 RECT rcHelpDoc;
 extern int dypMax;     /* Screen Size */
 int dxpMax=GetDeviceCaps( wwdCurrentDoc.hDC, HORZRES );
 TEXTMETRIC tm;
 unsigned dypChar;
 unsigned xpButton;
 unsigned dxpButton;
 register struct WWD *pwwdHelp;

#define cButton 4       /* # of buttons across the bottom of the Dialog */
 int rgidiButton[ cButton ];
 int iidiButton;

 rgidiButton [0] = idiHelpTopics;
 rgidiButton [1] = idiHelpNext;
 rgidiButton [2] = idiHelpPrev;
 rgidiButton [3] = idiCancel;

#define dxpMargin   (dxpMax/100)
#define dypMargin   (dypMax/100)

 Assert( docHelp != docNil );

    /* Make a wwd entry for the Help document & initialize it */
 if ((wwHelp=WwAlloc( (HWND)NULL, docHelp )) == wwNil)
    goto ErrRet;
 pwwdHelp = &rgwwd[ wwHelp ];

 SetHelpTopic( hDlg, iTopicChoice );

    /* Dialog box is centered and
       2/3 of the size of the screen, plus the scroll bar width
       This sizing method permits us to guarantee that the help document
       display area width is at least some fixed percentage of the width
       of the screen (currently 64.66 %) */
 hdPopUp.dxp = ((dxpMax * 2) / 3) + dxpScrlBar;
 hdPopUp.xp = (dxpMax - hdPopUp.dxp) / 2;
 vdPopUp.dyp = dypMax - ((vdPopUp.yp = dypMax / 6) * 2);
 MoveWindow( hDlg, hdPopUp.xp, vdPopUp.yp, hdPopUp.dxp, vdPopUp.dyp, TRUE );

    /* Get Standard text height so we know how much space to allow
       for Topic Name */
 if ( ((hdcPopUp=GetDC( hDlg ))==NULL) ||
      (SelectObject( hdcPopUp, GetStockObject( ANSI_FIXED_FONT ) )==0))
    goto ErrRet;
 GetTextMetrics( hdcPopUp, (LPTEXTMETRIC)&tm );
 ReleaseDC( hDlg, hdcPopUp );
 hdcPopUp = NULL;
 dypChar = tm.tmHeight + tm.tmExternalLeading;

     /* Obtain heights of button area, help doc display, and Topic Area by
        splitting up Dialog Box client rect */
 GetClientRect( hDlg, &rcPopUp );
 RectToHdVd( rcPopUp, hdPopUp, vdPopUp );
 vdButton.dyp = vdPopUp.dyp / 7;
 vdButton.yp = vdPopUp.yp + vdPopUp.dyp - vdButton.dyp;
 vdTopic.yp = vdPopUp.yp + dypMargin;
 vdTopic.dyp = dypMargin + dypChar;
 vdHelpDoc.yp = vdTopic.yp + vdTopic.dyp;
 vdHelpDoc.dyp = vdButton.yp - vdHelpDoc.yp;
 Assert( vdHelpDoc.dyp > dypChar + 2 );

    /* Obtain usable horiz area within dialog box */
 hdUsable.xp  = hdPopUp.xp + dxpMargin;
 hdUsable.dxp = hdPopUp.dxp - (2 * dxpMargin);

     /* Create the Help Doc Window */
 if ((hwndHelpDoc =
        CreateWindow( (LPSTR)szHelpDocClass, (LPSTR) "",
                      WS_CHILD | WS_BORDER,
                      hdUsable.xp, vdHelpDoc.yp,
                      hdUsable.dxp - dxpScrlBar, vdHelpDoc.dyp,
                      hDlg,                     /* PARENT */
                      NULL,                     /* Help Document Window ID */
                      hMmwModInstance,
                      (LONG) 0)) == NULL)
        /* Error Creating Help Document Window */
    goto ErrRet;
 pwwdHelp->wwptr = pwwdHelp->hHScrBar = hwndHelpDoc;

    /* OK to GetDc and hang onto it since Help doc window class has ownDC */
 if ((pwwdHelp->hDC = GetDC( hwndHelpDoc ))==NULL)
    goto ErrRet;

    /* Set up scroll bar control window */
 SetScrollRange( pwwdHelp->hVScrBar = GetDlgItem( hDlg, idiHelpScroll ),
                 pwwdHelp->sbVbar = SB_CTL,
                 0, drMax-1, FALSE );
 SetScrollPos( pwwdHelp->hVScrBar, SB_CTL, 0, FALSE );
 MoveHelpCtl( hDlg, idiHelpScroll,
                      hdUsable.xp + hdUsable.dxp - dxpScrlBar, vdHelpDoc.yp,
                      dxpScrlBar, vdHelpDoc.dyp );

    /* Move Button windows into place */
 xpButton = hdUsable.xp;
 dxpButton = (hdUsable.dxp - (dxpMargin*(cButton-1))) / cButton;
 vdButton.yp += dypMargin;
 vdButton.dyp -= (2 * dypMargin);
 for ( iidiButton = 0; iidiButton < cButton; iidiButton++ )
    {
    MoveHelpCtl( hDlg, rgidiButton[ iidiButton ],
                       xpButton, vdButton.yp, dxpButton, vdButton.dyp );
    xpButton += dxpButton + dxpMargin;
    }

    /* Move static text window into place */
 MoveHelpCtl( hDlg, idiHelpName, hdUsable.xp, vdTopic.yp,
                                 hdUsable.dxp, vdTopic.dyp );

    /* The "real, final" size of the help doc window goes in rgwwd */
 GetClientRect( hwndHelpDoc, (LPRECT) &rcHelpDoc );
 pwwdHelp->xpMin = rcHelpDoc.left;
 pwwdHelp->ypMin = rcHelpDoc.top;
 pwwdHelp->xpMac = rcHelpDoc.right;
 pwwdHelp->ypMac = rcHelpDoc.bottom;

    /* Finally, we display the whole dialog box */
 ShowWindow( hDlg, SHOW_OPENWINDOW );
 ShowWindow( hwndHelpDoc, SHOW_OPENWINDOW );
 return TRUE;

ErrRet:
    if (hdcPopUp != NULL)
        ReleaseDC( hDlg, hdcPopUp );
    CleanUpHelpPopUp();
    CloseHelpDoc();

    return FALSE;
}




NEAR MoveHelpCtl( hDlg, id, left, top, right, bottom )
HWND hDlg;
int id;
int left, top, right, bottom;
{
 MoveWindow( (HWND) GetDlgItem( hDlg, id ), left, top, right, bottom, TRUE );
}




SetHelpTopic( hDlg, iTopic )
HWND hDlg;
int iTopic;
{   /* Inz wwHelp entry in rgwwd for pending display of topic iTopic,
       which means "printed page" iTopic, the way we handle help files.
       We map iTopic==0 to "printed page 2", iTopic 1 to 3, etc.
       This skips the first printed page, which is the list of topics.
       Set the topic name of iTopic as the text for the idiHelpName
       static text control in the hDlg dialog box */

 extern typeCP cpMinCur, cpMacCur;
 extern struct SEL selCur;
 extern int wwCur;

 int ipgd = iTopic + 1;
 register struct WWD *pwwd=&rgwwd[ wwHelp ];
 typeCP cpFirstTopic = (**hpgtbHelp).rgpgd [ ipgd ].cpMin;
 typeCP cpLimTopic = (ipgd == (**hpgtbHelp).cpgd - 1) ?
                                      CpMacText( docHelp ) :
                                      (**hpgtbHelp).rgpgd [ ipgd + 1 ].cpMin;
 typeCP cp;
 int iTopicT;
 typeCP cpLimParaCache;
 RECT rc;

 Assert( wwHelp != wwNil && docHelp != docNil );

 cpLimTopic--;      /* Ignore end-of-page char at the end of each page */

 if (ipgd >= (**hpgtbHelp).cpgd)
    {
    Assert( FALSE );

    pwwd->cpMin = pwwd->cpMac = cp0;
    }
 else
    {
    pwwd->cpMin = cpFirstTopic;
    pwwd->cpMac = cpLimTopic;
    }
 pwwd->cpFirst = pwwd->cpMin;
    /* So no selection shows */
 pwwd->sel.cpFirst = pwwd->sel.cpLim = cpLimTopic + 1;

 if (wwCur == wwHelp)
    {
    cpMinCur = pwwd->cpMin;
    cpMacCur = pwwd->cpMac;
    selCur = pwwd->sel;
    }

 TrashCache();
 TrashWw( wwHelp );
 GetClientRect( pwwd->wwptr, (LPRECT) &rc );
 InvalidateRect( pwwd->wwptr, (LPRECT) &rc, TRUE );

 /* Set Help Topic name into dialog box */

 for ( iTopicT = 0, cp = (**hpgtbHelp).rgpgd [0].cpMin;
       cp < (**hpgtbHelp).rgpgd [1].cpMin;
       cp = cpLimParaCache, iTopicT++ )
        {
        int cch;
        int cchTopicMac;
        CHAR rgchTopic[ cchMaxTopicName ];

        CachePara( docHelp, cp );
        cpLimParaCache = vcpLimParaCache;

        if (iTopicT == iTopic)
            {   /* Found the topic we want */
            cchTopicMac = imin( (int)(vcpLimParaCache - cp) - ccpEol,
                                cchMaxTopicName );

            /* Build up a topic name string */

            cch = 0;
            while (cch < cchTopicMac)
                {
                int cchT;

                FetchCp( docHelp, cp, 0, fcmChars );
                cp += vccpFetch;
                cchT = imin( vcchFetch, cchTopicMac - cch );
                Assert( cchT > 0);
                bltbyte( vpchFetch, rgchTopic + cch, cchT );
                cch += cchT;
                }
            if ((cch == 0) || rgchTopic [0] == chSect)
                    /* End of Topics */
                break;

            rgchTopic[ cch ] = '\0';

            SetDlgItemText( hDlg, idiHelpName, (LPSTR) rgchTopic );
            return;
            }   /* end if */
        }   /* end for */
    /* Not enough topic names */
 Assert( FALSE );
}




NEAR CleanUpHelpPopUp()
{
extern int wwCur;

 if (wwCur != wwDocument)
    NewCurWw( wwDocument, TRUE );

 if (wwHelp != wwNil)
     FreeWw( wwHelp );
 }




NEAR CloseHelpDoc()
{
 if (docHelp != docNil)
    KillDoc( docHelp );

 if (hpgtbHelp != 0)
    {
    FreeH( hpgtbHelp );
    hpgtbHelp = 0;
    }

 if (fnHelpFile != fnNil)
    FreeFn( fnHelpFile );
 docHelp = docNil;
 fnHelpFile = fnNil;
}


NEAR FOpenHelpDoc()
{
 CHAR szHelpFile[ cchMaxFile ];
 CHAR (**hszHelpFile)[];

  /* This call to fnOpenSz is the one time that we don't normalize
    a filename before calling FnOpenSz.  The reason for this is
    that OpenFile (called in RfnAccess) will only search the path
    if the filename passed to it has no path.  We also get a side
    benefit: if the sneaky user has WRITE.HLP open as a document,
    it will get a different fn from FnOpenSz because the strings
    will not match. */

return ( PchFillPchId( szHelpFile, IDSTRHELPF ) &&
      ((fnHelpFile=FnOpenSz( szHelpFile, dtyHlp, TRUE ))!=fnNil) &&
      !FNoHeap(hszHelpFile=HszCreate( szHelpFile )) &&
      ((docHelp=DocCreate( fnHelpFile, hszHelpFile, dtyHlp )) != docNil) &&
      (**hpdocdod)[ docHelp ].fFormatted);
}

/* Window Proc for Help document child window */

long FAR PASCAL HelpDocWndProc( hwnd, message, wParam, lParam )
HWND hwnd;
unsigned message;
WORD wParam;
LONG lParam;
{
extern struct WWD *pwwdCur;
extern int wwCur;

    PAINTSTRUCT ps;

    switch (message)
        {
        case WM_SIZE:
            /* Window's size is changing.  lParam contains the width
            ** and height, in the low and high words, respectively.
            ** wParam contains SIZENORMAL for "normal" size changes,
            ** SIZEICONIC when the window is being made iconic, and
            ** SIZEFULLSCREEN when the window is being made full screen. */
            Assert( wParam == SIZENORMAL || wParam == SIZEFULLSCREEN );
            if (lParam)
                {   /* Not a NULL size request */
                rgwwd[ wwHelp ].xpMac = LOWORD( lParam );
                rgwwd[ wwHelp ].ypMac = HIWORD( lParam );
                }
            break;

        case WM_PAINT:
            /* Time for the window to draw itself. */
            {
            RECT rcSave;

                /* To allow UpdateWw to refresh ALL parts of the screen it */
                /* deems necessary, not just what Windows is telling us to */
                /* paint, we invoke it AFTER the call to EndPaint so that */
                /* the Vis region is not restricted.  The only reason we call */
                /* BeginPaint/EndPaint is to get the repaint rectangle */
            BeginPaint(hwnd, (LPPAINTSTRUCT)&ps);
            bltbyte( &ps.rcPaint, &rcSave, sizeof( RECT ) );
            EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
            NewCurWw( wwHelp, TRUE );
            InvalBand( pwwdCur, rcSave.top, rcSave.bottom );
            UpdateWw( wwCur, FALSE );
            NewCurWw( wwDocument, TRUE );
            break;
            }

        default:

            /* Everything else comes here.  This call MUST exist
            ** in your window proc.  */

            return(DefWindowProc(hwnd, message, wParam, lParam));
            break;
    }

    /* A window proc should always return something */
    return(0L);
}


/* Dialog Box function for Inner Help box (shows the topic text) */

BOOL far PASCAL DialogHelpInner( hDlg, code, wParam, lParam )
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
{
extern int wwCur;

    switch (code)
        {
        case WM_VSCROLL:    /* Scroll in help document */
            NewCurWw( wwHelp, TRUE );
            MmwVertScroll( hwndHelpDoc, wParam, (int) lParam );
            UpdateWw( wwCur, FALSE );
            NewCurWw( wwDocument, TRUE );
            break;

        case WM_CLOSE:
            goto Cancel;
        case WM_INITDIALOG:
            if (!FInzHelpPopUp( hDlg ))
                {
                goto Cancel;
                }
            EnableOtherModeless(FALSE);
            break;

        case WM_COMMAND:
            switch (wParam)
                {
                default:
                    break;
                case idiHelpNext:
                    if (++iTopicChoice >= cTopic)
                        {
                        iTopicChoice--;
                        beep();
                        }
                    else
                        SetHelpTopic( hDlg, iTopicChoice );

                    break;
                case idiHelpPrev:
                    if (iTopicChoice == 0)
                        beep();
                    else
                        SetHelpTopic( hDlg, --iTopicChoice );
                    break;

                case idiOk:
                    wParam = idiHelpTopics;
                case idiHelpTopics:
                    CleanUpHelpPopUp();
                    goto Endit;

                case idiCancel:
Cancel:
                    CleanUpHelpPopUp();
                    CloseHelpDoc();
Endit:
                    EndDialog(hDlg, wParam);
                    EnableOtherModeless(TRUE);
                    break;
                }
            break;

        default:
            return(FALSE);
            }
    return(TRUE);
    }




BOOL far PASCAL DialogHelp( hDlg, code, wParam, lParam )
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
{
 HWND hwndListBox;

    switch (code)
        {
        case WM_INITDIALOG:
            if (!FSetHelpList( hwndListBox=GetDlgItem( hDlg, idiHelp ) ))
                {
                Error( IDPMTNoHelpFile );
                CloseHelpDoc();
                goto EndIt;
                }

                /* Come up with the first string in the list box selected */
            SendMessage( hwndListBox, LB_SETCURSEL, (WORD) 0, (LONG) 0);

            {   /* Compute % of free memory, set that into dialog box */
            extern cwHeapFree, cbTotQuotient, cbTot;
            extern int vfOutOfMemory;
            int pctHeapFree=0;
            CHAR rgchPct[ 4 ];
            int cchPct;
            CHAR *pchT=&rgchPct[ 0 ];

            if (!vfOutOfMemory)
                {
                pctHeapFree = cwHeapFree / cbTotQuotient;
                if (pctHeapFree > 99)
                    pctHeapFree = (cwHeapFree*sizeof(int) == cbTot) ? 100 : 99;
                }
            cchPct = ncvtu( pctHeapFree, &pchT );
            Assert( cchPct < 4);
            rgchPct[ cchPct ] = '\0';
            SetDlgItemText( hDlg, idiMemFree, (LPSTR) rgchPct );
            }

            EnableOtherModeless(FALSE);
            break;

        case WM_COMMAND:
            switch (wParam)
                {
            case idiHelp:
                /* This is received as part of the LBS_NOTIFY style */
                /* whenever the user mouses up over a string */
                /* LOWORD( lParam ) is the window handle of the list box */
                /* HIWORD( lParam ) is 1 for single click, 2 for doubleclick */

                switch( HIWORD( lParam ) ) {
                    default:
                        break;
                    case 1: /* SINGLE CLICK */
                        EnableWindow( GetDlgItem( hDlg, idiOk ),
                                      SendMessage( (HWND)GetDlgItem( hDlg,
                                                                     idiHelp ),
                                                    LB_GETCURSEL,
                                                    0,
                                                    (LONG) 0 ) >= 0 );
                        break;
                    case 2: /* DOUBLE CLICK */
                        wParam = idiOk;
                        goto Okay;
                    }
                break;

            case idiOk:
Okay:
                iTopicChoice = SendMessage( (HWND)GetDlgItem( hDlg, idiHelp ),
                                            LB_GETCURSEL, 0, (LONG) 0 );
                goto EndIt;

            case idiCancel:
                    /* Cancelled, get rid of Help Document info */
                CloseHelpDoc();
EndIt:
                EndDialog(hDlg, wParam);
                EnableOtherModeless(TRUE);
                break;
                }
            break;

        default:
            return(FALSE);
            }
    return(TRUE);
    } /* end of DialogHelp */



FSetHelpList( hWndListBox )
HWND hWndListBox;
{   /* Open the MEMO Help File as a MEMO Document.  Set docHelp, fnHelpFile.
       Read the strings for the list box as the contents of the first
       "printed" page (i.e. use the page table) and send them to the
       list box with the passed window handle */

 CHAR szTopicBuf[ cchMaxTopicName ];
 typeCP cp;
 typeCP cpLimParaCache;
 int cch;
 struct PGTB **hpgtbT;

 Assert( docHelp != docNil );

 cTopic = 0;

 if ((hpgtbT=(**hpdocdod)[ docHelp ].hpgtb) != 0)
    {
    hpgtbHelp = hpgtbT;
    (**hpdocdod)[ docHelp ].hpgtb = 0;
    }

 Assert( (hpgtbHelp != 0) && ((**hpgtbHelp).cpgd > 1) );

 /* List of topics starts on the first page, 1 para per topic */
 /* For each topic (paragraph), build a string and send it to the list box */

 for ( cp = (**hpgtbHelp).rgpgd [0].cpMin;
       cp < (**hpgtbHelp).rgpgd [1].cpMin;
       cp = cpLimParaCache )
    {
    int cchTopicMac;

    CachePara( docHelp, cp );
    cpLimParaCache = vcpLimParaCache;

    cchTopicMac = imin( (int)(vcpLimParaCache - cp) - ccpEol,
                        cchMaxTopicName );

        /* Build up a topic name string */
    cch = 0;
    while (cch < cchTopicMac)
        {
        int cchT;

        FetchCp( docHelp, cp, 0, fcmChars );
        cp += vccpFetch;
        cchT = imin( vcchFetch, cchTopicMac - cch );
        Assert( cchT > 0);
        bltbyte( vpchFetch, szTopicBuf + cch, cchT );
        cch += cchT;
        }
    if ((cch == 0) || szTopicBuf [0] == chSect)
            /* End of Topics */
        break;

    szTopicBuf[ cch ] = '\0';
    SendMessage( hWndListBox, LB_INSERTSTRING, -1, (LONG)(LPSTR)szTopicBuf);
    cTopic++;
    }   /* end for */

 return (cTopic > 0);
}
#endif /* ONLINEHELP */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\insert2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* insert2.c - MW insertion routines */

#define NOGDICAPMASKS
#define NOCLIPBOARD
#define NOCTLMGR
#define NOWINSTYLES

#ifndef KOREA
#define NOSYSMETRICS
#endif

#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOBRUSH
#define NOCREATESTRUCT
#define NOFONT
#define NOCLIPBOARD
#define NODRAWTEXT
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOMB
#define NOOPENFILE
#define NOSOUND
#define NOCOMM
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "propdefs.h"
#include "dispdefs.h"
#include "fmtdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#define NOKCCODES
#include "ch.h"
#include "winddefs.h"
#include "fontdefs.h"
#include "debug.h"

#ifdef DEBUG
extern int          vTune;
#endif

#ifdef  KOREA       /* Use in KcInputNext..., 90.12.27 sangl */
extern int      IsInterim;
#endif

extern int          vdlIns;
extern int          vxpIns;
extern int          vfTextBltValid;
extern int          vdypCursLineIns;
extern struct FLI   vfli;
extern struct SEL   selCur;
extern int          vdypBase;
extern int          vypBaseIns;
extern int          vxpMacIns;
extern int          vdypAfter;
extern typeCP       cpInsert; /* Beginning cp of insert block */
extern int          ichInsert; /* Number of chars used in rgchInsert */
extern typeCP       cpMinCur;
extern typeCP       cpMacCur;
extern int          docCur;
extern struct CHP   vchpInsert;
extern struct WWD   rgwwd[];
extern struct WWD   *pwwdCur;
extern int          wwCur;
extern int          wwMac;
extern int          vfSeeSel;
extern int          vfFocus;
#ifdef DBCS
extern int      donteat;    /* see disp.c */
#endif


unsigned WHsecGetTime()
{       /* Get the time (in hundredths of seconds) into a normalized word */
        /* Ignore current hour, just minutes/seconds/hundredths */
 struct TIM tim;

 OsTime( &tim );
 return ( (unsigned)tim.minutes * 6000 +
          (unsigned)tim.sec * 100 +
          (unsigned)tim.hsec );
}




/* V A L I D A T E  T E X T  B L T */
ValidateTextBlt()
{   /* Validate info sufficient for TextOut and ScrollCurWw calls in Insert */
    /* In particular: vdlIns, vxpIns, vdypBase, vdypFont */

 int NEAR FCpInsertInDl( typeCP, struct EDL * );
 extern int vfInsFontTooTall;
 extern struct FMI vfmiScreen;
 extern int             ferror;
 extern int vfInsEnd;

 int dypFontAscent;
 int dypFontDescent;
 register struct EDL *pedl;
 int yp;
 typeCP cpBegin;

 /* Routine assumes ww == wwDocument */

 Assert( pwwdCur == &wwdCurrentDoc );

 {       /* Look for a valid dl containing selCur.cpFirst */
         /* We should usually be able to find one */
 int dlGuess = vdlIns;
 struct EDL *dndl=&(**wwdCurrentDoc.hdndl)[0];

 if ( (dlGuess < wwdCurrentDoc.dlMac) &&
      FCpInsertInDl( selCur.cpFirst, pedl = &dndl[ dlGuess ] ))
    {   /* vdlIns is already correct */
    cpBegin = pedl->cpMin;
    }
 else
    {   /* Search for valid dl containing insertion point */
        /* Use linear search, all dl's may not be valid */
    int dl;

    for ( pedl = dndl, dl = 0; dl < wwdCurrentDoc.dlMac; dl++, pedl++ )
        {
        if ( FCpInsertInDl( selCur.cpFirst, pedl ) )
            {   /* Found it */
            vdlIns = dl;
            cpBegin = pedl->cpMin;
            break;
            }
        }
    if (dl >= wwdCurrentDoc.dlMac)
        {   /* No valid dl contains the cp -- must update whole screen */
        cpBegin = CpBeginLine( &vdlIns, selCur.cpFirst );
        }
    }
 }

 /* Special case for splat: locate insert point at end of previous line */

 pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
 if (pedl->fSplat && (vdlIns > 0) && selCur.cpFirst == pedl->cpMin)
    {   /* Splat on current line */
        /* Check for pedl->cpMin above is necessary for the special case */
        /* in which the QD buffer is at the beginning of the splat line */
    pedl--;
    if (pedl->fValid && !pedl->fSplat)
        {   /* Locate cursor at end of previous line */
        vdlIns--;
        cpBegin = pedl->cpMin;

        ClearInsertLine();
        selCur.fEndOfLine = TRUE;
        vfInsEnd = TRUE;
        ToggleSel( selCur.cpFirst, selCur.cpLim, TRUE );
        }
    else
        {
        pedl++;
        goto CheckEnd;
        }
    }
 else
    {   /* Eliminate end of line cursor if not before a splat */
CheckEnd:
    if (selCur.fEndOfLine)
        {
        ClearInsertLine();
        selCur.fEndOfLine = FALSE;
        vfInsEnd = FALSE;
        ToggleSel( selCur.cpFirst, selCur.cpLim, TRUE );
        }
    }

 /* Assure we obtained a good vdlIns */

 Assert( vdlIns < wwdCurrentDoc.dlMac );
 Assert( ((selCur.cpFirst >= pedl->cpMin) &&
         (selCur.cpFirst <= pedl->cpMin + pedl->dcpMac)));

 FormatLine(docCur, cpBegin, 0, cpMacCur, flmSandMode);
 vxpIns = DxpDiff(0, (int) (selCur.cpFirst - cpBegin), &vxpIns) + vfli.xpLeft +
                    xpSelBar - wwdCurrentDoc.xpMin;
 vdypBase = vfli.dypBase;
 vdypAfter = vfli.dypAfter;
 vdypCursLineIns = min(vfli.dypFont, vfli.dypLine - vdypAfter);

 vxpMacIns = vfli.xpMarg;

 LoadFont(docCur, &vchpInsert, mdFontChk);
 ferror = FALSE; // running out of memory here is OK.  Must clear this
                 // or important calls will needlessly fail.
                 // (8.6.91) D. Kent

#ifdef	KOREA	// jinwoo: 92, 9, 28
/* For y position of display, 920604 KDLEE */
#ifdef	NODESC
	{ extern HDC	vhMDC;
	  TEXTMETRIC	tm;

	  GetTextMetrics (vhMDC, (LPTEXTMETRIC)&tm);
	  if (tm.tmCharSet==HANGEUL_CHARSET)
		vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp;
	  else
		vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp - vdypBase;
	}
#else  /* NODESC */
 vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp - vdypBase;
#endif /* NODESC */
#else   /* KOREA */

 vypBaseIns = (**wwdCurrentDoc.hdndl) [vdlIns].yp - vdypBase;
#endif // KOREA:  jinwoo: 92, 9, 28

 dypFontAscent = vfmiScreen.dypAscent + vfmiScreen.dypLeading;
 dypFontDescent = vfmiScreen.dypDescent;

 if (vchpInsert.hpsPos)
    {
    if (vchpInsert.hpsPos < hpsNegMin)
        {
        vypBaseIns -= ypSubSuper;   /* Superscript */
        dypFontAscent += ypSubSuper;
        }
    else
        {
        vypBaseIns += ypSubSuper;   /* Subscript */
        dypFontDescent += ypSubSuper;
        }
    }

 /* Set if current font is too tall to display on insert line */
 vfInsFontTooTall = (imax( dypFontAscent, vfli.dypLine - vfli.dypBase ) +
                     imax( dypFontDescent, vfli.dypBase )) > vfli.dypLine;

 vfTextBltValid = true;
}



int NEAR FCpInsertInDl( cp, pedl  )
typeCP cp;
register struct EDL *pedl;
{   /* Return TRUE if insert point cp is in dl & dl is valid, FALSE otherwise */

if ( (pedl->fValid) && (cp >= pedl->cpMin) )
    {   /* dl is valid & cp is at or below starting cp of dl */
    if ( (cp < pedl->cpMin + pedl->dcpMac) ||
         ((cp == cpMacCur) && (cp == pedl->cpMin + pedl->dcpMac)) )
        {   /* cp is on line dl */
        if (pedl->yp <= wwdCurrentDoc.ypMac)
            {   /* dl is complete, i.e. not cut off at bottom of window */
            return TRUE;
            }
        }
    }
return FALSE;
}




#ifdef FOOTNOTES
/* F  E D I T  F T N */
int FEditFtn(cpFirst, cpLim)
typeCP cpFirst, cpLim;
{ /* Return true if edit includes an end of footnote mark */
        struct FNTB **hfntb;
        typeCP cp;

        if ((hfntb = HfntbGet(docCur)) == 0 ||
                cpLim < (cp = (*hfntb)->rgfnd[0].cpFtn))
                return false;

        if (cpFirst < cp ||
                CpRefFromFtn(docCur, cpFirst) != CpRefFromFtn(docCur, cpLim))
                {
                Error(IDPMTFtnLoad);
                return fTrue;
                }
        return fFalse;
}
#endif  /* FOOTNOTES */




/* U P D A T E  O T H E R  W W S */
#ifdef CASHMERE
UpdateOtherWws(fInval)
BOOL fInval;
{
        int ww = 0;
        struct WWD *pwwd = rgwwd;
        {{
        while (ww < wwMac)
                {
                if (ww != wwCur && (pwwd++)->doc == docCur)
                        {{
                        typeCP cpI = cpInsert + ichInsert;
                        typeCP cpH = CpMax(cpI, cpInsLastInval);
                        typeCP cpL = CpMin(cpInsLastInval, cpI);
                        typeCP dcp;
                        if ((dcp = cpH - cpL) != cp0 || fInval)
                                AdjustCp(docCur, cpL, dcp, dcp);
                        cpInsLastInval = cpI;
                        return;
                        }}
                ww++;
                }
        }}
}
#endif  /* CASHMERE */




/* K C I N P U T N E X T K E Y */
KcInputNextKey()
{               /* Get next available key/event from Windows */
                /* Returns key code or kcNil if a non-key event */
                /* Updates the screen if there is time before events arrive */
extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern MSG  vmsgLast;   /* WINDOWS: last message gotten */
extern int  vfInsLast;
extern int vfCommandKey;
extern int vfShiftKey;
extern int vfAwfulNoise;

 int i;
 int kc;

 for ( ;; )
    {
    if ( FImportantMsgPresent() )
        goto GotMessage;

/* No events waiting -- if none show up for a while, update the screen */

#ifdef CASHMERE
    UpdateOtherWws( FALSE );
#endif

    {       /* Dawdle for a time, looking for keys, before updating the screen */
    unsigned WHsecGetTime();
    unsigned wHsec;

    wHsec = WHsecGetTime();
    do
        {
        if ( FImportantMsgPresent() )
            goto GotMessage;

        }    while ( WHsecGetTime() - wHsec < dwHsecKeyDawdle );
    }

#ifdef DEBUG
    if (vTune)
        continue;  /* Bag background update while debugging to see how we fare */
#endif

    Scribble( 8, 'U' );
    ClearInsertLine();
    UpdateWw(wwCur, fTrue);
    ToggleSel(selCur.cpFirst, selCur.cpLim, fTrue);
    Scribble( 8, ' ' );

    if ( FImportantMsgPresent() )
       goto GotMessage;

    vfAwfulNoise = FALSE;
    PutCpInWwHz( selCur.cpFirst );

    EndLongOp( NULL );

    if ( FImportantMsgPresent() )
        goto GotMessage;

    if ( !vfTextBltValid )
        ValidateTextBlt();

    /* Nothing has happened for a while, let's blink the cursor */

    {
    unsigned WHsecGetTime();
    unsigned wHsecBlink = GetCaretBlinkTime() / 10;
    unsigned wHsecLastBlink=WHsecGetTime() + wHsecBlink/2;

    for ( ;; )
        {
        unsigned wHsecT;

        if ( FImportantMsgPresent() )
            goto GotMessage;

        /* Another app may have stolen the focus away from us while we called
        PeekMessage(), in which case we should end Alpha mode. */
        if (!vfFocus)
            return kcNil;

        UpdateDisplay( TRUE );
        if ( (wHsecT = WHsecGetTime()) - wHsecLastBlink >= wHsecBlink )
            {
            DrawInsertLine();
            wHsecLastBlink = wHsecT;
            }
        }
    }

    continue;

GotMessage:
#ifdef DBCS

#ifdef  KOREA   /* Need to GetMessage for F-Key during Interim,90.12.27 sangl */
    if ( ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil) || IsInterim)
#else
    if ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil)
#endif
        {
        if (vmsgLast.wParam == VK_EXECUTE)
            return( kcNil );
        if (vmsgLast.message == WM_KEYDOWN)
            {
            switch (kc) {
            default:
                break;
            case kcAlphaVirtual:
                    /* This means we can't anticipate the key's meaning
                       before translation */
#ifdef  KOREA   /* Need GetMesssage for direc keys, etc during interim 90.12.26 sangl */
                if ( FNonAlphaKeyMessage( &vmsgLast, FALSE ) && !IsInterim)
#else
                if ( FNonAlphaKeyMessage( &vmsgLast, FALSE ) )
#endif
                        /* This is a non-alpha key message */
                    return kcNil;
        if ( !donteat ) {
                    GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
#ifdef DBCS
                    // kksuzuka #9193 NECAI95
                    // got message is WM_KEYDOWN by PeekMessage( )
                    // but got message is WM_IME_STARTCOMPOSITION by GetMessage()
                    // We need DispatchMessage( WM_IME_STARTCOMPOSITION ) 
                    if ( vmsgLast.message == 0x10d ) // WM_IME_STARTCOMPOSITION
                         DispatchMessage( (LPMSG)&vmsgLast );
#endif
            }
        else {
            /* not eat message because FimportantMsgPresent has
            ** eaten KEY_DOWN message
            */
            donteat = FALSE;
            }
        /*
        ** When KKAPP window open, this message is offten wrong.
        ** we must check it is really WM_KEYDOWN
        */
#ifdef  KOREA   /* for level 3, 90.12.26 sangl */
        if ((vmsgLast.message == WM_CHAR) || (vmsgLast.message == WM_INTERIM)) {
#else
        if ( vmsgLast.message == WM_CHAR ) {
#endif
            return vmsgLast.wParam;
            }
        if ( vmsgLast.message != WM_KEYDOWN ) {
            return kcNil;
            }
                TranslateMessage( &vmsgLast );
                continue;
            } /* switch kc */
            } /* if keydown */
    if ( !donteat ) {
            GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
#ifdef  KOREA       /* for level 3, 91.1.21 by Sangl */
        if ( (vmsgLast.message==WM_CHAR)||(vmsgLast.message==WM_INTERIM) ) {
#else
        if ( vmsgLast.message == WM_CHAR ) {
#endif
        return vmsgLast.wParam;
            }
        } /* dont eat */
    else {
        donteat = FALSE;
        }
        } /* if kc != kcNil */
#else
    if ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil)
        {
        if (vmsgLast.message == WM_KEYDOWN)
            {
            switch (kc) {
            default:
                break;
            case kcAlphaVirtual:
                    /* This means we can't anticipate the key's meaning
                       before translation */
                if ( FNonAlphaKeyMessage( &vmsgLast, FALSE ) )
                        /* This is a non-alpha key message */
                    return kcNil;

                GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
                TranslateMessage( &vmsgLast );
                continue;
            }
            }
        GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
        }
#endif
    return kc;
    }   /* End of for ( ;; ) loop to process messages */
}

#ifdef  KOREA       /* 90.12.29 sangl */
KcInputNextHan()
{       /* Get next available key/event from Windows */
        /* Returns key code or kcNil if a non-key event */
        /* Updates the screen if there is time before events arrive */
extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern MSG  vmsgLast;   /* WINDOWS: last message gotten */
extern int  vfInsLast;
extern int vfCommandKey;
extern int vfShiftKey;
extern int vfAwfulNoise;

 int i;
 int kc;
 int tmp;

tmp = vfInsLast;
tmp = vfCommandKey;
tmp = vfShiftKey;
tmp = vfAwfulNoise;
tmp = vmsgLast.message;
tmp = vmsgLast.wParam;

 for ( ;; )
    {
    if ( FImportantMsgPresent() )
    goto GotMessage;

/* No events waiting -- if none show up for a while, update the screen */

    {       /* Dawdle for a time, looking for keys, before updating the screen */
    unsigned WHsecGetTime();
    unsigned wHsec;

    wHsec = WHsecGetTime();
    do
    {
    if ( FImportantMsgPresent() )
        goto GotMessage;

    }    while ( WHsecGetTime() - wHsec < dwHsecKeyDawdle );
    }

#ifdef DEBUG
    if (vTune)
    continue;  /* Bag background update while debugging to see how we fare */
#endif

    if ( FImportantMsgPresent() )
       goto GotMessage;

/*  vfAwfulNoise = FALSE;
    PutCpInWwHz( selCur.cpFirst );

    EndLongOp( NULL );*/

    if ( FImportantMsgPresent() )
    goto GotMessage;


    /* Nothing has happened for a while, let's blink the cursor */

    {
    unsigned WHsecGetTime();
    unsigned wHsecBlink = GetCaretBlinkTime() / 10;
    unsigned wHsecLastBlink=WHsecGetTime() + wHsecBlink/2;
    KillTimer( vhWnd, tidCaret );
    for ( ;; )
    {
    unsigned wHsecT;

        if ( FImportantMsgPresent() ) {
        SetTimer( vhWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
        goto GotMessage;
        }

    /* Another app may have stolen the focus away from us while we called
    PeekMessage(), in which case we should end Alpha mode. */
        if (!vfFocus) {
        SetTimer( vhWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
        return kcNil;
        }

    if ( (wHsecT = WHsecGetTime()) - wHsecLastBlink >= wHsecBlink )
        {
        DrawInsertLine();
        wHsecLastBlink = wHsecT;
        }
    }
    }

    continue;

GotMessage:
    {  // MSCH bklee 12/22/94
       #define VK_PROCESSKEY 0xE5 // New finalize message. bklee.
       #include "ime.h"
       MSG msg;
       extern  BOOL fInterim;

       if (fInterim) {
           if (PeekMessage ((LPMSG)&msg, vhWnd, WM_KEYDOWN, WM_SYSKEYUP, PM_NOYIELD | PM_NOREMOVE )) {
               if ( msg.wParam == VK_MENU || msg.wParam == VK_PROCESSKEY )
                    return VK_MENU;
               else if( msg.wParam == VK_LEFT || msg.wParam == VK_RIGHT ) {
                    HANDLE  hIme;
                    LPIMESTRUCT lpIme;
                    DWORD dwConversionMode;

                    hIme = GlobalAlloc (GMEM_MOVEABLE|GMEM_DDESHARE,(LONG)sizeof(IMESTRUCT));
                    if (hIme && (lpIme = (LPIMESTRUCT)GlobalLock(hIme))) {
                       lpIme->fnc = IME_GETCONVERSIONMODE;
                       GlobalUnlock(hIme);

                       dwConversionMode = SendIMEMessage (GetFocus(), MAKELONG(hIme,0));
                       GlobalFree(hIme);
                    }
                    if (dwConversionMode & IME_MODE_HANJACONVERT) // Hanja conversion mode
                        return VK_MENU;
               }
           }
       }
    }

    if( vmsgLast.wParam == VK_EXECUTE )
        vmsgLast.wParam = VK_RETURN;

/* To GetMessage for Func/Ctrl/direc keys, 90.4.4, Sang-Weon */
    if ( ((kc=KcAlphaKeyMessage(&vmsgLast))!=kcNil) || IsInterim )
    {
if( vmsgLast.wParam == VK_EXECUTE )
    return kcNil;

    if (vmsgLast.message == WM_KEYDOWN)
        {
        switch (kc) {
        default:
        break;
        case kcAlphaVirtual:
            /* This means we can't anticipate the key's meaning
               before translation */
        if ( FNonAlphaKeyMessage(&vmsgLast, FALSE) && !IsInterim )
            /* This is a non-alpha key message */
            return kcNil;
        if ( !donteat ) {
            GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
            }
        else {
            /* not eat message because FimportantMsgPresent has
            ** eaten KEY_DOWN message
            */
            donteat = FALSE;
            }
        /*
        ** When KKAPP window open, this message is offten wrong.
        ** we must check it is really WM_KEYDOWN
        */
        if ( (vmsgLast.message==WM_CHAR)||(vmsgLast.message==WM_INTERIM) ) {
            return vmsgLast.wParam;
            }
        if ( vmsgLast.message != WM_KEYDOWN ) {
            return kcNil;
            }
        TranslateMessage( &vmsgLast );
        continue;
        } /* switch kc */
        } /* if keydown */
    if ( !donteat ) {
        GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
        if ( (vmsgLast.message==WM_CHAR)||(vmsgLast.message==WM_INTERIM) ) {
        return vmsgLast.wParam;
        }
        } /* dont eat */
    else {
        donteat = FALSE;
        }
    } /* if kc != kcNil */
    return kc;
    }   /* End of for ( ;; ) loop to process messages */
}
#endif  /* ifdef KOREA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\insertco.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOGDI
#define NOKEYSTATE
#define NOHDC
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "stcdefs.h"
#include "fkpdefs.h"
#include "editdefs.h"
#include "wwdefs.h"
#include "dispdefs.h"

/* E X T E R N A L S */
extern struct WWD rgwwd[];
extern int docCur;
extern struct CHP vchpFetch;
extern struct CHP vchpInsert;
extern struct CHP vchpSel;
extern struct CHP vchpNormal;
extern struct FKPD     vfkpdParaIns;
extern typeFC fcMacPapIns;
extern struct PAP *vppapNormal;
extern struct PAP vpapPrevIns;
extern struct FCB (**hpfnfcb)[];
extern struct BPS      *mpibpbps;
extern CHAR           (*rgbp)[cbSector];

extern typePN PnAlloc();


InsertRgch(doc, cp, rgch, cch, pchp, ppap)
int doc, cch;
typeCP cp;
CHAR rgch[];
struct CHP *pchp;
struct PAP *ppap;
{ /* Insert cch characters from rgch into doc before cp */
        typeFC fc;
        struct CHP chp;

        /* First finish off the previous CHAR run if necessary */
        if (pchp == 0)
                { /* Make looks be those of PREVIOUS character */
                CachePara(doc,cp);
                FetchCp(doc, CpMax(cp0, cp - 1), 0, fcmProps);
                blt(&vchpFetch, &chp, cwCHP);
                chp.fSpecial = false;
                pchp = &chp;
                }
        NewChpIns(pchp);

        /* Now write the characters to the scratch file */
        fc = FcWScratch(rgch, cch);

        /* Now insert a paragraph run if we inserted an EOL */
        if (ppap != 0)
                { /* Inserting EOL--must be last character of rgch */
                AddRunScratch(&vfkpdParaIns, ppap, vppapNormal,
                        FParaEq(ppap, &vpapPrevIns) &&
                        vfkpdParaIns.brun != 0 ? -cchPAP : cchPAP,
                        fcMacPapIns = (**hpfnfcb)[fnScratch].fcMac);
                blt(ppap, &vpapPrevIns, cwPAP);
                }

        /* Finally, insert the piece into the document */
        Replace(doc, cp, cp0, fnScratch, fc, (typeFC) cch);
}





InsertEolInsert(doc,cp)
int doc;
typeCP cp;
{
struct PAP papT;
struct CHP chpT;
CHAR rgch[2];

/* (MEMO) Here's the problem: When we insert or paste into a running head or
   foot, we expect all paras to have a non-0 rhc. This gets called from
   Replace to put in an Eol when we are inserting or pasting in front of
   a picture. It needs, therefore, to have running head properties when
   appropriate.  In a future world, cpMinDocument, cpMinHeader, cpMacHeader,
   cpMinFooter, and cpMacFooter will be document attributes instead of
   globals, and will be duly adjusted by AdjustCp. Then, we can trash the
   somewhat kludgy check for doc==docCur and editing header/footer,
   and instead check for cp within header/footer bounds for doc. */

papT = *vppapNormal;
if (doc==docCur)
    if (wwdCurrentDoc.fEditHeader)
        papT.rhc = RHC_fOdd + RHC_fEven;
    else if (wwdCurrentDoc.fEditFooter)
        papT.rhc = RHC_fBottom + RHC_fOdd + RHC_fEven;

#ifdef CRLF
        rgch[0] = chReturn;
        rgch[1] = chEol;
        chpT = vchpSel;
        chpT.fSpecial = fFalse;
        InsertRgch(doc, cp, rgch, 2, &chpT, &papT);
#else
        rgch[0] = chEol;
        chpT = vchpSel;
        chpT.fSpecial = fFalse;
        InsertRgch(doc, cp, rgch, 1, &chpT, &papT);
#endif
}





InsertEolPap(doc, cp, ppap)
int doc;
typeCP cp;
struct PAP      *ppap;
{
extern struct CHP vchpAbs;
struct CHP chpT;
#ifdef CRLF
CHAR rgch [2];
#else
CHAR rgch [1];
#endif

    /* We must get props here instead of using vchpNormal because of the
       "10-point kludge".  We don't want to change the default font
       just because we have to insert a new pap */

FetchCp( doc, cp, 0, fcmProps );
chpT = vchpAbs;
chpT.fSpecial = fFalse;

#ifdef CRLF
rgch [0] = chReturn;
rgch [1] = chEol;
InsertRgch(doc, cp, rgch, 2, &chpT, ppap);
#else
InsertRgch(doc, cp, rgch, 1, &chpT, ppap);
#endif
}




AddRunScratch(pfkpd, pchProp, pchStd, cchProp, fcLim)
struct FKPD *pfkpd;
CHAR *pchProp, *pchStd;
int cchProp;
typeFC fcLim;
{ /* Add a CHAR or para run to the scratch file FKP (see FAddRun) */
struct FKP *pfkp;
CHAR *pchFprop;
struct RUN *prun;
int ibp;

pfkp = (struct FKP *) rgbp[ibp = IbpEnsureValid(fnScratch, pfkpd->pn)];
pchFprop = &pfkp->rgb[pfkpd->bchFprop];
prun = (struct RUN *) &pfkp->rgb[pfkpd->brun];


while (!FAddRun(fnScratch, pfkp, &pchFprop, &prun, pchProp, pchStd, cchProp,
    fcLim))
        { /* Go to a new page; didn't fit. */
        int ibte = pfkpd->ibteMac;
        struct BTE (**hgbte)[] = pfkpd->hgbte;

        /* Create new entry in bin table for filled page */
        if (!FChngSizeH(hgbte, ((pfkpd->ibteMac = ibte + 1) * sizeof (struct BTE)) / sizeof (int),
            false))
                return;
        (**hgbte)[ibte].fcLim = (prun - 1)->fcLim;
        (**hgbte)[ibte].pn = pfkpd->pn;

        /* Allocate new page */
        pfkpd->pn = PnAlloc(fnScratch);
        pfkpd->brun = 0;
        pfkpd->bchFprop = cbFkp;

        if (cchProp < 0) /* New page, so force output of fprop */
                cchProp = -cchProp;

        /* Reset pointers and fill in fcFirst */
        pfkp = (struct FKP *) rgbp[ibp = IbpEnsureValid(fnScratch, pfkpd->pn)];
        pfkp->fcFirst = (prun - 1)->fcLim;
        pchFprop = &pfkp->rgb[pfkpd->bchFprop];
        prun = (struct RUN *) &pfkp->rgb[pfkpd->brun];
        }

mpibpbps[ibp].fDirty = true;
pfkpd->brun = (CHAR *) prun - &pfkp->rgb[0];
pfkpd->bchFprop = pchFprop - &pfkp->rgb[0];
}




int FAddRun(fn, pfkp, ppchFprop, pprun, pchProp, pchStd, cchProp, fcLim)
int fn, cchProp;
struct FKP *pfkp;
CHAR **ppchFprop, *pchProp, *pchStd;
struct RUN **pprun;
typeFC  fcLim;
{ /* Add a run and FCHP/FPAP to the current FKP. */
        /* Make a new page if it won't fit. */
        /* If cchProp < 0, don't make new fprop if page not full */
int cch;

/* If there's not even enough room for a run, force new fprop */
if (cchProp < 0 && (CHAR *) (*pprun + 1) > *ppchFprop)
        cchProp = -cchProp;

if (cchProp > 0)
        { /* Make a new fprop */
        /* Compute length of FPAP/FCHP */
        if (cchProp == cchPAP)
                {
/* compute difference from vppapNormal */
                if (((struct PAP *)pchProp)->rgtbd[0].dxa != 0)
                        {
                        int itbd;
/* find end of tab table */
                        for (itbd = 1; itbd < itbdMax; itbd++)
                                if (((struct PAP *)pchProp)->rgtbd[itbd].dxa == 0)
                                        {
                                        cch = cwPAPBase * cchINT + (itbd + 1) * cchTBD;
                                        goto HaveCch;
                                        }
                        }
                cchProp = cwPAPBase * cchINT;
                }
        cch = CchDiffer(pchProp, pchStd, cchProp);
HaveCch:
        if (cch > 0)
                ++cch;

        /* Determine whether info will fit on this page */
        if ((CHAR *) (*pprun + 1) > *ppchFprop - cch)
                { /* Go to new page; this one is full */
                if (fn == fnScratch)
                        return false; /* Let AddRunScratch handle this */
                WriteRgch(fn, pfkp, cbSector);
                pfkp->fcFirst = (*pprun - 1)->fcLim;
                *ppchFprop = &pfkp->rgb[cbFkp];
                *pprun = (struct RUN *) pfkp->rgb;
                }

        /* If new FPAP is needed, make it */
        if (cch > 0)
                {
                (*pprun)->b = (*ppchFprop -= cch) - pfkp->rgb;
                **ppchFprop = --cch;
                bltbyte(pchProp, *ppchFprop + 1, cch);
                }
        else /* Use standard props */
                (*pprun)->b = bNil;
        }
else  /* Point to previous fprop */
        (*pprun)->b = (*pprun - 1)->b;

    /* Replaced old sequence (see below) */
(*pprun)->fcLim = fcLim;
pfkp->crun = ++(*pprun) - (struct RUN *) pfkp->rgb;

/*      Used to be like this, but CMERGE -Oa (assume no aliasing)
        option made it not work -- "*pprun" is an alias for the
        postincremented value of *pprun */
/*(*pprun)++->fcLim = fcLim;
pfkp->crun = *pprun - (struct RUN *) pfkp->rgb; */

return true;
}


/* F  P A R A  E Q */
/* compares two PAP structures. Problem: tab tables are not fixed length
but are terminated by 0 dxa. */
FParaEq(ppap1, ppap2)
struct PAP *ppap1, *ppap2;
        {
        struct TBD *ptbd1 = ppap1->rgtbd, *ptbd2 = ppap2->rgtbd;
        while (ptbd1->dxa == ptbd2->dxa)
                {
                if (ptbd1->dxa == 0)
                        return CchDiffer(ppap1, ppap2, cchPAP) == 0;
                if (*(long *)ptbd1 != *(long *)ptbd2) break;
                ptbd1++; ptbd2++;
                }
        return fFalse;
        }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\jumppage.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOSCROLL
#define NOMB
#include <windows.h>

#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "str.h"
#include "propdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "docdefs.h"


extern int    rgval[];
extern struct WWD *pwwdCur;
extern struct DOD (**hpdocdod)[];
extern int        docCur;     /* Document in current ww */
extern struct SEL selCur;      /* Current selection (i.e., sel in current ww */
extern struct SEP vsepNormal;
extern HWND       vhWndMsgBoxParent;
extern int        vfCursorVisible;
extern HCURSOR    vhcArrow;



BOOL far PASCAL DialogGoTo( hDlg, message, wParam, lParam )
HWND    hDlg;            /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
    /* This routine handles input to the Go To dialog box. */
    /*RECT rc;*/
    struct SEP **hsep = (**hpdocdod)[docCur].hsep;
    struct SEP *psep;
    CHAR szT[cchMaxNum];
    CHAR *pch = &szT[0];
    extern ferror;

    switch (message)
    {
    case WM_INITDIALOG:
        EnableOtherModeless(false);
        /* Get a pointer to the section properties. */
        psep = (hsep == NULL) ? &vsepNormal : *hsep;

        /* Initialize the starting page number. */
        if (psep->pgnStart != pgnNil)
            {
            szT[ncvtu(psep->pgnStart, &pch)] = '\0';
            SetDlgItemText(hDlg, idiGtoPage, (LPSTR)szT);
            SelectIdiText(hDlg, idiGtoPage);
            }
        else
            {
            SetDlgItemText(hDlg, idiGtoPage, (LPSTR)"1");
            SelectIdiText(hDlg, idiGtoPage);
            }
        break;

    case WM_SETVISIBLE:
        if (wParam)
            EndLongOp(vhcArrow);
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            vhWndMsgBoxParent = hDlg;
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
        {
        case idiOk:
            if (!WPwFromItW3Id(&rgval[0], hDlg, idiGtoPage, pgnMin, pgnMax, wNormal, IDPMTNPI))
                {
                ferror = FALSE; /* reset error condition, so as to report any 
                                   further error */
                break;
                }
            OurEndDialog(hDlg, TRUE);   /* So we take down the dialog box and
                                           only screen update ONCE ..pault */
            CmdJumpPage();
            if (pwwdCur->fRuler)
                UpdateRuler();
            break;
        
        case idiCancel:
CancelDlg:
            OurEndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;

    case WM_CLOSE:
        goto CancelDlg;

    default:
        return(FALSE);
    }
    return(TRUE);
}
/* end of DialogGoTo */


/* C M D  J U M P  P A G E */
CmdJumpPage()
    { /* JUMP PAGE:
	0    page number
       */

    extern typeCP cpMinCur;

    int ipgd;
    int cpgd;
    register struct PGD *ppgd;
    struct PGTB **hpgtb = (**hpdocdod)[docCur].hpgtb;
    BOOL fWrap = FALSE;
    typeCP cpTarget;


    ClearInsertLine();

    if (hpgtb == NULL)
	{
	goto SelFirstPage;
	}

    cpgd = (**hpgtb).cpgd;

TryAgain:
    for (ipgd = 0, ppgd = &(**hpgtb).rgpgd[0]; ipgd < cpgd; ipgd++, ppgd++)
	{
	if (ppgd->pgn == rgval[0] && (fWrap || ipgd + 1 == cpgd ||
	  (ppgd + 1)->cpMin > selCur.cpFirst))
	    {
	    cpTarget = ppgd->cpMin;
	    goto ShowPage;
	    }
	}
    if (!fWrap)
	{
	fWrap = TRUE;
	goto TryAgain;
	}

    /* If rgval[0] > last page number jump to last page */
    if ((ppgd = &(**hpgtb).rgpgd[cpgd - 1])->pgn < rgval[0])
	{
	cpTarget = ppgd->cpMin;
	}
    else if (rgval[0] == 1)
	{

SelFirstPage:
	cpTarget = cpMinCur;
	}
    else
	{
	Error(IDPMTNoPage);
	return;
	}

ShowPage:
    /* Position first char of page on the first dl */
    DirtyCache(pwwdCur->cpFirst = cpTarget);
    pwwdCur->ichCpFirst = 0;
    CtrBackDypCtr(0, 0);

    /* In this case, CpFirstSty() will update the screen. */
    cpTarget = CpFirstSty(cpTarget, styLine);
    Select(cpTarget, cpTarget);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\kanji.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* kanji.h ----- kanji primitives forward declaration. */

#ifdef DBCS

/***** common definition for Korea, Japan and Taiwan PRC *****/

/* CHLS (c of half line spacing) used to indicate the default
   line spacing.  Used in createww.c and initmmw.c */
#define chlsSingle      2
#define chlsOneHalf     3
#define chlsDouble      4

#define chlsDefault     chlsOneHalf


/* HDC             KanjiGetDC(HWND);        */
/* void FAR PASCAL SetMapperFlags(HDC, long);   */
/* And the kludge value to be used. */
#define NEC_HACK      ((long) 0x04)


/* struct DNUT is used to map a unit annotation to ut. */
struct DNUT {
    char    *szUnit;
    int     ut;
    };

#ifdef CASHMERE
#define IDNUTMAX  19
#else
#define IDNUTMAX  15
#endif /* CASHMERE */


/* Function type declarations. */
int      HpsFromDya(unsigned);
unsigned DyaFromHps(int);

BOOL     FPasteTooLarge(unsigned long);

/* For copy command, we now use the "COPY" key. */
#ifndef NONECKEYBOARD
#define VK_COPY     0x2C
#else
#ifndef NOVIRTUALKEYCODES
#define VK_COPY     VK_F2
#endif /* not NOVIRTUALKEYCODES */
#endif /* if-else-def NONECKEYBOARD */

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif /* DEBUG */

/* Kanji flag ---- used in CpFirstSty() */
#define fkNonKanji ((CHAR) 0)
#define fkKanji1   ((CHAR) 1)
#define fkKanji2   ((CHAR) 2)

#define cchKanji   2

#define MAKEWORD(_bHi, _bLo) ((((WORD) _bHi) << 8) | ((WORD) _bLo))

#define dxp0       0

/******* KOREA specific definitons *******/

#ifdef  KOREA
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0xA1
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0xA1
/* 1 byte kanji period. */
#define bKanjiKuten 0xA1

#define FKanji1(_ch) (((int) (_ch))>=0x0081 && ((int) (_ch))<=0x00FE)
#define FKanji2(_ch) (((int) (_ch))>=0x0041 && ((int) (_ch))<=0x00FE)
#define FKana(_ch)      (FALSE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  ((0xB0 <= ((int) (_ch)) && ((int) (_ch)) <= 0xC8) \
                          || (0xCA <= ((int) (_ch)) && ((int) (_ch)) <= 0xFD))
#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA2)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x00A1)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                 ((int) (_ch2)) == 0x00AF)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                  ((int) (_ch2)) == 0x00AE)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x00A1)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x00A3)


/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
#define chEMark     ((CHAR) 0xA4)
#define chStatPage  ((CHAR) 0xBB)
#if 0
#define chMark1     ((CHAR) 0xA1)
#define chEMark     ((CHAR) 0xDF)
#define chStatPage  ((CHAR) 0xB7)
#define chStatRH    ((CHAR) 0xB5)
#endif

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    2
static CHAR mpdchrgchIdx[2] = {0xA1, 0xA3};
static int  mpdchichMax[2] = {13, 12};

static CHAR mpdchrgch[2][13] = {
          /* A1 */ {0xA1, 0xAF, 0xB1, 0xB3, 0xB5, 0xB7, 0xB9, 0xBB, 0xBD, 0xC6, 0xC7, 0xC8, 0xC9},
          /* A3 */ {0xA1, 0xA2, 0xA5, 0xA7, 0xA9, 0xAC, 0xAE, 0xBA, 0xBB, 0xBF, 0xDD, 0xFD}
                               };

/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    1
static  CHAR OptAdmit2Idx[1] = {0xA3};
static  int OptAdmit2ichMax[1] = {6};
static  CHAR mpdchrgchOptAdmit2[1][6] = {
                {0xA1, 0xAC, 0xAE, 0xBA, 0xBB, 0xBF}
                                        };
#endif      /* CODE_TABLE */

#endif      /* Korea */

/******* JAPAN specific definitons *******/

#ifdef  JAPAN
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0x81
/* First byte of a kanji space. */
#define bKanjiSpace1 0x81
/* Second byte of a kanji space. */
#define bKanjiSpace2 0x40
/* 1 byte kanji period. */
#define bKanjiKuten 0xA1

#define FKanji1(_ch) ((((int) (_ch))>=0x0081 && ((int) (_ch))<=0x009f)  \
                   || (((int) (_ch))>=0x00e0 && ((int) (_ch))<=0x00fc))
//T-HIROYN Win3.1
#define FKanji2(_ch) ((((int) (_ch))>=0x0040 && ((int) (_ch))<=0x007e)  \
                   || (((int) (_ch))>=0x0080 && ((int) (_ch))<=0x00fc))

#define FKana(_ch)      (0xA0 <= ((int) (_ch)) && ((int) (_ch)) <= 0xdf)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  (0xA6 <= ((int) (_ch)) && ((int) (_ch)) <= 0xDD)
#define FKanaPunct(_ch) ((0xA0 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA5) || \
                         (0xDE <= ((int) (_ch)) && ((int) (_ch)) <= 0xDF))

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x0081 && \
                                 ((int) (_ch2)) == 0x0040)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x0081 && \
                                 ((int) (_ch2)) == 0x0048)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x0081 && \
                                  ((int) (_ch2)) == 0x0044)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x0081 && \
                                  ((int) (_ch2)) == 0x0049)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x0081 && \
                                  ((int) (_ch2)) == 0x0042)

/* Write 3.1j endmark and pagemark is 1-byte charcter
 *                              t-Yoshio May 26,92
 */
//Win3.1 New Code
#define chEMark     ((CHAR) 0xA4)
#define chStatPage  ((CHAR) 0xBB)
/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
//Win3.0
#if 0
#define chMark1     ((CHAR) 0x81)
#define chEMark     ((CHAR) 0x9F)
#define chStatPage  ((CHAR) 0x74)
#define chStatRH    ((CHAR) 0x72)
#endif

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    4
static CHAR mpdchrgchIdx[4] = {0x81, 0x82, 0x83, 0x85};
static int  mpdchichMax[4] = {24, 9, 12, 20};

static CHAR mpdchrgch[4][24] = {
             /* 0x81 */ {0x40, 0x41, 0x42, 0x45, 0x4A, 0x4B, 0x5B, 0x5C,
                         0x5D, 0x63, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E,
                         0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x8C, 0x8D},
             /* 0x82 */ {0x9F, 0xA1, 0xA3, 0xA5, 0xA7, 0xC1, 0xE1, 0xE3,
                         0xE5},
             /* 0x83 */ {0x40, 0x42, 0x44, 0x46, 0x48, 0x62, 0x83, 0x85,
                         0x87, 0x8E, 0x95, 0x96},
             /* 0x85 */ {0x41, 0x46, 0x48, 0x7C, 0x9D, 0x9F, 0xA1, 0xA2,
                         0xA3, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB,
                         0xAC, 0xAD, 0xDC, 0xDD}
                               };
/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    2
static  CHAR OptAdmit2Idx[2] = {0x81, 0x85};
static  int OptAdmit2ichMax[2] = {6,6};
static  CHAR mpdchrgchOptAdmit2[2][6] = {
                        {0x43, 0x44, 0x46, 0x47, 0x48, 0x49},
                        {0x40, 0x49, 0x4A, 0x4B, 0x4D, 0x5E}
                                        };
#endif      /* CODE_TABLE */

#endif      /* Japan */

/******* PRC specific definitons *******/


#ifdef  PRC
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0x81
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0xA1
/* 1 byte kanji period. */
#define bKanjiKuten 0x7F

#define FKanji1(_ch) (((int) (_ch))>=0x0081 && ((int) (_ch))<=0x00FE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  ((0x81 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA0) ||  \
	                     (0xAA <= ((int) (_ch)) && ((int) (_ch)) <= 0xFE))

#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA9)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x00A1)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                 ((int) (_ch2)) == 0x00BF)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A3 && \
                                  ((int) (_ch2)) == 0x00AE)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A3 && \
                                  ((int) (_ch2)) == 0x00A1)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x00A2)


/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
#define chMark1     ((CHAR) 0xA1)
#define chEMark     ((CHAR) 0xF4)
#define chStatPage  ((CHAR) 0x6E)
#define chStatRH    ((CHAR) 0x72)

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    2
static CHAR mpdchrgchIdx[2] = {0xA1, 0xA3};
static int  mpdchichMax[2]  = {11,13};

static CHAR mpdchrgch[2][13] = {
	            /* 0xA1 */     {0xA2, 0xA3, 0xAF, 0xB1, 0xB3, 0xB5, 0xB7, 
                                0xB9, 0xBB, 0xBD, 0xBF},
	            /* 0xA3 */     {0xA1, 0xA2, 0xA7, 0xA9, 0xAC, 0xAE, 0xBA, 
                                0xBB, 0xBF, 0xDD, 0xE0, 0xFC, 0xFD},
						       };
/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    2
static  CHAR OptAdmit2Idx[2] = {0xA1, 0xA3};
static  int OptAdmit2ichMax[2] = {1,5};
static  CHAR mpdchrgchOptAdmit2[2][5] = {
	                   /* 0xA1 */         { 0xA3 },
	                   /* 0xA3 */         { 0xA1, 0xAE, 0xBA, 0xBB, 0xBF }
	                                    };
#endif      /* CODE_TABLE */

#else  

/******* TAIWAN specific definitons *******/

#ifdef  TAIWAN
/* Used in GetKanjiMeasurement */
#define bKanji1Min   0xA1
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0x40
/* 1 byte kanji period. */
#define bKanjiKuten 0x7F

#define FKanji1(_ch) (((int) (_ch))>=0x0081 && ((int) (_ch))<=0x00FE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  (0xA4 <= ((int) (_ch)) && ((int) (_ch)) <= 0xFE)
#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA3)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0040)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0048)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0044)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0049)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0042)


/* Since the higher half of 1-byte character codes are used for
   kanas and the first byte of a kanji character, we will use
   kanji characters for our markers. */
#define chMark1     ((CHAR) 0xA1)
#define chEMark     ((CHAR) 0xBB)
#define chStatPage  ((CHAR) 0x6E)
#define chStatRH    ((CHAR) 0x72)

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    1
static CHAR mpdchrgchIdx[1] = {0xA1};
static int  mpdchichMax[1] = {24};

static CHAR mpdchrgch[1][24] = {
                        {0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x48, 0x49,
                         0x4A, 0x4D, 0x4E, 0x51, 0x52, 0x53, 0x54, 0x62,
                         0x66, 0x6A, 0x77, 0x7B, 0x7E, 0xA2, 0xA4, 0xA8}
                               };

/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    1
static  CHAR OptAdmit2Idx[1] = {0xA1};
static  int OptAdmit2ichMax[1] = {6};
static  CHAR mpdchrgchOptAdmit2[1][6] = {
                        0x43, 0x44, 0x46, 0x47, 0x48, 0x49,
                                        };
#endif      /* CODE_TABLE */

#endif      /* Taiwan */

#endif  /* PRC */

#ifdef USA
#define chMark1     ((CHAR) 0x81)
#define chStatPage      (CHAR)'\273'
#define chStatRH        '>'
#define chEMark         (CHAR)'\244'


/* Used in GetKanjiMeasurement */
#define bKanji1Min   0xA1
/* First byte of a kanji space. */
#define bKanjiSpace1 0xA1
/* Second byte of a kanji space. */
#define bKanjiSpace2 0xA1
/* 1 byte kanji period. */
#define bKanjiKuten 0xA1

#define FKanji1(_ch) (((int) (_ch))>=0x00A1 && ((int) (_ch))<=0x00FE)
/* Excludes any kana punctuations. */
#define FKanaText(_ch)  (0xA4 <= ((int) (_ch)) && ((int) (_ch)) <= 0xFE)
#define FKanaPunct(_ch) (0xA1 <= ((int) (_ch)) && ((int) (_ch)) <= 0xA3)

#define FKanjiSpace(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0040)
#define FKanjiQMark(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                 ((int) (_ch2)) == 0x0048)
#define FKanjiPeriod(_ch1, _ch2) (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0044)
#define FKanjiBang(_ch1, _ch2)   (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0049)
#define FKanjiKuten(_ch1, _ch2)  (((int) (_ch1)) == 0x00A1 && \
                                  ((int) (_ch2)) == 0x0042)

#ifdef  CODE_TABLE
/* The following tables defines those characters which can be display
   beyond the right margin.
   Refer to FAdmitCh2 function in d_FORM1.c */

#define MPDCHRGCHIDX_MAC    0
static CHAR mpdchrgchIdx[1] = {0};
static int  mpdchichMax[1] = {0};

static CHAR mpdchrgch[1][1] = {0};

/* The followin tables specify characters which can exist beyond the
   right margin provided there is a kanji character on its left side
   Refer to FOptAdmitCh2 in d_FORM1.c on how to use them */

#define OPTADMIT2IDX_MAC    0
static  CHAR OptAdmit2Idx[1] = {0};
static  int OptAdmit2ichMax[1] = {0};
static  CHAR mpdchrgchOptAdmit2[1][1] = {0};
#endif      /* CODE_TABLE */

#endif

#endif      /* Kanji */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\lib.asm ===
TITLE   lib - various C library routines

; Windows Write, Copyright 1985-1992 Microsoft Corporation
;=============================================================================
;   This file contains various C library functions (and a few other
;   functions) with the PL/M calling conventions.  These routines
;   may some day make their way into a real library of some kind, but
;   until then, you'll just have to link this file in with the rest
;   of your code.
;=============================================================================

?PLM = 1
?WIN = 1

;*** See note about cmacros2.inc in DOSLIB.ASM
include cmacros3.inc

;
;createSeg _MMP2, code, byte, public, CODE
;

sBegin  CODE
;    assumes CS,_MMP2
        assumes CS,CODE

;------------------------------------------------------------------------------
; bltbyte (pbFrom, pbTo, cb) - a block transfer of bytes from pbFrom to
; pbTo.  The size of the block is cb bytes.  This bltbyte() handles the
; case of overlapping source and destination.  bltbyte() returns a pointer
; to the end of the destination buffer (pbTo + cb).  NOTE - use this
; bltbyte to transfer within the current DS only--use the bltbx for
; FAR blts.
;-----------------------------------------------------------------------------

cProc bltbyte, <FAR, PUBLIC>, <SI, DI>
parmDP  <pbFrom, pbTo>
parmW   <cb>
cBegin bltbyte
    mov     si,pbFrom           ; get pointers and length of blt
    mov     di,pbTo
    mov     cx,cb
    mov     ax,di               ; calculate return value
    add     ax,cx
    push    ds                  ; set up segment registers
    pop     es
    cmp     si,di               ; reverse direction of the blt if
    jae     bltb1               ;  necessary
    add     si,cx
    add     di,cx
    dec     si
    dec     di
    std
bltb1:
    rep     movsb
    cld
cEnd bltbyte

;-----------------------------------------------------------------------------
; bltbx (qbFrom, qbTo, cb) - same as bltbyte above except everything is
; handled as FAR pointers.
;-----------------------------------------------------------------------------

cProc bltbx, <FAR, PUBLIC>, <SI, DI, DS>
parmD <qbFrom, qbTo>
parmW <cb>
cBegin bltbx
    les     di,qbTo
    lds     si,qbFrom
    mov     cx,cb
    mov     ax,di
    add     ax,cx
    cmp     si,di
    jae     bltbx1
    add     si,cx
    add     di,cx
    dec     si
    dec     di
    std
bltbx1:
    rep     movsb
    cld
    mov     dx,es
cEnd bltbx


;------------------------------------------------------------------------------
; blt (pFrom, pTo, cw) - a block transfer of wFills from pFrom to pTo;
; The size of the block is cw wFills.  This blt() handles the case of
; overlapping source and destination.  blt() returns a pointer to the
; end of the destination buffer (pTo + cw).  NOTE - use this blt() to
; to transfer within the current DS only--use the bltx for FAR blts.
;-----------------------------------------------------------------------------

cProc blt, <FAR, PUBLIC>, <SI, DI>
parmDP  <pFrom, pTo>
parmW   <cw>
cBegin blt
    mov     si,pFrom            ; get pointers and length of blt
    mov     di,pTo
    mov     cx,cw
    mov     ax,di               ; calculate return value
    mov     bx,cx
    shl     bx,1
    add     ax,bx
    push    ds                  ; set up segment registers
    pop     es
    cmp     si,di               ; reverse direction of the blt if
    jae     blt1                ;  necessary
    dec     bx
    dec     bx
    add     si,bx
    add     di,bx
    std
blt1:
    rep     movsw
    cld
cEnd blt

;-----------------------------------------------------------------------------
; bltx (qFrom, qTo, cw) - same as blt() above except everything is
; handled as FAR pointers.
;-----------------------------------------------------------------------------

cProc bltx, <FAR, PUBLIC>, <si, di, ds>
parmD <qFrom, qTo>
parmW <cw>
cBegin bltx
    les     di,qTo
    lds     si,qFrom
    mov     cx,cw
    mov     ax,di
    mov     bx,cx
    shl     bx,1
    add     ax,bx
    cmp     si,di
    jae     bltx1
    dec     bx
    dec     bx
    add     si,bx
    add     di,bx
    std
bltx1:
    rep     movsw
    cld
    mov     dx,es
cEnd bltx

;-----------------------------------------------------------------------------
; bltc (pTo, wFill, cw) - fills cw words of memory starting at pTo with wFill.
;-----------------------------------------------------------------------------

cProc bltc, <FAR, PUBLIC>, <DI>
parmDP  <pTo>
parmW   <wFill, cw>
cBegin bltc
    mov     ax,ds               ; we are filling in the data segment
    mov     es,ax
    mov     di,pTo              ; get the destination, constant, and count
    mov     ax,wFill
    mov     cx,cw
    cld                         ; the operation is forward
    rep     stosw               ; fill memory
cEnd bltc

;-----------------------------------------------------------------------------
; bltcx (qTo, wFill, cw) - fills cw words of memory starting at FAR location
; qTo with wFill.
;-----------------------------------------------------------------------------

cProc bltcx, <FAR, PUBLIC>, <DI>
parmD   <qTo>
parmW   <wFill, cw>
cBegin bltcx
    les     di,qTo              ; get the destination, constant, and count
    mov     ax,wFill
    mov     cx,cw
    cld                         ; the operation is forward
    rep     stosw               ; fill memory
cEnd bltcx

;-----------------------------------------------------------------------------
; bltbc (pTo, bFill, cb) - fills cb bytes of memory starting at pTo with
; bFill.
;-----------------------------------------------------------------------------

cProc bltbc, <FAR, PUBLIC>, <DI>
parmDP  <pTo>
parmB   <bFill>
parmW   <cb>
cBegin bltbc
    mov     ax,ds               ; we are filling in the data segment
    mov     es,ax
    mov     di,pTo              ; get the destination, constant, and count
    mov     al,bFill
    mov     cx,cb
    cld                         ; the operation is forward
    rep     stosb               ; fill memory
cEnd bltbc

;-----------------------------------------------------------------------------
; bltbcx (qTo, bFill, cb) - fills cb bytes of memory starting at FAR location
; qTo with bFill.
;-----------------------------------------------------------------------------

cProc bltbcx, <FAR, PUBLIC>, <DI>
parmD   <qTo>
parmB   <bFill>
parmW   <cb>
cBegin bltbcx
    les     di,qTo              ; get the destination, constant, and count
    mov     al,bFill
    mov     cx,cb
    cld                         ; the operation is forward
    rep     stosb               ; fill memory
cEnd bltbcx



;-----------------------------------------------------------------------------
; MultDiv(w, Numer, Denom) returns (w * Numer) / Denom rounded to the nearest
; integer.  A check is made so that division by zero is not attempted.
;-----------------------------------------------------------------------------

cProc MultDiv, <FAR, PUBLIC>
parmW  <w, Numer, Denom>
cBegin MultDiv
    mov     bx,Denom    ; get the demoninator
    mov     cx,bx       ; cx holds the final sign
    or      bx,bx       ; ensure the denominator is positive
    jns     md1
    neg     bx
md1:
    mov     ax,w        ; get the word we are multiplying
    xor     cx,ax       ; make cx reflect any sign change
    or      ax,ax       ; ensure this word is positive
    jns     md2
    neg     ax
md2:
    mov     dx,Numer    ; get the numerator
    xor     cx,dx       ; make cx reflect any sign change
    or      dx,dx       ; ensure the numerator is positive
    jns     md3
    neg     dx
md3:
    mul     dx          ; multiply
    mov     cl,bl       ; get half of the demoninator to adjust for rounding
    sar     bx,1
    add     ax,bx       ; adjust for possible rounding error
    adc     dx,0        ; this is really a long addition
    sal     bx,1        ; restore the demoninator
    or      bl,cl
    cmp     dx,bx       ; check for overflow
    jae     md5
    div     bx          ; divide
    or      ax,ax       ; if sign is set, then overflow occured
    js      md5
    or      cx,cx       ; put the sign on the result
    jns     md4
    neg     ax
md4:

cEnd MultDiv

md5:
    mov     ax,7FFFh    ; return the largest integer
    or      cx,cx       ; with the correct sign
    jns     md4
    neg     ax
    jmp     md4

;-----------------------------------------------------------------------------
; FSzSame (szOne, szTwo) - Compare strings, return 1=Same, 0=different
;   Both strings in DS
;-----------------------------------------------------------------------------

cProc FSzSame, <FAR, PUBLIC>, <SI>
parmDP  <szOne>
parmDP  <szTwo>
cBegin FszSame

    mov     bx,szOne
    mov     si,szTwo

fszloop:
    mov     al,[bx]
    cmp     al,[si]
    jnz     notequal    ; found inequality - return FALSE
    inc     bx
    inc     si
    test    al,al
    jnz     fszloop     ; didn't reach a zero-terminator compare next char

    mov     ax,1
    jmp     fszend
notequal:
    xor     ax,ax
fszend:

cEnd FszSame


;-----------------------------------------------------------------------------
; CchDiffer (rgch1,rgch2,cch) - compare 2 strings, returning cch of
;                               shortest prefix leaving a common remainder
;    implementation of the following C code
;    note rather odd return values: 0 if =, # of unmatched chars +1 otherwise.
;    note comparison is from end of string
;** int CchDiffer(rgch1, rgch2, cch)
;** register CHAR *rgch1, *rgch2;
;** int cch;
;** {{ /* Return cch of shortest prefix leaving a common remainder */
;** int ich;

;** for (ich = cch - 1; ich >= 0; ich--)
        ;** if (rgch1[ich] != rgch2[ich])
                ;** break;
;** return ich + 1;
;** }}
;-----------------------------------------------------------------------------

        cProc CchDiffer, <FAR, PUBLIC>, <SI,DI>
        parmDP  <rgch1>
        parmDP  <rgch2>
        parmW   <cch>
        cBegin CchDiffer
        mov     ax,ds   ; set es=ds for string ops
        mov     es,ax

        mov     si,rgch1
        mov     di,rgch2
        mov     cx,cch     ; loop count in cx
        mov     ax,cx      ; compare from end of string down
        dec     ax
        add     si,ax
        add     di,ax
        std
        repz    cmpsb           ; compare strings
        jz      DiffRet         ; return 0 if strings =
        inc     cx              ; else increment return value
DiffRet:
        mov     ax,cx       ; return # of unmatched chars
        cld                     ; restore to be nice
        cEnd CchDiffer


ifdef DEBUG

;-----------------------------------------------------------------------------
; toggleProf () - toggles winprof (windows profiler) profiling on or off.
;     this calls to hard coded locations that both symdeb and winprof know
;     about - see Lyle Kline for an actual explanation.
;-----------------------------------------------------------------------------

cProc toggleProf, <FAR, PUBLIC>
cBegin toggleProf

    ; ** the following strings are stored by the profiler starting at
    ; ** 100h of the loaded segment. This routine checks that the 1st
    ; ** 3 letters of each string are in the proper location to determine
    ; ** whether the profiler is already loaded.

; **** segname  db      "SEGDEBUG",0
; ****          db      "PROFILER",0

        push    es
        push    di
        push    si
        xor     ax,ax
        mov     es,ax
        mov     ax,es:[14]              ;Get segment down there.
        mov     es,ax
        mov     di,0100h                ;See if Profiler in memory.

        cmp     Byte Ptr es:[di],'S'
        jnz     $0001

        cmp     Byte Ptr es:[di+1],'E'
        jnz     $0001

        cmp     Byte Ptr es:[di+2],'G'
        jnz     $0001

        cmp     Byte Ptr es:[di+9],'P'
        jnz     $0001

        cmp     Byte Ptr es:[di+10],'R'
        jnz     $0001

        mov     ax,30    ;Type of call.
        push    ax

        mov     di,00FCh
        call    Dword Ptr es:[di]       ; call to profiler toggle routine.
        add     sp,2                    ; winprof uses normal c conventions

$0001:
        pop     si
        pop     di
        pop     es

cEnd toggleProf

endif

;-----------------------------------------------------------------------------
; void OsTime( pTime )
;
;   pTime is a pointer to a structure of the form:
;       struct {
;               char min;       Minutes (0-59)
;               char hour;      Hours (0-23)
;               char hsec;      Hundredths of seconds (0-99)
;               char sec;       Seconds (0-59)
;
;   Get current time into structure
;   DOS-specific
;-----------------------------------------------------------------------------

cProc OsTime, <FAR, PUBLIC>
parmDP  <pTime>
cBegin OsTime

    mov     ah,2ch
    int     21h

    mov     bx,pTime
    mov     WORD PTR [bx], cx
    mov     WORD PTR [bx+2], dx

cEnd OsTime


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Added by PaulT 3/23/89, borrowed from PC Word 5:
;
;	IchIndexLp(lpsz, ch)
;		char far *lpsz;
;		int ch;
;	Searches for ch in lpsz and returns the index (-1 if not found)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	IchIndexLp,<FAR, PUBLIC>
	parmD	lpsz
	parmB	chT
cBegin
	mov	dx, di			; Save di
	les	di, lpsz
	mov	ah, chT
	xor	al,al
	mov	bx, di			; Save initial pointer
					; **** Can't access parms anymore

	mov	cx,-1
	repnz	scasb			; Must have '\0'
	or	ax, ax
	jz	LDoneILI
	mov	al, ah			; al = chT
	not	cx
	dec	cx
	mov	di, bx
	repnz	scasb
	jz	LDoneILI
	mov	di, bx
LDoneILI:
	mov	ax, di
	sub	ax, bx
	dec	ax			; ax = return value
	mov	di, dx			; Restore di
cEnd IchIndexLp


sEnd    CODE

        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\insert.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* insert.c -- MW insertion routines */
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOHDC
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
//#define NOATOM
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#define NOSTRERRORS
#include "str.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "fkpdefs.h"
#include "ch.h"
#include "winddefs.h"
#include "fontdefs.h"
#include "debug.h"
#if defined(OLE)
#include "obj.h"
#endif
#ifdef DBCS
#include "dbcs.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
int    changeKanjiftc = FALSE;
int    newKanjiftc = ftcNil;
#endif

/* E X T E R N A L S */

extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern MSG  vmsgLast;   /* WINDOWS: last message gotten */
extern HWND hParentWw;  /* WINDOWS: Handle for parent (MENU) window */

extern int vfSysFull;
extern int vfOutOfMemory;
extern int vxpIns;
extern int vdlIns;
extern struct PAP vpapAbs;
extern struct UAB vuab;
extern struct CHP vchpNormal;
extern int vfSeeSel;
extern int vfInsLast;
extern struct FCB (**hpfnfcb)[];
extern typeCP vcpLimParaCache;
extern typeCP vcpFirstParaCache;
extern typeCP CpMax();
extern typeCP CpMin();
extern CHAR rgchInsert[cchInsBlock]; /* Temporary insert buffer */
extern typeCP cpInsert; /* Beginning cp of insert block */
extern int ichInsert; /* Number of chars used in rgchInsert */
extern struct CHP vchpInsert;
extern int vfSelHidden;
extern struct FKPD vfkpdParaIns;
extern struct FKPD vfkpdCharIns;
extern struct PAP vpapPrevIns;
extern typeFC fcMacPapIns;
extern typeFC fcMacChpIns;
extern struct CHP vchpSel;
extern struct FLI vfli;
extern struct PAP *vppapNormal;
extern typeCP cpMinCur;
extern typeCP cpMacCur;
extern struct SEL selCur;
extern int docCur;
extern struct WWD rgwwd[];
extern struct DOD (**hpdocdod)[];
extern int wwCur;
extern struct CHP vchpFetch;
extern struct SEP vsepAbs;
extern int vfCommandKey;
extern int vfShiftKey;
extern int vfOptionKey;
extern int vfInsEnd;
extern typeCP cpWall;
extern int vfDidSearch;
extern int vdocParaCache;
extern typeCP vcpFetch;
extern int vccpFetch;
extern CHAR *vpchFetch;
extern struct CHP vchpFetch;
extern int ferror;
extern BOOL vfInvalid;
extern int docUndo;
extern struct EDL *vpedlAdjustCp;
extern int wwMac;
extern int vfFocus;
extern int vkMinus;

#ifdef CASHMERE
extern int vfVisiMode;      /* Whether "show fmt marks" mode is on */
extern int vwwCursLine;     /* Window containing cursor */
#endif

extern int vfLastCursor;    /* Whether up/down arrow xp goal position is valid */


/* state of the cursor line */
extern int vxpCursLine;
extern int vypCursLine;
extern int vdypCursLine;
extern int vfInsertOn;

/* G L O B A L S */
/* The following used to be defined here */

extern int vcchBlted;         /* # chars blted to screen, before line update */
extern int vidxpInsertCache;  /* current index of insertion into char width cache */
extern int vdlIns;
extern int vxpIns;
extern int vfTextBltValid;
extern int vfSuperIns;
extern int vdypLineSize;
extern int vdypCursLineIns;
extern int vdypBase;
extern int vypBaseIns;
extern int vxpMacIns;
extern int vdypAfter;
extern struct FMI vfmiScreen;

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

/* Used in this module only */

typeCP cpStart;    /* Start cp of the replacement operation that an Insert is */
typeCP cpLimInserted;  /* Last cp inserted */
typeCP cpLimDeleted;   /* Last cp deleted */

/* Enumerated type telling what to update  */
/* Ordering is such that larger numbers mean that there is more to update */

#define mdInsUpdNothing     0
#define mdInsUpdNextChar    1
#define mdInsUpdOneLine     2
#define mdInsUpdLines       3
#define mdInsUpdWhole       4

void NEAR FormatInsLine();
void NEAR DelChars( typeCP, int );
void NEAR EndInsert();
int  NEAR XpValidateInsertCache( int * );
int NEAR FBeginInsert();

#ifdef DBCS
CHAR near GetDBCSsecond();
BOOL      FOptAdmitCh(CHAR, CHAR);
int NEAR MdInsUpdInsertW( WORD, WORD, RECT *);
#else
int NEAR MdInsUpdInsertCh( CHAR, CHAR, RECT *);
#endif /* ifdef DBCS */

#ifdef  KOREA
int     IsInterim = 0;
int     WasInterim = 0;
BOOL    fInterim = FALSE; // MSCH bklee 12/22/94
#endif


#ifdef DEBUG
int vTune = 0;
#endif




/*      AlphaMode -- Handler for insertion, backspace, and forward delete

     Alpha mode works by inserting a block of cchInsBlock cp's at the
insertion point. The inserted piece has fn == fnInsert, cpMin == 0.
We AdjustCp for this block as though it contained cchInsBlock cp's,
even though it is initially "empty".

    When a character is typed, it is inserted at rgchInsert[ ichInsert++ ].
When rgchInsert is full, it is written to the scratch file, and
Replace'd with a new insertion block.

    AlphaMode exits when it encounters a key or event that it cannot handle
(e.g. cursor keys, mouse hits). It then cleans up, writing the insertion
block to the scratch file, and returns

    "Fast Insert" is achieved by writing characters directly to the screen
and scrolling the rest of the line out of the way.  The line is not updated
until it is necessary (or until we fall through the delay in KcInputNextKey).

    During "Fast Insert" (or fast backspace or fast delete), it is important
that ValidateTextBlt will usually NOT be called unless the line containing
the insertion point has been made valid. Otherwise, ValidateTextBlt will
fail to find a valid vdlIns, and call CpBeginLine, which forces an
update of the entire screen.
*/

#ifdef KOREA                   /* global to MdUpIns 90.12.28 */
int     dxpCh;
#endif


/* A L P H A  M O D E */
AlphaMode( kc )
int kc;         /* Keyboard Character */
{
 int rgdxp[ ichMaxLine ];
 int chShow, dlT, fGraphics;
 int mdInsUpd;
 int fDocDirty = (**hpdocdod) [docCur].fDirty;
 register struct EDL *pedl;
 int xpInsLineMac;

 int fGotKey = fFalse;
 int kcNext;
 int fScrollPending = fFalse;
 int dxpPending;
 int fDelPending = fFalse;
 typeCP cpPending;
 int cchPending;
 int mdInsUpdPending = mdInsUpdNothing;

#ifdef DBCS
 BOOL   fResetMdInsUpd = TRUE; /* To avoid the blinking cursor at beg. doc or eod. */
 CHAR   chDBCS2 = '\0'; /* Used to hold the second byte of a DBCS character */
#endif /* DBCS */

#ifdef JAPAN //T-HIROYN Win3.1
RetryAlpha:
    if(changeKanjiftc) {
        changeKanjiftc = FALSE;
        ApplyCLooks(&vchpSel, sprmCFtc, newKanjiftc);
    }
    changeKanjiftc = FALSE;
#endif

#ifdef DBCS                         /* was in JAPAN */
    if( kc == 0x000d )
          kc = 0x000a;
#endif

 if (!FWriteOk( fwcReplace ))
    {   /* Not OK to write on docCur (read-only OR out of memory) */
    _beep();
    return;
    }

/* Shut down the caret blink timer -- we don't want its messages or its cost */

#ifndef DBCS                    /* was in JAPAN */
 KillTimer( vhWnd, tidCaret );
#endif

#ifdef OLDBACKSPACE
/* Backspace in Win 3.0 has been changed to function
   identically like the Delete key ..pault 6/20/89 */

/* Handle BACKSPACE when there's a selection. DELETE with selection has already
   been filtered out by KcAlphaKeyMessage */
if (kc == kcDelPrev)
        /* Make a selection at selection-start preparatory to deleting previous
           char, which is accomplished in the loop. */
        Select( selCur.cpFirst, selCur.cpFirst );
#endif

    /* Set up initial limits for UNDO */
 cpStart = selCur.cpFirst;          /* Starting cp for insertion */
 cpLimDeleted = selCur.cpLim;       /* Last cp Deleted */

/* Delete the selection, and make an insert point selection in its stead */
/* Insert point selection inherits the properties of the deleted text */
 if (selCur.cpFirst < selCur.cpLim)
    {
    struct CHP chp;
    typeCP cpT;

    fDocDirty = TRUE;
    cpT = selCur.cpFirst;
    /* Get properties of the deleted text */
    FetchCp(docCur, cpT, 0, fcmProps);
    blt( &vchpFetch, &chp, cwCHP );
    if (fnClearEdit(OBJ_INSERTING))
        goto Abort;
    UpdateWw( wwCur, FALSE );
    if (ferror)
        goto Abort;
    Select(cpT, cpT);
    blt( &chp, &vchpSel, cwCHP );
    }
 else
    {    /* Current selection is 0 chars wide, no need to delete */
         /* Set up UNDO */
    noUndo:
    NoUndo();   /* Don't combine adjacent operations or
                   vuab.cp = cp in DelChars will be wrong */
    SetUndo( uacDelNS, docCur, cpStart, cp0, docNil, cpNil, cp0, 0);
    }

 fGraphics = FBeginInsert();

 Scribble( 7, (vfSuperIns ? 'S' : 'I') );

 vfSelHidden = false;
 vfTextBltValid = FALSE;

 if (ferror)
        /* Ran out of memory trying to insert */
    goto Abort;

 if (fGraphics)
    {
    selCur.cpFirst = selCur.cpLim = cpInsert + cchInsBlock;
/* this is to display the paragraph that has been automatically inserted
by edit in FBeginInsert */
    UpdateWw(wwCur, fFalse);
    if (kc == kcReturn)
        kc = kcNil;
    }

 for ( ; ; (fGotKey ? (fGotKey = fFalse, kc = kcNext) : (kc = KcInputNextKey())) )
    {           /* Loop til we get a command key we can't handle */
                /* KcInputNextKey will return kcNil if a nonkey */
                /* event occurs */
    RECT rc;
#ifndef  KOREA               /* has been defined globally */
    int dxpCh;
#endif

    typeCP cpFirstEdit=cpInsert + ichInsert;

    chShow = kc;
    mdInsUpd = mdInsUpdNothing;

        /* Force exit from loop if out of heap or disk space */
    if (vfSysFull || vfOutOfMemory)
        kc = kcNil;

#ifdef DBCS
    if (kc != kcDelPrev && kc != kcDelNext) {
        fResetMdInsUpd = TRUE;
        }
#endif /* DBCS */

    if (!vfTextBltValid)
        ValidateTextBlt();
    Assert( vdlIns >= 0 );
    pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
    FreezeHp();

    SetRect( (LPRECT)&rc, vxpIns+1, pedl->yp - pedl->dyp,
             wwdCurrentDoc.xpMac,
             min(pedl->yp, wwdCurrentDoc.ypMac));

    vfli.doc = docNil;

/* this is a speeder-upper of the switch below */
    if (kc <= 0)
        switch (kc)
            {
/*********************************************************************
 ********** START OF BACKSPACE/FORWARD DELETE CODE *******************
 *********************************************************************/
            CHAR chDelete;      /* Variables for Backspace/Delete */
            typeCP cpDelete;
            int cchDelete;
            int idxpDelete;
            int fCatchUp;
#ifdef DBCS
            typeCP cpT;

            case kcDelNext: /* Delete following character */
                cpT = selCur.cpFirst;
                if (fDelPending) {
                    cpT += cchPending;
                    }
                if (cpT >= cpMacCur) {
                    _beep();
                    MeltHp();
                    if (fResetMdInsUpd) {
                        mdInsUpd = mdInsUpdOneLine;
                        fResetMdInsUpd = FALSE;
                        }
                    goto DoReplace; /* Clean up pending replace ops */
                    }

                cpDelete  = CpFirstSty(cpT, styChar);
                cchDelete = CpLimSty(cpDelete, styChar) - cpDelete;
                goto DeleteChars;

            case kcDelPrev: /* Delete previous char */
                /* To reflect the state of cpPending and cchPending so that  */
                /* CpFirstSty( , styChar) is called with a proper cp.        */
                cpT = cpFirstEdit - 1;
                if (fDelPending) {
                    cpT -= cchPending;
                    }
                if (cpT < cpMinCur) {
                    _beep();
                    MeltHp();
                    if (fResetMdInsUpd) {
                        mdInsUpd = mdInsUpdOneLine;
                        fResetMdInsUpd = FALSE;
                        }
                    goto DoReplace;
                    }

                cpDelete = CpFirstSty(cpT, styChar);
                cchDelete = CpLimSty(cpDelete, styChar) - cpDelete;

#if defined(NEED_FOR_NT351_TAIWAN)  //Removed by bklee //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/24/93
    if ( cchDelete > 1 && (cpDelete + cchDelete + cchInsBlock) > cpMacCur )
        cchDelete = 1;
#endif  TAIWAN

#else
            case kcDelNext: /* Delete following character */
                cpDelete = selCur.cpFirst;
                if (fDelPending)
                    cpDelete += cchPending;

                if (cpDelete >= cpMacCur)
                    {
                    _beep();
                    MeltHp();
                    goto DoReplace;     /* Clean up pending replace ops */
                    }
                FetchCp( docCur, cpDelete, 0, fcmChars );
                chDelete = *vpchFetch;
                cchDelete = 1;
#ifdef CRLF
                if ((chDelete == chReturn) && (*(vpchFetch+1) == chEol) )
                    {
                    cchDelete++;
                    chDelete = chEol;
                    }
#endif
                goto DeleteChars;

            case kcDelPrev: /* Delete previous char */
                    /* Decide what char, cp we're deleting */
                cpDelete = cpFirstEdit - 1;
                if (fDelPending)
                    cpDelete -= cchPending;

                if (cpDelete < cpMinCur)
                    {
                    _beep();
                    MeltHp();
                    goto DoReplace;     /* Clean up pending replace ops */
                    }
                FetchCp( docCur, cpDelete, 0, fcmChars );
                chDelete = *vpchFetch;
                cchDelete = 1;
#ifdef CRLF
                if ( (chDelete == chEol) && (cpDelete > cpMinCur) )
                    {
                    FetchCp( docCur, cpDelete - 1, 0, fcmChars );
                    if (*vpchFetch == chReturn)
                        {
                        cchDelete++;
                        cpDelete--;
                        }
                    }
#endif
#endif /* DBCS */

DeleteChars:
#ifdef DBCS
                /* They expect chDelete as well as cpDelete and cchDelete */
                FetchCp(docCur, cpDelete, 0, fcmChars);
                chDelete = *vpchFetch;
#endif

                /* Here we have cpDelete, cchDelete */
                /* Also cchPending and cpPending if fDelPending is TRUE */
                /* Also dxpPending if fScrollPending is TRUE */

                if ( CachePara( docCur, cpDelete ), vpapAbs.fGraphics)
                    {   /* Trying to del over picture, illegal case */
                    _beep();
                    MeltHp();
                    goto DoReplace;     /* Clean up pending replace ops */
                    }

                /* Insert properties are now the properties of the
                   deleted char(s) */

                FetchCp( docCur, cpDelete, 0, fcmProps );
                vchpFetch.fSpecial = FALSE;
                NewChpIns( &vchpFetch );

                /* Pending replace operation <-- union of any pending
                             replace operations with the current one */

                if (fDelPending)
                    {
                    if (cpPending >= cchDelete)
                        {
                        cchPending += cchDelete;
                        if (kc == kcDelPrev)
                            cpPending -= cchDelete;
                        }
                    else
                        Assert( FALSE );
                    }
                else
                    {
                    cpPending = cpDelete;
                    cchPending = cchDelete;
                    fDelPending = TRUE;
                    }

                /* Determine whether the screen update for the current
                   deletion can be accomplished by scrolling.
                   We can scroll if:
                      (1) we are still on the line vdlIns,
                      (2) we are not deleting eol or chsect,
                      (3) our width cache is good OR vdlIns is valid, so we can
                          validate the cache w/o redisplaying the line
                */

                mdInsUpd = mdInsUpdOneLine;
                if ((idxpDelete = (int) (cpDelete - pedl->cpMin)) < 0)
                    {
                    mdInsUpd = mdInsUpdLines;
                    }
                else if ((chDelete != chEol) && (chDelete != chSect) &&
                         (vidxpInsertCache != -1 || pedl->fValid) &&
                         (mdInsUpdPending < mdInsUpdOneLine))
                    {   /* OK to scroll -- do all pending scrolls */
                    int fDlAtEndMark;
                    int fCatchUp;

                    MeltHp();
                            /* Re-entrant heap movement */
                    fCatchUp = FImportantMsgPresent();

                     if (vidxpInsertCache == -1)
                        {   /* Width cache is invalid, update it */
                        xpInsLineMac = XpValidateInsertCache( rgdxp ); /* HM */
                        }

                    pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
                    FreezeHp();

                    /* Obtain display width of character to delete */

                    if ((vcchBlted > 0) && (kc == kcDelPrev))
                        {   /* Deleted char was blted in superins mode
                               onto a line that has not been updated */
                        vcchBlted--;
                        /* Because chDelete is always 1 byte quantity
                           by itself or the 1st byte of the DBCS character
                           it is OK. */
                        dxpCh = DxpFromCh( chDelete, FALSE );
                        }
                    else
                        {
                        int idxpT = idxpDelete + cchDelete;

#ifdef DBCS
                        /* For the following segment of code to work,
                           an element in rgdxp corresponding to the second
                           byte of a DBCS character must contain 0. */
                        int *pdxpT;
                        int cchT;

                        for (dxpCh = 0, pdxpT = &rgdxp[idxpDelete], cchT = 0;
                             cchT < cchDelete;
                             dxpCh += *pdxpT++, cchT++);
#else
                        dxpCh = rgdxp[ idxpDelete ];
#endif

                        /* Adjust the character width cache to eliminate
                           width entries for deleted chars */

                        if ((vidxpInsertCache >= 0) &&
                            (idxpDelete >= 0) &&
                            (idxpT <= pedl->dcpMac) )
                            {
                            blt( &rgdxp[ idxpT ], &rgdxp[ idxpDelete ],
                                                  ichMaxLine - idxpT );

                            if (vidxpInsertCache > idxpDelete)
                                /* Deleted behind insert point, adjust index */
                                vidxpInsertCache -= cchDelete;
                            }
                        else
                            vidxpInsertCache = -1;
                        }

                    /* pending scroll op <-- current scroll op merged
                                            with pending scroll op */
                    if (fScrollPending)
                        {
                        dxpPending += dxpCh;
                        }
                    else
                        {
                        dxpPending = dxpCh;
                        fScrollPending = fTrue;
                        }

                    /* See if we should postpone the scroll */

                    if (fCatchUp)
                        {
                        MeltHp();
                        Assert( !fGotKey );
                        fGotKey = TRUE;
                        if ((kcNext = KcInputNextKey()) == kc)
                            {   /* Next key is same as this key, process NOW */
                            continue;
                            }
                        FreezeHp();
                        }

                    /* Perform all pending scrolls */

                    fScrollPending = fFalse;
                    if (dxpPending > 0)
                        {
                        ClearInsertLine();
                        if (kc == kcDelPrev)
                            {   /* Backspace */
                            vxpCursLine = (vxpIns -= dxpPending);
                            rc.left -= dxpPending;
                            }
                        ScrollCurWw( &rc, -dxpPending, 0 );
                        DrawInsertLine();
                        xpInsLineMac -= dxpPending;
                        }

                    /* See if we can get away without updating the screen
                       (and without invalidating the insert cache) */

#define cchGetMore         4
#define dxpGetMore         ((unsigned)dxpCh << 3)

                    /* Check for running out of chars ahead of the cursor */

                    fDlAtEndMark = (pedl->cpMin + pedl->dcpMac >= cpMacCur);

                    if ( (kc != kcDelNext && fDlAtEndMark) ||
                         ((idxpDelete + cchGetMore < pedl->dcpMac) &&
                          ( (int) (xpInsLineMac - vxpIns) > dxpGetMore) ))
                        {
                        mdInsUpd = mdInsUpdNothing;
                        }

                    /* Special check to avoid two end marks: see if the
                       dl after the ins line is dirty and beyond the
                       doc's end */

                    if (fDlAtEndMark &&
                        (vdlIns < wwdCurrentDoc.dlMac - 1) &&
                        !(pedl+1)->fValid)
                        {
                        mdInsUpd = mdInsUpdLines;
                        }
                    }   /* End of "if OK to scroll" */

                /* See if we should postpone the replace */

                MeltHp();
                    /* Re-entrant Heap Movement */
                if (FImportantMsgPresent() && !fGotKey)
                    {
                    fGotKey = TRUE;
                    if ((kcNext = KcInputNextKey()) == kc)
                        {   /* Next key is same as this key, process NOW */
                        if (mdInsUpd > mdInsUpdPending)
                            {
                                /* Mark screen update as pending */
                            mdInsUpdPending = mdInsUpd;
                            vidxpInsertCache = -1;
                            }
                        continue;
                        }
                    }

                /* Handle actual replacement of chars */

DoReplace:      if (fDelPending)
                    {
                    DelChars( cpPending, cchPending );  /* HM */
                    fDelPending = fFalse;
                    }

                /* Set up screen update based on present & pending needs */

                if (mdInsUpdPending > mdInsUpd)
                    mdInsUpd = mdInsUpdPending;

                if (mdInsUpd >= mdInsUpdOneLine)
                        /* If we're updating at least a line, assume we're
                           handling all necessary pending screen update */
                    mdInsUpdPending = mdInsUpdNothing;

                    /* Adjust vdlIns's dcpMac. vdlIns is invalid anyway,
                       and this allows us to catch the case
                       in which we run out of visible characters to scroll
                       in the forward delete case. See update test after
                       the scroll above */
                (**wwdCurrentDoc.hdndl) [vdlIns].dcpMac -= cchPending;

                /* this is here to compensate for RemoveDelFtnText */

                selCur.cpFirst = selCur.cpLim = cpInsert + (typeCP)cchInsBlock;
                cpFirstEdit = cpPending;

                goto LInvalIns;    /* Skip ahead to update the screen */
/*********************************************************************
 ************ END OF BACKSPACE/FORWARD DELETE CODE *******************
 *********************************************************************/

            case kcReturn:          /* Substitute EOL for return key */
                                    /* Also add a return if CRLF is on */
                MeltHp();
#ifdef CRLF
#ifdef DBCS
                MdInsUpdInsertW( MAKEWORD(0, chReturn),
                                 MAKEWORD(0, chReturn), &rc );
#else
                MdInsUpdInsertCh( chReturn, chReturn, &rc );
#endif /* DBCS */
#endif
                FreezeHp();
                kc = chEol;
                break;
#ifdef CASHMERE   /* These key codes are omitted from MEMO */
            case kcNonReqHyphen:    /* Substitute for non-required hyphen */
                kc = chNRHFile;
                chShow = chHyphen;
                break;
            case kcNonBrkSpace:     /* Substitute for non-breaking space */
                kc = chNBSFile;
                chShow = chSpace;
                break;
            case kcNLEnter:         /* Substitute for non-para return */
                kc = chNewLine;
                break;
#endif
#ifdef PRINTMERGE
            case kcLFld:        /* Substitite for Left PRINT MERGE bracket */
                chShow = kc = chLFldFile;
                break;
            case kcRFld:        /* Substitute for Right PRINT MERGE bracket */
                chShow = kc = chRFldFile;
                break;
#endif
            case kcPageBreak:
                kc = chSect;        /* Page break (no section) */
                if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
                    {   /* Page breaks prohibited in header/footer */
BadKey:             _beep();
                    MeltHp();
                    continue;
                    }
                break;
            case kcTab:             /* Tab */
                kc = chTab;
                break;
            default:
#if WINVER >= 0x300
                if (kc == kcNonReqHyphen)    /* Substitute for non-required hyphen */
                    {
                    /* no longer a const so can't be directly in switch */
                    kc = chNRHFile;
                    chShow = chHyphen;
                    break;
                    }
#endif
                            /* AlphaMode Exit point: Found key or event
                               that we don't know how to handle */
                MeltHp();
                goto EndAlphaMode;
                }       /* end of if kc < 0 switch (kc) */
    MeltHp();

#ifdef DBCS
    if (IsDBCSLeadByte(kc)) {
        /* We are dealing with the first byte of the DBCS character. */
        /* In case of DBCS letter, wInsert is equal to wShow. */
#ifdef JAPAN //T-HIROYN Win3.1
        if( ftcNil != (newKanjiftc = GetKanjiFtc(&vchpInsert)) ) {   //(menu.c)
            changeKanjiftc = TRUE;
            goto EndAlphaMode;
        }
#endif
        if ((chDBCS2 = GetDBCSsecond()) != '\0') {
            mdInsUpd = MdInsUpdInsertW( MAKEWORD(kc, chDBCS2),
                                        MAKEWORD(kc, chDBCS2), &rc );
        }
    } else {
#ifdef JAPAN //T-HIROYN Win3.1
        if (FKana(kc)) {
            if( ftcNil != (newKanjiftc = GetKanjiFtc(&vchpInsert)) ) {
                changeKanjiftc = TRUE;
                goto EndAlphaMode;
            }
        }
#endif
        mdInsUpd = MdInsUpdInsertW( MAKEWORD(0, kc), MAKEWORD(0, chShow), &rc);
    }
#else
/* Insert character kc into the document. Show character chShow (which is
equal to kc except for cases such as non-breaking space, etc. */
    mdInsUpd = MdInsUpdInsertCh( kc, chShow, &rc );
#endif /* DBCS */

/* common for insert and backspace: invalidate line and previous line if
dependency warrants it */
/* have vdlIns from ValidateTextBlt */
LInvalIns:
    pedl = &(**wwdCurrentDoc.hdndl) [vdlIns];
    pedl->fValid = fFalse;
    wwdCurrentDoc.fDirty = fTrue;

    Assert( vdlIns >= 0 );
    if ((dlT = vdlIns) == 0)
        {   /* Editing in first line of window */
        if ( wwdCurrentDoc.fCpBad ||
             (wwdCurrentDoc.cpFirst + wwdCurrentDoc.dcpDepend > cpFirstEdit) )
            {   /* Edit affects ww's first cp; recompute it */
            CtrBackDypCtr( 0, 0 );
            (**wwdCurrentDoc.hdndl) [vdlIns].cpMin = CpMax( wwdCurrentDoc.cpMin,
                                                      wwdCurrentDoc.cpFirst );
            mdInsUpd = mdInsUpdLines;
            }
        }
    else
        {   /* If the edit affects the line prior to vdlIns, invalidate it */
        --pedl;
#ifdef DBCS
        if (!IsDBCSLeadByte(kc)) {
            chDBCS2 = kc;
            kc = '\0';
            }
#endif /* DBCS */
        if ((pedl->cpMin + pedl->dcpMac + pedl->dcpDepend > cpFirstEdit))
            {
                pedl->fValid = fFalse;
                dlT--;
            }
#ifdef  DBCS    /* was in JAPAN; KenjiK '90-11-03 */
                // deal with the character beyond end of the line.
        else
#ifdef  KOREA  /* protect from displaying picture abnormally */
            if(((pedl+1)->cpMin == cpFirstEdit && FOptAdmitCh(kc, chDBCS2))
                && !pedl->fGraphics)
#else
            if ((pedl+1)->cpMin == cpFirstEdit && FOptAdmitCh(kc, chDBCS2))
#endif
            {
                /* We do exactly the same as above, except setting
                   mdInsUpd, because the one returned by MdInsUpdInsertW()
                   does not reflect this condition. */
                pedl->fValid = fFalse;
                dlT--;
                mdInsUpd = mdInsUpdOneLine;
            }
#endif
        else
            pedl++;
        }
#ifdef ENABLE   /* We now support end-of-line cursor while inserting because of
                   typing before splats */
    if (vfInsEnd)
        {   /* forget about special end-of-line cursor */
        vfInsEnd = fFalse;
        ClearInsertLine();
        }
#endif

#ifdef  KOREA   /* 90.12.28 sangl */
{
BOOL    UpNext=FALSE;
screenup:
#endif

    switch (mdInsUpd) {

        default:
        case mdInsUpdNothing:
        case mdInsUpdNextChar:
            break;
        case mdInsUpdLines:
        case mdInsUpdOneLine:
            ClearInsertLine();
            if ( FUpdateOneDl( dlT ) )
                {   /* Next line affected */
                struct EDL *pedl;

                if ( (mdInsUpd == mdInsUpdLines) ||
                        /* Re-entrant heap movement */
                     !FImportantMsgPresent() ||
                     (pedl = &(**wwdCurrentDoc.hdndl) [dlT],
                       (selCur.cpFirst >= pedl->cpMin + pedl->dcpMac)))
                    {
                    FUpdateOneDl( dlT + 1 );
                    }
                }
#ifdef  KOREA   /* 90.12.28 sangl */
            else if (UpNext && ((dlT+1) < wwdCurrentDoc.dlMac))
                        FUpdateOneDl(dlT + 1);
#endif
            ToggleSel(selCur.cpFirst, selCur.cpLim, fTrue);
            break;

        case mdInsUpdWhole:
            ClearInsertLine();
            UpdateWw(wwCur, fFalse);
            ToggleSel(selCur.cpFirst, selCur.cpLim, fTrue);
            break;
            }   /* end switch (mdInsUpd) */
#ifdef  KOREA   /* 90.12.28 sangl */
    if (IsInterim) {
        if (mdInsUpd>=mdInsUpdOneLine) {
                ClearInsertLine();
                vxpCursLine -= dxpCh;
                DrawInsertLine();
        }

//      while ( ((kc=KcInputNextHan()) < 0xA1) || (kc>0xFE) );
        while ( (((kc=KcInputNextHan()) < 0x81) || (kc>0xFE)) && (kc != VK_MENU));  // MSCH bklee 12/22/94

        if(kc == VK_MENU) { // MSCH bklee 12/22/94
           fInterim = IsInterim = 0;
           ichInsert -= 2;
           goto nextstep;
        }

        chDBCS2 = GetDBCSsecond();
        mdInsUpd = MdInsUpdInsertW(MAKEWORD(kc, chDBCS2),
                                        MAKEWORD(kc, chDBCS2), &rc);
        if (vfSuperIns)
                goto LInvalIns; /* This is for large size, when 1st interim
                                   becomes final (ex, consonants) */
        else {
                UpNext = TRUE;  /* For italic, try to FUpdateOneDl for
                                   current line */
                goto screenup;  /* 90.12.28 sangl */
        }
    }                           /* ex: all consonants */
}               /* For screenup: 90.12.28 sangl */

nextstep : // MSCH bklee 12/22/94

/*        if(IsInterim && kc == VK_MENU) { // MSCH bklee 12/22/94
           ClearInsertLine();
           UpdateWw(wwCur, fFalse);
           goto EndAlphaMode;
        } */

        if (WasInterim)
          { MSG msg;
            int wp;

            if (PeekMessage ((LPMSG)&msg, vhWnd, WM_KEYDOWN, WM_KEYUP, PM_NOYIELD | PM_NOREMOVE) )
                        { if( msg.message==WM_KEYDOWN &&
                                ( (wp=msg.wParam)==VK_LEFT || wp==VK_UP || wp==VK_RIGHT ||
                                        wp==VK_DOWN || wp==VK_DELETE) )
                                        goto EndAlphaMode;
                        }
                WasInterim = 0;
            }
#endif  /* KOREA */
    } /* end for */

EndAlphaMode:
 Scribble( 7, 'N' );
 EndInsert();       /* Clean Up Insertion Block */
#ifdef CASHMERE
 UpdateOtherWws(fFalse);
#endif

 if (cpLimInserted != cpStart)
    {   /* We inserted some characters */
    SetUndo( uacInsert, docCur, cpStart,
                             cpLimInserted - cpStart, docNil, cpNil, cp0, 0 );
    SetUndoMenuStr(IDSTRUndoTyping);
    }
 else if (cpLimDeleted == cpStart)
        /* This AlphaMode invocation had no net effect */
    {
Abort:
    NoUndo();
    if (!fDocDirty)
            /* The doc was clean when we started, & we didn't change it, so
               it's still clean */
        (**hpdocdod) [docCur].fDirty = FALSE;
    }

 vfLastCursor = fFalse; /* Tells MoveUpDown to recalc its xp seek position */
 if (vfFocus)
    {
    /* Restore the caret blink timer */
    SetTimer( vhWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
    }
 else
    {
    ClearInsertLine();
    }

 /* Backspaces/deletes may have changed vchpSel -- update it */

 blt( &vchpInsert, &vchpSel, cwCHP );

#ifdef  KOREA
 if (WasInterim)
    { MoveLeftRight(kcLeft);
      WasInterim = 0;
      vfSeeSel = TRUE;
    }
 else
      vfSeeSel = TRUE; /* Tell Idle() to scroll the selection into view */
#else
 vfSeeSel = TRUE;   /* Tell Idle() to scroll the selection into view */
#endif

#ifdef JAPAN //T-HIROYN Win3.1
 if(changeKanjiftc) {
    goto RetryAlpha;
 }
#endif
}



/* F  B E G I N  I N S E R T */
/* Prepare for start of insertion */
/* returns true iff inserting in front of a pic */
int NEAR FBeginInsert()
{
        int fGraphics;
        typeCP cp = selCur.cpFirst;
        typeCP cpFirstPara;
        cpInsert = cp;

/* We expect the caller to have deleted the selection already */
        Assert (selCur.cpLim == selCur.cpFirst);

/* Use super-fast text insertion unless we are inserting italics */
        CachePara(docCur, cp);
        cpFirstPara = vcpFirstParaCache;
        fGraphics = vpapAbs.fGraphics;
        vfSuperIns = !vchpSel.fItalic;
        vchpSel.fSpecial = fFalse;

        NewChpIns(&vchpSel);

        ichInsert = 0;  /* Must Set this BEFORE calling Replace */

/* Insert the speeder-upper QD insert block. Note: we invalidate since there
will be a character inserted anyway, plus to make sure that the line
length gets updated ("Invalidate" refers to the choice of Replace() over
the Repl1/AdjustCp/!vfInvalid mechanism used in EndInsert, in which the
insert dl is not made invalid).  It would be possible to optimize
by NOT invalidating here (thus being able to blt the first char typed),
but one would have to account for the case in which the cpMin of the
insert dl is changed by AdjustCp, or FUpdateOneDl will get messed up.
Currently this case is covered by an implicit UpdateWw, which occurs
in AlphaMode->ValidateTextBlt->CpBeginLine because we have invalidated vdlIns. */

        Replace(docCur, cpInsert, cp0, fnInsert, fc0, (typeFC) cchInsBlock);
        cpLimInserted = cpInsert + cchInsBlock;

        vidxpInsertCache = -1;  /* Char width cache for insert line is initially empty */

            /* Blank the mouse cursor so it doesn't make the display look ugly
               or slow us down trying to keep it up to date */
        SetCursor( (HANDLE) NULL );
        return fGraphics;
}




/* E N D  I N S E R T */
void NEAR EndInsert()
{ /* Clean up from quick insert mode */
        int dcp = cchInsBlock - ichInsert;
        typeFC fc;

#ifdef CASHMERE
        UpdateOtherWws(fTrue);
#endif

        fc = FcWScratch(rgchInsert, ichInsert);
#if WINVER >= 0x300
        if (!vfSysFull)
            /* The "tape dispenser bug replication method" has shown that
               holding down a key for 64k presses will cause FcWScratch()
               to run out of scratch-file space and fail.  If we go ahead
               with the Replacement we'll corrupt the piece table, so we
               delicately avoid that problem  3/14/90..pault */
#endif
            {
            Repl1(docCur, cpInsert, (typeCP) cchInsBlock, fnScratch, fc, (typeFC) ichInsert);
            cpLimInserted -= (cchInsBlock - ichInsert);
/* adjust separately, since first ichInsert characters have not changed at all */
            vfInvalid = fFalse;
            vpedlAdjustCp = (struct EDL *)0;
            AdjustCp(docCur, cpInsert + ichInsert, (typeCP) dcp, (typeFC) 0);
/* if the line is not made invalid, the length of the line
must be maintained.
*/
            if (vpedlAdjustCp)
                vpedlAdjustCp->dcpMac -= dcp;
            }

        vfInvalid = fTrue;

        cpWall = selCur.cpLim;
        vfDidSearch = fFalse;

        if (!vfInsertOn)
            DrawInsertLine();
}





/* N E W  C H P  I N S */
NewChpIns(pchp)
struct CHP *pchp;
{ /* Make forthcoming inserted characters have the look in pchp */

 if (CchDiffer(&vchpInsert, pchp, cchCHP) != 0)
    { /* Add the run for the previous insertion; our looks differ. */
    typeFC fcMac = (**hpfnfcb)[fnScratch].fcMac;

    if (fcMac != fcMacChpIns)
        {
        AddRunScratch(&vfkpdCharIns, &vchpInsert, &vchpNormal, cchCHP, fcMac);
        fcMacChpIns = fcMac;
        }
    blt(pchp, &vchpInsert, cwCHP);
    }
}



#ifdef DBCS
int NEAR MdInsUpdInsertW(wInsert, wShow, prcScroll)
    WORD    wInsert;    /* Char or 2 char's to insert into document */
    WORD    wShow;      /* Char or 2 char's to be shown on screen (SuperIns mode only) */
    RECT    *prcScroll; /* Rect to scroll for SuperIns */
#else
int NEAR MdInsUpdInsertCh( chInsert, chShow, prcScroll )
CHAR chInsert;     /* Char to insert into document */
CHAR chShow;       /* Char to show on screen (SuperIns mode only) */
RECT *prcScroll;   /* Rect to scroll for SuperIns */
#endif /* DBCS */
{       /* Insert character ch into the document. Show char chShow. */
        /* Flush the insert buffer to the scratch file if it fills up */
        /* Return:  mdInsUpdWhole     - Must do an UpdateWw
                    mdInsUpdNextChar  - Update not mandatory, char waiting
                    mdInsUpdLines     - Must update vdlIns and maybe following
                    mdInsUpdNothing   - No update needed & no char waiting
                    mdInsUpdOneLine   - Update vdlIns; only update following
                                        if there's no char waiting
         */
extern int vfInsFontTooTall;
void NEAR FlushInsert();
int mdInsUpd;

#ifndef KOREA                           /* has been defined globally */
int dxpCh;
#endif

int dl;

#ifdef DBCS
CHAR chInsert;
CHAR chShow;
BOOL fDBCSChar;
int  ichInsertSave;
int  dcchBlted;
#endif /* DBCS */

#ifdef  KOREA
        if (IsInterim)
                ichInsert -= 2;
#endif

#ifdef DIAG
{
char rgch[200];
wsprintf(rgch, "MdInsUpdInsertCh: ichInsert %d cpInsert %lu\n\r ",ichInsert, cpInsert);
CommSz(rgch);
}
#endif

 Assert(ichInsert <= cchInsBlock);
 if (ichInsert >= cchInsBlock)  /* Should never be >, but... */
    FlushInsert();

#ifdef DBCS
 ichInsertSave = ichInsert;
 if (HIBYTE(wInsert) != '\0') {
    fDBCSChar = TRUE;

#ifdef  KOREA   /* 90.12.28 sangl */
//  if (LOBYTE(HIWORD(vmsgLast.lParam)) == 0xF0)
    if (fInterim || LOBYTE(HIWORD(vmsgLast.lParam)) == 0xF0) // MSCH bklee 12/22/94
      {
        if (IsInterim == 0) dxpCh = DxpFromCh( wInsert, FALSE );  // fix bug #5382
        IsInterim ++;
      }
    else
     {
       WasInterim = IsInterim;
       IsInterim = 0;
     }
#endif

    if (ichInsert + 1 >= cchInsBlock) { /* Not enough room in the insertion block */
        FlushInsert();
#ifdef  KOREA
        ichInsertSave = ichInsert;       /* After flush, need to init ichInsertSave */
#endif
        }
    rgchInsert[ichInsert++] = chInsert = HIBYTE(wInsert);
    chShow = HIBYTE(wShow);
    }
 else {
    fDBCSChar = FALSE;
    chInsert = LOBYTE(wInsert);
    chShow = LOBYTE(wShow);
    }
 rgchInsert [ ichInsert++ ] = LOBYTE(wInsert);
#else
 rgchInsert [ ichInsert++ ] = chInsert;
#endif /* DBCS */

 /* NOTE: we only affect the para cache if the char inserted is Eol/chSect.
    We explicitly invalidate in this case below; otherwise, no invalidation
    is necessary */

 /* The following test works because chEol and chSect is not in
    the DBCS range. */

 if ( (chInsert == chEol) || (chInsert == chSect) )
    {          /* Add a paragraph run to the scratch file */
    struct PAP papT;

        /* Must invalidate the caches */
    vdocParaCache = vfli.doc = docNil;

#ifdef DBCS
    Assert(!fDBCSChar); /* Of course, you can't be too careful */
#endif /* DBCS */
        /* Get props for new para mark */
        /* NOTE: Under the new world, CachePara does not expect to ever */
        /* see an Eol in the insertion piece */
    ichInsert--;
    CachePara( docCur, cpInsert + cchInsBlock );
    papT = vpapAbs;
    ichInsert++;

#ifdef DEBUG
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {
        Assert( papT.rhc != 0 );
        }
#endif

        /* Write insert buf out to the scratch file */
    EndInsert();

        /* Add run for new para properties to the scratch file */
    AddRunScratch( &vfkpdParaIns,
                   &papT,
                   vppapNormal,
                   ((CchDiffer( &papT, &vpapPrevIns, cchPAP ) == 0) &&
                    (vfkpdParaIns.brun != 0)) ? -cchPAP : cchPAP,
                   fcMacPapIns = (**hpfnfcb)[fnScratch].fcMac );
    blt( &papT, &vpapPrevIns, cwPAP );

        /* Add a new insertion piece to the doc and we're ready to go again */
    InvalidateCaches( docCur );

    FBeginInsert();
    mdInsUpd = mdInsUpdWhole;   /* Must update the whole screen */
    }
 else if ( vfSuperIns && (chInsert != chNewLine) && (chInsert != chTab) &&
           (chInsert != chNRHFile ) && (chInsert != chReturn) &&
           !vfInsFontTooTall )
    {  /* We can do a superfast insert of this char */
    ClearInsertLine();

#ifdef DBCS
    /* Because chShow contains the first byte of a DBCS character,
       even when it is a DBCS character, the following call
       to DxpFromCh() is OK. */

#ifdef  KOREA
    if (fDBCSChar)
        dxpCh = DxpFromCh(wShow, FALSE);
    else
        dxpCh = DxpFromCh(chShow, FALSE);
#else
    dxpCh = DxpFromCh( chShow, FALSE );
#endif

    if( dxpCh > 0 ){
// Maybe it's no need so marked off, by chienho
#if defined(TAIWAN) || defined(KOREA) || defined(PRC)
//      dxpCh *= IsDBCSLeadByte(chShow) ? 2 : 1;
#else
        dxpCh *= IsDBCSLeadByte(chShow) ? 2 : 1;
#endif
        ScrollCurWw( prcScroll, dxpCh, 0 );
    }

    TextOut( wwdCurrentDoc.hDC,
             vxpIns + 1,
             vypBaseIns - vfmiScreen.dypBaseline,
             (LPSTR) &rgchInsert[ichInsertSave],
             dcchBlted = fDBCSChar ? 2 : 1 );
#ifdef  KOREA       /* 90.12.28  sangl */
    if ( IsInterim )
    {   unsigned kc;
    int dxpdiff;
    SetBkMode( wwdCurrentDoc.hDC, 2);   /* Set to OPAQUR mode */
    do { DrawInsertLine();
 //        while ( ((kc=KcInputNextHan()) < 0xA1) || (kc>0xFE) );
         while ( (((kc=KcInputNextHan()) < 0x81) || (kc>0xFE)) && (kc != VK_MENU));  // MSCH bklee 12/22/94
         if(kc == VK_MENU) return mdInsUpdLines;
         rgchInsert[ichInsertSave] = kc;
         rgchInsert[ichInsertSave+1] = GetDBCSsecond();
         ClearInsertLine();
         wShow = (kc<<8) + rgchInsert[ichInsertSave+1];
         prcScroll->left += dxpCh;      /* New left start of rect */
         dxpdiff = -dxpCh;      /* Save last dxpCh to go back */
         dxpCh = DxpFromCh(wShow, FALSE);  /* Get dxpCh of curr interim */
         dxpdiff += dxpCh;
         if (dxpdiff < 0)
                prcScroll->left += dxpdiff;
         ScrollCurWw(prcScroll, dxpdiff, 0);
         TextOut( wwdCurrentDoc.hDC,
                  vxpIns + 1,
                  vypBaseIns - vfmiScreen.dypBaseline,
                  (LPSTR)&rgchInsert[ichInsertSave], 2);
//      } while (LOBYTE(HIWORD(vmsgLast.lParam))==0xF0); /* End of If Hangeul */
        } while (fInterim || LOBYTE(HIWORD(vmsgLast.lParam))==0xF0); // MSCH bklee 12/22/94
        WasInterim = 1;
        IsInterim = 0;
        SetBkMode(wwdCurrentDoc.hDC, 1); /* Reset to TRANS mode */
      }
#endif      /* KOREA */

    vcchBlted += dcchBlted;
#else
    /* Because chShow contains the first byte of a DBCS character,
       even when it is a DBCS character, the following call
       to DxpFromCh() is OK. */

    if ((dxpCh = DxpFromCh( chShow, FALSE )) > 0)
        ScrollCurWw( prcScroll, dxpCh, 0 );

    TextOut( wwdCurrentDoc.hDC,
             vxpIns + 1,
             vypBaseIns - vfmiScreen.dypBaseline,
             (LPSTR) &chShow,
             1 );
    vcchBlted++;
#endif /* DBCS */

    vxpCursLine = (vxpIns += dxpCh);
    DrawInsertLine();

    /* Decide whether we have affected the next dl with this insertion */

    if ( vxpIns >= vxpMacIns )
        mdInsUpd = mdInsUpdLines;
    else if (!FImportantMsgPresent())
        {   /* No chars waiting; check for optional line update (word wrap) */
        if ((dl = vdlIns) < wwdCurrentDoc.dlMac - 1)
            {
            vfli.doc = docNil;

            FormatInsLine(); /* Update vfli for vdlIns */

            mdInsUpd = (vfli.cpMac != (**wwdCurrentDoc.hdndl) [dl + 1].cpMin) ?
              (FImportantMsgPresent() ? mdInsUpdNextChar : mdInsUpdOneLine) :
              mdInsUpdNothing;
            }
        }
    else
            /* Don't update; pay attention to the next character */
        mdInsUpd = mdInsUpdNextChar;
    }
 else if (vfSuperIns)
    {   /* In SuperInsMode but have a char we can't handle in SuperIns mode */
    mdInsUpd = (vfInsFontTooTall) ? mdInsUpdWhole : mdInsUpdLines;
    }
 else
    {   /* Non-superfast insertion; update line if we have to */
    vfli.doc = docNil;
    FormatInsLine(); /* Update vfli for vdlIns */

    /* Do the update only if:  (1) the selection is no longer on
       the current line OR  (2) No char is waiting */
#ifdef KOREA
    mdInsUpd = mdInsUpdLines;
#else
    mdInsUpd = ( (selCur.cpFirst < vfli.cpMin) ||
                 (selCur.cpFirst >= vfli.cpMac) ||
                 !FImportantMsgPresent() )  ? mdInsUpdLines : mdInsUpdNextChar;
#endif
    }

 Scribble( 10, mdInsUpd + '0' );
 return mdInsUpd;
}




void NEAR FlushInsert()
{       /* Flush the insert buffer to the scratch file. Insert a piece (ahead of
           the QD insertion piece) that points to the characters flushed to the
           scratch file.  Adjust CP's for the addition of the new scratch file
           piece. */

#ifdef DBCS
 /* The DBCS version of FlushInsert() is almost identical to the regular
    version, except it allows to insert an insertion block with one byte
    less than full.  This allows us to assume that the piece boundary aligns
    with the DBCS boundary. */
 typeFC fc = FcWScratch( rgchInsert, ichInsert );
 int    dcpDel;

#if WINVER >= 0x300
 if (!vfSysFull)
            /* The "tape dispenser bug replication method" has shown that
               holding down a key for 64k presses will cause FcWScratch()
               to run out of scratch-file space and fail.  If we go ahead
               with the Replacement we'll corrupt the piece table, so we
               delicately avoid that problem  3/14/90..pault */
#endif
  {
  Assert( cchInsBlock - ichInsert <= 1);
  Repl1( docCur, cpInsert, (typeCP) 0, fnScratch, fc, (typeFC) ichInsert );

  cpLimInserted += ichInsert;

  vfInvalid = fFalse;
  vpedlAdjustCp = (struct EDL *) 0;
  AdjustCp( docCur, cpInsert += ichInsert, (typeCP) (dcpDel = cchInsBlock - ichInsert),
            (typeCP) cchInsBlock );
  if (vpedlAdjustCp)
      vpedlAdjustCp->dcpMac += (cchInsBlock - dcpDel);
  }
#else
 typeFC fc = FcWScratch( rgchInsert, cchInsBlock );

#if WINVER >= 0x300
 if (!vfSysFull)
            /* The "tape dispenser bug replication method" has shown that
               holding down a key for 64k presses will cause FcWScratch()
               to run out of scratch-file space and fail.  If we go ahead
               with the Replacement we'll corrupt the piece table, so we
               delicately avoid that problem  3/14/90..pault */
#endif
  {
  Assert( ichInsert == cchInsBlock );
  Repl1( docCur, cpInsert, (typeCP) 0, fnScratch, fc, (typeFC) cchInsBlock );

  cpLimInserted += cchInsBlock;

  vfInvalid = fFalse;
  vpedlAdjustCp = (struct EDL *) 0;
  AdjustCp( docCur, cpInsert += cchInsBlock, (typeCP) 0, (typeFC) cchInsBlock );
  if (vpedlAdjustCp)
      vpedlAdjustCp->dcpMac += cchInsBlock;
  }
#endif /* DBCS */

 vfInvalid = fTrue;
 ichInsert = 0;
}




int NEAR XpValidateInsertCache( rgdxp )
int *rgdxp;
{    /* Validate the contents of the insert width cache, consisting of:
            (parm) rgdxp: table of widths of chars on the current insert
                          line (vdlIns) as last DisplayFli'd
            (global) vidxpInsertCache: -1 if invalid, index of current
                                       insert point otherwise
            (return value) xpMac: Mac pixel used on the insert line
    */
 int xpMac;

 Assert( vidxpInsertCache == -1 );

 vfli.doc = docNil;  /* Force FormatLine to act */

    /* Assert that FormatLine results will match screen contents */
 Assert( (**wwdCurrentDoc.hdndl)[vdlIns].fValid );

 /* Build vfli from insert line, extract cache info */

 FormatInsLine();
 blt( vfli.rgdxp, rgdxp, ichMaxLine );
 xpMac = umin( vfli.xpRight + xpSelBar, wwdCurrentDoc.xpMac );
 Assert( vcchBlted == 0);
 vidxpInsertCache = (int) (cpInsert + ichInsert - vfli.cpMin);

 Assert( vidxpInsertCache >= 0 && vidxpInsertCache < vfli.cpMac - vfli.cpMin);
 return xpMac;
}



void NEAR DelChars( cp, cch )
typeCP cp;
int    cch;
{   /* Delete cch characters at cp in docCur.

       We expect the request to be as results from repeated backspaces
       or forward deletes (not both); that is, the whole range extends
       backwards from (cpInsert + ichInsert) (non-inclusive) or forward from
       (cpInsert + cchInsBlock) (inclusive).

       We do not mark the vfli cache invalid, for speed.
       The Fast insert stuff will mark it invalid when it needs to.
     */

 int cchNotInQD;
 typeCP cpUndoAdd;
 int cchNewDel=0;

 Assert( (cp == cpInsert + cchInsBlock) ||      /* Fwd Deletes */
         (cp + cch == cpInsert + ichInsert));    /* Backsp */

 cchNotInQD = cch - ichInsert;
 if (cp + cchNotInQD == cpInsert)
    {   /* BACKSPACE */

    if (cchNotInQD <= 0)
        {   /* All deleted chars were in the QD buffer */
        ichInsert -= cch;

        /* Do not mark the para cache invalid -- we have not affected
           the para cache world, since there are never chSect/chEol in
           the QD buffer, and we have not adjusted cp's */
        return;
        }
    else
        {   /* Backspacing before the QD buffer */
        ichInsert = 0;

        if (cpStart > cp)
            {
            cpUndoAdd = cp0;
            cchNewDel = cpStart - cp;

            vuab.cp = cpStart = cp;

            /* cpStart has moved, and the count of cp's inserted has not
               changed -- we must adjust cpLimInserted */

            cpLimInserted -= cchNewDel;
            }

        cpInsert -= cchNotInQD;
        }
    }   /* End of if backspacing */
 else
    {   /* FORWARD DELETE */
    typeCP dcpFrontier = (cp + cch - cpLimInserted);

    if (dcpFrontier > 0)
        {
        cpUndoAdd = CpMacText( docUndo );
        cchNewDel = (int) dcpFrontier;
        cpLimDeleted += dcpFrontier;
        }
    cchNotInQD = cch;
    }

 /* Now we have: cchNewDel - chars deleted beyond previous limits
                             (cpStart to cpLimDeleted)
                 cpUndoAdd - where to add deleted chars to Undo doc
                             (only set if cchNewDel > 0)
                 cchNotInQD - chars deleted outside QD buffer */

 if (cchNotInQD > cchNewDel)
        /* Deleting chars previously inserted during this AlphaMode session */
    cpLimInserted -= (cchNotInQD - cchNewDel);

    /* Add the newly deleted stuff to the UNDO document.
       We find the { fn, fc } of the deleted char(s)
       so we can take advantage of Replace's optimizations
       wrt combining adjacent pieces (if the deletion is all one piece).
    */
 if (cchNewDel > 0)
    {
    struct PCTB **hpctb=(**hpdocdod)[ docCur ].hpctb;
    int ipcd=IpcdFromCp( *hpctb, cp );
    struct PCD *ppcd=&(*hpctb)->rgpcd [ipcd];
    int fn=ppcd->fn;
    typeFC fc=ppcd->fc;

    Assert( ppcd->fn != fnNil && (ppcd+1)->cpMin >= cp );

    if (bPRMNIL(ppcd->prm) && (cchNewDel <= (ppcd+1)->cpMin - cp))
        {   /* Deletion is all within one piece */
        Replace( docUndo, cpUndoAdd, cp0, fn, fc + (cp - ppcd->cpMin),
                 (typeFC) cchNewDel );
        }
    else
        {
        ReplaceCps( docUndo, cpUndoAdd, cp0, docCur, cp,
                    (typeCP) cchNewDel );
        }

    switch ( vuab.uac ) {
        default:
            Assert( FALSE );
            break;
        case uacDelNS:
            vuab.dcp += cchNewDel;
            break;
        case uacReplNS:
            vuab.dcp2 += cchNewDel;
            break;
        }
    }

 /* Remove deleted chars from the doc */
 Replace( docCur, cp, (typeCP) cchNotInQD, fnNil, fc0, fc0 );
}




FUpdateOneDl( dl )
int dl;
{   /* Update the display line dl.  Mark dl+1 as invalid if, in the process
       formatting dl, we discover that there is not a clean cp or
       yp transition between the two lines (i.e. the ending yp or cp of dl
       do not match the starting ones of dl+1).
       Return TRUE iff we marked dl+1 invalid; FALSE otherwise
       Starting cp & yp of dl+1 are adjusted as necessary */

 register struct EDL *pedl=&(**(wwdCurrentDoc.hdndl))[dl];
 int fUpdate=fFalse;
 RECT rc;

 vfli.doc = docNil;
 FormatLine(docCur, pedl->cpMin, 0, wwdCurrentDoc.cpMac, flmSandMode);

 pedl = &(**wwdCurrentDoc.hdndl) [dl + 1];

/* next line is invalid if it exists (<dlMac) and
        not following in cp space or not following in yp space
*/

 if ( (dl + 1 < wwdCurrentDoc.dlMac) &&
      (!pedl->fValid || (pedl->cpMin != vfli.cpMac) ||
                        (pedl->yp - pedl->dyp != (pedl-1)->yp)))
    {
    pedl->fValid = fFalse;
    pedl->cpMin = vfli.cpMac;
    pedl->yp = (pedl-1)->yp + pedl->dyp;
    fUpdate = fTrue;
    }
 else
    {
/* state is clean. Do not clear window dirty because more than one line may
have been made invalid earlier */
        /* Tell Windows we made this region valid */

#if WINVER >= 0x300
 /* Only actually USE pedl if it's be valid!  ..pault 2/21/90 */
    if (dl + 1 < wwdCurrentDoc.dlMac)
#endif
      {
      SetRect( (LPRECT) &rc, 0, wwdCurrentDoc.xpMac,
                              pedl->yp - pedl->dyp, pedl->yp );
      ValidateRect( wwdCurrentDoc.wwptr, (LPRECT) &rc );
      }

    (--pedl)->fValid = fTrue;
    }
 DisplayFli(wwCur, dl, fFalse);
 return fUpdate;
}



void NEAR FormatInsLine()
{   /* Format line containing insertion point, using vdlIns as a basis
       Assume vdlIns's cpMin has not changed */

 FormatLine( docCur, (**wwdCurrentDoc.hdndl) [vdlIns].cpMin, 0,
             wwdCurrentDoc.cpMac, flmSandMode );

     /* Compensate for LoadFont calls in FormatLine so we don't have to set
        vfTextBltValid to FALSE */
 LoadFont( docCur, &vchpInsert, mdFontChk );
}


#ifdef DBCS
/* Get the second byte of a DBCS character using a busy loop. */
CHAR near GetDBCSsecond()
{
    int        kc;
    CHAR       chDBCS2;
    BOOL       fGotKey;

    extern MSG vmsgLast;

    fGotKey = FALSE;
    do {
        if ( FImportantMsgPresent() ) {
            fGotKey = TRUE;
            if ((kc=KcAlphaKeyMessage( &vmsgLast )) != kcNil) {
                chDBCS2 = kc;
                if (vmsgLast.message == WM_KEYDOWN) {
                    switch (kc) {
                        default:
                            GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
                            break;
                        case kcAlphaVirtual:
                            /* This means we can't anticipate the key's meaning
                               before translation */
                            chDBCS2 = '\0';
                            if (!FNonAlphaKeyMessage(&vmsgLast, FALSE)) {
                                GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 );
                                TranslateMessage( &vmsgLast );
                                }
                            break;
                        }
                    }
                else {
                    if (kc < 0) {
                        chDBCS2 = '\0';
                        }
                    GetMessage( (LPMSG) &vmsgLast, NULL, 0, 0 );
                    }
                }
            else {
                chDBCS2 = '\0';
                }
            }
    } while (!fGotKey);

    /* As long as we go through the DBCS conversion window, this
       should not happen. */
    Assert(chDBCS2 != '\0');
    return chDBCS2;
}
#endif /* DBCS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\initwin.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/



#define NOVIRTUALKEYCODES
#define NOKEYSTATE
#define NOCREATESTRUCT
#define NOICON
//#define NOATOM
//#define NOMEMMGR
#define NOPEN
#define NOREGION
#define NODRAWTEXT
#define NOMB
#define NOWINOFFSETS
#define NOOPENFILE
#define NOMETAFILE
#define NOWH
//#define NOCLIPBOARD
#define NOSYSCOMMANDS
#define NOWINMESSAGES
#define NOSOUND
#define NOCOMM
#include <windows.h>

#include "mw.h"


#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "menudefs.h"
#include "str.h"
#include "fontdefs.h"
#include "printdef.h"
#if defined(OLE)
#include "obj.h"
#endif
#include <commdlg.h>

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

    /* static string arrays found in mglobals.c */
extern CHAR         szMw_acctb[];
extern CHAR         szNullPort[];
extern CHAR         szNone[15];
extern CHAR         szMwlores[];
extern CHAR         szMwhires[];
extern CHAR         szMw_icon[];
extern CHAR         szMw_menu[];
extern CHAR         szScrollBar[];
extern CHAR         szIntl[];
extern CHAR         szsDecimal[];
extern CHAR         szsDecimalDefault[];

#ifdef INTL /* International version */
extern CHAR         sziCountry[];
extern CHAR         sziCountryDefault[5];
#endif  /* International version */

extern CHAR         vchDecimal;  /* decimal point character */
extern int          viDigits;    /* digits after decimal point */
extern BOOL         vbLZero;     /* leading zero before decimal */

extern struct WWD   rgwwd[];
extern CHAR         stBuf[256];
extern int vifceMac;
extern union FCID vfcidScreen;
extern union FCID vfcidPrint;
extern struct FCE rgfce[ifceMax];
extern struct FCE *vpfceMru;
extern HCURSOR  vhcHourGlass;

#ifdef PENWIN   // for PenWindows (5/21/91) patlam
#include <penwin.h>

extern HCURSOR  vhcPen;

extern int (FAR PASCAL *lpfnProcessWriting)(HWND, LPRC);
extern VOID (FAR PASCAL *lpfnPostVirtualKeyEvent)(WORD, BOOL);
extern VOID (FAR PASCAL *lpfnTPtoDP)(LPPOINT, int);
extern BOOL (FAR PASCAL *lpfnCorrectWriting)(HWND, LPSTR, int, LPRC, DWORD, DWORD);
extern BOOL (FAR PASCAL *lpfnSymbolToCharacter)(LPSYV, int, LPSTR, LPINT);
#endif

extern WORD fPrintOnly;
extern HCURSOR  vhcIBeam;
extern HCURSOR  vhcArrow;
extern HCURSOR  vhcBarCur;
extern HANDLE   hMmwModInstance;
extern HWND     hParentWw;
extern HWND     vhWndSizeBox;
extern HWND     vhWndPageInfo;
extern HWND     vhWnd;
extern HMENU    vhMenu;
extern HANDLE   vhAccel;
extern long     rgbBkgrnd;
extern long     rgbText;
extern HBRUSH   hbrBkgrnd;
extern HDC      vhMDC;
extern int      vfInitializing;
extern int      vfMouseExist;
extern int      ferror;
extern CHAR     szWindows[];
extern CHAR     szNul[];
extern CHAR     szWriteProduct[];
extern CHAR     szBackup[];
extern int      vfBackupSave;

#if defined(JAPAN) || defined(KOREA)  //Win3.1J
extern CHAR     szWordWrap[];
extern int      vfWordWrap; /*t-Yoshio WordWrap flag*/
#endif
//IME3.1J

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
extern CHAR     szImeHidden[];
extern int      vfImeHidden; /*T-HIROYN ImeHidden Mode flag*/
#endif

#ifdef JAPAN    //01/21/93
extern HANDLE   hszNoMemorySel;
#endif
extern HANDLE   hszNoMemory;
extern HANDLE   hszDirtyDoc;
extern HANDLE   hszCantPrint;
extern HANDLE   hszPRFAIL;
extern HANDLE   hszCantRunM;
extern HANDLE   hszCantRunF;
extern HANDLE   hszWinFailure;
extern HDC      vhDCPrinter;

int vkMinus;

extern int utCur;

    /* Regrettably, we are not permitted to signal in WM_CREATE message
       handlers that we have failed -- instead, we resort to
       ugly global communication via this variable */
#ifdef WIN30
    /* Note that we now CAN return a -1L from MmwCreate and cause the
       CreateWindow to fail, but changing this now wouldn't accomplish us
       very much (besides saving a bunch of checks of a global) ..pault */
#endif
STATIC int fMessageInzFailed = FALSE;

STATIC BOOL NEAR FRegisterWnd( HANDLE );
#ifdef INEFFLOCKDOWN
STATIC int NEAR FInitFarprocs( HANDLE );
#endif
STATIC HANDLE NEAR HszCreateIdpmt( int );

BOOL InitIntlStrings( HANDLE );


#define cchCmdLineMax   64      /* Longest command line accepted */



/*               FInitWinInfo                           */
/* Main MS-WINDOWS initialization entry point for write */
/* Actions:
        Loads all mouse cursors & sets global handles to cursors (vhc's)
        Loads the menu key accelerator table vhAccel
        Registers all of WRITE's myriad window classes
        Sets up global hMmwModInstance, our instance handle
        Puts "DOC = WRITE.EXE ^.DOC" into WIN.INI if not already there
        Generates thunks for all exported procedures
        Creates a parent window for this instance (the menu window, NOT
          the document window)
        Sets the right colors for the window
*/
/* Returns FALSE if the initailization failed, TRUE if it succeeded */

int FInitWinInfo( hInstance, hPrevInstance, lpszCmdLine, cmdShow  )
HANDLE hInstance, hPrevInstance;
LPSTR  lpszCmdLine;
int    cmdShow;
{
 extern VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL);
 extern CHAR szParentClass[];
 extern int vfDiskError, vfDiskFull, vfSysFull;
 extern PRINTDLG PD;

 CHAR rgchCmdLine[ cchCmdLineMax ];
 CHAR bufT[3];  /* to hold decimal point string */
 CHAR *pch = bufT;
 BOOL fRetVal;

#if defined(OLE)
    /*
        The only place I'm worrying about this is when we open a file which
        contains objects.  Probably thats not enough, but its something.
        Alas for users of real mode.
    */
    fOleEnabled = GetWinFlags() & WF_PMODE; /* Are we in real mode today? */
#endif

    /* Save the command line in a DS variable so we can pass a NEAR pointer */
    bltszx( lpszCmdLine, (LPSTR)rgchCmdLine );

    /* First thing, put up the hourglass cursor. */
    if ((vhcHourGlass = LoadCursor( NULL, IDC_WAIT )) == NULL)
        {
        /* We don't even have enough memory to tell the user we don't have
        enough memory. */
        return (FALSE);
        }

    vfMouseExist = GetSystemMetrics(SM_MOUSEPRESENT);

    /* Next, save the out of memory messages. */
    hMmwModInstance = hInstance;
    if ((hszCantRunM = HszCreateIdpmt( IDPMTCantRunM )) == NULL ||
      (hszCantRunF = HszCreateIdpmt( IDPMTCantRunF )) == NULL ||
      (hszWinFailure = HszCreateIdpmt( IDPMTWinFailure )) == NULL ||
#ifdef JAPAN	//01/21/93
      (hszNoMemorySel = HszCreateIdpmt( IDPMTNoMemorySel )) == NULL ||
#endif
      (hszNoMemory = HszCreateIdpmt( IDPMTNoMemory )) == NULL ||
      (hszDirtyDoc  = HszCreateIdpmt( IDPMTDirtyDoc )) == NULL ||
      (hszCantPrint = HszCreateIdpmt( IDPMTCantPrint )) == NULL ||
      (hszPRFAIL = HszCreateIdpmt( IDPMTPRFAIL )) == NULL)
        {
        goto InzFailed;
        }

#if defined(INTL) && defined(WIN30)
/*  Initializaton of multi/intl strings.  This is done before anything
    else because many are defaults used for GetProfileString, etc. */

    if (!FInitIntlStrings(hInstance))
        goto InzFailed;
#endif

    /* Set up the standard cursors. */
    if ( ((vhcIBeam = LoadCursor( NULL, IDC_IBEAM )) == NULL) ||
         ((vhcArrow = LoadCursor( NULL, IDC_ARROW )) == NULL))
        goto InzFailed;

#ifdef PENWIN   // for PenWindows (5/21/91) patlam
    vhcPen =vhcIBeam;
#endif


    /* Set up the menu accelerator key table. */
    if ((vhAccel = LoadAccelerators( hMmwModInstance, (LPSTR)szMw_acctb )) ==
      NULL)
        goto InzFailed;

    /* Get whether to make backups during save from the user profile. */
    vfBackupSave = GetProfileInt((LPSTR)szWriteProduct, (LPSTR)szBackup, 0) == 0
      ? FALSE : TRUE;

    /* Get the name of the null port from the user profile. */

    GetProfileString((LPSTR)szWindows, (LPSTR)szNullPort, (LPSTR)szNone,
      (LPSTR)szNul, cchMaxIDSTR);

#ifdef INTL /* International version */
    /* Get the country code. If US or UK, set utCur to be inches, else set
       to cm */
    {
#if 0
      /* codes from MSDOS country codes */
#define USA (1)
#define UK (44)

    int iCountry;

    GetProfileString((LPSTR)szIntl, (LPSTR)sziCountry, (LPSTR)sziCountryDefault,
      (LPSTR)bufT, 4);
    iCountry = WFromSzNumber (&pch);
    if ((iCountry ==  USA) || (iCountry == UK))
        utCur = utInch;
#else
    if (GetProfileInt((LPSTR)szIntl, (LPSTR)"iMeasure", 1) == 1)
        utCur = utInch;
    else
        utCur = utCm;
#endif
    }

#endif  /* International version */

    /* Get the decimal point character from the user profile. */
    GetProfileString((LPSTR)szIntl, (LPSTR)szsDecimal, (LPSTR)szsDecimalDefault,
      (LPSTR)bufT, 2);
    vchDecimal = *bufT;

    viDigits = GetProfileInt((LPSTR)szIntl, (LPSTR)"iDigits", 2);
    vbLZero  = GetProfileInt((LPSTR)szIntl, (LPSTR)"iLZero", 0);

    MergeInit();   /* get message merge characters from resource file */
#if defined(JAPAN) || defined(KOREA)    /*t-Yoshio*/
/*
 *  Get WordWrap switch
 *      case 1 WordWrap ON(default)
 *      case 0 WordWrap OFF
 */
    vfWordWrap = GetProfileInt((LPSTR)szWriteProduct, (LPSTR)szWordWrap, 1);
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
/*
 *  Get ImeHidden switch
 *      case 1 Ime Conversion Window MCW_HIDDEN SET
 *      case 0 Ime Conversion Window MCW_WINDOW SET (default)
 */

    if (3 == (vfImeHidden = 
                GetProfileInt((LPSTR)szWriteProduct, (LPSTR)szImeHidden, 3))) {
// insert machine power get routine someday
        vfImeHidden = 0;
    }

    GetImeHiddenTextColors();

#endif

#ifdef FONT_KLUDGE
    AddFontResource( (LPSTR)"helv.fon" );
#endif /* FONT_KLUDGE */

    if (!hPrevInstance)
        {
        /* First time loaded; register the Write Windows. */
        if (!FRegisterWnd( hMmwModInstance ))
            {
            return ( FALSE );
            }

        /* Get the Memo specific cursor. */
        if ((vhcBarCur = LoadCursor( hMmwModInstance,
                          (GetSystemMetrics( SM_CXICON ) < 32) ||
                          (GetSystemMetrics( SM_CYICON ) < 32) ?
                              (LPSTR) szMwlores : (LPSTR) szMwhires )) == NULL)
            goto InzFailed;
        }
    else /* not first time loaded; get data from previous instance */
        {
        if (!GetInstanceData( hPrevInstance,
                              (PSTR)&vhcBarCur, sizeof( vhcBarCur ) ))
            goto InzFailed;
        }

#ifdef INEFFLOCKDOWN
    /* Now initialize the pointers to far procedures (thunks). */
    if (!FInitFarprocs( hMmwModInstance ))
        goto InzFailed;
#endif

    /* Create our parent (tiled) window */
    /* CreateWindow call generates a call to MmwCreate via message */
    {
        int cxFrame  = GetSystemMetrics( SM_CXFRAME );
        int cxBorder = GetSystemMetrics( SM_CXBORDER );
        int cyBorder = GetSystemMetrics( SM_CYBORDER );
        int x = ((cxFrame + 7) & 0xfff8) - cxFrame;

    if (  CreateWindow(
                      (LPSTR)szParentClass,
                      (LPSTR)rgchCmdLine, /* don't pass lpszCmdLine; it will change! ..pault 2/22/90 */
                      WS_TILEDWINDOW,
#ifdef WIN30
/* This makes for nicer cascading of Write.exe invocations ..pault */
                      CW_USEDEFAULT,     /* x */
                      CW_USEDEFAULT,            /* y */
                      CW_USEDEFAULT,            /* dx */
                      CW_USEDEFAULT,            /* dy */
#else
                      x,                        /* x */
                      x * cyBorder / cxBorder,  /* y */
                      CW_USEDEFAULT,            /* dx */
                      NULL,                     /* dy */
#endif
                      (HWND)NULL,               /* no parent */
                      (HMENU)NULL,              /* use class menu */
                      (HANDLE)hInstance,        /* handle to window instance */
                      (LPSTR)NULL               /* no params to pass on */
                      ) == NULL)
            /* Could not create window */
        goto InzFailed;
    }
    if (fMessageInzFailed)
            /* The create itself did not fail, but something in MmwCreate did
               and it signals us via this global */
        goto InzFailed;

    Assert( hParentWw != NULL );    /* MmwCreate should have assured this */

#if WINVER >= 0x300
    vkMinus = VkKeyScan('-');
#endif

    /* Record the window foreground and background colors. */

#ifdef DEBUG
    {
    int f =
#endif

    FSetWindowColors();

#ifdef DEBUG
    Assert (f);
    }
#endif

    /* Select the background brush into the parent window. */

    SelectObject( GetDC( hParentWw ), hbrBkgrnd );

    /* Commdlg stuff (3.7.91) D. Kent */
    if (InitCommDlg(0))
        goto InzFailed;

#ifdef PENWIN
    if (lpfnRegisterPenApp = GetProcAddress(GetSystemMetrics(SM_PENWINDOWS),
                                            "RegisterPenApp"))
    {
        (*lpfnRegisterPenApp)((WORD)1, fTrue); // be Pen-Enhanced
    }

    {
    // This assumes no edit controls created in FInitWinInfo
    HANDLE hLib;

    if (lpfnProcessWriting = GetProcAddress(hLib = GetSystemMetrics(SM_PENWINDOWS),
        "ProcessWriting"))
         {
         lpfnPostVirtualKeyEvent = GetProcAddress(hLib, "PostVirtualKeyEvent");
         lpfnTPtoDP = GetProcAddress(hLib, "TPtoDP");
         lpfnCorrectWriting = GetProcAddress(hLib, "CorrectWriting");
         lpfnSymbolToCharacter = GetProcAddress(hLib, "SymbolToCharacter");

        if ((vhcPen = LoadCursor( NULL, IDC_PEN   )) == NULL)
            goto InzFailed;
         }
    }

#endif

    /* init fields of the PRINTDLG structure (not used yet) */
    PD.lStructSize    = sizeof(PRINTDLG);
    PD.hwndOwner      = hParentWw;
    // PD.hDevMode  is already initialized
    PD.hDevNames      = NULL;
    PD.hDC            = NULL;
    PD.Flags          = PD_ALLPAGES; /* disable "pages" and "Selection" radiobuttons */
    PD.nFromPage      = 1;
    PD.nToPage        = 1;
    PD.nMinPage       = pgnMin; /* constant 1 */
    PD.nMaxPage       = pgnMax; /* largest integer */
    PD.nCopies        = 1;

    /* initialize OLE stuff (1-23-91 dougk) */
    if (!ObjInit(hInstance))
    goto InzFailed;

    /* Parse command line; load document & create an "mdoc" child window */

    if (!FInitArgs(rgchCmdLine) || fMessageInzFailed)
            /* Serious error -- bail out */
        goto InzFailed;

    /* Create a memory DC for the child window, to test that it works */

    ValidateMemoryDC();
    if (vhMDC == NULL)
        goto InzFailed;

    /* Make parent window visible after the child gets created; the order is
    important and that the parent window is created without the visible bit on,
    so that no size message is sent before child gets created */

    //if (!fPrintOnly)
        ShowWindow(hParentWw, cmdShow);

    Diag(CommSz("---------------------------------------------------------------------------\n\r"));
    vfInitializing = FALSE;
    fRetVal = TRUE;

FreeMsgs:
    if (hszCantRunM != NULL)
        GlobalFree( hszCantRunM );
    if (hszCantRunF != NULL)
        GlobalFree( hszCantRunF );
    return fRetVal;

InzFailed:
    FreeMemoryDC( TRUE );
    if (vhDCPrinter != NULL)
        DeleteDC( vhDCPrinter);

    if (hszWinFailure != NULL)
        GlobalFree( hszWinFailure );
#ifdef JAPAN 	//01/21/93
    if (hszNoMemorySel != NULL)
        GlobalFree( hszNoMemorySel );
#endif
    if (hszNoMemory != NULL)
        GlobalFree( hszNoMemory );
    if (hszDirtyDoc != NULL)
        GlobalFree( hszDirtyDoc );
    if (hszCantPrint != NULL)
        GlobalFree( hszCantPrint );
    if (hszPRFAIL != NULL)
        GlobalFree( hszPRFAIL );

    ferror = vfInitializing = FALSE; /* So the error report is not suppressed */
    if (vfDiskFull || vfSysFull || vfDiskError)
        Error(IDPMTCantRunF);
    else
        Error(IDPMTCantRunM);

    fRetVal = FALSE;
    goto FreeMsgs;
}




STATIC BOOL NEAR FRegisterWnd(hInstance)
HANDLE hInstance;
    {
    /* This routine registers all of the window classes.  TRUE is returned if
    all of the windows classes were successfully registered; FALSE otherwise. */

    extern CHAR szParentClass[];
    extern CHAR szDocClass[];
    extern CHAR szRulerClass[];
    extern CHAR szPageInfoClass[];
#ifdef ONLINEHELP
    extern CHAR szHelpDocClass[];
#endif

    extern long FAR PASCAL MmwWndProc(HWND, unsigned, WORD, LONG);
    extern long FAR PASCAL MdocWndProc(HWND, unsigned, WORD, LONG);
    extern long FAR PASCAL RulerWndProc(HWND, unsigned, WORD, LONG);
    extern long FAR PASCAL PageInfoWndProc(HWND, unsigned, WORD, LONG);

#ifdef ONLINEHELP
    extern long FAR PASCAL HelpDocWndProc(HWND, unsigned, WORD, LONG);
#endif /* ONLINEHELP */

    WNDCLASS Class;

    /* Register our Window Proc */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT;
    Class.lpfnWndProc = MmwWndProc;
    Class.hInstance = hInstance;
    Class.hCursor = vhcArrow;
    Class.hIcon = LoadIcon( hInstance, (LPSTR)szMw_icon );
    Class.lpszMenuName = (LPSTR)szMw_menu;
    Class.lpszClassName = (LPSTR)szParentClass;
    Class.hbrBackground = COLOR_WINDOW+1;

    /* register the parent menu class with WINDOWS */
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

    /* register memo document child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC | CS_DBLCLKS;
    Class.lpfnWndProc = MdocWndProc;
    Class.hInstance = hInstance;
    Class.lpszClassName = (LPSTR)szDocClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

    /* register ruler child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC | CS_DBLCLKS;
    Class.lpfnWndProc = RulerWndProc;
    Class.hInstance = hInstance;
    Class.hCursor = vhcArrow;
    Class.lpszClassName = (LPSTR)szRulerClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

#ifdef ONLINEHELP
    /* register Help document child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC;
    Class.lpfnWndProc = HelpDocWndProc;
    Class.hInstance = hInstance;
    Class.lpszClassName = (LPSTR)szHelpDocClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */
#endif /* ONLINE HELP */

    /* register page info child window class */
    bltbc( (PCH)&Class, 0, sizeof( WNDCLASS ) );
    Class.style = CS_OWNDC;
    Class.lpfnWndProc = PageInfoWndProc;
    Class.hInstance = hInstance;
    Class.hCursor = vhcArrow;
    Class.lpszClassName = (LPSTR)szPageInfoClass;
    if (!RegisterClass( (LPWNDCLASS)&Class ) )
        return FALSE;   /* Initialization failed */

    return TRUE;
    }


#ifdef INEFFLOCKDOWN
/* I've removed this for Windows 3.0 because (unless reasons come up
   proving otherwise) it is inefficient for a Win program to lock-down
   so many procedures like this for the entire time the app is running.
   Originally thought to lock down the entire procedure; now understood only
   to lock down the thunk.  The principle still applies..pault 10/26/89 */

STATIC int NEAR FInitFarprocs( hInstance )
HANDLE  hInstance;
    {
    /* This routine initializes all of the far pointer to procedures. */

    extern FARPROC lpDialogOpen;
    extern FARPROC lpDialogSaveAs;
    extern FARPROC lpDialogConfirm;
    extern FARPROC lpDialogPrinterSetup;
    extern FARPROC lpDialogPrint;
    extern FARPROC lpDialogRepaginate;
    extern FARPROC lpDialogSetPage;
    extern FARPROC lpDialogPageMark;
    extern FARPROC lpDialogCancelPrint;
    extern FARPROC lpDialogHelp;
#ifdef ONLINEHELP
    extern FARPROC lpDialogHelpInner;
#endif /* ONLINEHELP */
    extern FARPROC lpDialogGoTo;
    extern FARPROC lpDialogFind;
    extern FARPROC lpDialogChange;
    extern FARPROC lpDialogCharFormats;
    extern FARPROC lpDialogParaFormats;
    extern FARPROC lpDialogRunningHead;
    extern FARPROC lpDialogTabs;
    extern FARPROC lpDialogDivision;
    extern FARPROC lpDialogBadMargins;
    extern FARPROC lpFontFaceEnum;
    extern FARPROC lpFPrContinue;

#ifdef INTL /* International version */
    extern FARPROC lpDialogWordCvt;
    extern BOOL far PASCAL DialogWordCvt(HWND, unsigned, WORD, LONG);
#endif  /* International version */

    extern BOOL far PASCAL DialogOpen(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogSaveAs(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogPrinterSetup(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogPrint(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogCancelPrint(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogRepaginate(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogSetPage(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogPageMark(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogHelp(HWND, unsigned, WORD, LONG);
#ifdef ONLINEHELP
    extern BOOL far PASCAL DialogHelpInner(HWND, unsigned, WORD, LONG);
#endif /* ONLINEHELP */
    extern BOOL far PASCAL DialogGoTo(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogFind(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogChange(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogCharFormats(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogParaFormats(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogRunningHead(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogTabs(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogDivision(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogConfirm(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL DialogBadMargins(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL FontFaceEnum(LPLOGFONT, LPTEXTMETRIC, int, long);
    extern BOOL far PASCAL FPrContinue(HDC, int);

    if (
     ((lpDialogPrinterSetup = MakeProcInstance(DialogPrinterSetup, hInstance))
                                            == NULL) ||
     ((lpDialogPrint = MakeProcInstance(DialogPrint, hInstance)) == NULL) ||
     ((lpDialogSetPage = MakeProcInstance(DialogSetPage, hInstance)) == NULL)||
     ((lpDialogRepaginate = MakeProcInstance(DialogRepaginate, hInstance))
                                            == NULL) ||
     ((lpDialogPageMark = MakeProcInstance(DialogPageMark, hInstance))
                                            == NULL) ||
     ((lpDialogCancelPrint = MakeProcInstance(DialogCancelPrint, hInstance))
                                            == NULL) ||
     ((lpDialogHelp = MakeProcInstance(DialogHelp, hInstance)) == NULL) ||
#ifdef ONLINEHELP
     ((lpDialogHelpInner = MakeProcInstance(DialogHelpInner, hInstance))
                                            == NULL) ||
#endif /* ONLINEHELP */
     ((lpDialogGoTo = MakeProcInstance(DialogGoTo, hInstance)) == NULL) ||
     ((lpDialogFind = MakeProcInstance(DialogFind, hInstance)) == NULL) ||
     ((lpDialogChange = MakeProcInstance(DialogChange, hInstance)) == NULL) ||
     ((lpDialogCharFormats = MakeProcInstance(DialogCharFormats, hInstance))
                                            == NULL) ||
     ((lpDialogParaFormats = MakeProcInstance(DialogParaFormats, hInstance))
                                            == NULL) ||
     ((lpDialogRunningHead = MakeProcInstance(DialogRunningHead, hInstance))
                                            == NULL) ||
     ((lpDialogTabs = MakeProcInstance(DialogTabs, hInstance)) == NULL) ||
     ((lpDialogDivision = MakeProcInstance(DialogDivision, hInstance))
                                            == NULL) ||
     ((lpDialogConfirm = MakeProcInstance(DialogConfirm, hInstance)) == NULL)||
     ((lpDialogBadMargins = MakeProcInstance(DialogBadMargins, hInstance))
                                            == NULL) ||
     ((lpFontFaceEnum = MakeProcInstance(FontFaceEnum, hInstance)) == NULL) ||
     ((lpFPrContinue = MakeProcInstance(FPrContinue, hInstance)) == NULL)

#ifdef INTL /* International version */
     || ((lpDialogWordCvt = MakeProcInstance(DialogWordCvt, hInstance)) == NULL)
#endif  /* International version */
    )
        return FALSE;
    return TRUE;
    }
#endif /* ifdef-INEFFLOCKDOWN */


void MmwCreate(hWnd, lParam)
HWND  hWnd;
LONG  lParam;
{
    extern CHAR szPageInfoClass[];
    HANDLE hSysMenu;
    HDC hDC;
    HBRUSH hbr;

    Assert( hMmwModInstance != NULL );  /* Should have set up instance handle */

    hParentWw = hWnd;
    if ((vhMenu = GetMenu(hWnd)) == NULL)
        goto Error;

    /* set up font cache */
    /* RgfceInit() placed in line for speed */
    {
    int ifce;
    struct FCE *pfce;

    for (ifce = 0; ifce < vifceMac; ifce++)
        {
        pfce = &rgfce[ifce];
        pfce->pfceNext = &rgfce[(ifce + 1) % vifceMac];
        pfce->pfcePrev = &rgfce[(ifce + vifceMac - 1) % vifceMac];
        pfce->fmi.mpchdxp = pfce->rgdxp - chFmiMin;
        pfce->fcidRequest.lFcid = fcidNil;
        }

    Assert(sizeof(rgfce[0].fcidRequest.lFcid)
           == sizeof(rgfce[0].fcidRequest.strFcid));
    vpfceMru = &rgfce[0];
    vfcidScreen.lFcid = vfcidPrint.lFcid = fcidNil;
    }

/* set up page buffer, internal data structures, heap etc. */
    if (!FInitMemory())
        goto Error;

    /* Create the horizontal scroll bar.  The size is initialized to zero
    because it will be reset later. */

    if ((wwdCurrentDoc.hHScrBar = CreateWindow((LPSTR)szScrollBar, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_HORZ, 0, 0, 0, 0, hWnd,
      NULL, hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }
    wwdCurrentDoc.sbHbar = SB_CTL;

    /* Create the vertical scroll bar.  The size is initialized to zero
    because again it will be reset later. */

    if ((wwdCurrentDoc.hVScrBar = CreateWindow((LPSTR)szScrollBar, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_VERT, 0, 0, 0, 0, hWnd,
      NULL, hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }
    wwdCurrentDoc.sbVbar = SB_CTL;

#ifndef NOMORESIZEBOX
    /* Create the size box.  The size is initialized to zero because again it
    will be reset later. */
    if ((vhWndSizeBox = CreateWindow((LPSTR)szScrollBar, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_SIZEBOX,
      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hWnd, NULL,
      hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }
#endif

    /* Create the page info window.  Again, we'll worry about the sizing later.
    */
    if ((vhWndPageInfo = CreateWindow((LPSTR)szPageInfoClass, (LPSTR)NULL,
         WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, 0, 0, 0, 0, hWnd, NULL,
         hMmwModInstance, (LPSTR)NULL)) == NULL)
        {
        goto Error;
        }

    /* Initialize the page info window. */
    if ((hDC = GetDC(vhWndPageInfo)) == NULL || (hbr =
      CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) == NULL)
        {
        goto Error;
        }
      if (SelectObject(hDC, hbr) == NULL)
        {
        DeleteObject(hbr);
        goto Error;
        }
    SetBkMode(hDC, TRANSPARENT);
#ifdef WIN30
    /* If the user has their colors set with a TextCaption color of
       black then this becomes hard to read!  We just hardcode this
       to be white since the background defaults to being black */
    SetTextColor(hDC, (DWORD) -1);
#else
    SetTextColor(hDC, GetSysColor(COLOR_CAPTIONTEXT));
#endif

    /* Get the height and width of the scroll bars. */
    dypScrlBar = GetSystemMetrics(SM_CYHSCROLL);
    dxpScrlBar = GetSystemMetrics(SM_CXVSCROLL);

    /* Set the ranges of the horizontal and vertical scroll bars. */
    SetScrollRange(wwdCurrentDoc.hHScrBar, SB_CTL, 0, xpRightLim, TRUE);
    SetScrollRange(wwdCurrentDoc.hVScrBar, SB_CTL, 0, drMax - 1, TRUE);

    return;
Error:
    fMessageInzFailed = TRUE;
}




void MdocCreate(hWnd, lParam)
register HWND  hWnd;
LONG  lParam;
{
    vhWnd = wwdCurrentDoc.wwptr = hWnd;
    wwdCurrentDoc.hDC = GetDC( hWnd );
    if ( wwdCurrentDoc.hDC == NULL )
        {
        fMessageInzFailed = TRUE;
        return;
        }

    /* Set the DC to transparent mode. */
    SetBkMode( wwdCurrentDoc.hDC, TRANSPARENT );

    /* Set the background and foreground colors. */
    SetBkColor( wwdCurrentDoc.hDC, rgbBkgrnd );
    SetTextColor( wwdCurrentDoc.hDC, rgbText );

    /* Set the background brush. */
    SelectObject( wwdCurrentDoc.hDC, hbrBkgrnd );

}


STATIC HANDLE NEAR HszCreateIdpmt(idpmt)
int idpmt;
{
    /* Create a heap string and fill it with a string from the resource file. */
    char szTmp[cchMaxSz];

    return (LoadString(hMmwModInstance, idpmt, (LPSTR)szTmp, sizeof(szTmp)) == 0 ? NULL :
      HszGlobalCreate(szTmp));
}


#if defined(INTL) && defined(WIN30)
/* Routine to load some strings from write.rc.  These strings
   used to be placed in globdefs.h.    fernandd  10/20/89     */

BOOL FInitIntlStrings(hInstance)
HANDLE hInstance;
    {
    extern  CHAR    szMode[30];
    extern  CHAR    szWriteDocPrompt[25];
    extern  CHAR    szScratchFilePrompt[25];
    extern  CHAR    szSaveFilePrompt[25];
#if defined(KOREA)  // jinwoo : 10/16/92
    extern  CHAR    szAppName[13];
#else
    extern  CHAR    szAppName[10];
#endif
    extern  CHAR    szUntitled[20];
    extern  CHAR    sziCountryDefault[5];
    extern  CHAR    szWRITEText[30];
    extern  CHAR    szFree[15];
    extern  CHAR    szNone[15];
    extern  CHAR    szHeader[15];
    extern  CHAR    szFooter[15];
    extern  CHAR    szLoadFile[25];
    extern  CHAR    szCvtLoadFile[45];
    extern  CHAR    szAltBS[15];
    extern  CHAR    *mputsz[];

#ifdef JAPAN /*t-Yoshio T-HIROYN Win3.1 */
    extern  CHAR    Zenstr1[256];
    extern  CHAR    Zenstr2[256];
// default Font Face Name . We use this FInitFontEnum()
    extern  CHAR    szDefFFN0[10];
    extern  CHAR    szDefFFN1[10];

    LoadString(hInstance, IDSTRZen1,(LPSTR)Zenstr1,sizeof(Zenstr1));
    LoadString(hInstance, IDSTRZen2,(LPSTR)Zenstr2,sizeof(Zenstr2));
    LoadString(hInstance, IDSdefaultFFN0, (LPSTR)szDefFFN0,sizeof(szDefFFN0));
    LoadString(hInstance, IDSdefaultFFN1, (LPSTR)szDefFFN1,sizeof(szDefFFN1));
#elif defined(KOREA)
    extern  CHAR    Zenstr1[256];
    LoadString(hInstance, IDSTRZen1,(LPSTR)Zenstr1,sizeof(Zenstr1));
#endif

    if (LoadString(hInstance, IDSTRModeDef,              (LPSTR)szMode,              sizeof(szMode)) &&
        LoadString(hInstance, IDSTRWriteDocPromptDef,    (LPSTR)szWriteDocPrompt,    sizeof(szWriteDocPrompt)) &&
        LoadString(hInstance, IDSTRScratchFilePromptDef, (LPSTR)szScratchFilePrompt, sizeof(szScratchFilePrompt)) &&
        LoadString(hInstance, IDSTRSaveFilePromptDef,    (LPSTR)szSaveFilePrompt,    sizeof(szSaveFilePrompt)) &&
        LoadString(hInstance, IDSTRAppNameDef,           (LPSTR)szAppName,           sizeof(szAppName)) &&
        LoadString(hInstance, IDSTRUntitledDef,          (LPSTR)szUntitled,          sizeof(szUntitled)) &&
        LoadString(hInstance, IDSTRiCountryDefaultDef,   (LPSTR)sziCountryDefault,    sizeof(sziCountryDefault)) &&
        LoadString(hInstance, IDSTRWRITETextDef,         (LPSTR)szWRITEText,         sizeof(szWRITEText)) &&
        LoadString(hInstance, IDSTRFreeDef,              (LPSTR)szFree,              sizeof(szFree)) &&
        LoadString(hInstance, IDSTRNoneDef,              (LPSTR)szNone,              sizeof(szNone)) &&
        LoadString(hInstance, IDSTRHeaderDef,            (LPSTR)szHeader,            sizeof(szHeader)))
            {
            if (LoadString(hInstance, IDSTRFooterDef,            (LPSTR)szFooter,            sizeof(szFooter)) &&
                LoadString(hInstance, IDSTRLoadFileDef,          (LPSTR)szLoadFile,          sizeof(szLoadFile)) &&
                LoadString(hInstance, IDSTRCvtLoadFileDef,       (LPSTR)szCvtLoadFile,       sizeof(szCvtLoadFile)) &&
                LoadString(hInstance, IDSTRAltBSDef,             (LPSTR)szAltBS,             sizeof(szAltBS)) &&
                LoadString(hInstance, IDSTRInchDef,           (LPSTR)mputsz[0], 6) &&
                LoadString(hInstance, IDSTRCmDef,             (LPSTR)mputsz[1], 6) &&
                LoadString(hInstance, IDSTRP10Def,            (LPSTR)mputsz[2], 6) &&
                LoadString(hInstance, IDSTRP12Def,            (LPSTR)mputsz[3], 6) &&
                LoadString(hInstance, IDSTRPointDef,          (LPSTR)mputsz[4], 6) &&
                LoadString(hInstance, IDSTRLineDef,           (LPSTR)mputsz[5], 6))
                return(fTrue);
            }
    /* else */
    return(fFalse);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\initmmw.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* initialization codes for internal memory, page buffers, etc. */
#define NOKEYSTATE
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOSYSMETRICS
#define NOSYSCOMMANDS
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOSHOWWINDOW
//#define NOATOM
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSHOWWINDOW
#define NOBITMAP
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#define NOMETAFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOWH
#define NOWINOFFSETS
/* need gdi, hdc, memmgr */
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "stcdefs.h"
#ifdef CASHMERE
#include "txb.h"
#endif /* CASHMERE */
#include "fontdefs.h"
#include "code.h"
#include "heapdefs.h"
#include "heapdata.h"
#include "str.h"
#include "ch.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

/* E X T E R N A L S */
extern int              ypMaxWwInit;
extern int              dypWwInit;
extern int              *memory;
extern int              *pmemMax;
extern CHAR             *pmemStart;
extern unsigned         vcbMemTotal;
extern HWND             hParentWw;
extern HDC              vhDCPrinter;
extern int              rfnMac;
extern CHAR             (*rgbp)[cbSector];
extern int              fnMac;
extern typeTS           tsMruRfn;
extern struct ERFN      dnrfn[];
extern CHAR             *rgibpHash;
extern struct BPS       *mpibpbps;
extern typeTS           tsMruBps;
extern struct CHP       vchpNormal;
extern struct PAP       *vppapNormal;
extern struct SEP       vsepNormal;
extern struct CHP       (**vhgchpFormat)[];
extern int              ichpMacFormat;
extern struct CHP       vchpInsert;
extern struct CHP       vchpSel;
extern struct FCB       (**hpfnfcb)[];
extern struct FKPD      vfkpdCharIns;
extern struct FKPD      vfkpdParaIns;
extern struct PAP       vpapPrevIns;
extern struct FLI       vfli;
extern int              docMac;
extern struct DOD       (**hpdocdod)[];
extern int              docScrap;
extern int              docUndo;
#ifdef CASHMERE /* No docBuffer in WRITE */
extern int              docBuffer;
#endif
extern int              docCur;
extern CHAR             (**hszSearch)[];
extern CHAR             (**hszReplace)[];
extern CHAR             (**hszFlatSearch)[];
extern CHAR             stBuf[];
extern int              vrefSystem;
extern CHAR             (**vhrgbSave)[];
extern int              vdxaPaper;
extern int              vdyaPaper;
extern struct SEL       selCur;
extern BOOL             vfPrinterValid;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern int              dxaPrOffset;
extern int              dyaPrOffset;
extern HCURSOR          vhcArrow;
#ifdef UNUSED
extern int  vfCanPrint;
#endif

//Win3.1J
#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME */
extern int     docIRString;
#endif

/* G L O B A L S -- used only in here */
int                     rgwPapNormal[cwPAPBase + cwTBD] = {0};


#ifdef STATICPAGES
#ifdef MACHA
#define                 ibpMaxStatic  79
#define                 iibpHashMaxStatic  163
#else /* not MACHA */
#define                 ibpMaxStatic  7
#define                 iibpHashMaxStatic  17
#endif /* MACHA */
CHAR                    rgbpStatic[ibpMaxStatic][cbSector];
#endif /* STATICPAGES */

extern typePN PnAlloc();

STATIC int NEAR FInitDocs( void );
STATIC int NEAR FInitProps( void );
STATIC int NEAR FInitFiles( void );
WORD wWinVer,fPrintOnly=FALSE;

int FInitMemory()
{
extern HANDLE vhReservedSpace;
int i;

#ifdef UNUSED
/* Initially assume that it is not possible to print  */
/* Formerly InitPrint was called here    */
        vfCanPrint =  false;
#endif

    /** This is a glitch so that the fixed array for storing relocation
        information will be created immediately */
    wWinVer = (WORD)(GetVersion() & 0x0000FFFFL);
    if (((wWinVer & 0xFF) >= 3) && ((wWinVer & 0xFF00) >= 0x0A00))
    /* Windows Version >= 3.10 */
    {
        FARPROC LHandleDelta = GetProcAddress(GetModuleHandle((LPSTR)"KERNEL"),(LPSTR)0x136L);
        i = LHandleDelta(0);
        LHandleDelta(i*5); /* make a big finger table */
        vhReservedSpace = LocalAlloc(LHND, cbReserve);
        LocalFree(vhReservedSpace);
        LHandleDelta(i); /* resume to a smaller finger table if needed more */
    }
    else
    /* Windows Version < 3.10 */
    {
        /**
            This is heaping kludge upon kludge in the effort to be backwards
            compatible with past kludges.  This is the old macro which with
            Win31 has become a function call. (3.11.91) D. Kent
        **/
#define LocalHandleDelta(d) ((d) ? (*(pLocalHeap+9) = (d)) : *(pLocalHeap+9))
        i = LocalHandleDelta(0);
        LocalHandleDelta(i*5); /* make a big finger table */
        vhReservedSpace = LocalAlloc(LHND, cbReserve);
        LocalFree(vhReservedSpace);
        LocalHandleDelta(i); /* resume to a smaller finger table if needed more */
    }

#ifdef OURHEAP
/* reserve 1K for windows's memory manager for creating dialog boxes */
        vhReservedSpace = LocalAlloc(LPTR, cbReserve);

        CreateHeapI(); /* create heap first */
        if (!FCreateRgbp())  /* rgbp are expandable */
            return FALSE;

/* now free the reserved space after our memory is set up. */
/* hopefully we will get all the fixed objects created by
   dialog manager be placed above our memory chunk, so we can still
   expand our heap while a dialog box is up. */
        LocalFree(vhReservedSpace);
#else
        if (!FCreateRgbp())
            return FALSE;
        vhReservedSpace = LocalAlloc(LHND, cbReserve); /* this is to make
        discardable when we are out of memory and try to bring up the
        save dialog box */
#endif

        if (vhReservedSpace == NULL)
            return FALSE;

/* formerly CreateHpfnfcb */
        hpfnfcb = (struct FCB (**)[])HAllocate(cwFCB * fnMax);
        if (FNoHeap(hpfnfcb))
            return FALSE;
        fnMac = fnMax;
        for (i = 0; i < fnMac; i++)
            (**hpfnfcb)[i].rfn = rfnFree;
/* end of CreateHpfnfcb */

        if (!FSetScreenConstants())
            return FALSE;

        if ( !FInitDocs() ||
#ifdef CASHMERE     /* No glossary in MEMO */
             !FInitBufs() ||
#endif  /* CASHMERE */
             !FInitProps() ||
             !FInitFiles() )
            return FALSE;

/* allocate emergency space for save operations */
        if (FNoHeap(vhrgbSave = (CHAR (**)[])HAllocate(cwSaveAlloc)))
            return FALSE;

        return TRUE;
}
/* end of  F I n i t M e m o r y  */




int FInitArgs(sz)
CHAR *sz;
{   /*  Set extern int docCur to be a new doc, containing
        the file (if any) specified on the command line (sz).

        Initialize a wwd (window descriptor) structure for the document
        and set an appropriate title into the title bar.

        Set selCur to be an insertion point before the first char of the doc,
        and set vchpSel to be the char properties of the insertion point.

        Return TRUE if all is well, FALSE if something went wrong.
        A return of FALSE means that initialization should not continue.
        */

        extern typeCP cpMinDocument;
        extern struct WWD rgwwd[];
        extern int vfDiskError;
        extern int vfSysFull;
        extern int ferror;
        extern BOOL vfWarnMargins;

        int fn, doc;
        RECT rcCont;
        CHAR szT [ cchMaxFile ];
        register CHAR *pch;
                CHAR ch;
        int fEmptyLine = TRUE;
        CHAR (**hsz) [];
        int iT, cbsz;

#ifdef INTL /* International version */
        int fWordDoc = FALSE;
#endif  /* International version */

        /* Decide whether we have anything but white space on the command line */

        for ( pch = sz; (ch = *pch) != '\0'; pch++ )
            if ((ch != ' ') && (ch != '\011'))
                {
                fEmptyLine = FALSE;
                break;
                }

        if (fEmptyLine)
                /* No filename; start with (Untitled) */
            goto Untitled;

        cbsz = CchSz (sz ) - 1;
           /* remove trailing spaces from sz */
        for ( pch = sz + cbsz - 1; pch >= sz; pch-- )
            if (*pch != ' ')
                break;
            else
                {
                *pch = '\0';  /* replace with null */
                cbsz--;
                }

        /* check for /p option (6.26.91) v-dougk */
        if ((sz[0] == '/') && (sz[1] == 'p'))
        {
            sz += 2;
            cbsz -= 2;
            fPrintOnly = TRUE;
            for (; *sz; sz++, cbsz-- ) // get to filename
                if ((*sz != ' ') && (*sz != '\011'))
                    break;

            if (!*sz) /* No filename, abort */
                return FALSE;
        }

        /* convert to OEM */
        AnsiToOem(sz, sz);

        if (!FValidFile( sz, cbsz, &iT ) ||
             !FNormSzFile( szT, sz, dtyNormal ))
            {   /* Bad filename -- it could not be normalized */
            extern int vfInitializing;
            char szMsg[cchMaxSz];
            char *pch;
            extern HWND vhWndMsgBoxParent;
            extern HANDLE hParentWw;

            vfInitializing = FALSE; /* Do not suppress reporting this err */
            MergeStrings (IDPMTBadFileName, sz, szMsg);
            /* if we're being called from a message box, then use it
               as the parent window, otherwise use main write window */
            IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw,
                          szMsg, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
            ferror = TRUE; /* need to flag */
            vfInitializing = TRUE;
            goto Untitled;
            }

        if ((fn = FnOpenSz( szT, dtyNormal,
               index( szT, '/' ) == NULL &&
               index( szT,':') == NULL && index( szT, '\\') == NULL )) != fnNil)
                /* Opened file OK -- prefetch file contents into rgbp */
        {

#ifdef INTL /* Kanji / International version */
              /* **************************************
              * added check for international version to
                 do Word format conversion. If Word format,
                 bring up another dialog box.
              * ************************************** */

                  /* TestWordCvt return values:

                    -1 means dialog box failed (error already sent)
                       or cancel without conversion.
                    FALSE means not a word document.
                    TRUE means convert this word document.
                        vfBackupSave is changed to reflect whether
                        save is done with backup.
                      */

#ifdef KKBUGFIX     //  added by Hiraisi (BUG#2816 WIN31) in Japan
            if ((fWordDoc = TestWordCvt (fn, (HWND)NULL)) == -1  ||
                 fWordDoc == -2)
#else
            if ((fWordDoc = TestWordCvt (fn, (HWND)NULL)) == -1)
#endif
                goto Untitled;
                /* if fWordDoc is true, will convert later */
#endif  /* International version */


            StartLongOp();
            ReadFilePages( fn );
            EndLongOp(vhcArrow);
        }
        else /* Could not open file  */
        {
            if (fPrintOnly)
                return FALSE;
            else
            {   /* use (Untitled) */
Untitled:
            fn = fnNil;
            sz [0] = '\0';
            szT [0] = '\0';
            }
        }

        if (vfDiskError || vfSysFull)
                /* Serious disk error OR disk holding scratch file is full --
                   bail out */
            return FALSE;

        if (fn != fnNil)
            {   /* Opened file OK -- must account for the case when OpenFile
                   returned a filename that differed from the one given it */

            bltsz( &(**(**hpfnfcb) [fn].hszFile) [0], szT );
            }

        if (FNoHeap(hsz=HszCreate( (PCH) szT )) ||
            (doc=DocCreate( fn, hsz, dtyNormal )) == docNil)
            {   /* Could not create a doc */
            return FALSE;
            }
        if (WwNew(doc, dypWwInit, ypMaxWwInit) == wwNil)
            return FALSE;
        NewCurWw(0, true);
        if (fn != fnNil)
            {
            vfWarnMargins = TRUE;
            SetPageSize();
            vfWarnMargins = FALSE;
            }
        wwdCurrentDoc.cpFirst = selCur.cpLim = selCur.cpFirst = cpMinDocument;
        selCur.fForward = true;
        GetInsPtProps(selCur.cpFirst);

#ifdef OURHEAP
        {
        extern int cwInitStorage;
/* save this amount of heap as "100% free" */
/* formerly CalcTot(true) */
        cwInitStorage = cwHeapMac - cwHeapFree;
        cbTot = (cwHeapMac - cwInitStorage) * sizeof(int);
        cbTotQuotient = (cbTot>>1)/100;
        }
#endif

#ifdef STYLES
/* Set up scrap document to have a valid style sheet on start up. */
        (**hpdocdod)[docScrap].docSsht = (**hpdocdod)[docCur].docSsht;
#endif  /* STYLES */

#ifdef INTL /* International version */
     /* if a word document to be converted, save
        it doing conversion. */

                if (fWordDoc == TRUE)
                        {
                          /* save file in write format. */
                        ConvertFromWord();
                        }
#endif  /* International version */

        SetTitle(szT);

#if defined(OLE)
        ObjOpenedDoc(doc);
#endif
        return TRUE;
}
/* end of  F I n i t A r g s  */




#ifdef OURHEAP
CreateHeapI()
{
FGR *pfgr, *pfgrLim;
#ifdef WINBUG
unsigned cb = (unsigned)GlobalCompact((DWORD)0);
#endif

    ibpMax = ibpMaxSmall;
    if (cb > 0x4fff /* about 20K */)
        {
        HANDLE hTemp;
        /* we can start with a bigger page buffer */
        vcbMemTotal = (unsigned)LocalCompact((WORD)0);
        pmemStart = (CHAR *)LocalAlloc(LPTR, vcbMemTotal);
        /* get all we have and force a reallocation */
        hTemp = LocalReAlloc((HANDLE)pmemStart, 0x4fff, LPTR);
        if (hTemp != NULL)
            {
            LocalFree(hTemp);
            ibpMax = ibpMaxBig;
            }
        else
            {
            /* somehow we failed and went back to the small system */
            LocalFree((HANDLE)pmemStart);
            }
        }

    vcbMemTotal = (unsigned)LocalCompact((WORD)0);

/* memory always bumped to point to the next available slot
   for allocation */
/* take all the space as one chunk and do our own memory management */
    pmemStart = (CHAR *)LocalAlloc(LPTR, vcbMemTotal);
    memory = (int *)pmemStart;
    vcbMemTotal = (unsigned)LocalSize((HANDLE)pmemStart); /* in case
                  we got more than we asked */
    pmemMax = (int *)((CHAR *)memory + vcbMemTotal);

/* take half of heap space for page buffers
    ibpMax = (vcbMemTotal>>1)/cbSector;*/
    iibpHashMax = ibpMax * 2 + 1;

/* Set finger table to low end of heap */
    rgfgr = (PFGR)memory;
    memory += ifgrInit;
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */

/* Here is our heap */
    pHeapFirst = (int *)memory;

    cwHeapMac = /* cwtotal */
                (((unsigned)pmemMax - (unsigned)pHeapFirst +
                sizeof(int) - 1) / sizeof(int)) -
                /* cw in rgibpHash */
                ((iibpHashMax * sizeof(CHAR) +
                sizeof(int) - 1) / sizeof(int)) -
                /* cw in mpibpbps  */
                ((ibpMax * sizeof(struct BPS) +
                sizeof(int) - 1) / sizeof(int)) -
                /* cw in rgbp */
                ((ibpMax * cbSector * sizeof(CHAR) +
                sizeof(int) - 1) / sizeof(int));

    memory += cwHeapMac;

#ifdef DEBUG
    cwHeapMac -= 16; /* Need spare words for shaking */
                     /* This space is above the finger table */
#endif
    cwHeapFree = cwHeapMac;
    phhMac = (HH *)(pHeapFirst + cwHeapMac);
/* if DEBUG, then phhMac will point at the shake word;
   otherwise it will point to 1 cell after the heap */

    phhFree = (HH *) pHeapFirst;
    phhFree->cw = -cwHeapMac; /* whobj.heap is free */
    phhFree->phhNext = phhFree;
    phhFree->phhPrev = phhFree;

    pfgrMac = &rgfgr[ifgrInit];
    pfgrLim = pfgrMac - 1;

/* thread the free fingers */
    for (pfgr = rgfgr; pfgr < pfgrLim; pfgr++)
        *pfgr = (FGR)(pfgr + 1);
    *pfgrLim = NULL;              /* last free finger */
    pfgrFree = rgfgr;
}
/* end of  C r e a t e H e a p I  */
#endif /* OURHEAP */



STATIC int NEAR FInitDocs()
{ /* Initialize hpdocdod */
        struct DOD *pdod, *pdodLim;
        hpdocdod = (struct DOD (**)[])HAllocate(cwDOD * (docMac = cdocInit));
        if (FNoHeap(hpdocdod))
            return FALSE;

    pdod = &(**hpdocdod)[0];
        pdodLim = pdod + cdocInit;
        while (pdod < pdodLim)
            pdod++->hpctb = 0;  /* Mark all doc entries as free */
        docScrap = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer);   /* HM */

//Win3.1J
#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME */
        docIRString = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer); /* HM */
#endif

        docUndo = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer);    /* HM */
#ifdef CASHMERE
        docBuffer = DocCreate(fnNil, HszCreate((PCH)""), dtyBuffer);    /* HM */
#endif

        docCur = docNil;
        NoUndo();
        hszSearch = HszCreate((PCH)""); /* No initial search string */
        hszReplace = HszCreate((PCH)""); /* No initial replace string */
        hszFlatSearch = HszCreate((PCH)""); /* No initial flattenned search string */
        if (docScrap == docNil || docUndo == docNil ||
#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME */
        docIRString == docNil ||
#endif
#ifdef CASHMERE
            docBuffer == docNil ||
#endif
            FNoHeap(hszFlatSearch))
                return FALSE;
        return TRUE;
}
/* end of  F I n i t D o c s  */




#ifdef CASHMERE     /* No glossary in MEMO */
FInitBufs()
{
/* Initializes structures and data used in named buffer management.
Allocates space for hgtxb, initializes itxbMac */

        struct TXB *ptxb;
        extern struct TXB (**hgtxb)[];
        extern short itxbMac;

        if (FNoHeap(hszGlosFile = HszCreate((PCH)"")))
            return FALSE;
        if (FNoHeap(hgtxb = (struct TXB (**)[])HAllocate(cwTxb)))
            return FALSE;
        ptxb = &(**hgtxb)[0];
        ptxb->hszName = hszNil;
        itxbMac = 0;
        return TRUE;
}
/* end of  F I n i t B u f s  */
#endif  /* CASHMERE */



STATIC int NEAR FInitProps()
{ /* Initialize your basic properties */

#ifndef FIXED_PAGE
        unsigned dxaRightMin;
        unsigned dyaBottomMin;
#endif /* not FIXED_PAGE */

        vchpNormal.hps = hpsNormal;     /* NOTE - this is the size we use for
                                           incremental encoding, the "default"
                                           size may differ */
        vchpNormal.ftc = 0; /* will be whatever the standard modern font is */
        vchpNormal.ftcXtra = 0;

        vchpNormal.fStyled = true;
        /* vchpNormal.stc = stcNormal; */

        vppapNormal = (struct PAP *)rgwPapNormal;

        /* vppapNormal->fStyled = false; */
        /* vppapNormal->stc = 0; */
        vppapNormal->stcNormChp = stcParaMin;
        /* vppapNormal->dxaRight = 0; */
        /* vppapNormal->dxaLeft = 0; */
        /* vppapNormal->dxaLeft1 = 0; */
        /* vppapNormal->jc = jcLeft; */
        /* vppapNormal->dyaBefore = 0; */
        /* vppapNormal->dtaAfter = 0; */

        vppapNormal->fStyled = true;
        vppapNormal->stc = stcParaMin;
        vppapNormal->dyaLine = czaLine;

        Assert(cwPAP == cwSEP);

        /* vsepNormal.fStyled = false; */
        /* vsepNormal.stc = 0; */
        vsepNormal.bkc = bkcPage;
        /* vsepNormal.nfcPgn = nfcArabic; */

#ifdef FIXED_PAGE
        /* The "normal" page size is fixed at 8-1/2 by 11 inches. */
        vsepNormal.xaMac = cxaInch * 8 + cxaInch / 2;
        vsepNormal.xaLeft = cxaInch * 1 + cxaInch / 4;
        vsepNormal.dxaText = cxaInch * 6;
        vsepNormal.yaMac = cyaInch * 11;
        vsepNormal.yaTop = cyaInch * 1;
        vsepNormal.dyaText = cyaInch * 9;
        vsepNormal.yaRH1 = cyaInch * 3 / 4;
        vsepNormal.yaRH2 = cyaInch * 10 + cyaInch / 4;
#else /* not FIXED_PAGE */
        /* The page size is determined by inquiring it from the printer.  Then,
        other measurements can be derived from it. */
        Assert(vhDCPrinter);
        if (vfPrinterValid && vhDCPrinter != NULL)
            {
            POINT pt;

            /* Get the page size of the printer. */
            if (Escape(vhDCPrinter, GETPHYSPAGESIZE, 0, (LPSTR)NULL,
              (LPSTR)&pt))
                {
                vsepNormal.xaMac = MultDiv(pt.x, dxaPrPage, dxpPrPage);
                vsepNormal.yaMac = MultDiv(pt.y, dyaPrPage, dypPrPage);
     