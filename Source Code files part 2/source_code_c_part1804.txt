 else 
    {
        // maintain the same class if possible
        if (IsNamedWindow(_bbd._hwnd, TEXT("IEFrame")))
            uFlags |= COF_IEXPLORE;
    }

    IBrowserService *pbs;
    ITravelLog *ptlClone = NULL;
    DWORD bid = BID_TOPFRAMEBROWSER;

#ifdef UNIX
    if (wFlags & SBSP_HELPMODE) 
        uFlags |= COF_HELPMODE;
#endif

    if (!(wFlags & SBSP_NOTRANSFERHIST))
    {
        if (SUCCEEDED(_pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
        {
            ITravelLog *ptl;

            if (SUCCEEDED(pbs->GetTravelLog(&ptl)))
            {
                if (SUCCEEDED(ptl->Clone(&ptlClone)))
                {
                    ptlClone->UpdateEntry(pbs, FALSE);
                    bid = pbs->GetBrowserIndex();
                }
                ptl->Release();
            }
            pbs->Release();
        }
    }

    INotifyAppStart * pnasTop;
    HRESULT hr = _pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(INotifyAppStart, &pnasTop));
    if (SUCCEEDED(hr))
    {
        pnasTop->AppStarting();
        pnasTop->Release();
    }

    hr = SHOpenNewFrame(pidlNew, ptlClone, bid, uFlags);
    
    if (ptlClone)
        ptlClone->Release();

    return hr;
}

//
//  This is a helper member of CBaseBroaser class (non-virtual), which
// returns the effective client area. We get this rectangle by subtracting
// the status bar area from the real client area.
//
HRESULT CBaseBrowser2::_GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon)
{
    // (derived class overrides w/ GetEffectiveClientRect for FCIDM_STATUS etc.)
    //
    // This code should only be hit in the WebBrowserOC case, but I don't
    // have a convenient assert for that... [mikesh]
    //
    ASSERT(hmon == NULL);
    GetClientRect(_bbd._hwnd, lprectBorder);
    return NOERROR;
}

HRESULT CBaseBrowser2::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    TraceMsg(TF_SHDUIACTIVATE, "UIW::ReqestBorderSpace pborderwidths=%x,%x,%x,%x",
             pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    return S_OK;
}

//
// This is an implementation of IOleInPlaceUIWindow::GetBorder.
//
//  This function returns the bounding rectangle for the active object.
// It gets the effective client area, then subtract border area taken by
// all "frame" toolbars.
//
HRESULT CBaseBrowser2::GetBorder(LPRECT lprectBorder)
{
    _pbsOuter->_GetViewBorderRect(lprectBorder);
    return S_OK;
}

//
// NOTES: We used to handle the border space negotiation in CShellBrowser
//  and block it for OC (in Beta-1 of IE4), but I've changed it so that
//  CBaseBrowser2 always handles it. It simplifies our implementation and
//  also allows a DocObject to put toolbars within the frameset, which is
//  requested by the Excel team. (SatoNa)
//
HRESULT CBaseBrowser2::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    if (pborderwidths) 
    {
        TraceMsg(TF_SHDUIACTIVATE, "UIW::SetBorderSpace pborderwidths=%x,%x,%x,%x",
                 pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
        _rcBorderDoc = *pborderwidths;
    }
    else
    {
        TraceMsg(TF_SHDUIACTIVATE, "UIW::SetBorderSpace pborderwidths=NULL");
        SetRect(&_rcBorderDoc, 0, 0, 0, 0);
    }
    
    _pbsOuter->_UpdateViewRectSize();
    return S_OK;
}

HRESULT CBaseBrowser2::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    TraceMsg(TF_SHDUIACTIVATE, "UIW::SetActiveObject called %x", pActiveObject);

    ATOMICRELEASE(_pact);

    if (pActiveObject)
    {
        _pact = pActiveObject;
        _pact->AddRef();
    }

    return S_OK;
}


BOOL _IsLegacyFTP(IUnknown * punk)
{
    BOOL fIsLegacyFTP = FALSE;
    CLSID clsid;

    if ((4 == GetUIVersion()) &&
        SUCCEEDED(IUnknown_GetClassID(punk, &clsid)) &&
        IsEqualCLSID(clsid, CLSID_CDocObjectView))
    {
        fIsLegacyFTP = TRUE;
    }

    return fIsLegacyFTP;
}

/***********************************************************************\
    FUNCTION: _AddFolderOptionsSheets

    DESCRIPTION:
        Add the sheets for the "Folder Options" dialog.  These sheets
    come from the IShelLView object.
\***********************************************************************/
HRESULT CBaseBrowser2::_AddFolderOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh)
{
    // Add the normal Folder Option sheets.
    IShellPropSheetExt * ppsx;
    HRESULT hr = E_FAIL;
    
    if (!_IsLegacyFTP(_bbd._psv))
    {
        hr = _pbsOuter->CreateBrowserPropSheetExt(IID_PPV_ARG(IShellPropSheetExt, &ppsx));

        if (SUCCEEDED(hr))
        {
            hr = ppsx->AddPages(AddPropSheetPage, (LPARAM)ppsh);
            ppsx->Release();
        }
    }

    // Let the view add additional pages.  The exception will be FTP Folders because it exists to add
    // internet pages and we don't want them here.  However, if the above failed, then
    // we also want to fall back to this.  One of the cases this fixes if if the
    // browser fell back to legacy FTP support (web browser), then the above call will
    // fail on browser only, and we want to fall thru here to add the internet options.  Which
    // is appropriate for the fallback legacy FTP case because the menu will only have "Internet Options"
    // on it.
    if (FAILED(hr) || !IsBrowserFrameOptionsSet(_bbd._psf, BFO_BOTH_OPTIONS))
    {
        EVAL(SUCCEEDED(hr = _bbd._psv->AddPropertySheetPages(dwReserved, pfnAddPropSheetPage, (LPARAM)ppsh)));
    }

    return hr;
}


/***********************************************************************\
    FUNCTION: _AddInternetOptionsSheets

    DESCRIPTION:
        Add the sheets for the "Internet Options" dialog.  These sheets
    come from the browser.
\***********************************************************************/
HRESULT CBaseBrowser2::_AddInternetOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh)
{
    BOOL fPagesAdded = FALSE;
    HRESULT hr = E_FAIL;

    // HACK-HACK: On the original Win95/WinNT shell, shell32's
    //   CDefView::AddPropertySheetPages() didn't call shell
    //   extensions with SFVM_ADDPROPERTYPAGES so they could merge
    //   in additional property pages.  This works around that
    //   problem by having IShellPropSheetExt marge them in.
    //   This is only done for the FTP Folder options NSE.
    //   If other NSEs want both, we need to rewrite the menu merging
    //   code to generate the sheets by by-passing the NSE.  This
    //   is because we know what the menu says so but we don't have
    //   any way for the NSE to populate the pages with what the menu says.
    if ((WhichPlatform() != PLATFORM_INTEGRATED) &&
        IsBrowserFrameOptionsSet(_bbd._psf, (BFO_BOTH_OPTIONS)))
    {
        IShellPropSheetExt * pspse;

        hr = _bbd._psf->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));
        if (SUCCEEDED(hr))
        {
            hr = pspse->AddPages(pfnAddPropSheetPage, (LPARAM)ppsh);
            if (SUCCEEDED(hr))
                fPagesAdded = TRUE;
            pspse->Release();
        }
    }

    if (!fPagesAdded)
    {
        // Add the normal Internet Control Panel sheets. (This won't work when viewing FTP)
        if (_bbd._psvPending)
            hr = _bbd._psvPending->AddPropertySheetPages(dwReserved, pfnAddPropSheetPage, (LPARAM)ppsh);
        else
            hr = _bbd._psv->AddPropertySheetPages(dwReserved, pfnAddPropSheetPage, (LPARAM)ppsh);
    }

    return hr;
}

/***********************************************************************\
    FUNCTION: _DoOptions

    DESCRIPTION:
        The user selected either "Folder Options" or "Internet Options" from
    the View or Tools menu (or where ever it lives this week).  The logic
    in this function is a little strange because sometimes the caller doesn't
    tell us which we need to display in the pvar.  If not, we need to calculate
    what to use.
    1. If it's a URL pidl (HTTP, GOPHER, etc) then we assume it's the
       "Internet Options" dialog.  We then use psv->AddPropertySheetPages()
       to create the "Internet Options" property sheets.
    2. If it's in the shell (or FTP because it needs folder options), then
       we assume it's "Folder Options" the user selected.  In that case,
       we get the property sheets using _pbsOuter->CreateBrowserPropSheetExt().
     
    Now it gets weird.  The PMs want FTP to have both "Internet Options" and
    "Folder Options".  If the pvar param is NULL, assume it's "Folder Options".
    If it was "Internet Options" in the internet case, then I will pass an
    pvar forcing Internet Options.

    NOTE: SBO_NOBROWSERPAGES means "Folder Options".  I'm guessing browser refers
          to the original explorer browser.
\***********************************************************************/

HDPA    CBaseBrowser2::s_hdpaOptionsHwnd = NULL;

void CBaseBrowser2::_DoOptions(VARIANT* pvar)
{
    // Step 1. Determine what sheets to use.
    DWORD dwFlags = SBO_DEFAULT;
    TCHAR szCaption[MAX_PATH];
    
    if (!_bbd._psv)
        return;

    // Did the caller explicitly tell us which to use?
    if (pvar && pvar->vt == VT_I4)
        dwFlags = pvar->lVal;
    else if (_bbd._pidlCur)
    {
        // don't show the Folder Option pages if
        // 1. we're browsing the internet (excluding FTP), or
        // 2. if we're browsing a local file (not a folder), like a local .htm file.
        if (IsBrowserFrameOptionsSet(_bbd._psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET))
        {
            // SBO_NOBROWSERPAGES means don't add the "Folder Options" pages.
            dwFlags = SBO_NOBROWSERPAGES;
        }
    }
    
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE rPages[MAX_PAGES];

    psh.dwSize = SIZEOF(psh);
    psh.dwFlags = PSH_DEFAULT | PSH_USECALLBACK;
    psh.hInstance = MLGetHinst();
    psh.hwndParent = _bbd._hwnd;
    psh.pszCaption = szCaption;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;
    psh.pfnCallback = _OptionsPropSheetCallback;

    // Step 2. Now add "Internet Options" or "Folder Options" sheets.
    if (dwFlags == SBO_NOBROWSERPAGES)
    {
        // They don't want folder pages. (The used to refer to it as browser)
        EVAL(SUCCEEDED(_AddInternetOptionsSheets(0, AddPropSheetPage, &psh)));
        MLLoadString(IDS_INTERNETOPTIONS, szCaption, ARRAYSIZE(szCaption));
    }
    else
    {
        EVAL(SUCCEEDED(_AddFolderOptionsSheets(0, AddPropSheetPage, &psh)));
        MLLoadString(IDS_FOLDEROPTIONS, szCaption, ARRAYSIZE(szCaption));
    }

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    if (psh.nPages == 0)
    {
        SHRestrictedMessageBox(_bbd._hwnd);
    }
    else
    {
        // Step 3. Display the dialog
        _bbd._psv->EnableModelessSV(FALSE);
        INT_PTR iPsResult = PropertySheet(&psh);
        _SyncDPA();
        _bbd._psv->EnableModelessSV(TRUE);

        if (ID_PSREBOOTSYSTEM == iPsResult)
        {
            // The "offline folders" prop page will request a reboot if the user
            // has enabled or disabled client-side-caching.
            RestartDialog(_bbd._hwnd, NULL, EWX_REBOOT);
        }
    }
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
}

// we're here because our prop sheet just closed
// we need to purge it from the hwnd list
// check all the hwnds because 1) there's probably
// only one anyway, 2) paranoia.
void CBaseBrowser2::_SyncDPA()
{
    ENTERCRITICAL;

    if (s_hdpaOptionsHwnd != NULL)
    {
        int i, cPtr = DPA_GetPtrCount(s_hdpaOptionsHwnd);
        ASSERT(cPtr >= 0);

        // remove handles for windows which aren't there anymore
        for (i = cPtr - 1; i >= 0; i--)
        {
            HWND hwnd = (HWND)DPA_GetPtr(s_hdpaOptionsHwnd, i);
            if (!IsWindow(hwnd))
            {
                DPA_DeletePtr(s_hdpaOptionsHwnd, i);
                cPtr--;
            }
        }

        // if there aren't any windows left then clean up the hdpa
        if (cPtr == 0)
        {
            DPA_Destroy(s_hdpaOptionsHwnd);
            s_hdpaOptionsHwnd = NULL;
        }
    }

    LEAVECRITICAL;
}

int CALLBACK
CBaseBrowser2::_OptionsPropSheetCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    switch (uMsg)
    {
    case PSCB_INITIALIZED:
        {
            ENTERCRITICAL;

            if (s_hdpaOptionsHwnd == NULL)
            {
                // low mem -> Create failure -> don't track hwnd
                s_hdpaOptionsHwnd = DPA_Create(1);
            }

            if (s_hdpaOptionsHwnd != NULL)
            {
                // low mem -> AppendPtr array expansion failure -> don't track hwnd
                DPA_AppendPtr(s_hdpaOptionsHwnd, hwndDlg);
            }

            LEAVECRITICAL;
        }
        break;
    }

    return 0;
}

HRESULT CBaseBrowser2::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                  OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (rgCmds == NULL)
        return E_INVALIDARG;

    if (pguidCmdGroup == NULL)
    {
        for (ULONG i = 0 ; i < cCmds; i++)
        {
            rgCmds[i].cmdf = 0;

            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_SETDOWNLOADSTATE:
            case OLECMDID_UPDATECOMMANDS:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case OLECMDID_STOP:
            case OLECMDID_STOPDOWNLOAD:
                if (_bbd._psvPending) // pending views are stoppable
                {
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                }
                else if (_bbd._pctView) // current views may support stop also
                {
                    _bbd._pctView->QueryStatus(NULL, 1, &rgCmds[i], pcmdtext);
                }
                break;

            default:
                // set to zero above
                if (_bbd._pctView)
                {
                    // Recursion check.  Avoid looping for those command IDs where Trident bounces
                    // back up to us.
                    //
                    if (_fInQueryStatus)
                        break;
                    _fInQueryStatus = TRUE;
                    _bbd._pctView->QueryStatus(NULL, 1, &rgCmds[i], pcmdtext);
                    _fInQueryStatus = FALSE;
                }
                break;
            }
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            switch (rgCmds[i].cmdID)
            {            
            case SBCMDID_ADDTOFAVORITES:
            case SBCMDID_CREATESHORTCUT:
                rgCmds[i].cmdf = OLECMDF_ENABLED;   // support these unconditionally
                break;

            case SBCMDID_CANCELNAVIGATION:
                rgCmds[i].cmdf = _bbd._psvPending ? OLECMDF_ENABLED : 0;
                break;

            case SBCMDID_OPTIONS:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            ITravelLog *ptl;

            switch (rgCmds[i].cmdID)
            {
            case SHDVID_CANGOBACK:
                rgCmds[i].cmdf = FALSE; // Assume False 
                if (SUCCEEDED(GetTravelLog(&ptl)))
                {
                    ASSERT(ptl);
                    if (S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_BACK, NULL))
                        rgCmds[i].cmdf = TRUE;
                    ptl->Release();
                }
                break;

            case SHDVID_CANGOFORWARD:
                rgCmds[i].cmdf = FALSE; // Assume False 
                if (SUCCEEDED(GetTravelLog(&ptl)))
                {
                    ASSERT(ptl);
                    if (S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL))
                        rgCmds[i].cmdf = TRUE;
                    ptl->Release();
                }
                break;

            case SHDVID_PRINTFRAME:
            case SHDVID_MIMECSETMENUOPEN:
            case SHDVID_FONTMENUOPEN:
                if (_bbd._pctView)
                    _bbd._pctView->QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
    }
    else
    {
        return OLECMDERR_E_UNKNOWNGROUP;
    }

    return S_OK;
}

HRESULT CBaseBrowser2::_ShowBlankPage(LPCTSTR pszAboutUrl, LPCITEMIDLIST pidlIntended)
{
    // Never execute this twice.
    if (_fNavigatedToBlank) 
    {
        TraceMsg(TF_WARNING, "Re-entered CBaseBrowser2::_ShowBlankPage");
        return E_FAIL;
    }

    _fNavigatedToBlank = TRUE;

    BSTR bstrURL;
    TCHAR szPendingURL[MAX_URL_STRING + 1];
    TCHAR *pszOldUrl = NULL;
    
    szPendingURL[0] = TEXT('#');
    HRESULT hres;
    

    if (pidlIntended)
    {
        hres = ::IEGetNameAndFlags(pidlIntended, SHGDN_FORPARSING, szPendingURL + 1, SIZECHARS(szPendingURL)-1, NULL);
        if (S_OK == hres)
            pszOldUrl = szPendingURL;
    }   

    hres = CreateBlankURL(&bstrURL, pszAboutUrl, pszOldUrl);
   
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidlTemp;

        hres = IECreateFromPathW(bstrURL, &pidlTemp);
        if (SUCCEEDED(hres)) 
        {
            //
            // Note that we pass TRUE as fDontCallCancel to asynchronously
            // cancel the current view. Otherwise, we hit GPF in CDocHostObject::
            // _CancelPendingNavigation.
            //
            _NavigateToPidlAsync(pidlTemp, 0, TRUE); // takes ownership of pidl
        }

        SysFreeString(bstrURL);
    }
    return hres;
}

int CALLBACK _PunkRelease(void * p, void * pData)
{
    IUnknown* punk = (IUnknown*)p;
    punk->Release();
    return 1;
}

void CBaseBrowser2::_DLMDestroy(void)
{
    if (_hdpaDLM) 
    {
        DPA_DestroyCallback(_hdpaDLM, _PunkRelease, NULL);
        _hdpaDLM = NULL;
    }
}

HRESULT CBaseBrowser2::InitializeDownloadManager()
{
    _hdpaDLM = DPA_Create(4);
    return S_OK;
}


//
// DLM = DownLoad Manager
//
void CBaseBrowser2::_DLMUpdate(MSOCMD* prgCmd)
{
    ASSERT(prgCmd->cmdID == OLECMDID_STOPDOWNLOAD);
    for (int i = DPA_GetPtrCount(_hdpaDLM) - 1; i >= 0; i--) 
    {
        IOleCommandTarget* pcmdt = (IOleCommandTarget*)DPA_GetPtr(_hdpaDLM, i);
        prgCmd->cmdf = 0;
        pcmdt->QueryStatus(NULL, 1, prgCmd, NULL);
        if (prgCmd->cmdf & MSOCMDF_ENABLED) 
        {
            // We found one downloading guy, skip others. 
            break;
        }
        else 
        {
            // This guy is no longer busy, remove it from the list,
            // and continue. 
            DPA_DeletePtr(_hdpaDLM, i);
            pcmdt->Release();
        }
    }
}

void CBaseBrowser2::_DLMRegister(IUnknown* punk)
{
    // Check if it's already registered. 
    for (int i = 0; i < DPA_GetPtrCount(_hdpaDLM); i++) 
    {
        IOleCommandTarget* pcmdt = (IOleCommandTarget*)DPA_GetPtr(_hdpaDLM, i);
        if (IsSameObject(pcmdt, punk)) 
        {
            // Already registered, don't register.
            return;
        }
    }

    IOleCommandTarget* pcmdt;
    HRESULT hres = punk->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
    if (SUCCEEDED(hres)) 
    {
        if (DPA_AppendPtr(_hdpaDLM, pcmdt) == -1) 
        {
            pcmdt->Release();
        }
    }
}

//
// This function updates the _fDescendentNavigate flag.
//
// ALGORITHM:
//  If pvaragIn->lVal has some non-zero value, we set _fDescendentNavigate.
//  Otherwise, we ask the current view to see if it has something to stop.
// 
HRESULT CBaseBrowser2::_setDescendentNavigate(VARIANTARG *pvarargIn)
{
    ASSERT(!pvarargIn || pvarargIn->vt == VT_I4 || pvarargIn->vt == VT_BOOL || pvarargIn->vt == VT_UNKNOWN);
    if (!pvarargIn || !pvarargIn->lVal)
    {
        MSOCMD rgCmd;

        rgCmd.cmdID = OLECMDID_STOPDOWNLOAD;
        rgCmd.cmdf = 0;
        if (_bbd._pctView)
            _bbd._pctView->QueryStatus(NULL, 1, &rgCmd, NULL);

        //
        // If and only if the view says "I'm not navigating any more",
        // we'll ask the same question to each registered objects.
        //
        if (_hdpaDLM && !(rgCmd.cmdf & MSOCMDF_ENABLED)) 
        {
            _DLMUpdate(&rgCmd);
        }

        _fDescendentNavigate = (rgCmd.cmdf & MSOCMDF_ENABLED) ? TRUE:FALSE;
    }
    else
    {
        if (_hdpaDLM && pvarargIn->vt == VT_UNKNOWN) 
        {
            ASSERT(pvarargIn->punkVal);
            _DLMRegister(pvarargIn->punkVal);
        }
        _fDescendentNavigate = TRUE;
    }
    return S_OK;
}

void CBaseBrowser2::_CreateShortcutOnDesktop(IUnknown *pUnk, BOOL fUI)
{
    ISHCUT_PARAMS ShCutParams = {0};
    IWebBrowser *pwb = NULL;
    IDispatch *pdisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    LPITEMIDLIST pidlCur = NULL;
    BSTR bstrTitle = NULL;
    BSTR bstrURL = NULL;
    
    if (!fUI || (MLShellMessageBox(
                                 _bbd._hwnd,
                                 MAKEINTRESOURCE(IDS_CREATE_SHORTCUT_MSG),
                                 MAKEINTRESOURCE(IDS_TITLE),
                                 MB_OKCANCEL) == IDOK))
    {
         TCHAR szPath[MAX_PATH];
         
         if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, TRUE))
         {
            TCHAR szName[MAX_URL_STRING];
            HRESULT hr;

            if (pUnk)
            {
                hr = IUnknown_QueryService(pUnk, SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser, &pwb));
                if (hr)
                    goto Cleanup;
                
                hr = pUnk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
                if (hr)
                    goto Cleanup;
                
                hr = pDoc->get_URL(&bstrURL);
                if (hr)
                    goto Cleanup;
                
                hr = pDoc->get_title(&bstrTitle);
                if (hr)
                    goto Cleanup;
                
                if (SysStringLen(bstrTitle) == 0)
                {
                    StrCpyNW(szName, bstrURL, ARRAYSIZE(szName));
                    ShCutParams.pszTitle = PathFindFileName(szName); 
                }
                else
                {
                    StrCpyNW(szName, bstrTitle, ARRAYSIZE(szName));
                    ShCutParams.pszTitle = szName;
                }
                
                pidlCur = PidlFromUrl(bstrURL);
                if (!pidlCur)
                    goto Cleanup;
                
                ShCutParams.pidlTarget = pidlCur;
            }
            else
            {
                hr = QueryService(SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser, &pwb));
                if (hr)
                    goto Cleanup;
                
                hr = pwb->get_Document(&pdisp);
                if (hr)
                    goto Cleanup;
                
                hr = pdisp->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
                if (hr)
                    goto Cleanup;
                
                ShCutParams.pidlTarget = _bbd._pidlCur;
                if(_bbd._pszTitleCur)
                {
                    StrCpyNW(szName, _bbd._pszTitleCur, ARRAYSIZE(szName));
                    ShCutParams.pszTitle = szName;
                }
                else
                {
                    ::IEGetNameAndFlags(_bbd._pidlCur, SHGDN_INFOLDER, szName, SIZECHARS(szName), NULL);
                    ShCutParams.pszTitle = PathFindFileName(szName); 
                }
            }
            ShCutParams.pszDir = szPath; 
            ShCutParams.pszOut = NULL;
            ShCutParams.bUpdateProperties = FALSE;
            ShCutParams.bUniqueName = TRUE;
            ShCutParams.bUpdateIcon = TRUE;
            
            hr = pwb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &ShCutParams.pCommand));
            ASSERT((S_OK == hr) && (BOOLIFY(ShCutParams.pCommand)));
            if (hr)
                goto Cleanup;
            
            ShCutParams.pDoc = pDoc;
            ShCutParams.pDoc->AddRef();
            
            hr = CreateShortcutInDirEx(&ShCutParams);
            AssertMsg(SUCCEEDED(hr), TEXT("CDOH::_CSOD CreateShortcutInDir failed %x"), hr);
            if (hr)
                goto Cleanup;
         } 
         else 
         {
             TraceMsg(DM_ERROR, "CSB::_CSOD SHGetSFP(DESKTOP) failed");
         }
    }
Cleanup:
    SysFreeString(bstrTitle);
    SysFreeString(bstrURL);
    ILFree(pidlCur);
    SAFERELEASE(ShCutParams.pDoc);
    SAFERELEASE(ShCutParams.pCommand);
    SAFERELEASE(pwb);
    SAFERELEASE(pdisp);
    SAFERELEASE(pDoc);
}


void CBaseBrowser2::_AddToFavorites(LPCITEMIDLIST pidl, LPCTSTR pszTitle, BOOL fDisplayUI)
{
    HRESULT hr;
    IWebBrowser *pwb = NULL;
    IOleCommandTarget *pcmdt = NULL;

    if (SHIsRestricted2W(_bbd._hwnd, REST_NoFavorites, NULL, 0))
        return;

    hr = QueryService(SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser, &pwb));
    if (S_OK == hr)
    {
        ASSERT(pwb);

        hr = pwb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
        ASSERT((S_OK == hr) && (BOOLIFY(pcmdt)));
        
        pwb->Release();
    }

    //there's a small window where _pidlCur can be freed while AddToFavorites is coming up,
    // so use a local copy instead
    LPITEMIDLIST pidlCur = NULL;
    if (!pidl)
        pidlCur = ILClone(_bbd._pidlCur);

    if (pidl || pidlCur)
        AddToFavorites(_bbd._hwnd, pidl ? pidl : pidlCur, pszTitle, fDisplayUI, pcmdt, NULL);

    ILFree(pidlCur);

    SAFERELEASE(pcmdt);
}

HRESULT CBaseBrowser2::_OnCoCreateDocument(VARIANTARG *pvarargOut)
{
    HRESULT hres;

    //
    // Cache the class factory object and lock it (leave it loaded)
    //
    if (_pcfHTML == NULL) 
    {
        TraceMsg(DM_COCREATEHTML, "CBB::_OnCoCreateDoc called first time (this=%x)", this);
        hres = CoGetClassObject(CLSID_HTMLDocument, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                    0, IID_PPV_ARG(IClassFactory, &_pcfHTML));
        if (SUCCEEDED(hres)) 
        {
            hres = _pcfHTML->LockServer(TRUE);
            if (FAILED(hres)) 
            {
                _pcfHTML->Release();
                _pcfHTML = NULL;
                return hres;
            }
        } 
        else 
        {
            return hres;
        }
    }

    TraceMsg(DM_COCREATEHTML, "CBB::_OnCoCreateDoc creating an instance (this=%x)", this);

    hres = _pcfHTML->CreateInstance(NULL, IID_PPV_ARG(IUnknown, &pvarargOut->punkVal));
    if (SUCCEEDED(hres)) 
    {
        pvarargOut->vt = VT_UNKNOWN;
    } 
    else 
    {
        pvarargOut->vt = VT_EMPTY;
    }
    return hres;
}


// fill a buffer with a variant, return a pointer to that buffer on success of the conversion

LPCTSTR VariantToString(const VARIANT *pv, LPTSTR pszBuf, UINT cch)
{
    *pszBuf = 0;

    if (pv && pv->vt == VT_BSTR && pv->bstrVal)
    {
        StrCpyN(pszBuf, pv->bstrVal, cch);
        if (*pszBuf)
            return pszBuf;
    }
    return NULL;
}

HRESULT CBaseBrowser2::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                           VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup == NULL) 
    {
        switch(nCmdID) 
        {

        case OLECMDID_CLOSE:
            HWND hwnd;
            GetWindow(&hwnd);
            PostMessage(hwnd, WM_CLOSE, 0, 0);
            hres = S_OK;
            break;

        // CBaseBrowser2 doesn't actually do the toolbar -- itbar does, forward this
        case OLECMDID_UPDATECOMMANDS:
            _NotifyCommandStateChange();
            hres = S_OK;
            break;

        case OLECMDID_SETDOWNLOADSTATE:

            ASSERT(pvarargIn);

            if (pvarargIn) 
            {
                _setDescendentNavigate(pvarargIn);
                hres = _updateNavigationUI();              
            }
            else 
            {
                hres = E_INVALIDARG;
            }
            break;
            
        case OLECMDID_REFRESH:
            if (_bbd._pctView) // we must check!
                hres = _bbd._pctView->Exec(NULL, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            else if (_bbd._psv)
            {
                _bbd._psv->Refresh();
                hres = S_OK;
            }

            break;

        //
        //  When Exec(OLECMDID_STOP) is called either by the containee (the
        // current document) or the automation service object, we cancel
        // the pending navigation (if any), then tell the current document
        // to stop the go-going download in that page.
        //
        case OLECMDID_STOP:
            // cant stop if we are modeless
            if (S_FALSE == _DisableModeless())
            {
                LPITEMIDLIST pidlIntended = (_bbd._pidlPending) ? ILClone(_bbd._pidlPending) : NULL;
                _CancelPendingNavigation();

                // the _bbd._pctView gives us a _StopCurrentView()
                _pbsOuter->_ExecChildren(_bbd._pctView, TRUE, NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);   // Exec

                if (!_bbd._pidlCur)
                {
                    TCHAR szResURL[MAX_URL_STRING];

                    hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                             HINST_THISDLL,
                                             ML_CROSSCODEPAGE,
                                             TEXT("navcancl.htm"),
                                             szResURL,
                                             ARRAYSIZE(szResURL),
                                             TEXT("shdocvw.dll"));
                    if (SUCCEEDED(hres))
                    {
                        _ShowBlankPage(szResURL, pidlIntended);
                    }
                }

                if (pidlIntended)
                {
                    ILFree(pidlIntended);
                }
                    
            }

            hres = S_OK;
            break;

        // handled in basesb so IWebBrowser::ExecWB gets this
        // since this used to be in shbrowse, make sure we do
        // it only if _fTopBrowser
        case OLECMDID_FIND:
#ifndef UNIX

#define TBIDM_SEARCH            0x123 // defined in browseui\itbdrop.h

            // Check restriction here cuz Win95 didn't check in SHFindFiles like it now does.
            if (!SHRestricted(REST_NOFIND) && _fTopBrowser)
            {
                if (!_bbd._pctView || FAILED(_bbd._pctView->Exec(NULL, nCmdID, nCmdexecopt, pvarargIn, pvarargOut))) 
                {
                    if (GetUIVersion() >= 5 && pvarargIn)
                    {
                        if (pvarargIn->vt == VT_UNKNOWN)
                        {
                            ASSERT(pvarargIn->punkVal);

                            VARIANT  var = {0};
                            var.vt = VT_I4;
                            var.lVal = -1;
                            if (SUCCEEDED(IUnknown_Exec(pvarargIn->punkVal, &CLSID_CommonButtons, TBIDM_SEARCH, 0, NULL, &var)))
                                break;
                        }
                    }
                    SHFindFiles(_bbd._pidlCur, NULL);
                }
            }
#endif
            break;

        case OLECMDID_HTTPEQUIV_DONE:
        case OLECMDID_HTTPEQUIV:
            hres = OnHttpEquiv(_bbd._psv, (OLECMDID_HTTPEQUIV_DONE == nCmdID), pvarargIn, pvarargOut);
            break;

        case OLECMDID_PREREFRESH:
            // Tell the shell's HTML window we have a new document
            // Fall through default
            if (_phtmlWS)
            {
                _phtmlWS->ViewActivated();
            }

        // Binder prints by reflecting the print back down. do the same here
        // Note: we may want to do the same for _PRINTPREVIEW, _PROPERTIES, _STOP, etc.
        // The null command group should all go down, no need to stop these at the pass.
        default:
            if (_bbd._pctView) // we must check!
                hres = _bbd._pctView->Exec(NULL, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            else
                hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
    {
        if (_bbd._pctView) // we must check!
            hres = _bbd._pctView->Exec(&CGID_MSHTML, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        else
            hres = OLECMDERR_E_NOTSUPPORTED;
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SBCMDID_CREATESHORTCUT:
            if (   pvarargIn
                && (V_VT(pvarargIn) == VT_UNKNOWN)
               )
            {
                _CreateShortcutOnDesktop(V_UNKNOWN(pvarargIn), nCmdexecopt & OLECMDEXECOPT_PROMPTUSER);
            }
            else
            {
                _CreateShortcutOnDesktop(NULL, nCmdexecopt & OLECMDEXECOPT_PROMPTUSER);
            }
            hres = S_OK;
            break;

        case SBCMDID_ADDTOFAVORITES:
            {
                LPITEMIDLIST pidl = NULL;

                //if someone doesn't pass a path in, _AddToFavorites will use the current page
                if ((pvarargIn != NULL) && (pvarargIn->vt == VT_BSTR))
                    IECreateFromPath(pvarargIn->bstrVal, &pidl);
                
                TCHAR szTitle[128];
                LPTSTR pszTitle = NULL;
                if (pvarargOut)
                    pszTitle = (LPTSTR)VariantToString(pvarargOut, szTitle, ARRAYSIZE(szTitle)); // may be NULL
                else
                {
                    if (_bbd._pszTitleCur)
                        pszTitle = StrCpyNW(szTitle, _bbd._pszTitleCur, ARRAYSIZE(szTitle));
                }

                _AddToFavorites(pidl, pszTitle, nCmdexecopt & OLECMDEXECOPT_PROMPTUSER);

                if (pidl)
                    ILFree(pidl);
                hres = S_OK;
            }
            break;

        case SBCMDID_OPTIONS:
            _DoOptions(pvarargIn);
            break;

        case SBCMDID_CANCELNAVIGATION:

            TraceMsg(DM_NAV, "ief NAV::%s called when _bbd._pidlCur==%x, _bbd._psvPending==%x",
                             TEXT("Exec(SBCMDID_CANCELNAV) called"),
                             _bbd._pidlCur, _bbd._psvPending);

            // Check if this is sync or async
            if (pvarargIn && pvarargIn->vt == VT_I4 && pvarargIn->lVal) 
            {
                TraceMsg(DM_WEBCHECKDRT, "CBB::Exec calling _CancelPendingNavigation");
                _CancelPendingNavigation();
            }
            else
            {
                //
                //  We must call ASYNC version in this case because this call
                // is from the pending view itself.
                //
                LPITEMIDLIST pidlIntended = (_bbd._pidlPending) ? ILClone(_bbd._pidlPending) : NULL;
                _CancelPendingNavigationAsync();

                if (!_bbd._pidlCur)
                {
                    if (!_fDontShowNavCancelPage)
                    {
                        TCHAR szResURL[MAX_URL_STRING];

                        if (IsGlobalOffline())
                        {
                            hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                     HINST_THISDLL,
                                                     ML_CROSSCODEPAGE,
                                                     TEXT("offcancl.htm"),
                                                     szResURL,
                                                     ARRAYSIZE(szResURL),
                                                     TEXT("shdocvw.dll"));
                            if (SUCCEEDED(hres))
                            {
                                _ShowBlankPage(szResURL, pidlIntended);
                            }
                        }
                        else
                        {
                            hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                     HINST_THISDLL,
                                                     ML_CROSSCODEPAGE,
                                                     TEXT("navcancl.htm"),
                                                     szResURL,
                                                     ARRAYSIZE(szResURL),
                                                     TEXT("shdocvw.dll"));
                            if (SUCCEEDED(hres))
                            {
                                _ShowBlankPage(szResURL, pidlIntended);
                            }
                        }
                    }
                    else
                    {
                        _fDontShowNavCancelPage = FALSE;
                    }
                }

                if (pidlIntended)
                    ILFree(pidlIntended);
            }
            hres = S_OK;
            break;

        case SBCMDID_ASYNCNAVIGATION:

            TraceMsg(DM_NAV, "ief NAV::%s called when _bbd._pidlCur==%x, _bbd._psvPending==%x",
                             TEXT("Exec(SBCMDID_ASYNCNAV) called"),
                             _bbd._pidlCur, _bbd._psvPending);

            //
            //  We must call ASYNC version in this case because this call
            // is from the pending view itself.
            //
            _SendAsyncNavigationMsg(pvarargIn);
            hres = S_OK;
            break;


        case SBCMDID_COCREATEDOCUMENT:
            hres = _OnCoCreateDocument(pvarargOut);
            break;

        case SBCMDID_HISTSFOLDER:
            if (pvarargOut) 
            {
                VariantClearLazy(pvarargOut);
                if (NULL == _punkSFHistory)
                {
                    IHistSFPrivate *phsfHistory;

                    hres = LoadHistoryShellFolder(NULL, &phsfHistory);
                    if (SUCCEEDED(hres))
                    {
                        hres = phsfHistory->QueryInterface(IID_PPV_ARG(IUnknown, &_punkSFHistory));
                        phsfHistory->Release();
                    }
                }
                if (NULL != _punkSFHistory)
                {
                    pvarargOut->vt = VT_UNKNOWN;
                    pvarargOut->punkVal = _punkSFHistory;
                    _punkSFHistory->AddRef();
                }
            }
            break;

        case SBCMDID_UPDATETRAVELLOG:
            {
                BOOL fForceUpdate = FALSE;

                if (pvarargIn && (VT_I4 == V_VT(pvarargIn)))
                {
                    _fIsLocalAnchor = !!(V_I4(pvarargIn) & TRAVELLOG_LOCALANCHOR);
                    fForceUpdate = !!(V_I4(pvarargIn) & TRAVELLOG_FORCEUPDATE);
                }

                _UpdateTravelLog(fForceUpdate);
            }
            // fall through

        case SBCMDID_REPLACELOCATION:
            if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                WCHAR wzParsedUrl[MAX_URL_STRING];
                LPWSTR  pszUrl = pvarargIn->bstrVal;
                LPITEMIDLIST pidl;

                // BSTRs can be NULL.
                if (!pszUrl)
                    pszUrl = L"";

                // NOTE: This URL came from the user, so we need to clean it up.
                //       If the user entered "yahoo.com" or "Search Get Rich Quick",
                //       it will be turned into a search URL by ParseURLFromOutsideSourceW().
                DWORD cchParsedUrl = ARRAYSIZE(wzParsedUrl);
                if (!ParseURLFromOutsideSourceW(pszUrl, wzParsedUrl, &cchParsedUrl, NULL))
                {
                    StrCpyN(wzParsedUrl, pszUrl, ARRAYSIZE(wzParsedUrl));
                } 

                IEParseDisplayName(CP_ACP, wzParsedUrl, &pidl);
                if (pidl)
                {
                    NotifyRedirect(_bbd._psv, pidl, NULL);
                    ILFree(pidl);
                }
            }

            // even if there was no url, still force no refresh.
            _fGeneratedPage = TRUE;
            
            //  force updating the back and forward buttons
            _pbsOuter->UpdateBackForwardState();
            hres = S_OK;
            break;

        case SBCMDID_ONCLOSE:
            hres = S_OK;

            if (_bbd._pctView)
            {
                hres = _bbd._pctView->Exec(pguidCmdGroup, nCmdID, 0, NULL, NULL);
            }

            break;

        case SBCMDID_SETSECURELOCKICON:
            {
                //  if this is a SET, then just obey.
                LONG lock = pvarargIn->lVal;
                TraceMsg(DM_SSL, "SB::Exec() SETSECURELOCKICON lock = %d", lock);

                if (lock >= SECURELOCK_FIRSTSUGGEST)
                {
                    //
                    //  if this was ever secure, then the lowest we can be
                    //  suggested to is MIXED.  otherwise we just choose the 
                    //  lowest level of security suggested.
                    //
                    if ((lock == SECURELOCK_SUGGEST_UNSECURE) && 
                        (_bbd._eSecureLockIcon != SECURELOCK_SET_UNSECURE))
                    {
                        lock = SECURELOCK_SET_MIXED;
                    }
                    else
                    {
                        lock = min(lock - SECURELOCK_FIRSTSUGGEST, _bbd._eSecureLockIcon);
                    }
                }

                UpdateSecureLockIcon(lock);
                hres = S_OK;
            }
            break;

        default:
            hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SHDVID_GOBACK:
            hres = _psbOuter->BrowseObject(NULL, SBSP_NAVIGATEBACK);
            break;

        case SHDVID_GOFORWARD:
            hres = _psbOuter->BrowseObject(NULL, SBSP_NAVIGATEFORWARD);
            break;

        // we reflect AMBIENTPROPCHANGE down because this is how iedisp notifies dochost
        // that an ambient property has changed. we don't need to reflect this down in
        // cwebbrowsersb because only the top-level iwebbrowser2 is allowed to change props
        case SHDVID_AMBIENTPROPCHANGE:
        case SHDVID_PRINTFRAME:
        case SHDVID_MIMECSETMENUOPEN:
        case SHDVID_FONTMENUOPEN:
        case SHDVID_DOCFAMILYCHARSET:
            if (_bbd._pctView) // we must check!
            {
                hres = _bbd._pctView->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            else
                hres = E_FAIL;
            break;

        case SHDVID_DEACTIVATEMENOW:
            if (!_bbd._psvPending)
            {
                hres = S_OK;
                break;
            }
            //  fall through to activate new view
#ifdef FEATURE_PICS
        case SHDVID_ACTIVATEMENOW:
#endif
            if (   pvarargIn
                && (VT_BOOL == V_VT(pvarargIn))
                && (VARIANT_TRUE == V_BOOL(pvarargIn)))  // Synchronous
            {
                if (_bbd._psvPending)
                {
                    ASSERT(_pbsOuter);
                    _pbsOuter->ActivatePendingView();
                }
            }
            else  // Asynchronous
            {
                _ActivatePendingViewAsync();
            }

            hres = S_OK;
            break;


        case SHDVID_GETPENDINGOBJECT:
            ASSERT( pvarargOut);
            if (_bbd._psvPending && ((pvarargIn && pvarargIn->vt == VT_BOOL && pvarargIn->boolVal) || !_bbd._psv))
            {
                VariantClearLazy(pvarargOut);
                _bbd._psvPending->QueryInterface(IID_PPV_ARG(IUnknown, &pvarargOut->punkVal));
                if (pvarargOut->punkVal) pvarargOut->vt = VT_UNKNOWN;
            }
            hres = (pvarargOut->punkVal == NULL) ? E_FAIL : S_OK;
            break;

 
        case SHDVID_SETPRINTSTATUS:
            if (pvarargIn && pvarargIn->vt == VT_BOOL)
            {
                VARIANTARG var = {0};
                if (_bbd._pctView && SUCCEEDED(_bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_PRINTER, NULL, &var))
                     && V_UI4(&var) != PANE_NONE)
                {
                    _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var), 
                                  (LPARAM)(pvarargIn->boolVal ? g_hiconPrinter : NULL), NULL);
                    // we're putting the printer icon and the offline icon in the same
                    // slot on the status bar, so when we turn off the printer icon
                    // we have to check to see if we're offline so we can put the offline
                    // icon back
                    if (!pvarargIn->boolVal && IsGlobalOffline())
                    {
#ifdef DEBUG
                        VARIANTARG var2 = {0};
                        _bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_OFFLINE, NULL, &var2);
                        ASSERT(V_UI4(&var2) == V_UI4(&var));
#endif DEBUG
                        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var),
                                                  (LPARAM)(g_hiconOffline), NULL);
                    } // if (!pvarargIn->boolVal && IsGlobalOffline())
                }
                hres = S_OK;
            }
            else
                hres = E_INVALIDARG;
            break;

#ifdef FEATURE_PICS
        /* Dochost sends up this command to have us put up the PICS access
         * denied dialog.  This is done so that all calls to this ratings
         * API are modal to the top-level browser window;  that in turn
         * lets the ratings code coalesce denials for all subframes into
         * a single dialog.
         */
        case SHDVID_PICSBLOCKINGUI:
            {
                void * pDetails;
                if (pvarargIn && pvarargIn->vt == VT_INT_PTR)
                    pDetails = pvarargIn->byref;
                else
                    pDetails = NULL;
                TraceMsg(DM_PICS, "CBaseBrowser2::Exec calling RatingAccessDeniedDialog2");
                /**
                 * We QueryService for an SID_IRatingNotification which is
                 * implemented by our host, if we find it, instead of 
                 * displaying the modal ratings dialog, we notify our host through
                 * the interface and allow it to make the decision
                 */
                IRatingNotification* pRatingNotify;
                hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));
                if (SUCCEEDED(hres))
                {
                    RATINGBLOCKINGINFO* pRBInfo = NULL;
                    TraceMsg(DM_PICS, "CBaseBrowser2::Exec calling RatingMarsCrackData");
                    hres = RatingCustomCrackData(NULL, pDetails, &pRBInfo);
                    if (SUCCEEDED(hres))
                    {
                        hres = pRatingNotify->AccessDeniedNotify(pRBInfo);
                        RatingCustomDeleteCrackedData(pRBInfo);
                    }
                    pRatingNotify->Release();
                } // if (SUCCEEDED(hres))
                else {
                    hres = RatingAccessDeniedDialog2(_bbd._hwnd, NULL, pDetails);
                }
            }
            break;
#endif

       case SHDVID_ONCOLORSCHANGE:
            // PALETTE:
            // PALETTE: recompute our palette
            // PALETTE:
            _ColorsDirty(BPT_UnknownPalette);
            break;

        case SHDVID_GETOPTIONSHWND:
        {
            ASSERT(pvarargOut != NULL);
            ASSERT(V_VT(pvarargOut) == VT_BYREF);


            // return the hwnd for the inet options
            // modal prop sheet. we're tracking
            // this hwnd because if it's open
            // and plugUI shutdown needs to happen,
            // that dialog needs to receive a WM_CLOSE
            // before we can nuke it

            hres = E_FAIL;

            // is there a list of window handles?

            ENTERCRITICAL;

            if (s_hdpaOptionsHwnd != NULL)
            {
                int cPtr = DPA_GetPtrCount(s_hdpaOptionsHwnd);
                // is that list nonempty?
                if (cPtr > 0)
                {
                    HWND hwndOptions = (HWND)DPA_GetPtr(s_hdpaOptionsHwnd, 0);
                    ASSERT(hwndOptions != NULL);

                    pvarargOut->byref = hwndOptions;

                    // remove it from the list
                    // that hwnd is not our responsibility anymore
                    DPA_DeletePtr(s_hdpaOptionsHwnd, 0);

                    // successful hwnd retrieval
                    hres = S_OK;
                }
            }

            LEAVECRITICAL;
        }
        break;

        case SHDVID_DISPLAYSCRIPTERRORS:
        {
            HRESULT hr;

            hr = _bbd._pctView->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

            return hr;
        }
        break;

        case SHDVID_NAVIGATEFROMDOC:  // The document called Navigate
            _dwDocFlags |= DOCFLAG_NAVIGATEFROMDOC;
            return S_OK;

        case SHDVID_SETNAVIGATABLECODEPAGE:
            _dwDocFlags |= DOCFLAG_SETNAVIGATABLECODEPAGE;
            return S_OK;

        case SHDVID_CHECKINCACHEIFOFFLINE:
            {
                if (pvarargIn && (VT_BSTR == V_VT(pvarargIn)) && V_BSTR(pvarargIn)
                    && pvarargOut && (VT_BOOL == V_VT(pvarargOut)))
                {
                    LPITEMIDLIST pidl = PidlFromUrl(V_BSTR(pvarargIn));
                    if (pidl)
                    {
                        // (scotrobe): We should be passing fIsPost
                        // into _CheckInCacheIfOffline. 
                        //
                        V_BOOL(pvarargOut) = (S_OK == _CheckInCacheIfOffline(pidl, FALSE));
                        ILFree(pidl);

                        return S_OK;
                    }
                }
                return E_FAIL;
            }
            break;

        case SHDVID_CHECKDONTUPDATETLOG:
            {
                if (pvarargOut)
                    {
                    V_VT(pvarargOut) = VT_BOOL;
                    V_BOOL(pvarargOut) = (_fDontAddTravelEntry ? VARIANT_TRUE : VARIANT_FALSE);
                    hres = S_OK;
                    }
                break;
            }

        case SHDVID_FIREFILEDOWNLOAD:
            if (pvarargOut)
            {
                BOOL fCancel = FALSE;

                V_VT(pvarargOut) = VT_BOOL;

                FireEvent_FileDownload(_bbd._pautoEDS, &fCancel, pvarargIn ? V_BOOL(pvarargIn):VARIANT_FALSE);
                pvarargOut->boolVal = (fCancel ? VARIANT_TRUE : VARIANT_FALSE);
                hres = S_OK;
            }
            break;

        default:
            hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShortCut, *pguidCmdGroup))
    {
        if (_bbd._pctView) // we must check!
            hres = _bbd._pctView->Exec(&CGID_ShortCut, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        else
            hres = OLECMDERR_E_NOTSUPPORTED;
    } 
    else if (IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case DOCHOST_DOCCANNAVIGATE:
            if (pvarargIn && VT_UNKNOWN == V_VT(pvarargIn) && V_UNKNOWN(pvarargIn))
            {
                _dwDocFlags |= DOCFLAG_DOCCANNAVIGATE;
            }
            else
            {
                _dwDocFlags &= ~DOCFLAG_DOCCANNAVIGATE;                
            }

            hres = S_OK;
            break;

        case DOCHOST_SETBROWSERINDEX:
            if (pvarargIn && VT_I4 == V_VT(pvarargIn))
            {
                _dwBrowserIndex = V_I4(pvarargIn);
                return S_OK;
            }

            return E_INVALIDARG;

        default:
            hres = OLECMDERR_E_UNKNOWNGROUP;  // Backwards compatability
            break;
        }
    }
    else if (IsEqualGUID(CGID_InternetExplorer, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case IECMDID_BEFORENAVIGATE_GETSHELLBROWSE:
            {
                // true if pending navigate is NOT a web navigation.
                if (pvarargOut && _pidlBeforeNavigateEvent)
                {
                    DWORD dwAttributes = SFGAO_FOLDER;
                    hres = IEGetAttributesOf(_pidlBeforeNavigateEvent, &dwAttributes);

                    V_VT(pvarargOut) = VT_BOOL;
                    V_BOOL(pvarargOut) = SUCCEEDED(hres) && (dwAttributes & SFGAO_FOLDER) ?
                         VARIANT_TRUE : VARIANT_FALSE;
                    hres = S_OK;
                }
            }
            break;


        case IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE:
            {
                if (_pidlBeforeNavigateEvent)
                {                  
                    hres = _psbOuter->BrowseObject(_pidlBeforeNavigateEvent, SBSP_ABSOLUTE | SBSP_NEWBROWSER);
                }
            }
            break;

        case IECMDID_BEFORENAVIGATE_GETIDLIST:
            {
                if (pvarargOut && _pidlBeforeNavigateEvent)
                {                  
                    hres = InitVariantFromIDList(pvarargOut, _pidlBeforeNavigateEvent);
                }
            }
            break;

        default:
            hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
    {
        hres = OLECMDERR_E_UNKNOWNGROUP;
    }
    return hres;
}

LPITEMIDLIST
CBaseBrowser2::PidlFromUrl(BSTR bstrUrl)
{
    LPITEMIDLIST pidl = NULL;

    ASSERT(bstrUrl);

    IEParseDisplayNameWithBCW(CP_ACP, bstrUrl, NULL, &pidl);

    // IEParseDisplayNameWithBCW will return a null pidl if 
    // the URL has any kind of fragment identifier at the
    // end - #, ? =, etc.
    //    
    if (!pidl) 
    {
        TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];
        DWORD cchBuf = ARRAYSIZE(szPath);

        // If it's a FILE URL, convert it to a path.
        //
        if (IsFileUrlW(bstrUrl) && SUCCEEDED(PathCreateFromUrl(bstrUrl, szPath, &cchBuf, 0)))
        {
            // That worked, we are done because our buffer is now full.
        }
        else        
        {
            // We now need to copy to the buffer and we assume it's a path.
            //
            StrCpyN(szPath, bstrUrl, ARRAYSIZE(szPath));
        }

        pidl = SHSimpleIDListFromPath(szPath);
    }

    return pidl;
}

BSTR
CBaseBrowser2::GetHTMLWindowUrl(IHTMLWindow2 * pHTMLWindow)
{
    BSTR bstrUrl = NULL;
    IHTMLPrivateWindow * pPrivateWindow;

    ASSERT(pHTMLWindow);

    HRESULT hr = pHTMLWindow->QueryInterface(IID_PPV_ARG(IHTMLPrivateWindow, &pPrivateWindow));

    if (SUCCEEDED(hr))
    {
        pPrivateWindow->GetAddressBarUrl(&bstrUrl);
        pPrivateWindow->Release();
    }

    return bstrUrl;
}

LPITEMIDLIST
CBaseBrowser2::_GetPidlForDisplay(BSTR bstrUrl, BOOL * pfIsErrorUrl /* = NULL */)
{
    BOOL fIsErrorUrl  = FALSE;
    LPITEMIDLIST pidl = NULL;

    if (bstrUrl)
    {
        fIsErrorUrl = ::IsErrorUrl(bstrUrl);
        if (!fIsErrorUrl)
        {
            pidl = PidlFromUrl(bstrUrl);
        }
        else
        {
            int    nScheme;
            LPWSTR pszFragment = NULL;

            // Only strip the anchor fragment if it's not JAVASCRIPT: or VBSCRIPT:, because a # could not an
            // anchor but a string to be evaluated by a script engine like #00ff00 for an RGB color.
            //
            nScheme = GetUrlSchemeW(bstrUrl);      
            if (nScheme != URL_SCHEME_JAVASCRIPT && nScheme != URL_SCHEME_VBSCRIPT)
            {
                //  Locate local anchor fragment if possible
                //
                pszFragment = StrChr(bstrUrl, L'#');
            }

            // It is possible to have a fragment identifier 
            // with no corresponding fragment.
            //
            if (pszFragment && lstrlen(pszFragment) > 1)
            {
                BSTR bstrTemp = SysAllocString(pszFragment+1);

                if (bstrTemp)
                {
                    pidl = PidlFromUrl(bstrTemp);
                    SysFreeString(bstrTemp);
                }
            }
        }
    }

    if (pfIsErrorUrl)
        *pfIsErrorUrl = fIsErrorUrl;

    return pidl;
}

HRESULT CBaseBrowser2::ParseDisplayName(IBindCtx *pbc, LPOLESTR pszDisplayName,
        ULONG *pchEaten, IMoniker **ppmkOut)
{

    TraceMsg(0, "sdv TR ::ParseDisplayName called");
    *ppmkOut = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::EnumObjects( DWORD grfFlags, IEnumUnknown **ppenum)
{
    TraceMsg(0, "sdv TR ::EnumObjects called");
    *ppenum = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::LockContainer( BOOL fLock)
{
    TraceMsg(0, "sdv TR ::LockContainer called");
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::SetTitle(IShellView* psv, LPCWSTR lpszName)
{
    LPWSTR *ppszName = NULL;
    BOOL fFireEvent = FALSE;
    LPITEMIDLIST pidl;

    // We need to forward title changes on to the automation interface.
    // But since title changes can technically occur at any time we need
    // to distinguish between current and pending title changes and only
    // pass on the current title change now. We'll pass on the pending
    // title change at NavigateComplete time. (This also lets us identify
    // when we navigate to non-SetTitle object (such as the shell) and
    // simulate a TitleChange event.)
    //
    // Since the DocObjectHost needs to retrieve the title later, we
    // hold onto the current view's title change so they don't have to.
    //

    // Figure out which object is changing.
    //
    if (IsSameObject(_bbd._psv, psv))
    {
        ppszName = &_bbd._pszTitleCur;
        pidl = _bbd._pidlCur;
        fFireEvent = TRUE;
    }
    else if (EVAL(IsSameObject(_bbd._psvPending, psv) || !_bbd._psvPending)) // no pending probably means we're in _MayPlayTransition
    {
        ppszName = &_bbd._pszTitlePending;
        pidl = _bbd._pidlPending;
        // If we have no current guy, might as well set the title early
        fFireEvent = !_bbd._psv;
    }
    else
    {
        ppszName = NULL;
        pidl = NULL;        // init pidl to suppress bogus C4701 warning
    }

    if (ppszName)
    {
        UINT cchLen = lstrlenW(lpszName) + 1; // +1 for NULL
        UINT cbAlloc;

        // For some reason we cap the length of this string. We can't cap
        // less than MAX_PATH because we need to handle filesys names.
        //
        if (cchLen > MAX_PATH)
            cchLen = MAX_PATH;

        // We want to allocate at least a medium size string because
        // many web pages script the title one character at a time.
        //
#define MIN_TITLE_ALLOC  64
        if (cchLen < MIN_TITLE_ALLOC)
            cbAlloc = MIN_TITLE_ALLOC * SIZEOF(*lpszName);
        else
            cbAlloc = cchLen * SIZEOF(*lpszName);
#undef  MIN_TITLE_ALLOC

        // Do we need to allocate?
        if (!(*ppszName) || LocalSize((HLOCAL)(*ppszName)) < cbAlloc)
        {
            // Free up Old Title
            if(*ppszName)
                LocalFree((void *)(*ppszName));
                
            *ppszName = (LPWSTR)LocalAlloc(LPTR, cbAlloc);
        }

        if (*ppszName)
        {
            StrCpyNW(*ppszName, lpszName, cchLen);

            if (fFireEvent)
            {
                DWORD dwOptions;

                FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, *ppszName);

                // If this is a desktop component, try to update the friendly name if necessary.
                if (!_fCheckedDesktopComponentName)
                {
                    _fCheckedDesktopComponentName = TRUE;
                    if (SUCCEEDED(GetTopFrameOptions(_pspOuter, &dwOptions)) && (dwOptions & FRAMEOPTIONS_DESKTOP))
                    {
                        WCHAR wszPath[MAX_URL_STRING];
                        if (SUCCEEDED(::IEGetDisplayName(pidl, wszPath, SHGDN_FORPARSING)))
                        {
                            UpdateDesktopComponentName(wszPath, lpszName);
                        }
                    }
                }
            }
        }
    }

    return NOERROR;
}
HRESULT CBaseBrowser2::GetTitle(IShellView* psv, LPWSTR pszName, DWORD cchName)
{
    LPWSTR psz;

    if (!psv || IsSameObject(_bbd._psv, psv))
    {
        psz = _bbd._pszTitleCur;
    }
    else if (EVAL(IsSameObject(_bbd._psvPending, psv) || !_bbd._psvPending))
    {
        psz = _bbd._pszTitlePending;
    }
    else
    {
        psz = NULL;
    }

    if (psz)
    {
        StrCpyNW(pszName, psz, cchName);
        return(S_OK);
    }
    else
    {
        *pszName = 0;
        return(E_FAIL);
    }
}

HRESULT CBaseBrowser2::GetParentSite(struct IOleInPlaceSite** ppipsite)
{
    *ppipsite = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::GetOleObject(struct IOleObject** ppobjv)
{
    *ppobjv = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::NotifyRedirect(IShellView * psv, LPCITEMIDLIST pidlNew, BOOL *pfDidBrowse)
{
    HRESULT hres = E_FAIL;
    
    if (pfDidBrowse)
        *pfDidBrowse = FALSE;

    if (IsSameObject(psv, _bbd._psv) ||
        IsSameObject(psv, _bbd._psvPending))
    {
        hres = _pbsOuter->_TryShell2Rename(psv, pidlNew);
        if (FAILED(hres)) 
        {
            // if we weren't able to just swap it, we've got to browse to it
            // but pass redirect so that we don't add a navigation stack item
            //
            // NOTE: the above comment is a bit old since we don't pass
            // redirect here. If we ever start passing redirect here,
            // we'll confuse ISVs relying on the NavigateComplete event
            // exactly mirroring when navigations enter the navigation stack.
            //
            hres = _psbOuter->BrowseObject(pidlNew, SBSP_WRITENOHISTORY | SBSP_SAMEBROWSER);

            if(pfDidBrowse)
                *pfDidBrowse = TRUE;
        }
    }

    return hres;
}

HRESULT CBaseBrowser2::SetFlags(DWORD dwFlags, DWORD dwFlagMask)
{
    if (dwFlagMask & BSF_REGISTERASDROPTARGET)
    {
        _fNoDragDrop = (!(dwFlags & BSF_REGISTERASDROPTARGET)) ? TRUE : FALSE;

        if (!_fNoDragDrop)
            _RegisterAsDropTarget();
        else
            _UnregisterAsDropTarget();
    }
    
    if (dwFlagMask & BSF_DONTSHOWNAVCANCELPAGE)
    {
        _fDontShowNavCancelPage = !!(dwFlags & BSF_DONTSHOWNAVCANCELPAGE);
    }

    if (dwFlagMask & BSF_HTMLNAVCANCELED)
    {
        _fHtmlNavCanceled = !!(dwFlags & BSF_HTMLNAVCANCELED);
    }

    return S_OK;
}

HRESULT CBaseBrowser2::GetFlags(DWORD *pdwFlags)
{
    DWORD dwFlags = 0;

    if (!_fNoDragDrop)
        dwFlags |= BSF_REGISTERASDROPTARGET;
        
    if (_fTopBrowser)
        dwFlags |= BSF_TOPBROWSER;

    if (_grfHLNFPending & HLNF_CREATENOHISTORY)
        dwFlags |= BSF_NAVNOHISTORY;

    if (_fHtmlNavCanceled)
        dwFlags |= BSF_HTMLNAVCANCELED;
    
    if (_dwDocFlags & DOCFLAG_SETNAVIGATABLECODEPAGE)
        dwFlags |= BSF_SETNAVIGATABLECODEPAGE;

    if (_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC)
        dwFlags |= BSF_DELEGATEDNAVIGATION;

    *pdwFlags = dwFlags;

    return S_OK;
}


HRESULT CBaseBrowser2::UpdateWindowList(void)
{
    // code used to assert, but in WebBrowserOC cases we can get here.
    return E_UNEXPECTED;
}

STDMETHODIMP CBaseBrowser2::IsControlWindowShown(UINT id, BOOL *pfShown)
{
    if (pfShown)
        *pfShown = FALSE;
    return E_NOTIMPL;
}

STDMETHODIMP CBaseBrowser2::ShowControlWindow(UINT id, BOOL fShow)
{
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags)
{
    return ::IEGetDisplayName(pidl, pwszName, uFlags);
}

HRESULT CBaseBrowser2::IEParseDisplayName(UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut)
{
    HRESULT hr;
    IBindCtx * pbc = NULL;    
    WCHAR wzParsedUrl[MAX_URL_STRING];

    //
    // if we can find a search context living in a host somewhere,
    // then we need to pass that into ParseUrlFromOutsideSource
    // because it'll use it to customize the behavior of
    // the search hooks if a search ends up happening
    //

    ISearchContext *  pSC = NULL;
    QueryService(SID_STopWindow, IID_ISearchContext, (void **)&pSC);

    //
    // NOTE: This URL came from the user, so we need to clean it up.
    //       If the user entered "yahoo.com" or "Search Get Rich Quick",
    //       it will be turned into a search URL by ParseURLFromOutsideSourceW().
    //

    DWORD cchParsedUrl = ARRAYSIZE(wzParsedUrl);
    if (!ParseURLFromOutsideSourceWithContextW(pwszPath, wzParsedUrl, &cchParsedUrl, NULL, pSC))
    {
        StrCpyN(wzParsedUrl, pwszPath, ARRAYSIZE(wzParsedUrl));
    } 

    if (pSC != NULL)
    {
        pSC->Release();
    }

    // This is currently used for FTP, so we only do it for FTP for perf reasons.
    if (URL_SCHEME_FTP == GetUrlSchemeW(wzParsedUrl))
        pbc = CreateBindCtxForUI(SAFECAST(this, IOleContainer *));  // We really want to cast to (IUnknown *) but that's ambiguous.
    
    hr = IEParseDisplayNameWithBCW(uiCP, wzParsedUrl, pbc, ppidlOut);
    ATOMICRELEASE(pbc);

    return hr;
}

HRESULT _DisplayParseError(HWND hwnd, HRESULT hres, LPCWSTR pwszPath)
{
    if (FAILED(hres)
        && hres != E_OUTOFMEMORY
        && hres != HRESULT_FROM_WIN32(ERROR_CANCELLED))
    {
        TCHAR szPath[MAX_URL_STRING];
        SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath));
        MLShellMessageBox(hwnd,
                        MAKEINTRESOURCE(IDS_ERROR_GOTO),
                        MAKEINTRESOURCE(IDS_TITLE),
                        MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                        szPath);

        hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    return hres;
}

HRESULT CBaseBrowser2::DisplayParseError(HRESULT hres, LPCWSTR pwszPath)
{
    return _DisplayParseError(_bbd._hwnd, hres, pwszPath);
}

HRESULT CBaseBrowser2::_CheckZoneCrossing(LPCITEMIDLIST pidl)
{
    if (!(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC))
    {
        return _pbsOuter->v_CheckZoneCrossing(pidl);
    }

    return S_OK;
}


// if in global offline mode and this item requires net access and it is
// not in the cache put up UI to go online.
//
// returns:
//      S_OK        URL is ready to be accessed
//      E_ABORT     user canceled the UI

HRESULT CBaseBrowser2::_CheckInCacheIfOffline(LPCITEMIDLIST pidl, BOOL fIsAPost)
{
    HRESULT hr = S_OK;      // assume it is
    VARIANT_BOOL fFrameIsSilent;
    VARIANT_BOOL fFrameHasAmbientOfflineMode;

    EVAL(SUCCEEDED(_bbd._pautoWB2->get_Silent(&fFrameHasAmbientOfflineMode)));    // should always work

    EVAL(SUCCEEDED(_bbd._pautoWB2->get_Offline(&fFrameIsSilent)));   
    if ((fFrameIsSilent == VARIANT_FALSE) &&
        (fFrameHasAmbientOfflineMode == VARIANT_FALSE)&&
        pidl && (pidl != PIDL_NOTHING) && (pidl != PIDL_LOCALHISTORY) && 
        IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_IE_OFFLINE_SUPPORT) && 
        IsGlobalOffline()) 
    {
        TCHAR szURL[MAX_URL_STRING];
        EVAL(SUCCEEDED(::IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szURL, SIZECHARS(szURL), NULL)));

        if (UrlHitsNet(szURL) && ((!UrlIsMappedOrInCache(szURL)) || fIsAPost))
        {
            // UI to allow user to go on-line
            HWND hParentWnd = NULL; // init to suppress bogus C4701 warning

            hr = E_FAIL;
            if(!_fTopBrowser)
            {
               IOleWindow *pOleWindow;
               hr = _pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
               if(SUCCEEDED(hr))
               { 
                    ASSERT(pOleWindow);
                    hr = pOleWindow->GetWindow(&hParentWnd);
                    pOleWindow->Release();
               }
            }
            
            if (S_OK != hr)
            {
                hr = S_OK;
                hParentWnd = _bbd._hwnd;
            }


            _psbOuter->EnableModelessSB(FALSE);
            if (InternetGoOnline(szURL, hParentWnd, FALSE))
            {
                // Tell all browser windows to update their title and status pane
                SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000); 
            }    
            else
                hr = E_ABORT;   // user abort case...

            _psbOuter->EnableModelessSB(TRUE);
        }
    }

    return hr;
}


// This function exists to prevent us from using the stack space too long.
// We will use it here and then free it when we return.  This fixes 
HRESULT CBaseBrowser2::_ReplaceWithGoHome(LPCITEMIDLIST * ppidl, LPITEMIDLIST * ppidlFree)
{
    TCHAR szHome[MAX_URL_STRING];
    HRESULT hres = _GetStdLocation(szHome, ARRAYSIZE(szHome), DVIDM_GOHOME);

    if (SUCCEEDED(hres))
    {
        hres = IECreateFromPath(szHome, ppidlFree);
        if (SUCCEEDED(hres))
        {
            *ppidl = *ppidlFree;
        }
    }

    return hres;
}

// this does all the preliminary checking of whether we can navigate to pidl or not.
// then if all is ok, we do the navigate with CreateNewShellViewPidl
HRESULT CBaseBrowser2::_NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD fSBSP)
{
    HRESULT hres;
    BOOL fCanceledDueToOffline = FALSE;
    BOOL fIsAPost = FALSE;  
    LPITEMIDLIST pidlFree = NULL;

    //
    // If we are processing a modal dialog, don't process it.
    //
    // NOTES: Checking _cRefCannotNavigate is supposed to be enough, but
    //  since we are dealing with random ActiveX objects, we'd better be
    //  robust. That's why we check IsWindowEnabled as well.
    //
    if ((S_OK ==_DisableModeless()) || !IsWindowEnabled(_bbd._hwnd)) 
    {
        TraceMsg(DM_ENABLEMODELESS, "CSB::_NavigateToPidl returning ERROR_BUSY");
        hres = HRESULT_FROM_WIN32(ERROR_BUSY);
        goto Done;
    }

    TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_NavigateToPidl called"), pidl, grfHLNF);
    // used to be we would pull a NULL out of the 
    // the TravelLog, but i dont think that happens anymore
    ASSERT(pidl);  // Get ZEKEL

    // Sometimes we are navigated to the INTERNET shell folder
    // if this is the case, we really want to goto the Start Page.
    // This case only happens if you select "Internet Explorer" from the 
    // Folder Explorer Band.
    if (IsBrowserFrameOptionsPidlSet(pidl, BFO_SUBSTITUE_INTERNET_START_PAGE))
    {
        hres = _ReplaceWithGoHome(&pidl, &pidlFree);
        if (FAILED(hres))
            goto Done;
    }

    // We should only fire the BeforeNavigate event
    // if the document is not going to fire it.
    // We know that the document will fire it if
    // the document didn't call Navigate, the document
    // knows how to navigate and the document isn't hyperlinking.
    //
    if (!(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC))
    {
        hres = _FireBeforeNavigateEvent(pidl, &fIsAPost);
        if (hres == E_ABORT)
            goto Done;   // event handler told us to cancel
    }

#ifdef UNIX_DISABLE_LOCAL_FOLDER
    BOOL fCanceledDueToLocalFolder = FALSE;
    if (IsLocalFolderPidl( pidl ))
    {
        hres = E_FAIL;
        fCanceledDueToLocalFolder = TRUE;
        goto Done;
    }
#endif

    // if we can't go here (?), cancel the navigation
    hres = _CheckZoneCrossing(pidl);
    if (hres != S_OK)
        goto Done;
        
    TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_CreateNewShellViewPidl called"), pidl, grfHLNF);

    //
    // Now that we are actually navigating...
    //

    // tell the frame to cancel the current navigation
    // and tell it about history navigate options as it will not be getting it
    // from subsequent call to Navigate
    //
    if (_bbd._phlf) 
    {
        _bbd._phlf->Navigate(grfHLNF&(SHHLNF_WRITENOHISTORY|SHHLNF_NOAUTOSELECT), NULL, NULL, NULL);
    }

    hres = _CheckInCacheIfOffline(pidl, fIsAPost);
    if (hres != S_OK) 
    {
        fCanceledDueToOffline = TRUE;
        goto Done;
    }


    //
    //  if we goto the current page, we still do a full navigate
    //  but we dont want to create a new entry.
    //
    //  **EXCEPTIONS**
    //  if this was a generated page, ie Trident did doc.writes(),
    //  we need to always create a travel entry, because trident 
    //  can rename the pidl, but it wont actually be that page.
    //
    //  if this was a post then we need to create a travelentry.
    //  however if it was a travel back/fore, it will already have
    //  set the the bit, so we still wont create a new entry.
    //
    //
    //  NOTE: this is similar to a refresh, in that it reparses
    //  the entire page, but creates no travel entry.
    //
    if (   !_fDontAddTravelEntry                 // If the flag is already set, short circuit the rest
        && !fIsAPost                             // ...and not a Post
        && !_fGeneratedPage                      // ...and not a Generated Page
        && !(grfHLNF & HLNF_CREATENOHISTORY)     // ...and the CREATENOHISTORY flag is NOT set
        && pidl                                  // ...and we have a pidl to navigate to
        && _bbd._pidlCur                         // ...as well as a current pidl
        && ILIsEqual(pidl, _bbd._pidlCur)        // ...and the pidls are equal
        )
        _fDontAddTravelEntry = TRUE;             // Then set the DontAddTravelEntry flag.

    TraceMsg(TF_TRAVELLOG, "CBB:_NavToPidl() _fDontAddTravelEntry = %d", _fDontAddTravelEntry);

    _fGeneratedPage = FALSE;

    hres = _CreateNewShellViewPidl(pidl, grfHLNF, fSBSP);

    _dwDocFlags &= ~(DOCFLAG_NAVIGATEFROMDOC | DOCFLAG_SETNAVIGATABLECODEPAGE);

    if (SUCCEEDED(hres))
    {
        ATOMICRELEASE(_pHTMLDocument);
    }

Done:
    if (FAILED(hres))
    {
        TraceMsg(DM_WARNING, "CSB::_NavigateToPidl _CreateNewShellViewPidl failed %x", hres);

        // On failure we won't hit _ActivatePendingView
        OnReadyStateChange(NULL, READYSTATE_COMPLETE);

        //  if this was navigation via ITravelLog, 
        //  this will revert us to the original position
        if (_fDontAddTravelEntry)
        {
            ITravelLog *ptl;
        
            if(SUCCEEDED(GetTravelLog(&ptl)))
            {
                ptl->Revert();
                ptl->Release();
            }
            _fDontAddTravelEntry = FALSE;
            ASSERT(!_fIsLocalAnchor);

            ATOMICRELEASE(_poleHistory);
            ATOMICRELEASE(_pbcHistory);
            ATOMICRELEASE(_pstmHistory);
        }
        if (_pbsOuter)
            _pbsOuter->UpdateBackForwardState();

        //  we failed and have nothing to show for it...
        if (!_bbd._pidlCur && !_fNavigatedToBlank)
        {
            TCHAR szResURL[MAX_URL_STRING];

            if (fCanceledDueToOffline)
            {
                hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                         HINST_THISDLL,
                                         ML_CROSSCODEPAGE,
                                         TEXT("offcancl.htm"),
                                         szResURL,
                                         ARRAYSIZE(szResURL),
                                         TEXT("shdocvw.dll"));
                if (SUCCEEDED(hres))
                {
                    _ShowBlankPage(szResURL, pidl);
                }
            }
            else
            {
                // NT #274562: We only want to navigate to the
                //    about:NavigationCancelled page if it wasn't
                //    a navigation to file path. (UNC or Drive).
                //    The main reason for this is that if the user
                //    enters "\\unc\share" into Start->Run and
                //    the window can't successfully navigate to the
                //    share because permissions don't allow it, we
                //    want to close the window after the user hits
                //    [Cancel] in the [Retry][Cancel] dialog.  This
                //    is to prevent the shell from appearing to have
                //    shell integrated bugs and to be compatible with
                //    the old shell.
                if ( IsBrowserFrameOptionsPidlSet(_bbd._pidlCur, BFO_SHOW_NAVIGATION_CANCELLED ) )
                {
                    hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                             HINST_THISDLL,
                                             ML_CROSSCODEPAGE,
                                             TEXT("navcancl.htm"),
                                             szResURL,
                                             ARRAYSIZE(szResURL),
                                             TEXT("shdocvw.dll"));
                    if (SUCCEEDED(hres))
                    {
                        _ShowBlankPage(szResURL, pidl);
                    }
                }
            }
        }

#ifdef  UNIX_DISABLE_LOCAL_FOLDER
    if (fCanceledDueToLocalFolder)
    {
        // IEUNIX : since we are not making use of the url in the
        // about folder browsing page, we should not append it to 
        // the url to the error url as it is not handled properly
        // by about:folderbrowsing
        _ShowBlankPage(FOLDERBROWSINGINFO_URL, NULL);
        _fNavigatedToBlank = FALSE;
    }
#endif
        
    }

    ILFree(pidlFree);
    
    return hres;
}

HRESULT CBaseBrowser2::OnReadyStateChange(IShellView* psvSource, DWORD dwReadyState)
{
    BOOL fChange = FALSE;

    if (psvSource)
    {
        if (IsSameObject(psvSource, _bbd._psv))
        {
            TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(Current, %d)", this, dwReadyState);
            fChange = (_dwReadyStateCur != dwReadyState);
            _dwReadyStateCur = dwReadyState;
            if ((READYSTATE_COMPLETE == dwReadyState) && !_fReleasingShellView)
                _Exec_psbMixedZone();
        }
        else if (IsSameObject(psvSource, _bbd._psvPending))
        {
            TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(Pending, %d)", this, dwReadyState);
            fChange = (_dwReadyStatePending != dwReadyState);
            _dwReadyStatePending = dwReadyState;
        }
        else if (!_bbd._psvPending)
        {
            // Assume psvSource != _bbd._psv && NULL==_bbd._psvPending
            // means that _SwitchActivationNow is in the middle
            // of _MayPlayTransition's message loop and the
            // _bbd._psvPending dude is updating us.
            //
            // NOTE: We don't fire the event because get_ReadyState
            // can't figure this out. We know we will eventually
            // fire the event because CBaseBrowser2 will go to _COMPLETE
            // after _SwitchActivationNow.
            //
            TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(ASSUMED Pending, %d)", this, dwReadyState);
            _dwReadyStatePending = dwReadyState;
       }
    }
    else
    {
        // We use this function when our own simulated
        // ReadyState changes
        //
        TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(Self, %d)", this, dwReadyState);
        fChange = (_dwReadyState != dwReadyState);
        _dwReadyState = dwReadyState;
    }

    // No sense in firing events if nothing actually changed...
    //
    if (fChange && _bbd._pautoEDS)
    {
        DWORD dw;

        IUnknown_CPContainerOnChanged(_pauto, DISPID_READYSTATE);

        // if we at Complete, fire the event
        get_ReadyState(&dw);
        if (READYSTATE_COMPLETE == dw)
        {
            if (  !(_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
               || !_bbd._fIsViewMSHTML)
            {
                FireEvent_DocumentComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur);
            }

            // If we hit this, we have not picked up the history object we created.
            //
            AssertMsg(_fDontAddTravelEntry || !_poleHistory, TEXT("CBB::OnDocComplete: nobody picked up _poleHistory"));

            if (g_dwProfileCAP & 0x00080000) 
            {
                StopCAP();
            }
            
            ATOMICRELEASE(_pphHistory);
        }
    }

    return S_OK;
}

HRESULT CBaseBrowser2::get_ReadyState(DWORD * pdwReadyState)
{
    DWORD dw = _dwReadyState;

    if (_bbd._psvPending && _dwReadyStatePending < dw)
    {
        dw = _dwReadyStatePending;
    }

    if (_bbd._psv && _dwReadyStateCur < dw)
    {
        dw = _dwReadyStateCur;
    }

    *pdwReadyState = dw;

    return S_OK;
}

HRESULT CBaseBrowser2::_updateNavigationUI()
{
    if (_fNavigate || _fDescendentNavigate)
    {
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        if (!_fDownloadSet)
        {
            FireEvent_DoInvokeDispid(_bbd._pautoEDS, DISPID_DOWNLOADBEGIN);
            _fDownloadSet = TRUE;
        }   
    }
    else
    {
        if (_fDownloadSet)
        {
            FireEvent_DoInvokeDispid(_bbd._pautoEDS, DISPID_DOWNLOADCOMPLETE);
            _fDownloadSet = FALSE;
        }
        SetCursor(LoadCursor(NULL, IDC_ARROW));            
    }

    return S_OK;
}

HRESULT CBaseBrowser2::SetNavigateState(BNSTATE bnstate)
{
    switch (bnstate) 
    {
    case BNS_BEGIN_NAVIGATE:
    case BNS_NAVIGATE:
        _fNavigate = TRUE;
        _updateNavigationUI();
        break;

    case BNS_NORMAL:
        _fNavigate = FALSE;
        _updateNavigationUI();
        break;
    }
    return S_OK;
}


HRESULT CBaseBrowser2::GetNavigateState(BNSTATE *pbnstate)
{
    // Return Navigate if we are processing a navigation or if
    // we are processing a modal dialog.
    //
    // NOTES: Checking _cRefCannotNavigate is supposed to be enough, but
    //  since we are dealing with random ActiveX objects, we'd better be
    //  robust. That's why we check IsWindowEnabled as well.
    //
    *pbnstate = (_fNavigate || (S_OK ==_DisableModeless()) || _fDescendentNavigate ||
            !IsWindowEnabled(_bbd._hwnd)) ? BNS_NAVIGATE : BNS_NORMAL;
    return S_OK;
}

HRESULT CBaseBrowser2::UpdateBackForwardState(void)
{
    if (_fTopBrowser) 
    {
        _UpdateBackForwardState();
    } 
    else 
    {
        // sigh, BrowserBand now makes this fire
        //ASSERT(_fTopBrowser);
        IBrowserService *pbs = NULL;
        TraceMsg(TF_SHDNAVIGATE, "cbb.ohlfn: !_fTopBrowser (BrowserBand?)");
        if (SUCCEEDED(_pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs)))) 
        {
            BOOL fTopFrameBrowser = IsSameObject(pbs, SAFECAST(this, IShellBrowser *));
            if (!fTopFrameBrowser)
                pbs->UpdateBackForwardState();
            else 
                _UpdateBackForwardState();
            pbs->Release();        
        }
    }
    return S_OK;
}


HRESULT CBaseBrowser2::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    //
    // NOTES: Notice that CBaseBrowser2 directly expose the automation
    //  service object via QueryService. CWebBrowserSB will appropriately
    //  dispatch those. See comments on CWebBrowserSB::QueryService for
    //  detail. (SatoNa)
    //
    if (IsEqualGUID(guidService, SID_SWebBrowserApp) || 
        IsEqualGUID(guidService, SID_SContainerDispatch) || 
        IsEqualGUID(guidService, IID_IExpDispSupport))
    {
        hr = _bbd._pautoSS->QueryInterface(riid, ppv);
    }
    else  if (IsEqualGUID(guidService, SID_SHlinkFrame) || 
              IsEqualGUID(guidService, IID_ITargetFrame2) || 
              IsEqualGUID(guidService, IID_ITargetFrame)) 
    {
        hr = _ptfrm->QueryInterface(riid, ppv);
    }
    else if (IsEqualGUID(guidService, SID_STopLevelBrowser) || 
             IsEqualGUID(guidService, SID_STopFrameBrowser) ||
             IsEqualGUID(guidService, SID_STopWindow) ||
             IsEqualGUID(guidService, SID_SProfferService))
    {
        if (IsEqualGUID(riid, IID_IUrlHistoryStg))
        {
            ASSERT(_fTopBrowser);

            if (!_pIUrlHistoryStg)
            {
                // create this object the first time it's asked for
                CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IUrlHistoryStg, &_pIUrlHistoryStg));
            }

            if (_pIUrlHistoryStg)
                hr = _pIUrlHistoryStg->QueryInterface(riid, ppv);
            else
                hr = E_NOINTERFACE;
        }
        else if (IsEqualGUID(riid, IID_IToolbarExt))
        {
            // This code should all migrate to a helper object after IE5B2. So this
            // should be temporary (stevepro).
            if (!_pToolbarExt)
            {
                IUnknown* punk;
                if (SUCCEEDED(CBrowserExtension_CreateInstance(NULL, &punk, NULL)))
                {
                    IUnknown_SetSite(punk, _psbOuter);
                    punk->QueryInterface(IID_PPV_ARG(IToolbarExt, &_pToolbarExt));
                    punk->Release();
                }
            }

            if (_pToolbarExt)
                hr = _pToolbarExt->QueryInterface(riid, ppv);
            else
                hr = E_NOINTERFACE;
        }
        else
            hr = QueryInterface(riid, ppv);
    }
    else if (IsEqualGUID(guidService, SID_SUrlHistory)) 
    {
        if (!_pIUrlHistoryStg)
        {
            // Asking for it creates a copy in _pIUrlHistoryStg
            IUrlHistoryStg *puhs;
            if (SUCCEEDED(_pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IUrlHistoryStg, &puhs))))
            {
                if (!_pIUrlHistoryStg)
                    _pIUrlHistoryStg = puhs;
                else
                    puhs->Release();
            }
        }
        
        if (_pIUrlHistoryStg)
            hr = _pIUrlHistoryStg->QueryInterface(riid, ppv);
        else
            hr = E_NOINTERFACE;
    }
    else if (IsEqualGUID(guidService, SID_SShellBrowser) || 
             IsEqualGUID(guidService, SID_SVersionHost)) 
    {
        if (IsEqualIID(riid, IID_IHlinkFrame)) 
        {
            // HACK: MSHTML uses IID_IShellBrowser instead of SID_SHlinkFrame
            hr = _pspOuter->QueryService(SID_SHlinkFrame, riid, ppv);
        } 
        else if (IsEqualIID(riid, IID_IBindCtx) && _bbd._phlf) 
        {
            // HACK ALERT: Notice that we are using QueryService to the
            //  other direction here. We must make it absolutely sure
            //  that we'll never infinitly QueryService each other.
            hr = IUnknown_QueryService(_bbd._phlf, IID_IHlinkFrame, riid, ppv);
        } 
        else 
        {
            hr = QueryInterface(riid, ppv);
        }
    }
    else if (IsEqualGUID(guidService, SID_SOmWindow))
    {
        // HACK ALERT: Notice that we are using QueryService to the
        //  other direction here. We must make it absolutely sure
        //  that we'll never infinitly QueryService each other.
        hr = IUnknown_QueryService(_ptfrm, SID_SOmWindow, riid, ppv);
    }
    else if (IsEqualGUID(guidService, IID_IElementNamespaceTable) && _bbd._psv)
    {
        hr = IUnknown_QueryService(_bbd._psv, IID_IElementNamespaceTable, riid, ppv);
    }
    else if (IsEqualGUID(guidService, SID_STravelLogCursor))
    {
        // exposed travel log object
        if (!_pITravelLogStg)
        {    
            // create this object the first time it's asked for
            ITravelLog * ptl;
            GetTravelLog(&ptl);

            ITravelLogEx *ptlx;
            if (ptl && SUCCEEDED(ptl->QueryInterface(IID_PPV_ARG(ITravelLogEx, &ptlx))))
            {
                hr = CreatePublicTravelLog(SAFECAST(this, IBrowserService *), ptlx, &_pITravelLogStg);
                ptlx->Release();
            }
            SAFERELEASE(ptl);
        }
        
        if (_pITravelLogStg)
        {         
            hr = _pITravelLogStg->QueryInterface(riid, ppv);
        }
    }
    else if (IsEqualGUID(riid,IID_IEnumPrivacyRecords))
    {
        IHTMLWindow2     * pIW  = NULL;
        IServiceProvider * pISP = NULL;

        hr = QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void**)&pIW);
        if (SUCCEEDED(hr))
        {
            hr = pIW->QueryInterface(IID_IServiceProvider, (void**)&pISP);
            if (SUCCEEDED(hr))
            {
                hr = pISP->QueryService(IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, ppv);
                pISP->Release();
            }
            pIW->Release();
        }        
    }
    else
    {
        hr = IProfferServiceImpl::QueryService(guidService, riid, ppv);
    }

    ASSERT(SUCCEEDED(hr) ? *ppv != NULL : *ppv == NULL);  // COM rules

    return hr;
}


void CBaseBrowser2::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CBaseBrowser2::OnViewChange(DWORD dwAspect, LONG lindex)
{
    _ViewChange(dwAspect, lindex);
}

void CBaseBrowser2::OnRename(IMoniker *)
{
}

void CBaseBrowser2::OnSave()
{
}

void CBaseBrowser2::OnClose()
{
    _ViewChange(DVASPECT_CONTENT, -1);
}


// *** IDropTarget ***

// These methods are defined in shdocvw.cpp
extern DWORD CommonDragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt);


// Use the ShellView IDropTarget functions whenever they are implemented

// IDropTarget::DragEnter

HRESULT CBaseBrowser2::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if (_pdtView)
        return _pdtView->DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
    else 
    {
        if (_fNoDragDrop)
        {
            _dwDropEffect = DROPEFFECT_NONE;
        }
        else
        {
            _dwDropEffect = CommonDragEnter(pdtobj, grfKeyState, ptl);
        }
        *pdwEffect &= _dwDropEffect;
    }
    return S_OK;
}

// IDropTarget::DragOver

HRESULT CBaseBrowser2::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if (S_OK == _DisableModeless()) 
    {
        *pdwEffect = 0;
        return S_OK;
    }

    if (_pdtView)
        return _pdtView->DragOver(grfKeyState, ptl, pdwEffect);

    *pdwEffect &= _dwDropEffect;
    return S_OK;    
}


// IDropTarget::DragLeave

HRESULT CBaseBrowser2::DragLeave(void)
{
    if (_pdtView)
        return _pdtView->DragLeave();
    return S_OK;
}


// IDropTarget::DragDrop

HRESULT CBaseBrowser2::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    if (S_OK == _DisableModeless()) 
    {
        *pdwEffect = 0;
        return S_OK;
    }
    BOOL fNavigateDone = FALSE;
    HRESULT hr = E_FAIL;
    // If this is a shortcut - we want it to go via _NavIEShortcut
    // First check if it indeed a shortcut

    STGMEDIUM medium;

    if (_ptfrm && (DataObj_GetDataOfType(pdtobj, CF_HDROP, &medium)))
    {         
        WCHAR wszPath[MAX_PATH];

        if (DragQueryFileW((HDROP)medium.hGlobal, 0, wszPath, ARRAYSIZE(wszPath)))
        {
            LPWSTR pwszExtension = PathFindExtensionW(wszPath);
            // Check the extension to see if it is a .URL file

            if (0 == StrCmpIW(pwszExtension, L".url"))
            {
                // It is an internet shortcut 
                VARIANT varShortCutPath = {0};
                VARIANT varFlag = {0};

                varFlag.vt = VT_BOOL;
                varFlag.boolVal = VARIANT_TRUE;

                LBSTR::CString          strPath( wszPath );

                varShortCutPath.vt = VT_BSTR;
                varShortCutPath.bstrVal = strPath;

                hr = IUnknown_Exec(_ptfrm, &CGID_Explorer, SBCMDID_IESHORTCUT, 0, &varShortCutPath, &varFlag);
                fNavigateDone = SUCCEEDED(hr);   
                if(fNavigateDone)
                {
                    DragLeave();
                }
            }
        }

        // must call ReleaseStgMediumHGLOBAL since DataObj_GetDataOfType added an extra GlobalLock
        ReleaseStgMediumHGLOBAL(NULL, &medium);
    }

    if (FALSE == fNavigateDone)
    {
        if (_pdtView)
        {
            hr = _pdtView->Drop(pdtobj, grfKeyState, pt, pdwEffect);
        }
        else 
        {
            LPITEMIDLIST pidlTarget;
            hr = SHPidlFromDataObject(pdtobj, &pidlTarget, NULL, 0);
            if (SUCCEEDED(hr))
            {
                ASSERT(pidlTarget);
                hr = _psbOuter->BrowseObject(pidlTarget, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
                ILFree(pidlTarget);
            }
        }
    }

    return hr;
}

HRESULT CBaseBrowser2::_FireBeforeNavigateEvent(LPCITEMIDLIST pidl, BOOL* pfIsPost)
{
    HRESULT hres = S_OK;

    IBindStatusCallback * pBindStatusCallback;
    LPTSTR pszHeaders = NULL;
    LPBYTE pPostData = NULL;
    DWORD cbPostData = 0;
    BOOL fCancelled=FALSE;
    STGMEDIUM stgPostData;
    BOOL fHavePostStg = FALSE;

    *pfIsPost = FALSE;
    
    // If this is the first BeforeNavigateEvent of a ViewLinkedWebOC we do not need to fire.
    // It is fired by the hosting Trident. Note that _fIsViewLinkedWebOC is only set by the 
    // host, so we need not worry about BeforeNavigateEvent not being fired for other in other
    // instances of the WebOC.

    if (_fIsViewLinkedWebOC && (!_fHadFirstBeforeNavigate))
    {
        _fHadFirstBeforeNavigate = TRUE;
        return hres;
    }

    // get the bind status callback for this browser and ask it for
    // headers and post data
    if (SUCCEEDED(GetTopLevelPendingBindStatusCallback(this,&pBindStatusCallback))) 
    {
        GetHeadersAndPostData(pBindStatusCallback,&pszHeaders,&stgPostData,&cbPostData, pfIsPost);
        pBindStatusCallback->Release();
        fHavePostStg = TRUE;

        if (stgPostData.tymed == TYMED_HGLOBAL) 
        {
            pPostData = (LPBYTE) stgPostData.hGlobal;
        }
    }

    // Fire a BeforeNavigate event to inform container that we are about
    // to navigate and to give it a chance to cancel.  We have to ask
    // for post data and headers to pass to event, so only do this if someone
    // is actually hooked up to the event (HasSinks() is TRUE).
    //if (_bbd._pautoEDS->HasSinks()) 
    {
        TCHAR szFrameName[MAX_URL_STRING];
        SHSTR strHeaders;

        szFrameName[0] = 0;

        // get our frame name
        ITargetFrame2 *pOurTargetFrame;
        hres = TargetQueryService((IShellBrowser *)this, IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));
        if (SUCCEEDED(hres))
        {
            LPOLESTR pwzFrameName = NULL;
            pOurTargetFrame->GetFrameName(&pwzFrameName);
            pOurTargetFrame->Release();

            if (pwzFrameName) 
            {
                SHUnicodeToTChar(pwzFrameName, szFrameName, ARRAYSIZE(szFrameName));
                CoTaskMemFree(pwzFrameName);            
            }               
        }

        strHeaders.SetStr(pszHeaders);

        _pidlBeforeNavigateEvent = (LPITEMIDLIST) pidl; // no need to copy

        // This is a work around for view linked weboc. Setting the frame name has side effects.
        
        TCHAR * pEffectiveName;

        if (_fIsViewLinkedWebOC && !szFrameName[0])
        {
            pEffectiveName = _szViewLinkedWebOCFrameName;
        }
        else
        {
            pEffectiveName = szFrameName[0] ? szFrameName : NULL;
        }

        // fire the event!
        FireEvent_BeforeNavigate(_bbd._pautoEDS, _bbd._hwnd, _bbd._pautoWB2,
            pidl, NULL, 0, pEffectiveName,
            pPostData, cbPostData, strHeaders.GetStr(), &fCancelled);

        ASSERT(_pidlBeforeNavigateEvent == pidl);
        _pidlBeforeNavigateEvent = NULL;

        // free anything we alloc'd above
        if (pszHeaders)
        {
            LocalFree(pszHeaders);
            pszHeaders = NULL;
        }

        if (fCancelled) 
        {
            // container told us to cancel
            hres = E_ABORT;
        }
    }
    if (fHavePostStg) 
    {
        ReleaseStgMedium(&stgPostData);
    }
    return hres;
}

HRESULT CBaseBrowser2::SetTopBrowser()
{
    _fTopBrowser = TRUE;

#ifdef MESSAGEFILTER
    if (!_lpMF) 
    {
        /*
         * Create a message filter here to pull out WM_TIMER's while we are
         * busy.  The animation timer, along with other timers, can get
         * piled up otherwise which can fill the message queue and thus USER's
         * heap.
         */
        _lpMF = new CMsgFilter();

        if (_lpMF && !(((CMsgFilter *)_lpMF)->Initialize()))
        {
            ATOMICRELEASE(_lpMF);
        }
    }
#endif
    return S_OK;
}

HRESULT CBaseBrowser2::_ResizeView()
{
    _pbsOuter->_UpdateViewRectSize();
    if (_pact) 
    {
        RECT rc;
        GetBorder(&rc);
        TraceMsg(TF_SHDUIACTIVATE, "UIW::SetBorderSpaceDW calling _pact->ResizeBorder");
        _pact->ResizeBorder(&rc, this, TRUE);
    }
    return S_OK;
} 

HRESULT CBaseBrowser2::_ResizeNextBorder(UINT itb)
{
    // (derived class resizes inner toolbar if any)
    return _ResizeView();
}

HRESULT CBaseBrowser2::_OnFocusChange(UINT itb)
{
#if 0
    // the OC *does* get here (it's not aggregated so _pbsOuter->_OnFocusChange
    // ends up here not in commonsb).  not sure if E_NOTIMPL is o.k., but
    // for now it's what we'll do...
    ASSERT(0);
#endif
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    ASSERT(0);          // split: untested!
    // do we need to do _UIActivateView?
    ASSERT(fSetFocus);  // i think?

#if 0 // split: see commonsb.cpp, view/ONTOOLBARACTIVATED stuff
    // do we need something here?
#endif

    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::v_ShowHideChildWindows(BOOL fChildOnly)
{
    // (derived class does ShowDW on all toolbars)
    if (!fChildOnly) 
    {
        _pbsOuter->_ResizeNextBorder(0);
        // This is called in ResizeNextBorder 
        // _UpdateViewRectSize();
    }

    return S_OK;
}

//***   _ExecChildren -- broadcast Exec to view and toolbars
// NOTES
//  we might do *both* punkBar and fBroadcast if we want to send stuff
//  to both the view and to all toolbars, e.g. 'stop' or 'refresh'.
//
//  Note: n.b. the tray isn't a real toolbar, so it won't get called (sigh...).
HRESULT CBaseBrowser2::_ExecChildren(IUnknown *punkBar, BOOL fBroadcast, const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    //ASSERT(!fBroadcast);    // only derived class supports this
    // alanau: but CWebBrowserSB doesn't override this method, so we hit this assert.

    // 1st, send to specified guy (if requested)
    if (punkBar != NULL) 
    {
        // send to specified guy
        IUnknown_Exec(punkBar, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }

    // (derived class broadcasts to toolbars)

    return S_OK;
}

HRESULT CBaseBrowser2::_SendChildren(HWND hwndBar, BOOL fBroadcast, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#if 0
    // the OC *does* get here (it's not aggregated so _pbsOuter->_SendChildren
    // ends up here not in commonsb).  since there are no kids i guess it's
    // ok to just drop the fBroadcast on the floor.
    ASSERT(!fBroadcast);    // only derived class supports this
#endif

    // 1st, send to specified guy (if requested)
    if (hwndBar != NULL)
    {
        // send to specified guy
        SendMessage(hwndBar, uMsg, wParam, lParam);
    }

    // (derived class broadcasts to toolbars)

    return S_OK;
}

//
//  Handle <META HTTP-EQUIV ...> headers for lower components
//

HRESULT CBaseBrowser2::OnHttpEquiv(IShellView* psv, BOOL fDone, VARIANT *pvarargIn, VARIANT *pvarargOut)
{
    //
    // We don't want to process any HTTP-EQUIV from the 'current' shellview
    // if there is any pending navigation. 
    //
    if (_bbd._psvPending && IsSameObject(_bbd._psv, psv)) 
    {
        return E_FAIL;
    }

    typedef struct _HTTPEQUIVHANDLER {
        LPCWSTR pcwzHeaderName;
        HRESULT (*pfnHandler)(HWND, LPWSTR, LPWSTR, CBaseBrowser2 *, BOOL, LPARAM);
        LPARAM  lParam;
    } HTTPEQUIVHANDLER;

    const static HTTPEQUIVHANDLER HandlerList[] = {
                                           {L"PICS-Label",  _HandlePICS,            0},
                                           };
    DWORD   i = 0;
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    LPWSTR  pwzEquivString = pvarargIn? pvarargIn->bstrVal : NULL;
    BOOL    fHasHeader = (pwzEquivString!=NULL);

    if (pvarargIn && pvarargIn->vt != VT_BSTR)
        return OLECMDERR_E_NOTSUPPORTED;   // ? should be invalidparam

#ifdef DEBUG
    TCHAR szDebug[MAX_URL_STRING] = TEXT("(empty)");
    if (pwzEquivString) 
    {
        UnicodeToTChar(pwzEquivString, szDebug, ARRAYSIZE(szDebug));
    }
    TraceMsg(DM_HTTPEQUIV, "CBB::_HandleHttpEquiv got %s (fDone=%d)", szDebug, fDone);
#endif

    for ( ; i < ARRAYSIZE(HandlerList); i++) 
    {
        // Do we care about matching "Refresh" on "Refreshfoo"?
        // If there is no header sent, we will call all handlers; this allows
        // us to pass the fDone flag to all handlers

        if (!fHasHeader || StrCmpNIW(HandlerList[i].pcwzHeaderName, pwzEquivString, lstrlenW(HandlerList[i].pcwzHeaderName)) == 0) 
        {
            // Hit.  Now do the right thing for this header
            // We pass both the header and a pointer to the first char after
            // ':', which is usually the delimiter handlers will look for.

            LPWSTR pwzColon = fHasHeader? StrChrW(pwzEquivString, ':') : NULL;
      
            // Enforce the : at the end of the header
            if (fHasHeader && !pwzColon) 
            {
                return OLECMDERR_E_NOTSUPPORTED;
            }
             
            hr = HandlerList[i].pfnHandler(_bbd._hwnd, pwzEquivString, pwzColon?(pwzColon+1):NULL, this, fDone, HandlerList[i].lParam);
            // We do not break here intentionally
        }
    }

    return hr;
} // _HandleHttpEquiv

STDMETHODIMP CBaseBrowser2::GetPalette( HPALETTE * phpal )
{
    BOOL fRes = FALSE;
    if ( _hpalBrowser )
    {
       *phpal = _hpalBrowser;
       fRes = TRUE;
    }
    return fRes ? NOERROR : E_FAIL;
}

HRESULT _HandlePICS(HWND hwnd, LPWSTR pwz, LPWSTR pszColon, CBaseBrowser2 *pbb, BOOL fDone, LPARAM lParam)
{
    return OLECMDERR_E_NOTSUPPORTED;
} // _HandlePICS

/// BEGIN-CHC- Security fix for viewing non shdocvw ishellviews
void CBaseBrowser2::_CheckDisableViewWindow()
{
    void * pdov;
    HRESULT hres;

    if (_fTopBrowser && !_fNoTopLevelBrowser)
        return;     // Checking is not needed.

    if (WhichPlatform() == PLATFORM_INTEGRATED)
        return;     // Checking is not needed.

    hres = _bbd._psvPending->QueryInterface(CLSID_CDocObjectView, &pdov);
    if (SUCCEEDED(hres)) 
    {
        // this is asking for an internal interface...  which is NOT IUnknown.
        // so we release the psvPrev, not th interface we got
        _bbd._psvPending->Release();
        
        // if we got here, this is shdocvw, we don't need to do anything
        return;
    } 

    if (IsNamedWindow(_bbd._hwndViewPending, TEXT("SHELLDLL_DefView")))
    {
        if (_SubclassDefview())
            return;
    }

    // otherwise disable the window
    EnableWindow(_bbd._hwndViewPending, FALSE);
}

#define ID_LISTVIEW     1
BOOL CBaseBrowser2::_SubclassDefview()
{
    HWND hwndLV = GetDlgItem(_bbd._hwndViewPending, ID_LISTVIEW);

    // validate the class is listview
    if (!IsNamedWindow(hwndLV, WC_LISTVIEW)) 
        return FALSE;

    // ALERT:
    // Do not use SHRevokeDragDrop in the call below. That will have the
    // un-intentional side effect of unloading OLE because when the Defview
    // window is destroyed, we call SHRevokeDragDrop once again.

    RevokeDragDrop(hwndLV);

    _pfnDefView = (WNDPROC) SetWindowLongPtr(_bbd._hwndViewPending, GWLP_WNDPROC, (LONG_PTR)DefViewWndProc);
    
    // hack hack...  we know that defview doesn't use USERDATA so we do it instead
    // of using properties.
    SetWindowLongPtr(_bbd._hwndViewPending, GWLP_USERDATA, (LONG_PTR)(void*)(CBaseBrowser2*)this);
    return TRUE;
}

BOOL _IsSafe(IUnknown * psp, DWORD dwFlags)
{
    BOOL IsSafe = TRUE; // Assume we will allow this.
    IInternetHostSecurityManager * pihsm;

    // We should never subclass in this case, because the new shell32.dll with Zone Checking security
    // is installed.
    ASSERT(WhichPlatform() != PLATFORM_INTEGRATED);

    // What we want to do is allow this to happen only if the author of the HTML that hosts
    // the DefView is safe.  It's OK if they point to something unsafe, because they are
    // trusted.
    if (EVAL(SUCCEEDED(IUnknown_QueryService(psp, IID_IInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pihsm))))
    {
        if (S_OK != ZoneCheckHost(pihsm, URLACTION_SHELL_VERB, dwFlags))
        {
            // This zone is not OK or the user choose to not allow this to happen,
            // so cancel the operation.
            IsSafe = FALSE;    // Turn off functionality.
        }

        pihsm->Release();
    }

    return IsSafe;
}

LRESULT CBaseBrowser2::DefViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBaseBrowser2* psb = (CBaseBrowser2*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    CALLWNDPROC cwp = (CALLWNDPROC)psb->_pfnDefView;

    switch (uMsg) 
    {
    case WM_NOTIFY:
    {
        NMHDR* pnm = (NMHDR*)lParam;
        if (pnm->idFrom == ID_LISTVIEW) 
        {
            switch (pnm->code) 
            {
            case LVN_ITEMACTIVATE:
                // We should never subclass in this case, because the new shell32.dll with Zone Checking security
                // is installed.
                ASSERT(WhichPlatform() != PLATFORM_INTEGRATED);
                return 1; // abort what you were going to do
                break;
                
            case NM_RETURN:
            case NM_DBLCLK:
                if (!_IsSafe(SAFECAST(psb, IShellBrowser*), PUAF_DEFAULT | PUAF_WARN_IF_DENIED))
                    return 1;
                break;
            
            case LVN_BEGINDRAG:
                if (!_IsSafe(SAFECAST(psb, IShellBrowser*), PUAF_NOUI))
                    return 1;
            }
        }
    }    
    break;
        
    case WM_CONTEXTMENU:
        return 1;
        
    case WM_DESTROY:
        // unsubclass
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)cwp);
        break;
    }

    return CallWindowProc(cwp, hwnd, uMsg, wParam, lParam);
}


/// END-CHC- Security fix for viewing non shdocvw ishellviews




//
//  IPersist
//
HRESULT 
CBaseBrowser2::GetClassID(CLSID *pclsid)
{
    return E_NOTIMPL;
}

//
// IPersistHistory
//  
#ifdef DEBUG
#define c_szFrameMagic TEXT("IE4ViewStream")
#define c_cchFrameMagic SIZECHARS(c_szFrameMagic)
#endif

// NOTE this is almost the same kind of data that is 
//  stored in a TravelEntry.

typedef struct _PersistedFrame {
    DWORD cbSize;
    DWORD type;
    DWORD lock;
    DWORD bid;
    CLSID clsid;
    DWORD cbPidl;
} PERSISTEDFRAME, *PPERSISTEDFRAME;

#define PFTYPE_USEPIDL      1
#define PFTYPE_USECLSID     2

#define PFFLAG_SECURELOCK   0x00000001


HRESULT GetPersistedFrame(IStream *pstm, PPERSISTEDFRAME ppf, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    ASSERT(pstm);
    ASSERT(ppf);
    ASSERT(ppidl);

#ifdef DEBUG
    TCHAR szMagic[SIZECHARS(c_szFrameMagic)];
    DWORD cbMagic = CbFromCch(c_cchFrameMagic);

    ASSERT(SUCCEEDED(IStream_Read(pstm, (void *) szMagic, cbMagic)));
    ASSERT(!StrCmp(szMagic, c_szFrameMagic));
#endif //DEBUG

    // This is pointing to the stack, make sure it starts NULL
    *ppidl = NULL;

    if(SUCCEEDED(hr = IStream_Read(pstm, (void *) ppf, SIZEOF(PERSISTEDFRAME))))
    {
        if(ppf->cbSize == SIZEOF(PERSISTEDFRAME) && (ppf->type == PFTYPE_USECLSID || ppf->type == PFTYPE_USEPIDL))
        {
            //  i used SHAlloc() cuz its what all the IL functions use
            if(ppf->cbPidl)
                *ppidl = (LPITEMIDLIST) SHAlloc(ppf->cbPidl);
        
            if(*ppidl)
            {
                hr = IStream_Read(pstm, (void *) *ppidl, ppf->cbPidl);
                if(FAILED(hr))
                {
                    ILFree(*ppidl);
                    *ppidl = NULL;
                }
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT
CBaseBrowser2::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pstm);

    TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory entered pstm = %X, pbc = %d", pstm, pbc);

    ATOMICRELEASE(_poleHistory);
    ATOMICRELEASE(_pstmHistory);
    ATOMICRELEASE(_pbcHistory);

    if (pstm)
    {
        PERSISTEDFRAME pf;
        LPITEMIDLIST pidl;

        hr = GetPersistedFrame(pstm, &pf, &pidl);
        if (SUCCEEDED(hr))
        {
            //  need to restore the previous bid
            //  if this is a new window
            ASSERT(pf.bid == _dwBrowserIndex || !_bbd._pidlCur);
            _dwBrowserIndex = pf.bid;
            _eSecureLockIconPending = pf.lock;

            if (pf.type == PFTYPE_USECLSID)
            {
                hr = E_FAIL;

                if (_pHTMLDocument)
                {
                    if (   (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
                        && IsEqualCLSID(pf.clsid, CLSID_HTMLDocument))
                    {
                        IPersistHistory * pph;
                        hr = _pHTMLDocument->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));

                        if (SUCCEEDED(hr))
                        {
                            _fDontAddTravelEntry = TRUE;

                            hr = pph->LoadHistory(pstm, pbc);
                            TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory called pole->LoadHistory, hr =%X", hr);

                            pph->Release();

                            return hr;
                        }
                    }
                    else
                    {
                        ATOMICRELEASE(_pHTMLDocument);  // We are going to cocreate a new document.
                    }
                }

                if (S_OK != hr)
                {
                    // Get the class and instantiate
                    hr = CoCreateInstance(pf.clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IOleObject, &_poleHistory));
                }

                if (SUCCEEDED(hr))
                {
                    DWORD dwFlags;

                    hr = _poleHistory->GetMiscStatus(DVASPECT_CONTENT, &dwFlags);
                    if (SUCCEEDED(hr))
                    {
                        if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
                        {
                            pstm->AddRef();  
                            if (pbc)
                                pbc->AddRef();
 
                            // we need to addref because we will use it async
                            // whoever uses it needs to release.
                            _pstmHistory = pstm;
                            _pbcHistory = pbc;
                        }
                        else
                        {
                            IPersistHistory * pph;
                            hr = _poleHistory->QueryInterface(IID_PPV_ARG(IPersistHistory,  &pph));

                            if (SUCCEEDED(hr))
                            {
                                hr = pph->LoadHistory(pstm, pbc);
                                TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory called pole->LoadHistory, hr =%X", hr);

                                pph->Release();
                            }
                        }

                        //  if we made then set the prepared history object in 
                        //  _poleHistory
                        if (FAILED(hr))
                        {
                            ATOMICRELEASE(_poleHistory);
                            ATOMICRELEASE(_pstmHistory);
                            ATOMICRELEASE(_pbcHistory);
                        }
                    }
                }
            }
            
            //
            // just browse the object
            // if poleHistory is set, then when the dochost is created
            // it will pick up the object and use it.
            // other wise we will do a normal navigate.
            //
            if (pidl)
            {
                DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
                DEBUG_CODE(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);)
                DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::LoadHistory: URL - %ws", szPath);)

                _fDontAddTravelEntry = TRUE;
                hr = _psbOuter->BrowseObject(pidl, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
                ILFree(pidl);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory exiting, hr =%X", hr);
    _pbsOuter->UpdateBackForwardState();
    return hr;
}

// Save a stream represeting the history at this point.
// Be sure to keep this and GetDummyWindowData in sync.

HRESULT
CBaseBrowser2::SaveHistory(IStream *pstm)
{
    HRESULT hr = E_UNEXPECTED;
    TraceMsg(TF_TRAVELLOG, "CBB::SaveHistory entering, pstm =%X", pstm);
    ASSERT(pstm);

    if(_bbd._pidlCur)
    {
        PERSISTEDFRAME pf = {0};
        pf.cbSize = SIZEOF(pf);
        pf.bid = GetBrowserIndex();
        pf.cbPidl = ILGetSize(_bbd._pidlCur);
        pf.type = PFTYPE_USEPIDL;
        pf.lock = _bbd._eSecureLockIcon;

        DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
        DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
        
        ASSERT(SUCCEEDED(IStream_Write(pstm, (void *) c_szFrameMagic, CbFromCch(c_cchFrameMagic))));
    
        //
        //  in order to use IPersistHistory we need to get the CLSID of the Ole Object
        //  then we need to get IPersistHistory off that object
        //  then we can save the PERSISTEDFRAME and the pidl and then pass 
        //  the stream down into the objects IPersistHistory
        //

        //  Right now we circumvent the view object for history - zekel - 18-JUL-97
        //  right now we just grab the DocObj from the view object, and then query
        //  the Doc for IPersistHistory.  really what we should be doing is QI the view
        //  for pph, and then use it.  however this requires risky work with the
        //  navigation stack, and thus should be postponed to IE5.  looking to the future
        //  the view could persist all kinds of great state info
        //
        //  but now we just get the background object.  but check to make sure that it
        //  will be using the DocObjHost code by QI for IDocViewSite
        //

        //  _bbd._psv can be null in subframes that have not completed navigating
        //  before a refresh is called
        //
        if (!_pphHistory && _bbd._psv)
        {
            hr = SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &_pphHistory));
        }

        if (_pphHistory)
        {
            IDocViewSite *pdvs;

            if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IDocViewSite, &pdvs))) && 
                SUCCEEDED(hr = _pphHistory->GetClassID(&(pf.clsid))))
            {
                pf.type = PFTYPE_USECLSID;
                TraceMsg(TF_TRAVELLOG, "CBB::SaveHistory is PFTYPE_USECLSID");
            }

            ATOMICRELEASE(pdvs);
        }


        if (SUCCEEDED(hr = IStream_Write(pstm,(void *)&pf, pf.cbSize)))
            hr = IStream_Write(pstm,(void *)_bbd._pidlCur, pf.cbPidl);

        if (SUCCEEDED(hr) && pf.type == PFTYPE_USECLSID)
            hr = _pphHistory->SaveHistory(pstm);

        ATOMICRELEASE(_pphHistory);
    }
    
    TraceMsg(TF_TRAVELLOG, "CBB::SaveHistory exiting, hr =%X", hr);
    return hr;
}

HRESULT CBaseBrowser2::SetPositionCookie(DWORD dwPositionCookie)
{
    HRESULT hr = E_FAIL;
    //
    //  we force the browser to update its internal location and the address bar
    //  this depends on the fact that setposition cookie was always 
    //  started by a ptl->Travel(). so that the current position in the ptl
    //  is actually the correct URL for us to have.  zekel - 22-JUL-97
    //

    ITravelLog *ptl;
    GetTravelLog(&ptl);
    if(ptl)
    {
        ITravelEntry *pte;
        if(EVAL(SUCCEEDED(ptl->GetTravelEntry((IShellBrowser *)this, 0, &pte))))
        {
            LPITEMIDLIST pidl;
            ASSERT(pte);
            if(SUCCEEDED(pte->GetPidl(&pidl)))
            {
                BOOL fUnused;
                ASSERT(pidl);

                if (SUCCEEDED(hr = _FireBeforeNavigateEvent(pidl, &fUnused)))
                {
                    IPersistHistory *pph;
                    if(_bbd._psv && SUCCEEDED(hr = SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &pph))))
                    {
                        ASSERT(pph);

                        //  now that we are certain that we are going to call into 
                        //   the document, we need to update the entry right before.
                        //  NOTE: after an update, we cannot revert if there was an
                        //  error in the Set...
                        ptl->UpdateEntry((IShellBrowser *)this, TRUE);

                        hr = pph->SetPositionCookie(dwPositionCookie);
                        pph->Release();

                        //  this updates the browser to the new pidl, 
                        //  and navigates there directly if necessary.
                        BOOL fDidBrowse;
                        NotifyRedirect(_bbd._psv, pidl, &fDidBrowse);

                        if (!fDidBrowse)
                        {
                            // fire the event!
                            FireEvent_NavigateComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur, _bbd._hwnd);          
                            FireEvent_DocumentComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur);
                        }
                    }

                }
                ILFree(pidl);
            }
            pte->Release();
        }
        ptl->Release();
    }

    TraceMsg(TF_TRAVELLOG, "CBB::SetPositionCookie exiting, cookie = %X, hr =%X", dwPositionCookie, hr);
    
    return hr;
}

HRESULT CBaseBrowser2::GetPositionCookie(DWORD *pdwPositionCookie)
{
    HRESULT hr = E_FAIL;
    IPersistHistory *pph;
    ASSERT(pdwPositionCookie);

    if(pdwPositionCookie && _bbd._psv && SUCCEEDED(hr = SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &pph))))
    {
        ASSERT(pph);

        hr = pph->GetPositionCookie(pdwPositionCookie);
        pph->Release();
    }

    TraceMsg(TF_TRAVELLOG, "CBB::GetPositionCookie exiting, cookie = %X, hr =%X", *pdwPositionCookie, hr);

    return hr;
}

DWORD CBaseBrowser2::GetBrowserIndex()
{
    //  the first time we request the index, we init it.
    if (!_dwBrowserIndex)
    {
        //
        //  the topframe browser all have the same browser index so 
        //  that they can trade TravelEntries if necessary.  because we now
        //  trade around TravelEntries, then we need to make the bids relatively
        //  unique.  and avoid ever having a random frame be BID_TOPFRAMEBROWSER
        //
        if (IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
            _dwBrowserIndex = BID_TOPFRAMEBROWSER;
        else do
        {
            _dwBrowserIndex = SHRandom();

        } while (!_dwBrowserIndex || _dwBrowserIndex == BID_TOPFRAMEBROWSER);
        // psp->Release();

        TraceMsg(TF_TRAVELLOG, "CBB::GetBrowserIndex() NewFrame BID = %X", _dwBrowserIndex);
    }

    return _dwBrowserIndex;
}

HRESULT CBaseBrowser2::GetHistoryObject(IOleObject **ppole, IStream **ppstm, IBindCtx **ppbc) 
{
    ASSERT(ppole);
    ASSERT(ppstm);
    ASSERT(ppbc);

    *ppole = _poleHistory;
    *ppstm = _pstmHistory;
    *ppbc = _pbcHistory;

    //  we dont need to release, because we are just giving away our
    //  reference.
    _poleHistory = NULL;
    _pstmHistory = NULL;
    _pbcHistory = NULL;

    if(*ppole)
        return NOERROR;

    ASSERT(!*ppstm);
    return E_FAIL;
}

HRESULT CBaseBrowser2::SetHistoryObject(IOleObject *pole, BOOL fIsLocalAnchor)
{
    if (!_poleHistory && !_fGeneratedPage)
    {
        ASSERT(pole);

        // Note: _fIsLocalAnchor is ignored if (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
        // is TRUE. In that case, the document (Trident) can navigate
        // itself and will take care of updating the travel log.
        //
        _fIsLocalAnchor = fIsLocalAnchor;

        if (pole)
        {
            _poleHistory = pole;
            _poleHistory->AddRef();
            return NOERROR;
        }
    }
    return E_FAIL;
}

HRESULT CBaseBrowser2::CacheOLEServer(IOleObject *pole)
{
    TraceMsg(DM_CACHEOLESERVER, "CBB::CacheOLEServer called");
    HRESULT hres;
    IPersist* pps;

    // ISVs want to turn off this caching because it's "incovenient"
    // to have the browser hold onto their object. We can do that
    // with a quick registry check here, but first let's make sure
    // we don't have a real bug to fix...

    hres = pole->QueryInterface(IID_PPV_ARG(IPersist, &pps));
    if (FAILED(hres)) 
    {
        return hres;
    }

    CLSID clsid = CLSID_NULL;
    hres = pps->GetClassID(&clsid);
    pps->Release();

    if (SUCCEEDED(hres)) 
    {
        SA_BSTRGUID str;
        InitFakeBSTR(&str, clsid);

        VARIANT v;
        hres = _bbd._pautoWB2->GetProperty(str.wsz, &v);
        if (SUCCEEDED(hres) && v.vt != VT_EMPTY) 
        {
            // We already have it. We are fine.
            TraceMsg(DM_CACHEOLESERVER, "CBB::CacheOLEServer not first time");
            VariantClear(&v);
        }
        else
        {
            // We don't have it yet. Add it. 
            v.vt = VT_UNKNOWN;
            v.punkVal = ClassHolder_Create(&clsid);
            if (v.punkVal)
            {
                hres = _bbd._pautoWB2->PutProperty(str.wsz, v);
                TraceMsg(DM_CACHEOLESERVER, "CBB::CacheOLEServer first time %x", hres);
                v.punkVal->Release();
            }
        }
    }
    return hres;
}

HRESULT CBaseBrowser2::GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut)
{
    // Process the out parameter first so that the client can set and
    // get the previous value in a single call.

    if (pvarOut) 
    {
        pvarOut->vt = VT_I4;
        pvarOut->lVal = _cp;
    }

    if (pvarIn && pvarIn->vt==VT_I4) 
    {
        TraceMsg(DM_DOCCP, "CBB::GetSetCodePage changing _cp from %d to %d", _cp, pvarIn->lVal);
        _cp = pvarIn->lVal;
    }

    return S_OK;
}

HRESULT CBaseBrowser2::GetPidl(LPITEMIDLIST *ppidl)
{
    ASSERT(ppidl);

    *ppidl = ILClone(_bbd._pidlCur);

    return *ppidl ? S_OK : E_FAIL;
}

HRESULT CBaseBrowser2::SetReferrer(LPITEMIDLIST pidl)
{
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::GetBrowserByIndex(DWORD dwID, IUnknown **ppunk)
{
    HRESULT hr = E_FAIL;
    ASSERT(ppunk);
    *ppunk = NULL;

    //gotta get the target frame ...
    ITargetFramePriv * ptf;
    if(SUCCEEDED(_ptfrm->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptf))))
    {
        ASSERT(ptf);
        hr = ptf->FindBrowserByIndex(dwID, ppunk);

        ptf->Release();
    }

    return hr;
}

HRESULT CBaseBrowser2::GetTravelLog(ITravelLog **pptl)
{
    *pptl = NULL;

    if (!_bbd._ptl)
    {
        IBrowserService *pbs;
        if (SUCCEEDED(_pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs)))) 
        {
            if (IsSameObject(SAFECAST(this, IBrowserService *), pbs))
            {
                // we are it, so we need to make us a TravelLog
                CreateTravelLog(&_bbd._ptl);
            }
            else
            {
                pbs->GetTravelLog(&_bbd._ptl);
            }
            pbs->Release();
        }
    }

    return _bbd._ptl ? _bbd._ptl->QueryInterface(IID_PPV_ARG(ITravelLog, pptl)) : E_FAIL;
}

HRESULT CBaseBrowser2::InitializeTravelLog(ITravelLog* ptl, DWORD dwBrowserIndex)
{
    ptl->QueryInterface(IID_PPV_ARG(ITravelLog, &_bbd._ptl));   // hold a copy
    _dwBrowserIndex = dwBrowserIndex;
    return S_OK;
}

// Let the top level browser know that it might need to update it's zones information
void CBaseBrowser2::_Exec_psbMixedZone()
{
    IShellBrowser *psbTop;
    if (SUCCEEDED(_pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psbTop)))) 
    {
        IUnknown_Exec(psbTop, &CGID_Explorer, SBCMDID_MIXEDZONE, 0, NULL, NULL);
        psbTop->Release();
    }
}

STDMETHODIMP CBaseBrowser2::QueryUseLocalVersionVector(BOOL *pfUseLocal)
{
    *pfUseLocal = FALSE;
    return S_OK;
}

STDMETHODIMP CBaseBrowser2::QueryVersionVector(IVersionVector *pVersion)
{
    HRESULT    hr;
    ULONG      cchVer = 0;

    // Was IE's version set by a registry entry?
    // This simplified call checks for presence of the IE string
    //
    hr = pVersion->GetVersion(L"IE", NULL, &cchVer);
    ASSERT(hr == S_OK);

    if (cchVer == 0)
    {
        // Not already set.  Set it to default value.
        // Note that the four digits of precision is required due to a peculiarity in the parser.
        //
        hr = pVersion->SetVersion(L"IE", L"6.0000");
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FindWindowByIndex
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns the window with the given index.
//
//--------------------------------------------------------------------------
HRESULT
CBaseBrowser2::FindWindowByIndex(DWORD dwID, IUnknown ** ppunk)
{
    return GetBrowserByIndex(dwID, ppunk);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetWindowData
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns a WINDOWDATA structure containing pertinent
//              window information needed for the travel log.. 
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::GetWindowData(LPWINDOWDATA pWinData)
{
    HRESULT hr = S_OK;

    ASSERT(pWinData);
    ASSERT(_bbd._pidlCur);

    DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
    DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
    DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::ActivatePendingView (TRAVELLOG): _UpdateTravelLog called from shdocvw for %ws", szPath);)

    memset(pWinData, 0, sizeof(WINDOWDATA));

    // Window ID and codepage
    //
    pWinData->dwWindowID = GetBrowserIndex();
    pWinData->uiCP       = _cp;

    // Current Pidl
    //
    pWinData->pidl = ILClone(_bbd._pidlCur);

    // Title - when we are in a shell view, 
    // _bbd._pszTitleCur is NULL, which is correct.
    // However, we still have to create memory for
    // pWinData->lpszTitle and you can't pass NULL
    // to SHStrDupW.
    //
    if (_bbd._pszTitleCur)
        hr = SHStrDupW(_bbd._pszTitleCur, &pWinData->lpszTitle);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::LoadHistoryPosition
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Loads the Url location and position cookie. This is used 
//              during a history navigation in a frame that involves a
//              local anchor. 
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie)
{
    IEPlaySound(TEXT("Navigating"), FALSE);

    return SetPositionCookie(dwCookie);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetDummyWindowData
//
//  Interface : ITravelLogClient2
//
//  Synopsis  : Fills in a windowdata and a stream very similar to 
//              that created by SaveHistory.
//              Be sure to keep this and SaveHistory in sync.
//
//--------------------------------------------------------------------------

STDMETHODIMP CBaseBrowser2::GetDummyWindowData(
        LPWSTR pszUrl, 
        LPWSTR pszTitle,
        LPWINDOWDATA pWinData)
{
    HRESULT hres = S_OK;
    PERSISTEDFRAME pf = {0};
    LPITEMIDLIST pidl;

      // grab current window ID
    pWinData->dwWindowID = GetBrowserIndex();

      // everything else is dummy
    pWinData->uiCP = 0;
    hres = SHStrDup(pszUrl, &pWinData->lpszUrl);
    hres = SHStrDup(pszTitle, &pWinData->lpszTitle);

    if (!pWinData->pStream)
    {
      hres = CreateStreamOnHGlobal(NULL, FALSE, &pWinData->pStream);
      if (hres)
          goto done;
    }

    pidl = PidlFromUrl(pszUrl);

    pf.cbSize = SIZEOF(pf);
    pf.bid = GetBrowserIndex();
    pf.cbPidl = ILGetSize(pidl);
    pf.type = PFTYPE_USEPIDL;
    pf.lock = 0; // _bbd._eSecureLockIcon;

    ASSERT(SUCCEEDED(IStream_Write(pWinData->pStream, (void *) c_szFrameMagic, CbFromCch(c_cchFrameMagic))));

    if (SUCCEEDED(hres = IStream_Write(pWinData->pStream,(void *)&pf, pf.cbSize)))
        hres = IStream_Write(pWinData->pStream,(void *)pidl, pf.cbPidl);

    ILFree(pidl); 

done:
    return SUCCEEDED(hres) ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::UpdateDesktopComponent
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::UpdateDesktopComponent(IHTMLWindow2 * pHTMLWindow)
{
    BSTR bstrTitle = NULL;
    BSTR bstrUrlUnencoded = NULL;
    HRESULT hr = S_OK;
    IHTMLDocument2 * pHTMLDocument2;
    IHTMLDocument4 * pHTMLDocument4;
    DWORD   dwOptions = 0;

    hr = pHTMLWindow->get_document(&pHTMLDocument2);
    if (SUCCEEDED(hr))
    {
        hr = pHTMLDocument2->QueryInterface(IID_IHTMLDocument4, (void**)&pHTMLDocument4);

        if (SUCCEEDED(hr))
        {
            pHTMLDocument2->get_title(&bstrTitle);
            pHTMLDocument4->get_URLUnencoded(&bstrUrlUnencoded);

            TraceMsg(DM_TRACE, "CBaseBrowser2::UpdateDesktopComponent: URLUnencoded - %ws; Title - %ws",
                     bstrUrlUnencoded, bstrTitle);

            // Update the desktop component's friendly name.
            //
            UpdateDesktopComponentName(bstrUrlUnencoded, bstrTitle);
            
            SysFreeString(bstrTitle);
            SysFreeString(bstrUrlUnencoded);

            pHTMLDocument4->Release();
        }

        pHTMLDocument2->Release();
    }

    return hr;
}

HRESULT
CBaseBrowser2::_InitDocHost(IWebBrowser2 * pWebBrowser)
{
    HRESULT     hr = E_FAIL;
    IDispatch*  pDocDispatch = NULL;

    ASSERT(pWebBrowser);

    // get the IHTMLWindow2 for the WebOC windowop
    hr = pWebBrowser->get_Document(&pDocDispatch);

    if (S_OK == hr && pDocDispatch)
    {
        IHTMLDocument2* pDoc;    
        
        hr = pDocDispatch->QueryInterface(IID_IHTMLDocument2, 
                                          (void **)&pDoc);
        pDocDispatch->Release();

        if (S_OK == hr)
        {
            IHTMLWindow2* pHtmlWindow;
            
            hr = pDoc->get_parentWindow(&pHtmlWindow);
            pDoc->Release();

            if (S_OK == hr)
            {
                BOOL fIsFrameWindow = IsFrameWindow(pHtmlWindow);
                pHtmlWindow->Release();

                if (!fIsFrameWindow && _bbd._pctView)
                {
                    hr = _bbd._pctView->Exec(&CGID_ShellDocView, 
                                             SHDVID_NAVSTART, 
                                             0, 
                                             NULL, 
                                             NULL);
                }
            }
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireBeforeNavigate2
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireBeforeNavigate2(IDispatch * pDispatch,
                                   LPCTSTR     lpszUrl,
                                   DWORD       dwFlags,
                                   LPCTSTR     lpszFrameName,
                                   LPBYTE      pPostData,
                                   DWORD       cbPostData,
                                   LPCTSTR     lpszHeaders,
                                   BOOL        fPlayNavSound,
                                   BOOL      * pfCancel)
{
    HRESULT      hr = S_OK;
    BSTR         bstrUrl = NULL;
    LPITEMIDLIST pidl = NULL;
    IWebBrowser2 * pWebBrowser = NULL;

    ASSERT(pfCancel);

    *pfCancel = FALSE;
        
    // Stress fix
    //
    if (NULL == lpszUrl)
    {
        bstrUrl = SysAllocString(_T(""));
    }
    else
    {
        bstrUrl = SysAllocString(lpszUrl);
    }

    pidl = PidlFromUrl(bstrUrl);

    if (pidl)
    {

        hr = _GetWebBrowserForEvt(pDispatch, &pWebBrowser);

        if (S_OK == hr)
        {
            ASSERT(pWebBrowser);

            //
            // Note that I am casting lpszFrameName and lpszHeaders to
            // TCHAR*. FireEvent_BeforeNavigate doesn't actually change
            // these parameters but it still takes LPTSTRs instead
            // of LPCTSTRs for these parameters - Uuugggghhh!
            //

            _pidlBeforeNavigateEvent = pidl; // no need to copy.

            // This is a work around for view linked weboc. Setting the frame name has side effects.
        
            TCHAR * pEffectiveName;

            if (_fIsViewLinkedWebOC && (lpszFrameName == NULL || !lpszFrameName[0]))
            {
                pEffectiveName = _szViewLinkedWebOCFrameName;
            }
            else
            {
                pEffectiveName = const_cast<TCHAR*>(lpszFrameName);
            }

            FireEvent_BeforeNavigate(pWebBrowser, _bbd._hwnd, pWebBrowser,
                                     pidl, NULL, dwFlags, pEffectiveName,
                                     pPostData, cbPostData, const_cast<TCHAR*>(lpszHeaders), pfCancel);

            // Make sure that we remove earlier URLs that are cached during redirections.
            _InitDocHost(pWebBrowser);

            ATOMICRELEASE(pWebBrowser);

            ASSERT(_pidlBeforeNavigateEvent == pidl);
            _pidlBeforeNavigateEvent = NULL;

            ILFree(pidl);

            if (!*pfCancel && fPlayNavSound)
            {
                IEPlaySound(TEXT("Navigating"), FALSE);
            }
        }        
    }

    if (_phtmlWS && !pDispatch)
    {
        if (!_bbd._psvPending)
        {
            _phtmlWS->ViewReleased();
        }
        else
        {
            _phtmlWS->ViewReleaseIntelliForms();
        }
    }
    else if (_phtmlWS && !_bbd._psvPending)
    {
        _DismissFindDialog();
    }

    SysFreeString(bstrUrl);
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireNavigateError
//
//  Interface : ITridentService2
//
//  Called when there is a binding error
//
//  Input     : pHTMLWindow         - used to determine if we are a frame or 
//                                    the top-level.
//              bstrURL             - the URL which caused the error.                                   
//              bstrTargetFrameName - the frame being targeted.
//              dwStatusCode        - the binding error
//              pfCancel            - set by the host if it wants to 
//                                    cancel autosearch or friendly error
//                                    pages
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireNavigateError(IHTMLWindow2 * pHTMLWindow2, 
                                 BSTR           bstrURL,
                                 BSTR           bstrTargetFrameName,
                                 DWORD          dwStatusCode,
                                 BOOL         * pfCancel)
{
    ASSERT(!pHTMLWindow2 || !IsBadReadPtr(pHTMLWindow2, sizeof(IHTMLWindow2*)));
    ASSERT(!bstrURL      || !IsBadReadPtr(bstrURL, sizeof(BSTR)));
    ASSERT(!bstrTargetFrameName || !IsBadReadPtr(bstrTargetFrameName, sizeof(BSTR)));
    ASSERT(dwStatusCode != 0);
    ASSERT(!IsBadWritePtr(pfCancel, sizeof(BOOL)));

    HRESULT hr = S_OK;
    IWebBrowser2 * pWebBrowser = NULL;

    *pfCancel = FALSE;

    //
    //  Use top-level if window is not specified or the window is the top-level 
    //
    if ((pHTMLWindow2 != NULL) && IsFrameWindow(pHTMLWindow2))
    {
        hr = _GetWebBrowserForEvt(pHTMLWindow2, &pWebBrowser);
    }
    else
    {
        hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);
    }

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);

        TCHAR  szUrl[INTERNET_MAX_URL_LENGTH];

        LPITEMIDLIST pidl = NULL;

        if (bstrURL)
        {
            StrCpyN(szUrl, bstrURL, ARRAYSIZE(szUrl));
        }
        else
        {
            StrCpyN(szUrl,_T(""), ARRAYSIZE(szUrl));
        }

        pidl = PidlFromUrl(szUrl);

        if (pidl)
        {
            FireEvent_NavigateError(pWebBrowser, 
                                    pWebBrowser,
                                    pidl,
                                    bstrTargetFrameName,
                                    dwStatusCode,
                                    pfCancel);
            ILFree(pidl);
        }
    }

    ATOMICRELEASE(pWebBrowser);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FirePrintTemplateEvent
//
//  Interface : ITridentService
//
//  Called when a template is instantiate or torndown
//
//  pHTMLWindow is used to determine if we are a frame or the top-level
//  dispidPrintEvent either DISPID_PRINTTEMPLATEINSTANTIATION 
//                   or     DISPID_PRINTTEMPLATETEARDOWN 
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FirePrintTemplateEvent(IHTMLWindow2 * pHTMLWindow2, DISPID dispidPrintEvent)
{
    HRESULT hr = S_OK;

    IWebBrowser2 * pWebBrowser = NULL;

    //
    //  Use top-level if window is not specified or the window is the top-level 
    //
    if ((pHTMLWindow2 != NULL) && IsFrameWindow(pHTMLWindow2))
    {
        hr = _GetWebBrowserForEvt(pHTMLWindow2, &pWebBrowser);
    }
    else
    {
        hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);
    }

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);

        FireEvent_PrintTemplateEvent(pWebBrowser, 
                                     pWebBrowser,
                                     dispidPrintEvent);
    }

    ATOMICRELEASE(pWebBrowser);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireUpdatePageStatus
//
//  Interface : ITridentService
//
//  Called when a template is instantiate or torndown
//
//  pHTMLWindow is used to determine if we are a frame or the top-level
//  nPage defined to be the number of pages spooled
//  fDone a flag to indicate that the last page has been sppoled
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireUpdatePageStatus(IHTMLWindow2 * pHTMLWindow2, DWORD nPage, BOOL fDone)
{
    HRESULT hr = S_OK;

    IWebBrowser2 * pWebBrowser = NULL;

    //
    //  Use top-level if window is not specified or the window is the top-level 
    //
    if  ((pHTMLWindow2 != NULL) && IsFrameWindow(pHTMLWindow2))
    {
        hr = _GetWebBrowserForEvt(pHTMLWindow2, &pWebBrowser);
    }
    else
    {
        hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);
    }

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);

        FireEvent_UpdatePageStatus(pWebBrowser, 
                                   pWebBrowser,
                                   nPage,
                                   fDone);
    }

    ATOMICRELEASE(pWebBrowser);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FirePrivacyImpactedStateChange
//
//  Interface : ITridentService2
//
//  Called whenever the global privacy impacted state changes
//
//  Input     : The new privacy impacted state
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FirePrivacyImpactedStateChange(BOOL bPrivacyImpacted)
{
    HRESULT         hr          = S_OK;
    IWebBrowser2  * pWebBrowser = NULL;

    //
    // Update browser frame / save state
    //
    _UpdatePrivacyIcon(TRUE, bPrivacyImpacted);

    //
    // We always fire this at the top level 
    //
    hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);
        FireEvent_PrivacyImpactedStateChange(pWebBrowser, 
                                     bPrivacyImpacted);
    }

    ATOMICRELEASE(pWebBrowser);
    return hr;
}
    
HRESULT
CBaseBrowser2::_DismissFindDialog()
{
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        VARIANT varProp = {0};
        _bbd._pautoWB2->GetProperty(bstrName, &varProp);

        if ( (varProp.vt == VT_DISPATCH) && (varProp.pdispVal != NULL) )
        {
            IUnknown* pWindow = varProp.pdispVal;

            //now that we've pulled the pdispVal out of the propbag, clear the property on the automation object
            VARIANT varTmp = {0};
            _bbd._pautoWB2->PutProperty(bstrName, varTmp);

            //(davemi) see IE5 bug 57060 for why the below line doesn't work and IDispatch must be used instead
            //pWindow->close();
            IDispatch * pdisp;
            if (SUCCEEDED(pWindow->QueryInterface(IID_IDispatch, (void**)&pdisp)))
            {
                DISPID dispid;
                DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

                BSTR bstrClose = SysAllocString(L"close");
                if (bstrClose)
                {
                    HRESULT hr;

                    hr = pdisp->GetIDsOfNames(IID_NULL, &bstrClose, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                    if (hr == S_OK)
                        pdisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &dispparamsNoArgs, &varTmp, NULL, NULL);

                    SysFreeString(bstrClose);
                }

                pdisp->Release();
            }
        }
        
        VariantClear(&varProp);
        SysFreeString(bstrName);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::_GetWebBrowserForEvt
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::_GetWebBrowserForEvt(IDispatch     * pDispatch,
                                    IWebBrowser2 ** ppWebBrowser)
{
    if (_fIsViewLinkedWebOC && _pDispViewLinkedWebOCFrame && _fHadFirstBeforeNavigate)
    {
        *ppWebBrowser = _pDispViewLinkedWebOCFrame;
        _pDispViewLinkedWebOCFrame->AddRef();

        return S_OK;
    }
    else if (pDispatch)  // Top-level
    {
        return IUnknown_QueryService(pDispatch,
                                     SID_SWebBrowserApp,
                                     IID_PPV_ARG(IWebBrowser2, ppWebBrowser));
    }        
    else
    {
        *ppWebBrowser = _bbd._pautoWB2;

        if (*ppWebBrowser)
        {
            (*ppWebBrowser)->AddRef();
            return S_OK;
        }

        return E_FAIL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetUrlSearchComponent
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::GetUrlSearchComponent(BSTR * pbstrSearch)
{
    TCHAR sz[MAX_URL_STRING];

    ASSERT(pbstrSearch);
    ASSERT(!*pbstrSearch);
    if (ILGetHiddenString(_bbd._pidlPending ? _bbd._pidlPending : _bbd._pidlCur,
                          IDLHID_URLQUERY,
                          sz,
                          SIZECHARS(sz)))
    {
        *pbstrSearch = SysAllocString(sz);
    }
    return (*pbstrSearch) ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::IsErrorUrl
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::IsErrorUrl(LPCTSTR lpszUrl, BOOL *pfIsError)
{
    HRESULT hr = S_OK;
    
    if (!lpszUrl || !pfIsError)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfIsError = ::IsErrorUrl(lpszUrl);
    
Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireNavigateComplete2
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireNavigateComplete2(IHTMLWindow2 * pHTMLWindow2,
                                     DWORD          dwFlags)
{
    if (!pHTMLWindow2)
        return E_POINTER;

    HRESULT hr = E_FAIL;
    BOOL    fIsErrorUrl = FALSE;

    BSTR bstrUrl = GetHTMLWindowUrl(pHTMLWindow2);
    if (bstrUrl)
    {
        // If the URL is a res: URL, _GetPidlForDisplay will return
        // the URL after the # in the res: URL.
        //
        LPITEMIDLIST pidl = _GetPidlForDisplay(bstrUrl, &fIsErrorUrl);

        if (pidl)
        {
            BOOL fViewActivated = FALSE;
            IWebBrowser2 * pWebBrowser = NULL;

            // If this is not a frame, we update the browser
            // state and pass the browser's IWebBrowser2 to 
            // FireEvent_NavigateComplete. If this is a frame,
            // we pass the IWebBrowser2 of the window.
            //
            if (!(dwFlags & NAVDATA_FRAMEWINDOW))
            {
                fViewActivated = _ActivateView(bstrUrl, pidl, dwFlags, fIsErrorUrl);

                if (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
                {
                    ATOMICRELEASE(_pHTMLDocument);
                    pHTMLWindow2->get_document(&_pHTMLDocument);
                }
            }
            else
            {
                if (IsWindowVisible(_bbd._hwnd) 
                    && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)
                    && !(dwFlags & NAVDATA_FRAMECREATION)
                    && !(dwFlags & NAVDATA_RESTARTLOAD)) 
                {
                    IEPlaySound(TEXT("ActivatingDocument"), FALSE);
                }   

                if (_pbsOuter)
                {
                    _pbsOuter->UpdateBackForwardState();
                }
            }

            hr = _GetWebBrowserForEvt((dwFlags & NAVDATA_FRAMEWINDOW) ? pHTMLWindow2 : NULL,
                                      &pWebBrowser);

            if (S_OK == hr && !fViewActivated)
            {
                ASSERT(pWebBrowser);

                // fire the event!
                FireEvent_NavigateComplete(pWebBrowser, pWebBrowser, pidl, _bbd._hwnd);           
            }

            ATOMICRELEASE(pWebBrowser);

            ILFree(pidl);
        }

        SysFreeString(bstrUrl);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
// Method   : CBaseBrowser2::_ActivateView
//
// Synopsis : If there is a pending view, it will be activated. If there
//            if not a pending view, which is the case when we are 
//            navigating due to a hyperlink, OM navigation, or frame
//            navigation, we update the browser state. (The view is already
//            active in this case.)  In either case, we update the
//            state of the dochost.
//
//--------------------------------------------------------------------------

BOOL
CBaseBrowser2::_ActivateView(BSTR         bstrUrl,
                             LPITEMIDLIST pidl,
                             DWORD        dwFlags,
                             BOOL         fIsErrorUrl)
{
    BOOL fViewActivated = FALSE;

    // Activate the pending view if there is one.
    //
    if (_bbd._psvPending)
    {
        ILFree(_bbd._pidlPending);

        _bbd._pidlPending = ILClone(pidl);

         _fDontUpdateTravelLog = !!(dwFlags & NAVDATA_DONTUPDATETRAVELLOG);

         ASSERT(_pbsOuter);
         _pbsOuter->ActivatePendingView();

        _fDontUpdateTravelLog = FALSE;
        fViewActivated = TRUE;
    }
    else
    {
        UINT uProt = GetUrlSchemeW(bstrUrl);

        if (   uProt != URL_SCHEME_JAVASCRIPT 
            && uProt != URL_SCHEME_VBSCRIPT)
        {
            _UpdateBrowserState(pidl);
        }

        // In the case where there is a pending view
        // ActivatePendingView() will call ViewActivated().
        // Also, the call to ViewActivated() must happen
        // after the current pidl has changed. The current
        // pidl changes in _UpdateBrowserState().
        // 
        if (_phtmlWS)
        {
            _phtmlWS->ViewActivated();
        }

        // Don't play sound for the first navigation (to avoid multiple
        // sounds to be played for a frame-set creation).
        //

        ASSERT(_bbd._psv);

        if (IsWindowVisible(_bbd._hwnd) && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)) 
        {
            IEPlaySound(TEXT("ActivatingDocument"), FALSE);
        }                    
    }

    // In the case of an error URL, we must send the original URL
    // to the dochost. It needs the res: URL in the case of an 
    // error page so it knows not to update the history.
    //
    if (!fIsErrorUrl)
    {
        _UpdateDocHostState(pidl, fIsErrorUrl);
    }
    else
    {
        LPITEMIDLIST pidlOriginal = PidlFromUrl(bstrUrl);

        if (pidlOriginal)
        {
            _UpdateDocHostState(pidlOriginal, fIsErrorUrl);
            ILFree(pidlOriginal);
        }
    }

    if (_pbsOuter)
    {
        _pbsOuter->_OnFocusChange(ITB_VIEW);
    }

    return fViewActivated;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::_UpdateBrowserState
//
//--------------------------------------------------------------------------

void
CBaseBrowser2::_UpdateBrowserState(LPCITEMIDLIST pidl)
{
    ASSERT(pidl);

    ILFree(_bbd._pidlCur);

    _bbd._pidlCur = ILClone(pidl);

    // With the _bbd._pidlCur now updated, we can now call UpdateWindowList to 
    // update the window list with the new pidl.
    //
    _pbsOuter->UpdateWindowList();
    _fGeneratedPage = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::_UpdateDocHostState
//
//--------------------------------------------------------------------------

void
CBaseBrowser2::_UpdateDocHostState(LPITEMIDLIST pidl, BOOL fIsErrorUrl) const
{
    DOCHOSTUPDATEDATA dhud;
    VARIANT varVal;

    ASSERT(  (_bbd._psvPending  &&  _bbd._pidlPending)
          || (!_bbd._psvPending && !_bbd._pidlPending));

    ASSERT(!_bbd._pidlPending || ILIsEqual(_bbd._pidlPending, pidl) || fIsErrorUrl);

    IShellView * psv = _bbd._psvPending ? _bbd._psvPending : _bbd._psv;
    ASSERT(psv);

    dhud._pidl = pidl;       
    dhud._fIsErrorUrl = fIsErrorUrl;

    varVal.vt = VT_PTR;
    varVal.byref = &dhud;

    IUnknown_Exec(psv, &CGID_ShellDocView, 
                  SHDVID_UPDATEDOCHOSTSTATE, 0, &varVal, NULL);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireDocumentComplete
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireDocumentComplete(IHTMLWindow2 * pHTMLWindow2,
                                    DWORD          dwFlags)
{
    if (!pHTMLWindow2)
        return E_POINTER;

    HRESULT hr = E_FAIL;

    BSTR bstrUrl = GetHTMLWindowUrl(pHTMLWindow2);
    if (bstrUrl)
    {                      
        LPITEMIDLIST pidl = _GetPidlForDisplay(bstrUrl);

        if (pidl)
        {
            IWebBrowser2 * pWebBrowser;

            hr = _GetWebBrowserForEvt((dwFlags & NAVDATA_FRAMEWINDOW) ? pHTMLWindow2 : NULL,
                                      &pWebBrowser);
            ASSERT(pWebBrowser);

            if (S_OK == hr)
            {
                FireEvent_DocumentComplete(pWebBrowser, pWebBrowser, pidl);
                pWebBrowser->Release();
            }

            ILFree(pidl);
        }

        SysFreeString(bstrUrl);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireDownloadBegin
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireDownloadBegin()
{
    return _updateNavigationUI();
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireDownloadComplete
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireDownloadComplete()
{
    return _updateNavigationUI();
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetPendingUrl
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::GetPendingUrl(BSTR * pbstrPendingUrl)
{
    if (!pbstrPendingUrl)
        return E_POINTER;

    *pbstrPendingUrl = NULL;

    LPITEMIDLIST pidl = _bbd._pidlPending ? _bbd._pidlPending : _bbd._pidlCur;

    TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];

    HRESULT hr = IEGetDisplayName(pidl, szPath, SHGDN_FORPARSING);
    if (S_OK == hr)
    {
        TraceMsg(DM_TRACE, "CBaseBrowser2::GetPendingUrl - URL: %ws", szPath);

        *pbstrPendingUrl = SysAllocString(szPath);
    }

    return (*pbstrPendingUrl) ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::ActiveElementChanged
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::ActiveElementChanged(IHTMLElement * pHTMLElement)
{
    // Forward the call to the OmWindow
    //
    if (_phtmlWS)
    {
        return _phtmlWS->ActiveElementChanged(pHTMLElement);
    }

    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::InitAutoImageResize()
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::InitAutoImageResize()
{
    HRESULT            hr           = S_OK;
    IHTMLDocument2    *pDoc2        = NULL;
    IDispatch         *pDocDispatch = NULL;

    CAutoImageResize  *pAIResize    = new CAutoImageResize();
    
    if (_pAIResize)
        UnInitAutoImageResize();

    if (pAIResize)
    {
    
        // need to get a pDoc2 for the init call...
        hr = _bbd._pautoWB2->get_Document(&pDocDispatch);
        if (FAILED(hr))
            goto Cleanup;
   
        hr = pDocDispatch->QueryInterface(IID_IHTMLDocument2,(void **)&pDoc2);
        if (FAILED(hr) || !pDoc2)
            goto Cleanup;

        // init the object
        pAIResize->Init(pDoc2); 

        // cache the pointer for destruction later
        _pAIResize=pAIResize;   
    }
    else
        hr = E_OUTOFMEMORY;

Cleanup:

    SAFERELEASE(pDoc2);
    SAFERELEASE(pDocDispatch);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::UnInitAutoImageResize()
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::UnInitAutoImageResize()
{
    if(_pAIResize)
    {
        _pAIResize->UnInit();
        ATOMICRELEASE(_pAIResize);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::IsGalleryMeta
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::IsGalleryMeta(BOOL bFlag, void *pMyPics)
{
    // Forward the call to the CMyPics object
    //

    if (pMyPics)
    {
        ((CMyPics*)pMyPics)->IsGalleryMeta(bFlag);
        return S_OK;
    }

    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
// Functions that live in mypics.cpp that are called below
//
//--------------------------------------------------------------------------

HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite);
BOOL    MP_IsEnabledInIEAK();
BOOL    MP_IsEnabledInRegistry();


//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::EmailPicture
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::EmailPicture(BSTR bstrURL)
{
    LPITEMIDLIST       pidlForImg = NULL;
    IOleCommandTarget *pcmdt      = NULL;
    IServiceProvider  *pSP        = NULL;
    unsigned int       uiCodePage = 0;
    DWORD              dwSendAs   = FORCE_COPY;
    HRESULT            hr         = S_OK;

    IHTMLDocument2    *pDoc2      = NULL;
    IDispatch         *pDocDispatch = NULL;
    
    hr = _bbd._pautoWB2->get_Document(&pDocDispatch);
    if (FAILED(hr))
        return(hr);
    
    hr = pDocDispatch->QueryInterface(IID_IHTMLDocument2, 
         (void **)&pDoc2);
    if (FAILED(hr)) {
        pDocDispatch->Release();
        return(hr);
    }
    
    // Get the ISP and cache it...
    hr = pDoc2->QueryInterface(IID_IServiceProvider, (void**)&pSP);
    if (FAILED(hr)) {
        pDoc2->Release();
        pDocDispatch->Release();
        return(hr);
    }

    // use ISP pointer to get that cmd target thingie...
    hr = pSP->QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IOleCommandTarget, &pcmdt));
    if (FAILED(hr)) {
        pSP->Release();
        pDoc2->Release();
        pDocDispatch->Release();
        return(hr);
    }

    // ... and thus the pidl...
    IEParseDisplayName(CP_ACP, bstrURL, &pidlForImg);
    
    // ... and pray this works...
    SendDocToMailRecipient(pidlForImg, uiCodePage, dwSendAs, pcmdt);
    
    ILFree(pidlForImg);
    pcmdt->Release();
    pSP->Release();
    pDoc2->Release();
    pDocDispatch->Release();
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::AttachMyPics
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------


HRESULT
CBaseBrowser2::AttachMyPics(void *pDoc2, void **ppMyPics)
{
    IHTMLDocument2 *pdoc2     = (IHTMLDocument2 *)pDoc2;
    DWORD           dwOptions = 0;

    ASSERT(ppMyPics && *ppMyPics==NULL);

    if (!MP_IsEnabledInIEAK()     || 
        !MP_IsEnabledInRegistry() ||
        !IsInternetExplorerApp()) 
    {
        return S_OK;
    }

    if (!pdoc2 || !ppMyPics || (*ppMyPics != NULL)) 
    {
        return S_OK;
    }

    //Is this a desktop component?                    
    if (SUCCEEDED(GetTopFrameOptions(_pspOuter, &dwOptions)))
    {    
        if (dwOptions & FRAMEOPTIONS_DESKTOP) 
        {
            return S_OK;
        }
    }

    CMyPics *pPics = new CMyPics();

    if (pPics)
    {
        if (SUCCEEDED(pPics->Init(pdoc2))) 
        {
            *ppMyPics = pPics;
        } 
        else 
        {
            pPics->Release();
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::ReleaseMyPics
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

BOOL
CBaseBrowser2::ReleaseMyPics(void *pMyPics)
{
    CMyPics *pPics = (CMyPics *) pMyPics;

    BOOL bRet = pPics->IsOff();

    if (pPics) 
    {
        pPics->UnInit();
        pPics->Release();
    }

    return (bRet);
}

STDMETHODIMP CBaseBrowser2::SetFrameName(BSTR bstrFrameName)
{
    _tcscpy(_szViewLinkedWebOCFrameName, bstrFrameName);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::AppStarting
//
//  Interface : INotifyAppStart
//
//--------------------------------------------------------------------------
HRESULT
CBaseBrowser2::AppStarting(void)
{
    _dwStartingAppTick = GetTickCount();
    SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
    SetTimer( _bbd._hwnd, IDT_STARTING_APP_TIMER, STARTING_APP_DURATION, NULL);

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::AppStarted
//
//  Interface : INotifyAppStart
//
//--------------------------------------------------------------------------
HRESULT
CBaseBrowser2::AppStarted(void)
{
    _dwStartingAppTick = 0;
    KillTimer( _bbd._hwnd, IDT_STARTING_APP_TIMER );
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\browsext.cpp ===
#include "priv.h"
#include "browsext.h"
#include "tbext.h"
#include <winreg.h>     // For the registry walking
#include "dochost.h"
#include "resource.h"
#include <mluisupp.h>
#include <tb_ids.h>


// {DFEED31E-78ED-11d2-86BA-00C04F8EEA99}
EXTERN_C const IID IID_IToolbarExt = 
{ 0xdfeed31e, 0x78ed, 0x11d2, { 0x86, 0xba, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99 } };

// {D82B85D0-78F4-11d2-86BA-00C04F8EEA99}
EXTERN_C const CLSID CLSID_PrivBrowsExtCommands =
{ 0xd82b85d0, 0x78f4, 0x11d2, { 0x86, 0xba, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99 } };

const TCHAR c_szHelpMenu[]  = TEXT("help");

//+-------------------------------------------------------------------------
// Creates and instance of CBrowserExtension
//--------------------------------------------------------------------------
HRESULT CBrowserExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;
    CBrowserExtension* p = new CBrowserExtension();
    if (p)
    {
        *ppunk = SAFECAST(p, IToolbarExt*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CBrowserExtension::CBrowserExtension()
:   _cRef(1),
    _uStringIndex((UINT)-1),
    _uiImageIndex((UINT)-1)
{
    ASSERT(_pISB == NULL);
    ASSERT(_hdpa == NULL);
    ASSERT(_nExtButtons == 0);
    ASSERT(_fStringInit == FALSE);
    ASSERT(_fImageInit == FALSE);
}

CBrowserExtension::~CBrowserExtension(void)
{
    if (_pISB)
        _pISB->Release();

    if (_hdpa)
    {
        _FreeItems();
        DPA_Destroy(_hdpa);
        _hdpa = NULL;
    }

    _ReleaseImageLists(_uiImageIndex);
}

// *** IUnknown methods ***

HRESULT CBrowserExtension::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBrowserExtension, IToolbarExt),
        QITABENT(CBrowserExtension, IObjectWithSite),
        QITABENT(CBrowserExtension, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CBrowserExtension::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBrowserExtension::Release()
{
    if (InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}

// IToolbarExt interface functions
HRESULT CBrowserExtension::SetSite(IUnknown* pUnkSite)
{
    HRESULT hr = S_OK;

    ATOMICRELEASE(_pISB);

    if (pUnkSite)
    {
        hr = pUnkSite->QueryInterface(IID_IShellBrowser, (LPVOID*)&_pISB);
    }

    // See if we need to init ourselves
    if (NULL == _hdpa)
    {
        // Real construction happens here
        HRESULT hr2 = Update();

        ASSERT(SUCCEEDED(hr2));
    }
    else
    {
        // Update the site for each button/menu extension
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            IUnknown_SetSite(pItem->pIBE, _pISB);
        }
    }
    return hr;
}

STDMETHODIMP CBrowserExtension::GetSite(REFIID riid, void ** ppvSite)
{
    HRESULT hr = S_OK;
    *ppvSite = NULL;

    if (_pISB)
    {
        hr = _pISB->QueryInterface(riid, ppvSite);
    }
    return hr;
}

HRESULT CBrowserExtension::GetNumButtons(UINT* pButtons)
{
    ASSERT(pButtons);
    *pButtons = _nExtButtons;
    return S_OK;
}

HRESULT CBrowserExtension::InitButtons(IExplorerToolbar* pxtb, UINT* puStringIndex, const GUID* pguidCommandGroup)
{
    ASSERT(pxtb);

    UINT uiSize;
    pxtb->GetBitmapSize(&uiSize);
    int cx = LOWORD(uiSize);

    // Get the image lists for the current button size and screen resolution
    CImageList* pimlDef;
    CImageList* pimlHot;
    UINT uiImageIndexOld = _uiImageIndex;
    _uiImageIndex = _GetImageLists(&pimlDef, &pimlHot, cx < 20);
    pxtb->SetImageList(pguidCommandGroup, *pimlDef, *pimlHot, NULL);

    // Free the previously used image list
    _ReleaseImageLists(uiImageIndexOld);

    // Add the button text to the toolbar
    if (_uStringIndex == (UINT)-1)
    {
        LRESULT iAddResult = 0; // result of adding the string buffer to the toolbar string list
        HRESULT hr = pxtb->AddString(pguidCommandGroup, MLGetHinst(), IDS_BROWSER_TB_LABELS, &iAddResult);
        _uStringIndex = (UINT)iAddResult;
        _AddCustomStringsToBuffer(pxtb, pguidCommandGroup);
    }

    *puStringIndex = _uStringIndex;
    return S_OK;
}

CBrowserExtension::ExtensionItem* CBrowserExtension::_FindItem(REFGUID rguid)
{
    ExtensionItem* pFound = NULL;
    if (NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);

            if (pItem && IsEqualGUID(pItem->guid, rguid))
            {
                pFound = pItem;
                break;
            }
        }
    }
    return pFound;
}

void CBrowserExtension::_AddItem(HKEY hkeyExtensions, LPCWSTR pszGuidItem, REFGUID rguidItem)
{
    // Create the dpa used to store our items
    if (NULL == _hdpa)
    {
        _hdpa = DPA_Create(5);
        if (NULL == _hdpa)
        {
            return;
        }
    }

    HKEY hkeyThisExtension;

    if (RegOpenKeyEx(hkeyExtensions, pszGuidItem, 0, KEY_READ, &hkeyThisExtension) == ERROR_SUCCESS)
    {
        // Get the clsid of the object
        WCHAR szCLSID[64];
        ULONG cbCLSID = SIZEOF(szCLSID);
        CLSID clsidCustomButton;

        if (SUCCEEDED(RegQueryValueEx(hkeyThisExtension, TEXT("clsid"), NULL, NULL, (unsigned char *)&szCLSID, &cbCLSID)) &&
            SUCCEEDED(CLSIDFromString(szCLSID, &clsidCustomButton)))
        {
            IBrowserExtension * pibeTemp;

            // Check for our internal object.  Note that our CoCreateInctance wrapper
            // compares to the address of the global clsid, so we want to use the global
            // guid.
            const CLSID* pclsid = &clsidCustomButton;
            if (IsEqualGUID(clsidCustomButton, CLSID_ToolbarExtExec))
            {
                pclsid = &CLSID_ToolbarExtExec;
            }
            else if (IsEqualGUID(clsidCustomButton, CLSID_ToolbarExtBand))
            {
                pclsid = &CLSID_ToolbarExtBand;
            }

            // Create the extension object
            if (SUCCEEDED(CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IBrowserExtension, (void **)&pibeTemp)))
            {
                if (SUCCEEDED(pibeTemp->Init(rguidItem)))
                {
                    // Add this item to our array
                    ExtensionItem* pItem = new ExtensionItem;
                    if (pItem)
                    {
                        if (DPA_AppendPtr(_hdpa, pItem) != -1)
                        {
                            VARIANTARG varArg;

                            pItem->idCmd = _GetCmdIdFromClsid(pszGuidItem);
                            pItem->pIBE = pibeTemp;
                            pItem->guid = rguidItem;
                            pibeTemp->AddRef();

                            // See if it's a button
                            if (SUCCEEDED(pibeTemp->GetProperty(TBEX_BUTTONTEXT, NULL)))
                            {
                                _nExtButtons++;
                                pItem->fButton = TRUE;

                                // See if the button default to visible on the toolbar
                                if (SUCCEEDED(pibeTemp->GetProperty(TBEX_DEFAULTVISIBLE, &varArg)))
                                {
                                    ASSERT(varArg.vt == VT_BOOL);
                                    pItem->fVisible = (varArg.boolVal == VARIANT_TRUE);
                                }
                            }

                            // set the target menu
                            
                            pItem->idmMenu = 0;
                            
                            if (SUCCEEDED(pibeTemp->GetProperty(TMEX_MENUTEXT, NULL)))
                            {
                                
                                if (SUCCEEDED(pibeTemp->GetProperty(TMEX_CUSTOM_MENU, &varArg)))
                                {
                                    ASSERT(varArg.vt == VT_BSTR);
                                    ASSERT(IS_VALID_STRING_PTR(varArg.bstrVal, -1));
    
                                    if (!StrCmpNI(varArg.bstrVal, c_szHelpMenu, ARRAYSIZE(c_szHelpMenu)))
                                    {
                                        pItem->idmMenu = FCIDM_MENU_HELP;
                                    }
    
                                    VariantClear(&varArg);
                                }

                                if (pItem->idmMenu == 0)
                                {
                                    pItem->idmMenu = FCIDM_MENU_TOOLS;
                                }
                            }

                            // Pass the site to the object
                            IUnknown_SetSite(pibeTemp, _pISB);
                        }
                        else
                        {
                            delete pItem;
                        }
                    }
                }

                // This will free pibeTemp if we didn't store it away
                pibeTemp->Release();
            }
        }
        RegCloseKey(hkeyThisExtension);
    }
}


//
// All real construction happens here.  In theory this function can be called upon a SysINIChange to update our
// custom toolbar cached information.  This has not been tested.  This opens the Extensions section of the registry
// enumerates all of the subkeys.  Attempts to CoCreate each one.  Upon successful CoCreation it calls
// IObjectWithSite::SetSite(IShellBrowser), if it is implemented.  Next IBrowserExtension::Init is called.  Finally,
// IBrowserExtension::GetProperty(TBEX_BUTTONTEXT, NULL) is called looking for a S_OK to insure that the control in
// question is a Toolbar Button (as opposed to a tools menu item, or...)
//
HRESULT CBrowserExtension::Update()
{
    WCHAR szItemGuid[64];    // sufficient for {clsid}
    DWORD cbItemGuid;
    GUID guidItem;
    HRESULT hr = S_OK;

    // Free previous items
    _nExtButtons = 0;
    _nExtToolsMenuItems = 0;
    _FreeItems();

    // First add extensions from HKCU
    HKEY hkeyExtensions;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions"), 0,
                     KEY_READ, &hkeyExtensions) == ERROR_SUCCESS)
    {
        cbItemGuid = sizeof(szItemGuid);
        for (int iKey = 0;
             RegEnumKeyEx(hkeyExtensions, iKey, szItemGuid, &cbItemGuid, NULL, NULL, NULL, NULL) != ERROR_NO_MORE_ITEMS;
             iKey++)
        {
            if (SUCCEEDED(CLSIDFromString(szItemGuid, &guidItem)))
            {
                _AddItem(hkeyExtensions, szItemGuid, guidItem);
            }
            cbItemGuid = sizeof(szItemGuid);
        }

        RegCloseKey(hkeyExtensions);
    }

    // Next add any unique items from HKLM
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions"), 0,
                     KEY_READ, &hkeyExtensions) == ERROR_SUCCESS)
    {
        cbItemGuid = sizeof(szItemGuid);
        for (int iKey = 0;
             RegEnumKeyEx(hkeyExtensions, iKey, szItemGuid, &cbItemGuid, NULL, NULL, NULL, NULL) != ERROR_NO_MORE_ITEMS;
             iKey++)
        {
            if (SUCCEEDED(CLSIDFromString(szItemGuid, &guidItem)))
            {
                if (_FindItem(guidItem) == NULL)
                {
                    _AddItem(hkeyExtensions, szItemGuid, guidItem);
                }
            }
            cbItemGuid = sizeof(szItemGuid);
        }

        RegCloseKey(hkeyExtensions);
    }

    return hr;
}

//
// This takes a TBBUTTON[] and fills in the Custom Buttons.  A couple of usage points:
// (1) The caller should allocate a TBBUTTON[] big enough for NUM_STD_BUTTONS + GetNumExtButtons()
//     Then they should copy the standard buttons into the array, and pass the pointer to the remainder
//     of the array here.
// (2) This function should *by design* never be called before AddCustomImagesToImageList and
//     AddCustomStringsToBuffer have both been called.  An attempt to do so in DEBUG mode will hit
//     a break point.
//
HRESULT CBrowserExtension::GetButtons(TBBUTTON * tbArr, int nNumButtons, BOOL fInit)
{
    ASSERT(_fStringInit && _fImageInit);

    if (_hdpa)
    {
        ASSERT(nNumButtons == _nExtButtons);
        ASSERT(tbArr != NULL)
        int iBtn = 0;

        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (!pItem->fButton)
                continue;

            // We use the MAKELONG(n, 1) to insure that we are using the alternate image list.
            tbArr[iBtn].iBitmap    = MAKELONG(pItem->iImageID, 1);
            tbArr[iBtn].idCommand  = pItem->idCmd;
            tbArr[iBtn].fsState    = TBSTATE_ENABLED;
            tbArr[iBtn].fsStyle    = BTNS_BUTTON;
            tbArr[iBtn].dwData     = 0;
            tbArr[iBtn].iString    = pItem->iStringID;

            //
            // Default to hidden during initialization so that it defaults to the left well
            // of the the customize dialog (defaults off the toolbar)
            //
            if (fInit && !pItem->fVisible)
            {
                tbArr[iBtn].fsState = TBSTATE_HIDDEN;
            }

            ++iBtn;
        }
    }
    return S_OK;
}

//
// This function takes the ImageLists for hot and normal icons and adds the appropriate icon to each
// list for each custom toolbar button.  The resultant ImageID is then stored in our _rgExtensionItem struct
// so that the IDs can be placed in a TBBUTTON[] when AddExtButtonsTBArray is called.
//
HRESULT CBrowserExtension::_AddCustomImagesToImageList(CImageList& rimlNormal, CImageList& rimlHot, BOOL fSmallIcons)
{
#ifdef DEBUG
    _fImageInit = TRUE;
#endif DEBUG

    if (rimlNormal.HasImages() && rimlHot.HasImages() && NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (!pItem->fButton)
                continue;

            VARIANTARG varArg;

            pItem->iImageID = rimlNormal.GetImageIndex(pItem->guid);
            if (-1 == pItem->iImageID &&
                SUCCEEDED(pItem->pIBE->GetProperty((fSmallIcons ? TBEX_GRAYICONSM : TBEX_GRAYICON), &varArg)))
            {
                if (varArg.vt == VT_BYREF)
                {
                    pItem->iImageID = rimlNormal.AddIcon((HICON)varArg.byref, pItem->guid);
                }
                else if (varArg.vt == VT_I4)
                {
                    // It's one of our built-in images
                    pItem->iImageID = varArg.lVal;
                }
                else
                {
                    TraceMsg(TF_ALWAYS, "Button doesn't have an image associated");
                }
            }

            int iHot = rimlHot.GetImageIndex(pItem->guid);
            if (-1 == iHot &&
                SUCCEEDED(pItem->pIBE->GetProperty((fSmallIcons ? TBEX_HOTICONSM : TBEX_HOTICON), &varArg)))
            {
                if (varArg.vt == VT_BYREF)
                {
                    iHot = rimlHot.AddIcon((HICON)varArg.byref, pItem->guid);
                }
                else if (varArg.vt == VT_I4)
                {
                    // It's one of our built-in images
                    iHot = varArg.lVal;
                }
                else
                {
                    TraceMsg(TF_ALWAYS, "Button doesn't have an image associated");
                }
            }

            if (iHot!=pItem->iImageID)
            {
                TraceMsg(TF_ALWAYS, "ButtonExtension: iHot doesn't match iImageID");
            }
        }
    }

    return S_OK;
}

//
// This function takes the StringList and adds the caption (ToolbarText) for each of the custom toolbar buttons
// to it.  The resultant StringID is then stored in our _rgExtensionItem struct so that the ID can be placed in
// a TBBUTTON[] when AddExtButtonsTBArray is called.
//
HRESULT CBrowserExtension::_AddCustomStringsToBuffer(IExplorerToolbar * pxtb, const GUID* pguidCommandGroup)
{
#ifdef DEBUG
    _fStringInit = TRUE;
#endif DEBUG

    if (NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (!pItem->fButton)
                continue;

            VARIANTARG varArg;

            if (SUCCEEDED(pItem->pIBE->GetProperty(TBEX_BUTTONTEXT, &varArg)))
            {
                // We need to double-null terminate the string!
                WCHAR szBuf[70];    // should be ample for button text!
                ZeroInit(szBuf, sizeof(szBuf));
                StrNCpy(szBuf, varArg.bstrVal, ARRAYSIZE(szBuf) - 2);
                LRESULT iResult;

                if (SUCCEEDED(pxtb->AddString(pguidCommandGroup, 0, (LPARAM)szBuf, &iResult)))
                {
                    pItem->iStringID = (SHORT)iResult;
                }

                VariantClear(&varArg);
            }
        }
    }

    return S_OK;
}

int CBrowserExtension::_GetCmdIdFromClsid(LPCWSTR pszGuid)
{
    DWORD dwDisposition;
    HRESULT hr = S_OK;
    int nReturn = DVIDM_MENUEXT_FIRST; 

    HKEY hkeyExtensionMapping;
    if (RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions\\CmdMapping"), 0, NULL, 0,
                       KEY_READ | KEY_WRITE, NULL, &hkeyExtensionMapping, &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD dwType = REG_DWORD, dwData, cbData = sizeof(dwData);
        
        if ( (SHQueryValueEx(hkeyExtensionMapping, pszGuid, NULL, &dwType, &dwData, &cbData) == ERROR_SUCCESS) &&
             (dwType == REG_DWORD) )
        {
            //the item has a mapping
            nReturn = dwData;
        }
        else
        {
            //it's a new item, get and store the next available id in the default value of the Mapping key
            if ( (SHQueryValueEx(hkeyExtensionMapping, L"NextId", NULL, &dwType, &dwData, &cbData) != ERROR_SUCCESS) ||
                 (dwType != REG_DWORD) )
            {
                dwData = DVIDM_MENUEXT_FIRST;
            }
            nReturn = dwData;

            dwType = REG_DWORD;
            cbData = sizeof(dwData);
            EVAL(SHSetValueW(hkeyExtensionMapping, NULL, pszGuid, dwType, &dwData, cbData) == ERROR_SUCCESS);

            dwData++;
            ASSERT(dwData < DVIDM_MENUEXT_LAST); //ugh, we've used up our whole range. we need to look for holes.
            EVAL(SHSetValueW(hkeyExtensionMapping, NULL, L"NextId", dwType, &dwData, cbData) == ERROR_SUCCESS);
        }
        RegCloseKey(hkeyExtensionMapping);
    }

    return nReturn;
}

int CBrowserExtension::_GetIdpaFromCmdId(int nCmdId)
{
    if (NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (pItem->idCmd == nCmdId)
                return i;
        }
    }
    return -1;
}

// *** IOleCommandTarget methods ***

HRESULT CBrowserExtension::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (!pguidCmdGroup)
        return E_INVALIDARG;

    if (IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        int iCmd = _GetIdpaFromCmdId(nCmdID);

        if (iCmd >= 0 && iCmd < DPA_GetPtrCount(_hdpa))
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, iCmd);
            if (pItem)
                return IUnknown_Exec(pItem->pIBE, NULL, 0, 0, NULL, NULL);
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CLSID_PrivBrowsExtCommands))
    {
        switch (nCmdID)
        {
        case PBEC_GETSTRINGINDEX:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                pvarargIn->lVal = _uStringIndex;
                return S_OK;
            }
            break;
        }
    }

    return E_FAIL;
}

HRESULT CBrowserExtension::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (!pguidCmdGroup)
        return E_INVALIDARG;

    if (IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        for (ULONG i = 0; i < cCmds; i++)
        {
            int iCmd = _GetIdpaFromCmdId(rgCmds[i].cmdID);

            if (iCmd >= 0 && iCmd < DPA_GetPtrCount(_hdpa))
            {
                ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, iCmd);
                if (pItem)
                {
                    // I don't think this has ever worked.  The command id
                    // isn't the same as the one we use in Exec.
                    IUnknown_QueryStatus(pItem->pIBE, pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                }
            }
        }

        return S_OK;
    }

    return E_FAIL;
}

//
// This function is a helper for the destructor.  It is also called by Update() so that if we are ever asked
// to Update() we first kill all of our cached information and then we go to the registry...
//

void CBrowserExtension::_FreeItems(void)
{
    if (_hdpa)
    {
        for (int i = DPA_GetPtrCount(_hdpa) - 1; i >= 0; --i)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_DeletePtr(_hdpa, i);

            IUnknown_SetSite(pItem->pIBE, NULL);
            pItem->pIBE->Release();
            delete pItem;
        }
    }
}

// this help function is used to isolate the menu-specific
// processing. after using this helper to fill out the BROWSEXT_MENU_INFO
// struct, the OnCustomizableMenuPopup is able to do menu-inspecific
// processing.

HRESULT
CBrowserExtension::_GetCustomMenuInfo(HMENU hMenuParent, HMENU hMenu, BROWSEXT_MENU_INFO * pMI)
{
    HRESULT hr;

    RIP(IS_VALID_HANDLE(hMenuParent, MENU));
    RIP(IS_VALID_HANDLE(hMenu, MENU));
    RIP(IS_VALID_WRITE_PTR(pMI, BROWSEXT_MENU_INFO *));

    hr = E_FAIL;
    pMI->idmMenu = 0;

    // set idmMenu, idmPlaceholder, and idmModMarker to values
    // reflecting whichever menu's popup we're currently handling

    if (GetMenuFromID(hMenuParent, FCIDM_MENU_HELP) == hMenu)
    {
        pMI->idmMenu = FCIDM_MENU_HELP;
        pMI->idmPlaceholder = FCIDM_HELP_EXT_PLACEHOLDER;
        pMI->idmModMarker = FCIDM_HELP_EXT_MOD_MARKER;
    }
    else if (GetMenuFromID(hMenuParent, FCIDM_MENU_TOOLS) == hMenu)
    {
        pMI->idmMenu = FCIDM_MENU_TOOLS;
        pMI->idmPlaceholder = FCIDM_TOOLS_EXT_PLACEHOLDER;
        pMI->idmModMarker = FCIDM_TOOLS_EXT_MOD_MARKER;
    }

    // set iInsert. using a constant insertion index
    // instead of always inserting by command at
    // the placeholder makes it easier later when
    // we have to stick in the final separator to
    // isolate the custom item group.

    if (pMI->idmMenu != 0)
    {
        int i;
        int cItems;

        cItems = GetMenuItemCount(hMenu);

        for (i = 0; i < cItems; i++)
        {
            MENUITEMINFO    mii;
            BOOL            f;

            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID;

            f = GetMenuItemInfo(hMenu, i, TRUE, &mii);

            if (f && mii.wID == pMI->idmPlaceholder)
            {
                pMI->iInsert = i;
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

// note, this popup handler can't easily tell whether an item
// has been removed from the DPA. if you remove any items from the
// DPA it is your responsibility to delete them from the menu
// also, if they live on a menu

HRESULT CBrowserExtension::OnCustomizableMenuPopup(HMENU hMenuParent, HMENU hMenu)
{
    HRESULT             hr;
    BROWSEXT_MENU_INFO  menuInfo;

    RIP(IS_VALID_HANDLE(hMenu, MENU));

    hr = _GetCustomMenuInfo(hMenuParent, hMenu, &menuInfo);
    if (SUCCEEDED(hr) && _hdpa != NULL)
    {
        BOOL    fItemInserted;
        UINT    cItems;
        UINT    i;

        ASSERT(IS_VALID_HANDLE(_hdpa, DPA));

        fItemInserted = FALSE;

        // check each extension object we currently have
        // to see whether any of them should go into this
        // menu

        cItems = (UINT)DPA_GetPtrCount(_hdpa);

        for (i = 0; i < cItems; i++)
        {
            ExtensionItem * pItem;

            pItem = (ExtensionItem *)DPA_GetPtr(_hdpa, i);
            ASSERT(IS_VALID_READ_PTR(pItem, ExtensionItem));

            // does this item go into the menu we're currently
            // customizing?

            if (pItem->idmMenu == menuInfo.idmMenu)
            {
                MENUITEMINFO        mii;
                IOleCommandTarget * pOCT;

                mii.fMask   = MIIM_ID;
                mii.wID     = pItem->idCmd;
                mii.cbSize  = sizeof(mii);

                // set the MENUITEMINFO's state information, if applicable

                ASSERT(IS_VALID_CODE_PTR(pItem->pIBE, IBrowserExtension));

                hr = pItem->pIBE->QueryInterface(IID_IOleCommandTarget, (void **)&pOCT);
                if (SUCCEEDED(hr))
                {
                    OLECMD oleCmd = {OLECMDID_OPEN,};

                    ASSERT(IS_VALID_CODE_PTR(pOCT, IOleCommandTarget));

                    hr = pOCT->QueryStatus(NULL, 1, &oleCmd, NULL);
                    if (SUCCEEDED(hr))
                    {
                        mii.fMask |= MIIM_STATE;
                        mii.fState = 0;

                        // enabled state

                        if (oleCmd.cmdf & OLECMDF_ENABLED)
                        {
                            mii.fState |= MFS_ENABLED;
                        }
                        else
                        {
                            mii.fState |= MFS_DISABLED;
                        }

                        // checked state

                        if (oleCmd.cmdf & OLECMDF_LATCHED)
                        {
                            mii.fState |= MFS_CHECKED;
                        }
                        else
                        {
                            mii.fState |= MFS_UNCHECKED;
                        }
                    }

                    pOCT->Release();
                }

                // get the menu text.
                // this changing is an unlikely scenario, but if we're truly
                // supporting dynamic customization, then we need to allow for
                // this possibility.

                VARIANTARG  varArg;

                hr = pItem->pIBE->GetProperty(TMEX_MENUTEXT, &varArg);
                if (SUCCEEDED(hr))
                {
                    BOOL    fItemExists;

                    ASSERT(varArg.vt == VT_BSTR);
                    ASSERT(IS_VALID_STRING_PTR(varArg.bstrVal, -1));

                    fItemExists = GetMenuItemInfo(hMenu, mii.wID, FALSE, &mii);

                    mii.fMask |= MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.cch = SysStringLen(varArg.bstrVal);
                    mii.dwTypeData = varArg.bstrVal;

                    if (fItemExists)
                    {
                        // update the old item using current info

                        SetMenuItemInfo(hMenu, mii.wID, FALSE, &mii);
                    }
                    else
                    {
                        // create a new item using current info

                        if (InsertMenuItem(hMenu, menuInfo.iInsert, TRUE, &mii))
                        {
                            fItemInserted = TRUE;
                        }
                    }

                    VariantClear(&varArg);
                }

            }
        }

        if (fItemInserted)
        {
            MENUITEMINFO    mii;
            BOOL            fModMarkerExists;

            // since we made an insertion, we need to insert
            // a separator, but only if we didn't do it already

            mii.cbSize = sizeof(mii);
            mii.fMask = 0;

            fModMarkerExists = GetMenuItemInfo(hMenu, menuInfo.idmModMarker, FALSE, &mii);

            if (!fModMarkerExists)
            {
                mii.fMask = MIIM_ID | MIIM_TYPE;
                mii.wID = menuInfo.idmModMarker;
                mii.fType = MFT_SEPARATOR;

                InsertMenuItem(hMenu, menuInfo.iInsert, TRUE, &mii);
            }
        }

        // the only thing that is guaranteed to be a complete failure
        // if if we failed to get the info for the menu doing the popup.
        // otherwise, despite the possibility that any particular insertion
        // attempt might have failed, there are potentially many custom
        // items. though some might fail, some might succeed. in either
        // we'll return overall success, because we successfully did the
        // best we could with the items that were present.
        // at least we didn't crash :)

        hr = S_OK;
    }

    return hr;
}

HRESULT CBrowserExtension::OnMenuSelect(UINT nCmdID)
{
    VARIANT varArg;
    HRESULT hr = E_FAIL;

    // We better have stored our menu extensions if we are at this point
    ASSERT(_hdpa != NULL);
    int i = _GetIdpaFromCmdId(nCmdID);
    if (i >= 0 && i < DPA_GetPtrCount(_hdpa))
    {
        ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
        ASSERT(pItem->idmMenu != 0);

        hr = pItem->pIBE->GetProperty(TMEX_STATUSBARTEXT, &varArg);
        if (SUCCEEDED(hr))
        {
            if (varArg.vt == VT_BSTR)
            {
                // Set the Status Bar Text
                if (_pISB)
                {
                    _pISB->SetStatusTextSB(varArg.bstrVal);
                }
            }

            VariantClear(&varArg);
            hr = S_OK;
        }
    }
    return hr;
}

// Create an image list for the Cut/Copy/Paste buttons
CBrowserExtension::CImageCache CBrowserExtension::_rgImages[3];

//
// Get the image list for the toolbar. These image lists are shared between instances so
// the caller must call _ReturnImageLists when finished with them.  The index returned from this
// functions is passed to _ReturnImageLists.
//
UINT CBrowserExtension::_GetImageLists(CImageList** ppimlDef, CImageList** ppimlHot, BOOL fSmall)
{
    COLORREF crMask = RGB( 255, 0, 255 );
    BOOL bUseNewIcons = !SHUseClassicToolbarGlyphs();

    //
    // Get the index into our image cache
    //   16 color 16x16 (small)
    //   16 color 20x20
    //   256 color 20x20
    //
    int i = fSmall ? 0 : 1;
    if (!fSmall && SHGetCurColorRes() > 8)
        ++i;

    int cx = fSmall ? 16 : 20;

    if (!fSmall && bUseNewIcons)
    {
        cx = 24;
    }

    //
    // Create the images if necessary
    //
    ENTERCRITICAL;

    if (_rgImages[0].uiResDef == 0)
    {

        _rgImages[1].uiResDef = IDB_CLASSIC_IETOOLBAR;
        _rgImages[1].uiResHot = IDB_CLASSIC_IETOOLBARHOT;
        _rgImages[1].bShell32 = FALSE;


        if (bUseNewIcons)
        {
            _rgImages[0].uiResDef = IDB_TB_EXT_DEF_16;
            _rgImages[0].uiResHot = IDB_TB_EXT_HOT_16;
            _rgImages[0].bShell32 = TRUE;
            _rgImages[2].uiResDef = IDB_TB_EXT_DEF_24;
            _rgImages[2].uiResHot = IDB_TB_EXT_HOT_24;
            _rgImages[2].bShell32 = TRUE;
        }
        else
        {
            _rgImages[0].uiResDef = IDB_CLASSIC_IETOOLBAR16;
            _rgImages[0].uiResHot = IDB_CLASSIC_IETOOLBARHOT16;
            _rgImages[0].bShell32 = FALSE;
            _rgImages[2].uiResDef = IDB_CLASSIC_IETOOLBARHICOLOR;
            _rgImages[2].uiResHot = IDB_CLASSIC_IETOOLBARHOTHICOLOR;
            _rgImages[2].bShell32 = FALSE;
        }
    }

    if (!_rgImages[i].imlDef.HasImages())
    {
        _rgImages[i].imlDef = ImageList_LoadImage(_rgImages[i].bShell32 ? GetModuleHandle(TEXT("shell32.dll")) : HINST_THISDLL,
                                           MAKEINTRESOURCE(_rgImages[i].uiResDef),
                                           cx, 0, crMask,
                                           IMAGE_BITMAP, LR_CREATEDIBSECTION);
    }

    if (!_rgImages[i].imlHot.HasImages())
    {
        _rgImages[i].imlHot = ImageList_LoadImage(_rgImages[i].bShell32 ? GetModuleHandle(TEXT("shell32.dll")) : HINST_THISDLL,
                                           MAKEINTRESOURCE(_rgImages[i].uiResHot),
                                           cx, 0, crMask,
                                           IMAGE_BITMAP, LR_CREATEDIBSECTION);
    }

    //
    // Add the custom buttons to our image lists
    //
    _AddCustomImagesToImageList(_rgImages[i].imlDef, _rgImages[i].imlHot, fSmall);

    ++_rgImages[i].cUsage;

    *ppimlDef = &_rgImages[i].imlDef;
    *ppimlHot = &_rgImages[i].imlHot;
    LEAVECRITICAL;

    return i;
}

//
// Called when the imagelist indicated by uiIndex is not longer used by this instance
//
void CBrowserExtension::_ReleaseImageLists(UINT uiIndex)
{
    if (uiIndex >= ARRAYSIZE(_rgImages))
    {
        return;
    }

    ENTERCRITICAL;

    ASSERT(_rgImages[uiIndex].cUsage >= 1);

    // If the image lists are no longer used, we can free them
    if (--_rgImages[uiIndex].cUsage == 0)
    {
        _rgImages[uiIndex].imlDef.FreeImages();
        _rgImages[uiIndex].imlHot.FreeImages();
    }
    LEAVECRITICAL;
}

//+-------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
CImageList::CImageList(HIMAGELIST himl)
:   _himl(himl)
{
    ASSERT(_hdpa == NULL);
}

//+-------------------------------------------------------------------------
// Destructor
//--------------------------------------------------------------------------
CImageList::~CImageList()
{
    FreeImages();
}

//+-------------------------------------------------------------------------
// Frees an association item from our dpa
//--------------------------------------------------------------------------
int CImageList::_DPADestroyCallback(LPVOID p, LPVOID d)
{
    delete (ImageAssoc*)p;
    return 1;
}

//+-------------------------------------------------------------------------
// Frees our image list and inex associations
//--------------------------------------------------------------------------
void CImageList::FreeImages()
{
    if (_hdpa)
    {
        DPA_DestroyCallback(_hdpa, _DPADestroyCallback, 0);
        _hdpa = NULL;
    }
    if (_himl)
    {
        ImageList_Destroy(_himl);
        _himl = NULL;
    }
}

//+-------------------------------------------------------------------------
// Updates the image list
//--------------------------------------------------------------------------
CImageList& CImageList::operator=(HIMAGELIST himl)
{
    if (himl != _himl)
    {
        FreeImages();
        _himl = himl;
    }
    return *this;
}

//+-------------------------------------------------------------------------
// Returns the index of the images associated with rguid.  Returns -1 if not
// found.
//--------------------------------------------------------------------------
int CImageList::GetImageIndex(REFGUID rguid)
{
    int iIndex = -1;

    if (_hdpa)
    {
        ASSERT(_himl);

        for (int i=0; i < DPA_GetPtrCount(_hdpa); ++i)
        {
            ImageAssoc* pAssoc = (ImageAssoc*)DPA_GetPtr(_hdpa, i);
            if (IsEqualGUID(pAssoc->guid, rguid))
            {
                return pAssoc->iImage;
            }
        }
    }
    return iIndex;
}

//+-------------------------------------------------------------------------
// Adds the icon to the image list and returns the index.  If the image is
// already present, the existing index is returned.  Returns -1 on failure.
//--------------------------------------------------------------------------
int CImageList::AddIcon(HICON hicon, REFGUID rguid)
{
    ASSERT(hicon != NULL);

    // First see is we have already added this image
    int iIndex = GetImageIndex(rguid);
    if (iIndex == -1)
    {
        // Make sure we have a dpa to store our items
        if (NULL == _hdpa)
        {
            _hdpa = DPA_Create(5);
        }

        if (_hdpa && _himl)
        {
            // Add the icon to our image list
            iIndex = ImageList_AddIcon(_himl, hicon);
            if (iIndex != -1)
            {
                ImageAssoc* pAssoc = new ImageAssoc;
                if (pAssoc)
                {
                    pAssoc->guid = rguid;
                    pAssoc->iImage = iIndex;
                    DPA_AppendPtr(_hdpa, pAssoc);
                }
            }
        }
    }
    return iIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\browsext.h ===
#ifndef _BROWSEXT_H
#define _BROWSEXT_H

#include "tbext.h"

#define FCIDM_TOOLS_EXT_PLACEHOLDER         0x9000
#define FCIDM_TOOLS_EXT_MOD_MARKER          0x9001
#define FCIDM_HELP_EXT_PLACEHOLDER          0x9002
#define FCIDM_HELP_EXT_MOD_MARKER           0x9003

//
// This class is used to store/retrieve images by name (guid) from shared image lists
//
class CImageList
{
public:
    CImageList(HIMAGELIST himl = NULL);
    ~CImageList();

    CImageList& operator=(HIMAGELIST himl);
    operator HIMAGELIST() { return _himl; }
    int GetImageIndex(REFGUID rguid);
    int AddIcon(HICON hicon, REFGUID rguid);
    BOOL HasImages() { return (_himl != NULL); }
    void FreeImages();

protected:
    static int _DPADestroyCallback(LPVOID p, LPVOID d);

    // Associate guids with indices into the image list
    struct ImageAssoc
    {
        GUID    guid;
        int     iImage;
    };
    HIMAGELIST  _himl;
    HDPA        _hdpa;      // Array of ImageAssoc
};


//
// Internal interface fo managing buttons added to the internet toolbar and menu items added to the
// tools menu.  This interface will likely go away afer IE5B2 when we move this functionality to
// a browser helper object.
//
EXTERN_C const IID IID_IToolbarExt;

DECLARE_INTERFACE_(IToolbarExt, IUnknown)
{
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // *** IToolbarExt methods ***
    virtual STDMETHODIMP GetButtons(TBBUTTON* ptbArr, int nNumButtons, BOOL fInit) PURE;
    virtual STDMETHODIMP GetNumButtons(UINT* pButtons) PURE;
    virtual STDMETHODIMP InitButtons(IExplorerToolbar* pxtb, UINT* puStringIndex, const GUID* pguidCommandGroup) PURE;
    virtual STDMETHODIMP OnCustomizableMenuPopup(HMENU hMenuParent, HMENU hMenu) PURE;
    virtual STDMETHODIMP OnMenuSelect(UINT nCmdID) PURE;
};

class CBrowserExtension : public IToolbarExt
                        , public IObjectWithSite
                        , public IOleCommandTarget
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* pUnkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IToolbarExt methods ***
    virtual STDMETHODIMP GetButtons(TBBUTTON* ptbArr, int nNumButtons, BOOL fInit);
    virtual STDMETHODIMP GetNumButtons(UINT* pButtons);
    virtual STDMETHODIMP InitButtons(IExplorerToolbar* pxtb, UINT* puStringIndex, const GUID* pguidCommandGroup);
    virtual STDMETHODIMP OnCustomizableMenuPopup(HMENU hMenuParent, HMENU hMenu);
    virtual STDMETHODIMP OnMenuSelect(UINT nCmdID);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);

protected:
    // Instance creator
    friend HRESULT CBrowserExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    CBrowserExtension();
    ~CBrowserExtension();

    HRESULT Update();

    struct ExtensionItem
    {
        CLSID               guid;       // id of the extension
        IBrowserExtension*  pIBE;
        BITBOOL             fButton:1;  // if has a button
        BITBOOL             fVisible:1; // if defaults to visible on the toolbar
        int                 iStringID;  // Keeps track of the location in the string resource for the button
        int                 iImageID;   // The ID of the icon in the image lists
        int                 idCmd;      // toolbar CmdId
        UINT                idmMenu;    // idm of the menu this extension belongs to
    };

    void            _AddItem(HKEY hkeyExtensions,  LPCWSTR pszButtonGuid, REFGUID rguid);
    ExtensionItem*  _FindItem(REFGUID rguid);
    void            _FreeItems();
    HRESULT         _Exec(int nItem, int nCmdID);
    UINT            _GetImageLists(CImageList** ppimlDef, CImageList** ppimlHot, BOOL fSmall);
    void            _ReleaseImageLists(UINT uiIndex);
    HRESULT         _AddCustomImagesToImageList(CImageList& rimlNormal, CImageList& rimlHot, BOOL fSmallIcons);
    HRESULT         _AddCustomStringsToBuffer(IExplorerToolbar * pxtb, const GUID* pguidCommandGroup);

    int             _GetCmdIdFromClsid(LPCWSTR pszGuid);
    int             _GetIdpaFromCmdId(int nCmdId);

    typedef struct tagBROWSEXT_MENU_INFO
    {
        UINT    idmMenu;        // idm for this menu
        UINT    idmPlaceholder;
        UINT    idmModMarker;   // separator with this idm is present if customizations have been made
        int     iInsert;        // insertion point for custom items
    } BROWSEXT_MENU_INFO;

    HRESULT         _GetCustomMenuInfo(HMENU hMenuParent, HMENU hMenu, BROWSEXT_MENU_INFO * pMI);

    LONG                _cRef;                  // reference count
    HDPA                _hdpa;                  // array of ExtensionItem*
    int                 _nExtButtons;           // Number of Buttons
    int                 _nExtToolsMenuItems;    // Number of Tools Menu Items
    IShellBrowser*      _pISB;                  // Passed into the IObjectWithSite::GetSite
    UINT                _uStringIndex;          // index of first string added to toolbar

    // Used for CUT/COPY/PASTE imagelist
    struct CImageCache
    {
        UINT        uiResDef;               // resource id for grey-scale bitmap
        UINT        uiResHot;               // resource id for color bitmap
        CImageList  imlDef;                 // grey scale imagelist
        CImageList  imlHot;                 // color imagelist
        int         cUsage;                 // number of instances using this item
        BOOL        bShell32;               // resource stored in shell32
    };
    static CImageCache      _rgImages[3];   // cached image lists:
                                            //   16 color 16x16
                                            //   16 color 20x20
                                            //   256 color 20x20
    UINT                    _uiImageIndex;  // Currently used index into _rgImages (-1 is none)


#ifdef DEBUG
    BOOL _fStringInit;      // These are used to insure that AddExtButtonsTBArray is only called after
    BOOL _fImageInit;       // AddCustomImag... and AddCustomStrin... have been called.
#endif
};

EXTERN_C const CLSID CLSID_PrivBrowsExtCommands;
typedef enum {
    PBEC_GETSTRINGINDEX     =   1,
} PBEC_COMMANDS;

#endif // _BROWSEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\chanbar.h ===
#ifndef _CHANBAR_H
#define _CHANBAR_H

#include "dbapp.h"

#define SZ_REGKEY_CHANBAR   TEXT("Software\\Microsoft\\Internet Explorer\\Channels")
#define SZ_REGVALUE_CHANBAR TEXT("window_placement")

typedef struct tagCISSTRUCT {
    UINT iVer; 
    RECT rc; 
} CISSTRUCT;

class CChannelDeskBarApp : public CDeskBarApp
{
public:
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);


    // *** IPersistPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK DummyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnDisplayChange();
    virtual void _OnCreate();
    virtual void _OnSize(void);
    virtual void _UpdateCaptionTitle();
    void _CreateToolbar();
    void _PositionTB();
    void _SizeTB();
    void _PersistState();
    
    BOOL _OnCloseBar(BOOL fConfirm);
    
    HWND _hwndTB;
    HWND _hwndDummy; // for propagating WM_PALETTE* messages

    LONG _cxScreen, _cyScreen;   // the screen resolution

    friend HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);
} ;

HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);
void ChanBarSetAutoLaunchRegValue(BOOL);
void DesktopChannel();


#endif // _CHANBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\channel.h ===
#ifndef _CHANNEL_H
#define _CHANNEL_H


void Channel_UpdateQlinks();

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath);
LPITEMIDLIST Channel_GetFolderPidl();
HRESULT ChannelBand_CreateInstance(IUnknown** ppunk);
HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace);

BOOL GetFirstUrl(TCHAR szURL[], DWORD cb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\cacheoff.cpp ===
// Author:  Karim Farouki
// Date:    24 June 1998

#include "priv.h"
#include "util.h"
#include <emptyvc.h>
#include <mluisupp.h>   // for MLLoadString
#include "resource.h"   // for the string ID's

typedef HRESULT (* LPFCALLBACK )(LPINTERNET_CACHE_ENTRY_INFO, void *);

typedef struct tagRTSCBSTRUCT   
{
    IEmptyVolumeCacheCallBack   * picb;
    DWORDLONG                   * pdwlSpaceUsed;
} RTSCBSTRUCT;  // RunningTotalSizeCallBack Struct

typedef struct tagDECBSTRUCT
{
    IEmptyVolumeCacheCallBack   * picb;
    DWORDLONG                   dwlSpaceFreed;
    DWORDLONG                   dwlTotalSpace;
} DECBSTRUCT;   // DeleteEntryCallBack Struct

class COfflinePagesCacheCleaner : public IEmptyVolumeCache2
{
    private:
        // Data
        ULONG       m_cRef;
        DWORDLONG   m_dwlSpaceUsed;
        TCHAR       m_szCacheDir[MAX_PATH + 1];

        // Functions
        HRESULT     WalkOfflineCache(
                        LPFCALLBACK     lpfCallBack,
                        void            * pv
                        );

        static HRESULT CALLBACK RunningTotalSizeCallback(
                        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
                        void                        * pv
                        );
        
        static HRESULT CALLBACK DeleteEntryCallback(
                        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
                        void                        * pv
                        );
        static VOID IncrementFileSize(
                        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
                        DWORDLONG                   * pdwlSize
                        );

        ~COfflinePagesCacheCleaner(void);

    public:
        // Constructor/Destructor
        COfflinePagesCacheCleaner(void);

        // IUnknown Interface members
        STDMETHODIMP            QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG)    AddRef(void);
        STDMETHODIMP_(ULONG)    Release(void);

        // IEmptyVolumeCache interface methods
        STDMETHODIMP    Initialize(
                            HKEY    hkRegKey,
                            LPCWSTR pcwszVolume,
                            LPWSTR  * ppwszDisplayName,
                            LPWSTR  * ppwszDescription,
                            DWORD   * pdwFlags
                            );

        STDMETHODIMP    GetSpaceUsed(
                            DWORDLONG                   * pdwlSpaceUsed,
                            IEmptyVolumeCacheCallBack   * picb
                            );

        STDMETHODIMP    Purge(
                            DWORDLONG                   dwlSpaceToFree,
                            IEmptyVolumeCacheCallBack   * picb
                            );

        STDMETHODIMP    ShowProperties(
                            HWND    hwnd
                            );

        STDMETHODIMP    Deactivate(
                            DWORD   * pdwFlags
                            );

        // IEmptyVolumeCache2 interface methods
        STDMETHODIMP    InitializeEx(
                            HKEY hkRegKey,
                            LPCWSTR pcwszVolume,
                            LPCWSTR pcwszKeyName,
                            LPWSTR *ppwszDisplayName,
                            LPWSTR *ppwszDescription,
                            LPWSTR *ppwszBtnText,
                            DWORD *pdwFlags
                            );
};

STDAPI COfflinePagesCacheCleaner_CreateInstance(
    IUnknown        * punkOuter,
    IUnknown        ** ppunk,
    LPCOBJECTINFO   poi
    )
{
    HRESULT hr = S_OK;
    
    *ppunk = NULL;

    COfflinePagesCacheCleaner * lpOPCC = new COfflinePagesCacheCleaner();

    if (lpOPCC == NULL)
        hr = E_OUTOFMEMORY;
    else
        *ppunk = SAFECAST(lpOPCC, IEmptyVolumeCache *);

    return hr;
}

COfflinePagesCacheCleaner::COfflinePagesCacheCleaner() : m_cRef(1)
{
    DllAddRef();
}

COfflinePagesCacheCleaner::~COfflinePagesCacheCleaner()
{
    DllRelease();
}

STDMETHODIMP COfflinePagesCacheCleaner::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEmptyVolumeCache) || IsEqualIID(riid, IID_IEmptyVolumeCache2))
    {
        *ppv = SAFECAST(this, IEmptyVolumeCache2 *);
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) COfflinePagesCacheCleaner::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflinePagesCacheCleaner::Release()
{
    ULONG uRefCount = --m_cRef;
    
    if (!uRefCount)
        delete this;

    return uRefCount;
}

STDMETHODIMP COfflinePagesCacheCleaner::InitializeEx(
    HKEY hkRegKey,
    LPCWSTR pcwszVolume,
    LPCWSTR pcwszKeyName,
    LPWSTR *ppwszDisplayName,
    LPWSTR *ppwszDescription,
    LPWSTR *ppwszBtnText,
    DWORD *pdwFlags
    )
{
    *ppwszBtnText = (LPWSTR)CoTaskMemAlloc( 128*sizeof(WCHAR) );
    if ( !*ppwszBtnText )
        return E_OUTOFMEMORY;

    MLLoadString( IDS_CACHEOFF_BTNTEXT, *ppwszBtnText, 512 );

    return Initialize(hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags );
}

STDMETHODIMP COfflinePagesCacheCleaner::Initialize(
    HKEY    hkRegkey,
    LPCWSTR pcwszVolume,
    LPWSTR  * ppwszDisplayName,
    LPWSTR  * ppwszDescription,
    DWORD   * pdwFlags
    )
{
    HRESULT         hr;
    uCLSSPEC        ucs;          // Used to see if Webcheck is installed
    QUERYCONTEXT    qc = { 0 };   // Used to see if Webcheck is installed
    DWORDLONG       dwlSize;      // Amount of offline cachespace


#ifdef UNICODE
    // We can't use the registry values on NT because they can't be multi-local localized.
    // Instead we must use strings loaded from resources.
    *ppwszDisplayName = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDisplayName )
        return E_OUTOFMEMORY;

    *ppwszDescription = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDescription )
        return E_OUTOFMEMORY;

    MLLoadString( IDS_CACHEOFF_DISPLAY, *ppwszDisplayName, 512 );
    MLLoadString( IDS_CACHEOFF_DESCRIPTION, *ppwszDescription, 512 );

#else
    // We can use the default registry DisplayName and Description
    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;
#endif

    // Intentionally am not turning on cleanup by default; turning on *view pages* button
    *pdwFlags = EVCF_HASSETTINGS;

    // Let's check if the Internet Cache Folder is in pcwzVolume
    GetCacheLocation(m_szCacheDir, sizeof(m_szCacheDir));
    if (StrCmpNI(pcwszVolume, m_szCacheDir, 3))
    {
        // If the cache is on a different drive return S_FALSE so that we don't show up in UI
        return S_FALSE;
    }

    // Determine if offline browsing pack is intalled.
    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_SubscriptionMgr;

    hr = FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI);
    
    if (SUCCEEDED(hr))  // (if offline pack installed)
    {
        GetSpaceUsed(&dwlSize, NULL);  
        
        if (dwlSize)        // If there is something in offline cache to delete
            return S_OK;    // load cleaner/
    }

    return S_FALSE;
}

STDMETHODIMP COfflinePagesCacheCleaner::GetSpaceUsed(
    DWORDLONG                   * pdwlSpaceUsed,
    IEmptyVolumeCacheCallBack   * picb
    )
{
    HRESULT hr;

    ASSERT(NULL != pdwlSpaceUsed);

    if (NULL != pdwlSpaceUsed)
    {
        RTSCBSTRUCT * prtscbStruct = new RTSCBSTRUCT;
    
        if (NULL != prtscbStruct)
        {
            // Initialize GetSpazeUsed Structure
            prtscbStruct->pdwlSpaceUsed = pdwlSpaceUsed;
            *(prtscbStruct->pdwlSpaceUsed) = 0;
            prtscbStruct->picb = picb;

            // Get Offline Cache Space Usage    
            hr = WalkOfflineCache(RunningTotalSizeCallback, (void *)(prtscbStruct));
            m_dwlSpaceUsed = *(prtscbStruct->pdwlSpaceUsed);

            // Send the last notification to the cleanup manager
            if (picb != NULL)
                picb->ScanProgress(*(prtscbStruct->pdwlSpaceUsed), EVCCBF_LASTNOTIFICATION, NULL);

            delete prtscbStruct;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP COfflinePagesCacheCleaner::Purge(
    DWORDLONG                   dwlSpaceToFree,   // Spec makes this irrelevent!
    IEmptyVolumeCacheCallBack   * picb
    )
{
    HRESULT hr;

    DECBSTRUCT  * pdecbStruct = new DECBSTRUCT;

    if (NULL != pdecbStruct)
    {
        // Initialize DeleteEntry Structure
        pdecbStruct->picb = picb;
        pdecbStruct->dwlSpaceFreed = 0;
        pdecbStruct->dwlTotalSpace = m_dwlSpaceUsed;

        //  Delete Offline Cache Entries
        hr = WalkOfflineCache(DeleteEntryCallback, (void *)(pdecbStruct));

        // Send the last notification to the cleanup manager
        if (picb != NULL)
        {
            picb->PurgeProgress(m_dwlSpaceUsed, 0, EVCCBF_LASTNOTIFICATION, NULL);
        }

        delete pdecbStruct;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP COfflinePagesCacheCleaner::ShowProperties(HWND hwnd)
{
    TCHAR szOfflinePath[MAX_PATH];
    DWORD dwSize = SIZEOF(szOfflinePath);

    if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SUBSCRIPTION,
                       REGSTR_VAL_DIRECTORY, NULL, (LPBYTE)szOfflinePath, &dwSize) != ERROR_SUCCESS)
    {
        TCHAR szWindows[MAX_PATH];

        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        PathCombine(szOfflinePath, szWindows, TEXT("Offline Web Pages"));
    }

    SHELLEXECUTEINFO shei;
    ZeroMemory(&shei, sizeof(shei));
    shei.cbSize     = sizeof(shei);
    shei.lpFile     = szOfflinePath;
    shei.nShow      = SW_SHOWNORMAL;
    ShellExecuteEx(&shei);
    
    // Returning S_OK insures that GetSpaceUsed is recalled (to recalc) the size being
    // used (in case someone deletes some MAO stuff).
    return S_OK;
}

STDMETHODIMP COfflinePagesCacheCleaner::Deactivate(DWORD * pdwFlags)
{
    // We don't implement this.
    *pdwFlags = 0;

    return S_OK;
}

HRESULT COfflinePagesCacheCleaner::WalkOfflineCache(
    LPFCALLBACK     lpfCallBack,
    void *          pv
    )
{
    ASSERT(pv);

    HRESULT hr = S_OK;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo;
    HANDLE hCacheEntryInfo;
    DWORD dwCacheEntryInfoSize;
    
    if ((lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, 
                                        MAX_CACHE_ENTRY_INFO_SIZE)) == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;
        if ((hCacheEntryInfo = FindFirstUrlCacheEntry(NULL, lpCacheEntryInfo,
                                        &dwCacheEntryInfoSize)) == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    
        if (SUCCEEDED(hr))
        {
            do
            {   
                if (lpCacheEntryInfo->CacheEntryType & STICKY_CACHE_ENTRY)
                {
                    hr = lpfCallBack(lpCacheEntryInfo, pv);
                }

                dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;
            } while ((E_ABORT != hr) &&
                     FindNextUrlCacheEntry(hCacheEntryInfo, lpCacheEntryInfo,
                                           &dwCacheEntryInfoSize));
            
            if (hr != E_ABORT) 
            {
                DWORD dwLastErr = GetLastError();

                if (dwLastErr != ERROR_NO_MORE_ITEMS)
                {
                    hr = HRESULT_FROM_WIN32(dwLastErr);
                }
            }
        }
    
        LocalFree(lpCacheEntryInfo);
        lpCacheEntryInfo = NULL;
    }

    return hr;
}

HRESULT CALLBACK COfflinePagesCacheCleaner::RunningTotalSizeCallback(
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,  // Name of the CacheEntry to sum
    void                        * pv               // A RTSCBSTRUCT
    )
{
    HRESULT hr = S_OK;
    RTSCBSTRUCT * prtscbStruct = (RTSCBSTRUCT *)pv;

    // Add current file size to total    
    IncrementFileSize(lpCacheEntryInfo, prtscbStruct->pdwlSpaceUsed);

    // Update the progressbar!
    if (prtscbStruct->picb != NULL)
        hr = prtscbStruct->picb->ScanProgress(*(prtscbStruct->pdwlSpaceUsed), 0, NULL);

    return hr;
}

HRESULT CALLBACK COfflinePagesCacheCleaner::DeleteEntryCallback(
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, // Name of the CacheEntry to delete
    void                        * pv              // Pointer to DECBSTRUCT
    )
{
    HRESULT     hr = S_OK;
    DECBSTRUCT  * pdecbStruct = (DECBSTRUCT *)pv;
    
    // Add current file size to total deleted
    IncrementFileSize(lpCacheEntryInfo, &(pdecbStruct->dwlSpaceFreed));

    DeleteUrlCacheEntry(lpCacheEntryInfo->lpszSourceUrlName);   

    // Update the progress bar!
    if (pdecbStruct->picb != NULL)
    {
        hr =  pdecbStruct->picb->PurgeProgress(pdecbStruct->dwlSpaceFreed, 
            pdecbStruct->dwlTotalSpace - pdecbStruct->dwlSpaceFreed, NULL, NULL);
    }

    return hr;
}

VOID COfflinePagesCacheCleaner::IncrementFileSize(
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
    DWORDLONG                   * pdwlSize
    )
{
    ULARGE_INTEGER uliFileSize;
    
    uliFileSize.HighPart = lpCacheEntryInfo->dwSizeHigh;
    uliFileSize.LowPart = lpCacheEntryInfo->dwSizeLow;

    *pdwlSize += QUAD_PART(uliFileSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\cabsh.h ===
#ifndef _CABSH_H
#define _CABSH_H

// Define structure to be used at head of state stream that is
// not dependent on 16 or 32 bits...
typedef struct _CABSHOLD       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;
} CABSHOLD;

typedef struct _CABSH       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;

    DWORD   fMask;          // Flags specifying which fields are valid
    SHELLVIEWID vid;        // extended view id
    DWORD   dwVersionId;    // CABSH_VER below
    DWORD   dwRevCount;     // rev count of default settings when the folder was saved to the stream
} CABSH;

#define CABSHM_VIEWID  0x00000001
#define CABSHM_VERSION 0x00000002
#define CABSHM_REVCOUNT 0x00000004

#define CABSH_VER 1 // change this version whenever we want to change defaults
#define CABSH_WIN95_VER 0 // this was the pre-ie4 version number

#endif  // _CABSH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\cachecln.cpp ===
// Author:  Pritvinath Obla
// Date:    10 July 1997

#include "priv.h"
#include "util.h"
#include <emptyvc.h>
#include <mluisupp.h>   // for MLLoadString
#include "resource.h"   // for the string ID's

class CInternetCacheCleaner : public IEmptyVolumeCache2
{
private:
    //
    // Data
    //
    ULONG                   m_cRef;             // reference count
    DWORDLONG               m_dwlSpaceUsed;
    TCHAR                   m_szCacheDir[MAX_PATH + 1];

    //
    // Functions
    //
    HRESULT                 GetInternetCacheSize(
                                DWORDLONG                   *pdwlSpaceUsed,
                                IEmptyVolumeCacheCallBack   *picb
                                );

    HRESULT                 DelInternetCacheFiles(
                                DWORD                       dwPercentToFree,
                                IEmptyVolumeCacheCallBack   *picb
                                );

public:
    //
    // Constructor and Destructor
    //
    CInternetCacheCleaner(void);
    ~CInternetCacheCleaner(void);

    //
    // IUnknown interface members
    //
    STDMETHODIMP            QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    //
    // IEmptyVolumeCache interface methods
    //
    STDMETHODIMP            Initialize(
                                HKEY    hkRegKey,
                                LPCWSTR pcwszVolume,
                                LPWSTR  *ppwszDisplayName,
                                LPWSTR  *ppwszDescription,
                                DWORD   *pdwFlags
                                );

    STDMETHODIMP            GetSpaceUsed(
                                DWORDLONG                   *pdwlSpaceUsed,
                                IEmptyVolumeCacheCallBack   *picb
                                );

    STDMETHODIMP            Purge(
                                DWORDLONG                   dwlSpaceToFree,
                                IEmptyVolumeCacheCallBack   *picb
                                );

    STDMETHODIMP            ShowProperties(
                                HWND    hwnd
                                );

    STDMETHODIMP            Deactivate(
                                DWORD   *pdwFlags
                                );

    //
    // IEmptyVolumeCache2 interface methods
    //
    STDMETHODIMP            InitializeEx(
                                HKEY hkRegKey,
                                LPCWSTR pcwszVolume,
                                LPCWSTR pcwszKeyName,
                                LPWSTR *ppwszDisplayName,
                                LPWSTR *ppwszDescription,
                                LPWSTR *ppwszBtnText,
                                DWORD *pdwFlags
                                );
};

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner_CreateInstance
//
// Purpose:     CreateInstance function for IClassFactory
//------------------------------------------------------------------------------
//
STDAPI CInternetCacheCleaner_CreateInstance(
    IUnknown        *punkOuter,
    IUnknown        **ppunk,
    LPCOBJECTINFO   poi
    )
{
    *ppunk = NULL;

    CInternetCacheCleaner *lpICC = new CInternetCacheCleaner();

    if (lpICC == NULL)
        return E_OUTOFMEMORY;

    *ppunk = SAFECAST(lpICC, IEmptyVolumeCache *);

    return S_OK;
}

CInternetCacheCleaner::CInternetCacheCleaner() : m_cRef(1)
{
    DllAddRef();

    m_dwlSpaceUsed = 0;
    *m_szCacheDir = '\0';
}

CInternetCacheCleaner::~CInternetCacheCleaner()
{
    DllRelease();
}

STDMETHODIMP CInternetCacheCleaner::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IsEqualIID(riid, IID_IUnknown)  ||
        IsEqualIID(riid, IID_IEmptyVolumeCache2) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        *ppv = SAFECAST(this, IEmptyVolumeCache2 *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CInternetCacheCleaner::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CInternetCacheCleaner::Release()
{
    //  
    // Decrement and check
    //
    if (--m_cRef)
        return m_cRef;

    //
    // No references left to this object
    //
    delete this;

    return 0;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::InitializeEx
//
// Purpose:     Initializes the Internet Cache Cleaner and returns the 
//                  specified IEmptyVolumeCache flags to the cache manager
//------------------------------------------------------------------------------
//

STDMETHODIMP CInternetCacheCleaner::InitializeEx(
    HKEY hkRegKey,
    LPCWSTR pcwszVolume,
    LPCWSTR pcwszKeyName,
    LPWSTR *ppwszDisplayName,
    LPWSTR *ppwszDescription,
    LPWSTR *ppwszBtnText,
    DWORD *pdwFlags
    )
{
    *ppwszBtnText = (LPWSTR)CoTaskMemAlloc( 128*sizeof(WCHAR) );
    if ( !*ppwszBtnText )
        return E_OUTOFMEMORY;

    MLLoadString( IDS_CACHECLN_BTNTEXT, *ppwszBtnText, 128 );

    return Initialize(hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags );
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::Initialize
//
// Purpose:     Initializes the Internet Cache Cleaner and returns the 
//                  specified IEmptyVolumeCache flags to the cache manager
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::Initialize(
    HKEY    hkRegKey,
    LPCWSTR pcwszVolume,
    LPWSTR  *ppwszDisplayName,
    LPWSTR  *ppwszDescription,
    DWORD   *pdwFlags
    )
{
#ifdef UNICODE
    // We can't use the registry values on NT because they can't be multi-local localized.  As
    // a result we must set the out pointers with values read from resources.
    *ppwszDisplayName = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDisplayName )
        return E_OUTOFMEMORY;

    *ppwszDescription = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDescription )
        return E_OUTOFMEMORY;

    MLLoadString( IDS_CACHECLN_DISPLAY, *ppwszDisplayName, 512 );
    MLLoadString( IDS_CACHECLN_DESCRIPTION, *ppwszDescription, 512 );
#else
    //
    // Let cleanmgr read the default DisplayName and Description
    //      from hkRegKey and use them
    //
    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;
#endif

    *pdwFlags = 0;              // initialize the [out] parameter

    //
    // Check if the Internet Cache Folder is in pcwzVolume
    //
    GetCacheLocation(m_szCacheDir, sizeof(m_szCacheDir));
    if (StrCmpNI(pcwszVolume, m_szCacheDir, 3))
    {
        //
        // Different drives; return S_FALSE so that this cleaner
        //      doesn't show up in cleanmgr's UI
        //
        return S_FALSE;
    }

    //
    // Enable this cleaner by default both in cleanup and tuneup modes
    //
    *pdwFlags = EVCF_ENABLEBYDEFAULT |
                EVCF_ENABLEBYDEFAULT_AUTO |
                EVCF_HASSETTINGS;

#if 0
    /***
    // Since GetInternetCacheSize returns only an approx. size,
    //      we would never get a value of 0 even if the cache is empty
    // Should enable this check once wininet.dll exports a GetCacheSize API

    //
    // Check if there is any disk space to free at all
    // If not, return S_FALSE so that this cleaner doesn't show up in
    //      cleanmgr's UI
    //
    DWORDLONG dwlSpaceUsed;
    if (SUCCEEDED(GetInternetCacheSize(&dwlSpaceUsed, NULL))  &&
        dwlSpaceUsed == 0)
    {
        return S_FALSE;
    }
    ***/
#endif

    return S_OK;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::GetSpaceUsed
//
// Purpose:     Return the total amount of space this internet cache cleaner
//                  can free up
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::GetSpaceUsed(
    DWORDLONG                   *pdwlSpaceUsed,
    IEmptyVolumeCacheCallBack   *picb
    )
{
    HRESULT hr;

    hr = GetInternetCacheSize(pdwlSpaceUsed, picb);
    m_dwlSpaceUsed = *pdwlSpaceUsed;

    //
    // Send the last notification to the cleanup manager
    //
    if (picb != NULL)
    {
        picb->ScanProgress(*pdwlSpaceUsed, EVCCBF_LASTNOTIFICATION, NULL);
    }

    if (hr != E_ABORT)
    {
        if (FAILED(hr))
        {
            //
            // *pdwlSpaceUsed is only a guesstimate; so return S_FALSE
            //
            hr = S_FALSE;
        }
        else
        {
            //
            // Return S_OK once wininet exports a GetCacheSize API;
            //      till then use FindFirstUrlCacheEntry/FindNextUrlCacheEntry
            //      to get approx. size of the cache
            //
            hr = S_FALSE;
        }
    }

    return hr;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::Purge
//
// Purpose:     Delete the internet cache files
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::Purge(
    DWORDLONG                   dwlSpaceToFree,
    IEmptyVolumeCacheCallBack   *picb
    )
{
    HRESULT hr;
    DWORD dwPercentToFree = 100;    // Optimize the most common scenario:
                                    // In most cases, dwlSpaceToFree will be
                                    //      equal to m_dwlSpaceUsed

    if (dwlSpaceToFree != m_dwlSpaceUsed)
    {
        dwPercentToFree = m_dwlSpaceUsed ?
                                DWORD((dwlSpaceToFree * 100) / m_dwlSpaceUsed) :
                                100;
    }

    hr = DelInternetCacheFiles(dwPercentToFree, picb);

    //
    // Send the last notification to the cleanup manager
    //
    if (picb != NULL)
    {
        picb->PurgeProgress(dwlSpaceToFree, 0,
                                EVCCBF_LASTNOTIFICATION, NULL);
    }

    if (hr != E_ABORT)
    {
        hr = S_OK;          // cannot return anything else
    }

    return hr;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::ShowProperties
//
// Purpose:     Launch the cache viewer to list the internet cache files
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::ShowProperties(
    HWND    hwnd
    )
{
    DWORD dwAttrib;

    if (*m_szCacheDir == '\0')      // Internet cache dir is not yet initialized
    {
        GetCacheLocation(m_szCacheDir, sizeof(m_szCacheDir));
    }

    dwAttrib = GetFileAttributes(m_szCacheDir);
    if (dwAttrib != 0xffffffff  &&  (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        SHELLEXECUTEINFO sei;

        //
        // Launch the cache viewer
        //
        sei.cbSize          = sizeof(SHELLEXECUTEINFO);
        sei.hwnd            = hwnd;
        sei.lpVerb          = NULL;
        sei.lpFile          = m_szCacheDir;
        sei.lpParameters    = NULL;
        sei.lpDirectory     = NULL;
        sei.nShow           = SW_SHOWNORMAL;
        sei.fMask           = 0;

        ShellExecuteEx(&sei);
    }

    //
    // The user may or may not delete files directly from the cachevu folder
    // Since there is no way of knowing this, don't return S_OK which would
    //      trigger cleanmgr to call GetSpaceUsed again
    //
    return S_OK;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::Deactivate
//
// Purpose:     Deactivates the Internet Cache Cleaner...Not implemented
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::Deactivate(
    DWORD   *pdwFlags
    )
{
    *pdwFlags = 0;

    return S_OK;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::GetInternetCacheSize
//
// Purpose:     Find the size of the internet cache by calling into wininet APIs
//
// Notes:       The current implementation is temporary; once wininet exports
//                  a real API for getting the cache size, use that
//------------------------------------------------------------------------------
//
HRESULT CInternetCacheCleaner::GetInternetCacheSize(
    DWORDLONG                   *pdwlSpaceUsed,
    IEmptyVolumeCacheCallBack   *picb           // not used
    )
{
    HRESULT hr = S_OK;
    DWORD dwLastErr;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo;
    HANDLE hCacheEntryInfo;
    DWORD dwCacheEntryInfoSize;

    *pdwlSpaceUsed = 0;

    if ((lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFOA) LocalAlloc(LPTR,
                                        MAX_CACHE_ENTRY_INFO_SIZE)) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;
    if ((hCacheEntryInfo = FindFirstUrlCacheEntryA(NULL, lpCacheEntryInfo,
                                            &dwCacheEntryInfoSize)) == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (SUCCEEDED(hr))
    {
        do
        {
            if (!(lpCacheEntryInfo->CacheEntryType & (STICKY_CACHE_ENTRY | COOKIE_CACHE_ENTRY)))
            {
                ULARGE_INTEGER uliFileSize;

                uliFileSize.HighPart = lpCacheEntryInfo->dwSizeHigh;
                uliFileSize.LowPart = lpCacheEntryInfo->dwSizeLow;

                *pdwlSpaceUsed += QUAD_PART(uliFileSize);
            }
            
            dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;

        } while (FindNextUrlCacheEntryA(hCacheEntryInfo, lpCacheEntryInfo,
                                                    &dwCacheEntryInfoSize));

        if ((dwLastErr = GetLastError()) != ERROR_NO_MORE_ITEMS)
        {
            hr = HRESULT_FROM_WIN32(dwLastErr);
        }
    }

    if (lpCacheEntryInfo != NULL)
    {
        LocalFree(lpCacheEntryInfo);
        lpCacheEntryInfo = NULL;
    }

    return hr;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::DelInternetCacheFiles
//
// Purpose:     Delete the internet cache files
//------------------------------------------------------------------------------
//
HRESULT CInternetCacheCleaner::DelInternetCacheFiles(
    DWORD                       dwPercentToFree,
    IEmptyVolumeCacheCallBack   *picb           // not used
    )
{
    HRESULT hr = S_OK;

    if (*m_szCacheDir == '\0')      // Internet cache dir is not yet initialized
    {
        hr = GetCacheLocation(m_szCacheDir, sizeof(m_szCacheDir));
    }

    if (SUCCEEDED(hr))
    {
        FreeUrlCacheSpace(m_szCacheDir, dwPercentToFree, STICKY_CACHE_ENTRY);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\chanoc.cpp ===
//
// This Channel OC code was copied from browseui.  Once it is reenabled in
// browseui it can be removed from shdocvw.
//

#include "priv.h"
#include "cobjsafe.h"


STDAPI ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidlDefault);
//LPITEMIDLIST Channel_GetFolderPidl();
void Channels_SetBandInfoSFB(IUnknown* punkBand);

//////////////////////////////////////////////////
//
// ChannelOC
//
// This is an OC that wraps the above band for
// inclusion in the Active Desktop.
//
// TODO:
//  - listen to ISFBand for resizes and request them
//    from our container
//
// Do we need to register as a drop target?

#undef  SUPERCLASS
#define SUPERCLASS CShellEmbedding
#undef  THISCLASS
#define THISCLASS ChannelOC

class ChannelOC : public SUPERCLASS
    , public IServiceProvider
    , public IPersistPropertyBag
    , public CObjectSafety
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) { return SUPERCLASS::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return SUPERCLASS::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void) { return SUPERCLASS::Release(); }

    // *** CAggregatedUnknown ***
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider ***
    virtual STDMETHODIMP QueryService(REFGUID guidService,
        REFIID riid, void **ppvObj);

    // *** IPersistPropertyBag ***
    virtual STDMETHODIMP Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog);
    virtual STDMETHODIMP Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    virtual STDMETHODIMP InitNew();
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) { return SUPERCLASS::GetClassID(pClassID); };

    // *** IOleInPlaceObject ***
    virtual STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);

protected:
    ChannelOC(IUnknown* punkOuter, LPCOBJECTINFO poi);
    ~ChannelOC();
    friend HRESULT ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    virtual LRESULT v_WndProc(HWND, UINT, WPARAM, LPARAM);

    LPITEMIDLIST _GetInitialPidl(void);
    virtual void _OnInPlaceActivate(void);      // called when we actually go in-place-active
    virtual void _OnInPlaceDeactivate(void);    // called when we actually deactivate

    IDeskBand*          _pBand;
    IWinEventHandler*   _pweh;
    COLORREF            _crBkgndOC;
    COLORREF            _crBorder;

    // for GetBandInfo, not currently used
    DESKBANDINFO _dbi;
};

ChannelOC::ChannelOC(IUnknown* punkOuter, LPCOBJECTINFO poi) : 
    CShellEmbedding(punkOuter, poi, NULL)
{
    TraceMsg(TF_SHDLIFE, "ctor ChannelOC %x", this);
    _crBkgndOC = CLR_DEFAULT;
    _crBorder = CLR_DEFAULT;
}


ChannelOC::~ChannelOC() 
{
    TraceMsg(TF_SHDLIFE, "dtor ChannelOC %x", this);
}

HRESULT ChannelOC::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IServiceProvider),
        QITABENT(THISCLASS, IPersistPropertyBag),
        QITABENT(THISCLASS, IObjectSafety),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = SUPERCLASS::v_InternalQueryInterface(riid, ppvObj);

    return hres;
}

HRESULT ChannelOC::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_pcli, guidService, riid, ppvObj);
}

//***   ChannelOC::IPersistPropertyBag::* {
//
HRESULT THISCLASS::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    ASSERT(_crBkgndOC == CLR_DEFAULT);  // paranoia
    _crBkgndOC = PropBag_ReadInt4(pPropBag, L"BGColor", CLR_DEFAULT);
    TraceMsg(TF_WARNING, "coc.l: BGColor=%x", _crBkgndOC);
    
    _crBorder = PropBag_ReadInt4(pPropBag, L"BorderColor", CLR_DEFAULT);
    
    return S_OK;
}

HRESULT THISCLASS::Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT THISCLASS::InitNew()
{
    ASSERT(_crBkgndOC == CLR_DEFAULT);
    ASSERT(_crBorder == CLR_DEFAULT);
    return E_NOTIMPL;
}

// }

LRESULT ChannelOC::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch(uMsg)
    {
    case WM_CONTEXTMENU:
        return 1;

    case WM_WINDOWPOSCHANGED:
        if (_hwndChild)
        {
            LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
    
            if (!(lpwp->flags & SWP_NOSIZE))
            {
                SetWindowPos(_hwndChild, NULL,
                    0,0,
                    lpwp->cx, lpwp->cy,
                    SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE|
                    (lpwp->flags&(SWP_NOREDRAW|SWP_NOCOPYBITS)));
            }
    
        }
        return 0;

    case WM_ERASEBKGND:
        if ( _crBorder == CLR_DEFAULT )
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            HDC hdc = (HDC) wParam;
            RECT rcClient;
            GetClientRect( hwnd, &rcClient );
            COLORREF crSave = SetBkColor(hdc, _crBorder);
            
            ExtTextOut(hdc,0,0,ETO_OPAQUE,&rcClient,NULL,0,NULL);
            SetBkColor(hdc, crSave);
        }

    case WM_COMMAND:
    case WM_NOTIFY:
        if (_pweh)
        {
            LRESULT lres;
            if (SUCCEEDED(_pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lres)))
                return lres;
        }
        // fall through

    default:
        return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
    }
}


LPITEMIDLIST ChannelOC::_GetInitialPidl()
{
    LPITEMIDLIST pidl = NULL;

    // Figure out what directory this ChannelOC is looking at.
    // If we're looking at a specific channel category, use it,
    // otherwise use the top-level Channels folder.
    //
    if (EVAL(_pcli))
    {
        IOleContainer *pContainer;

        if (SUCCEEDED(_pcli->GetContainer(&pContainer)))
        {
            IHTMLDocument2 *pDoc;

            if (SUCCEEDED(pContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID*)&pDoc)))
            {
                IHTMLLocation *pLocation;

                if (SUCCEEDED(pDoc->get_location(&pLocation)))
                {
                    BSTR bstrURL;

                    if (SUCCEEDED(pLocation->get_href(&bstrURL)) && bstrURL)
                    {
                        TCHAR szPath[MAX_PATH];
                        DWORD cchT = ARRAYSIZE(szPath);
                        if (SUCCEEDED(PathCreateFromUrl(bstrURL, szPath, &cchT, 0)))
                        {
                            PathRemoveFileSpec(szPath);

                            // if we're not under the channels folder, then
                            // ignore this location
                            //
                            if (SUCCEEDED(IECreateFromPath(szPath, &pidl)))
                            {
                                LPITEMIDLIST pidlChannels = Channel_GetFolderPidl();

                                if (!pidlChannels || !ILIsParent(pidlChannels, pidl, FALSE))
                                {
                                    ILFree(pidl);
                                    pidl = NULL;
                                }

                                ILFree(pidlChannels);
                            }
                            TraceMsg(TF_BAND, "ChannelOC::_OnInPlaceActivate [%s] (%x)", szPath, pidl);
                        }

                        SysFreeString(bstrURL);
                    }

                    pLocation->Release();
                }

                pDoc->Release();
            }

            pContainer->Release();
        }
    }

    return pidl;
}

void ChannelOC::_OnInPlaceActivate()
{
    SUPERCLASS::_OnInPlaceActivate();

    // we should never get called twice, but might as well be safe
    //
    if (EVAL(!_pBand))
    {
        LPITEMIDLIST pidl = _GetInitialPidl();

        // Now create the band and initialize it properly
        //
        _pBand = ChannelBand_Create(pidl);
        if (_pBand)
        {
            IDropTarget* pdt;

            Channels_SetBandInfoSFB(_pBand);
            _pBand->QueryInterface(IID_IWinEventHandler, (LPVOID*)&_pweh);
        
            IUnknown_SetSite(_pBand, SAFECAST(this, IOleObject*));

            // now that band is sited and init'ed, we can override defaults
            if (_crBkgndOC != CLR_DEFAULT) {
                BANDINFOSFB bi;

                TraceMsg(TF_WARNING, "coc.oipa: BGColor=%x _pBand=%x", _crBkgndOC, _pBand);
                bi.dwMask = ISFB_MASK_BKCOLOR;
                bi.crBkgnd = _crBkgndOC;
                IUnknown_SetBandInfoSFB(_pBand, &bi);
            }

            _dbi.dwMask = DBIM_MINSIZE|DBIM_MAXSIZE|DBIM_INTEGRAL|DBIM_ACTUAL|DBIM_TITLE|DBIM_MODEFLAGS|DBIM_BKCOLOR;
            _pBand->GetBandInfo(0, DBIF_VIEWMODE_VERTICAL, &_dbi);

            _pBand->GetWindow(&_hwndChild);

            SetWindowPos(_hwndChild, NULL, 0, 0,
                         _rcPos.right - _rcPos.left,
                         _rcPos.bottom - _rcPos.top,
                         SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_SHOWWINDOW);

            _pBand->ShowDW(TRUE);

            // Register the band as a drop target
            if (SUCCEEDED(_pBand->QueryInterface(IID_IDropTarget, (LPVOID*)&pdt)))
            {
                THR(RegisterDragDrop(_hwnd, pdt));
                pdt->Release();
            }

            TraceMsg(TF_BAND, "ISFBandOC::_OnInPlaceActivate()d to cx=%d cy=%d", _size.cx, _size.cy);
        }

        ILFree(pidl);
    }
}

void ChannelOC::_OnInPlaceDeactivate()
{
    IDeskBand * pBand = _pBand;

    // set to NULL to avoid re-entrancy...
    _pBand = NULL;
    
    if (pBand)
    {
        _hwndChild = NULL;

        RevokeDragDrop(_hwnd);

        pBand->ShowDW(FALSE);
        IUnknown_SetSite(pBand, NULL);
        pBand->CloseDW(0);

        TraceMsg(TF_BAND, "ISFBandOC::_OnInPlaceDeactivate()d");
    }

    // we need to keep _pweh because we need the notifies during destruction to 
    // free everything properly
    // the _pBand = NULL above is sufficient to keep from reentrancy
    ATOMICRELEASE(_pweh);
    ATOMICRELEASE(pBand);

    SUPERCLASS::_OnInPlaceDeactivate();
}

HRESULT ChannelOC::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    HRESULT hres = SUPERCLASS::SetObjectRects(lprcPosRect, lprcClipRect);

    if (_hwndChild)
    {
        SetWindowPos(_hwndChild, NULL, 0,0,
            _rcPos.right - _rcPos.left,
            _rcPos.bottom - _rcPos.top, SWP_NOZORDER);
    }

    return hres;
}

STDAPI ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;

    ChannelOC* pBand = new ChannelOC(punkOuter, poi);
    if (pBand)
    {
        *ppunk = pBand->_GetInner();
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\clslock.cpp ===
#include "priv.h"
#include "dochost.h"

#define DM_CACHEOLESERVER   DM_TRACE

#define HACK_CACHE_OBJECT_TOO
// #define HACK_LOCKRUNNING_TOO

class CClassHolder : IUnknown
{
protected:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    friend IUnknown* ClassHolder_Create(const CLSID* pclsid);

    CClassHolder(const CLSID* pclsid);
    ~CClassHolder();

    UINT _cRef;
    IClassFactory* _pcf;
    DWORD _dwAppHack;

#ifdef HACK_CACHE_OBJECT_TOO
    IUnknown* _punk;
#ifdef HACK_LOCKRUNNING_TOO
    IRunnableObject* _pro;
#endif
#endif // HACK_CACHE_OBJECT_TOO
};

HRESULT CClassHolder::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CClassHolder, IDiscardableBrowserProperty, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CClassHolder::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CClassHolder::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

CClassHolder::CClassHolder(const CLSID* pclsid) : _cRef(1)
{
    HRESULT hres;
    hres = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                    0, IID_IClassFactory, (LPVOID*)&_pcf);

    TraceMsg(DM_CACHEOLESERVER, "CCH::CCH Just called CoGetClassObject %x", hres);

    if (SUCCEEDED(hres)) {
        ::GetAppHackFlags(NULL, pclsid, &_dwAppHack);

        _pcf->LockServer(TRUE);

#ifdef HACK_CACHE_OBJECT_TOO
        hres = _pcf->CreateInstance(NULL, IID_IUnknown, (LPVOID*)&_punk);

        if ((_dwAppHack & BROWSERFLAG_INITNEWTOKEEP) && SUCCEEDED(hres)) {

            TraceMsg(TF_SHDAPPHACK, "CCH::CCH hack for Excel. Call InitNew to keep it running");

            //
            // This InitNew keeps Excel running
            //
            IPersistStorage* pps;
            HRESULT hresT;
            hresT = _punk->QueryInterface(IID_IPersistStorage, (LPVOID*)&pps);
            if (SUCCEEDED(hresT)) {
                IStorage* pstg;
                hresT = StgCreateDocfile(NULL,
                    STGM_DIRECT | STGM_CREATE | STGM_READWRITE
                    | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
                    0, &pstg);
                if (SUCCEEDED(hresT)) {
                    TraceMsg(DM_TRACE, "CCLH::ctor calling InitNew()");
                    pps->InitNew(pstg);
                    pstg->Release();
                } else {
                    TraceMsg(DM_TRACE, "CCLH::ctor StgCreateDocfile failed %x", hresT);
                }
                pps->Release();
            } else {
                TraceMsg(DM_TRACE, "CCLH::ctor QI to IPersistStorage failed %x", hresT);
            }
#ifdef HACK_LOCKRUNNING_TOO
            hres = _punk->QueryInterface(IID_IRunnableObject, (LPVOID*)&_pro);
            if (SUCCEEDED(hres)) {
                TraceMsg(DM_CACHEOLESERVER, "CCH::CCH This is runnable. Keep it running %x", _pro);
                OleRun(_pro);
                OleLockRunning(_pro, TRUE, TRUE);
            }
#endif
        }
#endif
    }
}

CClassHolder::~CClassHolder()
{
    if (_pcf) {
#ifdef HACK_CACHE_OBJECT_TOO
        if (_punk) {
#ifdef HACK_LOCKRUNNING_TOO
            if (_pro) {
                OleLockRunning(_pro, FALSE, TRUE);
                _pro->Release();
            }
#endif
            _punk->Release();
        }
#endif
        _pcf->LockServer(FALSE);
        ATOMICRELEASE(_pcf);
    }
}

IUnknown* ClassHolder_Create(const CLSID* pclsid)
{
    return new CClassHolder(pclsid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\cwndproc.cpp ===
#include "priv.h"
#include "..\inc\cwndproc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\common.h ===
#ifndef _COMMON_H
#define _COMMON_H

#if defined(__cplusplus) && !defined(CINTERFACE)
#define QueryInterface(punk, iid, pobj) (punk)->QueryInterface(iid, pobj)
#define AddRef(punk)                    (punk)->AddRef()
#define Release(punk)                   (punk)->Release()
#else  /* CINTERFACE */
#define QueryInterface(punk, iid, pobj) (punk)->lpVtbl->QueryInterface(punk, iid, pobj)
#define AddRef(punk)                    (punk)->lpVtbl->AddRef(punk)
#define Release(punk)                   (punk)->lpVtbl->Release(punk)
#endif /* CINTERFACE */

#endif  // _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\convert.h ===
/************************************************************\
	FILE: convert.h

	DATE: Apr 1, 1996

	AUTHOR: Bryan Starbuck (bryanst)

	DESCRIPTION:
		This file will handle the logic to convert Netscape
	bookmarks to Microsoft Internet Explorer favorites.  This 
	will happen by finding the location of the Netscape bookmarks
	file and the Microsoft Internet Explorer favorites directory
	from the registry.  Then it will parse the bookmarks file to
	extract the URLs, which will finally be added to the favorites
	directory.

  NOTES:
	This was developed with Netscape 2.0 and IE 2.0.  Future notes
	will be made about compatibility with different versions of
	these browsers.
	
\************************************************************/

#ifndef _CONVERT_H
#define _CONVERT_H



// ItemType is going to be the type of entry found in the bookmarks
// file.
typedef enum MYENTRYTYPE
{
    ET_OPEN_DIR     = 531,  // New level in heirarchy
    ET_CLOSE_DIR,           // Close level in heirarchy
    ET_BOOKMARK,            // Bookmark entry.
    ET_NONE,                // End of File
    ET_ERROR                // Bail, we encountered an error
} MyEntryType;


//////////////////////////////////////////////////////////////////
//	Exprted Functions
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
BOOL    ImportNetscapeProxy(void);		// Import Netscape Proxy Setting
BOOL    UpdateHomePage(void);			// Upgrade IE v1.0 Home URL to v3.0
BOOL    ImportBookmarks(HINSTANCE hInstWithStr);			//  Import Netscape Bookmarks to IE Favorites

BOOL    RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL    GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);

BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL        ConvertBookmarks(char * szFavoritesDir, HANDLE hFile, HINSTANCE hInstWithStr);
MyEntryType   NextFileEntry(char ** ppStr, char ** ppToken);
BOOL        GetData(char ** ppData, HANDLE hFile);
void        RemoveInvalidFileNameChars(char * pBuf);
BOOL        CreateDir(char *pDirName);
BOOL        CloseDir(void);
BOOL        CreateBookmark(char *pBookmarkName);
BOOL        GetNavBkMkDir( LPSTR lpszDir, int isize );


#endif // _CONVERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shdocvw"
#define SZ_MODULE           "SHDOCVW"
#define DECLARE_DEBUG
#include <debug.h>

// Include the standard helper functions to dump common ADTs

#undef lstrcpy
#undef wsprintf

#undef  StrCpyW
#define lstrcpy    StrCpyW
#undef  wsprintfW
#define wsprintf   wsprintfW

#include "..\inc\dump.c"

#undef  lstrcpy
#define lstrcpy     Do_not_use_lstrcpy_use_StrCpyN
#undef  wsprintf
#define wsprintf    Do_not_use_wsprintf_use_wnsprintf

#define StrCpyW     Do_not_use_StrCpyW_use_StrCpyNW
#define wsprintfW   Do_not_use_wsprintfW_use_wnsprintfW



#ifdef DEBUG

void DumpMsg(LPCTSTR pszLabel, MSG * pmsg)
{
    ASSERT(IS_VALID_STRING_PTR(pszLabel, -1));
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYUP:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_KEYDOWN);
                STRING_CASE(WM_SYSKEYDOWN);
                STRING_CASE(WM_KEYUP);
                STRING_CASE(WM_SYSKEYUP);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            vk = %#04lx  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_CHAR);
                STRING_CASE(WM_SYSCHAR);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            char = '%c'  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_MOUSEMOVE:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MOUSEMOVE hwnd = %#08lx  x=%d  y=%d",
                 pszLabel, pmsg->hwnd, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
#endif
        break;

    case WM_TIMER:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
#endif
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        if (WM_USER > pmsg->message)
        {
            TraceMsg(TF_ALWAYS, "%s: msg = %#04lx    hwnd=%#04lx wP=%#08lx lP=%#08lx",
                     pszLabel, pmsg->message, pmsg->hwnd, pmsg->wParam, pmsg->lParam);
        }
        break;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\debdump.cpp ===
#include "priv.h"
#include "resource.h"   // IDM_AB_* fir this!
#include "hlframe.h"
#include "basesb.h"
#include "nsc.h"
#include "nsctask.h"

#ifdef DEBUG // {

#define DM_FIXME    0       // trace/break when hit unknown guy

struct DBClassInfo {
    int     cbSize;
    TCHAR * pszName;
};

//
// EXTERNALOBJECTS is a macro which simply expands to X(C,0) X(D,1)
// X(E, 2)...
// where C, D, E, ... are classes whose sizes are defined externally.
//

#define EXTERNALOBJECTS \
    X(CSDWindows, 0)  \

#define TABENT(c)   { SIZEOF(c), TEXT(#c) }
#define X(c, n)  { 0, TEXT(#c) },
struct DBClassInfo DBClassInfoTab[] =
{
    // tons of table entries missing
    // maybe drive off same file as debug extensions dumpers?
    TABENT(CBASEBROWSER),   // 0
    TABENT(CIEFrameAuto),   // 1
    TABENT(CNscTree),
    #define NUM_INTERNAL_OBJECTS 4

    EXTERNALOBJECTS // 5...
    { 0 },
};
#undef  TABENT
#undef  X

#define X(c, n) extern "C" extern const int SIZEOF_##c;
EXTERNALOBJECTS
#undef X


//***   DBGetClassSymbolic -- map size to class name (guess)
// NOTES
//  we just take the 1st hit, so if there are multiple classes w/ the
//  same size you get the wrong answer.  if that turns out to be a pblm
//  we can add special-case heuristics for the relevant classes.
//
//  TODO: should use a generic DWORD value/data pair lookup
//  helper func.
//

TCHAR *DBGetClassSymbolic(int cbSize)
{
    struct DBClassInfo *p;

#define X(c, n) \
    DBClassInfoTab[NUM_INTERNAL_OBJECTS+n].cbSize = SIZEOF_##c;
    EXTERNALOBJECTS
#undef X

    for (p = DBClassInfoTab; p->cbSize != 0; p++) {
        if (p->cbSize == cbSize)
            return p->pszName;
    }
    if (DM_FIXME) {
        TraceMsg(DM_FIXME, "DBgcs: cbSize=%d  no entry", cbSize);
        ASSERT(0);
    }
    return NULL;
}

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dhuihand.h ===
#ifndef _DHUIHAND_H
#define _DHUIHAND_H

class CDocHostUIHandler : 
               public IDocHostUIHandler2
             , public IObjectWithSite
             , public IOleCommandTarget
             , public IDispatch
{
   public:

       // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);
    
    // IDocHostUIHandler
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
        DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI( 
        DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI(void);
    virtual HRESULT STDMETHODCALLTYPE UpdateUI(void);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // IDocHostUIHandler2
    virtual HRESULT STDMETHODCALLTYPE GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw);

    // IObjectWithSite
    virtual HRESULT STDMETHODCALLTYPE SetSite(IUnknown *punkSite);
    virtual HRESULT STDMETHODCALLTYPE GetSite(REFIID riid, void **ppvSite);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);           

    //IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT* pctinfo) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId) { return E_NOTIMPL; };
    virtual STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr);

    CDocHostUIHandler::CDocHostUIHandler(void);
    CDocHostUIHandler::~CDocHostUIHandler(void);

protected:
    HRESULT GetAltExternal(IDispatch **ppDisp);    
    void ShowErrorDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);   
    HRESULT ShowMessage(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    void ShowFindDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT ShowPageSetupDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT ShowPrintDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT DoTemplatePrinting(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, BOOL fPREVIEW);
    HRESULT DoTemplatePageSetup(VARIANTARG *pvarargIn);
    HRESULT ShowPropertysheetDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT ShowPropertysheetDialogHelper(int cUnk, IUnknown ** apUnk, HWND hwndOwner, 
        IServiceProvider * pServiceProvider, IUnknown * punkBrowseDefault);
    HRESULT GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca);
    HRESULT ClsidToMoniker(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    IUnknown         * _punkSite;
    IOleInPlaceFrame * _pOleInPlaceFrame;
    HMENU              _hBrowseMenu;
    HMENU              _hEditMenu;    
    IDispatch        * _pExternal;

    IHTMLOptionsHolder * _pOptionsHolder;
    
    BOOL IsFindDialogUp(IWebBrowser2* pwb, IHTMLWindow2** ppWindow);

public:
    //to block more then one preview
    LONG    IncrementPreviewCnt() { return InterlockedIncrement(&m_cPreviewIsUp); };
    LONG    DecrementPreviewCnt() { return InterlockedDecrement(&m_cPreviewIsUp); };

private:
    LONG    m_cRef;
    LONG    m_cPreviewIsUp;
};

BSTR GetFindText(IWebBrowser2* pwb);
void PutFindText(IWebBrowser2* pwb, LPCWSTR pwszFindText);

#define STR_FIND_DIALOG_NAME   TEXT("__IE_FindDialog")
#define STR_FIND_DIALOG_TEXT   TEXT("__IE_FindDialogText")
#define STR_PRINT_PREVIEW_NAME TEXT("__IE_PRINTPREVIEW_TEMPLATE")

#endif //_DHUIHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dhuihand.cpp ===
#include "priv.h"
#include "resource.h"
#include "mshtmcid.h"

#include <mluisupp.h>

#ifndef X_IEHELPID_H_
#define X_IEHELPID_H_
#include "iehelpid.h"
#endif

#ifdef UNIX
#ifndef X_MAINWIN_H_
#define X_MAINWIN_H_
#  include <mainwin.h>
#endif
#endif // UNIX


#include "dhuihand.h"

#define DM_DOCHOSTUIHANDLER 0
#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2

//+------------------------------------------------------------------------
//
// WARNING! (greglett)
//
// The following defines were stolen from commdlg.h.  Since SHDOCVW is
// compiled with WINVER=0x0400 and these defines are WINVER=0x0500 they
// needed to be copied and included here.  These must be kept in sync
// with the commdlg.h definitions.
//
// If shdocvw ever gets compiled with WINVER=0x0500 or above, then these
// can be removed.
//
//-------------------------------------------------------------------------

#define NEED_BECAUSE_COMPILED_AT_WINVER_4
#ifdef  NEED_BECAUSE_COMPILED_AT_WINVER_4
//
//  Define the start page for the print dialog when using PrintDlgEx.
//
#define START_PAGE_GENERAL             0xffffffff

//
//  Page Range structure for PrintDlgEx.
//
typedef struct tagPRINTPAGERANGE {
   DWORD  nFromPage;
   DWORD  nToPage;
} PRINTPAGERANGE, *LPPRINTPAGERANGE;


//
//  PrintDlgEx structure.
//
typedef struct tagPDEXA {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCSTR                lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXA, *LPPRINTDLGEXA;
//
//  PrintDlgEx structure.
//
typedef struct tagPDEXW {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCWSTR               lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXW, *LPPRINTDLGEXW;
#ifdef UNICODE
typedef PRINTDLGEXW PRINTDLGEX;
typedef LPPRINTDLGEXW LPPRINTDLGEX;
#else
typedef PRINTDLGEXA PRINTDLGEX;
typedef LPPRINTDLGEXA LPPRINTDLGEX;
#endif // UNICODE

HRESULT  APIENTRY  PrintDlgExA(LPPRINTDLGEXA);
HRESULT  APIENTRY  PrintDlgExW(LPPRINTDLGEXW);
#ifdef UNICODE
#define PrintDlgEx  PrintDlgExW
#else
#define PrintDlgEx  PrintDlgExA
#endif // !UNICODE

//
//  Result action ids for PrintDlgEx.
//
#define PD_RESULT_CANCEL               0
#define PD_RESULT_PRINT                1
#define PD_RESULT_APPLY                2

#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000

#endif // NEED_BECAUSE_COMPILED_AT_WINVER_4


//+------------------------------------------------------------------------
//
// Useful combinations of flags for IOleCommandTarget
//
//-------------------------------------------------------------------------

#define OLECMDSTATE_DISABLED    OLECMDF_SUPPORTED
#define OLECMDSTATE_UP          (OLECMDF_SUPPORTED | OLECMDF_ENABLED)
#define OLECMDSTATE_DOWN        (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_LATCHED)
#define OLECMDSTATE_NINCHED     (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED)

struct SExpandoInfo
{
    TCHAR * name;
    VARTYPE type;
};

// Enumerations for custom expandos
enum MessageEnum
{
   MessageText,
   MessageCaption,
   MessageStyle,
   MessageHelpFile,
   MessageHelpContext
};

enum PagesetupEnum
{
    PagesetupHeader,
    PagesetupFooter,
    PagesetupStruct
};

enum PrintEnum
{
    PrintfRootDocumentHasFrameset,
    PrintfAreRatingsEnabled,
    PrintfPrintActiveFrame,
    PrintfPrintLinked,
    PrintfPrintSelection,
    PrintfPrintAsShown,
    PrintfShortcutTable,
    PrintiFontScaling,
    PrintpBodyActiveTarget,
    PrintStruct,
    PrintToFileOk,
    PrintToFileName,
    PrintfPrintActiveFrameEnabled,
};

enum PropertysheetEnum
{
    PropertysheetPunks
};

#ifdef UNIX
#   define ID_PRINT_R_PORTRAIT rad7
#   define ID_PRINT_R_LANDSCAPE rad8
#   define MAX_COMMAND_LEN   255
#endif // UNIX

//----------------------------------------------------------------------------
//
//  Arrays describing helpcontextids for PageSetup/Print
//
//----------------------------------------------------------------------------

static const DWORD aPrintDialogHelpIDs[] =
{
    stc6,                       IDH_PRINT_CHOOSE_PRINTER,
    cmb4,                       IDH_PRINT_CHOOSE_PRINTER,
    psh2,                       IDH_PRINT_PROPERTIES,
    stc7,                       IDH_PRINT_SETUP_DETAILS,
    stc8,                       IDH_PRINT_SETUP_DETAILS,
    stc9,                       IDH_PRINT_SETUP_DETAILS,
    stc10,                      IDH_PRINT_SETUP_DETAILS,
    stc12,                      IDH_PRINT_SETUP_DETAILS,
    stc11,                      IDH_PRINT_SETUP_DETAILS,
    stc14,                      IDH_PRINT_SETUP_DETAILS,
    stc13,                      IDH_PRINT_SETUP_DETAILS,
    stc5,                       IDH_PRINT_TO_FILE,
    chx1,                       IDH_PRINT_TO_FILE,
    ico3,                       IDH_PRINT_COLLATE,
    chx2,                       IDH_PRINT_COLLATE,
    grp1,                       IDH_PRINT_RANGE,
    rad1,                       IDH_PRINT_RANGE,        // all
    rad2,                       IDH_PRINT_RANGE,        // selection
    rad3,                       IDH_PRINT_RANGE,        // pages
    stc2,                       IDH_PRINT_RANGE,
    stc3,                       IDH_PRINT_RANGE,
    edt1,                       IDH_PRINT_RANGE,
    edt2,                       IDH_PRINT_RANGE,
    edt3,                       IDH_PRINT_COPIES,
    rad4,                       IDH_PRINT_SCREEN,
    rad5,                       IDH_PRINT_SEL_FRAME,
    rad6,                       IDH_PRINT_ALL_FRAME,
    IDC_LINKED,                 IDH_PRINT_LINKS,
    IDC_SHORTCUTS,              IDH_PRINT_SHORTCUTS,
    0,    0
};

static const DWORD aPageSetupDialogHelpIDs[] =
{
    psh3,                       IDH_PRINT_PRINTER_SETUP,
    stc2,                       IDH_PAGE_PAPER_SIZE,
    cmb2,                       IDH_PAGE_PAPER_SIZE,
    stc3,                       IDH_PAGE_PAPER_SOURCE,
    cmb3,                       IDH_PAGE_PAPER_SOURCE,
    rad1,                       IDH_PAGE_ORIENTATION,
    rad2,                       IDH_PAGE_ORIENTATION,
    stc15,                      IDH_PAGE_MARGINS,
    edt4,                       IDH_PAGE_MARGINS,
    stc16,                      IDH_PAGE_MARGINS,
    edt5,                       IDH_PAGE_MARGINS,
    stc17,                      IDH_PAGE_MARGINS,
    edt6,                       IDH_PAGE_MARGINS,
    stc18,                      IDH_PAGE_MARGINS,
    edt7,                       IDH_PAGE_MARGINS,
    IDC_EDITHEADER,             IDH_PAGESETUP_HEADER_LEFT,
    IDC_STATICHEADER,           IDH_PAGESETUP_HEADER_LEFT,
    IDC_EDITFOOTER,             IDH_PAGESETUP_HEADER_LEFT,
    IDC_STATICFOOTER,           IDH_PAGESETUP_HEADER_LEFT,
    IDC_HEADERFOOTER,           IDH_PAGESETUP_HEADER_LEFT,
    0,    0
};

//+---------------------------------------------------------------------------
//
//  Function:   GetControlID
//
//  Synopsis:
//
//  Arguments:  HWND - passed window handle of WM_CONTEXTMENU
//              lParam  - passed coordinates (lParam) of WM_CONTEXTMENU
//
//  Returns:    int - ctrlid
//
//
//----------------------------------------------------------------------------
int GetControlID(HWND hwnd, LPARAM lParam)
{
    int CtrlID;

    CtrlID = GetDlgCtrlID(hwnd);
    if (CtrlID==0)
    {
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        if (ScreenToClient(hwnd, &pt))
        {
            HWND  hwndChild = ChildWindowFromPointEx(hwnd, pt, CWP_ALL);
            if (hwndChild)
            {
                CtrlID = GetDlgCtrlID(hwndChild);
            }
        }
    }
    return CtrlID;

}

//+---------------------------------------------------------------------------
//
//  Function:   GetHelpFile
//
//  Synopsis:
//
//  Arguments:  iCtrlID - id of the control
//              adw     - array of DWORDS, consisting of controlid,helpid pairs
//
//  Returns:    A string with the name of the helpfile
//
//  Notes:      Help topics for the print dialogs can be either in iexplore.hlp
//              or in windows.hlp.  We key off the helpid to determine which
//              file to go to.
//
//----------------------------------------------------------------------------


LPTSTR
GetHelpFile(int iCtrlID, DWORD * adw)
{
    BOOL fContinue = TRUE;

    ASSERT (adw);
    while (fContinue)
    {
        int ctrlid = int(*adw);
        int helpid = int(*(adw + 1));

        if (ctrlid == 0 && helpid == 0)
        {
            fContinue = FALSE;
            break;
        }

        if (ctrlid == iCtrlID)
        {
            //TraceTag((tagContextHelp, "for ctrl=%d, topic=%d", ctrlid, helpid));
            return (helpid < 50000) ? TEXT("windows.hlp") : TEXT("iexplore.hlp");
        }

        adw += 2;
    }
    return TEXT("windows.hlp");
}

GetInterfaceFromClientSite(IUnknown *pUnk, REFIID riid, void ** ppv)
{
    HRESULT               hr;
    IOleObject          * pOleObject = NULL;
    IOleClientSite      * pOleClientSite = NULL;

    if (!pUnk || !ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pOleObject);
    if (hr)
        goto Cleanup;

    hr = pOleObject->GetClientSite(&pOleClientSite);
    if (pOleClientSite == NULL)
    {
        hr = E_FAIL;
    }
    if (hr)
        goto Cleanup;

    hr = pOleClientSite->QueryInterface(riid, ppv);

Cleanup:
    ATOMICRELEASE(pOleClientSite);
    ATOMICRELEASE(pOleObject);

    return hr;
    
    
}

//
// Get the IOleInPlaceFrame if available.  If this proves useful, move this somewhere interesting.
//
HRESULT GetInPlaceFrameFromUnknown(IUnknown * punk, IOleInPlaceFrame ** ppOleInPlaceFrame)
{
    HRESULT               hr;
    IOleInPlaceSite     * pOleInPlaceSite = NULL;
    IOleInPlaceUIWindow * pOleInPlaceUIWindow = NULL;
    RECT                  rcPos, rcClip;
    OLEINPLACEFRAMEINFO   frameInfo;

    hr = GetInterfaceFromClientSite(punk, IID_IOleInPlaceSite, (void**)&pOleInPlaceSite);
    if (hr)
        goto Cleanup;

    *ppOleInPlaceFrame = NULL;

    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    hr = pOleInPlaceSite->GetWindowContext(ppOleInPlaceFrame,
                                           &pOleInPlaceUIWindow,
                                           &rcPos,
                                           &rcClip,
                                           &frameInfo);

Cleanup:
    ATOMICRELEASE(pOleInPlaceUIWindow);
    ATOMICRELEASE(pOleInPlaceSite);

    return hr;
}

HRESULT
GetHwndFromUnknown(
    IUnknown          * punk,
    HWND              * phwnd)
{
    HRESULT             hr;
    IOleInPlaceFrame  * pOleInPlaceFrame = NULL;

    ASSERT(punk);
    ASSERT(phwnd);

    if (phwnd)
    {
        *phwnd = NULL;
    }

    if (!punk || !phwnd)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = GetInPlaceFrameFromUnknown((IUnknown*)punk, &pOleInPlaceFrame);
    if (hr)
        goto Cleanup;

    hr = pOleInPlaceFrame->GetWindow(phwnd);
    if (hr)
        goto Cleanup;

Cleanup:
    ATOMICRELEASE(pOleInPlaceFrame);

    return hr;
}

HRESULT
GetEventFromUnknown(
    IUnknown       * punk,
    IHTMLEventObj ** ppEventObj)
{
    HRESULT             hr;
    IHTMLDocument2    * pOmDoc = NULL;
    IHTMLWindow2      * pOmWindow = NULL;

    ASSERT(punk);
    ASSERT(ppEventObj);

    if (ppEventObj)
        *ppEventObj = NULL;

    if (!punk || !ppEventObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = punk->QueryInterface(IID_IHTMLDocument2, (void **) &pOmDoc);
    if (hr)
        goto Cleanup;

    hr = pOmDoc->get_parentWindow(&pOmWindow);
    if (hr)
        goto Cleanup;

    hr = pOmWindow->get_event(ppEventObj);
    if (hr)
        goto Cleanup;

Cleanup:
    ATOMICRELEASE(pOmDoc);
    ATOMICRELEASE(pOmWindow);

    return hr;
}

//
// Gets the dispids/variants from the event.
//
HRESULT
GetParamsFromEvent(
    IHTMLEventObj         * pEventObj,
    unsigned int            cExpandos,
    DISPID                  aDispid[],
    VARIANT                 aVariant[],
    const SExpandoInfo      aExpandos[])
{
    HRESULT             hr;
    IDispatchEx       * pDispatchEx = NULL;
    unsigned int        i;

    ASSERT(pEventObj);
    ASSERT(aVariant);
    ASSERT(aExpandos);
    // ASSERT(cExpandos >= 0); // cExpandos is an unsigned int, so this is always true

    // deleted "|| cExpandos < 0" from below test
    // since unsigned ints are never negative
    if (!pEventObj || !aVariant || !aExpandos)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i=0; i<cExpandos; i++)
    {
        VariantInit(aVariant+i);
        aDispid[i] = DISPID_UNKNOWN;
    }

    hr = pEventObj->QueryInterface(IID_IDispatchEx, (void**)&pDispatchEx);
    if (hr)
        goto Cleanup;

    for (i=0; i<cExpandos; i++)
    {
        hr = pDispatchEx->GetDispID(
            aExpandos[i].name,
            fdexNameCaseSensitive,
            aDispid+i);
        if (hr)
            goto Cleanup;

        hr = pDispatchEx->InvokeEx(
            aDispid[i],
            LOCALE_USER_DEFAULT,
            DISPATCH_PROPERTYGET,
            (DISPPARAMS *)&g_dispparamsNoArgs,
            aVariant+i,
            NULL,
            NULL);

        // Check the variant types match
        ASSERT(  V_VT(aVariant+i) == aExpandos[i].type
               || V_VT(aVariant+i) == VT_EMPTY);

        if (hr)
            goto Cleanup;
    }

Cleanup:
    ATOMICRELEASE(pDispatchEx);

    return hr;
}


HRESULT
PutParamToEvent(DISPID dispid, VARIANT * var, IHTMLEventObj * pEventObj)
{
    HRESULT         hr;
    IDispatchEx   * pDispatchEx = NULL;
    DISPPARAMS      dispparams = {var, &dispid, 1, 1};

    ASSERT(var);
    ASSERT(pEventObj);

    if (!var || !pEventObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pEventObj->QueryInterface(IID_IDispatchEx, (void**)&pDispatchEx);
    if (hr)
        goto Cleanup;

    hr = pDispatchEx->InvokeEx(
            dispid,
            LOCALE_USER_DEFAULT,
            DISPATCH_PROPERTYPUT,
            &dispparams,
            NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

Cleanup:
    ATOMICRELEASE(pDispatchEx);

    return hr;
}

void PutFindText(IWebBrowser2* pwb, LPCWSTR pwszFindText)
{
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_TEXT);

    if (NULL != bstrName)
    {
        VARIANT var = {VT_EMPTY};

        if (NULL != pwszFindText)
        {
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(pwszFindText);
        }

        if ((VT_EMPTY == var.vt) || (NULL != var.bstrVal))
        {
            pwb->PutProperty(bstrName, var);
        }

        SysFreeString(var.bstrVal);
        SysFreeString(bstrName);
    }
}

BSTR GetFindText(IWebBrowser2* pwb)
{   
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_TEXT);

    VARIANT var = {0};

    if (bstrName)
    {
        ASSERT(pwb);

        pwb->GetProperty(bstrName, &var);

        SysFreeString(bstrName);
    }

    BSTR bstrResult; 
    
    if (VT_BSTR == var.vt)
    {
        bstrResult = var.bstrVal;
    }
    else
    {   
        bstrResult = NULL;
        VariantClear(&var);
    }

    return bstrResult;
}

CDocHostUIHandler::CDocHostUIHandler(void) : m_cRef(1)
{
    DllAddRef();
    m_cPreviewIsUp = 0;
}

CDocHostUIHandler::~CDocHostUIHandler(void)
{
    ATOMICRELEASE(_punkSite);
    //
    // We don't addref _pExternal to avoid an addref/release cycle.  So, we can't release it.
    //
    // ATOMICRELEASE(_pExternal);
    ATOMICRELEASE(_pOptionsHolder);
    if (_hBrowseMenu)
        DestroyMenu(_hBrowseMenu);
    if (_hEditMenu)
        DestroyMenu(_hEditMenu);

    DllRelease();
}

STDMETHODIMP CDocHostUIHandler::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDocHostUIHandler, IDocHostUIHandler),
        QITABENT(CDocHostUIHandler, IObjectWithSite),
        QITABENT(CDocHostUIHandler, IOleCommandTarget),
        QITABENT(CDocHostUIHandler, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDocHostUIHandler::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CDocHostUIHandler::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CDocHostUIHandler::SetSite(IUnknown *punkSite)
{
    ATOMICRELEASE(_punkSite);

    ASSERT(_punkSite == NULL);  // don't lose a reference to this

    _punkSite = punkSite;

    if (_punkSite)
    {
        _punkSite->AddRef();
    }

    // Always return S_OK
    //
    return S_OK;
}

HRESULT CDocHostUIHandler::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}


//==========================================================================
// IDocHostUIHandler implementation
//==========================================================================

HRESULT CDocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    HRESULT                 hr = S_FALSE;
    HCURSOR                 hcursor;
    HMENU                   hMenu = NULL;
    VARIANT                 var, var1, var2;
    VARIANT               * pvar = NULL;
    int                     iSelection = 0;
    HWND                    hwnd = NULL;
    IOleCommandTarget     * pOleCommandTarget = NULL;
    IOleWindow            * pOleWindow = NULL;
    IOleInPlaceFrame      * pOleInPlaceFrame = NULL;
    IDocHostUIHandler     * pUIHandler = NULL;
    MENUITEMINFO            mii = {0};
    int                     i;
    OLECMD                  olecmd;
    UINT                    mf;
    BOOL                    fDeletePrint            = FALSE;
    BOOL                    fDeleteSetDesktopItem   = FALSE;

    IHTMLImgElement       * pImgEle = NULL;


    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowContextMenu called");

    //If restriction is set, we lie to Mshtml that context menu has been set. 
    if (SHRestricted2W(REST_NoBrowserContextMenu, NULL, 0))
        return S_OK;

    // Do a proper QI for IOleCommandTarget
    //
    hr = pcmdtReserved->QueryInterface(IID_IOleCommandTarget, (void**)&pOleCommandTarget);
    if (hr)
        goto Cleanup;


    // Check if we are in browse mode
    //
    olecmd.cmdID = IDM_BROWSEMODE;
    hr = pOleCommandTarget->QueryStatus(
            &CGID_MSHTML,
            1,
            &olecmd,
            NULL);
    if (hr)
        goto Cleanup;
    if (olecmd.cmdf == OLECMDSTATE_DOWN)
    {
        if (!_hBrowseMenu)
            _hBrowseMenu = LoadMenu(
                                MLGetHinst(),
                                MAKEINTRESOURCE(IDR_BROWSE_CONTEXT_MENU));
        hMenu = _hBrowseMenu;
    }

    // Check if we are in edit mode
    else
    {
        olecmd.cmdID = IDM_EDITMODE;
        hr = pOleCommandTarget->QueryStatus(
                &CGID_MSHTML,
                1,
                &olecmd,
                NULL);
        if (hr)
            goto Cleanup;
        if (olecmd.cmdf == OLECMDSTATE_DOWN)
        {
            if (!_hEditMenu)
                _hEditMenu = LoadMenu(
                                MLGetHinst(),
                                MAKEINTRESOURCE(IDR_FORM_CONTEXT_MENU));
            hMenu = _hEditMenu;
        }

        // Neither Browse nor Edit flags were set
        else
        {
            ASSERT(false);
            goto Cleanup;
        }
    }

    if (!hMenu)
        goto Cleanup;


    //
    // check through all the submenus and remove any sets of items which
    // need to be removed
    //

    fDeletePrint = SHRestricted2(REST_NoPrinting, NULL, 0);
    fDeleteSetDesktopItem = (WhichPlatform() != PLATFORM_INTEGRATED);

    if (fDeletePrint || fDeleteSetDesktopItem)
    {
        int  iSubMenuIndex;

        for(iSubMenuIndex = 0;  iSubMenuIndex < GetMenuItemCount(hMenu); iSubMenuIndex++)
        {
            HMENU hSubMenu;
            if(hSubMenu = GetSubMenu(hMenu, iSubMenuIndex))
            {
                if (fDeletePrint)
                {
                    DeleteMenu(hSubMenu, IDM_PRINT, MF_BYCOMMAND);
                }

                if (fDeleteSetDesktopItem)
                {
                    DeleteMenu(hSubMenu, IDM_SETDESKTOPITEM, MF_BYCOMMAND);
                }
            }
        }
    }


    // Make sure we are running mshtml debug build if we are loading debug window
    if (dwID == CONTEXT_MENU_DEBUG)
    {
        olecmd.cmdID = IDM_DEBUG_TRACETAGS;
        hr = pOleCommandTarget->QueryStatus(
                &CGID_MSHTML,
                1,
                &olecmd,
                NULL);
        if (olecmd.cmdf != OLECMDSTATE_UP)
            goto Cleanup;
    }


    // Select the appropriate submenu based on the passed in ID
    hMenu = GetSubMenu(hMenu, dwID);

    if (!hMenu)
        goto Cleanup;

    // Loop through and QueryStatus the menu items.
    //
    for(i = 0; i < GetMenuItemCount(hMenu); i++)
    {
        olecmd.cmdID = GetMenuItemID(hMenu, i);
        if (olecmd.cmdID > 0)
        {
            pOleCommandTarget->QueryStatus(
                    &CGID_MSHTML,
                    1,
                    &olecmd,
                    NULL);
            switch (olecmd.cmdf)
            {
            case OLECMDSTATE_UP:
            case OLECMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case OLECMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case OLECMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
            }
            CheckMenuItem(hMenu, olecmd.cmdID, mf);
            EnableMenuItem(hMenu, olecmd.cmdID, mf);
        }
    }

    // Get the language submenu
    hr = pOleCommandTarget->Exec(&CGID_ShellDocView, SHDVID_GETMIMECSETMENU, 0, NULL, &var);
    if (hr)
        goto Cleanup;

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.hSubMenu = (HMENU) var.byref;

    SetMenuItemInfo(hMenu, IDM_LANGUAGE, FALSE, &mii);
    // Insert Context Menu
    V_VT(&var1) = VT_INT_PTR;
    V_BYREF(&var1) = hMenu;

    V_VT(&var2) = VT_I4;
    V_I4(&var2) = dwID;

    hr = pOleCommandTarget->Exec(&CGID_ShellDocView, SHDVID_ADDMENUEXTENSIONS, 0, &var1, &var2);
    if (hr)
        goto Cleanup;

    // Get the window also.
    //
    if (SUCCEEDED(pcmdtReserved->QueryInterface(IID_IOleWindow, (void**)&pOleWindow)))
    {
        pOleWindow->GetWindow(&hwnd);
    }

    if (hwnd)
    {

        GetInterfaceFromClientSite(pcmdtReserved, IID_IDocHostUIHandler, (void **)&pUIHandler);
        if (pUIHandler)
            pUIHandler->EnableModeless(FALSE);

        GetInPlaceFrameFromUnknown(pcmdtReserved, &pOleInPlaceFrame);
        if (pOleInPlaceFrame)
                pOleInPlaceFrame->EnableModeless(FALSE);

        hcursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

        // Display the menu.  Pass in the HWND of our site object.
        //
        iSelection = ::TrackPopupMenu(
                        hMenu,
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                        ppt->x + CX_CONTEXTMENUOFFSET,
                        ppt->y + CY_CONTEXTMENUOFFSET,
                        0,
                        hwnd,
                        (RECT*)NULL);        

        if (pUIHandler)
            pUIHandler->EnableModeless(TRUE);

        if (pOleInPlaceFrame)
            pOleInPlaceFrame->EnableModeless(TRUE);

        SetCursor(hcursor);
    }

    if (iSelection)
    {
        switch (iSelection)
        {
            case IDM_FOLLOWLINKN:
                // tell the top level browser to save its window size to the registry so 
                // that our new window can pick it up and cascade properly

                IUnknown_Exec(_punkSite, &CGID_Explorer, SBCMDID_SUGGESTSAVEWINPOS, 0, NULL, NULL);

                // fall through

            case IDM_PROPERTIES:
            case IDM_FOLLOWLINKC:
            
                pvar = &var;
                V_VT(pvar) = VT_I4;
                V_I4(pvar) = MAKELONG(ppt->x, ppt->y);
                break;
        }

        pOleCommandTarget->Exec(&CGID_MSHTML, iSelection, 0, pvar, NULL);
    }

    {
        MENUITEMINFO mii2 = {0};
        mii2.cbSize = sizeof(mii);
        mii2.fMask  = MIIM_SUBMENU;
        mii2.hSubMenu = NULL;

        SetMenuItemInfo(hMenu, IDM_LANGUAGE, FALSE, &mii2);
    }

Cleanup:
    DestroyMenu (mii.hSubMenu);

    ATOMICRELEASE(pOleCommandTarget);
    ATOMICRELEASE(pOleWindow);
    ATOMICRELEASE(pOleInPlaceFrame);
    ATOMICRELEASE(pUIHandler);
    return hr;
}

HRESULT CDocHostUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    DWORD dwUrlEncodingDisableUTF8;
    DWORD dwSize = SIZEOF(dwUrlEncodingDisableUTF8);
    BOOL  fDefault = FALSE;
    DWORD dwLoadf = 0;

    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetHostInfo called");

    pInfo->cbSize = SIZEOF(DOCHOSTUIINFO);

    pInfo->dwFlags = DOCHOSTUIFLAG_BROWSER | DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION | DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION;

    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;     // default

    SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS,
        TEXT("UrlEncoding"), NULL, (LPBYTE) &dwUrlEncodingDisableUTF8, &dwSize, FALSE, (LPVOID) &fDefault, SIZEOF(fDefault));

    if (dwUrlEncodingDisableUTF8)
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8;
    else
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8;

    return S_OK;
}

HRESULT CDocHostUIHandler::ShowUI(
    DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
    IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
    IOleInPlaceUIWindow *pDoc)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowUI called");

    // Host did not display its own UI. Trident will proceed to display its own.
    return S_FALSE;
}

HRESULT CDocHostUIHandler::HideUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::HideUI called");
    // This one is paired with ShowUI
    return S_FALSE;
}

HRESULT CDocHostUIHandler::UpdateUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::UpdateUI called");
    // LATER: Isn't this equivalent to OLECMDID_UPDATECOMMANDS?
    return S_FALSE;
}

HRESULT CDocHostUIHandler::EnableModeless(BOOL fEnable)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::EnableModeless called");
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::ResizeBorder(
LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::TranslateAccelerator(
LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_FALSE; // The message was not translated
}

HRESULT CDocHostUIHandler::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    // Trident will default to its own user options.
    *pbstrKey = NULL;
    return S_FALSE;
}

HRESULT CDocHostUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget called");
    return E_NOTIMPL;
}

HRESULT CDocHostUIHandler::GetAltExternal(IDispatch **ppDisp)
{
    HRESULT hr = E_FAIL;

    IDocHostUIHandler *pDocHostUIHandler;
    IOleObject        *pOleObject;
    IOleClientSite    *pOleClientSite;

    *ppDisp = NULL;

    //  * QI ourselves for a service provider
    //  * QS for the top level browser's service provider
    //  * Ask for an IOleObject
    //  * Ask the IOleObject for an IOleClientSite
    //  * QI the IOleClientSite for an IDocHostUIHandler
    //  * Call GetExternal on the IDocHostUIHandler to get the IDispatch

    if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IOleObject, &pOleObject))))
    {
        if (SUCCEEDED(pOleObject->GetClientSite(&pOleClientSite)))
        {
            if (SUCCEEDED(pOleClientSite->QueryInterface(IID_IDocHostUIHandler,
                                                         (void **)&pDocHostUIHandler)))
            {
                hr = pDocHostUIHandler->GetExternal(ppDisp);
                pDocHostUIHandler->Release();
            }
            pOleClientSite->Release();
        }
        pOleObject->Release();
    }

    return hr;
}

HRESULT CDocHostUIHandler::GetExternal(IDispatch **ppDisp)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetExternal called");

    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_pExternal)
    {
        *ppDisp = _pExternal;
        (*ppDisp)->AddRef();
        goto Cleanup;
    }

    IDispatch *psuihDisp;
    IDispatch *pAltExternalDisp;

    *ppDisp = NULL;

    GetAltExternal(&pAltExternalDisp);

    hr = CShellUIHelper_CreateInstance2((IUnknown **)&psuihDisp, IID_IDispatch,
                                       _punkSite, pAltExternalDisp);
    if (SUCCEEDED(hr))
    {
        *ppDisp = psuihDisp;
        _pExternal = *ppDisp;

        if (pAltExternalDisp)
        {
            //  Don't hold a ref - the ShellUIHelper will do it
            pAltExternalDisp->Release();
        }
    }
    else if (pAltExternalDisp)
    {
        //  Couldn't create a ShellUIHelper but we got our host's
        //  external.
        *ppDisp = pAltExternalDisp;
        _pExternal = *ppDisp;
    }

Cleanup:
    ASSERT((SUCCEEDED(hr) && (*ppDisp)) || (FAILED(hr)));
    return hr;
}


HRESULT CDocHostUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::TranslateUrl called");

    return S_FALSE;
}


HRESULT CDocHostUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::FilterDataObject called");

    return S_FALSE;
}

HRESULT CDocHostUIHandler::GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetOverrideKeyPath called");

    return S_FALSE;
}


STDAPI CDocHostUIHandler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CDocHostUIHandler *pis = new CDocHostUIHandler;
    if (pis)
    {
        *ppunk = SAFECAST(pis, IDocHostUIHandler *);
        hres = S_OK;
    }
    return hres;
}

//==========================================================================
// IOleCommandTarget implementation
//==========================================================================

HRESULT CDocHostUIHandler::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
    {
        ULONG i;

        if (rgCmds == NULL)
            return E_INVALIDARG;

        for (i = 0 ; i < cCmds ; i++)
        {
            // ONLY say that we support the stuff we support in ::Exec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_SHOWSCRIPTERROR:
            case OLECMDID_SHOWMESSAGE:
            case OLECMDID_SHOWFIND:
            case OLECMDID_SHOWPAGESETUP:
            case OLECMDID_SHOWPRINT:
            case OLECMDID_PRINTPREVIEW:
            case OLECMDID_PRINT:
            case OLECMDID_PROPERTIES:
            case SHDVID_CLSIDTOMONIKER:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }

        hres = S_OK;
    }

    return hres;
}

HRESULT CDocHostUIHandler::Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case OLECMDID_SHOWSCRIPTERROR:
            if (!pvarargIn || !pvarargOut)
                return E_INVALIDARG;

            ShowErrorDialog(pvarargIn, pvarargOut, nCmdexecopt);
            return S_OK;

        case OLECMDID_SHOWMESSAGE:
            if (!pvarargIn || !pvarargOut)
                return E_INVALIDARG;
            else
                return ShowMessage(pvarargIn, pvarargOut, nCmdexecopt);

        case OLECMDID_SHOWFIND:
            if (!pvarargIn)
                return E_INVALIDARG;

            ShowFindDialog(pvarargIn, pvarargOut, nCmdexecopt);
            return S_OK;

        case OLECMDID_SHOWPAGESETUP:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return ShowPageSetupDialog(pvarargIn, pvarargOut, nCmdexecopt);

        case IDM_TEMPLATE_PAGESETUP:
            return DoTemplatePageSetup(pvarargIn);

        case OLECMDID_SHOWPRINT:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return ShowPrintDialog(pvarargIn, pvarargOut, nCmdexecopt);

        case OLECMDID_PRINTPREVIEW:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return DoTemplatePrinting(pvarargIn, pvarargOut, TRUE);

        case OLECMDID_PRINT:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return DoTemplatePrinting(pvarargIn, pvarargOut, FALSE);

        case OLECMDID_REFRESH:
            //if print preview is up, tell them we handled refresh 
            //to prevent Trident from refreshing.
            if (m_cPreviewIsUp > 0)
                return S_OK;
            // else do default handling
            break;

        case OLECMDID_PROPERTIES:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return ShowPropertysheetDialog(pvarargIn, pvarargOut, nCmdexecopt);

        case SHDVID_CLSIDTOMONIKER:
            if (!pvarargIn || !pvarargOut)
                return E_INVALIDARG;
            else
                return ClsidToMoniker(pvarargIn, pvarargOut);

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}

//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWSCRIPTERROR
//
//+---------------------------------------------------------------------------

void CDocHostUIHandler::ShowErrorDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{
    HRESULT hr;
    HWND hwnd;
    IHTMLEventObj * pEventObj = NULL;
    IMoniker * pmk = NULL;
    VARIANT varEventObj;
    TCHAR   szResURL[MAX_URL_STRING];

    hr = GetHwndFromUnknown(V_UNKNOWN(pvarargIn), &hwnd);
    if (hr)
        goto Cleanup;

    hr = GetEventFromUnknown(V_UNKNOWN(pvarargIn), &pEventObj);
    if (hr)
        goto Cleanup;

    hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                           HINST_THISDLL,
                           ML_CROSSCODEPAGE,
                           TEXT("error.dlg"),
                           szResURL,
                           ARRAYSIZE(szResURL),
                           TEXT("shdocvw.dll"));
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = CreateURLMoniker(NULL, szResURL, &pmk);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&varEventObj) = VT_DISPATCH;
    V_DISPATCH(&varEventObj) = pEventObj;

    ShowHTMLDialog(hwnd, pmk, &varEventObj, NULL, pvarargOut);

Cleanup:
    ATOMICRELEASE(pEventObj);
    ATOMICRELEASE(pmk);
}

//+---------------------------------------------------------------------------
//
//  Callback procedure for OLECMDID_SHOWMESSAGE dialog
//
//+---------------------------------------------------------------------------
struct MSGBOXCALLBACKINFO
{
    DWORD   dwHelpContext;
    TCHAR * pstrHelpFile;
    HWND    hwnd;
};

static void CALLBACK
MessageBoxCallBack(HELPINFO *phi)
{
    MSGBOXCALLBACKINFO  *p = (MSGBOXCALLBACKINFO *)phi->dwContextId;
    BOOL                fRet;

    fRet = WinHelp(
            p->hwnd,
            p->pstrHelpFile,
            HELP_CONTEXT,
            p->dwHelpContext);

    THR(fRet ? S_OK : E_FAIL);
}

//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWMESSAGE
//
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowMessage(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// must match order of MessageEnum
static const SExpandoInfo s_aMessageExpandos[] =
{
    {TEXT("messageText"),         VT_BSTR},
    {TEXT("messageCaption"),      VT_BSTR},
    {TEXT("messageStyle"),        VT_UI4},
    {TEXT("messageHelpFile"),     VT_BSTR},
    {TEXT("messageHelpContext"),  VT_UI4}
};

    HRESULT             hr;
    HWND                hwnd = NULL;
    MSGBOXPARAMS        mbp;
    MSGBOXCALLBACKINFO  mcbi;
    LRESULT             plResult = 0;
    LPOLESTR            lpstrText = NULL;
    LPOLESTR            lpstrCaption = NULL;
    DWORD               dwType = 0;
    LPOLESTR            lpstrHelpFile = NULL;
    DWORD               dwHelpContext = 0;

    IHTMLEventObj     * pEventObj = NULL;
    const int           cExpandos = ARRAYSIZE(s_aMessageExpandos);
    DISPID              aDispid[cExpandos];
    VARIANT             aVariant[cExpandos];
    int                 i;
    ULONG_PTR uCookie = 0;

    ASSERT(pvarargIn && pvarargOut);

    for(i=0; i<cExpandos; i++)
        VariantInit(aVariant + i);

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    GetHwndFromUnknown(V_UNKNOWN(pvarargIn), &hwnd);  // hwnd can be NULL
    hr = GetEventFromUnknown(V_UNKNOWN(pvarargIn), &pEventObj);
    if (hr)
        goto Cleanup;

    // Get parameters from event object
    hr = GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aMessageExpandos);
    if (hr)
        goto Cleanup;

    // Copy values from variants
    lpstrText = V_BSTR(&aVariant[MessageText]);
    lpstrCaption = V_BSTR(&aVariant[MessageCaption]);
    dwType = V_UI4(&aVariant[MessageStyle]);
    lpstrHelpFile = V_BSTR(&aVariant[MessageHelpFile]);
    dwHelpContext = V_UI4(&aVariant[MessageHelpContext]);

    // Set message box callback info
    mcbi.dwHelpContext = dwHelpContext;
    mcbi.pstrHelpFile = lpstrHelpFile;
    mcbi.hwnd = hwnd;

    // Set message box params
    memset(&mbp, 0, sizeof(mbp));
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = hwnd;           // It is okay if this is NULL
    mbp.hInstance = MLGetHinst();
    mbp.lpszText = lpstrText;
    mbp.lpszCaption = lpstrCaption;
    mbp.dwContextHelpId = (DWORD_PTR) &mcbi;
    mbp.lpfnMsgBoxCallback = MessageBoxCallBack;
    // mbp.dwLanguageID = ?
    mbp.dwStyle = dwType;

    if (dwHelpContext && lpstrHelpFile)
        mbp.dwStyle |= MB_HELP;

    if (mbp.hwndOwner == NULL)
        mbp.dwStyle |= MB_TASKMODAL;

    SHActivateContext(&uCookie);
    plResult = MessageBoxIndirect(&mbp);
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

Cleanup:
    V_VT(pvarargOut) = VT_I4;
    V_I4(pvarargOut) = (LONG)plResult;

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    ATOMICRELEASE(pEventObj);

    return hr;
}


BOOL CDocHostUIHandler::IsFindDialogUp(IWebBrowser2* pwb, IHTMLWindow2** ppWindow)
{
    BOOL fRet = FALSE;
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        VARIANT var = {0};
        pwb->GetProperty(bstrName, &var);

        if ( (var.vt == VT_DISPATCH) && (var.pdispVal != NULL) )
        {
            if (ppWindow)
            {
                *ppWindow = (IHTMLWindow2*)var.pdispVal;
                (*ppWindow)->AddRef();
            }
            fRet = TRUE;
        }

        VariantClear(&var);
        SysFreeString(bstrName);
    }

    if (!fRet && ppWindow)
        *ppWindow = NULL;

    return fRet;
}

HRESULT SetFindDialogProperty(IWebBrowser2* pwb, VARIANT* pvar)
{
    HRESULT hr;
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        hr = pwb->PutProperty(bstrName, *pvar);

        SysFreeString(bstrName);
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

//if this fails, then we have no choice but to orphan the dialog
HRESULT SetFindDialogUp(IWebBrowser2* pwb, IHTMLWindow2* pWindow)
{
    VARIANT var;
    var.vt = VT_DISPATCH;
    var.pdispVal = pWindow;
    return SetFindDialogProperty(pwb, &var);
}

void ReleaseFindDialog(IWebBrowser2* pwb)
{
    VARIANT var = {0};
    SetFindDialogProperty(pwb, &var);
}


//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWFIND
//
//  pvarargIn - IDispatch Interface
//  dwflags   - bidi flag
//+---------------------------------------------------------------------------

void
CDocHostUIHandler::ShowFindDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags)
{
    IDispatch             * pDispatch = NULL;
    IHTMLOptionsHolder    * pHTMLOptionsHolder = NULL;
    IHTMLDocument2        * pHTMLDocument2 = NULL;
    IHTMLWindow2          * pHTMLWindow2 = NULL;
    IOleInPlaceFrame      * pOleInPlaceFrame = NULL;
    HWND                    hwnd = NULL;
    IMoniker              * pmk = NULL;

    if (EVAL(V_VT(pvarargIn) == VT_DISPATCH))
    {
        pDispatch = V_DISPATCH(pvarargIn);
        
        if (SUCCEEDED(pDispatch->QueryInterface(IID_IHTMLOptionsHolder, (void**)&pHTMLOptionsHolder)))
        {
            if (SUCCEEDED(pHTMLOptionsHolder->get_document(&pHTMLDocument2)) && pHTMLDocument2)
            {
                if (SUCCEEDED(pHTMLDocument2->get_parentWindow(&pHTMLWindow2)))
                {
                    if (SUCCEEDED(GetInPlaceFrameFromUnknown(pHTMLDocument2, &pOleInPlaceFrame)))
                    {
                        if (SUCCEEDED(pOleInPlaceFrame->GetWindow(&hwnd)))
                        {
                            BOOL fInBrowser = FALSE;
                            IWebBrowser2 * pwb2 = NULL;

                            if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, &pwb2))))
                            {
                                fInBrowser = TRUE;
                            }

                            TCHAR   szResURL[MAX_URL_STRING];

                            if (SUCCEEDED(MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                            HINST_THISDLL,
                                                            ML_CROSSCODEPAGE,
                                                            (dwflags ? TEXT("bidifind.dlg") : TEXT("find.dlg")),
                                                            szResURL,
                                                            ARRAYSIZE(szResURL),
                                                            TEXT("shdocvw.dll"))))
                            {
                                CreateURLMoniker(NULL, szResURL, &pmk);

                                if (fInBrowser)
                                {
                                    IHTMLWindow2 *pWinOut;

                                    if (!IsFindDialogUp(pwb2, &pWinOut))
                                    {
                                        ASSERT(NULL==pWinOut);

                                        if ((NULL != pvarargIn) && 
                                            (VT_DISPATCH == pvarargIn->vt) &&
                                            (NULL != pvarargIn->pdispVal))
                                        {
                                            BSTR bstrFindText = GetFindText(pwb2);
                                            if (bstrFindText)
                                            {
                                                //  paranoia since we hang on to this object
                                                //  a while and there is always potential 
                                                //  for mess ups below where we mean to
                                                //  release it.
                                                ATOMICRELEASE(_pOptionsHolder);

                                                pvarargIn->pdispVal->QueryInterface(
                                                                     IID_IHTMLOptionsHolder,
                                                                     (void **)&_pOptionsHolder);
                                                if (_pOptionsHolder)
                                                    _pOptionsHolder->put_findText(bstrFindText);
                                                
                                                SysFreeString(bstrFindText);
                                            }
                                        }

                                        ShowModelessHTMLDialog(hwnd, pmk, pvarargIn, NULL, &pWinOut);

                                        if (pWinOut)
                                        {
                                            //can't really handle failure here, because the dialog is already up.
                                            BSTR bstrOnunload = SysAllocString(L"onunload");
                                            if (bstrOnunload)
                                            {
                                                IHTMLWindow3 * pWin3;
                                                if (SUCCEEDED(pWinOut->QueryInterface(IID_IHTMLWindow3, (void**)&pWin3)))
                                                {
                                                    VARIANT_BOOL varBool;
                                                    if (SUCCEEDED(pWin3->attachEvent(bstrOnunload, (IDispatch*)this, &varBool)))
                                                    {
                                                        // on SetFindDialogUp success, the property holds the ref on pWinOut
                                                        if (FAILED(SetFindDialogUp(pwb2, pWinOut)))
                                                        {
                                                            // No way to handle the event, so detach
                                                            pWin3->detachEvent(bstrOnunload, (IDispatch*)this);
                                                        }
                                                    }

                                                    pWin3->Release();
                                                }
                                                SysFreeString(bstrOnunload);
                                            }

                                            // REVIEW: the old code leaked this ref if the property
                                            // wasn't attached in SetFindDialogUp...
                                            pWinOut->Release();
                                        }        
                                    }
                                    else
                                    {
                                        //since the find dialog is already up, send focus to it
                                        pWinOut->focus();
                                        pWinOut->Release();
                                    }
                                }
                                else
                                {
                                    //we're not in the browser, so just show it modal
                                    ShowHTMLDialog(hwnd, pmk, pvarargIn, NULL, NULL);
                                }
                                if (pmk)
                                    pmk->Release();
                            }
                            ATOMICRELEASE(pwb2);

                        }
                        pOleInPlaceFrame->Release();
                    }
                    pHTMLWindow2->Release();
                }
                pHTMLDocument2->Release();
            }
            pHTMLOptionsHolder->Release();
        }
    }

    //pWinOut gets released in CDocHostUIHandler::Invoke() or CIEFrameAuto::COmWindow::ViewReleased(),
    // in response to the onunload event.
    
    if (pvarargOut)
        VariantInit(pvarargOut);
}

//+---------------------------------------------------------------------------
//
//  Callback procedure for OLECMDID_SHOWPAGESETUP dialog
//
//+---------------------------------------------------------------------------
struct PAGESETUPBOXCALLBACKINFO
{
    TCHAR   strHeader[1024];
    TCHAR   strFooter[1024];
};

UINT_PTR APIENTRY
PageSetupHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HKEY    keyPageSetup = NULL;

    switch (uiMsg)
    {
    case WM_INITDIALOG:
        PAGESETUPBOXCALLBACKINFO * ppscbi;
        ppscbi = (PAGESETUPBOXCALLBACKINFO *) ((PAGESETUPDLG*)lParam)->lCustData;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ppscbi);

#ifdef UNIX
        SendDlgItemMessage(hdlg,IDC_EDITHEADER, EM_LIMITTEXT, 1023, 0L);
        SendDlgItemMessage(hdlg,IDC_EDITFOOTER, EM_LIMITTEXT, 1023, 0L);
#endif
        SetDlgItemText(hdlg,IDC_EDITHEADER, ppscbi->strHeader);
        SetDlgItemText(hdlg,IDC_EDITFOOTER, ppscbi->strFooter);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            {
                PAGESETUPBOXCALLBACKINFO * ppscbi;
                ppscbi = (PAGESETUPBOXCALLBACKINFO *) GetWindowLongPtr(hdlg, DWLP_USER);
                if (ppscbi)
                {
                    GetDlgItemText(hdlg,IDC_EDITHEADER, ppscbi->strHeader,1024);
                    GetDlgItemText(hdlg,IDC_EDITFOOTER, ppscbi->strFooter,1024);
                }
            }
        }
        break;

   case WM_HELP:
    {
        LPHELPINFO pHI;


        pHI = (LPHELPINFO)lParam;
        if (pHI->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            WinHelp(
                    (HWND)pHI->hItemHandle,
                    GetHelpFile(pHI->iCtrlId, (DWORD *)aPageSetupDialogHelpIDs),
                    HELP_WM_HELP,
                    (DWORD_PTR)(LPVOID) aPageSetupDialogHelpIDs);
        }
        break;
        //return TRUE;
    }

    case WM_CONTEXTMENU:
    {
        int CtrlID = GetControlID((HWND)wParam, lParam);

        WinHelp(
                (HWND)wParam,
                GetHelpFile(CtrlID, (DWORD *)aPageSetupDialogHelpIDs),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aPageSetupDialogHelpIDs);
        break;
    }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWPAGESETUP
//
//  pvarargIn - holds IHTMLEventObj * for the event
//
// Returns S_FALSE if the user clicked Cancel and S_TRUE if the user
// clicked OK.
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowPageSetupDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// must match order of PagesetupEnum
static const SExpandoInfo s_aPagesetupExpandos[] =
{
    {OLESTR("pagesetupHeader"),  VT_BSTR},
    {OLESTR("pagesetupFooter"),  VT_BSTR},
    {OLESTR("pagesetupStruct"),  VT_PTR}
};

    HRESULT                         hr = E_FAIL;
    PAGESETUPDLG                  * ppagesetupdlg = NULL;
    PAGESETUPBOXCALLBACKINFO        pagesetupcbi;

    IHTMLEventObj                 * pEventObj = NULL;
    const int                       cExpandos = ARRAYSIZE(s_aPagesetupExpandos);
    DISPID                          aDispid[cExpandos];
    VARIANT                         aVariant[cExpandos];
    int                             i;
    ULONG_PTR uCookie = 0;

    for (i=0; i<cExpandos; i++)
        VariantInit(aVariant+i);

    ASSERT(pvarargIn && (V_VT(pvarargIn) == VT_UNKNOWN));
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
        goto Cleanup;

    if (V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj, (void **) &pEventObj))
        goto Cleanup;

    // Get parameters from event object
    if (GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aPagesetupExpandos))
        goto Cleanup;

    // Copy values from variants
    StrCpyN((TCHAR*)pagesetupcbi.strHeader,
        V_BSTR(&aVariant[PagesetupHeader]) ? V_BSTR(&aVariant[PagesetupHeader]) : TEXT(""),
        ARRAYSIZE(pagesetupcbi.strHeader));
    StrCpyN((TCHAR*)pagesetupcbi.strFooter,
        V_BSTR(&aVariant[PagesetupFooter]) ? V_BSTR(&aVariant[PagesetupFooter]) : TEXT(""),
        ARRAYSIZE(pagesetupcbi.strHeader));

    ppagesetupdlg = (PAGESETUPDLG *)V_BYREF(&aVariant[PagesetupStruct]);
    if (!ppagesetupdlg)
        goto Cleanup;

    // Set up custom dialog resource fields in pagesetupdlg
    ppagesetupdlg->Flags |= PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;
    ppagesetupdlg->lCustData = (LPARAM) &pagesetupcbi;
    ppagesetupdlg->lpfnPageSetupHook = PageSetupHookProc;
    ppagesetupdlg->hInstance = MLLoadShellLangResources();

#ifdef UNIX
    ppagesetupdlg->lpPageSetupTemplateName = MAKEINTRESOURCE(PAGESETUPDLGORDMOTIF);
#else
    ppagesetupdlg->lpPageSetupTemplateName = MAKEINTRESOURCE(PAGESETUPDLGORD);
#endif // UNIX

    // Show dialog
    SHActivateContext(&uCookie);
    if (!PageSetupDlg(ppagesetupdlg))
    {
        // treat failure as canceling
        hr = S_FALSE;
        goto Cleanup;
    }
    hr = S_OK;

    // Save header/footer in event object
    VARIANT var;

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = SysAllocString(pagesetupcbi.strHeader ? pagesetupcbi.strHeader : TEXT(""));
    if (NULL != V_BSTR(&var))
    {
        PutParamToEvent(aDispid[PagesetupHeader], &var, pEventObj);
        VariantClear(&var);
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = SysAllocString(pagesetupcbi.strFooter ? pagesetupcbi.strFooter : TEXT(""));
    if (NULL != V_BSTR(&var))
    {
        PutParamToEvent(aDispid[PagesetupFooter], &var, pEventObj);
        VariantClear(&var);
    }

Cleanup:
    if (ppagesetupdlg)
        MLFreeLibrary(ppagesetupdlg->hInstance);

    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    if (pvarargOut)
        VariantInit(pvarargOut);

    ATOMICRELEASE(pEventObj);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Callback procedure for OLECMDID_SHOWPRINT dialog
//
//+---------------------------------------------------------------------------

static void SetPreviewBitmap(long bitmapID, HWND hdlg);
HRESULT GetPrintFileName(HWND hwnd, TCHAR achFilePath[]);

struct PRINTBOXCALLBACKINFO
{
    BOOL    fRootDocumentHasFrameset;
    BOOL    fAreRatingsEnabled;
    BOOL    fPrintActiveFrameEnabled;
    BOOL    fPrintActiveFrame;
    BOOL    fPrintLinked;
    BOOL    fPrintSelection;
    BOOL    fPrintAsShown;
    BOOL    fShortcutTable;
    int     iFontScaling;
    IOleCommandTarget * pBodyActive;
#ifdef UNIX
    int     dmOrientation
#endif // UNIX
};

// Common handling functions for both NT 5 and legacy print dialogs
void OnInitDialog( HWND hdlg, PRINTBOXCALLBACKINFO * ppcbi )
{
    if (ppcbi)
    {
        // Three scenarioes:
        // 1.  Base case: Not FRAMESET, no IFRAMES.  No frameoptions should be available.
        // 2.  FRAMESET:  Obey all frameoptions.  Any may be available.
        // 3.  IFRAME:    May have selected frame available.  If so, make selecetd frame & as laid out avail.
        
        // Should the active frame be disabled?
        if (!ppcbi->fPrintActiveFrameEnabled)
        {
            // Disable "print selected frame" radiobutton.
            HWND hwndPrintActiveFrame =  GetDlgItem(hdlg, rad5);
            EnableWindow(hwndPrintActiveFrame, FALSE);
        }

        // If there is no frameset, disable "print all frames" radiobutton.
        if (!ppcbi->fRootDocumentHasFrameset)
        {
            HWND hwndPrintAllFrames = GetDlgItem(hdlg, rad6);
            EnableWindow(hwndPrintAllFrames, FALSE);

            if (!ppcbi->fPrintActiveFrameEnabled)
            {
                // We're not a FRAMESET and don't have IFRAMEs
                // Disable "print as laid out on screen" radiobutton.
                HWND hwndPrintAsLaidOutOnScreen = GetDlgItem(hdlg, rad4);
                EnableWindow(hwndPrintAsLaidOutOnScreen, FALSE);
                SetPreviewBitmap(IDR_PRINT_PREVIEWDISABLED, hdlg);                
            }
        }

        // Setup default radio button to be checked.
        // NOTE: We currently allow the template to check options that are disabled.
        if (ppcbi->fPrintActiveFrame)
        {
            // Check "print selected frame" radiobutton.
            CheckRadioButton(hdlg, rad4, rad6, rad5);
            SetPreviewBitmap(IDR_PRINT_PREVIEWONEDOC, hdlg);
        }
        else if (ppcbi->fPrintAsShown)
        {
            // Check "print frames as laid out" radiobutton.
            CheckRadioButton(hdlg, rad4, rad6, rad4);
            SetPreviewBitmap(IDR_PRINT_PREVIEW, hdlg);
        }
        else
        {
            // Check "print all frames" radiobutton.
            CheckRadioButton(hdlg, rad4, rad6, rad6);
            SetPreviewBitmap(IDR_PRINT_PREVIEWALLDOCS, hdlg);
        }


        HWND hwndSelection = GetDlgItem(hdlg, rad2);
        if (hwndSelection) EnableWindow(hwndSelection, (ppcbi->fPrintSelection));

#ifdef FONTSIZE_BOX
        int i=0, cbLen=0;

        //bugwin16: need to fix this.
        for (i = 0; i < IDS_PRINT_FONTMAX; i++)
        {
            TCHAR   achBuffer[128];

            cbLen = MLLoadShellLangString(IDS_PRINT_FONTSCALE+i,achBuffer,127);
            if (cbLen)
            {
                SendDlgItemMessage(hdlg, IDC_SCALING, CB_ADDSTRING, 0, (long) achBuffer);
            }
        }

        if (i>0)
        {
            SendDlgItemMessage(hdlg, IDC_SCALING, CB_SETCURSEL, IDS_PRINT_FONTMAX - 1 - ppcbi->iFontScaling, 0);
        }
#endif // FONTSIZE_BOX

        // If ratings are enabled, don't allow recursive printing.
        if (ppcbi->fAreRatingsEnabled)
        {
            HWND hwndPrintLinkedDocuments = GetDlgItem(hdlg, IDC_LINKED);
            CheckDlgButton(hdlg, IDC_LINKED, BST_UNCHECKED);
            EnableWindow(hwndPrintLinkedDocuments, FALSE);
        }
    }
}

void OnCommand( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    PRINTBOXCALLBACKINFO * ppcbi;
    ppcbi = (PRINTBOXCALLBACKINFO *)GetWindowLongPtr(hdlg, DWLP_USER);

    if (!ppcbi)
    {
        return;
    }

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case rad1:         // "Print all"
    case rad3:         // "Print range"
    case rad2:         // "Print selection" (text selection)
      {
        // If we are printing a text selection, and we have a selected frame,
        // force a print selected frame.
        if (ppcbi && ppcbi->fPrintActiveFrame && ppcbi->fPrintSelection)
        {
            HWND hwndPrintWhatGroup = GetDlgItem(hdlg, grp3);
            HWND hwndPrintActiveFrame = GetDlgItem(hdlg, rad5);
            HWND hwndPrintAllFrames = GetDlgItem(hdlg, rad6);
            HWND hwndPrintSelectedFrame = GetDlgItem(hdlg, rad4);

            if (hwndPrintWhatGroup)     EnableWindow(hwndPrintWhatGroup, LOWORD(wParam) != rad2);
            if (hwndPrintActiveFrame)   EnableWindow(hwndPrintActiveFrame, LOWORD(wParam) != rad2);
            if (hwndPrintAllFrames)     EnableWindow(hwndPrintAllFrames, ppcbi->fRootDocumentHasFrameset && LOWORD(wParam) != rad2);
            if (hwndPrintSelectedFrame) EnableWindow(hwndPrintSelectedFrame, LOWORD(wParam) != rad2);

        }

        break;
      }

    case rad4:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            // now change the icon...

            SetPreviewBitmap(IDR_PRINT_PREVIEW, hdlg);
            HWND hwnd = GetDlgItem(hdlg, rad2);
            if (hwnd) EnableWindow(hwnd, FALSE);
            hwnd = GetDlgItem(hdlg, IDC_SHORTCUTS);
            if (hwnd) EnableWindow(hwnd, FALSE);
            hwnd = GetDlgItem(hdlg, IDC_LINKED);
            if (hwnd) EnableWindow(hwnd, FALSE);
   //         if(ppcbi->pBodyActive);
   //             ppcbi->pBodyActive->Layout()->LockFocusRect(FALSE);
        }
        break;

    case rad5:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            // now change the icon

            SetPreviewBitmap(IDR_PRINT_PREVIEWONEDOC, hdlg);
            HWND hwnd = GetDlgItem(hdlg, rad2);
            if (hwnd) EnableWindow(hwnd, (ppcbi->fPrintSelection));
            hwnd = GetDlgItem(hdlg, IDC_SHORTCUTS);
            if (hwnd) EnableWindow(hwnd, TRUE);
            hwnd = GetDlgItem(hdlg, IDC_LINKED);
            if (hwnd) EnableWindow(hwnd, TRUE);
   //         if(ppcbi->pBodyActive);
   //             ppcbi->pBodyActive->Layout()->LockFocusRect(TRUE);
        }
        break;

    case rad6:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            // now change the icon

            SetPreviewBitmap(IDR_PRINT_PREVIEWALLDOCS, hdlg);
            HWND hwnd = GetDlgItem(hdlg, rad2);
            if (hwnd) EnableWindow(hwnd, FALSE);
            hwnd = GetDlgItem(hdlg, IDC_SHORTCUTS);
            if (hwnd) EnableWindow(hwnd, TRUE);
            hwnd = GetDlgItem(hdlg, IDC_LINKED);
            if (hwnd) EnableWindow(hwnd, TRUE);
   //         if(ppcbi->pBodyActive);
   //             ppcbi->pBodyActive->Layout()->LockFocusRect(FALSE);
        }
        break;

#ifdef UNIX
    case rad7:   // Portrait
        CheckRadioButton(hdlg, ID_PRINT_R_PORTRAIT,
                         ID_PRINT_R_LANDSCAPE, ID_PRINT_R_PORTRAIT);
        break;

    case rad8:   // Landscape
        CheckRadioButton(hdlg, ID_PRINT_R_PORTRAIT,
                         ID_PRINT_R_LANDSCAPE, ID_PRINT_R_LANDSCAPE);
        break;
#endif // UNIX
    }
}

void OnHelp( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    LPHELPINFO pHI;

    pHI = (LPHELPINFO)lParam;
    if (pHI->iContextType == HELPINFO_WINDOW)   // must be for a control
    {
        WinHelp(
                (HWND)pHI->hItemHandle,
                GetHelpFile(pHI->iCtrlId, (DWORD *) aPrintDialogHelpIDs),
                HELP_WM_HELP,
                (DWORD_PTR)(LPVOID) aPrintDialogHelpIDs);
    }
}

void OnContextMenu( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    int CtrlID = GetControlID((HWND)wParam, lParam);

    WinHelp(
            (HWND)wParam,
            GetHelpFile(CtrlID, (DWORD *) aPrintDialogHelpIDs),
            HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) aPrintDialogHelpIDs);
}

void OnApplyOrOK( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
#ifdef UNIX
    CHAR szPrinterCommand[MAX_PATH];
#endif // UNIX
    PRINTBOXCALLBACKINFO * ppcbi;
    ppcbi = (PRINTBOXCALLBACKINFO *)GetWindowLongPtr(hdlg, DWLP_USER);

    if (ppcbi)
    {
        ppcbi->fPrintLinked      = IsDlgButtonChecked(hdlg, IDC_LINKED);
        ppcbi->fPrintSelection   = IsDlgButtonChecked(hdlg, rad2);
        ppcbi->fPrintActiveFrame = IsDlgButtonChecked(hdlg, rad5) ||
                                       ( ppcbi->fPrintSelection &&
                                         ppcbi->fRootDocumentHasFrameset
                                        );
        ppcbi->fPrintAsShown     = IsDlgButtonChecked(hdlg, rad4) ||
                                       ( ppcbi->fPrintSelection &&
                                         ppcbi->fRootDocumentHasFrameset
                                        );
        ppcbi->fShortcutTable    = IsDlgButtonChecked(hdlg, IDC_SHORTCUTS);
#ifdef FONTSIZE_BOX
        ppcbi->iFontScaling      = IDS_PRINT_FONTMAX - 1 - SendDlgItemMessage( hdlg, IDC_SCALING, CB_GETCURSEL, 0,0 );
#endif

#ifdef UNIX
        // Code to deal with orientation on print dialog
        if ( IsDlgButtonChecked(hdlg, ID_PRINT_R_PORTRAIT) )
        {
            ppcbi->dmOrientation = DMORIENT_PORTRAIT;
        }
        else
        {
            ppcbi->dmOrientation = DMORIENT_LANDSCAPE;
        }

        // get user entered printer command
        GetDlgItemTextA(hdlg, edt4, szPrinterCommand, MAX_PATH);
        MwSetPrintCommand( szPrinterCommand );
#endif // UNIX
    }

}
// This is the callback routine (and dlgproc) for the options
// page in the NT 5 print dialog.
INT_PTR APIENTRY
OptionsPageProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
    case WM_INITDIALOG:
    {
        PRINTBOXCALLBACKINFO * ppcbi;
        ppcbi = (PRINTBOXCALLBACKINFO *) ((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ppcbi);

        OnInitDialog( hdlg, ppcbi );
        break;
    }

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_APPLY:
            OnApplyOrOK( hdlg, wParam, lParam );
            SetWindowLongPtr (hdlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr (hdlg, DWLP_MSGRESULT, FALSE);
            return 1;
            break;

        case PSN_RESET:
            SetWindowLongPtr (hdlg, DWLP_MSGRESULT, FALSE);
            break;
        }
        break;

    case WM_COMMAND:
        OnCommand( hdlg, wParam, lParam );
        break;

    case WM_HELP:
        OnHelp( hdlg, wParam, lParam );
        break;

    case WM_CONTEXTMENU:
        OnContextMenu( hdlg, wParam, lParam );
        break;
    }

    return FALSE;

}


UINT_PTR CALLBACK
PrintHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
    case WM_INITDIALOG:
        if (lParam)
        {
            PRINTBOXCALLBACKINFO * ppcbi;
            ppcbi = (PRINTBOXCALLBACKINFO *) ((PRINTDLG*)lParam)->lCustData;
            SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ppcbi);

            OnInitDialog( hdlg, ppcbi );
        }
        return TRUE;

    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDOK:
                OnApplyOrOK( hdlg, wParam, lParam );
                break;

            default:
                OnCommand( hdlg, wParam, lParam );
                break;
            }
        }
        break;

    case WM_HELP:
        OnHelp( hdlg, wParam, lParam );
        break;
        //return TRUE;

    case WM_CONTEXTMENU:
        OnContextMenu( hdlg, wParam, lParam );
        break;

    case WM_DESTROY:
    {
        PRINTBOXCALLBACKINFO * ppcbi;
        ppcbi = (PRINTBOXCALLBACKINFO *)GetWindowLongPtr(hdlg, DWLP_USER);
        ASSERT(ppcbi);

  //      if(ppcbi && ppcbi->pBodyActive);
  //          ppcbi->pBodyActive->Layout()->LockFocusRect(FALSE);
        break;
    }
    }

    return FALSE;
}

void SetPreviewBitmap(long bitmapID, HWND hdlg)
{
    // now change the icon...(note these bitmaps are not localized)
    HBITMAP hNewBitmap, hOldBitmap;
    hNewBitmap = (HBITMAP) LoadImage(HINST_THISDLL, MAKEINTRESOURCE(bitmapID),
                           IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADMAP3DCOLORS );

    ASSERT(hNewBitmap);
    if (hNewBitmap)
    {
        hOldBitmap = (HBITMAP) SendDlgItemMessage(hdlg, IDC_PREVIEW, STM_SETIMAGE,
                                                  (WPARAM) IMAGE_BITMAP, (LPARAM) hNewBitmap);

        if (hOldBitmap)
        {
            //VERIFY(DeleteObject(hOldBitmap)!=0);
            int i;
            i = DeleteObject(hOldBitmap);
            ASSERT(i!=0);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWPRINT
//
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowPrintDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// the following must match the order of PrintEnum
static const SExpandoInfo s_aPrintExpandos[] =
{
    {OLESTR("printfRootDocumentHasFrameset"),   VT_BOOL},
    {OLESTR("printfAreRatingsEnabled"),         VT_BOOL},
    {OLESTR("printfActiveFrame"),               VT_BOOL},
    {OLESTR("printfLinked"),                    VT_BOOL},
    {OLESTR("printfSelection"),                 VT_BOOL},
    {OLESTR("printfAsShown"),                   VT_BOOL},
    {OLESTR("printfShortcutTable"),             VT_BOOL},
    {OLESTR("printiFontScaling"),               VT_INT},
    {OLESTR("printpBodyActiveTarget"),          VT_UNKNOWN},
    {OLESTR("printStruct"),                     VT_PTR},
    {OLESTR("printToFileOk"),                   VT_BOOL},
    {OLESTR("printToFileName"),                 VT_BSTR},
    {OLESTR("printfActiveFrameEnabled"),        VT_BOOL},
};

    HRESULT                         hr = E_FAIL;
    PRINTDLG                      * pprintdlg = NULL;
    PRINTBOXCALLBACKINFO            printcbi;

    IHTMLEventObj                 * pEventObj = NULL;
    const int                       cExpandos = ARRAYSIZE(s_aPrintExpandos);
    DISPID                          aDispid[cExpandos];
    VARIANT                         aVariant[cExpandos];
    int                             i;
    DWORD                           dwErr = 0;

    printcbi.pBodyActive = NULL;

    if (!V_UNKNOWN(pvarargIn))
        goto Cleanup;

    if (V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj, (void **) &pEventObj))
        goto Cleanup;

    // Get parameters from event object
    if (GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aPrintExpandos))
        goto Cleanup;

    // Copy values from variants
    printcbi.fRootDocumentHasFrameset   = V_BOOL(&aVariant[PrintfRootDocumentHasFrameset]);
    printcbi.fAreRatingsEnabled         = V_BOOL(&aVariant[PrintfAreRatingsEnabled]);
    printcbi.fPrintActiveFrame          = V_BOOL(&aVariant[PrintfPrintActiveFrame]);
    printcbi.fPrintActiveFrameEnabled   = V_BOOL(&aVariant[PrintfPrintActiveFrameEnabled]);
    printcbi.fPrintLinked               = V_BOOL(&aVariant[PrintfPrintLinked]);
    printcbi.fPrintSelection            = V_BOOL(&aVariant[PrintfPrintSelection]);
    printcbi.fPrintAsShown              = V_BOOL(&aVariant[PrintfPrintAsShown]);
    printcbi.fShortcutTable             = V_BOOL(&aVariant[PrintfShortcutTable]);
    printcbi.iFontScaling               = V_INT(&aVariant[PrintiFontScaling]);

    // If we ever get LockFocusRect, use this field to access it
    // peterlee 8/7/98
    /*
    if (V_UNKNOWN(&aVariant[PrintpBodyActiveTarget]))
    {
        if (V_UNKNOWN(&aVariant[PrintpBodyActiveTarget])->QueryInterface(IID_IOleCommandTarget,
                (void**)&printcbi.pBodyActive))
            goto Cleanup;
    }
    */

    pprintdlg = (PRINTDLG *)V_BYREF(&aVariant[PrintStruct]);
    if (!pprintdlg)
        goto Cleanup;

    // Fix up requested page range so it's within bounds.  The dialog will
    // fail to initialize under W95 if this isn't done.
    if ( pprintdlg->nFromPage < pprintdlg->nMinPage )
        pprintdlg->nFromPage = pprintdlg->nMinPage;
    else if ( pprintdlg->nFromPage > pprintdlg->nMaxPage )
        pprintdlg->nFromPage = pprintdlg->nMaxPage;

    if ( pprintdlg->nToPage < pprintdlg->nMinPage )
        pprintdlg->nToPage = pprintdlg->nMinPage;
    else if ( pprintdlg->nToPage > pprintdlg->nMaxPage )
        pprintdlg->nToPage = pprintdlg->nMaxPage;

    // Set up custom dialog resource fields in pagesetupdlg
    pprintdlg->hInstance            = MLLoadShellLangResources();
    pprintdlg->lCustData            = (LPARAM) &printcbi;
    pprintdlg->lpfnPrintHook        = PrintHookProc;
#ifdef UNIX
    pprintdlg->lpPrintTemplateName  = MAKEINTRESOURCE(PRINTDLGORDMOTIF);
    pprintdlg->Flags |= PD_SHOWHELP;
    pprintdlg->Flags |= PD_ENABLESETUPHOOK;
    pprintdlg->lpfnSetupHook = PageSetupHookProc;
#else
    pprintdlg->lpPrintTemplateName  = MAKEINTRESOURCE(PRINTDLGORD);
#endif // UNIX

    if (g_bRunOnNT5)
    {
        // We want to use the new PrintDlgEx in NT 5, so map all the PrintDlg
        // settings to the new PrintDlgEx, get a pointer to the new function
        // and then call it.

        // Load the function from comdlg32 directly...
        typedef HRESULT (*PFNPRINTDLGEX)(LPPRINTDLGEX pdex);
        PFNPRINTDLGEX pfnPrintDlgEx = NULL;
        HMODULE hComDlg32 = LoadLibrary( TEXT("comdlg32.dll") );

        if (hComDlg32)
        {
            pfnPrintDlgEx = (PFNPRINTDLGEX)GetProcAddress( hComDlg32, "PrintDlgExW" );
        }


        // Make sure we can call the function...
        if (!pfnPrintDlgEx)
        {
            if (hComDlg32)
            {
                FreeLibrary( hComDlg32 );
            }
            hr = E_FAIL;
            goto Cleanup;
        }

        PRINTDLGEX              pdex;
        PROPSHEETPAGE           psp;
        HPROPSHEETPAGE          pages[1];
        PRINTPAGERANGE          ppr;

        // Copy over existing settings
        memset( &pdex, 0, sizeof(pdex) );
        pdex.lStructSize = sizeof(pdex);
        pdex.hwndOwner   = pprintdlg->hwndOwner;
        pdex.hDevMode    = pprintdlg->hDevMode;
        pdex.hDevNames   = pprintdlg->hDevNames;
        pdex.hDC         = pprintdlg->hDC;
        pdex.Flags       = pprintdlg->Flags;
        pdex.nMinPage    = pprintdlg->nMinPage;
        pdex.nMaxPage    = pprintdlg->nMaxPage;
        pdex.nCopies     = pprintdlg->nCopies;

        // New settings
        pdex.nStartPage     = START_PAGE_GENERAL;
        ppr.nFromPage       = pprintdlg->nFromPage;
        ppr.nToPage         = pprintdlg->nToPage;
        pdex.nPageRanges    = 1;
        pdex.nMaxPageRanges = 1;
        pdex.lpPageRanges   = &ppr;

        // Create options page
        memset( &psp, 0, sizeof(psp) );
        psp.dwSize       = sizeof(psp);
        psp.dwFlags      = PSP_DEFAULT;
        psp.hInstance    = pprintdlg->hInstance;
        psp.pszTemplate  = MAKEINTRESOURCE(IDD_PRINTOPTIONS);
        psp.pfnDlgProc   = OptionsPageProc;
        psp.lParam       = (LPARAM)&printcbi;
       
        pages[0] = SHNoFusionCreatePropertySheetPageW(&psp);

        if (pages[0])
        {

            pdex.nPropertyPages = 1;
            pdex.lphPropertyPages = pages;

            // Show the dialog
            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            hr = pfnPrintDlgEx(&pdex);
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
            if (SUCCEEDED(hr))
            {
                hr = S_FALSE;

                if ((pdex.dwResultAction == PD_RESULT_PRINT) || (pdex.Flags & PD_RETURNDEFAULT))
                {
                    // copy back values which might have changed
                    // during the call to PrintDlgEx
                    pprintdlg->Flags     = pdex.Flags;
                    pprintdlg->hDevMode  = pdex.hDevMode;
                    pprintdlg->hDevNames = pdex.hDevNames;
                    pprintdlg->nCopies   = (WORD)pdex.nCopies;
                    pprintdlg->nFromPage = (WORD)ppr.nFromPage;
                    pprintdlg->nToPage   = (WORD)ppr.nToPage;
                    if (pprintdlg->Flags & PD_RETURNDC)
                    {
                        pprintdlg->hDC = pdex.hDC;
                    }

                    hr = S_OK;
                }
                else if ((pdex.Flags & (PD_RETURNDC | PD_RETURNIC)) && pdex.hDC)
                {
                    DeleteDC(pdex.hDC);
                    pdex.hDC = NULL;
                }
            }
            else
            {
                hr = S_FALSE;
            }

            FreeLibrary( hComDlg32 );
        }
        else
        {
            FreeLibrary( hComDlg32 );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }



    }
    else
    {
        pprintdlg->Flags |= PD_ENABLEPRINTTEMPLATE | PD_ENABLEPRINTHOOK;
        pprintdlg->Flags &= (~(PD_CURRENTPAGE | PD_NOCURRENTPAGE));         // Just in case, mask out the W2K only.

        // Show dialog
        if (!PrintDlg(pprintdlg))
        {
           // treat failure as canceling
            dwErr = CommDlgExtendedError();
            hr = S_FALSE;
            goto Cleanup;
        }
        hr = S_OK;
    }

    // Write changed values to event object
    VARIANT var;
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = printcbi.fPrintLinked ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfPrintLinked], &var, pEventObj);

    V_BOOL(&var) = printcbi.fPrintActiveFrame ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfPrintActiveFrame], &var, pEventObj);

    V_BOOL(&var) = printcbi.fPrintAsShown ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfPrintAsShown], &var, pEventObj);

    V_BOOL(&var) = printcbi.fShortcutTable ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfShortcutTable], &var, pEventObj);

#ifdef FONTSIZE_BOX
    V_VT(&var) = VT_INT;
    V_INT(&var) = printcbi.iFontScaling;
    PutParamToEvent(aDispid[PrintiFontScaling], &var, pEventObj);
#endif // FONTSIZE_BOX

#ifdef UNIX
    V_VT(&var) = VT_INT;
    V_INT(&var) = printcbi.dmOrientation;
    PutParamToEvent(aDispid[PrintdmOrientation], &var, pEventObj);
#endif // UNIX

    // now pop up the fileselection dialog and save the filename...
    // this is the only place where we can make this modal
    BOOL fPrintToFileOk;
    fPrintToFileOk = FALSE;
    if ((pprintdlg->Flags & PD_PRINTTOFILE) != 0)
    {
        // Get the save file path from the event object
        TCHAR achPrintToFileName[MAX_PATH];
    
        StrCpyN(achPrintToFileName,
            V_BSTR(&aVariant[PrintToFileName]) ? V_BSTR(&aVariant[PrintToFileName]) : TEXT(""),
            ARRAYSIZE(achPrintToFileName));

        if (!GetPrintFileName(pprintdlg->hwndOwner, achPrintToFileName) &&
                achPrintToFileName)
        {
            fPrintToFileOk = TRUE;
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = SysAllocString(achPrintToFileName);
            if (NULL != V_BSTR(&var))
            {
                PutParamToEvent(aDispid[PrintToFileName], &var, pEventObj);
                VariantClear(&var);
            }
        }
    }

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fPrintToFileOk ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintToFileOk], &var, pEventObj);

Cleanup:
    if (pprintdlg)
        MLFreeLibrary(pprintdlg->hInstance);

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    if (pvarargOut)
        VariantInit(pvarargOut);

    ATOMICRELEASE(pEventObj);
    ATOMICRELEASE(printcbi.pBodyActive);

    return hr;
}


//+---------------------------------------------------------------------------
//
//   Callback procedure for PrintToFile Dialog
//
//+---------------------------------------------------------------------------
UINT_PTR APIENTRY PrintToFileHookProc(HWND hdlg,
                              UINT uiMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_INITDIALOG:
        {
            int      cbLen;
            TCHAR    achOK[MAX_PATH];

            // change "save" to "ok"
            cbLen = MLLoadShellLangString(IDS_PRINTTOFILE_OK,achOK,MAX_PATH);
            if (cbLen < 1)
                StrCpyN(achOK, TEXT("OK"), ARRAYSIZE(achOK));

    //        SetDlgItemText(hdlg, IDOK, _T("OK"));
            SetDlgItemText(hdlg, IDOK, achOK);

            // ...and, finally force us into foreground (needed for Win95, Bug : 13368)
            ::SetForegroundWindow(hdlg);
            break;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetPrintFileName
//
//  Synopsis:   Opens up the customized save file dialog and gets
//              a filename for the printoutput
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT GetPrintFileName(HWND hwnd, TCHAR achFilePath[])
{
    OPENFILENAME    openfilename;
    int             cbLen;
    TCHAR           achTitlePrintInto[MAX_PATH];
    TCHAR           achFilePrintInto[MAX_PATH];
    TCHAR           achFilter[MAX_PATH];
    TCHAR           achPath[MAX_PATH];

    HRESULT         hr = E_FAIL;

    memset(&openfilename,0,sizeof(openfilename));
    openfilename.lStructSize = sizeof(openfilename);
    openfilename.hwndOwner = hwnd;

    cbLen = MLLoadShellLangString(IDS_PRINTTOFILE_TITLE,achTitlePrintInto,MAX_PATH);
    ASSERT (cbLen && "could not load the resource");

    if (cbLen > 0)
        openfilename.lpstrTitle = achTitlePrintInto;

    // guarantee trailing 0 to terminate the filter string
    memset(achFilter, 0, sizeof(TCHAR)*MAX_PATH);
    cbLen = MLLoadShellLangString(IDS_PRINTTOFILE_SPEC,achFilter,MAX_PATH-2);
    ASSERT (cbLen && "could not load the resource");

    if (cbLen>0)
    {
        for (; cbLen >= 0; cbLen--)
        {
            if (achFilter[cbLen]== L',')
            {
                achFilter[cbLen] = 0;
            }
        }
    }

    openfilename.nMaxFileTitle = openfilename.lpstrTitle ? lstrlen(openfilename.lpstrTitle) : 0;
    StrCpyN(achFilePrintInto, TEXT(""), ARRAYSIZE(achFilePrintInto));
    openfilename.lpstrFile = achFilePrintInto;
    openfilename.nMaxFile = MAX_PATH;
    openfilename.Flags = OFN_NOREADONLYRETURN | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
                        OFN_ENABLEHOOK | OFN_NOCHANGEDIR;
    openfilename.lpfnHook = PrintToFileHookProc;
    openfilename.lpstrFilter = achFilter;
    openfilename.nFilterIndex = 1;

    StrCpyN(achPath, achFilePath, ARRAYSIZE(achPath));
    openfilename.lpstrInitialDir = *achPath ? achPath : NULL;

    if (GetSaveFileName(&openfilename))
    {
        StrCpyN(achFilePath, openfilename.lpstrFile, MAX_PATH);
        hr = S_OK;
    }

    if (hr)
        *achFilePath = NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Helpers for OLECMDID_PROPERTIES
//
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowPropertysheetDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// must match order of PropertysheetEnum
static const SExpandoInfo s_aPropertysheetExpandos[] =
{
    {OLESTR("propertysheetPunks"),  VT_SAFEARRAY}
};

    HRESULT             hr;
    HWND                hwnd = NULL;
    HWND                hwndParent;
    IUnknown          * punk = NULL;
    OLECMD              olecmd = {0, 0};
    int                 cUnk = 0;
    IUnknown * HUGEP  * apUnk = NULL;
    OCPFIPARAMS         ocpfiparams;
    CAUUID              ca = { 0, 0 };
    RECT                rc = {0, 0, 0, 0};
    RECT                rcDesktop = {0, 0, 0, 0};
    SIZE                pixelOffset;
    SIZE                metricOffset = {0, 0};

    IHTMLEventObj     * pEventObj = NULL;
    const int           cExpandos = ARRAYSIZE(s_aPropertysheetExpandos);
    VARIANT             aVariant[cExpandos];
    DISPID              aDispid[cExpandos];
    SAFEARRAY         * psafearray = NULL;

    for (int i=0; i<cExpandos; i++)
        VariantInit(&aVariant[i]);

    ASSERT(pvarargIn && V_VT(pvarargIn) == VT_UNKNOWN && V_UNKNOWN(pvarargIn));
    if (!pvarargIn || (V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the hwnd
    punk = V_UNKNOWN(pvarargIn);
    hr = GetHwndFromUnknown(punk, &hwnd);
    if (hr)
        goto Cleanup;

    // get the SafeArray expando from the event obj
    hr = GetEventFromUnknown(punk, &pEventObj);
    if (hr)
        goto Cleanup;

    hr = GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aPropertysheetExpandos);
    if (hr)
        goto Cleanup;
    psafearray = V_ARRAY(&aVariant[PropertysheetPunks]);

    // verify array dimensions
    if (SafeArrayGetDim(psafearray) != 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get array size, adding one to 0-based size
    hr = SafeArrayGetUBound(psafearray, 1, (long*)&cUnk);
    if (hr)
        goto Cleanup;
    cUnk++;

    if (cUnk)
    {
        // get pointer to vector
        hr = SafeArrayAccessData(psafearray, (void HUGEP* FAR*)&apUnk);
        if (hr)
            goto Cleanup;
    }
    else
    {
        cUnk = 1;
        apUnk = &punk;
    }

    // Compute pages to load
    hr = THR(GetCommonPages(cUnk, apUnk, &ca));
    if (hr)
        goto Cleanup;

    //  compute top-level parent
    while ( hwndParent = GetParent(hwnd) )
        hwnd = hwndParent;

    // The dialog box is not centered on screen
    // the ocpfi seems to be ignoring the x, y values in ocpfiparams
    // Compute offset to center of screen
    GetWindowRect(GetDesktopWindow(), &rcDesktop);
    GetWindowRect(hwnd, &rc);
    pixelOffset.cx = (rcDesktop.right - rcDesktop.left)/2 - rc.left;
    pixelOffset.cy = (rcDesktop.bottom - rcDesktop.top)/2 - rc.top;
    AtlPixelToHiMetric(&pixelOffset, &metricOffset);

    memset(&ocpfiparams, 0, sizeof(ocpfiparams));

    ocpfiparams.cbStructSize = sizeof(ocpfiparams);
    ocpfiparams.hWndOwner = hwnd;
    ocpfiparams.x = metricOffset.cx;
    ocpfiparams.y = metricOffset.cy;
    ocpfiparams.lpszCaption = NULL;
    ocpfiparams.cObjects = cUnk;
    ocpfiparams.lplpUnk = apUnk;
    ocpfiparams.cPages = ca.cElems;
    ocpfiparams.lpPages = ca.pElems;
    ocpfiparams.lcid = GetUserDefaultLCID();
    ocpfiparams.dispidInitialProperty = DISPID_UNKNOWN;

    // OleCreatePropertyFrameIndirect throws its own dialog on error,
    // so we don't want to display that twice
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    THR(OleCreatePropertyFrameIndirect(&ocpfiparams));
    hr = S_OK;

Cleanup:
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    if (ca.cElems)
        CoTaskMemFree(ca.pElems);

    if (psafearray && apUnk)
        SafeArrayUnaccessData(psafearray);

    if (pvarargOut)
        VariantInit(pvarargOut);

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    ATOMICRELEASE(pEventObj);

    return hr;
}

HRESULT
CDocHostUIHandler::GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca)
{
    HRESULT                hr = E_INVALIDARG;
    int                    i;
    UINT                   iScan, iFill, iCompare;
    BOOL                   fFirst = TRUE;
    CAUUID                 caCurrent;
    IUnknown *             pUnk;
    ISpecifyPropertyPages *pSPP;

    pca->cElems = 0;
    pca->pElems = NULL;

    for (i = 0; i < cUnk; i++)
    {
        pUnk = apUnk[i];
        ASSERT(pUnk);

        hr = THR(pUnk->QueryInterface(
                IID_ISpecifyPropertyPages,
                (void **)&pSPP));
        if (hr)
            goto Cleanup;

         hr = THR(pSPP->GetPages(fFirst ? pca : &caCurrent));
         ATOMICRELEASE(pSPP);
         if (hr)
             goto Cleanup;

         if (fFirst)
             continue;

         // keep only the common pages
         else
         {
             for (iScan = 0, iFill = 0; iScan < pca->cElems; iScan++)
             {
                 for (iCompare = 0; iCompare < caCurrent.cElems; iCompare++)
                 {
                     if (caCurrent.pElems[iCompare] == pca->pElems[iScan])
                         break;
                 }
                 if (iCompare != caCurrent.cElems)
                 {
                     pca->pElems[iFill++] = pca->pElems[iScan];

                 }
             }
             pca->cElems = iFill;
             CoTaskMemFree(caCurrent.pElems);
         }
    }


Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Helper for SHDVID_CLSIDTOMONIKER
//
//+---------------------------------------------------------------------------

struct HTMLPAGECACHE
{
    const CLSID *   pclsid;
    TCHAR *         ach;
};

HRESULT CDocHostUIHandler::ClsidToMoniker(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    static const HTMLPAGECACHE s_ahtmlpagecache[] =
    {
        &CLSID_CAnchorBrowsePropertyPage,           _T("anchrppg.ppg"),
        &CLSID_CImageBrowsePropertyPage,            _T("imageppg.ppg"),
        &CLSID_CDocBrowsePropertyPage,              _T("docppg.ppg"),
    };

    HRESULT                 hr = E_FAIL;
    IMoniker              * pmk = NULL;
    IUnknown              * pUnk = NULL;
    int                     i;
    const HTMLPAGECACHE   * phtmlentry;
    const CLSID           * pclsid;

    ASSERT(pvarargIn);
    ASSERT(pvarargOut);
    ASSERT(V_VT(pvarargIn) == VT_UINT_PTR && V_BYREF(pvarargIn));

    if (!pvarargIn || V_VT(pvarargIn) != VT_UINT_PTR || !V_BYREF(pvarargIn))
        goto Cleanup;
    pclsid = (CLSID *)V_BYREF(pvarargIn);

    if (!pvarargOut)
        goto Cleanup;
    VariantInit(pvarargOut);

    // lookup the resource from the CLSID
    for (i = ARRAYSIZE(s_ahtmlpagecache) - 1, phtmlentry = s_ahtmlpagecache;
        i >= 0;
        i--, phtmlentry++)
    {
        ASSERT(phtmlentry->pclsid && phtmlentry->ach);
        if (IsEqualCLSID(*pclsid, *phtmlentry->pclsid))
        {
            // create a moniker for the dialog resource
            TCHAR szResURL[MAX_URL_STRING];
#ifndef UNIX
            hr = MLBuildResURL(TEXT("shdoclc.dll"),
                       HINST_THISDLL,
                       ML_CROSSCODEPAGE,
                       phtmlentry->ach,
                       szResURL,
                       ARRAYSIZE(szResURL));
#else
            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                       HINST_THISDLL,
                       ML_CROSSCODEPAGE,
                       phtmlentry->ach,
                       szResURL,
                       ARRAYSIZE(szResURL),
                       TEXT("shdocvw.dll"));
#endif
            if (hr)
                goto Cleanup;

            hr = CreateURLMoniker(NULL, szResURL, &pmk);
            if (hr)
                goto Cleanup;

            break;
        }
    }

    if (!pmk)
        goto Cleanup;

    // return the moniker
    hr = pmk->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;
    else
    {
        V_VT(pvarargOut) = VT_UNKNOWN;
        V_UNKNOWN(pvarargOut) = pUnk;
        V_UNKNOWN(pvarargOut)->AddRef();
    }

Cleanup:
    ATOMICRELEASE(pUnk);
    ATOMICRELEASE(pmk);

    return hr;
}

STDMETHODIMP CDocHostUIHandler::Invoke(
    DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, 
    VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT hr = S_OK;

    if (pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    ASSERT(!StrCmpCW(bstrEvent, L"unload"));

                    IWebBrowser2* pwb2;
                    hr = IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, &pwb2));
                    if (SUCCEEDED(hr))
                    {
                        IHTMLWindow2* pWindow;

                        // we shouldn't be catching this event if the dialog is not up
                        if (IsFindDialogUp(pwb2, &pWindow))
                        {
                            ASSERT(pWindow);

                            if (_pOptionsHolder)
                            {
                                BSTR bstrFindText = NULL;
                                _pOptionsHolder->get_findText(&bstrFindText);

                                ATOMICRELEASE(_pOptionsHolder);
                                PutFindText(pwb2, bstrFindText);

                                SysFreeString(bstrFindText);
                            }

                            BSTR bstrOnunload = SysAllocString(L"onunload");
                            if (bstrOnunload)
                            {
                                IHTMLWindow3 * pWin3;

                                if (SUCCEEDED(pWindow->QueryInterface(IID_IHTMLWindow3, (void**)&pWin3)))
                                {
                                    pWin3->detachEvent(bstrOnunload, (IDispatch*)this);
                                    pWin3->Release();
                                }
                                SysFreeString(bstrOnunload);
                            }
                            pWindow->Release();

                             //this is the one that should release the dialog (the pWinOut from ShowFindDialog())
                            ReleaseFindDialog(pwb2);
                        }
                        pwb2->Release();
                    }
                    SysFreeString(bstrEvent);
                }
                pObj->Release();
            }
        }
    }

    return hr;
}


//------------------------------------------------------------------
//------------------------------------------------------------------
IMoniker * GetTemplateMoniker(VARIANT varUrl)
{
    IMoniker * pMon = NULL;
    HRESULT    hr = S_OK;

    if (   V_VT(&varUrl) == VT_BSTR
        && SysStringLen(V_BSTR(&varUrl)) !=0)
    {
        // we have a template URL
        hr = CreateURLMoniker(NULL, V_BSTR(&varUrl), &pMon);
    }
    else 
    {
        TCHAR   szResURL[MAX_URL_STRING];

        hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                               HINST_THISDLL,
                               ML_CROSSCODEPAGE,
                               TEXT("preview.dlg"),
                               szResURL,
                               ARRAYSIZE(szResURL),
                               TEXT("shdocvw.dll"));
        if (hr)
            goto Cleanup;

        hr = CreateURLMoniker(NULL, szResURL, &pMon);
    }
    if (hr)
        goto Cleanup;

Cleanup:
    return pMon;
}

//============================================================================
//
//  Printing support
//
//============================================================================

static enum {
    eTemplate    = 0,
    eParentHWND  = 1,
    eHeader      = 2, // keep this in ssync with the list below!
    eFooter      = 3,
    eOutlookDoc  = 4,
    eFontScale   = 5,
    eFlags       = 6,
    eContent     = 7,
    ePrinter     = 8,
    eDevice      = 9,
    ePort        = 10,
    eSelectUrl   = 11,
    eBrowseDoc   = 12,
    eTempFiles   = 13,
};

static const SExpandoInfo s_aPrintTemplateExpandos[] =
{
    {TEXT("__IE_TemplateUrl"),         VT_BSTR},
    {TEXT("__IE_ParentHWND"),          VT_UINT},
    {TEXT("__IE_HeaderString"),        VT_BSTR},    // from here down matches the
    {TEXT("__IE_FooterString"),        VT_BSTR},    //    safeArray structure  so
    {TEXT("__IE_OutlookHeader"),       VT_UNKNOWN}, //    that we can just VariantCopy
    {TEXT("__IE_BaseLineScale"),       VT_INT},     //    in a loop to transfer the
    {TEXT("__IE_uPrintFlags"),         VT_UINT},    //    data.
    {TEXT("__IE_ContentDocumentUrl"),  VT_BSTR},    // See MSHTML: SetPrintCommandParameters()
    {TEXT("__IE_PrinterCMD_Printer"),  VT_BSTR},
    {TEXT("__IE_PrinterCMD_Device"),   VT_BSTR},
    {TEXT("__IE_PrinterCMD_Port"),     VT_BSTR},
    {TEXT("__IE_ContentSelectionUrl"), VT_BSTR},
    {TEXT("__IE_BrowseDocument"),      VT_UNKNOWN},
    {TEXT("__IE_TemporaryFiles"),      VT_ARRAY|VT_BSTR},
};

//+--------------------------------------------------------------------------------------
//
//  Helper class CPrintUnloadHandler. Used to delete tempfiles created for print[preview].
//  Note that we don't delete files when we get onUnload event - at this moment
//  files are still in use and can't be deleted. We use destructor - when template
//  is being destructed and all files are already released, template releases 
//  all sinks and here we do our cleanup.
//---------------------------------------------------------------------------------------

class CPrintUnloadHandler: public IDispatch
{
    CDocHostUIHandler *m_pUIHandler;
    VARIANT            m_vFileNameArray;    //SAFEARRAY with filenames
    LONG               m_cRef;
    IUnknown          *m_punkFreeThreadedMarshaler; 
    bool               m_fPreview;

   public:

    //IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv)
    {
        HRESULT hr = E_NOINTERFACE;

        if (ppv == NULL) return E_POINTER;
        else if(IsEqualIID(IID_IUnknown, riid) || IsEqualIID(IID_IDispatch, riid))
        {
            *ppv = this;
            AddRef();
            hr = S_OK;
        }
        else if(IsEqualIID(IID_IMarshal, riid))
            hr = m_punkFreeThreadedMarshaler->QueryInterface(riid,ppv);

        return hr;
    }
    
    STDMETHOD_(ULONG,AddRef)(THIS)
    {
        InterlockedIncrement(&m_cRef);
        return m_cRef;
    }
    
    STDMETHOD_(ULONG,Release)(THIS)
    {
        if (InterlockedDecrement(&m_cRef))
            return m_cRef;

        delete this;
        return 0;
    }

    //IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT* pctinfo) 
    { return E_NOTIMPL; };

    virtual STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) 
    { return E_NOTIMPL; };

    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId) 
    { return E_NOTIMPL; };

    virtual STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr)
    { return S_OK; }

    CPrintUnloadHandler(CDocHostUIHandler *pUIHandler, bool fPreview)
    {
        ASSERT(pUIHandler);
        //make sure our handler doesn't go anywere..
        m_pUIHandler = pUIHandler;
        pUIHandler->AddRef();
        m_cRef = 1;
        VariantInit(&m_vFileNameArray);
        //create threaded marshaler because we will be called from another thread
        //which will be created for print(preview) window
        CoCreateFreeThreadedMarshaler((IUnknown*)this, &m_punkFreeThreadedMarshaler);
        //if preview, lock the preview gate so no more then one is possible
        m_fPreview = fPreview;
        if(m_fPreview) pUIHandler->IncrementPreviewCnt();
    }

    ~CPrintUnloadHandler()
    {
        //here we delete those temp files, finally.
        DeleteFiles();
        if(m_fPreview) m_pUIHandler->DecrementPreviewCnt();
        if(m_pUIHandler) m_pUIHandler->Release();
        if(m_punkFreeThreadedMarshaler) m_punkFreeThreadedMarshaler->Release();
        VariantClear(&m_vFileNameArray);
    }

    HRESULT SetFileList(VARIANT *pvFileList)
    {
        if(pvFileList && (V_VT(pvFileList) == (VT_ARRAY | VT_BSTR)))
            return VariantCopy(&m_vFileNameArray, pvFileList);
        else 
            return VariantClear(&m_vFileNameArray);
    }

    void DeleteFiles()
    {
        int arrayMin, arrayMax;

        if(V_VT(&m_vFileNameArray) != (VT_ARRAY | VT_BSTR)) return;

        SAFEARRAY  *psa = V_ARRAY(&m_vFileNameArray);

        if(FAILED(SafeArrayGetLBound(psa, 1, (LONG*)&arrayMin))) return;

        if(FAILED(SafeArrayGetUBound(psa, 1, (LONG*)&arrayMax))) return;

        for ( int i = arrayMin; i <= arrayMax; i++ )
        {
            BSTR bstrName = NULL;
            
            if(SUCCEEDED(SafeArrayGetElement(psa, (LONG*)&i, &bstrName)) && bstrName)
            {
                TCHAR szFileName[MAX_PATH];
                SHUnicodeToTChar(bstrName, szFileName, MAX_PATH);
                DeleteFile(szFileName);
                SysFreeString(bstrName);
            }
       }
    }
};



//+--------------------------------------------------------------------------------------
//  
//  Member DoTemplatePrinting
//
//  Synopsis : this member function deals with instantiating a print template and enabling 
//      the printing of a document. It deals with the logic of whether to show or hide the
//      template;  determining whether/and-how to bring up the print/page-setup dialogs;
//      kicking off the print process rather or waiting for the template
//      UI (and thus the user) to do so.
//
//  Arguments : 
//      pvarargIn  : points to an event object with a number of expandoes that define
//                      how this print operation should progress.
//      pvarargOut : not used
//      fPreview   : flag indicating whether or not to actually show the template. This is true
//                      for preview mode, and false for normal printing
//
//---------------------------------------------------------------------------------------
HRESULT 
CDocHostUIHandler::DoTemplatePrinting(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, BOOL fPreview)
{
    int                     i;
    HRESULT                 hr = S_OK;
    VARIANT                 varDLGOut = {0};
    const int               cExpandos = ARRAYSIZE(s_aPrintTemplateExpandos);
    VARIANT                 aVariant[cExpandos] = {0};
    DISPID                  aDispid[cExpandos];
    BSTR                    bstrDlgOptions = NULL;
    DWORD                   dwDlgFlags;
    IHTMLEventObj         * pEventObj  = NULL;
    IHTMLEventObj2        * pEventObj2 = NULL;
    IMoniker              * pmk        = NULL;
    IHTMLWindow2          * pWinOut    = NULL;
    TCHAR                   achInit[512];
    TCHAR                   achBuf[32];
    RECT                    rcClient;
    HWND                    hwndOverlay = NULL;
    HWND                    hwndParent  = NULL;
    CPrintUnloadHandler   * pFinalizer = NULL;
    BOOL                    fBlock;

    // in preview mode we do not want to bring up another instance of the template
    if (fPreview && (IncrementPreviewCnt() > 1))
        goto Cleanup;

    if (SHRestricted2(REST_NoPrinting, NULL, 0))
    {
        // printing functionality disabled via IEAK restriction

        MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_RESTRICTED), MAKEINTRESOURCE(IDS_TITLE), MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);

        hr = S_FALSE;
        goto Cleanup;
    }

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // now get the expando properties that were passed in...
    //
    hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj);
    if (hr)
        goto Cleanup;
    hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2);
    if (hr)
        goto Cleanup;

    //
    // Get expando parameters from event object
    //
    hr = GetParamsFromEvent(pEventObj,
                            cExpandos,
                            aDispid,
                            aVariant,
                            s_aPrintTemplateExpandos);

    if (hr)
        goto Cleanup;

    //
    // Now that we have all the data, lets do the work of raising the template.
    //  First, Create the Moniker of the template document
    //
    pmk = GetTemplateMoniker(aVariant[eTemplate]);

    //
    // Set up the bstrDlgOptions to properly pass in the size and location 
    //
    _tcscpy(achInit, _T("resizable:yes;status:no;help:no;"));

    //
    // get the top most hwnd to use as the parenting hwnd and
    // to use to set the size of the preview window
    //

    hwndOverlay = (HWND)(void*)V_UNKNOWN(&aVariant[eParentHWND]);

    while (hwndParent = GetParent(hwndOverlay))
    {
        hwndOverlay = hwndParent;
    }

    if (GetWindowRect(hwndOverlay, &rcClient))
    {
        _tcscat(achInit, _T("dialogLeft:"));
        _ltot(rcClient.left, achBuf, 10);
        _tcscat(achInit, achBuf);
        _tcscat(achInit, _T("px;dialogTop:"));
        _ltot(rcClient.top, achBuf, 10);
        _tcscat(achInit, achBuf);
        _tcscat(achInit, _T("px;dialogWidth:"));
        _ltot(rcClient.right - rcClient.left, achBuf, 10);
        _tcscat(achInit, achBuf);
        _tcscat(achInit, _T("px;dialogHeight:"));
        _ltot(rcClient.bottom - rcClient.top, achBuf, 10);
        _tcscat(achInit, achBuf);
        _tcscat(achInit, _T("px;"));
    }
    bstrDlgOptions = SysAllocString(achInit);
    if (!bstrDlgOptions)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //Create a finalizer    
    pFinalizer = new CPrintUnloadHandler(this, fPreview);
    if(pFinalizer)
    {
       pFinalizer->SetFileList(&aVariant[eTempFiles]);
    }


    //
    // Bring up a modeless dialog and get the window pointer so that 
    // we can properly initialize the template document.
    //
    V_VT(&varDLGOut) = VT_UNKNOWN;
    V_UNKNOWN(&varDLGOut) = NULL;

    // HTMLDLG_MODELESS really means "open dialog on its own thread", which
    // we want to do for both actual printing and previewing.
    // Note that if we're previewing, we also flip on HTMLDLG_MODAL; this
    // is by design! (see comment below).
    fBlock = ((V_UINT(&aVariant[eFlags]) & PRINT_WAITFORCOMPLETION) != 0);

    dwDlgFlags = HTMLDLG_PRINT_TEMPLATE;

    // VERIFY if we are going to display
    if (fPreview)
        dwDlgFlags |= HTMLDLG_VERIFY;
    // otherwise, don't display with NOUI
    else
        dwDlgFlags |= HTMLDLG_NOUI;

    // If we are not printing synchronously, create a thread for printing.
    if (!fBlock)
        dwDlgFlags |= HTMLDLG_MODELESS;

    // Dlg should block UI on parent
    if (fPreview || fBlock)
        dwDlgFlags |= HTMLDLG_MODAL;

    ShowHTMLDialogEx((HWND)(void*)V_UNKNOWN(&aVariant[eParentHWND]), 
                     pmk, 
                     dwDlgFlags, 
                     pvarargIn,
                     bstrDlgOptions, 
                     &varDLGOut);

    if (V_UNKNOWN(&varDLGOut))
    {
        V_UNKNOWN(&varDLGOut)->QueryInterface(IID_IHTMLWindow2, (void**)&pWinOut);
    }

    if (pWinOut)
    {
        BSTR bstrOnunload = SysAllocString(L"onunload");

        //
        // can't really handle failure here, because the dialog is already up.
        // .. but we need to set up an onunload handler to properly ref release
        //
        if (bstrOnunload)
        {
            IHTMLWindow3 * pWin3;

            if (SUCCEEDED(pWinOut->QueryInterface(IID_IHTMLWindow3, (void**)&pWin3)))
            {
                VARIANT_BOOL varBool;
                hr = pWin3->attachEvent(bstrOnunload, (IDispatch*)pFinalizer, &varBool);

                // (greglett) If this fails, we're in trouble. 
                // We can either delete the temp files at the end of the function (where the ATOMICRELEASE
                //    calls the Finalizer's destructor), or we can leak the temp files.
                // We choose to delete the temp files if we were not modeless (same thread means we're now done with the files).
                // Otherwise, we'd rather leak the files than not work.
                // Known case: 109200.
                if (    hr
                    &&  !fBlock )
                {
                    //ASSERT(FALSE && "Temp files leaked while printing!");
                    pFinalizer->SetFileList(NULL);
                }
                pWin3->Release();
            }
            SysFreeString(bstrOnunload);
        }

        pWinOut->Release();
    }

Cleanup:

    DecrementPreviewCnt();

    VariantClear(&varDLGOut);

    if (bstrDlgOptions) 
        SysFreeString(bstrDlgOptions);

    if (pvarargOut) 
        VariantClear(pvarargOut);

   for(i=0; i<cExpandos; i++)
        VariantClear(aVariant + i);

    //  This will also delete temp files stored in finalizer if we did non-modeless preview (!fBlock)
    ATOMICRELEASE(pFinalizer);  

    ATOMICRELEASE(pEventObj);
    ATOMICRELEASE(pEventObj2);
    ATOMICRELEASE(pmk);

    return hr;
}

//+--------------------------------------------------------------------------------------
//
//  Member DoTemplatePageSetup
//
//  Synopsis : In template printing architecture, the page setup dialog is still raised 
//      by the DHUIHandler, but it may be overriden. In order to pull ALL print knowledge
//      out of trident it is necessary to have trident delegate the request for pagesetup
//      up to here, then we instantiate a minimal template which brings up a CTemplatePrinter
//      which delegates back to the DHUIHandler to bring up the dialog itself.
//
//      Although this is slightly convoluted, it is necessary in order to give the host
//      complete control over the pagesetup dialog (when not raised from print preview)
//      while at the same time maintaining backcompat for the registry setting that is done
//      independant of the UI handling itself
//
//---------------------------------------------------------------------------------------
HRESULT
CDocHostUIHandler::DoTemplatePageSetup(VARIANTARG *pvarargIn)
{
    HRESULT         hr            = S_OK;
    TCHAR           szResURL[MAX_URL_STRING];
    IHTMLEventObj * pEventObj     = NULL;
    IMoniker      * pMon          = NULL;
    const int       cExpandos = ARRAYSIZE(s_aPrintTemplateExpandos);
    VARIANT         aVariant[cExpandos] = {0};
    DISPID          aDispid[cExpandos];
    int i;

    if (SHRestricted2(REST_NoPrinting, NULL, 0))
    {
        // printing functionality disabled via IEAK restriction

        MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_RESTRICTED), MAKEINTRESOURCE(IDS_TITLE), MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);

        hr = S_FALSE;
        goto Cleanup;
    }

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // now get the expando properties that were passed in...
    //
    hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj);
    if (hr)
        goto Cleanup;
    
    //
    // Get expando parameters from event object
    //
    hr = GetParamsFromEvent(pEventObj,
                            cExpandos,
                            aDispid,
                            aVariant,
                            s_aPrintTemplateExpandos);

    // get the resource URL
    hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                           HINST_THISDLL,
                           ML_CROSSCODEPAGE,
                           TEXT("pstemplate.dlg"),
                           szResURL,
                           ARRAYSIZE(szResURL),
                           TEXT("shdocvw.dll"));
    if (hr)
        goto Cleanup;

    // create the moniker
    hr = CreateURLMoniker(NULL, szResURL, &pMon);
    if (hr)
        goto Cleanup;

    // raise the template
    hr = ShowHTMLDialogEx((HWND)(void*)V_UNKNOWN(&aVariant[eParentHWND]), 
                          pMon, 
                          HTMLDLG_MODAL | HTMLDLG_NOUI | HTMLDLG_PRINT_TEMPLATE, 
                          pvarargIn,
                          NULL, 
                          NULL);

Cleanup:
   for(i=0; i<cExpandos; i++)
        VariantClear(aVariant + i);

    ATOMICRELEASE(pMon);
    ATOMICRELEASE(pEventObj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dochost.h ===
#include "dhuihand.h"
#include "iface.h"
#include "dspsprt.h"
#include "privacyui.hpp"

#ifdef UNIX
#define MAIL_ACTION_SEND    1
#define MAIL_ACTION_READ    2
#endif

#define MAX_SCRIPT_ERR_CACHE_SIZE   20

class CDocObjectHost;
interface IToolbarExt;
interface IHTMLPrivateWindow;
interface IPrivacyServices;

//
// script error handling
// support for caching errors and displaying them when the script error icon
// on the status bar is clicked by the user
//

class CScriptErrorList : public CImpIDispatch,
                         public IScriptErrorList
{
public:
    CScriptErrorList();
    ~CScriptErrorList();

    BOOL    IsEmpty()
        { return _hdpa != NULL && DPA_GetPtrCount(_hdpa) == 0; }
    BOOL    IsFull()
        { return _hdpa != NULL && DPA_GetPtrCount(_hdpa) >= MAX_SCRIPT_ERR_CACHE_SIZE; }

    HRESULT AddNewErrorInfo(LONG    lLine,
                            LONG    lChar,
                            LONG    lCode,
                            BSTR    strMsg,
                            BSTR    strUrl);
    void    ClearErrorList();

    // IUnknown
    STDMETHODIMP            QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // IScriptErrorList
    STDMETHODIMP    advanceError();
    STDMETHODIMP    retreatError();
    STDMETHODIMP    canAdvanceError(BOOL * pfCanAdvance);
    STDMETHODIMP    canRetreatError(BOOL * pfCanRetreat);
    STDMETHODIMP    getErrorLine(LONG * plLine);
    STDMETHODIMP    getErrorChar(LONG * plChar);
    STDMETHODIMP    getErrorCode(LONG * plCode);
    STDMETHODIMP    getErrorMsg(BSTR * pstrMsg);
    STDMETHODIMP    getErrorUrl(BSTR * pstrUrl);
    STDMETHODIMP    getAlwaysShowLockState(BOOL * pfAlwaysShowLock);
    STDMETHODIMP    getDetailsPaneOpen(BOOL * pfDetailsPaneOpen);
    STDMETHODIMP    setDetailsPaneOpen(BOOL fDetailsPaneOpen);
    STDMETHODIMP    getPerErrorDisplay(BOOL * pfPerErrorDisplay);
    STDMETHODIMP    setPerErrorDisplay(BOOL fPerErrorDisplay);

private:
    class _CScriptErrInfo
    {
    public:
        ~_CScriptErrInfo();

        HRESULT Init(LONG lLine, LONG lChar, LONG lCode, BSTR strMsg, BSTR strUrl);

        LONG    _lLine;
        LONG    _lChar;
        LONG    _lCode;
        BSTR    _strMsg;
        BSTR    _strUrl;
    };

    HDPA    _hdpa;
    LONG    _lDispIndex;
    ULONG   _ulRefCount;
};

// The dochost and docview need to talk to eachother. We can't use the IOleCommandTarget
// because there's no direction associated with that. Create two different interfaces
// for now becuz that'll probably be useful if we ever make dochost a CoCreateable thing
// so we can share hosting code with shell32.
// (We can coalesce them into one interface later if they don't diverge.)

//
// IDocHostObject
//
EXTERN_C const GUID IID_IDocHostObject;   //67431840-C511-11CF-89A9-00A0C9054129

#undef  INTERFACE
#define INTERFACE  IDocHostObject
DECLARE_INTERFACE_(IDocHostObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocHostObject methods ***
    virtual STDMETHODIMP OnQueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext, HRESULT hres) PURE;
    virtual STDMETHODIMP OnExec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut) PURE;
    virtual STDMETHODIMP QueryStatusDown(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext) PURE;
    virtual STDMETHODIMP ExecDown(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut) PURE;
} ;


//
//  This is a proxy IOleInPlaceActiveObject class. The interface to this
// object will be passed to the IOleInPlaceUIWindow interface of the browser
// if it support it.
//
class CProxyActiveObject : public IOleInPlaceActiveObject
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IOleInPlaceActiveObject ***
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    STDMETHODIMP OnFrameWindowActivate(
        BOOL fActivate);
    STDMETHODIMP OnDocWindowActivate(
        BOOL fActivate);
    STDMETHODIMP ResizeBorder(
        LPCRECT prcBorder,
        IOleInPlaceUIWindow *pUIWindow,
        BOOL fFrameWindow);
    STDMETHODIMP EnableModeless(
        BOOL fEnable);

    void Initialize(CDocObjectHost* pdoh) { _pdoh = pdoh; }

    IOleInPlaceActiveObject *GetObject() { return _piact;}
    HWND GetHwnd() {return _hwnd;}
    void SetActiveObject(IOleInPlaceActiveObject * );
protected:


    CDocObjectHost* _pdoh;
    IOleInPlaceActiveObject*    _piact; // non-NULL while UI-active
    HWND _hwnd;
};


//  This is a proxy IOleInPlaceFrame class. The interfaces to this object
// will be passed to in-place active object.
//
class CDocObjectFrame : public IOleInPlaceFrame
                      , public IOleCommandTarget
                      , public IServiceProvider
                      , public IInternetSecurityMgrSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceUIWindow (also IOleWindow)
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(
        IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleInPlaceFrame (also IOleInPlaceUIWindow)
    STDMETHODIMP InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus(HMENU hmenuShared);
    STDMETHODIMP SetStatusText(LPCOLESTR pszStatusText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IServiceProvider (must be QI'able from IOleClientSite)
    STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

    // *** IInternetSecurityMgrSite methods ***
    // STDMETHODIMP GetWindow(HWND * lphwnd) { return IOleWindow::GetWindow(lphwnd); }
    // STDMETHODIMP EnableModeless(BOOL fEnable) { return IOleInPlaceFrame::EnableModeless(fEnable); }

public:
    void Initialize(CDocObjectHost* pdoh) { _pdoh = pdoh; }
protected:
    CDocObjectHost* _pdoh;
};

//
// LATER: Move it to a private, but shared header later.
//
//   BROWSERFLAG_OPENCOPY               - make a copy of object (Excel)
//   BROWSERFLAG_OPENVERB               - use OLEIVERB_OPEN instead of PRIMARY
//   BROWSERFLAG_SETHOSTNAME            - set HostName
//   BROWSERFLAG_DONTINPLACE            - Never in-place activate
//   BROWSERFLAG_CANOPENFILEMULTIPETIMES- 
//   BROWSERFLAG_DONTUIDEACTIVATE       - Never UI-deactivate 
//   BROWSERFLAG_NEVERERASEBKGND        - Never erase background (Trident)
//   BROWSERFLAG_PRINTPROMPTUI          - Don't pass DONPROMPTUI for PRINT (PPT)
//   BROWSERFLAG_SUPPORTTOP             - Handles Navigate("#top")
//   BROWSERFLAG_INITNEWTOKEEP          - IPS::InitNew to keep it running
//   BROWSERFLAG_DONTAUTOCLOSE          - Don't auto close on first navigate w/ no OLE object
//   BROWSERFLAG_REPLACE                - Don't use hard-coded flags
//   BROWSERFLAG_DONTCACHESERVER        - Don't cache the server.
//   BROWSERFLAG_ENABLETOOLSBUTTON      - Ignore when QueryStatus doesn't set enabled flag (Visio)
//   BROWSERFLAG_SAVEASWHENCLOSING      - Show the Save As dialog instead of attempting to save (Visio)  
//
#define BROWSERFLAG_OPENCOPY                0x00000001
#define BROWSERFLAG_OPENVERB                0x00000002
#define BROWSERFLAG_SETHOSTNAME             0x00000004
#define BROWSERFLAG_DONTINPLACE             0x00000008
#define BROWSERFLAG_CANOPENFILEMULTIPETIMES 0x00000010
#define BROWSERFLAG_DONTUIDEACTIVATE        0x00000020
#define BROWSERFLAG_NEVERERASEBKGND         0x00000040
#define BROWSERFLAG_PRINTPROMPTUI           0x00000080
#define BROWSERFLAG_SUPPORTTOP              0x00000100
#define BROWSERFLAG_INITNEWTOKEEP           0x00000200
#define BROWSERFLAG_DONTAUTOCLOSE           0x00000400
#define BROWSERFLAG_DONTDEACTIVATEMSOVIEW   0x00000800
#define BROWSERFLAG_MSHTML                  0x40000000
#define BROWSERFLAG_REPLACE                 0x80000000 
#define BROWSERFLAG_DONTCACHESERVER         0x00001000
#define BROWSERFLAG_ENABLETOOLSBTN          0x00002000
#define BROWSERFLAG_SAVEASWHENCLOSING       0x00004000

#ifdef FEATURE_PICS
class CPicsRootDownload;
#endif

// CMenuList:  a small class that tracks whether a given hmenu belongs
//             to the frame or the object, so the messages can be
//             dispatched correctly.
class CMenuList
{
public:
    CMenuList(void);
    ~CMenuList(void);

    void Set(HMENU hmenuShared, HMENU hmenuFrame);
    void AddMenu(HMENU hmenu);
    void RemoveMenu(HMENU hmenu);
    BOOL IsObjectMenu(HMENU hmenu);

#ifdef DEBUG
    void Dump(LPCTSTR pszMsg);
#endif

private:
    HDSA    _hdsa;
};

#define ERRORPAGE_DNS               1
#define ERRORPAGE_SYNTAX            2
#define ERRORPAGE_NAVCANCEL         3
#define ERRORPAGE_OFFCANCEL         4
#define ERRORPAGE_CHANNELNOTINCACHE	5

// Array of http error codes and file names.
//
struct ErrorUrls
{
    DWORD   dwError;
    LPCTSTR pszUrl;
};

class CDocObjectHost :
                  /* public CDocHostUIHandler */
                     public IDocHostUIHandler2
                   , public IDocHostShowUI
    /* Group 2 */  , public IOleClientSite, public IOleDocumentSite
                   , public IOleCommandTarget
    /* Group 3 */  , public IOleInPlaceSiteEx
    /* VBE */      , public IServiceProvider
                   , public IDocHostObject

    /* palette */  , public IViewObject, public IAdviseSink
                   , public IDispatch // ambient properties (from container/iedisp)
                   , public IPropertyNotifySink // for READYSTATE
                   , public IOleControlSite // forward to container/iedisp
                   , protected CImpWndProc
{
  /*typedef CDocHostUIHandler super;*/
    friend class CDocObjectView;
    friend CDocObjectFrame;
    friend CProxyActiveObject;
    friend void CDocObjectHost_GetCurrentPage(LPARAM that, LPTSTR szBuf, UINT cchMax);
public:
    CDocObjectHost(BOOL fWindowOpen = FALSE);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);


    // IOleClientSite
    STDMETHODIMP SaveObject(void);
    STDMETHODIMP GetMoniker(DWORD, DWORD, IMoniker **);
    STDMETHODIMP GetContainer(IOleContainer **);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    // IServiceProvider (must be QI'able from IOleClientSite)
    STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

    // IViewObject
    STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);
    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);
    STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    STDMETHODIMP Unfreeze(DWORD);
    STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // IAdviseSink
    virtual STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    virtual STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    virtual STDMETHODIMP_(void) OnRename(IMoniker *);
    virtual STDMETHODIMP_(void) OnSave();
    virtual STDMETHODIMP_(void) OnClose();

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceSite (also IOleWindow)
    STDMETHODIMP CanInPlaceActivate( void);
    STDMETHODIMP OnInPlaceActivate( void);
    STDMETHODIMP OnUIActivate( void);
    STDMETHODIMP GetWindowContext(
        IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc,
        LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll(SIZE scrollExtant);
    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate( void);
    STDMETHODIMP DiscardUndoState( void);
    STDMETHODIMP DeactivateAndUndo( void);
    STDMETHODIMP OnPosRectChange(LPCRECT lprcPosRect);

    // IOleInPlaceSiteEx
    STDMETHODIMP OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags);
    STDMETHODIMP OnInPlaceDeactivateEx(BOOL fNoRedraw);
    STDMETHODIMP RequestUIActivate( void);

    // IOleDocumentSite
    STDMETHODIMP ActivateMe(IOleDocumentView *pviewToActivate);

    // IDocHostUIHandler
    STDMETHODIMP ShowContextMenu( 
        DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
    STDMETHODIMP ShowUI( 
        DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    STDMETHODIMP HideUI(void);
    STDMETHODIMP UpdateUI(void);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
    STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
    STDMETHODIMP ResizeBorder( 
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    STDMETHODIMP TranslateAccelerator( 
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    STDMETHODIMP GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    STDMETHODIMP GetDropTarget( 
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    STDMETHODIMP GetExternal(IDispatch **ppDisp);
    STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    STDMETHODIMP FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // IDocHostUIHandler2
    STDMETHODIMP GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw);

    // IDocHostShowUI
    STDMETHODIMP ShowMessage(HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption,
            DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT *plResult);
    STDMETHODIMP ShowHelp(HWND hwnd, LPOLESTR pszHelpFile, UINT uCommand, DWORD dwData,
            POINT ptMouse, IDispatch *pDispatchObjectHit);

    // IOleInPlaceFrame equivalent (non-virtual)
    HRESULT _InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    HRESULT _SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    HRESULT _RemoveMenus(HMENU hmenuShared);
    HRESULT _SetStatusText(LPCOLESTR pszStatusText);
    HRESULT _EnableModeless(BOOL fEnable);
    HRESULT _TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // IOleCommandTarget equivalent (virtual / both direction)
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDocHostObject methods ***
    STDMETHODIMP OnQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext, HRESULT hres);
    STDMETHODIMP OnExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    STDMETHODIMP QueryStatusDown(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP ExecDown(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDispatch methods ***
    STDMETHOD(GetTypeInfoCount) (unsigned int *pctinfo)
        { return E_NOTIMPL; };
    STDMETHOD(GetTypeInfo) (unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, unsigned int cNames, LCID lcid, DISPID * rgdispid)
        { return E_NOTIMPL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // *** IPropertyNotifySink methods ***
    STDMETHODIMP OnChanged(DISPID dispid);
    STDMETHODIMP OnRequestEdit(DISPID dispid);

    // *** IOleControlSite ***
    STDMETHODIMP OnControlInfoChanged();
    STDMETHODIMP LockInPlaceActive(BOOL fLock)
        { return E_NOTIMPL; };
    STDMETHODIMP GetExtendedControl(IDispatch **ppDisp)
        { *ppDisp = NULL; return E_NOTIMPL; };
    STDMETHODIMP TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
        { return E_NOTIMPL; };
    STDMETHODIMP TranslateAccelerator(MSG *pMsg,DWORD grfModifiers);

    STDMETHODIMP OnFocus(BOOL fGotFocus)
        { return E_NOTIMPL; };
    STDMETHODIMP ShowPropertyFrame(void)
        { return E_NOTIMPL; };



    HRESULT SetTarget(IMoniker* pmk, UINT uiCP, LPCTSTR pszLocation, LPITEMIDLIST pidlKey, IShellView* psvPrev, BOOL fFileProtocol);
    HRESULT UIActivate(UINT uState, BOOL fPrevViewIsDocView);
    
    //Helper function for initing History related privates
    IUnknown *get_punkSFHistory();
    BOOL InitHostWindow(IShellView* psv, IShellBrowser* psb, LPRECT prcView);
    void DestroyHostWindow();
    BOOL _OperationIsHyperlink();
    void _ChainBSC();
    HRESULT TranslateHostAccelerators(LPMSG lpmsg);
    HRESULT AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    BOOL _IsMenuShared(HMENU hmenu);
    void _SetPriorityStatusText(LPCOLESTR pszPriorityStatusText);

    BOOL DocCanHandleNavigation() const
        { return (_fPrevDocHost && _fDocCanNavigate); }

    void OnInitialUpdate();
    void ResetRefreshUrl();
    void HideBrowser() const;

protected:
    virtual ~CDocObjectHost();

    // Private method
    void _InitOleObject();
    void _ResetOwners();
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnMenuSelect(UINT id, UINT mf, HMENU hmenu);
    void _OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu);
    void _OnCommand(UINT wNotify, UINT id, HWND hwndControl);
    void _OnNotify(LPNMHDR lpnm);
    void _OnSave(void);
    void _OnBound(HRESULT hres);
    static BOOL_PTR CALLBACK s_RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnOpen(void);
    void _OnClose() const;
    BOOL _HideBrowserBar() const;
    void _OnImportExport(HWND hwnd);
    HRESULT _PrepFileOpenAddrBand(IAddressEditBox ** ppaeb, IWinEventHandler ** ppweh, IBandSite ** ppbs);
    void _OnPaint(HDC hdc);
    void _OnSetFocus(void);
    void _GetClipRect(RECT* prc);
    void _RegisterWindowClass(void);
    void _PlaceProgressBar(BOOL fForcedLayout=FALSE);
    void _OnSetProgressPos(DWORD dwPos, DWORD state);
    void _OnSetProgressMax(DWORD dwRange);
    HRESULT _OnContentDisposition();
    void _OnSetStatusText(VARIANTARG *pvarIn);
    void _Navigate();
#ifndef UNIX
    void _NavigateFolder(BSTR bstrUrl);
#endif // UNIX

    // IE Media Bar functions
    BOOL _DelegateToMediaBar(IBindCtx * pbc, LPCWSTR pwzMimeType);
    void _ForceCreateMediaBar();
    static INT_PTR CALLBACK s_MimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


    void _CancelPendingNavigation(BOOL fDownloadAsync,
                                  BOOL fSyncReally = FALSE,
                                  BOOL fDontShowNavCancelPage = FALSE,
                                  BOOL fForceClose = FALSE);

    void _DoAsyncNavigation(LPCTSTR pwzURL);
    IOleInPlaceSite* _GetParentSite(void);
    HRESULT _GetCurrentPage(LPTSTR szBuf, UINT cchMax, BOOL fURL=FALSE);
    HRESULT _GetCurrentPageW(LPOLESTR * ppszDisplayName, BOOL fURL=FALSE);
    BOOL _IsDirty(IPersistFile** pppf);
    HRESULT _OnSaveAs(void);
    void _MergeToolbarSB();
    void _OnHelpGoto(UINT idRes);
    void _Navigate(LPCWSTR pwszURL);
    HRESULT _OnMaySaveChanges(void);
    void _OnCodePageChange(const VARIANTARG* pvarargIn);
    void _MappedBrowserExec(DWORD nCmdID, DWORD nCmdexecopt);
#ifdef DEBUG
    void _DumpMenus(LPCTSTR pszMsg, BOOL bBreak);
#endif

    HRESULT _BindSync(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev);
    void    _PostBindAppHack(void);
    void    _AppHackForExcel95(void);
    HRESULT _GetOfflineSilent(BOOL *pbIsOffline, BOOL *pbIsSilent);
    HRESULT _StartAsyncBinding(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev);
    HRESULT _BindWithRetry(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev);
    void    _UnBind(void);
    void    _ReleaseOleObject(BOOL fIfInited = TRUE);
    void    _ReleasePendingObject(BOOL fIfInited = TRUE);
    HRESULT _GetUrlVariant(VARIANT *pvarOut);
    HRESULT _CreatePendingDocObject(BOOL fMustInit, BOOL fWindowOpen = FALSE);
    void    _ActivateOleObject(void);
    HRESULT _CreateMsoView(void);
    void    _CloseMsoView(void);
    HRESULT _EnsureActivateMsoView(void);
    void    _ShowMsoView(void);
    void    _HideOfficeToolbars(void);
    HRESULT _ActivateMsoView(void);
    HRESULT _DoVerbHelper(BOOL fOC);
    void    _InitToolbarButtons(void);
    void    _UIDeactivateMsoView(void);
    BOOL    _BuildClassMapping(void);
    HRESULT _RegisterMediaTypeClass(IBindCtx* pbc);
    void    _IPDeactivateMsoView(IOleDocumentView* pmsov);
    void    _CompleteHelpMenuMerge(HMENU hmenu);
    BOOL    _ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _ForwardObjectMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _MayHaveVirus(REFCLSID rclsid);
    HRESULT _ForwardSetSecureLock(int lock);
    void    _ResetStatusBar();

    BOOL _ToolsButtonAvailable();
    BYTE _DefToolsButtonState(DWORD dwRest);

    BYTE _DefFontsButtonState(DWORD dwRest);

    DWORD _DiscussionsButtonCmdf();
    BOOL _DiscussionsButtonAvailable();
    BYTE _DefDiscussionsButtonState(DWORD dwRest);

    BOOL _MailButtonAvailable();
    BYTE _DefMailButtonState(DWORD dwRest);

    BOOL _EditButtonAvailable();
    BYTE _DefEditButtonState(DWORD dwRest);

    void _MarkDefaultButtons(PTBBUTTON tbStd);
    const GUID* _GetButtonCommandGroup();
    void _AddButtons(BOOL fForceReload);

    HRESULT _OnChangedReadyState();
    void    _OnReadyState(long lVal, BOOL fUpdateHistory = TRUE);
    BOOL    _SetUpTransitionCapability(BOOL fWindowOpen = FALSE);
    BOOL    _RemoveTransitionCapability();
    void    _UpdateHistoryAndIntSiteDB(LPCWSTR pszTitle);
    HRESULT _CoCreateHTMLDocument(REFIID riid, LPVOID* ppvOut);

    void    _RemoveFrameSubMenus(void);
    HRESULT _DestroyBrowserMenu(void);
    HRESULT _CreateBrowserMenu(LPOLEMENUGROUPWIDTHS pmw);
    void    _SetStatusText(LPCSTR pszText);
    void    _OnSetTitle(VARIANTARG *pvTitle);
    DWORD   _GetAppHack(void);
    void    _CleanupProgress(void);

    // Trident Native Frames Support
    //

    VOID    ClearScriptError();
    
    HRESULT _HandleFailedNavigation(VARIANTARG * varargIn, VARIANTARG * varargOut = NULL );

    HRESULT _DisplayHttpErrorPage(IHTMLWindow2 * pCurrentWindow,
                                  BSTR           bstrUrl,
                                  DWORD          dwError,
                                  BOOL           fAddrBarNav,
                                  BOOL           fRefresh = FALSE );

    HRESULT _DoAutoSearch(VARIANTARG   * pvarargIn,
                          long           lStartIdx,
                          DWORD          dwStatusCode,
                          BOOL           fAddMRU,
                          BOOL         * pfShouldDisplayError);

    HRESULT _HandleDocHostCmds(DWORD nCmdID,
                               DWORD nCmdexecopt,
                               VARIANTARG * pvarargIn,
                               VARIANTARG * pvarargOut,
                               BOOL       * pfHandled);

    HRESULT _HandleDocHostCmdPriv(DWORD nCmdID,
                                  DWORD nCmdexecopt,
                                  VARIANTARG * pvarargIn,
                                  VARIANTARG * pvarargOut,
                                  BOOL       * pfHandled);

    HRESULT _NavigateDocument(BSTR bstrUrl, BSTR bstrLocation);
    void    _GetShortCutPath(BSTR * bstrShortCutPath);
    void    _GetDocNavFlags(DWORD * pdwDocNavFlags);

    BOOL    _HandleShdocvwCmds(DWORD        nCmdID,
                               DWORD        nCmdexecopt,
                               VARIANTARG * pvarargIn,
                               VARIANTARG * pvarargOut);

    void _StartPicsForWindow(VARIANTARG * pvarargIn, VARIANTARG * pvarargOut);
    void _CancelPicsForWindow(VARIANTARG * pvarargIn);
    void _IsPicsEnabled(VARIANTARG * pvarIsPicsEnabled);

    HRESULT _UpdateState(LPITEMIDLIST pidl, BOOL fIsErrorUrl);
    void    _Init();

    BOOL _IsInBrowserBand() const;

    DEBUG_CODE(void _TraceMonikerDbg(IMoniker * pmk, TCHAR * pszCaller) const;)

    HRESULT _LoadDocument();

    void _FireNavigateErrorHelper(IHTMLWindow2 * pHTMLWindow2,
                                  DWORD          dwStatusCode,
                                  BOOL         * pfCancelAutoSearch,
                                  BSTR           bstrPendingURL = NULL);

    static LRESULT s_IconsWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static UINT _MapCommandID(UINT id, BOOL fToMsoCmd);
    inline static UINT _MapToMso(UINT id) { return _MapCommandID(id, TRUE); }
    inline static UINT _MapFromMso(UINT idMso) { return _MapCommandID(idMso, FALSE); }

    inline IOleInPlaceActiveObject *_ActiveObject() { return _xao.GetObject(); }
    inline HWND _ActiveHwnd() { return _xao.GetHwnd(); }

    inline IOleObject * GetOleObject() { return _pole; }


    // internal class objects
    CDocObjectFrame         _dof;
    CProxyActiveObject      _xao;
    CDocHostUIHandler       _dhUIHandler;

    IToolbarExt *           _pBrowsExt;
    int                     _iString;       // start index for toolbar button strings

    UINT                    _cRef;

    // parent references
    IShellView * _psv;
    IOleCommandTarget*      _pmsoctView;
    IDocViewSite*           _pdvs;

    //
    IShellBrowser*          _psb;
    IOleCommandTarget*      _pmsoctBrowser;
    IBrowserService*        _pwb;
    
    IServiceProvider*       _psp;
    IOleInPlaceUIWindow*    _pipu; // Optional interface from IShellBrowser
    IExpDispSupport *       _peds;
    IExpDispSupportOC *     _pedsHelper;

    // for pre-merged menu
    IOleCommandTarget*      _pcmdMergedMenu;

    // Pointer to the WebBrowserOC's DocHostUIHandler, if any.
    IDocHostUIHandler         * _pWebOCUIHandler;
    IDocHostUIHandler2        * _pWebOCUIHandler2;

    // Pointer to the WebBrowserOC's ShowUI handler, if any.
    IDocHostShowUI            * _pWebOCShowUI;

    // Pointer to the WebBrowserOC's InPlaceSiteEx, if any.
    IOleInPlaceSiteEx         * _pWebOCInPlaceSiteEx;

    // we created...
    UINT        _uState;
    HWND        _hwndProgress;
    HWND        _hwndIcons;
    HWND        _hwndTooltip;
    WNDPROC     _pfnStaticWndProc;

    HACCEL      _hacc;

    // Menus: the final menu bar the user sees (_hmenuCur, _hmenuSet) is the product 
    //        of merging the object's menu with the browser's menu.  The browser's menu
    //        (_hmenuBrowser) is the result of combining the browser's
    //        menu (owned by mshtml, obtained via IShellBrowser) with the 
    //        frame's menu (_hmenuFrame).

    HMENU       _hmenuFrame;    // menu to be merged when we have focus
    HMENU       _hmenuBrowser;  // Menu from IShellBrowser
    HMENU       _hmenuSet;      // set by ::SetMenu
    HMENU       _hmenuCur;      // currently set menu
    HMENU       _hmenuMergedHelp;   // Merged help menu
    HMENU       _hmenuObjHelp;  // Hosted object's help menu

    CMenuList   _menulist;      // Menu list for dispatching

    LPCTSTR      _pszLocation;
    UINT        _uiCP;

    LPOLESTR    _pwszRefreshUrl;  // Url to refresh when intrenal error page is dispalyed.

    BOOL        _fNeedToActivate:1;     //  this is set when we do a LoadHistory on the _pole
    BOOL        _fClientSiteSet:1;
    BOOL        _fDontInplaceActivate:1;
    BOOL        _fDrawBackground:1;
    BOOL        _fCanceledByBrowser:1;
    BOOL        _fForwardMenu:1;            // TRUE: forward the menu message
    BOOL        _fHaveParentSite:1;     // pretty much "we're in a frame"
    BOOL        _fhasLastModified;    // object has Last-Modified header
    BOOL        _fIPDeactivatingView:1;
    BOOL        _fCantSaveBack:1;       // We can't call IPSFile::Save(NULL)
    BOOL        _fHaveAppHack:1;
    BOOL        _fReadystateInteractiveProcessed:1;
    BOOL        _fFileProtocol:1;
    BOOL        _fConfirmed:1;            // _MayHaveVirus already confirmed
    BOOL        _fCycleFocus:1;           // 1=got callback to do CycleFocus
    BOOL        _fCreatingPending:1;      // we are creating _punkPending
    BOOL        _fAbortCreatePending:1;   // abort create due to reentrant free
    BOOL        _fCalledMayOpenSafeDlg:1; // Already called MayOpenSafeOpenDialog. 
    BOOL        _fPendingNeedsInit:1;     // does _punkPending need to be inited?
    BOOL        _fPendingWasInited:1;     // _punkPending was inited
    BOOL        _fSetSecureLock:1;        // indicates we should update the browser with fSecureLock
    BOOL        _fProgressTimer:1;        //  progress timer is active
    BOOL        _fProgressTimerFull:1;    //  wait a quarter sec with a full progress bar
    BOOL        _fIsHistoricalObject:1;   //  this item was retrieved from GetHistoryObject() and successfully took LoadHistory()
    BOOL        _fSyncBindToObject:1;     //  to detect when the call backs are on the sync thread
    BOOL        _fUIActivatingView:1;     // Indicates if we're UIActivating or Showing our DocObj view.
    BOOL        _fShowProgressCtl:1;      // Show the progress control on the status bar.
    BOOL        _fWebOC:1;                // are we a web oc?
#ifdef DEBUG
    BOOL        _fFriendlyError:1;        // So we know we're going to an error page.
#endif

    BOOL        _fDocCanNavigate:1;       // TRUE indicates that the hosted document can navigate itself.
    BOOL        _fPrevDocHost:1;          // TRUE if there was a previous doc object host.
    BOOL        _fClosing:1;              // The browser is being closed.
    BOOL        _fRefresh:1;              // the browser is being refreshed (ie we are handling refresh).
    BOOL        _fDelegatedNavigation:1;  // TRUE if the navigation was delegated from the document.
    BOOL        _fErrorPage : 1;        // True if we're navigating to some sort of error page.
    BOOL        _fWindowOpen:1;
    
    IHTMLWindow2 * _pHTMLWindow;        // Navigation interface of the hosted document.    
    LPITEMIDLIST   _pidl;               // Current pidl.
    
    HRESULT     _hrOnStopBinding;       // set in onstopbinding when _fSyncBindToObject
    DWORD       _dwPropNotifyCookie;

    DWORD       _dwAppHack;
    DWORD       _dwSecurityStatus;      // Return from QueryOptions(INTERNET_OPTION_SECURITY_FLAGS)
    int         _eSecureLock;           // one of the SECURELOCK_* values

    HINSTANCE   _hinstInetCpl;          // Inetcpl

    TBBUTTON*   _ptbStd;                // buffer for button array (used for ETCMDID_GETBUTTONS)
    int         _nNumButtons;

    VARIANT     _varUserEnteredUrl;     // The URL entered by the user in the address bar.
                                        // Needed for AutoSearch when initiated by Trident.
    BOOL        _fDontInPlaceNavigate() { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_DONTINPLACE); }
    BOOL        _fCallSetHostName()     { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_SETHOSTNAME); }
    BOOL        _fUseOpenVerb()         { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_OPENVERB); }
    BOOL        _fAppHackForExcel()     { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_OPENCOPY); }

    UINT        posOfflineIcon;

    enum {
        PROGRESS_RESET,
        PROGRESS_FINDING,
        PROGRESS_TICK,
        PROGRESS_SENDING,
        PROGRESS_RECEIVING,
        PROGRESS_FULL
    };

#define PROGRESS_REBASE     100
#define PROGRESS_FINDMAX    30 * PROGRESS_REBASE    //  maximum amount of status on find
#define PROGRESS_SENDMAX    40 * PROGRESS_REBASE    //  maximum amount of status on send
#define PROGRESS_TOTALMAX   100 * PROGRESS_REBASE   //  the total size of the progress bar in find/send
#define PROGRESS_INCREMENT  50          //  default progress increment

#define ADJUSTPROGRESSMAX(dw)   (PROGRESS_REBASE * (dw) )
#define ADJUSTPROGRESSPOS(dw)   ((dw) * PROGRESS_REBASE + ((_dwProgressBase * _dwProgressMax) / PROGRESS_REBASE))

    DWORD       _dwProgressMax; // max progress range for progress bar
    DWORD       _dwProgressPos;
    DWORD       _dwProgressInc;
    DWORD       _dwProgressTicks;
    DWORD       _dwProgressMod;
    DWORD       _dwProgressBase;

#define IDTIMER_PROGRESS        88
#define IDTIMER_PROGRESSFULL    89


#ifdef HLINK_EXTRA
    // Navigation
    IHlinkBrowseContext* _pihlbc;
#endif // HLINK_EXTRA

    // Data associated
    IMoniker*   _pmkCur;
    IBindCtx*   _pbcCur;
    IOleObject* _pole;
    IViewObject* _pvo;
    IStorage*   _pstg;
    IUnknown*   _punkPending;

    IHlinkFrame *_phf;
    IOleCommandTarget*_pocthf;
    IUnknown *_punkSFHistory;

    // Advisory connection
    IAdviseSink *_padvise;
    DWORD _advise_aspect;
    DWORD _advise_advf;

    // View associated (only used when the object is active)
    IOleDocumentView*           _pmsov;
    IOleCommandTarget*          _pmsot;
    IOleControl*                _pmsoc;
    IHlinkSource*               _phls;
    BORDERWIDTHS _bwTools;
    RECT        _rcView;

    int _iZoom;
    int _iZoomMin;
    int _iZoomMax;
    class CDOHBindStatusCallback : public IBindStatusCallback
            , public IAuthenticate
            , public IServiceProvider
            , public IHttpNegotiate
            , public IHttpSecurity

    {
        friend CDocObjectHost;
    protected:
        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        // *** IAuthenticate ***
        STDMETHODIMP Authenticate(
            HWND *phwnd,
            LPWSTR *pszUsername,
            LPWSTR *pszPassword);

        // *** IServiceProvider ***
        STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

        // *** IBindStatusCallback ***
        STDMETHODIMP OnStartBinding(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

        STDMETHODIMP GetPriority(
            /* [out] */ LONG *pnPriority);

        STDMETHODIMP OnLowResource(
            /* [in] */ DWORD reserved);

        STDMETHODIMP OnProgress(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

        STDMETHODIMP OnStopBinding(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

        STDMETHODIMP GetBindInfo(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

        STDMETHODIMP OnDataAvailable(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

        STDMETHODIMP OnObjectAvailable(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);

        /* *** IHttpNegotiate ***  */
        STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                DWORD dwReserved, LPWSTR *pszAdditionalHeaders);

        STDMETHODIMP OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
                            LPCWSTR szRequestHeaders,
                            LPWSTR *pszAdditionalRequestHeaders);

        /* *** IHttpSecurity ***  */
        STDMETHODIMP  GetWindow(REFGUID rguidReason, HWND* phwnd);

        STDMETHODIMP OnSecurityProblem(DWORD dwProblem);

    protected:
        ~CDOHBindStatusCallback();
        IBinding*       _pib;
        IBindCtx*       _pbc;
        IBindStatusCallback* _pbscChained;
        IHttpNegotiate* _pnegotiateChained;
        IShellView*     _psvPrev;
        ULONG           _bindst;
        HGLOBAL _hszPostData;
        int _cbPostData;
        LPSTR _pszHeaders;
        LPTSTR _pszRedirectedURL;
        LPTSTR _pszCacheFileName;
        DWORD           _dwBindVerb;            // the verb requested
        DWORD           _dwBindf;               // last set of bind flags returned as a response to the GetBindInfo call...
        DWORD           _cbContentLength;
        BOOL            _fSelfAssociated:1;     //
        BOOL            _fBinding:1;        // downloading
        BOOL            _bFrameIsOffline:1;
        BOOL            _bFrameIsSilent:1;
        BOOL            _fDocWriteAbort:1;      // abort to use _punkPending
        BOOL            _fBoundToMSHTML:1;      // if bound to TRIDENT
        BOOL            _fBoundToNoOleObject:1; // the object does not support IOleObject
        BOOL            _fAborted:1;            // TRUE when AbortBinding called when IDCANCEL for BINDSTATUS_CONTENTDISPOSITIONATTACH

        //Privacy data
        LPTSTR          _pszPolicyRefURL;
        LPTSTR          _pszP3PHeader;
        DWORD           _dwPrivacyFlags;

        CPrivacyQueue   _privacyQueue;
        
        void _Redirect(LPCWSTR pwzNew);
        HRESULT _HandleSelfAssociate(void);
        void _UpdateSSLIcon(void);
        BOOL _DisplayFriendlyHttpErrors(void);
        void _HandleHttpErrors(DWORD dwError, DWORD cbContentLength, CDocObjectHost* pdoh);
        
        HRESULT _HandleFailedNavigationSearch (LPBOOL           pfShouldDisplayError,
                                               DWORD            dwStatusCode,
                                               CDocObjectHost * pdoh,
                                               HRESULT          hrDisplay,
                                               TCHAR          * szURL,
                                               LPCWSTR          szError,
                                               IBinding       * pib,
                                               BOOL             fAddMRU = TRUE,
                                               BOOL             fFromTrident = FALSE);
                                               
        void _CheckForCodePageAndShortcut(void);
        void _DontAddToMRU(CDocObjectHost* pdoh);
        void _UpdateMRU(CDocObjectHost* pdoh, LPCWSTR pszUrl);
        HRESULT _SetSearchInfo(CDocObjectHost *pdoh, DWORD dwIndex, BOOL fAllowSearch, BOOL fContinueSearch, BOOL fSentToEngine);
        void ResetPrivacyInfo();
        HRESULT BuildRecord();
        HRESULT AddToPrivacyQueue(LPTSTR * ppszUrl, LPTSTR * ppszPolicyRef, LPTSTR * ppszP3PHeader, DWORD dwFlags);

    public:
        void AbortBinding(void);
        CDOHBindStatusCallback() : _pib(NULL) {}
        void _RegisterObjectParam(IBindCtx* pbc);
        void _RevokeObjectParam(IBindCtx* pbc);
        void _NavigateToErrorPage(DWORD dwError, CDocObjectHost* pdoh, BOOL fInPlace);
    };

    friend class CDOHBindStatusCallback;
    CDOHBindStatusCallback _bsc;

#ifdef FEATURE_PICS
#define PICS_WAIT_FOR_ASYNC 0x01        /* waiting for async rating query */
#define PICS_WAIT_FOR_INDOC 0x02        /* waiting for in-document rating */
#define PICS_WAIT_FOR_ROOT  0x04        /* waiting for root document */
#define PICS_WAIT_FOR_END   0x08        /* waiting for end of document */

#define PICS_MULTIPLE_FLAGS PICS_WAIT_FOR_INDOC     /* sources which can produce multiple results */

#define PICS_LABEL_FROM_HEADER 0        /* label was obtained from the http header */
#define PICS_LABEL_FROM_PAGE   1        /* label was obtained from the page itself */

    /*
     * _fPicsBlockLate - TRUE if we're using a DocObject which we have
     *                   to allow to download completely because we may
     *                   need to get ratings out of it.  FALSE if we
     *                   just want to block it as early as possible
     *                   (usually at OnProgress(CLASSIDAVAILABLE)).
     * _fSetTarget - bug 29364: this indicates we are calling _StartAsyncBinding
     *               and we shouldn't do any activation, even if we're told to.
     *               Has URLMON changed how it binds to objects? (GregJ claims
     *               that URLMON never called OnObjectAvailable synchronously
     *               with the _StartAsyncBinding call...) It also seems that
     *               both Trident and this PICS stuff use the
     *               message SHDVID_ACTIVATEMENOW which might confuse
     *               the delayed activation stuff CDTurner put in... [mikesh]
     */

    BOOL        _fSetTarget:1;
    BOOL        _fPicsBlockLate:1;

    class CPicsProcessor : public IOleCommandTarget
    {
    // Everything public because the _bsc needs to get at base proc
    public:
        friend class CDocObjectHost;

        CPicsProcessor();
        ~CPicsProcessor() { _ReInit(); }
        void _ReInit();

        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        // IOleCommandTarget equivalent (virtual / both direction)
        STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
            ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
        STDMETHODIMP Exec(const GUID *pguidCmdGroup,
            DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

        /* PICS state flags:
         *
         * _fPicsAccessAllowed - Whether the most significant rating we've
         *                       found so far (that actually applies to the
         *                       thing we're browsing to) would allow access.
         *                       Once all rating sources report in, this flag
         *                       indicates whether the user can see the content.
         */
        BYTE            _fPicsAccessAllowed:1;
        BYTE            _fInDialog:1;
        BYTE            _fTerminated:1;

        /* The following flags are a separate bitfield so I can easily test
         * "if (!_fbPicsWaitFlags)" to see if I'm done waiting.
         *
         * IMPORTANT: The flags are in order of precedence.  That is, ASYNC
         * is more important than INDOC, which is more important than ROOT.
         * This way, given any flag which specifies the source of a rating,
         * if that rating applies to the content, then
         *
         *  _fbPicsWaitFlags &= (flag - 1);
         *
         * will turn off that flag and all flags above it, causing the code
         * to not consider any further ratings from that source or less
         * important sources.
         */
        BYTE        _fbPicsWaitFlags;

        DWORD       _dwPicsLabelSource;
        LPVOID      _pRatingDetails;
        DWORD       _dwPicsSerialNumber;    /* serial number for async query */
        DWORD       _dwKey;                 /* Key for identifying CPicsProcs */
        HANDLE      _hPicsQuery;            /* handle to async query event */
        LPTSTR      _pszPicsURL;            /* result of CoInternetGetSecurityUrl */

        IHTMLPrivateWindow *    _pPrivWindow;       /* Private Window on behalf of which this proccessing is being done */
        CPicsRootDownload *     _pRootDownload;     /* object managing root document download */
        CDocObjectHost *        _pdoh;          

        CPicsProcessor *        _pPicsProcNext;     /* the next pics proc in the chain */

        LONG_PTR _GetKey() { return (LONG_PTR)_dwKey; }
        UINT    _PicsBlockingDialog();
        HRESULT _StartPicsQuery(LPCOLESTR pwszRawURL);
        void    _HandlePicsChecksComplete();
        void    _GotLabel(HRESULT hres, LPVOID pDetails, BYTE bfSource);
        void    _HandleInDocumentLabel(LPCTSTR pszLabel);
        void    _HandleDocumentEnd(void);
        void    _StartPicsRootQuery(LPCTSTR pszURL);
        void    _Terminate();
    };

    friend class CPicsProcessor;
    CPicsProcessor _PicsProcBase;
    DWORD          _dwPicsKeyBase;

    CPicsProcessor* _GetPicsProcessorFromKey(LONG_PTR lKey);
    CPicsProcessor* _GetPicsProcessorFromSerialNumber( DWORD dwPicsSerialNumber );
    void            _StartBasePicsProcessor();
    HRESULT         _StartSecondaryPicsProcessor(IHTMLPrivateWindow * pPrivWindow);
    HRESULT         _RemovePicsProcessorByKey(LONG_PTR lKey);
    HRESULT         _RemovePicsProcessorByPrivWindowUnk(IUnknown* pUnkFind);
    HRESULT         _RemoveAllPicsProcessors();

#endif

    BSTR                _strPriorityStatusText;

    // support for caching of script errors
    CScriptErrorList *  _pScriptErrList;
    BOOL                _fScriptErrDlgOpen;
    BOOL                _fShowScriptErrDlgAgain;
    HRESULT             _ScriptErr_CacheInfo(VARIANTARG *pvarIn);
    void                _ScriptErr_Dlg(BOOL fOverrridePerErrorMode);
};


#ifdef FEATURE_PICS

//#include <brwsectl.h>   /* for IBrowseControl */

class CPicsRootDownload : public IBindStatusCallback,
                                 IOleClientSite, IServiceProvider,
                                 IDispatch
{
protected:
    UINT m_cRef;
    long m_lFlags;
    IOleCommandTarget *m_pctParent;
    IOleObject *m_pole;
    IOleCommandTarget *m_pctObject;
    IBinding *m_pBinding;
    IBindCtx *m_pBindCtx;

    void _NotifyEndOfDocument(void);
    HRESULT _Abort(void);
    BOOL m_fFrameIsSilent:1;
    BOOL m_fFrameIsOffline:1;

public:
    CPicsRootDownload(IOleCommandTarget *pctParent, BOOL fFrameIsOffline, BOOL fFrameIsSilent);
    ~CPicsRootDownload();

    HRESULT StartDownload(IMoniker *pmk);
    void CleanUp(void);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IOleClientSite
    STDMETHODIMP SaveObject(void);
    STDMETHODIMP GetMoniker(DWORD, DWORD, IMoniker **);
    STDMETHODIMP GetContainer(IOleContainer **);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    // IServiceProvider (must be QI'able from IOleClientSite)
    STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

    // *** IDispatch methods ***
    STDMETHOD(GetTypeInfoCount) (unsigned int *pctinfo)
        { return E_NOTIMPL; };
    STDMETHOD(GetTypeInfo) (unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, unsigned int cNames, LCID lcid, DISPID * rgdispid)
        { return E_NOTIMPL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,EXCEPINFO * pexcepinfo,UINT * puArgErr);
};

// IID_IsPicsBrowser is a way we can use pClientSite->QueryService to find out
// if the top-level browser is a PICS root document download or not, so we can
// avoid navigating sub-frames.  No real interface corresponds to this IID, we
// just return an IUnknown pointer.
EXTERN_C const GUID IID_IsPicsBrowser;   // F114C2C0-90BE-11D0-83B1-00C04FD705B2

#endif


void DeleteFileSent(LPTSTR *ppszTempFile);
BOOL ShouldShellExecURL( LPTSTR pszURL );
DWORD GetSyncMode (DWORD dwDefault);

// in Dochost.cpp
BOOL _ValidateURL(LPTSTR pszName, DWORD dwFlags);
void GetAppHackFlags(IOleObject* pole, const CLSID* pclsid, DWORD* pdwAppHack);

BOOL _IsDesktopItem(CDocObjectHost * pdoh);
BOOL IsAssociatedWithIE(LPCWSTR pwszFileName);
UINT OpenSafeOpenDialog(HWND hwnd, UINT idRes, LPCTSTR pszFileClass, LPCTSTR pszURL, LPCTSTR pszRedirURL, LPCTSTR pszCacheName, LPCTSTR pszDisplay, UINT uiCP, IUnknown *punk = NULL, BOOL fDisableOpen = FALSE);

void CDownLoad_OpenUI(IMoniker* pmk, 
                      IBindCtx *pbc, 
                      BOOL fSync, 
                      BOOL fSaveAs=FALSE, 
                      BOOL fSafe=FALSE, 
                      LPWSTR pwzHeaders = NULL, 
                      DWORD dwVerb=BINDVERB_GET, 
                      DWORD grfBINDF = (BINDF_ASYNCHRONOUS | BINDF_PULLDATA), 
                      BINDINFO* pbinfo = NULL,
                      LPCTSTR pszRedir=NULL,
                      UINT uiCP = CP_ACP,
                      IUnknown *punk = NULL,
                      BOOL fConfirmed=FALSE
                      );

HRESULT CDownLoad_OpenUIURL(LPCWSTR pwszURL, IBindCtx *pbc, LPWSTR pwzHeaders, BOOL fSync, BOOL fSaveAs=FALSE, BOOL fSafe=FALSE, DWORD dwVerb=BINDVERB_GET, DWORD grfBINDF=(BINDF_ASYNCHRONOUS | BINDF_PULLDATA), BINDINFO* pbinfo=NULL,
                    LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, IUnknown *punk = NULL, BOOL fConfirmed=FALSE);

HRESULT _GetRequestFlagFromPIB(IBinding *pib, DWORD *pdwOptions);
HRESULT _SetSearchInfo (IServiceProvider *psp, DWORD dwIndex, BOOL fAllowSearch, BOOL fContinueSearch, BOOL fSentToEngine);
HRESULT _GetSearchInfo (IServiceProvider *psp, LPDWORD pdwIndex, LPBOOL pfAllowSearch, LPBOOL pfContinueSearch, LPBOOL pfSentToEngine);


// Values for automatically scanning common net suffixes

#define NO_SUFFIXES     0
#define SCAN_SUFFIXES   1
#define DONE_SUFFIXES   2

// Registry values for automatically sending request to search engine

#define NEVERSEARCH     0
#define PROMPTSEARCH    1
#define ALWAYSSEARCH    2

#define SHOULD_DO_SEARCH(x,y) (y || (x && x != DONE_SUFFIXES))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dllreg.cpp ===
// dllreg.c -- autmatic registration and unregistration
//
#include "priv.h"
#include "util.h"
#include "htregmng.h"
#include <advpub.h>
#include <comcat.h>
#include <winineti.h>
#include "resource.h"
#include "DllRegHelper.h"

#include <mluisupp.h>

#ifdef UNIX
#include "unixstuff.h"
#endif

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//
// helper macros
//
//#define RegCreate(hk, psz, phk) if (ERROR_SUCCESS != RegCreateKeyEx((hk), psz, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, (phk), &dwDummy)) goto CleanUp
//#define RegSetStr(hk, psz) if (ERROR_SUCCESS != RegSetValueEx((hk), NULL, 0, REG_SZ, (BYTE*)(psz), lstrlen(psz)+1)) goto CleanUp
//#define RegSetStrValue(hk, pszStr, psz)    if(ERROR_SUCCESS != RegSetValueEx((hk), (const char *)(pszStr), 0, REG_SZ, (BYTE*)(psz), lstrlen(psz)+1)) goto CleanUp
//#define RegCloseK(hk) RegCloseKey(hk); hk = NULL
#define RegOpenK(hk, psz, phk) if (ERROR_SUCCESS != RegOpenKeyEx(hk, psz, 0, KEY_READ|KEY_WRITE, phk)) return FALSE


//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    const CLSID* piidLibrary
)
{
    TCHAR szScratch[GUID_STR_LEN];
    HKEY hk;
    BOOL f;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));
    RegOpenK(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk);

    f = SHDeleteKey(hk, szScratch);

    RegCloseKey(hk);
    return f;
}

HRESULT SHRegisterTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];

    // Load and register our type library.
    //

    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));

#ifdef UNIX
    dwPathLen = ConvertModuleNameToUnix( szTmp );
#endif

    hr = LoadTypeLib(szTmp, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_SHDocVw);
        hr = RegisterTypeLib(pTypeLib, szTmp, NULL);

        if (FAILED(hr))
        {
            TraceMsg(DM_WARNING, "sccls: RegisterTypeLib failed (%x)", hr);
        }
        pTypeLib->Release();
    }
    else
    {
        TraceMsg(DM_WARNING, "sccls: LoadTypeLib failed (%x)", hr);
    }

    return hr;
}


//
// The actual functions called
//


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.
*/
HRESULT 
CallRegInstall(
    LPSTR pszSection,
    BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            // Get the location of iexplore from the registry
            if ( !EVAL(GetIEPath(szIEPath, SIZECHARS(szIEPath))) )
            {
                // Failed, just say "iexplore"
#ifndef UNIX
                StrCpyNA(szIEPath, "iexplore.exe", ARRAYSIZE(szIEPath));
#else
                StrCpyNA(szIEPath, "iexplorer", ARRAYSIZE(szIEPath));
#endif
            }

            if (g_fRunningOnNT)
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }

            hr = pfnri(g_hinst, pszSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        else
            TraceMsg(TF_ERROR, "DLLREG CallRegInstall() calling GetProcAddress(hinstAdvPack, \"RegInstall\") failed");

        FreeLibrary(hinstAdvPack);
    }
    else
        TraceMsg(TF_ERROR, "DLLREG CallRegInstall() Failed to load ADVPACK.DLL");

    return hr;
}

const CATID * const c_DeskBandClasses[] = 
{
    &CLSID_QuickLinks,
    &CLSID_AddressBand,
    NULL
};

const CATID * const c_OldDeskBandClasses[] = 
{
    &CLSID_QuickLinksOld,
    NULL
};

const CATID * const c_InfoBandClasses[] =
{
    &CLSID_FavBand,
    &CLSID_HistBand,
    &CLSID_ExplorerBand,
    NULL
};

void RegisterCategories(BOOL fRegister)
{
    enum DRH_REG_MODE eRegister = fRegister ? CCR_REG : CCR_UNREG;

    DRH_RegisterOneCategory(&CATID_DeskBand, IDS_CATDESKBAND, c_DeskBandClasses, eRegister);
    DRH_RegisterOneCategory(&CATID_InfoBand, IDS_CATINFOBAND, c_InfoBandClasses, eRegister);
    if (fRegister) 
    {
        // only nuke the implementor(s), not the category
        DRH_RegisterOneCategory(&CATID_DeskBand, IDS_CATDESKBAND, c_OldDeskBandClasses, CCR_UNREGIMP);
    }
}

HRESULT CreateShellFolderPath(LPCTSTR pszPath, LPCTSTR pszGUID, BOOL bUICLSID)
{
    if (!PathFileExists(pszPath))
        CreateDirectory(pszPath, NULL);

    // Mark the folder as a system directory
    if (SetFileAttributes(pszPath, FILE_ATTRIBUTE_SYSTEM))
    {
        TCHAR szDesktopIni[MAX_PATH];
        // Write in the desktop.ini the cache folder class ID
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);

        // (First, flush the cache to make sure the desktop.ini
        // file is really created.)
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), bUICLSID ? TEXT("UICLSID") : TEXT("CLSID"), pszGUID, szDesktopIni);
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);

        // Hide the desktop.ini since the shell does not selectively
        // hide it.
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN);

        return NOERROR;
    }
    else
    {
        TraceMsg(TF_ERROR, "Cannot make %s a system folder", pszPath);
        return E_FAIL;
    }
}

STDAPI 
DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;
    TraceMsg(DM_TRACE, "DLLREG DllRegisterServer() Beginning");

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllRegisterServer");
        DEBUG_BREAK;
    }
#endif

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = THR(CallRegInstall("InstallControls", FALSE));
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    hr = THR(SHRegisterTypeLib());
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;

#ifdef UNIX
    hrExternal = UnixRegisterBrowserInActiveSetup();
#endif /* UNIX */

    return hrExternal;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    TraceMsg(DM_TRACE, "DLLREG DllUnregisterServer() Beginning");

    // UnInstall the registry values
    hr = THR(CallRegInstall("UnInstallControls", TRUE));

    return hr;
}


extern HRESULT UpgradeSettings(void);

/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;
    HINSTANCE hinstAdvPack;

    if (0 == StrCmpIW(pszCmdLine, TEXTW("ForceAssoc")))
    {
        InstallIEAssociations(IEA_FORCEIE);
        return hr;
    }

    hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    // Assume we're installing for integrated shell unless otherwise
    // noted.
    BOOL bIntegrated = ((WhichPlatform() == PLATFORM_INTEGRATED) ? TRUE : FALSE);

    TraceMsg(DM_TRACE, "DLLREG DllInstall(bInstall=%lx, pszCmdLine=\"%ls\") bIntegrated=%lx", (DWORD) bInstall, pszCmdLine, (DWORD) bIntegrated);

    CoInitialize(0);
    if (bInstall)
    {
        // Backup current associations because InstallPlatformRegItems() may overwrite.
        hr = THR(CallRegInstall("InstallAssociations", FALSE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        hr = THR(CallRegInstall("InstallBrowser", FALSE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        if (bIntegrated)
        {
            // UnInstall settings that cannot be installed with Shell Integration.
            // This will be a NO-OP if it wasn't installed.
            hr = THR(CallRegInstall("UnInstallOnlyBrowser", TRUE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            // Install IE4 shell components too.
            hr = THR(CallRegInstall("InstallOnlyShell", FALSE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            if (GetUIVersion() >= 5)
            {
                hr = THR(CallRegInstall("InstallWin2KShell", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }
            else
            {
                hr = THR(CallRegInstall("InstallPreWin2KShell", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }

            if (IsOS(OS_WHISTLERORGREATER))
            {
                hr = THR(CallRegInstall("InstallXP", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }
        }
        else
        {
            // UnInstall Shell Integration settings.
            // This will be a NO-OP if it wasn't installed.
            hr = THR(CallRegInstall("UnInstallOnlyShell", TRUE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            // Install IE4 shell components too.
            hr = THR(CallRegInstall("InstallOnlyBrowser", FALSE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;
        }

        UpgradeSettings();
        UninstallCurrentPlatformRegItems();
        InstallIEAssociations(IEA_NORMAL);
        RegisterCategories(TRUE);
        SHRegisterTypeLib();
    }
    else
    {
        // Uninstall browser-only or integrated-browser?
        UninstallPlatformRegItems(bIntegrated);

        // Restore previous association settings that UninstallPlatformRegItems() could
        // have Uninstalled.
        hr = THR(CallRegInstall("UnInstallAssociations", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        // UnInstall settings that cannot be installed with Shell Integration.
        // This will be a NO-OP if it wasn't installed.
        hr = THR(CallRegInstall("UnInstallOnlyBrowser", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        // UnInstall Shell Integration settings.
        // This will be a NO-OP if it wasn't installed.
        hr = THR(CallRegInstall("UnInstallShell", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        hr = THR(CallRegInstall("UnInstallBrowser", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        UnregisterTypeLibrary(&LIBID_SHDocVw);
        RegisterCategories(FALSE);
    }


    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    CoUninitialize();
    return hrExternal;    
}    


/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.  
         This will open HKEY_CURRENT_USER if it exists,
         otherwise it will open HKEY_LOCAL_MACHINE.  

Returns: DWORD containing success or error code.
Cond:    --
*/
LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)           
{
    DWORD dwRet = RegOpenKeyEx(HKEY_CURRENT_USER, lpSubKey, ulOptions, samDesired, phkResult);

    if (ERROR_SUCCESS != dwRet)
        dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey, ulOptions, samDesired, phkResult);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dpastuff.cpp ===
#include "priv.h"
#include "runonnt.h"

#include "..\inc\dpastuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dochostbsc.cpp ===
#include "priv.h"
#include "iehelpid.h"
#include "bindcb.h"
#include "winlist.h"
#include "droptgt.h"
#include <mshtml.h>     // CLSID_HTMLDocument
#include "resource.h"
#include <htmlhelp.h>
#include <prsht.h>
#include <inetcpl.h>
#include <optary.h>
#include "shdocfl.h"
#include "interned.h" // IHTMLPrivateWindow

#ifdef FEATURE_PICS
#include <shlwapi.h>
#include <ratings.h>
#endif

#include "dochost.h"

#include <mluisupp.h>

#define THISCLASS CDocObjectHost
#define SUPERCLASS CDocHostUIHandler

#define BSCMSG(psz, i, j)       TraceMsg(TF_SHDBINDING, "shd TR-BSC::%s %x %x", psz, i, j)
#define BSCMSG3(psz, i, j, k)   TraceMsg(0, "shd TR-BSC::%s %x %x %x", psz, i, j, k)
#define BSCMSG4(psz, i, j, k, l)        TraceMsg(0, "shd TR-BSC::%s %x %x %x %x", psz, i, j, k, l)
#define BSCMSGS(psz, sz)        TraceMsg(0, "shd TR-BSC::%s %s", psz, sz)
#define CHAINMSG(psz, x)        TraceMsg(0, "shd CHAIN::%s %x", psz, x)
#define PERFMSG(psz, x)         TraceMsg(TF_SHDPERF, "PERF::%s %d msec", psz, x)
#define OPENMSG(psz)            TraceMsg(TF_SHDBINDING, "shd OPENING %s", psz)

#define DM_DOCCP        0
#define DM_DEBUGTFRAME  0
#define DM_SELFASC      TF_SHDBINDING
#define DM_SSL              0
#define DM_PICS         0

#define DO_SEARCH_ON_STATUSCODE(x) ((x == 0) || (x == HTTP_STATUS_BAD_GATEWAY) || (x == HTTP_STATUS_GATEWAY_TIMEOUT))

const static c_aidRes[] = {
    IDI_STATE_NORMAL,          // 0
    IDI_STATE_FINDINGRESOURCE, // BINDSTATUS_FINDINGRESOURCE
    IDI_STATE_FINDINGRESOURCE, // BINDSTATUS_CONNECTING
    IDI_STATE_FINDINGRESOURCE, // BINDSTATUS_REDIRECTING
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_BEGINDOWNLOADDATA
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_DOWNLOADINGDATA
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_ENDDOWNLOADDATA
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_BEGINDOWNLOADCOMPONENTS
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_INSTALLINGCOMPONENTS
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_ENDDOWNLOADCOMPONENTS
    IDI_STATE_SENDINGREQUEST,  // BINDSTATUS_USINGCACHEDCOPY
    IDI_STATE_SENDINGREQUEST,  // BINDSTATUS_SENDINGREQUEST
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_CLASSIDAVAILABLE
};

extern HICON g_ahiconState[IDI_STATE_LAST-IDI_STATE_FIRST+1];


#define SEARCHPREFIX        L"? "
#define SEARCHPREFIXSIZE    sizeof(SEARCHPREFIX)
#define SEARCHPREFIXLENGTH  2

// Put the most common errors first in c_aErrorUrls.
//

//========================================================
//
// WARNING - Thinking of changing the Table ?
//
// You also need to update the IsErrorHandled in mshtml
//  src\site\download\dwnbind.cxx
//
//========================================================

ErrorUrls c_aErrorUrls[] =
{
    {404, TEXT("http_404.htm")}, 
    {ERRORPAGE_DNS, TEXT("dnserror.htm")},
    {ERRORPAGE_NAVCANCEL, TEXT("navcancl.htm")},
    {ERRORPAGE_SYNTAX, TEXT("syntax.htm")},
    {400, TEXT("http_400.htm")},
    {403, TEXT("http_403.htm")},
    {405, TEXT("http_gen.htm")},
    {406, TEXT("http_406.htm")},
    {408, TEXT("servbusy.htm")},
    {409, TEXT("servbusy.htm")},
    {410, TEXT("http_410.htm")},
    {500, TEXT("http_500.htm")},
    {501, TEXT("http_501.htm")},
    {505, TEXT("http_501.htm")},
    {ERRORPAGE_OFFCANCEL, TEXT("offcancl.htm")},
    {ERRORPAGE_CHANNELNOTINCACHE, TEXT("cacheerr.htm")},
};
                   
//
// Determine if there is an internal error page for the given http error.
//

BOOL IsErrorHandled(DWORD dwError)
{
    BOOL fRet = FALSE;

    for (int i = 0; i < ARRAYSIZE(c_aErrorUrls); i++)
    {
        if (dwError == c_aErrorUrls[i].dwError)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}


const SA_BSTRGUID s_sstrSearchIndex = {
    38 * SIZEOF(WCHAR),
    L"{265b75c0-4158-11d0-90f6-00c04fd497ea}"
};

//extern const SA_BSTRGUID s_sstrSearchFlags;
const SA_BSTRGUID s_sstrSearchFlags = {
    38 * SIZEOF(WCHAR),
    L"{265b75c1-4158-11d0-90f6-00c04fd497ea}"
};

EXTERN_C const SA_BSTRGUID s_sstrSearch = {
    38 * SIZEOF(WCHAR),
    L"{118D6040-8494-11d2-BBFE-0060977B464C}"
};

EXTERN_C const SA_BSTRGUID s_sstrFailureUrl = {
    38 * SIZEOF(WCHAR),
    L"{04AED800-8494-11d2-BBFE-0060977B464C}"
};


//
// Clears that parameters set by window.external.AutoScan()
//
HRESULT _ClearSearchString(IServiceProvider* psp)
{
    HRESULT hr = E_FAIL;

    if (psp == NULL)
        return hr;

    IWebBrowser2 *pWB2 = NULL;
    hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
    if (pWB2 && SUCCEEDED(hr))
    {
        VARIANT v;
        VariantInit(&v);
        v.vt = VT_EMPTY;

        hr = pWB2->PutProperty((BSTR)s_sstrSearch.wsz, v);
        hr = pWB2->PutProperty((BSTR)s_sstrFailureUrl.wsz, v);
        pWB2->Release();
    }
    return hr;
}

//
// Gets the string that was entered in the addressbar
//
HRESULT _GetSearchString(IServiceProvider* psp, VARIANT* pvarSearch)
{
    HRESULT hr = E_FAIL;

    if (psp != NULL)
    {
        VariantInit(pvarSearch);
        IDockingWindow* psct = NULL;
        IOleCommandTarget* poct;

        // first see if there is an ISearchContext to get this information from
        ISearchContext * pSC = NULL;
        hr = psp->QueryService(SID_STopWindow, IID_ISearchContext, (void **) &pSC);
        if (SUCCEEDED(hr))
        {
            RIP(pSC != NULL);

            pvarSearch->vt = VT_BSTR;
            hr = pSC->GetSearchText(&(pvarSearch->bstrVal));

            pSC->Release();
        }
        else
        {
            // otherwise try to get the search string directly out of the address bar
            hr = psp->QueryService(SID_SExplorerToolbar, IID_IDockingWindow, (LPVOID*)&psct);
            if (SUCCEEDED(hr))
            {
                hr = psct->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&poct);
                if (SUCCEEDED(hr)) 
                {
                    // NULL is the first parameter so our ErrorMsgBox
                    // doesn't call EnableModelessSB()
                    // If we don't, our pdoh members may be freed 
                    // by the time we return.
                    hr = poct->Exec(&CGID_Explorer, SBCMDID_GETUSERADDRESSBARTEXT, 0, NULL, pvarSearch);
                    poct->Release();
                }
                psct->Release();
            }
        }
    }

    return hr;
}

//
// Get page that should be displayed if the AutoScan fails
//
HRESULT _GetScanFailureUrl(IServiceProvider* psp, VARIANT* pvarFailureUrl)
{
    HRESULT hr = E_FAIL;

    if (psp == NULL)
        return hr;

    //
    // See if a default failure page is stored as a property of the page
    //
    IWebBrowser2 *pWB2 = NULL;
    hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
    if (pWB2 && SUCCEEDED(hr))
    {
        hr = pWB2->GetProperty((BSTR)s_sstrFailureUrl.wsz, pvarFailureUrl);
        pWB2->Release();
    }
    return hr;
}

HRESULT _GetSearchInfo(IServiceProvider *psp, LPDWORD pdwIndex, LPBOOL pfAllowSearch, LPBOOL pfContinueSearch, LPBOOL pfSentToEngine, VARIANT* pvarUrl)
{
    HRESULT hr = E_FAIL;
    DWORD   dwFlags = 0;

    if (psp) {
        IWebBrowser2 *pWB2 = NULL;
        hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
        if (pWB2 && SUCCEEDED(hr)) {
            if (pdwIndex) {
                VARIANT v;
                if (SUCCEEDED(pWB2->GetProperty((BSTR)s_sstrSearchIndex.wsz, &v))) {
                    if (v.vt == VT_I4)
                        *pdwIndex = v.lVal;
                    VariantClear(&v);
                }
            }
            if (pfAllowSearch || pfContinueSearch || pfSentToEngine) {
                VARIANT v;
                if (SUCCEEDED(pWB2->GetProperty((BSTR)s_sstrSearchFlags.wsz, &v))) {
                    if (v.vt == VT_I4)
                        dwFlags = v.lVal;
                    VariantClear(&v);
                }
            }

            //
            // If we have a search string property, and the index is zero, we start
            // with the second autoscan index.  This is because the first index should
            // have already been tried (see window.external.AutoScan()).
            //
            if (pvarUrl)
            {
                VariantInit(pvarUrl); // in case of failure
                if (SUCCEEDED(pWB2->GetProperty((BSTR)s_sstrSearch.wsz, pvarUrl)) &&
                    pvarUrl->vt == VT_BSTR && pdwIndex && *pdwIndex == 0)
                {
                    *pdwIndex = 2;
                }
            }

            if (pfAllowSearch)
                *pfAllowSearch = ((dwFlags & 0x01) ? TRUE : FALSE);
            if (pfContinueSearch)
                *pfContinueSearch = ((dwFlags & 0x02) ? TRUE : FALSE);
            if (pfSentToEngine)
                *pfSentToEngine = ((dwFlags & 0x04) ? TRUE : FALSE);

            pWB2->Release();
        }
    }
    return hr;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::_SetSearchInfo(CDocObjectHost *pdoh, DWORD dwIndex, BOOL fAllowSearch, BOOL fContinueSearch, BOOL fSentToEngine)
{
    HRESULT hr = E_FAIL;
    DWORD   dwFlags = 0;

    dwFlags = (fAllowSearch ? 0x01 : 0) +
              (fContinueSearch ? 0x02 : 0) +
              (fSentToEngine ? 0x04 : 0);

    if (pdoh->_psp)
    {
        IWebBrowser2 *pWB2 = NULL;
        hr = pdoh->_psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
        if (pWB2 && SUCCEEDED(hr))
        {
            VARIANT v;
            VariantInit (&v);

            v.vt = VT_I4;
            v.lVal = dwIndex;
            pWB2->PutProperty((BSTR)s_sstrSearchIndex.wsz, v);

            v.vt = VT_I4;
            v.lVal = dwFlags;
            pWB2->PutProperty((BSTR)s_sstrSearchFlags.wsz, v);

            pWB2->Release();
        }
    }

    // If we are done, clear any parameters set by window.external.AutoScan().
    if (!fContinueSearch)
    {
        _ClearSearchString(pdoh->_psp);
    }
    TraceMsg(TF_SHDNAVIGATE, "::HFNS_SetSearchInfo() hr = %X, index = %d, allow = %d, cont = %d, sent = %d", hr, dwIndex, fAllowSearch, fContinueSearch, fSentToEngine);
    
    return hr;
}

//
// Gets the prefix/postfix to use for autoscanning (www.%s.com, etc)
//
LONG GetSearchFormatString(DWORD dwIndex, LPTSTR psz, DWORD cbpsz) 
{
    TCHAR szValue[10];
    DWORD dwType;

    wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwIndex);
    return SHRegGetUSValue(REGSTR_PATH_SEARCHSTRINGS, szValue, &dwType, (LPVOID)psz, &cbpsz, FALSE, NULL, 0);
}


// dwSearchForExtensions : 0     do not search
// dwSearchForExtensions : 1     search through list of exts.
// dwSearchForExtensions : 2     move on to autosearch

// 0 = never ask, never search
// 1 = always ask
// 2 = never ask, always search

HRESULT GetSearchKeys(IServiceProvider * psp, LPDWORD pdwSearchStyle, LPDWORD pdwSearchForExtensions, LPDWORD pdwDo404Search)
{
    RIP(pdwSearchStyle != NULL);
    RIP(pdwSearchForExtensions != NULL);
    RIP(pdwDo404Search != NULL);

    GetSearchStyle(psp, pdwSearchStyle);

    if (*pdwSearchStyle == 0)
    {
        *pdwSearchForExtensions = NO_SUFFIXES;
        *pdwDo404Search = NEVERSEARCH;
    }
    else
    {
        *pdwSearchForExtensions = SCAN_SUFFIXES;
        *pdwDo404Search = ALWAYSSEARCH;
    }

    return S_OK;
} // GetSearchKeys




//
// Map error codes to error urls.
//

int EUIndexFromError(DWORD dwError)
{
    for (int i = 0; i < ARRAYSIZE(c_aErrorUrls); i++)
    {
        if (dwError == c_aErrorUrls[i].dwError)
            break;
    }

    ASSERT(i < ARRAYSIZE(c_aErrorUrls));

    return i;
}

//
// IsErrorUrl determines if the given url is an internal error page url.  
//


BOOL IsErrorUrl(LPCWSTR pwszDisplayName)
{
    BOOL fRet = FALSE;
    TCHAR szDisplayName[MAX_URL_STRING];
    UnicodeToTChar(pwszDisplayName, szDisplayName, ARRAYSIZE(szDisplayName));

    //
    // First check if the prefix matches.
    //

    if (0 == StrCmpN(szDisplayName, TEXT("res://"), 6))
    {
        int iResStart;

        // find the resource name part of the URL
        // use the fact that the DLL path will be using
        // '\' as delimiters while the URL in general
        // uses '/'

        iResStart = 6;
        while (szDisplayName[iResStart] != TEXT('/') &&
               szDisplayName[iResStart] != TEXT('\0'))
        {
            iResStart++;
        }
        iResStart++;    // get off the '/'

        //
        // Check each url in order.
        //
        for (int i = 0; i < ARRAYSIZE(c_aErrorUrls); i++)
        {
            if (0 == StrCmpN(szDisplayName + iResStart, c_aErrorUrls[i].pszUrl,
                             lstrlen(c_aErrorUrls[i].pszUrl)))
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}

//
// When an http error occurs the server generally returns a page.  The
// threshold value this function returns is used to determine if the
// server page is displayed (if the size of the returned page is greater than
// the threshold) or if an internal error page is shown (if the returned page
// is smaller than the threshold).
//

DWORD _GetErrorThreshold(DWORD dwError)
{
    DWORD dwRet;

    TCHAR  szValue[11]; //Should be large enough to hold max dword 4294967295
    DWORD cbValue = ARRAYSIZE(szValue);
    DWORD cbdwRet = sizeof(dwRet);
    DWORD dwType  = REG_DWORD;

    wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwError);

    if (ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_THRESHOLDS, szValue,
                                          &dwType, (LPVOID)&dwRet, &cbdwRet,
                                          FALSE, NULL, 0))
    {
        dwRet = 512; // hard coded default size if all else fails.
    }

    return dwRet;
}

void CDocObjectHost::CDOHBindStatusCallback::_RegisterObjectParam(IBindCtx* pbc)
{
    // pbc->RegisterObjectParam(L"BindStatusCallback", this);

    _fAborted = FALSE;
    HRESULT hres = RegisterBindStatusCallback(pbc, this, 0, 0);
    BSCMSG3(TEXT("_RegisterObjectParam returned"), hres, this, pbc);
}

void CDocObjectHost::CDOHBindStatusCallback::_RevokeObjectParam(IBindCtx* pbc)
{
    // pbc->RevokeObjectParam(L"BindStatusCallback");
    HRESULT hres = RevokeBindStatusCallback(pbc, this);
    AssertMsg(SUCCEEDED(hres), TEXT("URLMON bug??? RevokeBindStatusCallback failed %x"), hres);
    BSCMSG3(TEXT("_RevokeObjectParam returned"), hres, this, pbc);
}

CDocObjectHost::CDOHBindStatusCallback::~CDOHBindStatusCallback()
{
    TraceMsg(DM_DEBUGTFRAME, "dtor CDocObjectHost::CBSC %x", this);

    if (_pib) {
        AssertMsg(0, TEXT("CBSC::~ _pib is %x (this=%x)"), _pib, this);
    }
    ATOMICRELEASE(_pib);

    if (_pbc) {
        AssertMsg(0, TEXT("CBSC::~ _pbc is %x (this=%x)"), _pbc, this);
    }
    ATOMICRELEASE(_pbc);

    if (_psvPrev) {
        AssertMsg(0, TEXT("CBSC::~ _psvPrev is %x (this=%x)"), _psvPrev, this);
    }

    ATOMICRELEASE(_psvPrev);
    ATOMICRELEASE(_pbscChained);
    ATOMICRELEASE(_pnegotiateChained);

    if (_hszPostData)
    {
        GlobalFree(_hszPostData);
        _hszPostData = NULL;
    }
    if (_pszHeaders)
    {
        LocalFree(_pszHeaders);
        _pszHeaders = NULL;
    }
    if (_pszRedirectedURL)
    {
        LocalFree(_pszRedirectedURL);
        _pszRedirectedURL = NULL;
    }
    if(_pszCacheFileName)
    {
        LocalFree(_pszCacheFileName);
        _pszCacheFileName = NULL;
    }
    if (_pszPolicyRefURL)
    {
        LocalFree(_pszPolicyRefURL);
        _pszPolicyRefURL = NULL;
    }
    if (_pszP3PHeader)
    {
        LocalFree(_pszP3PHeader);
        _pszP3PHeader = NULL;
    }
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IBindStatusCallback) || 
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IBindStatusCallback*);
    }
    else if (IsEqualIID(riid, IID_IHttpNegotiate))
    {
        *ppvObj = SAFECAST(this, IHttpNegotiate*);
    }
    else if (IsEqualIID(riid, IID_IAuthenticate))
    {
        *ppvObj = SAFECAST(this, IAuthenticate*);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IHttpSecurity))
    {
        *ppvObj = SAFECAST(this, IHttpSecurity*);
    }
    else if (IsEqualIID(riid, IID_IWindowForBindingUI))
    {
        *ppvObj = SAFECAST(this, IWindowForBindingUI*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

ULONG CDocObjectHost::CDOHBindStatusCallback::AddRef(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    return pdoh->AddRef();
}

ULONG CDocObjectHost::CDOHBindStatusCallback::Release(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    return pdoh->Release();
}

void SetBindfFlagsBasedOnAmbient(BOOL fAmbientOffline, DWORD *grfBindf);


#define CP_UCS_2                1200  // Unicode, ISO 10646
#define CP_UCS_2_BIGENDIAN      1201  // Unicode
#define CP_UTF_8                65001

UINT
NavigatableCodePage(UINT cp)
{
    return (cp == CP_UCS_2 || cp == CP_UCS_2_BIGENDIAN) ? CP_UTF_8 : cp;
}


HRESULT CDocObjectHost::CDOHBindStatusCallback::GetBindInfo(
     DWORD* grfBINDF,
     BINDINFO *pbindinfo)
{
    if ( !grfBINDF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;

    DWORD dwConnectedStateFlags = 0;
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    BSCMSG(TEXT("GetBindInfo"), 0, 0);

    *grfBINDF = BINDF_ASYNCHRONOUS;

    // Delegation is valid ONLY for the ::GetBindInfo() method
    if (_pbscChained) {
        CHAINMSG("GetBindInfo", grfBINDF);
        _pbscChained->GetBindInfo(grfBINDF, pbindinfo);
        
        DWORD dwFlags = 0;

        if (pdoh->_pwb)
        {
            pdoh->_pwb->GetFlags(&dwFlags);
        }

        pbindinfo->dwCodePage = (dwFlags & BSF_SETNAVIGATABLECODEPAGE)
                                ? NavigatableCodePage(pdoh->_uiCP)
                                : pdoh->_uiCP;
        
        // As far as offline mode is concerned, we want the latest
        // info. Over-rule what the delegated IBSC returned

        SetBindfFlagsBasedOnAmbient(_bFrameIsOffline, grfBINDF);

        if(_bFrameIsSilent)
            *grfBINDF |= BINDF_NO_UI;  
        else
            *grfBINDF &= ~BINDF_NO_UI;
           
    }
    else
    {
        // fill out the BINDINFO struct
        *grfBINDF = 0;
        BuildBindInfo(grfBINDF,pbindinfo,_hszPostData,_cbPostData,
            _bFrameIsOffline, _bFrameIsSilent, FALSE, /* bHyperlink */
            (IBindStatusCallback *) this);

        // HTTP headers are added by the callback to our
        // IHttpNegotiate::BeginningTransaction() method

    }

    // Remember it to perform modeless download for POST case.
    _dwBindVerb = pbindinfo->dwBindVerb;

    // Remember this to use when populating the threadparams for CDownload.
    // (FerhanE): We are only remembering the restricted zone enforcement 
    //            to not break anything that depended on other flags being
    //            not set before.
    _dwBindf = *grfBINDF & BINDF_ENFORCERESTRICTED;

    return S_OK;
}

// *** IAuthenticate ***
HRESULT CDocObjectHost::CDOHBindStatusCallback::Authenticate(
    HWND *phwnd,
    LPWSTR *pszUsername,
    LPWSTR *pszPassword)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);

    if (!phwnd || !pszUsername || !pszPassword)
        return E_POINTER;



    if(!_bFrameIsSilent){
        if (pdoh->_psb) {
            pdoh->_psb->GetWindow(phwnd);
        } else {
            *phwnd = pdoh->_hwnd;
        }
    }else{
        *phwnd = NULL;
    }

    *pszUsername = NULL;
    *pszPassword = NULL;
    // If we're a frame in the active desktop, then find out
    // the user name and password are stored with the subscription
    // and use it
    if(_IsDesktopItem(pdoh))
    {
        // Get the URL
        LPOLESTR pszURL;
        HRESULT hres;
        hres = pdoh->_GetCurrentPageW(&pszURL, TRUE);
        if(SUCCEEDED(hres))
        {
            IActiveDesktop *pActiveDesk;
         
            hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID*)&pActiveDesk);
            
            if(SUCCEEDED(hres))
            {
                // Get the subscribed URL for this
                COMPONENT Component;

                Component.dwSize = SIZEOF(Component);
                Component.wszSubscribedURL[0] = TEXT('\0');
                hres = pActiveDesk->GetDesktopItemBySource(pszURL, &Component, 0);
                if(SUCCEEDED(hres) && Component.wszSubscribedURL[0])
                {
                    // We have a non null subscribed URL
                    // Gotta find the user name and password 
                    // associated with this subscription
                    ISubscriptionMgr *pSubsMgr;

                    hres = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                            CLSCTX_INPROC_SERVER, 
                                    IID_ISubscriptionMgr, (LPVOID*)&pSubsMgr);

                    if(SUCCEEDED(hres))
                    {
                        SUBSCRIPTIONINFO SubInfo;
                        SubInfo.cbSize = sizeof(SUBSCRIPTIONINFO);
                        SubInfo.fUpdateFlags = (SUBSINFO_NEEDPASSWORD | SUBSINFO_TYPE 
                                                 | SUBSINFO_USER | SUBSINFO_PASSWORD);
                        SubInfo.bstrUserName = NULL;
                        SubInfo.bstrPassword = NULL;
                        hres = pSubsMgr->GetSubscriptionInfo(Component.wszSubscribedURL, &SubInfo);
                        if(SUCCEEDED(hres) && SubInfo.bNeedPassword)
                        {
                            if((SubInfo.bstrUserName) && (SubInfo.bstrPassword))
                            {
                                // Copy  user name and password
                                SHStrDupW(SubInfo.bstrPassword, pszPassword);
                                SHStrDupW(SubInfo.bstrUserName, pszUsername);
                            }
                        
                        }   
                        if(SubInfo.bstrPassword)
                            SysFreeString(SubInfo.bstrPassword);
                        if(SubInfo.bstrUserName)
                            SysFreeString(SubInfo.bstrUserName);
                        pSubsMgr->Release();
                    }
                }
                pActiveDesk->Release();
            }

            OleFree(pszURL);
        }
        
    }
    
    return S_OK;
}

// *** IServiceProvider ***
HRESULT CDocObjectHost::CDOHBindStatusCallback::QueryService(REFGUID guidService,
                            REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;

    if (IsEqualGUID(guidService, IID_IAuthenticate)) {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, IID_ITargetFrame2))
    {
        return IToClass(CDocObjectHost, _bsc, this)->QueryService(
                    guidService,
                    riid,
                    ppvObj);
    }
    else if (_pbscChained)
    {
        // Has a delegating IBindStatusCallback.
        IServiceProvider* psp;
        hres = _pbscChained->QueryInterface(IID_IServiceProvider, (LPVOID*)&psp);
        if (SUCCEEDED(hres)) {
            // It supports ServiceProvider, just delegate.
            hres = psp->QueryService(guidService, riid, ppvObj);
            psp->Release();
        } else if (IsEqualGUID(guidService, riid)) {
            // It does not supports ServiceProvide, try QI.
            hres = _pbscChained->QueryInterface(riid, ppvObj);
        }
    }

    return hres;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnStartBinding(
            DWORD grfBSCOption, IBinding *pib)
{

    BSCMSG(TEXT("OnStartBinding"), _pib, pib);
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);

    _fBinding = TRUE;
    _fDocWriteAbort = FALSE;
    _fBoundToMSHTML = FALSE;
    ASSERT(pdoh->_pocthf);

    // ASSERT(_pib==NULL);
    ATOMICRELEASE(_pib);

    _pib = pib;
    if (_pib) {
        _pib->AddRef();
    }

#ifndef NO_DELEGATION
    if (_pbscChained) {
        CHAINMSG("OnStartBinding", grfBSCOption);
    _pbscChained->OnStartBinding(grfBSCOption, pib);
    }
#endif

    pdoh->_fShowProgressCtl = TRUE;
    pdoh->_PlaceProgressBar(TRUE);

    _privacyQueue.Reset();
    ResetPrivacyInfo();

    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::GetPriority(LONG *pnPriority)
{
    BSCMSG(TEXT("GetPriority"), 0, 0);
    *pnPriority = NORMAL_PRIORITY_CLASS;
#ifndef NO_DELEGATION
    if (_pbscChained) {
        _pbscChained->GetPriority(pnPriority);
    }
#endif
    return S_OK;
}

void CDocObjectHost::CDOHBindStatusCallback::ResetPrivacyInfo()
{
    _dwPrivacyFlags = 0;

    if (_pszPolicyRefURL)
    {
        LocalFree(_pszPolicyRefURL);
        _pszPolicyRefURL = NULL;
    }
    if (_pszP3PHeader)
    {
        LocalFree(_pszP3PHeader);
        _pszP3PHeader = NULL;
    }
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::AddToPrivacyQueue(LPTSTR * ppszUrl, 
                                                                  LPTSTR * ppszPolicyRef, 
                                                                  LPTSTR * ppszP3PHeader, 
                                                                  DWORD dwFlags)
{
    CPrivacyRecord *pRecord = new CPrivacyRecord;
    
    if (!pRecord)
    {
        return E_OUTOFMEMORY;        
    }
    
    HRESULT hRes = S_OK;

    hRes = pRecord->Init(ppszUrl, ppszPolicyRef, ppszP3PHeader, dwFlags);

    if (SUCCEEDED(hRes))
        _privacyQueue.Queue(pRecord);
    else
        delete pRecord;

    return hRes;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::BuildRecord()
{
    HRESULT hRes = S_OK;
    
    CDocObjectHost* pdoh    = NULL; 
    TCHAR         * pszUrl  = NULL;    

    if (_pszRedirectedURL) 
    {
        hRes = AddToPrivacyQueue(&_pszRedirectedURL, &_pszPolicyRefURL, &_pszP3PHeader, _dwPrivacyFlags);
        goto cleanup;
    }

    pdoh = IToClass(CDocObjectHost, _bsc, this);

    // Get the current URL to add 
    pszUrl = new TCHAR[MAX_URL_STRING];
    if (!pszUrl)
    {
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }
    
    pszUrl[0] = TEXT('\0');

    if (pdoh->_pidl)
    {
        hRes = IEGetDisplayName(pdoh->_pidl, pszUrl, SHGDN_FORPARSING);
    }
    else
    {
        LPOLESTR pwUrl = NULL;
        hRes = pdoh->_GetCurrentPageW(&pwUrl, TRUE);
        if (SUCCEEDED(hRes))
        {        
            StrCpyN(pszUrl, pwUrl, MAX_URL_STRING);
            OleFree(pwUrl);
        }
    }

    hRes = AddToPrivacyQueue(&pszUrl, &_pszPolicyRefURL, &_pszP3PHeader, _dwPrivacyFlags);
    
cleanup:
    
    if (!SUCCEEDED(hRes)) 
    {
        delete [] pszUrl;
    }

    return hRes;
}

void CDocObjectHost::CDOHBindStatusCallback::_Redirect(LPCWSTR pwzNew)
{
    LPITEMIDLIST pidlNew;
    WCHAR wszPath[MAX_URL_STRING] = TEXT("");
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    LPOLESTR pwszCurrent = NULL;
    BOOL fAllow = FALSE;

    if (SUCCEEDED(IECreateFromPath(pwzNew, &pidlNew))) {
        TraceMsg(TF_SHDNAVIGATE, "CDOH::CBSC::_Redirect calling NotifyRedirect(%s)", pwzNew);

        if ( pdoh->_pwb )
        {
            pdoh->_pwb->NotifyRedirect(pdoh->_psv, pidlNew, NULL);
        }

        // Important - Do this before we destroy the old redirect url
        BuildRecord();
        ResetPrivacyInfo();

        // Save te redirected URL
        if (_pszRedirectedURL)
           LocalFree( _pszRedirectedURL );
        _pszRedirectedURL = StrDup(pwzNew);

        // We need to account for a bookmark that might appear
        // in the redirected URL.
        if(IEILGetFragment(pidlNew, wszPath, SIZECHARS(wszPath))) {
            LocalFree((LPVOID) pdoh->_pszLocation);
            pdoh->_pszLocation = StrDup(wszPath);
        }

        ILFree(pidlNew);
    }

    AddUrlToUrlHistoryStg(pwzNew, NULL, pdoh->_psb, FALSE,
                                NULL, NULL, NULL);

    // Security:  Release the pre-created object and start over for
    // server-side redirects.  The only security check for the
    // document reference occurs when someone tries to obtain it.
    // Therefore, we want to orphan the reference if x-domain, so the
    // client will need to obtain a new reference to the redirected
    // document.
    if (SUCCEEDED(pdoh->_GetCurrentPageW(&pwszCurrent, TRUE)))
    {
        fAllow = AccessAllowed(pwszCurrent, pwzNew);
        OleFree(pwszCurrent);
    }

    if (!fAllow)
        pdoh->_ReleasePendingObject(FALSE);
}


//
// In this function, we get the codepage for the current URL. If that's not
// CP_ACP, we pass it to Trident via IBindCtx*.
//
void CDocObjectHost::CDOHBindStatusCallback::_CheckForCodePageAndShortcut(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    LPWSTR pwszURL;
    HRESULT hres = pdoh->_GetCurrentPageW(&pwszURL, TRUE);

    

    if (SUCCEEDED(hres)) {
        UINT codepage = CP_ACP;
        IOleCommandTarget *pcmdt;
        VARIANT varShortCutPath = {0};
        BOOL fHasShortcut = FALSE;
        hres = pdoh->QueryService(SID_SHlinkFrame, IID_IOleCommandTarget, (void **)&pcmdt);
        if(S_OK == hres) 
        {
           ASSERT(pcmdt);
           hres = pcmdt->Exec(&CGID_Explorer, SBCMDID_GETSHORTCUTPATH, 0, NULL, &varShortCutPath);

           //
           // App Compat:  Imagineer Technical returns S_OK for the above Exec
           // but of course doesn't set the output parameter.
           //
           if((S_OK) == hres && VT_BSTR == varShortCutPath.vt && varShortCutPath.bstrVal)
           {
               fHasShortcut = TRUE;
           }
           pcmdt->Release();
        }
        if(UrlHitsNetW(pwszURL))
        {
            // Don't do this for File: files - we can live
            // with getting the code page late for file: even
            // if it slows down file: display somewhat if the
            // trident parser needs to restarted
            AddUrlToUrlHistoryStg(pwszURL, NULL, pdoh->_psb, FALSE,
                                NULL, NULL, &codepage);
        }
        TraceMsg(DM_DOCCP, "CDOH::CBSC::_CheckForCodePageAndShortcut codepage=%d", codepage);

        if ((codepage != CP_ACP || fHasShortcut) && _pbc) {
            // Here is where we pass the codepage to Trident.
            // (Mars): Clients may have already registered HtmlLoadOptions with
            // the bind context in order to specify the shortcut path.  In this case,
            // registering it again to set the codepage would fail.  However, we should
            // first verify that this codepage stuff actually gets used.
            IHtmlLoadOptions *phlo;
            HRESULT hres = CoCreateInstance(CLSID_HTMLLoadOptions,
                NULL, CLSCTX_INPROC_SERVER,
                IID_IHtmlLoadOptions, (void**)&phlo);

            if (SUCCEEDED(hres) && phlo)
            {
                if(codepage != CP_ACP)
                {
                    hres = phlo->SetOption(HTMLLOADOPTION_CODEPAGE, &codepage, sizeof(codepage));
                }
                if (SUCCEEDED(hres))
                {
                    if(fHasShortcut)
                    {
                        // deliberately ignore failures here
                        phlo->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH, varShortCutPath.bstrVal, 
                                                (lstrlenW(varShortCutPath.bstrVal) + 1)*sizeof(WCHAR));
                    }
                    _pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                }
                phlo->Release();
            } else {
                TraceMsg(DM_WARNING, "DOH::_CheckForCodePagecut CoCreateInst failed (%x)", hres);
            }
        }
        VariantClear(&varShortCutPath);
        OleFree(pwszURL);
    }
}

#ifdef BETA1_DIALMON_HACK
extern void IndicateWinsockActivity();
#endif // BETA1_DIALMON_HACK


HRESULT CDocObjectHost::CDOHBindStatusCallback::OnProgress(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText)
{
    HRESULT hr = S_OK;
    HRESULT hrPrivacy = S_OK;
    
    TCHAR         * pszPrivacyURL = NULL;
    static TCHAR  * pszNULL       = NULL;
    
    
    TraceMsg(TF_SHDPROGRESS, "DOH::BSC::OnProgress (%d of %d) ulStatus=%x",
             ulProgress, ulProgressMax, ulStatusCode);

    // JEFFWE 4/15/96 Beta 1 Hack - every once in a while, send message
    // to the hidden window that detects inactivity so that it doesn't
    // think we are inactive during a long download

#ifdef BETA1_DIALMON_HACK
        IndicateWinsockActivity();
#endif


    CDocObjectHost * pdoh = IToClass(CDocObjectHost, _bsc, this);


#ifdef DEBUG
    if (pwzStatusText)
    {
        char szStatusText[MAX_PATH];    // OK with MAX_PATH
        UnicodeToAnsi(pwzStatusText, szStatusText, ARRAYSIZE(szStatusText));
        TraceMsg(TF_SHDPROGRESS, "DOH::BSC::OnProgress pszStatus=%s", szStatusText);
    }
#endif

    if (pdoh->_psb)
    {
        // we may be switching between multiple proxy/server hosts, so don't prevent
        //  showing them when they change
        if (_bindst != ulStatusCode ||
            ulStatusCode == BINDSTATUS_FINDINGRESOURCE)
        {
            UINT idRes = IDI_STATE_NORMAL;
            _bindst = ulStatusCode;

            if (_bindst < ARRAYSIZE(c_aidRes)) 
                idRes = c_aidRes[_bindst];

            pdoh->_psb->SendControlMsg(FCW_STATUS, SB_SETICON, STATUS_PANE_NAVIGATION, 
                                        (LPARAM)g_ahiconState[idRes-IDI_STATE_FIRST], NULL);

            TCHAR szStatusText[MAX_PATH];        // OK with MAX_PATH

            if (pwzStatusText)
            {
                StrCpyN(szStatusText, pwzStatusText, ARRAYSIZE(szStatusText));
            }
            else
            {
                szStatusText[0] = TEXT('\0');
            }

            //
            // This if-block will open the safe open dialog for OLE Object
            // and DocObject.
            //
            if (_bindst == BINDSTATUS_CLASSIDAVAILABLE)
            {
                TraceMsg(TF_SHDPROGRESS, "DOH::BSC::OnProgress got CLSID=%ws", szStatusText);
                CLSID clsid;

                // WORK-AROUND: CLSIDFromString does not take LPCOLESTR correctly.
                HRESULT hresT = CLSIDFromString((LPOLESTR)pwzStatusText, &clsid);

                if (SUCCEEDED(hresT))
                {
#ifdef DEBUG
                    if (IsEqualGUID(clsid, CLSID_NULL))
                    {
                        TraceMsg(DM_WARNING, "DOH::SBC::OnProgress Got CLSID_NULL");
                    }
#endif
                    //
                    //  Notice that we don't want to use BROWSERFLAG_MSHTML,
                    // which includes other types of MSHMTL CLSIDs.
                    // In this case, we just want to deal with HTMLDocument.
                    // (We allow XMLViewer docobj and *.MHT and *.MHTML too!)
                    BOOL fIsHTML = (IsEqualGUID(clsid, CLSID_HTMLDocument) || 
                                    IsEqualGUID(clsid, CLSID_XMLViewerDocObj) ||
                                    IsEqualGUID(clsid, CLSID_MHTMLDocument));
                    BOOL fAbortDesktopComponent = FALSE;

                    if(!fIsHTML)
                    {
                        //Check if we are a desktop component.
                        if (_IsDesktopItem(pdoh))
                        {
                            //Because this is NOT html, then don't show it!
                            fAbortDesktopComponent = TRUE;
                        }
                    }

                    if (fAbortDesktopComponent)
                    {
                        AbortBinding();
                        hr = E_ABORT;
                    }
                    else
                    {
                        _fBoundToMSHTML = fIsHTML; // Remember this and suppress redundant
                                               // AddUrl to history

                        //  There is an interval of time between OnProgress and OnObjectAvailable
                        //  in which the om might be required.
                        if (fIsHTML && pdoh->_punkPending == NULL)
                        {
                            pdoh->_CreatePendingDocObject(FALSE);
                        }
                        if (pdoh->_punkPending)
                        {
                            IPersist *pip;

                            hresT = pdoh->_punkPending->QueryInterface(IID_IPersist, (LPVOID *) &pip);
                            if (SUCCEEDED(hresT))
                            {
                                CLSID clsidPending;

                                hresT = pip->GetClassID(&clsidPending);
                                if (SUCCEEDED(hresT) && IsEqualGUID(clsid, clsidPending))
                                {
                                    _pbc->RegisterObjectParam(L"__PrecreatedObject", pdoh->_punkPending);
                                }
                                pip->Release();
                            }
                        }

                        hresT = pdoh->_MayHaveVirus(clsid);

                        if (hresT == HRESULT_FROM_WIN32(ERROR_CANCELLED))
                        {
                            hr = E_ABORT;
                            AbortBinding();

                            if (pdoh->_pmsoctBrowser && pdoh->_fWindowOpen)
                            {
                                pdoh->_pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELANDCLOSE, 0, NULL, NULL);
                            }
                        }

                    }
                }
                else
                {
                    TraceMsg(DM_ERROR, "DOH::BSC::OnProgress CLSIDFromString failed %x", hresT);
                }

                //
                //  Notice that URLMON will call IPersistMoniker::Load right
                // after we return from this notification. Therefore, this
                // is the latest moment we have a chance to pass the code
                // page to Trident.
                //              
                _CheckForCodePageAndShortcut();
            }
            else if (_bindst == BINDSTATUS_CACHEFILENAMEAVAILABLE)
            {
                TraceMsg(DM_SELFASC, "DOH::OnProgress got BINDSTATUS_CACHEFILENAMEAVAILABLE");
                _fSelfAssociated = IsAssociatedWithIE(pwzStatusText);

                if(_pszCacheFileName)
                     LocalFree(_pszCacheFileName);
                _pszCacheFileName = StrDup(pwzStatusText);
            }
            else if (_bindst == BINDSTATUS_CONTENTDISPOSITIONATTACH)
            {
                TCHAR szURL[MAX_URL_STRING];
                TCHAR * pszURL = szURL;
                HRESULT hresT;
        
                hresT = pdoh->_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);

                if (SUCCEEDED(hresT)) 
                {
                    UINT uRet;

                    if (_pszRedirectedURL && lstrlen(_pszRedirectedURL))
                    {
                        pszURL = _pszRedirectedURL;
                    }

                    IUnknown * punk;

                    hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        uRet = OpenSafeOpenDialog(pdoh->_hwnd, DLG_SAFEOPEN, NULL, pszURL, NULL, szStatusText, NULL, pdoh->_uiCP, punk);
            
                        switch(uRet) 
                        {
                            case IDOK:
                                //
                                // Set this flag to avoid poppping this dialog box twice.
                                // 
                                pdoh->_fConfirmed = TRUE;
                                break;  // continue download

                            case IDD_SAVEAS:
                                CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);
                                ATOMICRELEASE(_pbc);
                                ATOMICRELEASE(_psvPrev);
                                // fall thru to AbortBinding

                            case IDCANCEL:
                                pdoh->_CancelPendingNavigation(FALSE);
                                AbortBinding();
                                if (uRet == IDCANCEL)
                                {
                                    _fAborted = TRUE;
                                }
                                break;
                        }

                        punk->Release();
                    }
                }
            }
            
            if (  ( _bindst >= BINDSTATUS_FINDINGRESOURCE
                 && _bindst <= BINDSTATUS_SENDINGREQUEST)
                 || _bindst == BINDSTATUS_PROXYDETECTING)
            {
                TCHAR szTemplate[MAX_PATH];              // OK with MAX_PATH
                UINT idResource = IDS_BINDSTATUS+_bindst;

                if ( _bindst == BINDSTATUS_PROXYDETECTING )
                {
                    idResource = IDS_BINDSTATUS_PROXYDETECTING;
                }

                // If we are connecting over proxy, don't say "web site found".
                //
                if (fOnProxy() && idResource == IDS_BINDSTATUS_SEND)
                {
                    idResource = IDS_BINDSTATUS_CON;

                    TCHAR szUrl[MAX_URL_STRING];

                    pdoh->_GetCurrentPage(szUrl, SIZECHARS(szUrl));
                    DWORD cchStatusText = SIZECHARS(szStatusText);

                    UrlGetPart(szUrl, szStatusText, &cchStatusText, URL_PART_HOSTNAME, 0);
                }

                if (MLLoadString(idResource, szTemplate, ARRAYSIZE(szTemplate)))
                {
                    BSCMSGS("OnProgress szTemplate=", szTemplate);

                    TCHAR szMessage[MAX_PATH];          // OK with MAX_PATH
                    BOOL fSuccess = wnsprintf(szMessage, ARRAYSIZE(szMessage), szTemplate, szStatusText);

                    if (fSuccess)
                    {
                        
                        BSCMSGS("OnProgress szMessage=", szMessage);
                        pdoh->_SetStatusText(szMessage);
                    }
                }
            }
        }

        DWORD dwState = 0;

        switch (ulStatusCode)
        {
        case BINDSTATUS_REDIRECTING:
            // they're redirecting.  treat this as a rename.
            _Redirect(pwzStatusText);
            break;
        
        case BINDSTATUS_FINDINGRESOURCE:
            dwState = PROGRESS_FINDING;
            ASSERT(!ulProgressMax);
            break;

        case BINDSTATUS_SENDINGREQUEST:
            dwState = PROGRESS_SENDING;
            ASSERT(!ulProgressMax);
            break;

        //Handle privacy notifications
        case BINDSTATUS_COOKIE_SENT:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_SENT"), 0 ,0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_READ);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_READ;
            }
            break;
        case BINDSTATUS_COOKIE_SUPPRESSED:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_SUPPRESSED"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_SUPPRESS);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_SUPPRESS;
            }            
            break;

        case BINDSTATUS_COOKIE_STATE_UNKNOWN:
            BSCMSG(TEXT("Shdocvw should never BINDSTATUS_COOKIE_STATE_UNKNOWN from Wininet/Urlmon"), 0, 0);
            break;
        case BINDSTATUS_COOKIE_STATE_ACCEPT:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_ACCEPT"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_ACCEPT);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_ACCEPT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_REJECT:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_REJECT"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_REJECT);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_REJECT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_PROMPT:
            BSCMSG(TEXT("Shdocvw should never BINDSTATUS_COOKIE_STATE_PROMPT from Wininet/Urlmon"), 0, 0);
            break;
        case BINDSTATUS_COOKIE_STATE_LEASH:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_LEASH"), 0, 0);            
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_LEASH);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_LEASH;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_DOWNGRADE:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_DOWNGRADE"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_DOWNGRADE);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_DOWNGRADE;
            }
            break;
            
        case BINDSTATUS_COMPACT_POLICY_RECEIVED:
            _dwPrivacyFlags |= PRIVACY_URLHASCOMPACTPOLICY;
            break;            

        case BINDSTATUS_POLICY_HREF:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_POLICY_HREF"), 0, 0);
            ASSERT(pwzStatusText && *pwzStatusText);
            // We are getting two notifications from urlmon, once that is fixed, need to uncomment this assert
            //ASSERT(!_pszPolicyRefURL);
            if (_pszPolicyRefURL)
            {
                LocalFree(_pszPolicyRefURL);
            }
            _pszPolicyRefURL = StrDup(pwzStatusText);
            _dwPrivacyFlags |= PRIVACY_URLHASPOLICYREFHEADER;
            break;

        case BINDSTATUS_P3P_HEADER:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_P3P_HEADER"), 0, 0);
            ASSERT(pwzStatusText && *pwzStatusText);
            // We are getting two notifications from urlmon, once that is fixed, need to uncomment this assert
            //ASSERT(!_pszP3PHeader);
            if (_pszP3PHeader)
            {
                LocalFree(_pszP3PHeader);
            }
            _pszP3PHeader = StrDup(pwzStatusText);
            _dwPrivacyFlags |= PRIVACY_URLHASP3PHEADER;
            break;
        }

        if (dwState)
        {
            pdoh->_OnSetProgressPos(ulProgress, dwState);
        }

        if (BINDSTATUS_BEGINDOWNLOADDATA == ulStatusCode)
        {
            _cbContentLength = ulProgress;
        }
        else if (BINDSTATUS_MIMETYPEAVAILABLE == ulStatusCode)
        {
            // delegate to media bar if this is a media mime-type
            if (    pwzStatusText
                &&  (   !StrCmpNIW(pwzStatusText, _T("audio"), 5)
                     || !StrCmpNIW(pwzStatusText, _T("video"), 5)))
            {
                if (pdoh->_DelegateToMediaBar(NULL, pwzStatusText))
                {
                    // Cancel the navigation
                    pdoh->_CancelPendingNavigation(FALSE);
                    AbortBinding();
                    _fAborted = TRUE;

                    if (pdoh->_pwb)
                    {
                        pdoh->_pwb->SetNavigateState(BNS_NORMAL);
                    }
                }
            }
        }
    }

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        _pbscChained->OnProgress(ulProgress, ulProgressMax, ulStatusCode, pwzStatusText);
    }
#endif
    return hr;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnDataAvailable(
            /* [in] */ DWORD grfBSC,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed)
{
    BSCMSG(TEXT("OnDataAvailable (grf,pstg)"), grfBSC, pstgmed);

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        _pbscChained->OnDataAvailable(grfBSC, dwSize, pformatetc, pstgmed);
    }
#endif
    return S_OK;
}

void CDocObjectHost::CDOHBindStatusCallback::_UpdateSSLIcon(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    ASSERT(_pib);
    //
    //  if we have already been set by our object, we dont 
    //  want to override it.
    if (_pib  && !pdoh->_fSetSecureLock) 
    {
        pdoh->_eSecureLock = SECURELOCK_SET_UNSECURE;

        IWinInetInfo* pwinet;
        HRESULT hresT = _pib->QueryInterface(IID_IWinInetInfo, (LPVOID*)&pwinet);

        if (SUCCEEDED(hresT))
        {
            DWORD dwOptions = 0;
            DWORD cbSize = SIZEOF(dwOptions);
            
            hresT = pwinet->QueryOption(INTERNET_OPTION_SECURITY_FLAGS,
                                (LPVOID)&dwOptions, &cbSize);

            TraceMsg(DM_SSL, "pwinet->QueryOptions hres=%x dwOptions=%x", hresT, dwOptions);

            if (SUCCEEDED(hresT))
            {
                LPWSTR pwzUrl;

                pdoh->_fSetSecureLock = TRUE;

                if(dwOptions & SECURITY_FLAG_SECURE)
                {
                    pdoh->_dwSecurityStatus = dwOptions;

                    if (pdoh->_dwSecurityStatus & SECURITY_FLAG_40BIT)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_SECURE40BIT;
                    }
                    else if (pdoh->_dwSecurityStatus & SECURITY_FLAG_128BIT)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_SECURE128BIT;
                    }
                    else if (pdoh->_dwSecurityStatus & SECURITY_FLAG_FORTEZZA)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_FORTEZZA;
                    }
                    else if (pdoh->_dwSecurityStatus & SECURITY_FLAG_56BIT)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_SECURE56BIT;
                    }
                }
                else if (SUCCEEDED(_GetRequestFlagFromPIB(_pib, &dwOptions)) && 
                    (dwOptions & INTERNET_REQFLAG_FROM_CACHE) && 
                    SUCCEEDED(pdoh->_GetCurrentPageW(&pwzUrl, TRUE)))
                {
                    // 
                    //  when secure pages are cached, they lose their
                    //  security context, but should still be displayed
                    //  as secure.  therefore we use the UnknownBit level
                    //  of security.
                    //
                    if(URL_SCHEME_HTTPS == GetUrlSchemeW(pwzUrl))
                        pdoh->_eSecureLock = SECURELOCK_SET_SECUREUNKNOWNBIT;

                    OleFree(pwzUrl);
                }
            }
            else 
            {
                pdoh->_dwSecurityStatus = 0;
            }

            //  we will update the browser when we are activated

            pwinet->Release();
        }
        else
        {
            TraceMsg(DM_SSL, "QI to IWinInetInfo failed");
        }

        TraceMsg(DM_SSL, "[%X] UpdateSslIcon() setting _eSecureLock = %d", pdoh, pdoh->_eSecureLock);
    }
    else
    {
        TraceMsg(DM_SSL, "[%X] UpdateSslIcon() already set _eSecureLock = %d", pdoh, pdoh->_eSecureLock);
    }
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnObjectAvailable(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk)
{
    BSCMSG(TEXT("OnObjectAvailable (riid,punk)"), riid, punk);

    CDocObjectHost * pdoh = IToClass(CDocObjectHost, _bsc, this);

#ifdef DEBUG
    extern DWORD g_dwPerf;
    PERFMSG(TEXT("OnObjectAvailable called"), GetCurrentTime()-g_dwPerf);
    g_dwPerf = GetCurrentTime();
#endif

    //  If we get this far, DocObject has been inited by UrlMon or
    //  in process of retrieving pending object via IOleCommandTarget::Exec()
    if (pdoh->_punkPending)
    {
        pdoh->_fPendingNeedsInit = 0;
    }

    //
    //  When this notification is called first time, we should ask
    // the browser to activate us (which causes BindToObject).
    //
    if (pdoh->_pole==NULL && punk)
    {
        HRESULT hresT = punk->QueryInterface(IID_IOleObject, (LPVOID*)&(pdoh->_pole));

        if (SUCCEEDED(hresT))
        {
            IOleDocument * pmsod = NULL;

            pdoh->_OnBound(S_OK);

            hresT = (pdoh->_fDontInPlaceNavigate() ? E_NOINTERFACE : punk->QueryInterface(IID_IOleDocument, (LPVOID*)&pmsod));

            if (SUCCEEDED(hresT))
            {
                pmsod->Release();       // We don't use it at this point.

                // Case 1: DocObject
                OPENMSG(TEXT("OnObjectAvailable ASYNC DocObject"));

                ASSERT(pdoh->_psb);

                if (pdoh->_pmsoctBrowser)
                {
                    VARIANT var = {0};
                    VARIANT varOut = {0};

                    // Tell the host that we know this is a document object. 
                    V_VT(&var) = VT_BOOL;
                    V_BOOL(&var) = VARIANT_TRUE;

                    pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD, 0, &var, &varOut);
                }

#ifdef FEATURE_PICS
                BOOL fSupportsPICS = FALSE;

                if (pdoh->_PicsProcBase._fbPicsWaitFlags)
                {
                    VARIANTARG v;
                    v.vt = VT_UNKNOWN;
                    v.byref = (LPVOID)(IOleCommandTarget *)&pdoh->_PicsProcBase;

                    hresT = IUnknown_Exec(pdoh->_pole, &CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
                    if (hresT == S_OK)
                    {
                        BSCMSG(TEXT("OnObjectAvailable - obj supports PICS"), 0, 0);
                        fSupportsPICS = TRUE;
                    }
                    else
                    {
                        BSCMSG(TEXT("OnObjectAvailable - obj either doesn't support IOleCommandTarget or doesn't support PICS"), hresT, 0);
                    }
                }
#endif
                BSCMSG(TEXT("OnObjectAvailable calling pdoh->_Navigate"), 0, 0);

                pdoh->_SetUpTransitionCapability();
                
                _UpdateSSLIcon();
#ifdef FEATURE_PICS
                // If we can't get labels out of the document (or don't need
                // to, because we already got one from a bureau or HTTP header),
                // see if we can complete PICS checking now.
                //
                if (!fSupportsPICS)
                {
                    pdoh->_PicsProcBase._fbPicsWaitFlags &= ~(PICS_WAIT_FOR_INDOC | PICS_WAIT_FOR_END);   /* no indoc ratings */

                    if (!pdoh->_PicsProcBase._fbPicsWaitFlags)
                    {
                        TraceMsg(DM_PICS, "OnObjectAvailable calling _HandlePicsChecksComplete");
                        pdoh->_PicsProcBase._HandlePicsChecksComplete();
                    }
                }
#endif
            }
            else
            {
                // Case 2: OLE object

                OPENMSG(TEXT("OnDataAvailable ASYNC OLE Object"));
                pdoh->_ActivateOleObject();
                
                // We need to tell the browser not to add this one to the
                // browse history.
                // We also want to close the browser window if this is the first
                // download - that's why we pass TRUE - to treat it like a code
                // download
                //
                if (pdoh->_dwAppHack & BROWSERFLAG_DONTAUTOCLOSE)
                {
                    pdoh->_CancelPendingNavigation(FALSE);
                }
                else
                {
                    pdoh->_CancelPendingNavigation(TRUE, FALSE, FALSE, TRUE);
                }

                if (pdoh->_fDelegatedNavigation)
                {
                    VARIANT        varOut = {0};
                    IDocNavigate * pDocNavigate;

                    pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView,
                                               SHDVID_FIREFILEDOWNLOAD,
                                               0, NULL, &varOut);

                    HRESULT hr = E_FAIL;
                    
                    if ( pdoh->_pwb )
                    {
                        hr = pdoh->_pwb->QueryInterface(IID_PPV_ARG(IDocNavigate, &pDocNavigate));
                    }

                    if (S_OK == hr)
                    {
                        pDocNavigate->OnReadyStateChange(NULL, READYSTATE_COMPLETE);
                        pDocNavigate->Release();
                    }
                }

                //
                // If this is the very first page, we should draw the background.
                //
                pdoh->_fDrawBackground = TRUE;

                //If the following assert is hit, then that means that we are
                // going to invalidate the desktop window (which is not
                // intended here)
                //
                ASSERT(pdoh->_hwnd);
                InvalidateRect(pdoh->_hwnd, NULL, TRUE);
            }

        }
        else
        {
            _fBoundToNoOleObject = TRUE;
        }
    }


    // Add privacy info to Trident's list if possible
    if (_fBoundToMSHTML)
    {
        HRESULT               hRes             = E_FAIL;
        IServiceProvider    * pSP              = NULL;
        IPrivacyServices    * pPrivacyServices = NULL;
        DWORD                 dwTopLevelFlag   = 0;

        // QueryService the Trident for the IPrivacyServices interface
        hRes = pdoh->_pole->QueryInterface(IID_IServiceProvider, (void**)&pSP);
        if (SUCCEEDED(hRes) && pSP)
        {
            hRes = pSP->QueryService(IID_IPrivacyServices,IID_IPrivacyServices,(void**)&pPrivacyServices);
            pSP->Release();
        }
        
        if (pPrivacyServices)
        {
            if (pdoh->_psp && pdoh->_psb && IsTopFrameBrowser(pdoh->_psp, pdoh->_psb))
            {
                dwTopLevelFlag |= PRIVACY_URLISTOPLEVEL;
            }

            // Add dummy marker since Trident would have added its records during the BindToStorage call
            // initiated due to shdocvw's current bind only if we are top level
            if (dwTopLevelFlag)
                pPrivacyServices->AddPrivacyInfoToList( TEXT(""), NULL, NULL, 0, PRIVACY_URLISTOPLEVEL);

            // Add each item in the privacy queue (accumulated from redirections) to Trident's list
            CPrivacyRecord *pPrivacyRecord = _privacyQueue.Dequeue();
            
            if (pPrivacyRecord)
            {
                while (pPrivacyRecord)
                {
                    pPrivacyRecord->_dwPrivacyFlags |= dwTopLevelFlag;

                    pPrivacyServices->AddPrivacyInfoToList( pPrivacyRecord->_pszUrl, pPrivacyRecord->_pszPolicyRefUrl, pPrivacyRecord->_pszP3PHeader, 
                                                            0, pPrivacyRecord->_dwPrivacyFlags);
                    delete pPrivacyRecord;

                    // Add the dummy marker separating top level records if this is top level
                    if (dwTopLevelFlag)
                        pPrivacyServices->AddPrivacyInfoToList( TEXT(""), NULL, NULL, 0, PRIVACY_URLISTOPLEVEL);

                    pPrivacyRecord = _privacyQueue.Dequeue();
                }
                // Add the last one redirected url from the class itself since this was not added to the list
                _dwPrivacyFlags |= dwTopLevelFlag;
                pPrivacyServices->AddPrivacyInfoToList(_pszRedirectedURL, _pszPolicyRefURL, _pszP3PHeader, 0, _dwPrivacyFlags);
            }
            else
            {
                TCHAR szUrl[MAX_URL_STRING];
                szUrl[0] = TEXT('\0');
        
                // Get the url used for binding
                if (pdoh->_pidl)
                {
                    hRes = IEGetDisplayName(pdoh->_pidl, szUrl, SHGDN_FORPARSING);
                }
                else
                {
                    LPOLESTR pwUrl = NULL;
                    hRes = pdoh->_GetCurrentPageW(&pwUrl, TRUE);
                    if (SUCCEEDED(hRes))
                    {        
                        StrCpyN(szUrl, pwUrl, MAX_URL_STRING);
                        OleFree(pwUrl);
                    }
                }

                if (SUCCEEDED(hRes))
                {
                    _dwPrivacyFlags |= dwTopLevelFlag;
                    pPrivacyServices->AddPrivacyInfoToList(szUrl, _pszPolicyRefURL, _pszP3PHeader, 0, _dwPrivacyFlags);
                }
            }

            pPrivacyServices->Release();
        }
    }

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        _pbscChained->OnObjectAvailable(riid, punk);
    }
#endif
    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnLowResource(DWORD reserved)
{
    BSCMSG(TEXT("OnLowResource"), 0, 0);

#ifndef NO_DELEGATION
    if (_pbscChained) {
        _pbscChained->OnLowResource(reserved);
    }
#endif
    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                DWORD dwReserved, LPWSTR __RPC_FAR * ppwzAdditionalHeaders)
{
    HRESULT hres;

#ifndef NO_DELEGATION
    if (_pnegotiateChained) {
        hres = _pnegotiateChained->BeginningTransaction(szURL, szHeaders, dwReserved, ppwzAdditionalHeaders);
    }
    else
    {
#endif
        //  Here we pass headers to URLMon

        hres=BuildAdditionalHeaders((LPCTSTR) _pszHeaders,(LPCWSTR *) ppwzAdditionalHeaders);

#ifndef NO_DELEGATION
    }
#endif
    return hres;
}


const WCHAR g_wszPicsLabel[] = L"\r\nPICS-Label:";

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
                            LPCWSTR szRequestHeaders,
                            LPWSTR *pszAdditionalRequestHeaders)
{
#ifndef NO_DELEGATION
    if (_pnegotiateChained) {
        _pnegotiateChained->OnResponse(dwResponseCode, szResponseHeaders, szRequestHeaders, pszAdditionalRequestHeaders);
    }
    else
    {
#endif

#ifndef NO_DELEGATION
    }
#endif

#ifdef FEATURE_PICS
    /* CODEWORK: For next release, all response headers should be handled
     * generically through _OnHttpEquiv, and rating labels should be
     * processed there instead of through a private IOleCommandTarget
     * interface with Trident.
     */

    /* NOTE: We still need to check for the PICS label header here, even
     * if we chained to Trident or whoever above.
     */

    // (jbeda) this _dwPicsLabelSource stuff looks really screwy...
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    if (pdoh->_PicsProcBase._fbPicsWaitFlags & PICS_WAIT_FOR_INDOC) {
        LPCWSTR pwszPicsLabel = StrStrW(szResponseHeaders, g_wszPicsLabel);
        if (pwszPicsLabel != NULL) {
            pdoh->_PicsProcBase._dwPicsLabelSource=PICS_LABEL_FROM_HEADER;
            pwszPicsLabel += ARRAYSIZE(g_wszPicsLabel); /* skip \r\n and label name */
            LPCWSTR pwszPicsLabelEnd = StrChrW(pwszPicsLabel, L'\r');
            if (pwszPicsLabelEnd == NULL) {
                // NOTE: lstrlenW doesn't work on Win95, so we do this manually.
                for (pwszPicsLabelEnd = pwszPicsLabel;
                     *pwszPicsLabelEnd;
                     pwszPicsLabelEnd++)
                    ;
            }
            if (pwszPicsLabel && (pwszPicsLabelEnd > pwszPicsLabel))
            {
                WCHAR* pszLabel = new WCHAR[((int)(pwszPicsLabelEnd - pwszPicsLabel)) + 1];

                if (pszLabel)
                {
                    //
                    // pwszPicsLabel may not be NULL terminated so use memcpy to
                    // move it.  Memory allocated by new is zero filled so
                    // pszLabel doesn't have to have L'\0' appeneded.
                    //
                    memcpy(pszLabel, pwszPicsLabel,
                           ((int)(pwszPicsLabelEnd - pwszPicsLabel)) * sizeof(WCHAR));
                    pdoh->_PicsProcBase._HandleInDocumentLabel(pszLabel);

                    delete pszLabel;
                }
            }
        }
        else
        {
            pdoh->_PicsProcBase._dwPicsLabelSource=PICS_LABEL_FROM_PAGE;
        }
    }
#endif

    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::GetWindow(REFGUID rguidReason, HWND* phwnd)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);

    if (!phwnd)
        return E_POINTER;

    if (pdoh->_psb) {
        pdoh->_psb->GetWindow(phwnd);
    } else {
        *phwnd = pdoh->_hwnd;
    }

    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnSecurityProblem(DWORD dwProblem)
{
    // force UI - return S_FALSE for all problems
    return S_FALSE;
}


HRESULT CDocObjectHost::CDOHBindStatusCallback::_HandleSelfAssociate(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    HRESULT hres;
    IPersistMoniker* ppmk;
    hres = pdoh->_CoCreateHTMLDocument(IID_IPersistMoniker, (LPVOID*)&ppmk);

    if (SUCCEEDED(hres)) {
        BIND_OPTS bindopts;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        hres = _pbc->GetBindOptions(&bindopts);
        if (SUCCEEDED(hres)) {
            hres = ppmk->Load(FALSE, pdoh->_pmkCur, _pbc, bindopts.grfMode);
            if (SUCCEEDED(hres)) {
                ASSERT(NULL==pdoh->_pole);
                hres = ppmk->QueryInterface(IID_IOleObject, (LPVOID*)&pdoh->_pole);
                if (SUCCEEDED(hres)) {
                    pdoh->_InitOleObject();

                    TraceMsg(DM_SELFASC, "DOH::_HandleSelfAssociate self-association is working");
                    pdoh->_Navigate();
                    pdoh->_SetUpTransitionCapability();
                    _UpdateSSLIcon();
                } else {
                    TraceMsg(DM_WARNING, "DOH::_HandleSelfAssociate ppmk->QI(IOleObject) failed (%x)", hres);
                }
            } else {
                TraceMsg(DM_WARNING, "DOH::_HandleSelfAssociate ppmk->Load failed (%x)", hres);
            }
        } else {
            TraceMsg(DM_WARNING, "DOH::_HandleSelfAssociate _pbc->GetBindOptions failed (%x)", hres);
        }
        ppmk->Release();
    } else {
        TraceMsg(DM_WARNING, "DOH::_HandleSelfAssociate CoCreateInst failed (%x)", hres);
    }

    return hres;
}


#define BUG_EXEC_ON_FAILURE     //nash:31526

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnStopBinding(HRESULT hrError,
            LPCWSTR szError)
{
    BSCMSG(TEXT("OnStopBinding"), this, hrError);

    _fBinding = FALSE;

    CDocObjectHost * pdoh = IToClass(CDocObjectHost, _bsc, this);
    LPWSTR   pwzHeaders = NULL;
    BOOL     fShouldDisplayError = TRUE;
    DWORD    dwStatusCode = 0;       // We use 0 to mean no status yet
    DWORD    dwStatusCodeSize = sizeof(dwStatusCode);
    BOOL     bSuppressUI = FALSE;
    BOOL     fAsyncDownload = FALSE;
    BOOL     fAborted = _fAborted;
    BOOL     fCancelAutoSearch = FALSE;
    BOOL     fNavigateErrorFired = FALSE;    // I cannot tell if _HandleHttpErrors are really mutually exclusive from the AutoSearching.
                                             // Therefore I am adding a flag to make sure we don't fire NavigateError twice.

    _fAborted = FALSE;

    _privacyQueue.Reset();
    ResetPrivacyInfo();

    //
    //  this is to protect against urlmons behavior of returning 
    //  an async error and sync error on the same call.
    if (pdoh->_fSyncBindToObject && FAILED(hrError))
    {
        pdoh->_hrOnStopBinding = hrError;
        return S_OK;
    }

    // if aborting to let Document.Write work...pretend everything is cool
    if (_fDocWriteAbort && hrError == E_ABORT) hrError = S_OK;

    // Why not use the cached value?
    // pdoh->_GetOfflineSilent(0, &bSuppressUI);
    bSuppressUI = (_bFrameIsSilent || _IsDesktopItem(pdoh)) ? TRUE : FALSE;

    _bindst = 0;    // go back to the normal state

    if (_pbc && pdoh->_punkPending)
    {
        _pbc->RevokeObjectParam(L"__PrecreatedObject");
    }

    if (!_pbc)
    {
        ASSERT(0);
        return S_OK;
    }

    // NOTES: Guard against last Release by _RevokeObjectParam
    AddRef();

    if (pdoh->_pwb)
    {
        pdoh->_pwb->SetNavigateState(BNS_NORMAL);
    }

    if (pdoh->_psb)
    {   // paranoia
        pdoh->_psb->SetStatusTextSB(NULL);
    }

    BSCMSG("OnStopBinding calling _RevokeObjectParam", this, _pbc);
    _RevokeObjectParam(_pbc);
    _pbc->RevokeObjectParam(WSZGUID_OPID_DocObjClientSite);

    //
    //  If the error code is a mapped error code (by URLMON), get the
    // real error code from IBinding for display purpose.
    //
    HRESULT hrDisplay = hrError;    // assume they are the same

#define ENABLE_WHEN_GETBINDRESULT_STARTS_WORKING
#ifdef ENABLE_WHEN_GETBINDRESULT_STARTS_WORKING

    if (hrError>=INET_E_ERROR_FIRST && hrError<=INET_E_ERROR_LAST)
    {
        //
        //  We come here when _pib==NULL, if URLMON synchronously fails
        // (such as a bad protocol).
        //
        // ASSERT(_pib);
        //
        if (_pib)
        {
            CLSID clsid;
            LPWSTR pwszError = NULL;

            HRESULT hresT=_pib->GetBindResult(&clsid, (DWORD *)&hrDisplay, &pwszError, NULL);
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding called GetBindResult %x->%x (%x)", hrError, hrDisplay, hresT);

            if (SUCCEEDED(hresT))
            {
                //
                // URLMON returns a native Win32 error.
                //
                if (hrDisplay && SUCCEEDED(hrDisplay))
                {
                    hrDisplay = HRESULT_FROM_WIN32(hrDisplay);
                }

                //
                // URLMON is not supposed to return 0 as the error code,
                //  which causes a "successfully done" error msgbox. 
                //
                AssertMsg(hrDisplay != S_OK, TEXT("Call JohannP if you see this assert."));

                if (pwszError)
                {
                    OleFree(pwszError);
                }
            }
        }
    }
#endif

    TraceMsg(TF_SHDBINDING, "DOH::BSC::OnStopBinding binding failed %x (hrDisplay=%x)", hrError, hrDisplay);

    //
    // HACK: If the object is associated with IE/Shell itself, but has
    //  no CLSID, we'll force MSHTML.
    //
    // if (_fSelfAssociated && (hrError==MK_E_INVALIDEXTENSION || hrError==REGDB_E_CLASSNOTREG)) {
    //     hrError = _HandleSelfAssociate();
    // }

    if (_pib)
    {

        //  we dont need to do the expiry stuff here anymore.
        //  now mshtml should be doing it through the IPersistHistory

        // get the expire info
        // The HTTP rules for expiration are
        // Expires: 0               expire immediately
        // if Expires: <= Date:     expire immediately
        // if Expires: bad format   expire immediately

        IWinInetHttpInfo * phi;

        if (SUCCEEDED(_pib->QueryInterface(IID_IWinInetHttpInfo, (LPVOID*)&phi)))
        {
            BYTE  abBuffer[256]; // We don't care about this data, just
            DWORD cbBuffer=sizeof(abBuffer); // whether it exists or not

            if (phi->QueryInfo(HTTP_QUERY_LAST_MODIFIED, &abBuffer, &cbBuffer, NULL, 0) == S_OK)
                pdoh->_fhasLastModified = TRUE;

            if (phi->QueryInfo(HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &dwStatusCode, &dwStatusCodeSize, NULL, 0) != S_OK)
            {
                dwStatusCode = 0;       // failed to get status code
                dwStatusCodeSize = 0;   // failed to get status code
            }

            // This code will decide if we should display a popup error;
            // essentially, it detects if we can reasonably assume that
            // HTML was returned in the error case; if so, we believe that
            // it is an error page, so we let that display rather than a
            // popup.

            if (dwStatusCode)
            {
                 // We got a status code; let's see if we have a
                 // content-type.

                 // HTTP retcode 204 is a "succeeded, do nothing" retcode
                 // So we should always suppress the popup; further, it is
                 // spec'd to NEVER have content, so we do this before checking
                 // for content-type.
                 // So is 100
                 // 100 is not in wininet.h
                 if (dwStatusCode == HTTP_STATUS_NO_CONTENT)
                     fShouldDisplayError = FALSE;

                 // what is max header size?
                 CHAR  szContentType[1024];
                 DWORD dwContentTypeSize = sizeof(szContentType);

                 // This code handles a bug in URLMON where it tells us 
                 // INET_E_DATA_NOT_AVAILABLE when in fact the
                 // data _was_ available.  We don't want any future 
                 // errors affected by this, so we restrict this
                 // hack to less than 600, and ONLY for the 
                 // INET_E_DATA_NOT_AVAILABLE case.

                 if (hrError == INET_E_DATA_NOT_AVAILABLE && 
                     dwStatusCode < 600 &&
                     phi->QueryInfo(HTTP_QUERY_CONTENT_TYPE, &szContentType, 
                                    &dwContentTypeSize, NULL, 0) == S_OK)
                 {
                     fShouldDisplayError = FALSE;
                 }

                //
                // Handle http errors.
                //

                // Let's wrap the firing in case it is not the first attempt in future

                if (dwStatusCode >= 400 && dwStatusCode <= 599)
                {
                    if (!fNavigateErrorFired)
                    {
                        pdoh->_FireNavigateErrorHelper(NULL, dwStatusCode, &fCancelAutoSearch);
                        fNavigateErrorFired = TRUE;
                    }
                    
                    if (!fCancelAutoSearch)
                    {
                        _HandleHttpErrors(dwStatusCode, _cbContentLength, pdoh);
                    }
                    else if (!pdoh->_fCanceledByBrowser)
                    {
                        pdoh->_CancelPendingNavigation(FALSE, FALSE);
                    }
                }
            }

            phi->Release();
        }

        ATOMICRELEASE(_pib);
    }

    ATOMICRELEASE(_psvPrev);

    //
    //  If the object does not support IOleObject, treat it as if we failed
    // to bind.
    //
    if (_fBoundToNoOleObject)
    {
        ASSERT(SUCCEEDED(hrError));
        hrError = MK_E_INVALIDEXTENSION;
    }

    // need to handle navigation in successful proxy response but w/
    // 404 error.  tonyci 13nov96.  for autosearching & autosuffixing

    if (FAILED(hrError)) 
    {
        BOOL fAddToMRU = FALSE;
        pdoh->_fDrawBackground = TRUE;

        TCHAR szURL[MAX_URL_STRING+1];
        szURL[0] = TEXT('\0');

        //
        //  It seems that in some of the case of hrError the code counts on dwStatusCode being set
        //  dwStatus is set exactly when the real error code was obtained from IBinding for display purpose
        //  For the other case I am going to use hrError
        //

        if (!fNavigateErrorFired)
        {
            if (dwStatusCode)
            {
                pdoh->_FireNavigateErrorHelper(NULL, dwStatusCode, &fCancelAutoSearch);
                fNavigateErrorFired = TRUE;
            }
            else if (hrError>=INET_E_ERROR_FIRST && hrError<=INET_E_ERROR_LAST)
            {
                pdoh->_FireNavigateErrorHelper(NULL, hrError, &fCancelAutoSearch);
                fNavigateErrorFired = TRUE;
            }
        }

        if (pdoh->_pmkCur)
        {
            pdoh->_GetCurrentPage(szURL,ARRAYSIZE(szURL));
        }

        TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding hrError=%x", hrError);
        
        pdoh->_OnSetProgressPos(0, PROGRESS_RESET);

        switch(hrError)
        {
        //
        //  If pmk->BindToObject is failed because of "binding", we should
        // offer an option to download it as a file.
        //

#ifdef BUG_EXEC_ON_FAILURE
        case INET_E_CANNOT_INSTANTIATE_OBJECT:
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding IDS_ERR_OLESVR");
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
            goto Lexec;

        case INET_E_CANNOT_LOAD_DATA:
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding IDS_ERR_LOAD");
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
            goto Lexec;
#else
        case INET_E_CANNOT_INSTANTIATE_OBJECT:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            if (MLShellMessageBox(pdoh->_hwnd,
                            MAKEINTRESOURCE(IDS_ERR_OLESVR),
                            MAKEINTRESOURCE(IDS_TITLE),
                            MB_YESNO|MB_ICONERROR,
                            szURL) == IDYES)
            {
                IUnknown * punk;
                HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                if(SUCCEEDED(hresT))
                {
                    if (!fAborted)
                    {
                        CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);
                    }

                    punk->Release();
                }
            }

            break;

        case INET_E_CANNOT_LOAD_DATA:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            // e.g. click on .xls link when doc already open/modified/locked
            // and say 'cancel'
            //
            if (MLShellMessageBox(pdoh->_hwnd,
                            MAKEINTRESOURCE(IDS_ERR_LOAD),
                            MAKEINTRESOURCE(IDS_TITLE),
                            MB_YESNO|MB_ICONERROR,
                            szURL) == IDYES) 
            {
                IUnknown *punk;
                HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);
                if(SUCCEEDED(hresT))
                {
                    if (!fAborted)
                    {
                        CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);
                    }

                    punk->Release();
                }
            }

            break;
#endif

        //
        // NOTES: According to JohannP, URLMON will give us
        //  REGDB_E_CLASSNOTREG. I'll leave MK_E_INVALIDEXTENSION
        //  to be compatible with old URLMON (which is harmless).
        //
        case MK_E_INVALIDEXTENSION:
        case REGDB_E_CLASSNOTREG:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

#ifdef BUG_EXEC_ON_FAILURE
    Lexec: // nash:31526
            // for various instantiation errors:
            // - for ie3 we suppress messages and force a ShellExec as a
            // 2nd try, pretty much always
            // - for ie4 we should be more selective (nash:31526)
#endif

#ifdef FEATURE_PICS
            // For data types that don't have a CLSID, we never get a chance
            // to block in the CLASSIDAVAILABLE OnProgress notification, so
            // we have to block here.  However, avoid blocking documents such
            // as HTML which we want to download completely so we can get
            // ratings strings out of them.
            //
            if (!pdoh->_fPicsBlockLate && (pdoh->_PicsProcBase._fbPicsWaitFlags || !pdoh->_PicsProcBase._fPicsAccessAllowed))
            {
                pdoh->_PicsProcBase._fbPicsWaitFlags &= ~(PICS_WAIT_FOR_INDOC | PICS_WAIT_FOR_END);   /* make sure we don't expect indoc ratings */
                TraceMsg(DM_PICS, "OnStopBinding calling _PicsBlockingDialog, waitflags now %x", (DWORD)pdoh->_PicsProcBase._fbPicsWaitFlags);

                if (pdoh->_PicsProcBase._PicsBlockingDialog() != IDOK)
                {
                    TraceMsg(DM_PICS, "OnStopBinding, PICS canceled, calling _CancelPendingNavigation");
                    pdoh->_CancelPendingNavigation(FALSE);
                    break;
                }
            }
#endif

            BeginningTransaction (NULL, NULL, 0, &pwzHeaders);

            if (_dwBindVerb==BINDVERB_POST)
            {
                // This is a POST. Do it use the same moniker (modeless)
                //
                // Notes: The ownership of the data in pbinfo will be transfered
                //  to CDownLoad_OpenUIPost. Therefore, we should not call
                //  ReleaseBindInfo(pbinfo) here.
                //
                DWORD grfBINDF;

                // The BINDINFO can not be on the stack since it will be freed by the
                // download thread.
                //
                BINDINFO * pbinfo = (BINDINFO*)LocalAlloc(LPTR, SIZEOF(BINDINFO));

                if (!pbinfo)
                {
                    return E_OUTOFMEMORY;
                }

                pbinfo->cbSize = SIZEOF(BINDINFO);
                GetBindInfo(&grfBINDF, pbinfo);

                // If our POST was really a redirected POST, it will have
                // turned into a GET.  In this case, we need to release
                // ownership of the data and pretend like the whole thing
                // was a GET to start with.

                if (pbinfo->dwBindVerb==BINDVERB_GET)
                {
                    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

                    ASSERT(_pszRedirectedURL);

                    SHTCharToUnicode(_pszRedirectedURL, wszUrl, ARRAYSIZE(wszUrl));

                    IUnknown * punk;
                    HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        VARIANT varOut = {0};

                        pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD,
                                                   0, NULL, &varOut);

                        if (V_VT(&varOut) != VT_BOOL || V_BOOL(&varOut) == VARIANT_FALSE)
                        { 
                            if (!fAborted)
                            {
                                CDownLoad_OpenUIURL(wszUrl, NULL, pwzHeaders, 
                                                 FALSE /* fSync */, FALSE /* fSaveAs */, pdoh->_fCalledMayOpenSafeDlg,
                                                 NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);

                                pwzHeaders = NULL;   // ownership is to CDownload now
                            }
                        }

                        punk->Release();
                    }

                    ReleaseBindInfo(pbinfo); // This one is OK since we did not pass the pbinfo
                    LocalFree(pbinfo);       // and we can free it 
                    pbinfo = NULL;
                }
                else
                {

                    ASSERT(pbinfo->dwBindVerb==BINDVERB_POST);

                    // Collect the headers associated with this xact
                    IUnknown * punk;
                    HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        VARIANT varOut = {0};

                        pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD,
                                                   0, NULL, &varOut);

                        if (V_VT(&varOut) != VT_BOOL || V_BOOL(&varOut) == VARIANT_FALSE)
                        {
                            if (!fAborted)
                            {
                                CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE /* fSync */, FALSE /* fSaveAs */, pdoh->_fCalledMayOpenSafeDlg /* fSafe */, pwzHeaders, BINDVERB_POST, grfBINDF, pbinfo, _pszRedirectedURL, pdoh->_uiCP, punk);

                                pwzHeaders = NULL;   // ownership is to CDownload now
                            }
                        }

                        punk->Release();
                    }

                    TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding just called CDownLoad_OpenUIPost");

                    // NOTE: t-gpease 8-18-97
                    // Do not ReleaseBindInfo(pinfo) because it is used by the download thread.
                    // The thread is responsible for releasing it.
                }

            }
            else
            {
                // Otherwise, spawn another thread and get it there.

                // NOTE: If UnBind gets called then pdoh->_pmkCur will be NULL
                // and URLMON is most likely returning a bogus error code.  So
                // we'll check the pointer and prevent from blowing up.

                if (pdoh->_pmkCur)
                {
                    BOOL fSafe = pdoh->_fCalledMayOpenSafeDlg;

                    IBrowserService * pbs;

                    if (PathIsFilePath(szURL) && 
                        SUCCEEDED(pdoh->QueryService(SID_STopFrameBrowser, IID_IBrowserService, (LPVOID *)&pbs)))
                    {
                        DWORD dwFlags;

                        if (SUCCEEDED(pbs->GetFlags(&dwFlags)) && (dwFlags & BSF_NOLOCALFILEWARNING))
                        {
                            fSafe = TRUE;
                        }

                        pbs->Release();
                    }

                    IUnknown *punk;
                    HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        VARIANT varOut = {0};

                        pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD,
                                                   0, NULL, &varOut);

                        if (V_VT(&varOut) != VT_BOOL || V_BOOL(&varOut) == VARIANT_FALSE)
                        {
                            if (pdoh->_pmsoctBrowser && pdoh->_fWindowOpen)
                            {
                                pdoh->_pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELANDCLOSE, 0, NULL, NULL);
                            }

                            if (!fAborted)
                            {
                                CDownLoad_OpenUI(pdoh->_pmkCur, pdoh->_pbcCur, FALSE, FALSE,
                                                fSafe, pwzHeaders, NULL, pdoh->_bsc._dwBindf, NULL, _pszRedirectedURL,
                                                pdoh->_uiCP, punk, pdoh->_fConfirmed);
                
                                pwzHeaders = NULL;   // ownership is to CDownload now
                            }
                        }
                        punk->Release();
                    }

                    fAsyncDownload = TRUE;
                }
            }

            if (pwzHeaders)
            {
                CoTaskMemFree(pwzHeaders);
            }

            break;

        // URLMON failed to bind because it didn't know what to do with
        // with this URL.  Lets check and see if the Shell should handle
        // it via a helper app (news:, mailto:, telnet:, etc.)
        case INET_E_UNKNOWN_PROTOCOL:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            {
                // If we've been redirected, use that URL
                //
                if (_pszRedirectedURL)
                {
                    StrCpyN(szURL, _pszRedirectedURL, ARRAYSIZE(szURL));
                }

                // Here we check to see if it is a URL we really want to shellexecute
                // so it is handled by helper apps.....else it really is an error
                if (ShouldShellExecURL(szURL))
                {
                    // We can add this to the address bar MRU 
                    fAddToMRU = TRUE;

                    // We need to decode this before passing it on to someone.

                    TCHAR szDecodedURL[INTERNET_MAX_URL_LENGTH];
                    DWORD cchDecodedURL = ARRAYSIZE(szDecodedURL);

                    // REVIEW: NT 319480 IE 54850 - need to append _pszLocation back to pszBadProtoURL...
                    //
                    // I assume the string was escaped when it came from urlmon, so we need
                    // to append it before PrepareURLForExternalApp.
                    //
                    // Note: if the url had been redirected above, _pszLocation has been updated
                    // to the new redirected URL, so we still want to append it.
                    //
                    if (pdoh->_pszLocation)
                    {
                        StrCatBuff(szURL, pdoh->_pszLocation, ARRAYSIZE(szURL));
                    }

                    PrepareURLForExternalApp(szURL, szDecodedURL, &cchDecodedURL);

                    // PathQuoteSpaces(szDecodedURL);

                    SHELLEXECUTEINFO sei = {0};

                    sei.cbSize = sizeof(sei);
                    sei.lpFile = szDecodedURL;
                    sei.nShow  = SW_SHOWNORMAL;

                    if (!ShellExecuteEx(&sei))
                    {
                        if(!bSuppressUI)
                        {
                            IE_ErrorMsgBox(pdoh->_psb, pdoh->_hwnd, hrDisplay, szError,
                                           szDecodedURL, IDS_CANTSHELLEX, MB_OK | MB_ICONSTOP );
                        }
                    }

                    //
                    //  We want to close the browser window if this is the
                    // very first navigation. 
                    //
                    fAsyncDownload = TRUE;
                }
                else if ((!bSuppressUI) && (!fCancelAutoSearch))
                {
                    _NavigateToErrorPage(ERRORPAGE_SYNTAX, pdoh, FALSE);
                }

                break;
            }

        case E_ABORT:
        case HRESULT_FROM_WIN32(ERROR_CANCELLED):
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            // If the binding was aborted or canceled and this is 
            // a navigation that was delegated from Trident, then
            // we must fire the FileDownload event so Trident won't
            // switch the markup.
            //
            if (pdoh->_fDelegatedNavigation && pdoh->_pmsoctBrowser)
            {
                VARIANT varOut = {0};

                pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD, 0, NULL, &varOut);
            }

            break;

#ifdef BUG_EXEC_ON_FAILURE
        case E_NOINTERFACE: // nash:31526
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding E_NOINTERFACE");
            goto Lexec;
#endif

        case INET_E_RESOURCE_NOT_FOUND:
        case INET_E_DATA_NOT_AVAILABLE:

            if (!fCancelAutoSearch)
            {
                if (_HandleFailedNavigationSearch(&fShouldDisplayError, dwStatusCode, pdoh, hrDisplay, (LPTSTR) &szURL, szError, _pib) != S_OK)
                {
                    fShouldDisplayError = TRUE;
                }
            }
            else if (!pdoh->_fCanceledByBrowser)
            {
                     pdoh->_CancelPendingNavigation(FALSE, FALSE);
            }

            // intentional fallthrough to default to popup if needed

        case INET_E_DOWNLOAD_FAILURE:
            if(IsGlobalOffline())
            {
                fShouldDisplayError = FALSE;
                break; 
            }

            // otherwise fall through to do default handling

        default:
            {
                if (fShouldDisplayError)
                {
                    _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
                    if  ((!bSuppressUI) && (!fCancelAutoSearch))
                    {
                        //
                        // If we're in a frame try to navigate in place.  This
                        // won't work if we're in a synchronous call
                        // (_fSetTarget).
                        //
                        BOOL fNavigateInPlace = pdoh->_fHaveParentSite && !pdoh->_fSetTarget;
                        _NavigateToErrorPage(ERRORPAGE_DNS, pdoh, fNavigateInPlace);
                    }
                }
            }
            break;

        }

        // Tell addressbar to not add this to its mru
        if (!fAddToMRU)
        {
            _DontAddToMRU(pdoh);
        }

        //
        // Prepare for the case where the container keep us visible
        // after hitting this code (Explorer does, IE doesn't).
        //
        pdoh->_fDrawBackground = TRUE;

        // In the case of quickly jumping to another link, we end up with
        // a _hwnd being NULL and we were invalidating the desktop. So,
        // I check for NULL here before calling InvalidateRect.
        if (pdoh->_hwnd)
        {
            InvalidateRect(pdoh->_hwnd, NULL, TRUE);
        }

        // Tell the browser to cancel the pending navigation only
        // if it has not been canceled by the browser itself.
        // and if the navigation wasn't delegated from the document.
        //
        if (!pdoh->_fCanceledByBrowser)
        {
            pdoh->_CancelPendingNavigation(fAsyncDownload, FALSE, pdoh->_fDelegatedNavigation);

            if (pdoh->_fDelegatedNavigation)
            {
                IDocNavigate * pDocNavigate;

                HRESULT hr = E_FAIL;
                
                if ( pdoh->_pwb )
                {
                    hr = pdoh->_pwb->QueryInterface(IID_PPV_ARG(IDocNavigate, &pDocNavigate));
                }

                if (S_OK == hr)
                {
                    pDocNavigate->OnReadyStateChange(NULL, READYSTATE_COMPLETE);
                    pDocNavigate->Release();
                }
            }
        }
        else
        {
            TraceMsg(TF_SHDNAVIGATE|TF_SHDPROGRESS, 
                "DOH::::OnStopBinding not calling _CancelPendingNav");
        }
    }
    else
    {
        BOOL bDidNavigate = FALSE;

        //  Might have redirected to mailto: or some other protocol handled by
        //  plugable protocol that does some magic (eg launch mail program) and
        //  reports OnStopBinding w/o going through OnObjectAvailable!
        if (NULL == pdoh->_pole && !pdoh->_fCanceledByBrowser)
        {
            pdoh->_CancelPendingNavigation(FALSE);
        }

        // It is still possible that our Proxy failed to find the server but
        // gave us HTML.  If this is the case, and the user has "find sites"
        // set, we should go ahead and start trying to do our automatic
        // navigation stuff.

        if (dwStatusCode && DO_SEARCH_ON_STATUSCODE(dwStatusCode))
        {
            if (!fCancelAutoSearch)
            {
                if (_HandleFailedNavigationSearch(&fShouldDisplayError, dwStatusCode, pdoh, hrDisplay, NULL, szError, _pib) == S_OK)
                {
                    bDidNavigate = TRUE;
                }
            }
            else if (!pdoh->_fCanceledByBrowser)
            {
                 pdoh->_CancelPendingNavigation(FALSE, FALSE);
            }
            // Note, since the Proxy will have given us HTML in this case,
            // we will never display an error dialog.
        }

        if (!bDidNavigate && !pdoh->_fDocCanNavigate)
        {
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            //  We can suppress this redundant call to Add to History if DocObject
            //  is MSHTML, since it will report readystate
            if (!_fBoundToMSHTML && pdoh->_pmkCur)
            {
                TCHAR  szUrl[MAX_URL_STRING+1];

                pdoh->_GetCurrentPage(szUrl,ARRAYSIZE(szUrl));

                if (pdoh->_pszLocation)
                {
                    StrCatBuff(szUrl, pdoh->_pszLocation, ARRAYSIZE(szUrl));
                }

                if (!bSuppressUI)
                {
                    BOOL fWriteHistory  = TRUE;
                    BOOL fSelectHistory = TRUE;

                    if (NULL != pdoh->_pocthf)
                    {
                        MSOCMD rgCmd[] = { { SBCMDID_WRITEHIST, 0 }, { SBCMDID_SELECTHISTPIDL, 0 } };

                        pdoh->_pocthf->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgCmd), rgCmd, NULL);

                        fWriteHistory  = BOOLIFY(rgCmd[0].cmdf & MSOCMDF_ENABLED);
                        fSelectHistory = BOOLIFY(rgCmd[1].cmdf & MSOCMDF_ENABLED);
                    }

                    AddUrlToUrlHistoryStg(szUrl,
                                          NULL, 
                                          pdoh->_pwb,
                                          fWriteHistory,
                                          fSelectHistory ? pdoh->_pocthf : NULL,
                                          pdoh->get_punkSFHistory(), NULL);
                }
            }
        } // if !bDidNavigate
    } // if failed(hrerror) ... else

    // Released here because we may need it for OpenUI() w/ POST verb
    ATOMICRELEASE(_pbc);

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        CHAINMSG("OnStopBinding", hrError);
        _pbscChained->OnStopBinding(hrError, szError);
    }
#endif

    ATOMICRELEASE(_pbscChained);
    ATOMICRELEASE(_pnegotiateChained);
    pdoh->_ResetStatusBar();

    ATOMICRELEASE(pdoh->_pbcCur);

    if (_pszHeaders)
    {
        LocalFree(_pszHeaders);
        _pszHeaders = NULL;
    }
    if (_hszPostData)
    {
        GlobalFree(_hszPostData);
        _hszPostData = NULL;
    }

    // NOTES: Guard against last Release by _RevokeObjectParam
    Release();

    return S_OK;
}

void CDocObjectHost::CDOHBindStatusCallback::AbortBinding(void)
{
    TraceMsg(TF_SHDPROGRESS, "CDOH::CBSC::AbortBinding called _pib=%x", _pib);

    if (_pib)
    {
        TraceMsg(0, "sdv TR AbortBinding Calling _pib->Abort");
        //
        // Notes: OnStopBinding(E_ABORT) will be called from _pib->Abort
        //
        HRESULT hresT = _pib->Abort();
        TraceMsg(TF_SHDBINDING, "sdv TR AbortBinding Called _pib->Abort (%x)", hresT);

        // URLMon may call our OnStopBinding asynchronously.
        ATOMICRELEASE(_pib);

        
        CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
        if(pdoh->_dwProgressPos)
        {
            pdoh->_ResetStatusBar();
            pdoh->_OnSetProgressPos(0, PROGRESS_RESET);
        }
    }
}

//
// NavigatesToErrorPage cancels the pending navigation and and navigates to
// an internal error page.
//

void CDocObjectHost::CDOHBindStatusCallback::_NavigateToErrorPage(DWORD dwError, CDocObjectHost* pdoh, BOOL fInPlace)
{
    ASSERT(IsErrorHandled(dwError));
    ASSERT(pdoh);

    // Security:  Release the pre-created object because we don't want
    // anyone to have access to the OM of the navigated error document
    // if they obtained the reference before the error navigation.
    // Releasing the reference prevents a parent window from getting keys
    // to the My Computer zone.

    pdoh->_ReleaseOleObject(FALSE);
    pdoh->_ReleasePendingObject(FALSE);

    //
    // pdoh->_pmkCur can be NULL if this is a "DNS" error and Unbind has already
    // been called.
    //

    if (pdoh->_pmkCur)
    {
        //
        // Save the url the user attempted to navigate to.  It will be used
        // to refresh the page.
        //

        if (pdoh->_pwszRefreshUrl)
        {
            OleFree(pdoh->_pwszRefreshUrl);
            pdoh->_pwszRefreshUrl = NULL;
        }

        pdoh->_pmkCur->GetDisplayName(pdoh->_pbcCur, NULL,
                                      &pdoh->_pwszRefreshUrl);
    }

    if ((NULL == pdoh->_pwszRefreshUrl) || !IsErrorUrl(pdoh->_pwszRefreshUrl))
    {
        // Build the error page url.
        //
        TCHAR szErrorUrl[MAX_URL_STRING];

        if (fInPlace)
        {
            HRESULT hr;

            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                   HINST_THISDLL,
                                   ML_CROSSCODEPAGE,
                                   (TCHAR *)c_aErrorUrls[EUIndexFromError(dwError)].pszUrl,
                                   szErrorUrl,
                                   ARRAYSIZE(szErrorUrl),
                                   TEXT("shdocvw.dll"));
            if (SUCCEEDED(hr))
            {
                //
                // Navigate to the error page.
                //

                IMoniker* pIMoniker;

                if (SUCCEEDED(MonikerFromString(szErrorUrl, &pIMoniker)))
                {
                    ASSERT(pIMoniker);
#ifdef DEBUG
                    pdoh->_fFriendlyError = TRUE;
#endif

                    pdoh->SetTarget(pIMoniker, pdoh->_uiCP, NULL, NULL, NULL, 0);

                    pIMoniker->Release();
                }
            }
        }
        else
        {
            const WCHAR* const pszFmt = L"#%s";
            HRESULT hr;

            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                   HINST_THISDLL,
                                   ML_CROSSCODEPAGE,
                                   (TCHAR *)c_aErrorUrls[EUIndexFromError(dwError)].pszUrl,
                                   szErrorUrl,
                                   ARRAYSIZE(szErrorUrl),
                                   TEXT("shdocvw.dll"));
            if (SUCCEEDED(hr))
            {
                int nLenWritten;

                // append the #<refresh URL>
                nLenWritten = lstrlen(szErrorUrl);
                wnsprintf(szErrorUrl + nLenWritten,
                          ARRAYSIZE(szErrorUrl) - nLenWritten,
                          pszFmt,
                          pdoh->_pwszRefreshUrl ? pdoh->_pwszRefreshUrl : L"");

                //
                // Cancel the server page and display the internal page instead.
                //

                if (!pdoh->_fCanceledByBrowser)
                    pdoh->_CancelPendingNavigation(FALSE);

                // Turn off the flag in the base browser that
                // indicates that the view should be reused.
                // We want a new view in this case.
                //
                if ( pdoh->_pwb )
                {
                    pdoh->_pwb->SetFlags(NULL, BSF_HTMLNAVCANCELED);
                }
                    
                pdoh->_DoAsyncNavigation(szErrorUrl);
                pdoh->_fCanceledByBrowser = TRUE;
            }
        }
    }
    return;
}

//
// Check if the user turned off friendly http errors.  Default is yes.
//

BOOL CDocObjectHost::CDOHBindStatusCallback::_DisplayFriendlyHttpErrors()
{
    BOOL fRet;

    DWORD dwType = REG_SZ;
    TCHAR  szYesOrNo[20];
    DWORD  cbSize = sizeof(szYesOrNo);

    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_MAIN,
                                         REGSTR_VAL_HTTP_ERRORS, &dwType,
                                         (LPVOID)szYesOrNo, &cbSize, FALSE,
                                         NULL, 0))
    {
        fRet = StrCmpI(szYesOrNo, L"no");
    }
    else
    {
        fRet = TRUE;
    }

    return fRet;
}

//
// Error handler
//

void CDocObjectHost::CDOHBindStatusCallback::_HandleHttpErrors(DWORD dwError, DWORD cbContentLength, CDocObjectHost* pdoh)
{
    // Tell addressbar to not add this to its mru
    _DontAddToMRU(pdoh);    
    if (IsErrorHandled(dwError))
    {
        pdoh->_fErrorPage = TRUE;
        //
        //  On a 4XX error display an internal page if the server returned a
        //  page smaller than the threshold value.  If the page is larger than
        //  the threshold, display it.
        //
        // If the content length is zero assume the server didn't send the
        // length.  In this case take the conservative approach and don't 
        // show our page.
        //

        if (cbContentLength != 0 &&
            cbContentLength <= _GetErrorThreshold(dwError))
        {
            if (_DisplayFriendlyHttpErrors())
                _NavigateToErrorPage(dwError, pdoh, TRUE);
        }
    }

    return;
}

//
// Informs the address bar to not put this page in its mru
//
void CDocObjectHost::CDOHBindStatusCallback::_DontAddToMRU(CDocObjectHost* pdoh)
{
    IDockingWindow* pdw = NULL;
    IOleCommandTarget* poct;

    if (pdoh->_psp &&
        SUCCEEDED(pdoh->_psp->QueryService(SID_SExplorerToolbar, IID_IDockingWindow, (LPVOID*)&pdw)))
    {
        if (SUCCEEDED(pdw->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&poct)))
        {
            // Get the URL we were navigating to
            LPWSTR pszUrl;
            if (pdoh->_pmkCur &&
                SUCCEEDED(pdoh->_pmkCur->GetDisplayName(pdoh->_pbcCur, NULL, &pszUrl)))
            {
                LBSTR::CString          strDisplay( pszUrl );

                VARIANT varURL = {0};

                varURL.vt      = VT_BSTR;
                varURL.bstrVal = strDisplay;

                poct->Exec(&CGID_Explorer, SBCMDID_ERRORPAGE, 0, &varURL, NULL);

                OleFree(pszUrl);
            }

            poct->Release();
        }
        pdw->Release();
    }
}

//
// Tells the addressbar that we are autosearching so that it can update
// the pending url in its mru
//
void CDocObjectHost::CDOHBindStatusCallback::_UpdateMRU(CDocObjectHost* pdoh, LPCWSTR pszUrl)
{
    IDockingWindow* pdw = NULL;
    IOleCommandTarget* poct;

    if (pdoh->_psp &&
        SUCCEEDED(pdoh->_psp->QueryService(SID_SExplorerToolbar, IID_IDockingWindow, (LPVOID*)&pdw)))
    {
        if (SUCCEEDED(pdw->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&poct)))
        {
            // Copy url to stack allocated bstr
            LBSTR::CString          strDisplay( pszUrl );

            VARIANT varURL = {0};

            varURL.vt      = VT_BSTR;
            varURL.bstrVal = strDisplay;

            poct->Exec(&CGID_Explorer, SBCMDID_AUTOSEARCHING, 0, &varURL, NULL);

            poct->Release();
        }
        pdw->Release();
    }
}

//
//  S_OK means we successfully did a navigation
//  S_FALSE means that we did everything ok, but did not navigate
//  E_* means some internal api failed.
//

HRESULT CDocObjectHost::CDOHBindStatusCallback::_HandleFailedNavigationSearch(
            LPBOOL           pfShouldDisplayError,
            DWORD            dwStatusCode,
            CDocObjectHost * pdoh,
            HRESULT          hrDisplay, 
            TCHAR          * szURL, 
            LPCWSTR          szError, 
            IBinding       * pib,
            BOOL             fAddMRU, /* = TRUE */
            BOOL             fFromTrident /* = FALSE */)
{
    DWORD                dwSearchForExtensions = NO_SUFFIXES;
    DWORD                dwDo404Search = PROMPTSEARCH;
    BOOL                 bAskUser = TRUE;  // rely on init
    BOOL                 bDoSearch = FALSE;  // rely on init
    HRESULT              hres = S_FALSE;
    BOOL                 bSuppressUI = FALSE;
    BOOL                 bFrameIsOffline = FALSE;
    BOOL                 bPrepareForSearch = FALSE;
    DWORD                dwSuffixIndex = 0;
    BOOL                 bAllowSearch = FALSE;
    BOOL                 bContinueSearch = FALSE;
    BOOL                 bSentToEngine = FALSE;
    BOOL                 bOnProxy = FALSE;  
    TCHAR                szSearchFormatStr[MAX_SEARCH_FORMAT_STRING];
    DWORD                dwSearchStyle = 3; // "display search results and navigate to the most likely site"

    ASSERT(pdoh);

#define SAFETRACE(psz)      (psz ? psz : TEXT(""))

    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() entered status = %d, url = %s, pib = %X", dwStatusCode, SAFETRACE(szURL) , pib);
    if (FAILED(GetSearchKeys(pdoh->_psp, &dwSearchStyle, &dwSearchForExtensions, &dwDo404Search)))
    {
        return E_FAIL;
    }
    
    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() dwSearch = %d, do404 = %d", dwSearchForExtensions, dwDo404Search);

    // Get any persistent information from the last request
    VARIANT varURL = {0};
    _GetSearchInfo(pdoh->_psp, &dwSuffixIndex, &bAllowSearch, &bContinueSearch, &bSentToEngine, &varURL);

    // See if window.external.autoscan() was called
    BOOL fAutoScan = (varURL.vt == VT_BSTR);

    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() index = %d, allow = %d, cont = %d, sent = %d", dwSuffixIndex, bAllowSearch, bContinueSearch, bSentToEngine);

    // Why not use the cached value?
    // pdoh->_GetOfflineSilent(&bFrameIsOffline, &bSuppressUI);
    bFrameIsOffline = _bFrameIsOffline ? TRUE : FALSE;
    bSuppressUI = (_bFrameIsSilent || _IsDesktopItem(pdoh)) ? TRUE : FALSE;

    // if we are at the end of the extension list, turn off extensions
    BOOL fAutoSearching = FALSE;
    if (dwSearchForExtensions)
    {
        if (dwSuffixIndex == 0 && dwSearchStyle != 0)
        {
            StrCpyN(szSearchFormatStr, L"? %s", ARRAYSIZE(szSearchFormatStr));
            fAutoSearching = TRUE;
        }
        else if (GetSearchFormatString(dwSuffixIndex, szSearchFormatStr, sizeof(szSearchFormatStr)) != ERROR_SUCCESS)
        {
            dwSearchForExtensions = DONE_SUFFIXES;
            StrCpyN(szSearchFormatStr, TEXT("%s"), ARRAYSIZE(szSearchFormatStr));
        }
    }
    else
    {
        dwSearchForExtensions = DONE_SUFFIXES;
    }

    // don't try a 404 srch if we are still trying suffixes
    if (dwSearchForExtensions == SCAN_SUFFIXES)
        dwDo404Search = NEVERSEARCH;

    {
        DWORD dwOptions;

        if (SUCCEEDED(_GetRequestFlagFromPIB(pib, &dwOptions)))
        {
            if (dwOptions & INTERNET_REQFLAG_VIA_PROXY)
            {
                bOnProxy = TRUE;
            }
        }
        else
        {
            TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() QI to IWinInetInfo failed");
        }
    }

    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() search = %d, do404 = %d, onproxy = %d, szSearch = %s", dwSearchForExtensions, dwDo404Search, bOnProxy, SAFETRACE(szSearchFormatStr));

    // Prepare to do an automatic search if the navigation failed
    // and we think a search might be valuable.

    // These cases are:
    //   (1) if the previous navigation was search-generated (bContinue)
    //   (2) the user allows searching (bAllow)
    //   (3) we are searching for extensions or autosearching
    //   (4) this is a status code we allow searching for
    //   (5) if over proxy, continue searching even on 404

    // Note: 404 is special; it is the case that most servers return this if
    // the documnet is not there, but Proxies also return this if the server
    // was not found - a conditon which normally makes us search.  This means
    // that a 404 over proxy actually causes a search to occur, which is not
    // what we want.
    // Is there any way I can tell the difference?

    bPrepareForSearch = ((bContinueSearch || (bAllowSearch)) &&
                 (fAutoScan || SHOULD_DO_SEARCH(dwSearchForExtensions, dwDo404Search)) &&
                 DO_SEARCH_ON_STATUSCODE(dwStatusCode) &&
                 (!bOnProxy || pdoh->_fDocCanNavigate || (dwStatusCode == HTTP_STATUS_NOT_FOUND)));

    if (bPrepareForSearch)
    {
        TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() Preparing for Search...");

        HRESULT hr = S_OK;

        // If we don't have the url we are searching, get it from the addressbar
        if (!fAutoScan)
            hr = _GetSearchString(pdoh->_psp, &varURL);

        if (S_OK!=hr && pdoh->_fDocCanNavigate)
        {
            hr = VariantCopy(&varURL, &pdoh->_varUserEnteredUrl);
        }
        
        // If we have completed the autoscan, see if there is a special error page that
        // we should display.
        VARIANT varScanFailure = {0};
        if (SUCCEEDED(hr) &&
            dwSearchForExtensions == DONE_SUFFIXES &&
            SUCCEEDED(_GetScanFailureUrl(pdoh->_psp, &varScanFailure)))
        {
            bDoSearch = TRUE;
        }

        else if (SUCCEEDED(hr) &&
            (dwSearchForExtensions == SCAN_SUFFIXES ||  dwDo404Search == ALWAYSSEARCH)) 
        {
            bDoSearch = TRUE;
        } 
        else 
        {
            bDoSearch = FALSE; 
        }
        bAskUser = FALSE;

        TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() typedurl = %s, ask = %d, dosearch = %d", varURL.bstrVal, bAskUser, bDoSearch);


// Don't prompt user if there is an extension, since we are going to
// not scan anyway.

        if (bDoSearch)
        {
            PARSEDURL pu;

            pu.cbSize = SIZEOF(PARSEDURL);
            if (ParseURL(varURL.bstrVal, &pu) == URL_E_INVALID_SYNTAX)
            {
                // only if this is not a valid URL, should we try to do this searching

                // but try to avoid the case of typos like http;//something.something.com
                // The malformed URL case
                if (!fAutoSearching &&
                    (//StrChrI(varURL.bstrVal, L'.') || 
                     StrChrI(varURL.bstrVal, L'/') ||
                     StrChrI(varURL.bstrVal, L' '))
                    )
                {
                    bAskUser = FALSE;
                    bDoSearch = FALSE;
                }
            }
            else
            {
                bAskUser = FALSE;
                bDoSearch = FALSE;
            }
        }

        TCHAR szT[MAX_URL_STRING + SEARCHPREFIXLENGTH];
        DWORD cchT = SIZECHARS(szT);

        // Bug 35354 has been resolved "not repro" because the dialog below
        // currently cannot ever be displayed (there is no way for bAskUser to
        // be true in the following conditional). If that changes, then that bug
        // needs to get fixed.

        if (bAskUser)
        {
            PrepareURLForDisplay(varURL.bstrVal, szT, &cchT);

            // If we ask the user, make sure we don't display another
            // error dialog.
            *pfShouldDisplayError = FALSE;

            // S_OK means we handled any popups; if we return an error,
            // the caller may display an error dialog
            hres = S_OK;

            if (!bSuppressUI && IDYES == IE_ErrorMsgBox(NULL, pdoh->_hwnd, hrDisplay, szError, szT, IDS_CANTFINDURL, MB_YESNO|MB_ICONSTOP))
            {
                bDoSearch = TRUE;
            }
            else
            {
                _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
                bDoSearch = FALSE;
            }
        }

        if (bDoSearch)
        {
            if (dwSearchForExtensions && dwSearchForExtensions != DONE_SUFFIXES)
            {
                wnsprintf(szT, ARRAYSIZE(szT), szSearchFormatStr, varURL.bstrVal);
                if (!fAutoSearching)
                {
                    _ValidateURL(szT, UQF_DEFAULT);
                }

                if (fAddMRU)
                    _UpdateMRU(pdoh, szT);
            } 
            else if (VT_BSTR == varScanFailure.vt && NULL != varScanFailure.bstrVal)
            {
                StrCpyN(szT, varScanFailure.bstrVal, ARRAYSIZE(szT));
                _ValidateURL(szT, UQF_DEFAULT);
                _DontAddToMRU(pdoh);
            }
            else if (dwDo404Search)
            {
                // add the search prefix
                StrCpyN(szT, TEXT("? "), ARRAYSIZE(szT));
                StrCatBuff(szT, varURL.bstrVal, ARRAYSIZE(szT));
                _DontAddToMRU(pdoh);
            }
            else
            {
                ASSERT(0);
            }

            if (dwSearchForExtensions && dwSearchForExtensions != DONE_SUFFIXES)
                _SetSearchInfo(pdoh, ++dwSuffixIndex, FALSE, TRUE, FALSE);
            else if (dwDo404Search)
                _SetSearchInfo(pdoh, dwSuffixIndex, FALSE, FALSE, TRUE);
            else
                _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);

            // If we're called from Trident (fFromTrident == TRUE), then we're going to call
            // IHTMLPrivateWindow::SuperNavigate().  In that case, the call to _CancelPendingNavigation
            // below needs to be synchronous.  However, if we're going to call _DoAsyncNavigation,
            // then the call to _CancelPendingNavigation needs to remain asynchronous.
            //
            if (!pdoh->_fCanceledByBrowser)
                pdoh->_CancelPendingNavigation(FALSE, fFromTrident);

            TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() Doing search on %s", szT);

            DWORD cchT = SIZECHARS(szT);

            //
            // if we can find a search context living in a host somewhere,
            // then we need to pass that into ParseUrlFromOutsideSource
            // because it'll use it to customize the behavior of
            // the search hooks if a search ends up happening
            //

            ISearchContext *  pSC = NULL;
            pdoh->QueryService(SID_STopWindow, IID_ISearchContext, (void **)&pSC);

            ParseURLFromOutsideSourceWithContextW(szT, szT, &cchT, NULL, pSC);

            if (pSC != NULL)
            {
                pSC->Release();
            }


            if (fFromTrident)
            {
                BSTR  bstrUrl = SysAllocString(szT);
                IHTMLPrivateWindow * pPrivWindow = NULL;

                ASSERT(pdoh->_fDocCanNavigate);
                ASSERT(pdoh->_pHTMLWindow);

                // The navigation state is already reset by cancelpending navigation 
                // causing either trident to cancel pending navigation or by OnStopBinding
                /*
                if (pdoh->_pwb)
                    pdoh->_pwb->SetNavigateState(BNS_NORMAL);
                */

                hres = pdoh->_pHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow,
                                                          (void**)&pPrivWindow);
                if (SUCCEEDED(hres))
                {
                    hres = pPrivWindow->SuperNavigate(bstrUrl, NULL, NULL, NULL, NULL, NULL, 0);
                    pPrivWindow->Release();
                }

                SysFreeString(bstrUrl);
            }
            else
            {
                pdoh->_DoAsyncNavigation(szT);
            }
            
            pdoh->_fCanceledByBrowser = TRUE;
            *pfShouldDisplayError = FALSE;  // Don't display another dialog

            hres = S_OK;  // we did a navigate
        } 

        VariantClear(&varScanFailure);
    }
    else if (bSentToEngine && !bSuppressUI)
    {
        *pfShouldDisplayError = FALSE;
        _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);
        IE_ErrorMsgBox(NULL, pdoh->_hwnd, hrDisplay, szError, szURL, IDS_CANTFINDSEARCH, MB_OK|MB_ICONSTOP);
        hres = S_OK;
    }

    VariantClear(&varURL);

    return hres;

} // _HandleFailedNavigationSearch()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\droptgt.cpp ===
#include "priv.h"
#include "..\inc\droptgt.h"

#include "..\inc\droptgt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\download.cpp ===
#include "priv.h"
#include "bindcb.h"
#include "resource.h"
#include <vrsscan.h>
#include "iface.h"
#include "security.h"
#include <wintrust.h>
#include "iehelpid.h"
#include <shlwapi.h>
#include "inetreg.h"
#include <varutil.h>
#include "dochost.h"
#include <mluisupp.h>
#include <downloadmgr.h>
#include "apithk.h"
#include "richedit.h"
#include <brutil.h>


#define MIME
#include "filetype.h"


#define ALLFILE_WILDCARD TEXT("*.*")

#define MAX_BYTES_STRLEN 64
#define CALC_NOW 5  // Recalcs Estimated time left every this many'th call to OnProgress

//
//  Enable WinVerifyTrust
//
#define CALL_WVT

#ifdef CALL_WVT
#include "wvtp.h"

//
//  Note that this is a global variable. It means we don't call LoadLibrary
// everytime we download an EXE (good), but the user need to reboot if
// WINTRUST.DLL is added later (bad). Since WINTRUST.DLL is part of IE 3.0,
// this is sufficient at this point.
//
Cwvt g_wvt;

HWND g_hDlgActive = NULL;   // get rid of this, not needed

//
// A named mutex is being used to determine if a critical operation exist, such as a file download.
// When we detect this we can prevent things like going offline while a download is in progress.
// To start the operation Create the named mutex. When the op is complete, close the handle.
// To see if any pending operations are in progress, Open the named mutex.  Success/fail will indicate
// if any pending operations exist.  This mechanism is being used to determine if a file download is
// in progress when the user attempts to go offline.  If so, we prompt them to let them know that going 
// offline will cancel the download(s).
HANDLE g_hCritOpMutex = NULL;

UINT _VerifyTrust(HWND hwnd, LPCTSTR pszFileName, LPCWSTR pszStatusText);
#endif // CALL_WVT

// Do strong typechecking on the parameters
#ifdef SAFECAST
#undef SAFECAST
#endif
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

extern HRESULT _GetRequestFlagFromPIB(IBinding *pib, DWORD *pdwOptions);
extern HRESULT _PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcchOut, BOOL fUTF8Enabled, UINT uiCP);


UINT IE_ErrorMsgBox(IShellBrowser* psb,
                    HWND hwnd, HRESULT hrError, LPCWSTR szError, LPCTSTR szURL,
                    UINT idResource, UINT wFlags);
BOOL IsAssociatedWithIE(LPCWSTR pszFileName);

extern "C" EXECUTION_STATE WINAPI pSetThreadExecutionState(EXECUTION_STATE esFlags);  // Win2k+, Win98+ kernel32 API

#define DM_DOWNLOAD             TF_SHDPROGRESS
#define DM_PROGRESS             TF_SHDPROGRESS
#define DM_WVT                  TF_SHDPROGRESS

#define DWNLDMSG(psz, psz2)     TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %s", psz, psz2)
#define DWNLDMSG2(psz, x)       TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %x", psz, x)
#define DWNLDMSG3(psz, x, y)    TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %x %x", psz, x, y)
#define DWNLDMSG4(psz, x, y, z) TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %x %x %x", psz, x, y, z)

#define SAFEMSG(psz, psz2)      TraceMsg(0, "shd TR-SAFE::%s %s", psz, psz2)
#define SAFEMSG2(psz, x)        TraceMsg(0, "shd TR-SAFE::%s %x", psz, x)
#define EXPMSG(psz, psz2)       TraceMsg(0, "shd TR-EXP::%s %s", psz, psz2)
#define MDLGMSG(psz, x)         TraceMsg(0, "shd TR-MODELESS::%s %x", psz, x)
#define MSGMSG(psz, x)          TraceMsg(TF_SHDTHREAD, "ief MMSG::%s %x", psz, x)
#define PARKMSG(psz, x)         TraceMsg(TF_SHDTHREAD, "ief MPARK::%s %x", psz, x)

// File name and 32 for the rest of the title string
#define TITLE_LEN    (256 + 32)
#define MAX_DISPLAY_LEN 96
#define MAX_SCHEME_STRING 16
class CDownload : public IBindStatusCallback
            , public IAuthenticate
            , public IServiceProvider
            , public IHttpNegotiate
            , public IWindowForBindingUI
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // *** IAuthenticate ***
    STDMETHODIMP Authenticate(
        HWND *phwnd,
        LPWSTR *pszUsername,
        LPWSTR *pszPassword);

    // *** IServiceProvider ***
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // *** IBindStatusCallback ***
    STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    /* *** IHttpNegotiate ***  */
    STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders);

    STDMETHODIMP OnResponse(DWORD dwResponseCode,
                        LPCWSTR szResponseHeaders,
                        LPCWSTR szRequestHeaders,
                        LPWSTR *pszAdditionalRequestHeaders);

    STDMETHODIMP GetWindow(REFGUID RefGUI, HWND* phWnd);

protected:
    LONG        _cRef;
    LONG        _cRefDLD;
    IBinding*   _pib;
    IBindCtx*   _pbc;
    CDocObjectHost *_pdoh;
    HWND        _hDlg;
    HWND        _hwndToolTips;
    BOOL        _fSaveAs : 1;
    BOOL        _fGotFile : 1;
    BOOL        _fFirstTickValid : 1;
    BOOL        _fEndDialogCalled : 1;
    BOOL        _fDontPostQuitMsg : 1;  // Posts WM_QUIT message in destructor
    BOOL        _fCallVerifyTrust : 1;
    BOOL        _fStrsLoaded : 1;
    BOOL        _fSafe : 1;             // no need to call IsSafe dialog
    BOOL        _fDownloadStarted : 1; // Have we started receiving data
    BOOL        _fDownloadCompleted : 1;  // We have received BSCF_LASTDATANOTIFICATION
    BOOL        _fDeleteFromCache : 1; // Delete the file from cache when done
    BOOL        _fWriteHistory : 1;  // Should it be written to history? (SECURITY)
    BOOL        _fDismissDialog : 1;
    BOOL        _fUTF8Enabled : 1;
    DWORD       _dwFirstTick;
    DWORD       _dwFirstSize;
    DWORD       _dwTotalSize;           // Size of file downloaded so far
    DWORD       _dwFileSize;            // Size of file to download
    HICON       _hicon;
    TCHAR       _szPath[MAX_PATH];      // ok with MAX_PATH
    TCHAR       _szSaveToFile[MAX_PATH];    // File to Save to
    TCHAR       _szEstimateTime[MAX_PATH];  // ok with MAX_PATH
    TCHAR       _szBytesCopied[MAX_PATH];  // ok with MAX_PATH
    TCHAR       _szTitlePercent[TITLE_LEN];
    TCHAR       _szTitleBytes[TITLE_LEN];
    TCHAR       _szTransferRate[TITLE_LEN];
    TCHAR       _szURL[MAX_URL_STRING];
    TCHAR       _szDisplay[MAX_DISPLAY_LEN];   // URL to be displayed
    TCHAR       _szDefDlgTitle[256];
    TCHAR       _szExt[10];
    DWORD       _grfBINDF;
    BINDINFO*   _pbinfo;
    LPWSTR      _pwzHeaders;
    IMoniker*   _pmk;                   // WARNING: No ref-count (only for modal)
    LPWSTR      _pwszDisplayName;
    DWORD       _dwVerb;
    UINT        _uiCP;                  // Code page
    DWORD       _dwOldEst;
    ULONG       _ulOldProgress;
    DWORD       _dwOldRate;
    DWORD       _dwOldPcent;
    DWORD       _dwOldCur;
    BOOL        _fConfirmed;


    void SetMoniker(IMoniker* pmk) { _pmk=pmk; }
    BOOL _IsModal(void) { return (bool)_pmk; }

    virtual ~CDownload();
    friend INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK SafeOpenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    UINT _MayAskUserIsFileSafeToOpen(LPCTSTR pszMime);
    BOOL _GetSaveLocation(void);
    BOOL _SaveFile(void);
    void _DeleteFromCache(void);
    ULONG AddRefDLD(void);
    ULONG ReleaseDLD(void);
    HRESULT PerformVirusScan(LPCTSTR szFileName);

public:
    CDownload(BOOL fSaveAs = FALSE, LPWSTR pwzHeaders = NULL,
              DWORD grfBINDF = BINDF_ASYNCHRONOUS, BINDINFO* pbinfo = NULL,
              BOOL fSafe = FALSE, DWORD dwVerb = BINDVERB_GET, LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, BOOL fConfirmed = FALSE);

    static void OpenUI(IMoniker* pmk, IBindCtx *pbc, BOOL fSaveAs = FALSE, BOOL fSafe = FALSE, LPWSTR pwzHeaders = NULL, DWORD dwVerb = BINDVERB_GET, DWORD grfBINDF = 0, BINDINFO* pbinfo = NULL, LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, BOOL fConfirmed = FALSE);

    HRESULT StartBinding(IMoniker* pmk, IBindCtx *pbc = NULL);
    void EndDialogDLD(UINT id);
    void ShowStats(void);
    BOOL SetDismissDialogFlag(BOOL fDismiss) { return(_fDismissDialog = fDismiss); }
    BOOL GetDismissDialogFlag(void) { return(_fDismissDialog); }
#ifdef USE_LOCKREQUEST
    HRESULT LockRequestHandle(void);
#endif
};

CDownload::CDownload(BOOL fSaveAs, LPWSTR pwzHeaders, DWORD grfBINDF, BINDINFO* pbinfo, BOOL fSafe, DWORD dwVerb, LPCTSTR pszRedir, UINT uiCP, BOOL fConfirmed)
    : _cRef(1), _fSaveAs(fSaveAs), _fWriteHistory(1),
      _grfBINDF(grfBINDF), _pbinfo(pbinfo), _fSafe(fSafe), _pwzHeaders(pwzHeaders), _dwVerb(dwVerb), _uiCP(uiCP), _fConfirmed(fConfirmed)
{
    ASSERT(_fStrsLoaded == FALSE);
    ASSERT(_fDownloadStarted == FALSE);
    ASSERT(_fDownloadCompleted == FALSE);
    ASSERT(_fGotFile == FALSE);
    ASSERT(_fUTF8Enabled == FALSE);
    ASSERT(_hDlg == NULL);
    ASSERT(_pwszDisplayName == NULL);
    ASSERT(_dwTotalSize == 0);
    ASSERT(_dwFileSize == 0);
    ASSERT(_dwFirstTick == 0);
    ASSERT(_ulOldProgress == 0);
    ASSERT(_dwOldRate == 0);
    ASSERT(_dwOldPcent == 0);
    ASSERT(_dwOldCur == 0);

    _dwOldEst = 0xffffffff;
    
    if (pszRedir && lstrlen(pszRedir))
        StrCpyN(_szURL, pszRedir, ARRAYSIZE(_szURL) - 1); // -1 ???

    TraceMsg(TF_SHDLIFE, "CDownload::CDownload being constructed");
}

void ProcessStartbindingError(HWND hWnd, LPTSTR pszTitle, LPTSTR pszText, UINT uiFlag, HRESULT hres)
{
    if (E_ACCESSDENIED == hres)
    {
        pszText = MAKEINTRESOURCE(IDS_DOWNLOADDISALLOWED);
        pszTitle = MAKEINTRESOURCE(IDS_SECURITYALERT);
        uiFlag = MB_ICONWARNING;
    }

    MLShellMessageBox(hWnd, pszText, pszTitle, MB_OK | MB_SETFOREGROUND | uiFlag );

    if (IsValidHWND(hWnd))
    {
        FORWARD_WM_COMMAND(hWnd, IDCANCEL, NULL, 0, PostMessage);
    }
}

HRESULT SelectPidlInSFV(IShellFolderViewDual *psfv, LPCITEMIDLIST pidl, DWORD dwOpts)
{
    VARIANT var;
    HRESULT hr = InitVariantFromIDList(&var, pidl);
    if (SUCCEEDED(hr))
    {
        hr = psfv->SelectItem(&var, dwOpts);
        VariantClear(&var);
    }

    return hr;
}

void OpenFolderPidl(LPCITEMIDLIST pidl)
{
    SHELLEXECUTEINFO shei = { 0 };

    shei.cbSize     = sizeof(shei);
    shei.fMask      = SEE_MASK_INVOKEIDLIST;
    shei.nShow      = SW_SHOWNORMAL;
    shei.lpIDList   = (LPITEMIDLIST)pidl;
    ShellExecuteEx(&shei);
}

STDAPI OpenContainingFolderAndGetShellFolderView(HWND hwnd, LPCITEMIDLIST pidlFolder, IShellFolderViewDual **ppsfv)
{
    *ppsfv = NULL;
    
    IWebBrowserApp *pauto;
    HRESULT hr = SHGetIDispatchForFolder(pidlFolder, &pauto);
    if (SUCCEEDED(hr))
    {
        // We have IDispatch for window, now try to get one for
        // the folder object...
        HWND hwnd;
        if (SUCCEEDED(pauto->get_HWND((LONG_PTR *)&hwnd)))
        {
            // Make sure we make this the active window
            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_SHOWNORMAL);

        }
        IDispatch * pautoDoc;
        hr = pauto->get_Document(&pautoDoc);
        if (SUCCEEDED(hr))
        {
            hr = pautoDoc->QueryInterface(IID_PPV_ARG(IShellFolderViewDual, ppsfv));
            pautoDoc->Release();
        }
        pauto->Release();
    }
    return hr;
}

//
// Stolen (and modified) from shell\ext\mydocs2\prop.cpp which was from link.c in shell32.dll
//
void FindTarget(HWND hDlg, LPTSTR pPath)
{
    USHORT uSave;

    LPITEMIDLIST pidl = ILCreateFromPath( pPath );
    if (!pidl)
        return;

    LPITEMIDLIST pidlLast = ILFindLastID(pidl);

    // get the folder, special case for root objects (My Computer, Network)
    // hack off the end if it is not the root item
    if (pidl != pidlLast)
    {
        uSave = pidlLast->mkid.cb;
        pidlLast->mkid.cb = 0;
    }
    else
        uSave = 0;

    LPITEMIDLIST pidlDesk;
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlDesk)))
    {
        BOOL fIsDesktopDir = pidlDesk && ILIsEqual(pidl, pidlDesk);

        if (fIsDesktopDir || !uSave)  // if it's in the desktop dir or pidl == pidlLast (uSave == 0 from above)
        {
            //
            // It's on the desktop...
            //

            MLShellMessageBox(hDlg, (LPTSTR)IDS_ON_DESKTOP, (LPTSTR)IDS_FIND_TITLE,
                             MB_OK | MB_ICONINFORMATION | MB_APPLMODAL | MB_TOPMOST);
        }
        else
        {
            if (WhichPlatform() == PLATFORM_BROWSERONLY)
            {
                OpenFolderPidl(pidl);
            }
            else
            {
                IShellFolderViewDual *psfv;
                if (SUCCEEDED(OpenContainingFolderAndGetShellFolderView(hDlg, uSave ? pidl : pidlDesk, &psfv)))
                {
                    if (uSave)
                        pidlLast->mkid.cb = uSave;
                    SelectPidlInSFV(psfv, pidlLast, SVSI_SELECT | SVSI_FOCUSED | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE);
                    psfv->Release();
                }
            }
        }
        ILFree(pidlDesk);
    }

    ILFree(pidl);
}

BOOL SetExemptDelta(LPCTSTR pszURL, DWORD dwExemptDelta)
{
    BOOL fRC;
    INTERNET_CACHE_ENTRY_INFO icei;
    icei.dwStructSize = sizeof(icei);
    icei.dwExemptDelta = dwExemptDelta;    // Number of seconds from last access time to keep entry
    // Retry setting the exempt delta if it fails since wininet may have either not have created the
    //    entry yet or might have it locked.
    for (int i = 0; i < 5; i++)
    {
        if (fRC = SetUrlCacheEntryInfo(pszURL, &icei, CACHE_ENTRY_EXEMPT_DELTA_FC))
            break;
        Sleep(1000);
    }
    return fRC;
}

INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static fInBrowseDir = FALSE;
    CDownload* pdld = (CDownload*) GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwExStyle = 0;
    TCHAR szURL[MAX_URL_STRING];    // make copies since EndDialog will delete CDownload obj
    BOOL fDownloadAborted;

    DWNLDMSG4("DownloadDlgProc ", uMsg, wParam, lParam);

    if ((pdld == NULL) && (uMsg != WM_INITDIALOG))
    {
        RIPMSG(TRUE, "CDownload freed (pdld == NULL) && (uMsg != WM_INITDIALOG)");
        return FALSE;
    }
    
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        TCHAR szYesNo[20];
        DWORD dwType = REG_SZ;
        DWORD dwSize = ARRAYSIZE(szYesNo);

        if (lParam == NULL)
            return FALSE;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdld = (CDownload*)lParam;
        pdld->_hDlg = hDlg;

        EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_SIZE, MF_BYCOMMAND | MF_GRAYED);

        EnableWindow(GetDlgItem(hDlg, IDD_OPENFILE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_BROWSEDIR), FALSE);

        // On BiDi Loc Win98 & NT5 mirroring will take care of that
        // Need to fix only on BiBi Win95 Loc
        if (g_bBiDiW95Loc)
        {
            SetWindowBits(GetDlgItem(hDlg, IDD_DIR), GWL_EXSTYLE, WS_EX_RTLREADING, WS_EX_RTLREADING);
        }
        MLLoadString(IDS_DEFDLGTITLE, pdld->_szDefDlgTitle, ARRAYSIZE(pdld->_szDefDlgTitle));

        if (pdld->_hwndToolTips = CreateWindowEx(dwExStyle, TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP,
                                  CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
                                  hDlg, NULL, HINST_THISDLL, NULL))
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
            ti.hwnd = hDlg;
            ti.uId = (UINT_PTR) GetDlgItem(hDlg, IDD_NAME);
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.hinst = HINST_THISDLL;
            GetWindowRect((HWND)ti.uId, &ti.rect);
            SendMessage(pdld->_hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        }
        // make sure we support cross-lang platform
        SHSetDefaultDialogFont(hDlg, IDD_NAME);

        pdld->SetDismissDialogFlag(FALSE);
        if ( SHRegGetUSValue( TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                              TEXT("NotifyDownloadComplete"),
                              &dwType, (void *)szYesNo, &dwSize, FALSE, NULL, 0 ) == ERROR_SUCCESS )
        {
            pdld->SetDismissDialogFlag(!StrCmpI(szYesNo, TEXT("No")));
        }
        CheckDlgButton(hDlg, IDD_DISMISS, pdld->GetDismissDialogFlag());

        DWNLDMSG("DownloadDlgProc", "Got WM_INITDIALOG");
        Animate_OpenEx(GetDlgItem(hDlg, IDD_ANIMATE), HINST_THISDLL, MAKEINTRESOURCE(IDA_DOWNLOAD));
        ShowWindow(GetDlgItem(hDlg, IDD_DOWNLOADICON), SW_HIDE);

        g_hCritOpMutex = CreateMutexA(NULL, TRUE, "CritOpMutex");
        
        // Automatically start binding if we are posting synchronously.
        if (pdld->_IsModal()) 
        {
            HRESULT hres = pdld->StartBinding(pdld->_pmk);
            ASSERT(pdld->_pmk);
            if (FAILED(hres))
            {
                ProcessStartbindingError(hDlg, MAKEINTRESOURCE(IDS_DOWNLOADFAILED),
                                         pdld->_szDisplay, MB_ICONWARNING, hres);
            }
        }

        return TRUE;
    }

    case WM_SIZE:
        if ((wParam == SIZE_MAXIMIZED) || (wParam == SIZE_RESTORED))
            SetWindowText(hDlg, pdld->_szDefDlgTitle);
        break;

    case WM_NOTIFY:
    {
        LPTOOLTIPTEXT lpTT = (LPTOOLTIPTEXT) lParam;
        if (lpTT->hdr.code == TTN_NEEDTEXT)
        {
            lpTT->lpszText = pdld->_szURL;
            lpTT->hinst = NULL;
        }
    }
    break;

    case WM_COMMAND:
        DWNLDMSG2("DownloadDlgProc WM_COMMAND id =", GET_WM_COMMAND_ID(wParam, lParam));
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDD_SAVEAS:
            if (pdld) 
            {
                pdld->AddRefDLD();
                BOOL fSuccess = FALSE;

                // Prevent someone from canceling dialog while the shell copy etc. is going on
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
                
                // If zone check fails or if we found virus, bail out and remove file from cache.
                if (pdld->PerformVirusScan(pdld->_szPath) != S_OK) 
                {
                    pdld->_fDeleteFromCache = TRUE;
                    pdld->EndDialogDLD(IDCANCEL);
                    break;
                }

                fSuccess = pdld->_SaveFile();

                AddUrlToUrlHistoryStg(pdld->_pwszDisplayName, NULL, NULL, pdld->_fWriteHistory, NULL, NULL, NULL);
                // -- BharatS --- Only add to history if Visible ?

                IEPlaySound(TEXT("SystemAsterisk"), TRUE);
                
                if (fSuccess)
                {
                    if (pdld->SetDismissDialogFlag(IsDlgButtonChecked(hDlg, IDD_DISMISS) == BST_CHECKED))
                    {
                        StrCpyN(szURL, pdld->_szURL, ARRAYSIZE(szURL));
                        pdld->EndDialogDLD(IDCANCEL);
                        SetExemptDelta(szURL, 0);
                    }
                    else
                    {
                        TCHAR szStr[MAX_PATH];

                        if (MLLoadString(IDS_CLOSE, szStr, ARRAYSIZE(szStr)))
                        {
                            SetWindowText(GetDlgItem(hDlg, IDCANCEL), szStr);
                        }

                        ShowWindow(GetDlgItem(hDlg, IDD_ANIMATE), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDESTTIME), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDCOMPLETEICON), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDCOMPLETETEXT), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDTIME), SW_SHOW);
                        
                        MLLoadString(IDS_SAVED, szStr, ARRAYSIZE(szStr));
                        SetDlgItemText(hDlg, IDD_OPENIT, szStr);

                        MLLoadString(IDS_DOWNLOADCOMPLETE, szStr, ARRAYSIZE(szStr));
                        SetWindowText(hDlg, szStr);

                        EnableWindow(GetDlgItem(hDlg, IDD_OPENFILE), TRUE);
                        EnableWindow(GetDlgItem(hDlg, IDD_BROWSEDIR), TRUE);

                        pdld->ShowStats();
                        pdld->ReleaseDLD();
                    }
                }
                else
                {
                    pdld->ReleaseDLD();
                }
                
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);
            }
            break;

        case IDCANCEL:  // Cancel on abort, Close on dismiss
            if (pdld && IsWindowEnabled(GetDlgItem(hDlg, IDCANCEL))) 
            {
                pdld->AddRefDLD();
                fDownloadAborted  = pdld->_fDownloadStarted && !pdld->_fDownloadCompleted;
                StrCpyN(szURL, pdld->_szURL, ARRAYSIZE(szURL));
                
                if (pdld->_pib) 
                {
                    HRESULT hresT;
                    hresT = pdld->_pib->Abort();
                    TraceMsg(DM_DOWNLOAD, "DownloadDlgProc::IDCANCEL: called _pib->Abort() hres=%x", pdld->_pib, hresT);
                }
                pdld->EndDialogDLD(IDCANCEL);
                
                // Download was canceled.  Increase exempt time to keep downloaded a bit in case download is resumed
                SetExemptDelta(szURL, fDownloadAborted ?60*60*24 :0);
            }
            break;

        case IDD_BROWSEDIR:
                if (!fInBrowseDir) 
                {
                    pdld->AddRefDLD();  
                    fInBrowseDir = TRUE;    
                    
                    FindTarget(hDlg, pdld->_szSaveToFile);
                    
                    // Since EndDialogDLD will probably release our structure...
                    HWND hwndToolTips = pdld->_hwndToolTips;
                    pdld->_hwndToolTips = NULL;
                    pdld->EndDialogDLD(IDOK);

                    if (IsWindow(hwndToolTips))
                        DestroyWindow(hwndToolTips);
                        
                    fInBrowseDir = FALSE;
                }
#if DEBUG
                else
                {
                    TraceMsg(DM_DOWNLOAD, "DownloadDlgProc rcvd IDD_BROWSEDIR msg while already processing IDD_BROWSEDIR");
                }
#endif
                break;

        case IDD_OPENFILE:
            StrCpyN(pdld->_szPath, pdld->_szSaveToFile, ARRAYSIZE(pdld->_szPath));
        case IDOK:
            ShowWindow(GetDlgItem(hDlg, IDD_DISMISS), SW_HIDE);
            
            if (pdld)
            {
                pdld->AddRefDLD();
                
                if (pdld->_fGotFile) 
                {
                    // If zone check fails or if we found virus, bail out and remove file from cache.
                    if ( pdld->PerformVirusScan(pdld->_szPath) != S_OK ) 
                    {
                        pdld->_fDeleteFromCache = TRUE;
                    }
                    else
                    {
                        TCHAR  szQuotedPath[MAX_PATH];
                        StrCpyN(szQuotedPath, pdld->_szPath, MAX_PATH);

                        if (PLATFORM_INTEGRATED == WhichPlatform())
                        {
                            PathQuoteSpaces(szQuotedPath);
                        }

                        SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO),
                                                 SEE_MASK_NOZONECHECKS, hDlg, NULL, szQuotedPath, NULL, NULL, SW_SHOWNORMAL, NULL};
                        if (!ShellExecuteEx(&sei))
                        {
                            DWNLDMSG2("ShellExecute failed", GetLastError());
                        }
                    }
                }

                if (!pdld->_fDeleteFromCache)
                    AddUrlToUrlHistoryStg(pdld->_pwszDisplayName, NULL, NULL, pdld->_fWriteHistory, NULL, NULL, NULL);

                // Since EndDialogDLD will probably release our structure...
                HWND hwndToolTips = pdld->_hwndToolTips;
                pdld->_hwndToolTips = NULL;
                StrCpyN(szURL, pdld->_szURL, ARRAYSIZE(szURL));
                
                pdld->EndDialogDLD(!pdld->_fDeleteFromCache ?IDOK :IDCANCEL);

                if (IsWindow(hwndToolTips))
                    DestroyWindow(hwndToolTips);
                SetExemptDelta(szURL, 0);
            }
            break;
        }
        break;


    case WM_ACTIVATE:
        if (pdld && pdld->_IsModal())
            return FALSE;
        else 
        {
            // There can be race conditions here. If the WA_ACTIVATE messages came in reverse
            // order, we might end up setting up the wrong hDlg as the active window. As of right now,
            // the only thing g_hDlgActive is being used for is for the IsDialogMessage in
            // CDownload_MayProcessMessage. And since there is only one tab-able control in this
            // dialog, a wrong hDlg in the g_hDlgActive should not hurt.
            ENTERCRITICAL;
            if (LOWORD(wParam) == WA_INACTIVE) 
            {
                if (g_hDlgActive == hDlg)
                {
                    MDLGMSG(TEXT("being inactivated"), hDlg);
                    g_hDlgActive = NULL;
                }
            } 
            else 
            {
                MDLGMSG(TEXT("being activated"), hDlg);
                g_hDlgActive = hDlg;
            }
            LEAVECRITICAL;
        }
        break;

    case WM_NCDESTROY:
        MDLGMSG(TEXT("being destroyed"), hDlg);
        ASSERT((pdld && pdld->_IsModal()) || (g_hDlgActive != hDlg));
        SetWindowLongPtr(hDlg, DWLP_USER, NULL);
        return FALSE;

    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    default:
        return FALSE;
    }

    return TRUE;
}

void CDownload::ShowStats(void)
{
    TCHAR szStr[MAX_PATH];
    TCHAR szBytes[MAX_BYTES_STRLEN];
    TCHAR szTime[MAX_BYTES_STRLEN];
    TCHAR *pszTime = szTime;
    DWORD dwSpent = (GetTickCount() - _dwFirstTick);

    SetDlgItemText(_hDlg, IDD_NAME, _szDisplay);
    
    MLLoadString(IDS_BYTESTIME, _szBytesCopied, ARRAYSIZE(_szBytesCopied));
    StrFromTimeInterval(szTime, ARRAYSIZE(szTime), (dwSpent < 1000)  ?1000 :dwSpent, 3);
    while(pszTime && *pszTime && *pszTime == TEXT(' '))
        pszTime++;
    _FormatMessage(_szBytesCopied, szStr, ARRAYSIZE(szStr),
                StrFormatByteSize(_dwTotalSize, szBytes, MAX_BYTES_STRLEN), pszTime);
    SetDlgItemText(_hDlg, IDD_TIMEEST, szStr);

    // division below requires at least 1/2 second to have elapsed.
    if (dwSpent < 500)
        dwSpent = 500;
    _FormatMessage(_szTransferRate, szStr, ARRAYSIZE(szStr), 
                StrFormatByteSize(_dwTotalSize / ((dwSpent+500)/1000), szBytes, MAX_BYTES_STRLEN));
    SetDlgItemText(_hDlg, IDD_TRANSFERRATE, szStr);

    SetForegroundWindow(_hDlg);
}

void CDownload::EndDialogDLD(UINT id)
{
    if (ReleaseDLD() != 0)
        return;
        
    ASSERT(!_fEndDialogCalled);
    _fEndDialogCalled = TRUE;

    DWNLDMSG2("EndDialogDLD cRef ==", _cRef);
    TraceMsg(TF_SHDREF, "CDownload::EndDialogDLD called when _cRef=%d", _cRef);

    _fDismissDialog = (IsDlgButtonChecked(_hDlg, IDD_DISMISS) == BST_CHECKED);
    if (SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), 
                    TEXT("NotifyDownloadComplete"), 
                    REG_SZ, _fDismissDialog ?TEXT("no") :TEXT("yes"), _fDismissDialog ?sizeof(TEXT("no")-sizeof(TCHAR)) :sizeof(TEXT("yes")-sizeof(TCHAR)), SHREGSET_FORCE_HKCU) != ERROR_SUCCESS)
    {
        DWNLDMSG2("SHRegSetUSValue NotifyDownloadComplete failed", GetLastError());
    }

    // HACK: USER does not send us WM_ACTIVATE when this dialog is
    //  being destroyed when it was activated. We need to work around
    //  this bug(?) by cleaning up g_hDlgActive.
    if (g_hDlgActive == _hDlg) 
    {
        MDLGMSG(TEXT("EndDialogDLD putting NULL in g_hDlgActive"), _hDlg);
        g_hDlgActive = NULL;
    }

    DestroyWindow(_hDlg);
    Release();
}

#define SZEXPLORERKEY  TEXT("Software\\Microsoft\\Internet Explorer")
#define SZDOWNLOADDIRVAL  TEXT("Download Directory")
// _GetSaveLocation
//      -   Tries to get the current download directory from the registry
//          default is the Desktop
//      -   Shows the FileSave Dialog
//      -   If the user changed the download location, save that off into
//          the registry for future downloads
//      -   _szSaveToFile is updated (this will be used by _SaveFile()
//
// Returns TRUE, if successfully done.
//
BOOL _GetSaveLocation(HWND hDlg, LPTSTR pszPath, LPTSTR pszExt, LPTSTR pszSaveToFile, UINT cchSaveToFile, BOOL fUTF8Enabled, UINT uiCP)
{
    BOOL fRet = FALSE;
    TCHAR * pszSaveTo =  NULL;
    HKEY hKey;
    BOOL fRegFileType = FALSE;
    TCHAR szDownloadDir[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szTemp[40];
    LPTSTR pszWalk = szBuffer;
    int    cchWalk = ARRAYSIZE(szBuffer);
    int    cch;

    szDownloadDir[0] = 0;

    // If we don't have a download directory in the registry, download to the desktop
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZEXPLORERKEY, 0, KEY_READ, &hKey))
    {
        DWORD dwType, cbData = sizeof(szDownloadDir);
        RegQueryValueEx(hKey, SZDOWNLOADDIRVAL, NULL, &dwType, (LPBYTE)szDownloadDir, &cbData);
        RegCloseKey(hKey);
    }

    if (szDownloadDir[0] == 0)
        SHGetSpecialFolderPath(NULL, szDownloadDir, CSIDL_DESKTOPDIRECTORY, FALSE);

    // Get the file name. If there is no filename. create one called using the string resource in IDS_DOCUMENT

    pszSaveTo = PathFindFileName(pszPath);
    if (pszSaveTo)
    {
        DWORD cchData = cchSaveToFile;

        // Unescape the filename suggested by wininet.
        if (_PrepareURLForDisplayUTF8W(pszSaveTo, pszSaveToFile, &cchData, fUTF8Enabled, uiCP) != S_OK)
            StrCpyN(pszSaveToFile, pszSaveTo, cchSaveToFile);
            
        // Strip out any path that may have been encoded
        TCHAR * pszSaveToDst = pszSaveToFile;
        pszSaveTo = PathFindFileName(pszSaveToFile);
        if (pszSaveTo != pszSaveToFile)
        {
            while(*pszSaveTo)
                *pszSaveToDst++ = *pszSaveTo++;
            *pszSaveToDst = *pszSaveTo;
        }

        // Strip out the the cache's typical decoration of "(nn)"
        PathUndecorate (pszSaveToFile);
    }
    else
        MLLoadString(IDS_DOCUMENT, pszSaveToFile, cchSaveToFile);

    if (!g_fRunningOnNT) // Win9x isn't able to deal with DBCS chars in edit controls when UI lang is non-native OS lang
    {
        CHAR szBufA[MAX_PATH*2];
        int iRC = WideCharToMultiByte(CP_ACP, 0, pszSaveToFile, -1, szBufA, ARRAYSIZE(szBufA), NULL, NULL);
        if (iRC == 0)    // If we are unable to convert using system code page
            *pszSaveToFile = TEXT('\0');    // make suggested file name blank
    }
    
    OPENFILENAME OFN = {0};
    OFN.lStructSize        = sizeof(OFN);
    OFN.hwndOwner          = hDlg;
    OFN.nMaxFile           = cchSaveToFile;
    OFN.lpstrInitialDir    = szDownloadDir;

    OFN.lpstrFile = pszSaveToFile;
    OFN.Flags = OFN_HIDEREADONLY  | OFN_OVERWRITEPROMPT | OFN_EXPLORER |
                OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;

    if (!pszExt || !*pszExt)
        pszExt = PathFindExtension(pszPath);

    if (pszExt && *pszExt)
        OFN.lpstrDefExt = pszExt;

    // Try to get the file type name from the registry. To add to the filter pair strings
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0, KEY_READ, &hKey))
    {
        DWORD dwType, cbData = sizeof(szBuffer);
        fRegFileType = (ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szBuffer, &cbData));
        RegCloseKey(hKey);
    }

    if (fRegFileType)
    {
        fRegFileType = FALSE;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuffer, 0, KEY_READ, &hKey))
        {
            DWORD dwType, cbData = sizeof(szBuffer);
            szBuffer[0] = 0;

            fRegFileType = ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szBuffer, &cbData);
            if (fRegFileType)
            {
                // Now tack on the second part of the filter pair
                int cchBuffer = lstrlen(szBuffer) + 1;
                pszWalk = szBuffer + cchBuffer;
                cchWalk = ARRAYSIZE(szBuffer) - cchBuffer;
                StrCpyN(pszWalk, TEXT("*"), cchWalk);
                StrCatBuff(pszWalk, pszExt, --cchWalk); // sub 1 for * above
            }
            RegCloseKey(hKey);
        }
        cch = lstrlen(pszWalk);
    }

    // There was no registry entry for the file type or the entry did not have a default value
    // So create the file name type - "<file extension> DOCUMENT"
    if (!fRegFileType || !(*szBuffer))
    {
        szBuffer[0] = 0;
        pszWalk = szBuffer;
        cchWalk = ARRAYSIZE(szBuffer);
        MLLoadString(IDS_EXTDOCUMENT, szTemp, ARRAYSIZE(szTemp));
        cch = wnsprintf(pszWalk, cchWalk, szTemp, pszExt, TEXT('\0'), pszExt);
    }

    // Add in the pair for "*.* All files"
    pszWalk += (cch + 1);
    cchWalk -= (cch + 1);

    MLLoadString(IDS_ALLFILES, szTemp, ARRAYSIZE(szTemp));
    StrCpyN(pszWalk, szTemp, cchWalk);

    cch = lstrlen(pszWalk) + 1;
    pszWalk += cch;
    cchWalk -= cch;

    StrCpyN(pszWalk, ALLFILE_WILDCARD, cchWalk);

    cch = (lstrlen( ALLFILE_WILDCARD )+1); //Add the second NULL to the end of the string
    pszWalk += cch;
    cchWalk -= cch;

    if (cchWalk > 0)
        *pszWalk = 0; //because we had some garbage put after memset.

    OFN.lpstrFilter = szBuffer;

    if ((fRet = (!SHIsRestricted2W(hDlg, REST_NoSelectDownloadDir, NULL, 0))) 
        && (fRet = GetSaveFileName(&OFN)))
    {
        // If the download location was changed, save that off to the registry
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZEXPLORERKEY, 0, KEY_WRITE, &hKey))
        {
            StrCpyN(szBuffer, pszSaveToFile, ARRAYSIZE(szBuffer));
            PathRemoveFileSpec(szBuffer);

            if (szBuffer[0])
                RegSetValueEx(hKey, SZDOWNLOADDIRVAL, 0, REG_SZ, (LPBYTE)szBuffer, CbFromCch(lstrlen(szBuffer) + 1));

            RegCloseKey(hKey);
        }
    }

    return fRet;
}


BOOL CDownload::_GetSaveLocation()
{
    return ::_GetSaveLocation(_hDlg, _szPath, _szExt, _szSaveToFile, ARRAYSIZE(_szSaveToFile), _fUTF8Enabled, _uiCP);
}

BOOL CDownload::_SaveFile()
{
    SHFILEOPSTRUCT fo = { _hDlg, FO_COPY, _szPath, _szSaveToFile, FOF_NOCONFIRMATION | FOF_NOCOPYSECURITYATTRIBS};

    // Be sure the strings are double terminated
    DWORD dwLen = (DWORD)min(ARRAYSIZE(_szPath), lstrlen(_szPath) + 1);
    if (dwLen == 0)  // Not likely, but better to fail than trash someone else's data
        return FALSE;
    _szPath[dwLen] = TEXT('\0');
    _szPath[dwLen-1] = TEXT('\0');
    
    dwLen = (DWORD)min(ARRAYSIZE(_szSaveToFile), lstrlen(_szSaveToFile) + 1);
    if (dwLen == 0)
        return FALSE;
    _szSaveToFile[dwLen] = TEXT('\0');
    _szSaveToFile[dwLen-1] = TEXT('\0');

    // If the file is in the cache, we probably want to delete it from the
    // cache to free up some disk space rather than wait for it to be scavenged.
    // This is best done after _pib->Release called from ~CDownload.
    _fDeleteFromCache = TRUE;

    // Copy the file (which is locked, so can't move it) to its target destination.
    return !SHFileOperation(&fo);
}

void CDownload::_DeleteFromCache()
{
    INTERNET_CACHE_CONFIG_INFO CCInfo;
    DWORD dwCCIBufSize = sizeof(CCInfo);

    // Obtain the cache directory path.

    if (!GetUrlCacheConfigInfo (&CCInfo, &dwCCIBufSize, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        ASSERT(FALSE);
    }
    else if (0 == StrCmpNI (_szPath,
        CCInfo.CachePaths[0].CachePath,
        lstrlen(CCInfo.CachePaths[0].CachePath)))
    {
        // Attempt to delete the file from the cache only if resides under
        // the cache directory, otherwise we could in theory nuke a preinstalled
        // or edited cache entry.  Here a prefix match is also a string prefix
        // match since .CachePath will have a trailing slash ('/')

        DeleteUrlCacheEntry(_szURL);
    }
}


void CDownload::OpenUI(IMoniker* pmk, IBindCtx *pbc, BOOL fSaveAs, BOOL fSafe, LPWSTR pwzHeaders, DWORD dwVerb, DWORD grfBINDF, BINDINFO* pbinfo, LPCTSTR pszRedir, UINT uiCP, BOOL fConfirmed)
{
    TraceMsg(DM_DOWNLOAD, "CDownLoad::OpenUI called with fSaveAs=%d, verb=%d", fSaveAs, dwVerb);

    // CDownload will take ownership pbinfo.
    CDownload* pdld = new CDownload(fSaveAs, pwzHeaders, grfBINDF, pbinfo, fSafe, dwVerb, pszRedir, uiCP, fConfirmed);
    if (pdld) 
    {
        HWND hwnd = CreateDialogParam(MLGetHinst(), 
            MAKEINTRESOURCE(DLG_DOWNLOADPROGRESS), NULL, DownloadDlgProc, (LPARAM)pdld);
        pwzHeaders = NULL;   // Owner is now CDownload
        DWNLDMSG2("CDownLoad_OpenUI dialog created", hwnd);
        if (hwnd)
        {
            HRESULT hres = pdld->StartBinding(pmk, pbc);
            if (FAILED(hres))
            {
                TraceMsg(DM_DOWNLOAD, "CDownLoad::OpenUI() - StartBinding() Failed with hres=0x%x!", hres );

                ProcessStartbindingError(hwnd, MAKEINTRESOURCE(IDS_DOWNLOADFAILED),
                                         pdld->_szDisplay, MB_ICONWARNING, hres);
            }
            else
            {
                ShowWindow(hwnd, SW_SHOWNORMAL);
            }
        }
        else
        {
            delete pdld;
            pdld = NULL;
        }
    }

    if (pwzHeaders)
    {
        CoTaskMemFree(pwzHeaders);
        pwzHeaders = NULL;
    }
}

BOOL CDownload_MayProcessMessage(MSG* pmsg)
{
    if (g_hDlgActive)
        return IsDialogMessage(g_hDlgActive, pmsg);

    return FALSE;       // not processed
}

class CDownloadThreadParam {
#ifdef DEBUG
    const DWORD* _pdwSigniture;
    static const DWORD s_dummy;
#endif
public:
    DWORD   _dwVerb;
    DWORD   _grfBINDF;
    BINDINFO *_pbinfo;
    LPWSTR  _pszDisplayName;
    LPWSTR  _pwzHeaders;
    BOOL    _fSaveAs;
    BOOL    _fSafe;
    BOOL    _fConfirmed;
    IStream *_pStream;
    TCHAR   _szRedirURL[MAX_URL_STRING];
    UINT    _uiCP;

    ~CDownloadThreadParam() 
    {
        OleFree(_pszDisplayName);
        if (_pwzHeaders) 
            CoTaskMemFree(_pwzHeaders);
        if (_pStream)
            _pStream->Release();
        // CDownload releases our _pbinfo.
    }

    CDownloadThreadParam(LPWSTR pszDisplayName, LPWSTR pwzHeaders, BOOL fSaveAs, BOOL fSafe=FALSE, DWORD dwVerb=BINDVERB_GET, DWORD grfBINDF = 0, BINDINFO* pbinfo = NULL, LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, BOOL fConfirmed=FALSE )
        : _pszDisplayName(pszDisplayName), _fSaveAs(fSaveAs), _fSafe(fSafe), _pwzHeaders(pwzHeaders), _pStream(NULL), _dwVerb(dwVerb), _grfBINDF(grfBINDF), _pbinfo(pbinfo), _uiCP(uiCP), _fConfirmed(fConfirmed)
    {
#ifdef DEBUG
        _pdwSigniture = &s_dummy;
#endif
        if (pszRedir && lstrlen(pszRedir))
            StrCpyN(_szRedirURL, pszRedir, MAX_URL_STRING - 1);
        // CDownload releases our _pbinfo.
    }

    void SetStream(IStream *pStm)
    {
        if (_pStream)
        {
            _pStream->Release();
        }
        _pStream = pStm;

        if (_pStream)
        {
            _pStream->AddRef();
        }
    }
};

DWORD CALLBACK IEDownload_ThreadProc(void *pv)
{
    CDownloadThreadParam* pdtp = (CDownloadThreadParam*)pv;

    HRESULT hr;

    IBindCtx *pbc = NULL;
    if (pdtp->_pStream)
    {
        pdtp->_pStream->AddRef();
        hr = pdtp->_pStream->Seek(c_li0,STREAM_SEEK_SET,0);
        hr = CoGetInterfaceAndReleaseStream(pdtp->_pStream, IID_PPV_ARG(IBindCtx, &pbc));
        pdtp->SetStream(NULL);
    }

    if (pbc == NULL)
        CreateBindCtx(0, &pbc);

    //winse#12726:Give other thread a chance to finish its work.
    Sleep(100);

    hr = CDownLoad_OpenUIURL(pdtp->_pszDisplayName, pbc, pdtp->_pwzHeaders, TRUE, pdtp->_fSaveAs, pdtp->_fSafe,
                             pdtp->_dwVerb, pdtp->_grfBINDF, pdtp->_pbinfo, pdtp->_szRedirURL, pdtp->_uiCP, NULL, pdtp->_fConfirmed);

    if (SUCCEEDED(hr)) 
    {
        pdtp->_pwzHeaders = NULL;   // CDownload owns freeing headers now
        pdtp->_pbinfo = NULL;       // CDownload owns freeing pbinfo now.
    }

    delete pdtp;
    pdtp = NULL;

    if (pbc)
    {
        pbc->Release();
        pbc = NULL;
    }

    while (1)
    {
        MSG msg;

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

            // Note that for IE 3.0, the parking thread is also
            //  the owner of all modeless download dialog.
            if (CDownload_MayProcessMessage(&msg)) 
                continue;

            TranslateMessage(&msg);
            DispatchMessage(&msg);
            continue;
        }
        WaitMessage();
    }

    return 0;
}

void CDownLoad_OpenUI(IMoniker *pmk, IBindCtx *pbc, BOOL fSync, BOOL fSaveAs, BOOL fSafe, LPWSTR pwzHeaders, DWORD dwVerb, DWORD grfBINDF, BINDINFO* pbinfo, LPCTSTR pszRedir, UINT uiCP, IUnknown *punk, BOOL fConfirmed)
{
    TraceMsg(DM_DOWNLOAD, "CDownLoad_OpenUI called with fSync=%d fSaveAs=%d", fSync, fSaveAs);
    ASSERT(dwVerb == BINDVERB_GET || dwVerb == BINDVERB_POST);

    if (fSync) 
    {
        CDownload::OpenUI(pmk, pbc, fSaveAs, fSafe, pwzHeaders, dwVerb, grfBINDF, pbinfo, pszRedir, uiCP, fConfirmed);
        pwzHeaders = NULL;  // CDownload now owns headers
        return;
    }

    IDownloadManager *pdlm;
    HRESULT hr = IUnknown_QueryService(punk, SID_SDownloadManager, IID_PPV_ARG(IDownloadManager, &pdlm));
    if (FAILED(hr))
    {
        hr = CreateFromRegKey(TSZIEPATH, TEXT("DownloadUI"), IID_PPV_ARG(IDownloadManager, &pdlm));
    }

    if (SUCCEEDED(hr))
    {
        hr = pdlm->Download(pmk, pbc, dwVerb, grfBINDF, pbinfo, pwzHeaders, pszRedir, uiCP);
        pdlm->Release();
    }

    if (FAILED(hr))
    {
        if (pbc == NULL)
        {
            hr = CreateBindCtx(0, &pbc);
        }
        else
        {
            hr = S_OK;
            pbc->AddRef();
        }

        if (SUCCEEDED(hr))
        {
            LPWSTR pszDisplayName = NULL;
            hr = pmk->GetDisplayName(pbc, NULL, &pszDisplayName);
            if (SUCCEEDED(hr)) 
            {
                CDownloadThreadParam* pdtp = new CDownloadThreadParam(pszDisplayName, pwzHeaders, fSaveAs, fSafe, dwVerb, grfBINDF, pbinfo, pszRedir, uiCP, fConfirmed);
                if (pdtp) 
                {
                    pwzHeaders = NULL;  // ownership is to CDTP

                    // Note: IAsyncBindCtx has identicial interface as IBindCtx
                    IBindCtx *pbcAsync;
                    hr = pbc->QueryInterface(IID_IAsyncBindCtx, (void **)&pbcAsync);
                    if (SUCCEEDED(hr))
                    {
                        // This introduces a double bind, but only for the mk: protocol and
                        // the fix is needed for displaying pdfs and other special mime types.
                        if (_tcsnicmp(pszDisplayName, _T("mk:"), 3) == 0)
                        {
                            pbcAsync->Release();
                            pbcAsync = NULL;
                            hr = CreateBindCtx(0, &pbcAsync);
                        }

                        if (SUCCEEDED(hr))
                        {
                            IStream *pStm;
                            hr = CoMarshalInterThreadInterfaceInStream(IID_IBindCtx, pbcAsync, &pStm);
                            if (hr == S_OK)
                            {
                                pdtp->SetStream(pStm);
                                pStm->Release();
                            }
                            pbcAsync->Release();
                        }
                    }

                    if (!SHCreateThread(IEDownload_ThreadProc, pdtp, CTF_PROCESS_REF | CTF_REF_COUNTED | CTF_COINIT, NULL))
                    {
                        delete pdtp;
                        pdtp = NULL;
                    }
                } 
                else 
                {
                    OleFree(pszDisplayName);
                }
            }
            pbc->Release();
        }
    }

    CoTaskMemFree(pwzHeaders);  // may be NULL, we consume this in all cases
}

HRESULT CDownLoad_OpenUIURL(LPCWSTR pwszURL, IBindCtx *pbc, LPWSTR pwzHeaders, BOOL fSync,BOOL fSaveAs, BOOL fSafe, DWORD dwVerb, DWORD grfBINDF, BINDINFO* pbinfo, LPCTSTR pszRedir, UINT uiCP, IUnknown *punk, BOOL fConfirmed)
{
    HRESULT hr;
    ASSERT(pwszURL);
    if (pwszURL) 
    {
        IMoniker* pmk = NULL;
        hr = CreateURLMoniker(NULL, pwszURL, &pmk);
        if (SUCCEEDED(hr)) 
        {
            CDownLoad_OpenUI(pmk, pbc, fSync, fSaveAs, fSafe, pwzHeaders, dwVerb, grfBINDF, pbinfo, pszRedir, uiCP, punk, fConfirmed);
            pwzHeaders = NULL;  // CDownload now owns headers
            pmk->Release();
            hr = S_OK;
        }
        if (pwzHeaders)
            CoTaskMemFree(pwzHeaders);
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

HRESULT CDownload::StartBinding(IMoniker* pmk, IBindCtx *pbc)
{
    ASSERT(_pbc==NULL);
    HRESULT hr = S_OK;

    if (pbc == NULL)
    {
        hr = CreateBindCtx(0, &_pbc);
    }
    else
    {
        _pbc = pbc;
        _pbc->AddRef();
    }

    if (SUCCEEDED(hr))
    {
        hr = RegisterBindStatusCallback(_pbc, this, 0, 0);
        if (SUCCEEDED(hr)) 
        {
            hr = pmk->GetDisplayName(_pbc, NULL, &_pwszDisplayName);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuf[MAX_PATH];
                DWORD dwSize = ARRAYSIZE(szBuf);
                DWORD dwPUAF = PUAF_NOUI;

                DWORD dwPolicy = 0, dwContext = 0;
                int cch = lstrlen(_szURL);

                if (!cch)
                {
                    SHUnicodeToTChar(_pwszDisplayName, _szURL, ARRAYSIZE(_szURL));
                }

                TraceMsg(TF_SHDNAVIGATE, "CDld::StartBinding SHUnicodeToTChar returns %d (%s)", cch, _szURL);

                // The URL from GetDisplayName() is always fully
                // canonicalized and escaped.  Prepare it for display.
                if (PrepareURLForDisplay(_szURL, szBuf, &dwSize))
                    FormatUrlForDisplay(szBuf, _szDisplay, ARRAYSIZE(_szDisplay), NULL, 0, TRUE, _uiCP, NULL);
                else
                    FormatUrlForDisplay(_szURL, _szDisplay, ARRAYSIZE(_szDisplay), NULL, 0, TRUE, _uiCP, NULL);

                SetWindowText(GetDlgItem(_hDlg, IDD_NAME), _szDisplay);

                if (_grfBINDF & BINDF_ENFORCERESTRICTED)
                {
                    dwPUAF |= PUAF_ENFORCERESTRICTED;
                }

                ZoneCheckUrlEx(_szURL, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                               URLACTION_SHELL_FILE_DOWNLOAD, dwPUAF, NULL);
                dwPolicy = GetUrlPolicyPermissions(dwPolicy);
                if ((dwPolicy == URLPOLICY_ALLOW) || (dwPolicy == URLPOLICY_QUERY)) 
                {
                    IUnknown* punk = NULL;
                    hr = pmk->BindToStorage(_pbc, NULL, IID_PPV_ARG(IUnknown, &punk));
                    DWNLDMSG3("StartBinding pmk->BindToStorage returned", hr, punk);
                    if (SUCCEEDED(hr) || hr == E_PENDING)
                    {
                        hr = S_OK;
                        if (punk)
                        {
                            ASSERT(0);
                            punk->Release();
                        }

                    }
                    else 
                    {
                        TraceMsg(DM_ERROR, "CDld::StartBinding pmk->BindToStorage failed %x", hr);

                        HRESULT hrRevoke = RevokeBindStatusCallback( _pbc, this );

                        ASSERT( SUCCEEDED( hrRevoke ) );
                    }
                } 
                else
                {
                    TraceMsg(DM_ERROR, "CDld::StartBinding: Zone does not allow file download");

                    HRESULT hrRevoke = RevokeBindStatusCallback( _pbc, this );

                    ASSERT( SUCCEEDED( hrRevoke ) );

                    hr = E_ACCESSDENIED;
                }
            }
            else
            {
                TraceMsg(DM_ERROR, "CDld::StartBinding pmk->GetDisplayName failed %x", hr);

                HRESULT hrRevoke = RevokeBindStatusCallback( _pbc, this );

                ASSERT( SUCCEEDED( hrRevoke ) );
            }
        }
        else 
        {
            TraceMsg(DM_ERROR, "CDld::StartBinding RegisterBSC failed %x", hr);
        }
    }
    else
    {
        TraceMsg(DM_ERROR, "CDld::StartBinding CreateBindCtx failed %x", hr);
    }
    return hr;
}

HRESULT CDownload::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CDownload, IBindStatusCallback),   // IID_IBindStatusCallback
        QITABENT(CDownload, IAuthenticate),         // IID_IAuthenticate
        QITABENT(CDownload, IServiceProvider),      // IID_IServiceProvider
        QITABENT(CDownload, IHttpNegotiate),        // IID_IHttpNegotiate
        QITABENT(CDownload, IWindowForBindingUI),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDownload::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDownload::Release()
{
    DWNLDMSG2("CDownload::Release cRef=", _cRef);

    if (InterlockedDecrement(&_cRef))
        return _cRef;

    CDownload* pdld = (CDownload*) GetWindowLongPtr(_hDlg, DWLP_USER);
    if (pdld == this)
        SetWindowLongPtr(_hDlg, DWLP_USER, NULL);

    DWNLDMSG3("CDownload::Release delete this", pdld, this);

    delete this;
    return 0;
}

ULONG CDownload::AddRefDLD()
{
    return InterlockedIncrement(&_cRefDLD);
}

ULONG CDownload::ReleaseDLD()
{
    if (InterlockedDecrement(&_cRefDLD))
        return _cRefDLD;

    return 0;
}

CDownload::~CDownload()
{
    if (_pbinfo) {
        ReleaseBindInfo(_pbinfo);
        LocalFree(_pbinfo);
        _pbinfo = NULL;
    }

    if (_pib) {
        _pib->Release();
    }

    if (_pbc) {
        _pbc->Release();
    }

    if (_hicon) {
        DestroyIcon(_hicon);
    }

    if (_pwszDisplayName)
        OleFree(_pwszDisplayName);

    if (_fDeleteFromCache)
        _DeleteFromCache();

    if ( _pwzHeaders )
        CoTaskMemFree( _pwzHeaders );

    TraceMsg(TF_SHDLIFE, "CDownload::~CDownload being destructed");

    TraceMsg(TF_SHDTHREAD, "CDownload::EndDialogDLD calling PostQuitMessage");
    // Post the quit message ONLY if this flag is set. The constructor for the
    // derived class CDownloadURL resets the flag to FALSE because it doesn't
    // need any quit messages.
    if (!_fDontPostQuitMsg)
        PostQuitMessage(0);
}

#ifdef USE_LOCKREQUEST
HRESULT CDownload::LockRequestHandle(void)
{
    HRESULT hres = E_FAIL;
    HANDLE hLock;
    
    if (_pib)
    {
        IWinInetInfo* pwinet;
        hres = _pib->QueryInterface(IID_PPV_ARG(IWinInetInfo, &pwinet));
        if (SUCCEEDED(hres)) 
        {
            DWORD cbSize = sizeof(HANDLE);
            hres = pwinet->QueryOption(WININETINFO_OPTION_LOCK_HANDLE, &hLock, &cbSize);

            pwinet->Release();
        }
    }
    return hres;
}
#endif

HRESULT CDownload::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    DWNLDMSG3("OnStartBinding", _pib, pib);
    if (_pib) 
    {
        _pib->Release();
    }

    _pib = pib;
    if (_pib) 
    {
        _pib->AddRef();
    }

    SetQueryNetSessionCount(SESSION_INCREMENT);

    _fUTF8Enabled = UTF8Enabled();

    return S_OK;
}

HRESULT CDownload::GetPriority(LONG *pnPriority)
{
    DWNLDMSG("GetPriority", "called");
    *pnPriority = NORMAL_PRIORITY_CLASS;
    return S_OK;
}

HRESULT CDownload::OnLowResource(DWORD reserved)
{
    DWNLDMSG("OnLowResource", "called");
    return S_OK;
}


#define WM_DIALMON_FIRST        WM_USER+100

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY             WM_DIALMON_FIRST + 0

#define MIN_ACTIVITY_MSG_INTERVAL       15000

void IndicateWinsockActivity(void)
{
    // if there is an autodisconnect monitor, send it an activity message
    // so that we don't get disconnected during long downloads.  For perf's sake,
    // don't send a message any more often than once every MIN_ACTIVITY_MSG_INTERVAL
    // milliseconds (15 seconds).  Use GetTickCount to determine interval;
    // GetTickCount is very cheap.
    DWORD dwTickCount = GetTickCount();
    // Sharing this among multiple threads is OK
    static DWORD dwLastActivityMsgTickCount = 0;
    DWORD dwElapsed = dwTickCount - dwLastActivityMsgTickCount;
    
    // have we sent an activity message recently?
    if (dwElapsed > MIN_ACTIVITY_MSG_INTERVAL) 
    {
        HWND hwndMonitorApp = FindWindow(TEXT("MS_AutodialMonitor"), NULL);
        if (hwndMonitorApp) 
        {
            PostMessage(hwndMonitorApp, WM_WINSOCK_ACTIVITY, 0, 0);
        }
        hwndMonitorApp = FindWindow(TEXT("MS_WebcheckMonitor"), NULL);
        if (hwndMonitorApp) 
        {
            PostMessage(hwndMonitorApp, WM_WINSOCK_ACTIVITY, 0, 0);
        }
        
        // record the tick count of the last time we sent an
        // activity message
        dwLastActivityMsgTickCount = dwTickCount;
    }
}

#define MAXCALCCNT 5

HRESULT CDownload::OnProgress(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText)
{
    DWNLDMSG4("OnProgress", ulProgress, ulProgressMax, ulStatusCode);
    TCHAR szBytes[MAX_BYTES_STRLEN];
    TCHAR szBytesMax[MAX_BYTES_STRLEN];
    TCHAR szBuf[MAX_PATH];      // OK with MAX_PATH
    LPTSTR pszFileName = NULL;
    HWND hwndShow;
    DWORD dwCur;

    switch (ulStatusCode)
    {
        case BINDSTATUS_BEGINDOWNLOADDATA:
            hwndShow = GetDlgItem(_hDlg, ulProgressMax ? IDD_PROBAR : IDD_NOFILESIZE);
            if (!IsWindowVisible(hwndShow))
            {
                ShowWindow(GetDlgItem(_hDlg, ulProgressMax ? IDD_NOFILESIZE : IDD_PROBAR), SW_HIDE);
                ShowWindow(hwndShow, SW_SHOW);
            }

            _ulOldProgress = ulProgress;
            // fall thru
        case BINDSTATUS_DOWNLOADINGDATA:
        case BINDSTATUS_ENDDOWNLOADDATA:
            // Prevent machines with APM enabled from suspending during download
            _SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
                
            _dwFileSize = max(ulProgressMax, ulProgress);
            
            // every once in a while, send message
            // to the hidden window that detects inactivity so that it doesn't
            // think we are inactive during a long download
            IndicateWinsockActivity();
            // Sometimes OnProgress is called by folks who do not create a dialog
            if (_hDlg )
            {
                if (!_fStrsLoaded)
                {
                     MLLoadString(IDS_TITLEPERCENT, _szTitlePercent, ARRAYSIZE(_szTitlePercent));
                     MLLoadString(IDS_ESTIMATE, _szEstimateTime, ARRAYSIZE(_szEstimateTime));
                     MLLoadString(IDS_TITLEBYTES, _szTitleBytes, ARRAYSIZE(_szTitleBytes));
                     MLLoadString(IDS_BYTESCOPIED, _szBytesCopied, ARRAYSIZE(_szBytesCopied));
                     MLLoadString(IDS_TRANSFERRATE, _szTransferRate, ARRAYSIZE(_szTransferRate));
                    _fStrsLoaded = TRUE;
                }

                // Get the file name of the file being downloaded
                pszFileName = PathFindFileName(_szURL);

                dwCur = GetTickCount();
                if (_dwOldCur == 0)   // Allow the download to get started before displaying stats
                    _dwOldCur = dwCur;

                if ((ulProgressMax > 0) && _fDownloadStarted)
                {
                    if (_hDlg) 
                    {
                        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETRANGE32, 0, _dwFileSize);
                        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETPOS, ulProgress, 0);
                    }

                    if (!_fFirstTickValid) 
                    {
                        _dwFirstSize = ulProgress;
                        _fFirstTickValid = TRUE;

                        SetWindowText(GetDlgItem(_hDlg, IDD_NAME), _szDisplay);
                    } 
                    else
                    {
                        if ((ulProgress - _dwFirstSize) && _hDlg) 
                        {
                            // Recompute and display stats at least every second
                            if ((dwCur - _dwOldCur) >= 1000)
                            {
                                _dwOldCur = dwCur;  // Save current tick count
                                
                                TCHAR szTime[32];
                                DWORD dwSpent = ((dwCur - _dwFirstTick)+500) / 1000;
                                ULONG ulLeft = _dwFileSize - ulProgress;
                                DWORD dwRate = _dwOldRate;
                                dwRate = (ulProgress - _ulOldProgress) / (dwSpent ? dwSpent : 1);

                                TraceMsg(DM_PROGRESS, "OnProgress ulProgress=%d ulGot=%d dwSpent=%d ulLeft=%d", ulProgress, (ulProgress - _dwFirstSize), dwSpent, ulLeft);
                                
                                // Compute & display estimated time left to download, bytes so far, total bytes
                                DWORD dwEst;
                                if (ulLeft > 0x100000L)     // To avoid overflow, use KB for >1MB file.
                                    dwEst = (ulLeft >> 10) / ((dwRate >> 10) ?(dwRate >> 10) :1);
                                else
                                    dwEst = ulLeft / (dwRate ?dwRate :1);
                                    
                                if (dwEst == 0)
                                    dwEst = 1;

                                TraceMsg(DM_PROGRESS, "OnProgress Estimated time left = %d", dwEst);

                                StrFromTimeInterval(szTime, ARRAYSIZE(szTime), dwEst * 1000, 3);
                                LPTSTR pszTime = szTime;
                                while(*pszTime && (*pszTime == ' '))
                                    pszTime++;
                                _FormatMessage(_szEstimateTime, szBuf, ARRAYSIZE(szBuf), pszTime,
                                               StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN),
                                               StrFormatByteSize(_dwFileSize, szBytesMax, MAX_BYTES_STRLEN));
                                TraceMsg(DM_PROGRESS, "OnProgress Estimated string = %s", szBuf);
                                SetDlgItemText(_hDlg, IDD_TIMEEST, szBuf);
                                
                                _dwOldEst = dwEst;

                                // Compute & display transfer rate
                                if (dwRate != _dwOldRate)
                                {
                                    _dwOldRate = dwRate;
                                    _FormatMessage(_szTransferRate, szBuf, ARRAYSIZE(szBuf), StrFormatByteSize(dwRate, szBytes, MAX_BYTES_STRLEN));
                                    SetDlgItemText(_hDlg, IDD_TRANSFERRATE, szBuf);
                                }
                            }

                            // Compute & display percentage of download completed
                            DWORD dwPcent = (100 - MulDiv(_dwFileSize - ulProgress, 100, _dwFileSize));
                            if (dwPcent != _dwOldPcent)
                            {
                                _dwOldPcent = dwPcent;
                                if (dwPcent == 100)  // Don't peg the meter until we've completed
                                    dwPcent = 99;
                                    
                                TCHAR szBuf2[MAX_PATH];
                                DWORD dwSize = ARRAYSIZE(szBuf2);
                                if (PrepareURLForDisplay(pszFileName, szBuf2, &dwSize))
                                    _FormatMessage(_szTitlePercent, szBuf, ARRAYSIZE(szBuf), (UINT)dwPcent, szBuf2);
                                else
                                    _FormatMessage(_szTitlePercent, szBuf, ARRAYSIZE(szBuf), (UINT)dwPcent, pszFileName);

                                SetWindowText(_hDlg, szBuf);
                            }
                        }
                    }
                }
                else if (_hDlg && _fDownloadStarted)    // Unknown file size, just show bytes and rate
                {
                    // Recompute and display stats at most every second
                    if ((dwCur - _dwOldCur) >= 1000)
                    {
                        _dwOldCur = dwCur;  // Save current tick count

                        DWORD dwSpent = ((dwCur - _dwFirstTick)+500) / 1000;
                        DWORD dwRate = ulProgress / (dwSpent ? dwSpent : 1);

                        _FormatMessage(_szBytesCopied, szBuf, ARRAYSIZE(szBuf),
                                         StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN));
                        TraceMsg(DM_PROGRESS, "OnProgress string = %s", szBuf);
                        SetDlgItemText(_hDlg, IDD_TIMEEST, szBuf);

                        _FormatMessage(_szTransferRate, szBuf, ARRAYSIZE(szBuf), StrFormatByteSize(dwRate, szBytes, MAX_BYTES_STRLEN));
                        SetDlgItemText(_hDlg, IDD_TRANSFERRATE, szBuf);

                        {
                            TCHAR szBuf2[MAX_PATH];
                            DWORD dwSize = ARRAYSIZE(szBuf2);

                            if (PrepareURLForDisplay (pszFileName, szBuf2, &dwSize))
                                _FormatMessage(_szTitleBytes, szBuf, ARRAYSIZE(szBuf),
                                                StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN),szBuf2);
                            else
                                _FormatMessage(_szTitleBytes, szBuf, ARRAYSIZE(szBuf),
                                                StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN), pszFileName);
                            SetWindowText(_hDlg, szBuf);
                        }
                    }
                }
            }
            break;
        default:    // ulStatusCode
            break;
    }
    return S_OK;
}

HRESULT CDownload::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
    TraceMsg(DM_DOWNLOAD, "OnStopBinding called with hrError==%x", hrError);

    HRESULT hrDisplay = hrError;
    AddRef(); // Guard against last Release by _RevokeObjectParam

    HRESULT hres = RevokeBindStatusCallback(_pbc, this);
    AssertMsg(SUCCEEDED(hres), TEXT("URLMON bug??? RevokeBindStatusCallback failed %x"), hres);

    if (_pib) 
    {
        CLSID clsid;
        LPWSTR pwszError = NULL;

        HRESULT hresT = _pib->GetBindResult(&clsid, (DWORD *)&hrDisplay, &pwszError, NULL);
        TraceMsg(TF_SHDBINDING, "DLD::OnStopBinding called GetBindResult %x->%x (%x)", hrError, hrDisplay, hresT);
        if (SUCCEEDED(hresT)) 
        {
            //
            // URLMON returns a native Win32 error.
            //
            if (hrDisplay && SUCCEEDED(hrDisplay))
                hrDisplay = HRESULT_FROM_WIN32(hrDisplay);

            if (pwszError)
                OleFree(pwszError);
        }

        // We don't call IBinding::Release until ~CDownload
        // because we need to guarantee the download file
        // exists until we have copied or executed it.
    }

#ifdef DEBUG
    if (hrError==S_OK && GetKeyState(VK_CONTROL) < 0) 
    {
        hrError = E_FAIL;
    }
#endif

    if (FAILED(hrError) && hrError != E_ABORT) 
    {
        IE_ErrorMsgBox(NULL, _hDlg, hrDisplay, szError,_szDisplay, IDS_CANTDOWNLOAD, MB_OK|MB_ICONSTOP);
    }

    if (g_hCritOpMutex != NULL)
    {
        CloseHandle(g_hCritOpMutex);
        g_hCritOpMutex = NULL;
    }

    SetQueryNetSessionCount(SESSION_DECREMENT);
    
    if (!_fGotFile || !_fDownloadCompleted) 
    {
        AssertMsg(FAILED(hrError), TEXT("CDownload::OnStopBinding is called, but we've never got a file -- URLMON bug"));

        if (!_fEndDialogCalled) 
        {
            FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);
        }
    }

    Release(); // Guard against last Release by _RevokeObjectParam
    return S_OK;
}

HRESULT CDownload::GetBindInfo(DWORD* grfBINDINFOF, BINDINFO *pbindinfo)
{
    TraceMsg(DM_DOWNLOAD, "DWNLD::GetBindInfo called when _pbinfo==%x", _pbinfo);

    if ( !grfBINDINFOF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;

    if (_pbinfo) {
        // Give the ownership to URLMON... shallow copy; don't use CopyBindInfo().
        // Don't forget to keep pbindinfo cbSize!
        DWORD cbSize = pbindinfo->cbSize;
        CopyMemory( pbindinfo, _pbinfo, min(_pbinfo->cbSize, cbSize) );
        pbindinfo->cbSize = cbSize;

        if (pbindinfo->cbSize > _pbinfo->cbSize)
        {
            ZeroMemory((BYTE *)pbindinfo + _pbinfo->cbSize, pbindinfo->cbSize - _pbinfo->cbSize);
        }

        LocalFree(_pbinfo);
        _pbinfo = NULL;

    } else {
        // We don't have a BINDINFO our selves so
        // clear BINDINFO except cbSize
        DWORD cbSize = pbindinfo->cbSize;
        ZeroMemory( pbindinfo, cbSize );
        pbindinfo->cbSize = cbSize;
        if (UTF8Enabled())
            pbindinfo->dwOptions = BINDINFO_OPTIONS_ENABLE_UTF8;
    }

    // #52524. With post build ~1100, If we do not return the following flags when URLMon calls
    // GetBindInfo(), It will bind to the storage synchronously. (judej, danpoz)
    *grfBINDINFOF = _grfBINDF | BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    return S_OK;
}

HRESULT CDownload::OnDataAvailable(DWORD grfBSC, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    DWORD dwOptions = 0;

    DWNLDMSG3("OnDataAvailable (grf,pstg)", grfBSC, pstgmed);

    _dwTotalSize = dwSize; // keep track of number of bytes downloaded
    
    if (SUCCEEDED(_GetRequestFlagFromPIB(_pib, &dwOptions)) && (dwOptions & INTERNET_REQFLAG_CACHE_WRITE_DISABLED)) 
    {
        _fWriteHistory = FALSE;
    }
    
    if (grfBSC & BSCF_LASTDATANOTIFICATION) 
    {
        _fDownloadCompleted = TRUE;
    }
    //
    //   This code gets the file name from pstgmed, when it became
    //  available. URLMon is supposed to pass it even though the file
    //  is not completely ready yet.
    //
    if (!_fGotFile && pstgmed) 
    {
        Animate_Stop(GetDlgItem(_hDlg, IDD_ANIMATE));
        if (pstgmed->tymed == TYMED_FILE) 
        {
            TCHAR szBuf[MAX_PATH];  // ok with MAX_PATH (because we truncate)

            SHUnicodeToTChar(pstgmed->lpszFileName, _szPath, ARRAYSIZE(_szPath));
            // Because of redirection the _szURL could be http://.../redir.dll or query.exe.
            // Whereas the actual filename would be something else. The Cache filename is generated
            // by wininet after it has figured out what the real filename is. However, it might contain
            // a "(1)" or a "(2)" at the end of the file name.

            TCHAR szURL[MAX_URL_STRING];

            StrCpyN(szURL, _szURL, ARRAYSIZE(szURL));

            TCHAR * pszURLFName = PathFindFileName(szURL);
            TCHAR * pszCacheFName = PathFindFileName(_szPath);

            // Unescape the filename suggested by wininet.
            DWORD cch = ARRAYSIZE(szBuf);
            if (_PrepareURLForDisplayUTF8W(pszCacheFName, szBuf, &cch, _fUTF8Enabled, _uiCP) != S_OK)
                StrCpyN(szBuf, pszCacheFName, ARRAYSIZE(szBuf));


            // Strip out any path that may have been encoded
            pszCacheFName = szBuf;
            TCHAR *pszSrc = PathFindFileName(szBuf);
            if (pszSrc != szBuf)
            {
                while(*pszSrc)
                    *pszCacheFName++ = *pszSrc++;
                *pszCacheFName = *pszSrc;
            }

            // Use the Cache name. pszURLFName point to the file name in szURL. Just overwrite it
            if (pszURLFName && szBuf)
            {
                StrCpyN(pszURLFName, szBuf, ARRAYSIZE(szURL) - ((int)(pszURLFName-szURL)/sizeof(TCHAR)));
                FormatUrlForDisplay(szURL, _szDisplay, ARRAYSIZE(_szDisplay), NULL, 0, TRUE, _uiCP, NULL);
            }

            DWNLDMSG("OnDataAvailable got TYMED_FILE", _szPath);
            _fGotFile = TRUE;

            TCHAR szMime[MAX_PATH];
            if (GetClipboardFormatName(pformatetc->cfFormat, szMime, sizeof(szMime)/sizeof(szMime[0])))
            {
                MIME_GetExtension(szMime, (LPTSTR) _szExt, SIZECHARS(_szExt));
            }

            SetWindowText(GetDlgItem(_hDlg, IDD_NAME), _szDisplay);

            UINT uRet = _MayAskUserIsFileSafeToOpen(szMime);
            switch (uRet) {
            case IDOK:
                MLLoadString(IDS_OPENING, szBuf, ARRAYSIZE(szBuf));
                break;

            case IDD_SAVEAS:
                _fSaveAs = TRUE;
                _fCallVerifyTrust = FALSE;
                MLLoadString(IDS_SAVING, szBuf, ARRAYSIZE(szBuf));
                break;

            case IDCANCEL:
                FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);

                //
                // HACK: Under a certain condition, we receive one more
                //  OnDataAvailable from URLMON with BSCF_LASTDATANOTIFICATION
                //  before this posted message is dispatched. It causes
                //  WinVerifyTrust call, which is wrong. To prevent it,
                //  we unset this flag.
                //
                //  We still assumes that OnStopBinding will not happen before
                //  this message is dispatched. In IE 4.0, we should introduce
                //  another flag (_fCancelled) to make it more robust.
                //
                _fCallVerifyTrust = FALSE;
                return S_OK;

            }

            SetDlgItemText(_hDlg, IDD_OPENIT, szBuf);

            if (_fSaveAs)
            {
                if (!_GetSaveLocation())
                {
                    FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);
                    return S_OK;
                }
                StrCpyN(szBuf, _szSaveToFile, ARRAYSIZE(szBuf));

                RECT rect;
                GetClientRect(GetDlgItem(_hDlg, IDD_DIR), &rect);
                PathCompactPath(NULL, szBuf, rect.right);
            }
            else
                MLLoadString(IDS_DOWNLOADTOCACHE, szBuf, ARRAYSIZE(szBuf));

            SetDlgItemText(_hDlg, IDD_DIR, szBuf);
            Animate_Play(GetDlgItem(_hDlg, IDD_ANIMATE),0, -1, -1);
            
            if (_dwFirstTick == 0)   // Start the timer
                _dwFirstTick = GetTickCount();
        }
        else
        {
            TraceMsg(DM_WARNING, "CDownload::OnDataAvailable pstgmed->tymed (%d) != TYMED_FILE", pstgmed->tymed);
        }
        _fDownloadStarted = TRUE;
    }

    if (_fDownloadCompleted) 
    {
#ifdef CALL_WVT
        if (_fCallVerifyTrust)
        {
            ShowWindow(_hDlg, SW_HIDE);
            UINT uRet = _VerifyTrust(_hDlg, _szPath, _szDisplay);
            switch (uRet) {
            case IDOK:
                break;

            default:
                // We assume _VerifyTrust always is able to open the file
                // passed from URLMON. If it fails, we bail with no UI.
                ASSERT(0);
                // Fall through
            case IDCANCEL:
                _fDeleteFromCache = TRUE;
                FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);
                return S_OK;
            }
        }
#endif // CALL_WVT

        DWNLDMSG3("OnDataAvailable calling Animate_Stop", _hDlg, GetDlgItem(_hDlg, IDD_ANIMATE));
        Animate_Stop(GetDlgItem(_hDlg, IDD_ANIMATE));

        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETRANGE32, 0, 100);
        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETPOS, 100, 0);

        if (_fSaveAs) {
            FORWARD_WM_COMMAND(_hDlg, IDD_SAVEAS, NULL, 0, PostMessage);
        } else {
#ifdef USE_LOCKREQUEST
            LockRequestHandle();  // Tell wininet that we want the file locked to allow the app to open it.
                                  // This prevents wininet from deleting the file from the cache before the
                                  // app gets a chance to use it.  When wininet sees this file is locked, it
                                  // will add the file to the scavenger leak list and attempt to delete the
                                  // file in the future.
#endif
            
            FORWARD_WM_COMMAND(_hDlg, IDOK, NULL, 0, PostMessage);
        }
    }
    return S_OK;
}

HRESULT CDownload::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DWORD dwOptions = 0;

    DWNLDMSG3("OnObjectAvailable (riid,punk)", riid, punk);

    if (SUCCEEDED(_GetRequestFlagFromPIB(_pib, &dwOptions)) && (dwOptions & INTERNET_REQFLAG_CACHE_WRITE_DISABLED)) 
    {
        _fWriteHistory = FALSE;
    }

    return S_OK;
}

/* *** IHttpNegotiate ***  */
HRESULT CDownload::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
        DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    if ((!_pwzHeaders) || (!pszAdditionalHeaders))
        return S_OK;

    DWORD cbHeaders = (lstrlenW(_pwzHeaders) + 1) * sizeof(WCHAR);
    LPWSTR pwzHeaders = (LPWSTR)CoTaskMemAlloc(cbHeaders + sizeof(WCHAR));

    if (pwzHeaders)
    {
        memcpy (pwzHeaders, _pwzHeaders, cbHeaders);
        *pszAdditionalHeaders = pwzHeaders;
    }
    // Caller owns freeing *pszAdditionalHeaders
    return S_OK;
}

HRESULT CDownload::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders, 
                              LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders)
{
    return S_OK;
}


BOOL _RememberFileIsSafeToOpen(LPCTSTR szFileClass)
{
    DWORD dwEditFlags;
    ULONG cb = sizeof(dwEditFlags);

    HRESULT hr;
    IQueryAssociations *passoc = NULL;
    BOOL bRet = FALSE;

    hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &passoc));
    if (SUCCEEDED(hr) && passoc)
    {
        hr = passoc->Init(NULL, szFileClass, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = passoc->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwEditFlags, &cb);
            if (SUCCEEDED(hr))
            {
                dwEditFlags &= ~FTA_NoEdit;
                dwEditFlags |= FTA_OpenIsSafe;
            }
        }
        passoc->Release();
    }

    if (FAILED(hr))
        dwEditFlags = FTA_OpenIsSafe;   

    return (SHSetValue(HKEY_CLASSES_ROOT, szFileClass, TEXT("EditFlags"),
                             REG_BINARY, (BYTE*)&dwEditFlags,
                             sizeof(dwEditFlags)) == ERROR_SUCCESS);
}

struct SAFEOPENDLGPARAM {
    LPCTSTR pszFileClass;
    LPCTSTR pszFriendlyURL;
    LPCTSTR pszURL;
    HWND    hwndTT;
    TCHAR*  pszTTText;
    LPCTSTR pszCacheFile;
    DWORD   uiCP;
    BOOL    fTypeMismatch;
    BOOL    fShellExecPrompt;
    BOOL    fPackagerCommandPrompt;
};

INT_PTR CALLBACK SafeOpenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT id;
    static BOOL bCancelled;
    SAFEOPENDLGPARAM* param = (SAFEOPENDLGPARAM*) GetWindowLongPtr(hDlg, DWLP_USER);

    if ((param == NULL) && (uMsg != WM_INITDIALOG))
        return FALSE;
        
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        BOOL fUnsafeFile;
        TCHAR szFriendlyName[MAX_DISPLAY_LEN] = {TEXT('\0')};
        TCHAR szFriendlyFrom[MAX_DISPLAY_LEN] = {TEXT('\0')};
        TCHAR szProcessedURL[MAX_URL_STRING] = {TEXT('\0')};
        DWORD dwSize = ARRAYSIZE(szProcessedURL);

        if (lParam == NULL)
            return FALSE;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        param = (SAFEOPENDLGPARAM*)lParam;

        // init unsafe file to mismatch between progid and file
        fUnsafeFile = param->fTypeMismatch;

        // Determine whether or not to gray out the Always ask checkbox. We wil gray out in the following cases
        // 1. If we were not told what the file class is
        // 2. If the file class is in the unsafe extensions list
        // 3. if the file extension in the URL is in the unsafe extensions list
        // 4. if the cache file extension is in the unsafe extensions list (if we are redirected)
        TCHAR * pszExt = NULL;
        TCHAR * pszCacheExt = NULL;

        if (param->pszURL)
            pszExt = PathFindExtension(param->pszURL);

        if (param->pszCacheFile)
            pszCacheExt = PathFindExtension(param->pszCacheFile);

        if(param->fPackagerCommandPrompt)
        {
            fUnsafeFile = TRUE;
        }
        else if (pszExt || pszCacheExt)
        {
            if (pszExt && AssocIsDangerous(pszExt))
                fUnsafeFile = TRUE;
            else if (pszCacheExt && AssocIsDangerous(pszCacheExt))
                fUnsafeFile = TRUE;
        }
        else
        {
            fUnsafeFile = TRUE;
        }

        if (fUnsafeFile || SHRestricted2(REST_AlwaysPromptWhenDownload, NULL, 0))
            EnableWindow(GetDlgItem(hDlg, IDC_SAFEOPEN_ALWAYS), FALSE);
        // The check box is always checked by default
        CheckDlgButton(hDlg, IDC_SAFEOPEN_ALWAYS, TRUE);
        
        // adjust the warning
        if (fUnsafeFile)
        {
            HICON hIcon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PRIVACY_WARN),
                            IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
            if (hIcon != NULL)
                SendDlgItemMessage(hDlg, IDC_SAFEOPEN_WARNICON, STM_SETICON, (WPARAM)hIcon, 0);
        }
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_SAFEOPEN_WARNTEXT), SW_HIDE);
        }

        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDC_SAFEOPEN_FILENAME);
        SHSetDefaultDialogFont(hDlg, IDC_SAFEOPEN_FILETYPE);
        SHSetDefaultDialogFont(hDlg, IDC_SAFEOPEN_FILEFROM);
        
        // Get the URL for the tooltip. Also get URL for the display string if we weren't passed one
        if (param->pszURL)
        {
            if (!PrepareURLForDisplay(param->pszURL, szProcessedURL, &dwSize))
            {
                dwSize = ARRAYSIZE(szProcessedURL);
                StrCpyN(szProcessedURL, param->pszURL, dwSize);
            }
        }

        // Now figure out what we want to display
        if(param->fPackagerCommandPrompt)
        {
            // If this was a packager command line, then just display the full command as passed in param->pszURL
            StrCpyN(szFriendlyName, param->pszURL, ARRAYSIZE(szFriendlyName));
        }
        else
        {
            FormatUrlForDisplay((LPTSTR)param->pszURL, szFriendlyName, ARRAYSIZE(szFriendlyName), szFriendlyFrom, ARRAYSIZE(szFriendlyFrom),
                            TRUE, param->uiCP, (PWSTR)param->pszCacheFile);
        }

        
        SetDlgItemText(hDlg, IDC_SAFEOPEN_FILENAME, szFriendlyName);

        if(param->fPackagerCommandPrompt)
        {
            // If it was a packager command line, then display "Unknown" for the from
            MLLoadString(IDS_VALUE_UNKNOWN, szFriendlyFrom, ARRAYSIZE(szFriendlyFrom)); 
            SetDlgItemText(hDlg, IDC_SAFEOPEN_FILEFROM, szFriendlyFrom);
        }
        else
        {
            if (szFriendlyFrom[0] != '\0')
                SetDlgItemText(hDlg, IDC_SAFEOPEN_FILEFROM, szFriendlyFrom);
        }

        if (param->pszFileClass || pszCacheExt)
        {
            DWORD cchName = ARRAYSIZE(szFriendlyName);

            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_FRIENDLYDOCNAME,
                (param->pszFileClass ? param->pszFileClass : pszCacheExt), NULL, szFriendlyName, &cchName)))
            {
                SetDlgItemText(hDlg, IDC_SAFEOPEN_FILETYPE, szFriendlyName);
            }
        }

        int cch = lstrlen(szProcessedURL) + 1;
        param->pszTTText = (TCHAR*)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (param->pszTTText)
        {
            StrCpyN(param->pszTTText, szProcessedURL, cch);
            if (param->hwndTT = CreateWindow(TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP,
                                      CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
                                      hDlg, NULL, HINST_THISDLL, NULL))
            {
                TOOLINFO ti;

                ti.cbSize = sizeof(ti);
                ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
                ti.hwnd = hDlg;
                ti.uId = (UINT_PTR) GetDlgItem(hDlg, IDC_SAFEOPEN_FILENAME);
                ti.lpszText = LPSTR_TEXTCALLBACK;
                ti.hinst = HINST_THISDLL;
                GetWindowRect((HWND)ti.uId, &ti.rect);
                SendMessage(param->hwndTT, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                SendMessage(param->hwndTT, TTM_SETMAXTIPWIDTH, 0, 300);
            }
        }
        if (param->fShellExecPrompt)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_SAFEOPEN_AUTOSAVE), FALSE);
            // make Cancel the default action
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDCANCEL), TRUE);
        }
        else
        {
            // make Save the default action
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_SAFEOPEN_AUTOSAVE), TRUE);
        }
        return FALSE;
    }

    case WM_NOTIFY:
    {
        LPTOOLTIPTEXT lpTT = (LPTOOLTIPTEXT) lParam;
        if (lpTT->hdr.code == TTN_NEEDTEXT)
        {
            lpTT->lpszText = param->pszTTText;
            lpTT->hinst = NULL;
        }
        break;
    }

   case WM_DESTROY:

        //deal with checkbox
        if ((!bCancelled) &&  (!IsDlgButtonChecked(hDlg, IDC_SAFEOPEN_ALWAYS)) && param->pszURL)
        {
            // Now save EditFlags at the key value value that the filetypes dialog will get/set.
            TCHAR * pszExt = PathFindExtension(param->pszURL);
            if (*pszExt)
            {
                TCHAR szFileClass[MAX_PATH];
                ULONG cb = sizeof(szFileClass);
                *szFileClass = TEXT('\0');
                SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szFileClass, &cb);
                if (*szFileClass)
                    _RememberFileIsSafeToOpen(szFileClass);
            }
        }

        SHRemoveDefaultDialogFont(hDlg);

        if (IsWindow(param->hwndTT))
            DestroyWindow(param->hwndTT);

        if (param->pszTTText)
        {
            LocalFree(param->pszTTText);
            param->pszTTText = NULL;
        }

        return FALSE;

    case WM_COMMAND:
        id = GET_WM_COMMAND_ID(wParam, lParam);
        switch (id) 
        {
        case IDC_SAFEOPEN_AUTOOPEN:
            EndDialog(hDlg, IDOK);
            break;

        case IDC_SAFEOPEN_AUTOSAVE:
            EndDialog(hDlg, IDD_SAVEAS);
            break;
        
        case IDM_MOREINFO:
            SHHtmlHelpOnDemandWrap(hDlg, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("filedown.htm"), ML_CROSSCODEPAGE);
            break;

        case IDCANCEL:
            bCancelled = TRUE;
            EndDialog(hDlg, id);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

UINT _ShowSafeOpenDialog(HWND hwnd, UINT idRes, SAFEOPENDLGPARAM *pparam)
{
    UINT uRet = -1;
    // is whistler ?
    if (IsOS(OS_WHISTLERORGREATER))
    {
        HMODULE hmod = LoadLibrary(TEXT("xpsp1res.dll"));
        if (hmod)
        {
            uRet = (UINT) DialogBoxParam(hmod, MAKEINTRESOURCE(idRes), hwnd, SafeOpenDlgProc, (LPARAM)pparam);
            FreeLibrary(hmod);
        }
    }
    
    if (uRet == -1)
        uRet = (UINT) DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(idRes), hwnd, SafeOpenDlgProc, (LPARAM)pparam);
    return uRet;
}

UINT OpenSafeOpenDialog(HWND hwnd, UINT idRes, LPCTSTR pszFileClass, LPCTSTR pszURL, LPCTSTR pszRedirURL, LPCTSTR pszCacheName, LPCTSTR pszDisplay, UINT uiCP, IUnknown *punk, BOOL fTypeMismatch)
{
    IDownloadManager *pdlm;
    HRESULT hr = IUnknown_QueryService(punk, SID_SDownloadManager, IID_PPV_ARG(IDownloadManager, &pdlm));
    if (SUCCEEDED(hr))
    {
        pdlm->Release();
        return IDD_SAVEAS;
    }
    
    LPCTSTR pszTemp = pszURL;
    if (pszRedirURL && lstrlen(pszRedirURL))
        pszTemp = pszRedirURL;

    SAFEOPENDLGPARAM param = { pszFileClass, pszDisplay, pszTemp, 0, 0, pszCacheName, uiCP, fTypeMismatch, FALSE, FALSE};

    return _ShowSafeOpenDialog(hwnd, idRes, &param);
}

STDAPI_(BOOL) SafeOpenPromptForShellExec(HWND hwnd, PCWSTR pszFile)
{
    SAFEOPENDLGPARAM param = { PathFindExtension(pszFile), NULL, pszFile, 0, 0, NULL, CP_ACP, TRUE, TRUE, FALSE};
    return IDOK == _ShowSafeOpenDialog(hwnd, DLG_SAFEOPEN, &param);
}

STDAPI_(BOOL) SafeOpenPromptForPackager(HWND hwnd, PCWSTR pszFile, BOOL bFromCommandLine)
{
    SAFEOPENDLGPARAM param = { PathFindExtension(pszFile), NULL, pszFile, 0, 0, NULL, CP_ACP, TRUE, TRUE, bFromCommandLine};
    return IDOK == _ShowSafeOpenDialog(hwnd, DLG_SAFEOPEN, &param);
}

BOOL _OpenIsSafe(LPCTSTR pszClass)
{
    BOOL bRet = FALSE;
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &passoc));
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(NULL, pszClass, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            DWORD dwEditFlags;
            ULONG cb = sizeof(dwEditFlags);
            hr = passoc->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwEditFlags, &cb);
            if (SUCCEEDED(hr))
            {
                if (dwEditFlags & FTA_OpenIsSafe)
                    bRet = TRUE;
            }
        }
        passoc->Release();
    }
    return bRet;
}

UINT MayOpenSafeOpenDialog(HWND       hwnd,
                           LPCTSTR    pszFileClass,
                           LPCTSTR    pszURL,
                           LPCTSTR    pszCacheName,
                           LPCTSTR    pszDisplay,
                           UINT       uiCP,
                           IUnknown * punk,
                           IOleCommandTarget * pCmdTarget = NULL,
                           BOOL       fDisableOpen = FALSE)
{
    // Has some association
    UINT uiRet = IDIGNORE;  // default for no dlg displayed
    const LPCTSTR c_szExcluded[] = {TEXT(".ins"),TEXT(".isp")};
    const LPCTSTR c_szNoZoneCheckExtns[] = {TEXT(".cdf")};

    BOOL fSafe = _OpenIsSafe(pszFileClass);

    // We will not do Zone check on CDF files..#56297.
    if (!IsTypeInList(pszFileClass, c_szNoZoneCheckExtns, ARRAYSIZE(c_szNoZoneCheckExtns)))
    {
        DWORD dwPolicy = 0, dwContext = 0;
        ZoneCheckUrlEx(pszURL, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                    URLACTION_SHELL_FILE_DOWNLOAD, PUAF_NOUI, NULL);
        dwPolicy = GetUrlPolicyPermissions(dwPolicy);
        if ((dwPolicy != URLPOLICY_ALLOW) && (dwPolicy != URLPOLICY_QUERY))
        {
            ProcessStartbindingError(NULL, NULL, NULL, MB_ICONWARNING, E_ACCESSDENIED);
            return IDCANCEL;
        }
    }


    // Always ask for certain the types that we know to be unsafe. We will allow .ins and .isp
    // files through for the ICW folks.
    if (AssocIsDangerous(pszFileClass) &&
        !IsTypeInList(pszFileClass, c_szExcluded, ARRAYSIZE(c_szExcluded)))
        fSafe = FALSE;

    if (!fSafe || SHRestricted2(REST_AlwaysPromptWhenDownload, NULL,0))
    {
        VARIANT varOut = {0};

        if (pCmdTarget)
        {
            pCmdTarget->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD, 0, NULL, &varOut);
        }

        if ((V_VT(&varOut) != VT_BOOL) || (VARIANT_FALSE == V_BOOL(&varOut)))
        { 
            uiRet = OpenSafeOpenDialog(hwnd,
                                       DLG_SAFEOPEN,
                                       pszFileClass,
                                       pszURL,
                                       NULL,
                                       pszCacheName,
                                       pszDisplay,
                                       uiCP,
                                       punk,
                                       fDisableOpen);
        }
    }

    if (uiRet != IDOK && uiRet != IDD_SAVEAS && uiRet != IDIGNORE)
        DeleteUrlCacheEntry(pszURL);

    return(uiRet);
}

#ifdef CALL_WVT
// Returns:
//
//  IDOK     -- If it's trusted
//  IDNO     -- If it's not known (warning dialog requried)
//  IDCANCEL -- We need to stop download it
//
UINT _VerifyTrust(HWND hwnd, LPCTSTR pszFileName, LPCWSTR pszStatusText)
{
    UINT uRet = IDNO; // assume unknown
    HANDLE hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        HRESULT hres =  g_wvt.VerifyTrust(hFile, hwnd, pszStatusText);
        if (SUCCEEDED(hres)) 
        {
            uRet = IDOK;
        } 
        else 
        {
            ASSERT((hres != HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)) &&
                   (hres != HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND)));

            uRet = IDCANCEL;
        }

        CloseHandle(hFile);
    } 
    else
    {
        TraceMsg(DM_WARNING, "_VerifyTrust CreateFile failed %x", GetLastError());
    }

    TraceMsg(DM_WVT, "_VerifyTrust returning %d", uRet);
    return uRet;
}
#endif // CALL_WVT

//
// Returns:
//  IDOK: Continue download and open it
//  IDD_SAVEAS: Save it as a file
//  IDCANCEL: Stop downloading
//
UINT CDownload::_MayAskUserIsFileSafeToOpen(LPCTSTR pszMime)
{
    if (_fSaveAs || _fSafe) 
    {
        return (_fSaveAs ? IDD_SAVEAS : IDOK);    // no need to ask
    }

    // Force save as dialog if we are using SSL and 
    // HKCU\software\microsoft\windows\currentversion\internet settings\DisableCachingOfSSLPages is set
    DWORD dwValue;
    DWORD dwDefault = 0;
    DWORD dwSize;
    dwSize = sizeof(dwValue);
    SHRegGetUSValue(TSZWININETPATH, TEXT("DisableCachingOfSSLPages"), NULL, (LPBYTE)&dwValue, &dwSize, FALSE, (void *) &dwDefault, sizeof(dwDefault));

    if (dwValue != 0 && URL_SCHEME_HTTPS == GetUrlScheme(_szURL))
    {
        return(IDD_SAVEAS);
    }

    if(_fConfirmed)
    {
        return IDOK;
    }

    BOOL fUnknownType = TRUE;
    UINT uRet = IDNO;   // assume no extension or no association
    LPTSTR pszExt = PathFindExtension(_szPath);

    if (*pszExt) 
    {
        TCHAR szFileClass[MAX_PATH];
        memset(szFileClass, 0, ARRAYSIZE(szFileClass));
#ifdef CALL_WVT
        //
        //  If this is an EXE and we have WINTRUST ready to call,
        // don't popup any UI here at this point.
        if ((StrCmpI(pszExt, TEXT(".exe"))==0) && SUCCEEDED(g_wvt.Init()))
        {
            TraceMsg(DM_WVT, "_MayAskUIFSTO this is EXE, we call _VerifyTrust later");
            _fCallVerifyTrust = TRUE;
        }
#endif // CALL_WVT

        ULONG cb = SIZEOF(szFileClass);
        if ((RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szFileClass, (LONG*)&cb)
                == ERROR_SUCCESS) && * szFileClass)
        {
            fUnknownType = FALSE;
            uRet = MayOpenSafeOpenDialog(_hDlg, szFileClass, _szURL, _szPath, _szDisplay, _uiCP, NULL, NULL, FALSE);
            if (uRet == IDIGNORE)   // caller doesn't recognize IDIGNORE
                uRet = IDOK;
        }
    }

    if (fUnknownType) 
    {
        uRet = OpenSafeOpenDialog(_hDlg, DLG_SAFEOPEN, NULL, _szURL, NULL, _szPath, _szDisplay, _uiCP, NULL, FALSE);
    }

    return uRet;
}

// *** IAuthenticate ***
HRESULT CDownload::Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword)
{
    if (!phwnd || !pszUsername || !pszPassword)
        return E_POINTER;

    *phwnd = _hDlg;
    *pszUsername = NULL;
    *pszPassword = NULL;
    return S_OK;
}

HRESULT CDownload::GetWindow(REFGUID RefGUID, HWND *phWnd)
{
    if (IsEqualGUID(RefGUID, IID_IHttpSecurity))
    {
        *phWnd = _hDlg;
        return S_OK;
    }
    else
        return E_FAIL;
}

// *** IServiceProvider ***
HRESULT CDownload::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualGUID(guidService, IID_IAuthenticate)) 
    {
        return QueryInterface(riid, ppvObj);
    }
    return E_FAIL;
}

//   S_OK : continue with operation
//   S_FALSE : cancel operation.

HRESULT CDownload::PerformVirusScan(LPCTSTR szFileName)
{
    HRESULT hr = S_OK;  // default to accepting the file

    IVirusScanner *pvs;
    if (SUCCEEDED(CreateFromRegKey(TSZIEPATH, TEXT("VirusScanner"), IID_PPV_ARG(IVirusScanner, &pvs))))
    {
        STGMEDIUM stg;
        WCHAR wszFileName[MAX_PATH];

        VIRUSINFO vi;
        vi.cbSize = sizeof(VIRUSINFO);

        //
        // VIRUSINFO lpszFileName is not defined as 'const' so we need to copy
        // szFileName into a buffer.  If it really should be const get rid of
        // this copy and use a cast.
        //
        StrCpyN(wszFileName, szFileName, ARRAYSIZE(wszFileName));
        stg.tymed = TYMED_FILE;
        stg.lpszFileName = wszFileName;
        stg.pUnkForRelease = NULL;

        hr = pvs->ScanForVirus(_hDlg, &stg, _pwszDisplayName, SFV_DELETE, &vi);

        switch (hr) {

        case S_OK:
            break;

        case VSCAN_E_NOPROVIDERS:   //No virus scanning providers
        case VSCAN_E_CHECKPARTIAL:  //Atleast one of providers didn't work.
        case VSCAN_E_CHECKFAIL:     //No providers worked.
            hr = S_OK;
            break;

        case VSCAN_E_DELETEFAIL:    //Tried to delete virus file but failed.
        case S_FALSE:               // Virus found.
            hr = E_FAIL;
            break;

        // If some bizarre result, continue on.
        default:
            hr = S_OK;
            break;
        }

        pvs->Release();
    }

    return hr;
}

// Starts a download of a file in its own window.

// This function is exported and called by HTML doc object.
// Someday we probably want to put this in a COM interface.
// Currently it just calls the internal function CDownLoad_OpenUIURL.

STDAPI DoFileDownload(LPCWSTR pwszURL)
{
    return CDownLoad_OpenUIURL(pwszURL, NULL, NULL, FALSE,TRUE);
}

STDAPI DoFileDownloadEx(LPCWSTR pwszURL, BOOL fSaveAs)
{
    return CDownLoad_OpenUIURL(pwszURL, NULL, NULL, FALSE, fSaveAs);
}

#ifdef DEBUG
const DWORD CDownloadThreadParam::s_dummy = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dochost.cpp ===
//
// NOTES:
//
//  This is the code which enables the explorer hosting (being a container)
// a DocObject (a super set of OLE in-place object). In a nut shell, this
// code creates an object (class CDocObjectHost) which can be plugged into
// the explorer's right pane (by supporting IShellView) is also a DocObject
// container (by supporting IOleClientSite, IOleInPlaceSite, ...).
//
//  This CDocObjectHost directly supports following interfaces:
//
// Group 1 (to be plugged in):
//   IShellView, IDropTarget
// Group 2 (to be a Doc site):
//   IOleClientSite, IOleDocumentSite
// Group 3 (to be a View Site)
//   IOleInPlaceSite

//  It also supports following interfaces indirectly via contained object,
// CDocObjectFrame.
//
//  IOleInPlaceFrame, IOleCommandTarget
//
//  The reason we export them separately is because we may need to return
// a different hwnd for GetWindow method. The CDocObjectHost object always
// returns hwnd of the view window, but the CDocObjectFrame returns hwnd
// of the explorer in case the explorer support IOleInPlaceUIWindow.
//
//  It also supports following interface indirectly via contained object,
// CProxyActiveObject.
//
//  IOleInPlaceActiveObject
//
//
//  --------------------------------------------------------
//      Explorer (browser)
//  --------------------------------------------------------
//        ^          |          |
//        |          |          |
//   ISB (+IOIUI)   ISV       IOIAO
//        |          |          |
//        |          V          |
//  ----------------------------V---------------------------
//       CDocObjectHost  CProxyActiveObject CDocObjectFrame
//  ----------------------------------------------^---------
//        ^                |                      |
//        |                |                      |
//  IOCS/IOIPS/IMDS   IO/IOIPO/IMV/IMCT    IOIUI/IOIF/IMCT
//        |                |                      |
//        |                V                      |
//  ---------------------------------------------------------
//       DocObject (Doc + View)
//  ---------------------------------------------------------
//

#include "priv.h"
#include "iehelpid.h"
#include "bindcb.h"
#include "winlist.h"
#include "droptgt.h"
#include <mshtml.h>     // CLSID_HTMLDocument
#include <mshtmcid.h>
#include "resource.h"
#include <htmlhelp.h>
#include <prsht.h>
#include <inetcpl.h>
#include <optary.h>
#include "impexp.h"
#include "impexpwz.h"
#include "thicket.h"
#include "uemapp.h"
#include "iextag.h"   // web folders
#include "browsext.h"
#include "interned.h" // IHTMLPrivateWindow
#include "dochost.h"
#include <mluisupp.h>
#include <varutil.h>
#include "msiehost.h"
#include "shdocfl.h"
#include "mediautil.h"
#include "mediahlpr.h"
#include "privacyui.hpp"
#include "brdispp.h"

#include <strsafe.h>

// temp, going away once itbar edit stuff moves here
#define  CITIDM_EDITPAGE  10
// Command group for private communication with CITBar
// 67077B95-4F9D-11D0-B884-00AA00B60104
const GUID CGID_PrivCITCommands = { 0x67077B95L, 0x4F9D, 0x11D0, 0xB8, 0x84,
0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };
// end temp itbar stuff

// Command group for accessing Bind Context Param set by Trident (Media Bar hook) 
// (copied from mshtml\src\other\include\othrguid.h)
static const GUID CGID_DownloadObjectBindContext = { 0x3050f3df, 0x98b5, 0x11cf, 0xbb, 0x82, 
0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b };

static const GUID CLSID_JITWMP8 = { 0x6BF52A52, 0x394A, 0x11d3, 0xb1, 0x53, 0x00, 0xc0, 0x4f, 0x79, 0xfa, 0xa6 };


#define  DBG_ACCELENTRIES 2
#define  OPT_ACCELENTRIES 1

#ifdef UNIX

#include <unixstuff.h>
#define  EXPLORER_EXE "explorer"
#define  IEXPLORE_EXE "iexplorer"
#define  DBG_ACCELENTRIES_WITH_FILEMENU 8
#define  OPT_ACCELENTRIES_WITH_FILEMENU 7

#else

#define  EXPLORER_EXE TEXT("explorer.exe")
#define  IEXPLORE_EXE TEXT("iexplore.exe")
#define  DBG_ACCELENTRIES_WITH_FILEMENU 6
#define  OPT_ACCELENTRIES_WITH_FILEMENU 5

#endif /* UNIX */

EXTERN_C const GUID IID_IDocHostObject  = {0x67431840L, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29};
EXTERN_C const GUID IID_IMimeInfo       = {0xF77459A0L, 0xBF9A, 0x11cf, 0xBA, 0x4E, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x16};
EXTERN_C const GUID IID_IsPicsBrowser   = {0xF114C2C0L, 0x90BE, 0x11D0, 0x83, 0xB1, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xB2};

#include <shlwapi.h>
#include <ratingsp.h>
#include <ratings.h>

#define DM_ZONECROSSING 0
#define DM_SAVEASHACK   0
#define DM_MIMEMAPPING  0
#define DM_SELFASC      TF_SHDBINDING
#define DM_ACCEPTHEADER 0
#define DM_DEBUGTFRAME  0
#define DM_DOCHOSTUIHANDLER 0
#define DM_PREMERGEDMENU    0
#define DM_FOCUS        0
#define DM_DOCCP        0
#define DM_PICS         0
#define DM_SSL              0

#define KEY_BINDCONTEXTPARAM  _T("BIND_CONTEXT_PARAM")

// media bar entries
#define WZ_RADIO_PROTOCOL   L"vnd.ms.radio:"

enum PlayMimeOptions {PLAYMIME_YES, PLAYMIME_NO, PLAYMIME_YESSAVE, PLAYMIME_NOSAVE};

// WARNING: Never define it in shipping product.
#ifdef DEBUG
// #define TEST_DELAYED_SHOWMSOVIEW
#endif

void CShdAdviseSink_Advise(IBrowserService * pwb, IOleObject* pole);

UINT MayOpenSafeOpenDialog(HWND                hwndOwner,
                           LPCTSTR             pszFileClass,
                           LPCTSTR             pszURL,
                           LPCTSTR             pszCacheName,
                           LPCTSTR             pszDisplay,
                           UINT                uiCP,
                           IUnknown          * punk,
                           IOleCommandTarget * pCmdTarget = NULL,
                           BOOL                fDisableOK = FALSE);

LONG _GetSearchFormatString(DWORD dwIndex, LPTSTR psz, DWORD cbpsz);
DWORD _GetErrorThreshold(DWORD dwError);
BOOL IsRegisteredClient(LPCTSTR pszClient);

HRESULT _GetSearchString(IServiceProvider * psp, VARIANT * pvarSearch);
int     EUIndexFromError(DWORD dwError);
BOOL    IsErrorHandled(DWORD dwError);
HRESULT _GetSearchInfo(IServiceProvider * psp,
                       LPDWORD   pdwIndex,
                       LPBOOL    pfAllowSearch,
                       LPBOOL    pfContinueSearch,
                       LPBOOL    pfSentToEngine,
                       VARIANT * pvarUrl);

STDAPI _URLMONMonikerFromPidl(LPCITEMIDLIST pidl, IMoniker ** ppmk, BOOL * pfFileProtocol);
LRESULT CALLBACK PolicyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

// macros
#define DO_SEARCH_ON_STATUSCODE(x) ((x == 0) || (x == HTTP_STATUS_BAD_GATEWAY) || (x == HTTP_STATUS_GATEWAY_TIMEOUT))

// Suite Apps Registry keys
#define NEW_MAIL_DEF_KEY            TEXT("Mail")
#define NEW_NEWS_DEF_KEY            TEXT("News")
#define NEW_CONTACTS_DEF_KEY        TEXT("Contacts")
#define NEW_CALL_DEF_KEY            TEXT("Internet Call")
#define NEW_APPOINTMENT_DEF_KEY     TEXT("Appointment")
#define NEW_MEETING_DEF_KEY         TEXT("Meeting")
#define NEW_TASK_DEF_KEY            TEXT("Task")
#define NEW_TASKREQUEST_DEF_KEY     TEXT("Task Request")
#define NEW_JOURNAL_DEF_KEY         TEXT("Journal")
#define NEW_NOTE_DEF_KEY            TEXT("Note")

#ifdef DEBUG
DWORD g_dwPerf = 0;
#endif

// #include "..\shell32\fstreex.h"              // for IDFOLDER
// HACK:
struct IDFOLDERA
{
    WORD    cb;
    BYTE    bFlags;
};
typedef IDFOLDERA* LPIDFOLDERA;

const ITEMIDLIST s_idNull = { {0} };


//
// Icons are globally shared among multiple threads.
//
HICON g_hiconSSL = NULL;
HICON g_hiconFortezza = NULL;
HICON g_hiconOffline = NULL;
HICON g_hiconPrinter = NULL;
HICON g_hiconScriptErr = NULL;
HICON g_hiconPrivacyImpact = NULL;

HICON g_ahiconState[IDI_STATE_LAST-IDI_STATE_FIRST+1] = { NULL };
#define MAX_MIXED_STR_LEN   32

// OpenUIURL is just a wrapper for OpenUI, calling CreateURLMoniker() if the
// caller only has an URL.

extern BOOL __cdecl _FormatMessage(LPCSTR szTemplate, LPSTR szBuf, UINT cchBuf, ...);

#include "asyncrat.h"



#define MAX_STATUS_SIZE 128

//
// Set this flag if we are going to use IHlinkBrowseContext in HLINK.DLL
// #define HLINK_EXTRA
//

// Array of http error codes and file names.
//
extern ErrorUrls c_aErrorUrls[];

#define DM_RECYCLE      DM_TRACE
#define DM_BINDAPPHACK  TF_SHDAPPHACK
#define DM_ADVISE       TF_SHDLIFE
#define DM_APPHACK      DM_WARNING

#define NAVMSG3(psz, x, y)      TraceMsg(0, "shdv NAV::%s %x %x", psz, x, y)
#define PAINTMSG(psz,x)         TraceMsg(0, "shd TR-PAINT::%s %x", psz, x)
#define JMPMSG(psz, psz2)       TraceMsg(0, "shd TR-CDOV::%s %s", psz, psz2)
#define JMPMSG2(psz, x)         TraceMsg(0, "shd TR-CDOV::%s %x", psz, x)
#define DOFMSG(psz)             TraceMsg(0, "shd TR-DOF::%s", psz)
#define DOFMSG2(psz, x)         TraceMsg(0, "shd TR-DOF::%s %x", psz, x)
#define URLMSG(psz)             TraceMsg(TF_SHDBINDING, "shd TR-DOF::%s", psz)
#define URLMSG2(psz, x)         TraceMsg(TF_SHDBINDING, "shd TR-DOF::%s %x", psz, x)
#define URLMSG3(psz, x, y)      TraceMsg(TF_SHDBINDING, "shd TR-DOF::%s %x %x", psz, x, y)
#define OIPSMSG(psz)            TraceMsg(0, "shd TR-OIPS::%s", psz)
#define OIPSMSG3(psz, sz, p)    TraceMsg(0, "shd TR-OIPS::%s %s,%x", psz, sz,p)
#define VIEWMSG(psz)            TraceMsg(0, "sdv TR CDOV::%s", psz)
#define VIEWMSG2(psz,xx)        TraceMsg(0, "sdv TR CDOV::%s %x", psz,xx)
#define OPENMSG(psz)            TraceMsg(TF_SHDBINDING, "shd OPENING %s", psz)
#define OPENMSG2(psz, x)        TraceMsg(TF_SHDBINDING, "shd OPENING %s %x", psz, x)
#define HFRMMSG(psz)            TraceMsg(0, "shd HFRM::%s", psz)
#define HFRMMSG2(psz, x, y)     TraceMsg(0, "shd HFRM::%s %x %x", psz, x, y)
#define MNKMSG(psz, psz2)       TraceMsg(0, "shd MNK::%s (%s)", psz, psz2)
#define CHAINMSG(psz, x)        TraceMsg(0, "shd CHAIN::%s %x", psz, x)
#define SHVMSG(psz, x, y)       TraceMsg(0, "shd SHV::%s %x %x", psz, x, y)
#define HOMEMSG(psz, psz2, x)   TraceMsg(TF_SHDNAVIGATE, "shd HOME::%s %s %x", psz, psz2, x)
#define SAVEMSG(psz, x)         TraceMsg(0, "shd SAVE::%s %x", psz, x)
#define PERFMSG(psz, x)         TraceMsg(TF_SHDPERF, "PERF::%s %d msec", psz, x)

static const TCHAR  szRegKey_SMIEM[] =              TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR  szRegVal_ErrDlgPerErr[] =       TEXT("Error Dlg Displayed On Every Error");
static const TCHAR  szRegVal_ErrDlgDetailsOpen[] =  TEXT("Error Dlg Details Pane Open");

////////////////////////////////////////////////////////////
// ShabbirS (980917) - BugFix# 34259
// Repair menuitem in the Help Menu.

typedef HRESULT (* FIXIEPROC) (BOOL, DWORD);

void RepairIE()
{
    HINSTANCE   hIESetup;
    FIXIEPROC   fpFixIE;

    hIESetup = LoadLibrary(L"IESetup.dll");
    if (hIESetup)
    {
        fpFixIE = (FIXIEPROC) GetProcAddress(hIESetup,"FixIE");
        if (fpFixIE)
        {
            fpFixIE(TRUE,0);
        }
        FreeLibrary(hIESetup);
    }
}


BOOL _IsDesktopItem(CDocObjectHost * pdoh)
{
    BOOL fIsDesktopItem = FALSE;
    IServiceProvider  * psb;

    ASSERT(pdoh);
    //Check if we are a desktop component.
    if (SUCCEEDED(pdoh->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&psb)))
    {
        LPTARGETFRAME2  ptgf;
        if (SUCCEEDED(psb->QueryService(IID_ITargetFrame2, IID_ITargetFrame2, (void **)&ptgf)))
        {
            DWORD dwOptions;

            if (SUCCEEDED(ptgf->GetFrameOptions(&dwOptions)))
            {
                //Is this a desktop component?
                if (IsFlagSet(dwOptions, FRAMEOPTIONS_DESKTOP))
                    fIsDesktopItem = TRUE;
            }
            ptgf->Release();
        }
        psb->Release();
    }

    return fIsDesktopItem;
}

BOOL _IsImmediateParentDesktop(CDocObjectHost *pdoh, IServiceProvider *psp)
{
    BOOL    fImmediateParentIsDesktop = FALSE;
    LPTARGETFRAME2  ptgf;

    //First check if this is hosted on desktop.
    if (!_IsDesktopItem(pdoh))
        return FALSE;     //This is not a desktop item. So, the immediate parent can't be desktop!

    //We know that this is a desktop item. Check if the immediate parent is desktop
    // or it is hosted too deep on desktop!
    if (psp && SUCCEEDED(psp->QueryService(IID_ITargetFrame2, IID_ITargetFrame2, (void **)&ptgf)))
    {
        IUnknown *pUnkParent;

        //Get it's immediate parent.
        if(SUCCEEDED(ptgf->GetParentFrame(&pUnkParent)))
        {
            if(pUnkParent)
            {
                //Has a parent. So, the immediate parent can't be desktop!
                pUnkParent->Release();

                fImmediateParentIsDesktop = FALSE;
            }
            else
                fImmediateParentIsDesktop = TRUE; //No parent. Must be a desktop comp.
        }
        ptgf->Release();
    }
    return(fImmediateParentIsDesktop);
}

// Gets the current display name in wide char
//
// If fURL is TRUE, it returns file-URL with file: prefix.
//
HRESULT CDocObjectHost::_GetCurrentPageW(LPOLESTR * ppszDisplayName, BOOL fURL)
{
    HRESULT hres = E_FAIL;
    ASSERT(_pmkCur);

    *ppszDisplayName = NULL;

    if (_pmkCur) {
        IBindCtx* pbc;
        hres = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hres))
        {
            hres = _pmkCur->GetDisplayName(pbc, NULL, ppszDisplayName);

            //
            //  special handling just for file: urls.
            //
            if (SUCCEEDED(hres) && _fFileProtocol)
            {
                ASSERT(*ppszDisplayName);

                WCHAR szText[MAX_URL_STRING];
                DWORD cchText = SIZECHARS(szText);
                if (!fURL)
                {
                     hres = PathCreateFromUrlW(*ppszDisplayName, szText, &cchText, 0);
                }
                else
                {
                    //  we need this to be in the normalized form of the URL
                    //  for internal usage.  urlmon keeps them in the funny PATHURL style
                    hres = UrlCanonicalizeW(*ppszDisplayName, szText, &cchText, 0);
                }

                if (SUCCEEDED(hres))
                {
                    UINT cchDisplayName = lstrlenW(*ppszDisplayName);

                    if (cchText > cchDisplayName)
                    {
                        //  need to resize
                        CoTaskMemFree(*ppszDisplayName);
                        *ppszDisplayName = (WCHAR *)CoTaskMemAlloc((cchText + 1) * SIZEOF(WCHAR));

                        if (*ppszDisplayName)
                        {
                            //  go ahead and copy it in
                            StrCpyNW(*ppszDisplayName, szText, cchText + 1);
                        }
                        else
                            hres = E_OUTOFMEMORY;
                    }
                    else
                    {
                        StrCpyNW(*ppszDisplayName, szText, cchDisplayName + 1);
                    }
                }
                else
                    OleFree(*ppszDisplayName);
            }
            pbc->Release();
        }
    }

    return hres;
}

//
//  We fire NavigateError in one location in DocObjectHost
//  However it is fired from (n) locations in DocHostBsc 
//  so I have extracted the common code
//
void
CDocObjectHost::_FireNavigateErrorHelper(IHTMLWindow2 * pHTMLWindow2,
                                         DWORD          dwStatusCode,
                                         BOOL         * pfCancelAutoSearch,
                                         BSTR           bstrURL /* = NULL */)
{
    ASSERT(!pHTMLWindow2 || !IsBadReadPtr(pHTMLWindow2, sizeof(IHTMLWindow2*)));
    ASSERT(dwStatusCode != 0);
    ASSERT(!IsBadWritePtr(pfCancelAutoSearch, sizeof(BOOL)));
    ASSERT(!bstrURL || !IsBadReadPtr(bstrURL, sizeof(BSTR)));

    if ( ! _pwb )
    {
        TraceMsg( TF_ERROR, "CDocObjectHost::_FireNavigateErrorHelper() - _pwb is NULL!" );
        return;
    }

    ITridentService2 * pTridentSvc2;

    HRESULT hres = _pwb->QueryInterface(IID_ITridentService2, (void**)&pTridentSvc2);

    if (SUCCEEDED(hres))
    {
        LPOLESTR pwzURL        = NULL;
        BSTR     bstrMkURL     = NULL;
        BSTR     bstrPidlURL   = NULL;
        BSTR     bstrFrameName = NULL;

        if (!bstrURL)
        {
            ASSERT(!_pmkCur || !IsBadReadPtr(_pmkCur, sizeof(_pmkCur)));
            ASSERT(!_pbcCur || !IsBadReadPtr(_pbcCur, sizeof(_pbcCur)));

            if (_pmkCur && _pbcCur)
            {
                EVAL(S_OK == _pmkCur->GetDisplayName(_pbcCur, NULL, &pwzURL));
                bstrMkURL = SysAllocString(pwzURL);
            }
            else if (_pidl)
            {
                TCHAR szUrl[MAX_URL_STRING];
                HRESULT hresGDN = IEGetDisplayName(_pidl, szUrl, SHGDN_FORPARSING);
                
                if (SUCCEEDED(hresGDN))
                {
                   bstrPidlURL = SysAllocString(szUrl);
                }
                else
                {
                   bstrPidlURL = SysAllocString(_T(""));
                }
            }
        }

        if (pHTMLWindow2)
            pHTMLWindow2->get_name(&bstrFrameName);

        pTridentSvc2->FireNavigateError(pHTMLWindow2,
                                        bstrURL ? bstrURL : bstrMkURL ? bstrMkURL : bstrPidlURL,
                                        bstrFrameName,
                                        dwStatusCode,
                                        pfCancelAutoSearch);
        pTridentSvc2->Release();

        OleFree(pwzURL);
        SysFreeString(bstrPidlURL);
        SysFreeString(bstrMkURL);
        SysFreeString(bstrFrameName);
    }
}

HRESULT CDocObjectHost::_GetCurrentPage(LPTSTR szBuf, UINT cchMax, BOOL fURL)
{
    szBuf[0] = 0;   // zero out buffer

    WCHAR * pszDisplayName;
    HRESULT hres = _GetCurrentPageW(&pszDisplayName, fURL);

    if (SUCCEEDED(hres))
    {
        StrCpyN(szBuf, pszDisplayName, cchMax);
        OleFree(pszDisplayName);
    }

    return hres;
}

void CDocObjectHost_GetCurrentPage(LPARAM that, LPTSTR szBuf, UINT cchMax)
{
    CDocObjectHost* pdoh = (CDocObjectHost*)that;
    pdoh->_GetCurrentPage(szBuf, cchMax);
}

//========================================================================
// CDocObjectHost members
//========================================================================

CDocObjectHost::CDocObjectHost(BOOL fWindowOpen /* = FALSE */) : _cRef(1), _uState(SVUIA_DEACTIVATE)
{
    DllAddRef();
    TraceMsg(TF_SHDLIFE, "ctor CDocObjectHost %x", this);
    TraceMsg(DM_DEBUGTFRAME, "ctor CDocObjectHost %x, %x", this, &_bsc);

    // Initialize proxy objects (which are contained)
    _dof.Initialize(this);
    _xao.Initialize(this);

#ifdef HLINK_EXTRA
    HRESULT hres = HlinkCreateBrowseContext(NULL, IID_IHlinkBrowseContext, (void **)&_pihlbc);
    TraceMsg(0, "sdv TR CDOV::constructor HlinkCreateBrowseContext returned %x", hres);
#endif // HLINK_EXTRA

    ::_RefPicsQueries();    /* we'll free PICS async query list when last dochost is destroyed */

    _dwPicsKeyBase = 1;

    _pScriptErrList = NULL;
    _fScriptErrDlgOpen = FALSE;

    _strPriorityStatusText = NULL;

    _iString = -1;
    _uiCP = CP_ACP;

    _PicsProcBase._pdoh = this;

    VariantInit(&_varUserEnteredUrl);

    _fWindowOpen = fWindowOpen;

    ASSERT(!_fDocCanNavigate);
    ASSERT(!_fPrevDocHost);
}

CDocObjectHost::~CDocObjectHost()
{
    ASSERT(_pole==NULL);    // to catch extra release.
    ASSERT(_psp==NULL);     // to cache extra release.
    ASSERT(_hwnd==NULL);
    ASSERT(_pmsoc==NULL);
    ASSERT(_pmsot==NULL);
    ASSERT(_pmsov==NULL);
    ASSERT(_pcmdMergedMenu==NULL);
    ASSERT(NULL == _pHTMLWindow);
    ASSERT(VT_EMPTY == V_VT(&_varUserEnteredUrl));

    if (_pScriptErrList != NULL)
    {
        _pScriptErrList->Release();
    }

    if (_strPriorityStatusText != NULL)
    {
        SysFreeString(_strPriorityStatusText);
    }

#ifdef HLINK_EXTRA
    ASSERT(_phls == NULL);
    ATOMICRELEASE(_pihlbc);
#endif // HLINK_EXTRA

    ::_ReleasePicsQueries();

    if (    _PicsProcBase._pRootDownload 
        ||  _PicsProcBase._pPicsProcNext) {
        ASSERT(0);  /* need to destroy this earlier to prevent Trident problems */
        _RemoveAllPicsProcessors();
    }

    if (_padvise) {
        _padvise->OnClose();
        ATOMICRELEASE(_padvise);
    }

    if (_pwszRefreshUrl)
        OleFree(_pwszRefreshUrl);

    if (_hmenuBrowser) {
        AssertMsg(0, TEXT("_hmenuBrowser should be NULL!"));
        DestroyMenu(_hmenuBrowser);
    }

    if (_hmenuFrame) {
        DestroyMenu(_hmenuFrame);
    }

    if (_hacc)
    {
        DestroyAcceleratorTable(_hacc);
        _hacc = NULL;
    }

    if (_hinstInetCpl)
        FreeLibrary(_hinstInetCpl);

    if (_ptbStd)
        delete [] _ptbStd;

    if (_pBrowsExt)
    {
        _pBrowsExt->Release();
    }

    ILFree(_pidl);
    _pidl = NULL;

    // Make it sure that View Window is released (and _psb)
    DestroyHostWindow();        // which will call _CloseMsoView and _UnBind

    _ResetOwners();

    TraceMsg(TF_SHDLIFE, "dtor CDocObjectHost %x", this);
    DllRelease();
}


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump the menu handles for this docobj.  Optionally
         breaks after dumping handles.

Returns:
Cond:    --
*/
void
CDocObjectHost::_DumpMenus(
    IN LPCTSTR pszMsg,
    IN BOOL    bBreak)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        ASSERT(pszMsg);

        TraceMsg(TF_ALWAYS, "DocHost: Dumping menus for %#08x %s", (LPVOID)this, pszMsg);
        TraceMsg(TF_ALWAYS, "   _hmenuBrowser = %x, _hmenuSet = %x, _hmenuFrame = %x",
                 _hmenuBrowser, _hmenuSet, _hmenuFrame);
        TraceMsg(TF_ALWAYS, "   _hmenuCur = %x, _hmenuMergedHelp = %x, _hmenuObjHelp = %x",
                 _hmenuCur, _hmenuMergedHelp, _hmenuObjHelp);

        _menulist.Dump(pszMsg);

        if (bBreak && IsFlagSet(g_dwBreakFlags, BF_ONDUMPMENU))
            DebugBreak();
    }
}
#endif

HRESULT CDocObjectHost::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CDocObjectHost, IOleInPlaceSite, IOleInPlaceSiteEx),
        QITABENTMULTI(CDocObjectHost, IOleWindow, IOleInPlaceSiteEx),
        QITABENT(CDocObjectHost, IOleClientSite),
        QITABENT(CDocObjectHost, IOleDocumentSite),
        QITABENT(CDocObjectHost, IOleCommandTarget),
        QITABENT(CDocObjectHost, IServiceProvider),
        QITABENT(CDocObjectHost, IViewObject),
        QITABENT(CDocObjectHost, IAdviseSink),
        QITABENT(CDocObjectHost, IDocHostObject),
        QITABENT(CDocObjectHost, IDocHostUIHandler),
        QITABENT(CDocObjectHost, IDocHostUIHandler2),
        QITABENT(CDocObjectHost, IDocHostShowUI),
        QITABENT(CDocObjectHost, IDispatch),
        QITABENT(CDocObjectHost, IPropertyNotifySink),
        QITABENT(CDocObjectHost, IOleControlSite),
        { 0 },
    };

    static const QITAB qit1[] = {
        QITABENT(CDocObjectHost, IOleInPlaceSiteEx),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (hr == S_OK)
        return S_OK;

    if (_pWebOCInPlaceSiteEx)
        return QISearch(this, qit1, riid, ppvObj);

    return hr;
}

void CDocObjectHost::_ResetOwners()
{
    _pszLocation = NULL;
    _uiCP = CP_ACP;

    _ReleasePendingObject();

    ATOMICRELEASE(_psv);
    ATOMICRELEASE(_pmsoctView);
    ATOMICRELEASE(_pdvs);
    ATOMICRELEASE(_psb);
    ATOMICRELEASE(_pwb);
    ATOMICRELEASE(_phf);
    ATOMICRELEASE(_pocthf);
    ATOMICRELEASE(_punkSFHistory);
    ATOMICRELEASE(_pmsoctBrowser);
    ATOMICRELEASE(_psp);
    ATOMICRELEASE(_peds);
    ATOMICRELEASE(_pedsHelper);
    ATOMICRELEASE(_pWebOCUIHandler);
    ATOMICRELEASE(_pWebOCUIHandler2);
    ATOMICRELEASE(_pWebOCShowUI);
    ATOMICRELEASE(_pWebOCInPlaceSiteEx);

    // Release cached OleInPlaceUIWindow of the browser
    ATOMICRELEASE(_pipu);

    // Tell embedded CDocHostUIHandler object to release its references on us.
    _dhUIHandler.SetSite(NULL);
}



ULONG CDocObjectHost::AddRef()
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CDocObjectHost(%x)::AddRef called, new _cRef=%d", this, _cRef);
    return _cRef;
}

ULONG CDocObjectHost::Release()
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CDocObjectHost(%x)::Release called, new _cRef=%d", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// cut & paste from browseui\itbar.cpp
int RemoveHiddenButtons(TBBUTTON* ptbn, int iCount)
{
    int i;
    int iTotal = 0;
    TBBUTTON* ptbn1 = ptbn;
    for (i = 0; i < iCount; i++, ptbn1++) {
        if (!(ptbn1->fsState & TBSTATE_HIDDEN)) {
            if (ptbn1 != ptbn) {
                *ptbn = *ptbn1;
            }
            ptbn++;
            iTotal++;
        }
    }
    return iTotal;
}

// We use two different image lists in the TBBUTTON array.  The bitmaps for browser-specific buttons
// cut/copy/paste have been moved to shdocvw, and are therefore obtained from a second image list.
// MAKELONG(0,1) accesses the first image from this second list.  Without a call to MAKELONG there is
// a 0 in the upper integer, thereby referencing the first list by default.
static const TBBUTTON c_tbStd[] = {
    {10, DVIDM_SHOWTOOLS,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 10},
    {13, DVIDM_MAILNEWS,        TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN, {0,0}, 0, 13 },
    { 8, DVIDM_FONTS,           TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN, {0,0}, 0, 8 },
    { 7, DVIDM_PRINT,           TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 7 },
    { 9, DVIDM_EDITPAGE,        TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 9 },
    {15, DVIDM_DISCUSSIONS,     TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 15 },
    {MAKELONG(0,1), DVIDM_CUT,             TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
    {MAKELONG(1,1), DVIDM_COPY,            TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
    {MAKELONG(2,1), DVIDM_PASTE,           TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
    {MAKELONG(3,1), DVIDM_ENCODING,        TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN, {0,0}, 0, 0 },
    {MAKELONG(5,1), DVIDM_PRINTPREVIEW,    TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
};

// c_tbStd and c_rest need to match exactly
static const BROWSER_RESTRICTIONS c_rest[] = {
    REST_BTN_TOOLS,
    REST_BTN_MAIL,
    REST_BTN_FONTS,
    REST_BTN_PRINT,
    REST_BTN_EDIT,
    REST_BTN_DISCUSSIONS,
    REST_BTN_CUT,
    REST_BTN_COPY,
    REST_BTN_PASTE,
    REST_BTN_ENCODING,
    REST_BTN_PRINTPREVIEW,
};

#ifdef DEBUG
void _AssertRestrictionOrderIsCorrect()
{
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbStd) == ARRAYSIZE(c_rest));

    for (UINT i = 0; i < ARRAYSIZE(c_tbStd); i++)
    {
        // If any of these rip, it means that c_rest and c_tbStd have
        // gotten out of sync.  Need to fix up c_rest to match c_tbStd.
        switch (c_tbStd[i].idCommand)
        {
            case DVIDM_SHOWTOOLS:       ASSERT(c_rest[i] == REST_BTN_TOOLS);        break;
            case DVIDM_MAILNEWS:        ASSERT(c_rest[i] == REST_BTN_MAIL);         break;
            case DVIDM_FONTS:           ASSERT(c_rest[i] == REST_BTN_FONTS);        break;
            case DVIDM_PRINT:           ASSERT(c_rest[i] == REST_BTN_PRINT);        break;
            case DVIDM_EDITPAGE:        ASSERT(c_rest[i] == REST_BTN_EDIT);         break;
            case DVIDM_DISCUSSIONS:     ASSERT(c_rest[i] == REST_BTN_DISCUSSIONS);  break;
            case DVIDM_CUT:             ASSERT(c_rest[i] == REST_BTN_CUT);          break;
            case DVIDM_COPY:            ASSERT(c_rest[i] == REST_BTN_COPY);         break;
            case DVIDM_PASTE:           ASSERT(c_rest[i] == REST_BTN_PASTE);        break;
            case DVIDM_ENCODING:        ASSERT(c_rest[i] == REST_BTN_ENCODING);     break;
            case DVIDM_PRINTPREVIEW:    ASSERT(c_rest[i] == REST_BTN_PRINTPREVIEW); break;
            default:                    ASSERT(0);                                  break;
        }
    }
}
#endif

BYTE _BtnStateFromRestIfAvailable(BOOL fAvailable, DWORD dwRest)
{
    if (fAvailable)
        return SHBtnStateFromRestriction(dwRest, TBSTATE_ENABLED);

    return TBSTATE_HIDDEN;
}

BOOL CDocObjectHost::_ToolsButtonAvailable()
{
    OLECMD rgcmd = { OLECMDID_HIDETOOLBARS, 0 };

    if (_pmsoctBrowser)
        _pmsoctBrowser->QueryStatus(NULL, 1, &rgcmd, NULL);

    return (rgcmd.cmdf & OLECMDF_SUPPORTED);
}

__inline BYTE CDocObjectHost::_DefToolsButtonState(DWORD dwRest)
{
    BOOL fAvailable = _ToolsButtonAvailable();
    return _BtnStateFromRestIfAvailable(fAvailable, dwRest);
}

static const TCHAR c_szRegKeyCoolbar[] = TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar");

BYTE CDocObjectHost::_DefFontsButtonState(DWORD dwRest)
{
    BYTE fsState = TBSTATE_ENABLED;

    // default to whatever the IE4 reg key specifies,
    // or FALSE if reg key not present (clean install)
    if (!SHRegGetBoolUSValue(c_szRegKeyCoolbar, TEXT("ShowFonts"), FALSE, FALSE))
        fsState |= TBSTATE_HIDDEN;

    return SHBtnStateFromRestriction(dwRest, fsState);
}

DWORD CDocObjectHost::_DiscussionsButtonCmdf()
{
    if (SHRegGetBoolUSValue(c_szRegKeyCoolbar,
                                TEXT("ShowDiscussionButton"), FALSE, TRUE) &&
       _pmsoctBrowser) {

        OLECMD rgcmds[] = {
            { SBCMDID_DISCUSSIONBAND, 0 },
        };
        static const int buttonsInternal[] = {
            DVIDM_DISCUSSIONS,
        };
        _pmsoctBrowser->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmds), rgcmds, NULL);
        return rgcmds[0].cmdf;
    }

    return 0;
}

__inline BOOL CDocObjectHost::_DiscussionsButtonAvailable()
{
    return (_DiscussionsButtonCmdf() & OLECMDF_SUPPORTED);
}

__inline BYTE CDocObjectHost::_DefDiscussionsButtonState(DWORD dwRest)
{
    BOOL fAvailable = _DiscussionsButtonAvailable();
    return _BtnStateFromRestIfAvailable(fAvailable, dwRest);
}

BOOL CDocObjectHost::_MailButtonAvailable()
{
    OLECMD rgcmdMailFavs[] = { { SBCMDID_DOMAILMENU, 0} };

    if (_pmsoctBrowser)
        _pmsoctBrowser->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmdMailFavs), rgcmdMailFavs, NULL);

    if (rgcmdMailFavs[0].cmdf & OLECMDF_ENABLED)
        return TRUE;

    return FALSE;
}

__inline BYTE CDocObjectHost::_DefMailButtonState(DWORD dwRest)
{
    BOOL fAvailable = _MailButtonAvailable();
    return _BtnStateFromRestIfAvailable(fAvailable, dwRest);
}


// We default the edit button to visible if there is an html editer registered
BOOL CDocObjectHost::_EditButtonAvailable()
{
    DWORD cchVerb;
    return (SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, TEXT(".htm"), TEXT("edit"), NULL, &cchVerb)) ||
        SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, TEXT("htmlfile"), TEXT("edit"), NULL, &cchVerb)));
}

__inline BYTE CDocObjectHost::_DefEditButtonState(DWORD dwRest)
{
    BYTE fsState;

    if (_EditButtonAvailable())
        fsState = TBSTATE_ENABLED;
    else
        fsState = TBSTATE_HIDDEN;

    return SHBtnStateFromRestriction(dwRest, fsState);
}


void CDocObjectHost::_MarkDefaultButtons(PTBBUTTON tbStd)
{
    // We're assuming tbStd is the same size as c_tbStd

#ifdef DEBUG
    _AssertRestrictionOrderIsCorrect();
#endif

    DWORD dwRest[ARRAYSIZE(c_tbStd)];

    BOOL fCheckRestriction = SHRestricted2(REST_SPECIFYDEFAULTBUTTONS, NULL, 0);
    for (UINT i = 0; i < ARRAYSIZE(c_rest); i++) {
        if (fCheckRestriction)
            dwRest[i] = SHRestricted2(c_rest[i], NULL, 0);
        else
            dwRest[i] = RESTOPT_BTN_STATE_DEFAULT;
    }

    // We want the Cut, Copy, Paste buttons to default off of the toolbar
    // (but available in the view-toolbars-customize dialog)
    // We set the state of the buttons to TBSTATE_HIDDEN here, but leave them alone
    // in ETCMDID_GETBUTTONS so that they appear in the customize dialog.

    ASSERT(tbStd[6].idCommand == DVIDM_CUT);
    ASSERT(tbStd[7].idCommand == DVIDM_COPY);
    ASSERT(tbStd[8].idCommand == DVIDM_PASTE);
    ASSERT(tbStd[9].idCommand == DVIDM_ENCODING);
    ASSERT(tbStd[10].idCommand == DVIDM_PRINTPREVIEW);

    for (i = 6; i <= 10; i++)
        tbStd[i].fsState = SHBtnStateFromRestriction(dwRest[i], tbStd[i].fsState | TBSTATE_HIDDEN);

    ASSERT(tbStd[0].idCommand == DVIDM_SHOWTOOLS);
    tbStd[0].fsState = _DefToolsButtonState(dwRest[0]);

    ASSERT(tbStd[1].idCommand == DVIDM_MAILNEWS);
    tbStd[1].fsState = _DefMailButtonState(dwRest[1]);

    ASSERT(tbStd[2].idCommand == DVIDM_FONTS);
    tbStd[2].fsState = _DefFontsButtonState(dwRest[2]);

    ASSERT(tbStd[3].idCommand == DVIDM_PRINT);
    tbStd[3].fsState = SHBtnStateFromRestriction(dwRest[3], TBSTATE_ENABLED);

    ASSERT(tbStd[4].idCommand == DVIDM_EDITPAGE);
    tbStd[4].fsState = _DefEditButtonState(dwRest[4]);

    ASSERT(tbStd[5].idCommand == DVIDM_DISCUSSIONS);
    tbStd[5].fsState = _DefDiscussionsButtonState(dwRest[5]);
}

const GUID* CDocObjectHost::_GetButtonCommandGroup()
{
    if (_ToolsButtonAvailable())
        return &CLSID_MSOButtons;
    else
        return &CLSID_InternetButtons;
}

void CDocObjectHost::_AddButtons(BOOL fForceReload)
{
    if (!_pBrowsExt)
        return;

    IExplorerToolbar* pxtb;
    if (_psp && SUCCEEDED(_psp->QueryService(SID_SExplorerToolbar, IID_IExplorerToolbar, (void **)&pxtb)))
    {
        const GUID* pguid = _GetButtonCommandGroup();

        HRESULT hr = pxtb->SetCommandTarget((IOleCommandTarget*)this, pguid, 0);

        if (!fForceReload && hr == S_FALSE) {
            // Another dochost already merged the buttons into the toolbar under the
            // same command group, so don't bother re-merging.  We just need to initialize
            // _iString, since we're skipping the call to _pBrowsExt->InitButtons below.
            VARIANT var = { VT_I4 };
            IUnknown_Exec(_pBrowsExt, &CLSID_PrivBrowsExtCommands, PBEC_GETSTRINGINDEX, 0, &var, NULL);   // should always succeed
            _iString = var.lVal;
        } else {

            UINT nNumExtButtons = 0;

            _pBrowsExt->GetNumButtons(&nNumExtButtons);

            int nNumButtons = nNumExtButtons + ARRAYSIZE(c_tbStd);

            // GetTBArray insures that tbStd != NULL, so we don't need that check here
            TBBUTTON    *tbStd = new TBBUTTON[nNumButtons];

            if (tbStd != NULL)
            {
                memcpy(tbStd, c_tbStd, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbStd));

                UINT iStringIndex = (UINT)-1;  // result of adding the string buffer to the toolbar string list
                HRESULT hr = _pBrowsExt->InitButtons(pxtb, &iStringIndex, pguid);

                ASSERT(tbStd[6].idCommand == DVIDM_CUT);
                ASSERT(tbStd[7].idCommand == DVIDM_COPY);
                ASSERT(tbStd[8].idCommand == DVIDM_PASTE);
                ASSERT(tbStd[9].idCommand == DVIDM_ENCODING);
                ASSERT(tbStd[10].idCommand == DVIDM_PRINTPREVIEW);

                if (SUCCEEDED(hr) && iStringIndex != -1)
                {
                    tbStd[6].iString = iStringIndex;
                    tbStd[7].iString = iStringIndex + 1;
                    tbStd[8].iString = iStringIndex + 2;
                    tbStd[9].iString = iStringIndex + 3;
                    tbStd[10].iString = iStringIndex+ 4;
                    _iString = (int)iStringIndex;
                }
                else
                {
                    tbStd[6].iString = tbStd[7].iString = tbStd[8].iString = tbStd[9].iString = tbStd[10].iString = -1;
                    _iString = -1;
                }

                // Add custom buttons to the toolbar array.  We pass in the nNumButtons
                // as a *sanity check*...
                _pBrowsExt->GetButtons(&tbStd[ARRAYSIZE(c_tbStd)], nNumExtButtons, TRUE);

                _MarkDefaultButtons(tbStd);

                nNumButtons = RemoveHiddenButtons(tbStd, nNumButtons);

                pxtb->AddButtons(pguid, nNumButtons, tbStd);

                delete [] tbStd;
            }
        }

        pxtb->Release();
    }
}

HRESULT CDocObjectHost::UIActivate(UINT uState, BOOL fPrevViewIsDocView)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::UIActivate called %d->%d (this=%x)",
             _uState, uState, this);

    HRESULT hres = S_OK;
    UINT uStatePrev = _uState;

    // We are supposed to update the menu
    if (uState != _uState)
    {
        // There was a state transition.
        //
        _uState = uState;

        // If the new state is SVUIA_DEACTIVATE
        //
        if (_uState == SVUIA_DEACTIVATE)
        {
            //
            //  When we are deactivating (we are navigating away)
            // we UIDeactivate the current MsoView.
            //

            _UIDeactivateMsoView();

            _IPDeactivateMsoView(_pmsov);
            _DestroyBrowserMenu();
        }
        else if (_uState == SVUIA_INPLACEACTIVATE && uStatePrev == SVUIA_ACTIVATE_FOCUS)
        {
            // Transition from SVUIA_ACTIVATE_FOCUS->SVUIA_INPLACEACTIVATE
            //
            //  If we set this DONT_UIDEACTIVATE, then we stop calling
            //  UIActivate(FALSE) when a DocObject in a frameset looses a focus.
            //  It will solve some problems with Office apps (Excel, PPT), which
            //  InPlaceDeactivate when we call UIActivate(FALSE). We want to treat
            //  it as a bug, but unfortunately DocObject spec says that's OK.
            //
            //   Putting this work around, however, slightly confuses MSHTML
            //  (both classic and Trident). Once it's UIActivated, it keep
            //  thinking that it's UIActivated and never calls onUIActivate.
            //  Until we figure out what's the right implementation,
            //  we can't turn this on.             (SatoNa -- 11/04/96).
            //
            _GetAppHack(); // get if we don't have it yet.
            if (_dwAppHack & BROWSERFLAG_DONTUIDEACTIVATE) {
                //
                // HACK: We are supposed to just call UIActivate(FALSE) when
                //  another DocObject (in the case of a frame set) became
                //  UIActivated. Excel/PPT, however, InplaceDeactivate instead.
                //  To work around, SriniK suggested us to call
                //  OnDocWindowActivate(FALSE). (SatoNa)
                //
                IOleInPlaceActiveObject* piact = _xao.GetObject(); // no AddRef
                TraceMsg(TF_SHDAPPHACK, "DOH::UIActivate APPHACK calling %x->OnDocWindowActivate (this=%x)",
                         piact, this);
                if (piact)
                {
                    piact->OnDocWindowActivate(FALSE);
                }
            }
            else if (!(_dwAppHack & BROWSERFLAG_DONTDEACTIVATEMSOVIEW))
            {
                // HACK: In Excel, if we deactiveate the view, it never gets focus again
                // fix for the bug: #20906
                // Also, we don't want to deactivate the view 
                // if the document is currently navigating.
                //
                _UIDeactivateMsoView();
            }
            else
            {
                // We're transitioning from SVUIA_ACTIVATE_FOCUS->SVUIA_INPLACEACTIVATE
                // and BROWSERFLAG_DONTDEACTIVATEMSOVIEW is set.
                // call the object's IOleInPlactActiveObject::OnFrameWindowActivate(FALSE);
                IOleInPlaceActiveObject* piact = _xao.GetObject(); // no AddRef
                if (piact)
                {
                    piact->OnFrameWindowActivate(FALSE);
                }
            }
        }
        else if (uStatePrev == SVUIA_DEACTIVATE)
        {

            //
            //  If UIActivate is called either
            // (1) when the binding is pending; _bsc._pbc!=NULL
            // (2) when the async binding is done; _bsc._pole!=NULL
            //
            SHVMSG("UIActivate about to call _Bind", _bsc._pbc, NULL);
            if (_pole == NULL && _bsc._pbc)
            {
                ASSERT(_pmkCur);
                IBindCtx* pbc = _bsc._pbc;
                pbc->AddRef();
                HRESULT hresT = _BindSync(_pmkCur, _bsc._pbc, _bsc._psvPrev);
                pbc->Release();
                ASSERT(_bsc._pbc==NULL);
                ASSERT(_bsc._psvPrev==NULL);
                ASSERT(_bsc._pbscChained==NULL);
            }

            hres = _EnsureActivateMsoView();

            // We are being asked to UI activate and we are currently deactivated.  Show
            // the view now.
            if (SUCCEEDED(hres) && DocCanHandleNavigation())
            {
                _ShowMsoView();
            }

            _AddButtons(FALSE);

        }
        else
        {
            // opening a new document for 1st time (to UIActive or IPActive)
            goto GoSetFocus;
        }
    }
    else
    {
        TraceMsg(TF_SHDUIACTIVATE, "DOH:::UIActivate -- same uState (%x)", _uState);
GoSetFocus:
        if ((_uState == SVUIA_ACTIVATE_FOCUS)) {
            // see if object is already UIActive.
            if (_ActiveHwnd()) {
                // if it is, we have an hwnd and all we need to do
                // is SetFocus (for compatibility w/ weird guys...)

                if ( IsChildOrSelf( _ActiveHwnd(), GetFocus() ) != S_OK )
                {
                    TraceMsg(TF_SHDUIACTIVATE, "DOH:::UIActivate -- calling SetFocus(%x)", _ActiveHwnd());
                    SetFocus(_ActiveHwnd());
                }
            }
            else {
                // we're in the OC, and it's IPActive not UIActive.
                // (either that or it's the very 1st time for the main view).
                // NOTE: Due to CBaseBrowser code that defers SVUIA_ACTIVATE_FOCUS until
                // application is active, we can have a top level docobject go
                // SVUIA_INPLACEACTIVE and then on activation of the window,
                // we transition to SVUIA_ACTIVATE_FOCUS, thus never UIActivating
                // the docobject (cf: BUG 62138)

                hres = _DoVerbHelper(FALSE);
            }
        }
    }
    if ((_uState == SVUIA_INPLACEACTIVATE) || (_uState  == SVUIA_ACTIVATE_FOCUS))
        _PlaceProgressBar();

    return hres;
}

//***   _DoVerbHelper -- DoVerb w/ various hacks
// NOTES
//  do comments in _OnSetFocus apply here?
HRESULT CDocObjectHost::_DoVerbHelper(BOOL fOC)
{
    HRESULT hres = E_FAIL;
    LONG iVerb = OLEIVERB_SHOW;
    MSG msg;
    LPMSG pmsg = NULL;

    if (_pole)
    {
        if (_uState == SVUIA_INPLACEACTIVATE) 
        {
            iVerb = OLEIVERB_INPLACEACTIVATE;
        }
        else if ((_uState == SVUIA_ACTIVATE_FOCUS)) 
        {
            iVerb = OLEIVERB_UIACTIVATE;
        }
        else 
        {
            TraceMsg(TF_ERROR, "DOC::_DoVerbHelper untested (and probably the wrong iVerb mapping)");
        }

        if (_pedsHelper)
        {
            if (SUCCEEDED(_pedsHelper->GetDoVerbMSG(&msg)))
            {
                pmsg = &msg;
            }
        }
        hres = _pole->DoVerb(iVerb, pmsg, this, (UINT)-1, _hwnd, &_rcView);
        if (hres == OLEOBJ_E_INVALIDVERB && iVerb == OLEIVERB_INPLACEACTIVATE) 
        {
            hres = _pole->DoVerb(OLEIVERB_SHOW, pmsg, this, (UINT)-1, _hwnd, &_rcView);
        }

        if (FAILED(hres)) 
        {
            TraceMsg(DM_ERROR, "DOC::_DoVerbHelper _pole->DoVerb ##FAILED## %x", hres);
        }
    }

    return hres;
}

void CDocObjectHost::_IPDeactivateMsoView(IOleDocumentView* pmsov)
{
    IInitViewLinkedWebOC* pInitViewLinkedWebOC;

    BOOL fIsViewLinked = FALSE;

    TraceMsg(TF_SHDUIACTIVATE, "DOH::_IPDeactivateMsoView called (this==%x)", this);

    if (pmsov)
    {   
        // Because of NativeFrames, in the viewlinked WebOC case, the ReleaseShellView does not 
        // Deactivate the DocumentView. The sequence of these events is critical to Application 
        // Compatibility. So we force the show before the InPlaceDeactivate if we have a viewlinked WebOC.
        ASSERT(_pwb);

        HRESULT hres = E_FAIL;

        if ( _pwb )
        {
            hres = _pwb->QueryInterface(IID_IInitViewLinkedWebOC, (void**)&pInitViewLinkedWebOC);
        }

        if (SUCCEEDED(hres))
        {
            hres = pInitViewLinkedWebOC->IsViewLinkedWebOC(&fIsViewLinked);
            
            if (SUCCEEDED(hres) && fIsViewLinked)
            {
                pmsov->Show(FALSE);
            }

            pInitViewLinkedWebOC->Release();
        }

        IOleInPlaceObject* pipo = NULL;
        HRESULT hresT = _pole->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
        if (SUCCEEDED(hresT))
        {
            pipo->InPlaceDeactivate();
            pipo->Release();
        }

        if (!fIsViewLinked) 
            pmsov->Show(FALSE);     
    }
}

void CDocObjectHost::_UIDeactivateMsoView(void)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::_UIDeactivateMsoView called (this==%x)", this);

    if (_pmsov)
    {
        _pmsov->UIActivate(FALSE);
    }
}

//
// Hide the office toolbar
//
void CDocObjectHost::_HideOfficeToolbars(void)
{
    if (_pmsot) {
        OLECMD rgcmd = { OLECMDID_HIDETOOLBARS, 0 };

        _pmsot->QueryStatus(NULL, 1, &rgcmd, NULL);

        // LATCHED means hidden
        rgcmd.cmdf &= (OLECMDF_SUPPORTED | OLECMDF_LATCHED);

        // If it's supported and visible (not LATCHED), toggle it.
        if (rgcmd.cmdf == OLECMDF_SUPPORTED) {
            _pmsot->Exec(NULL, OLECMDID_HIDETOOLBARS, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }
    }
}

void CDocObjectHost::_ShowMsoView(void)
{
    HRESULT hres;

    //
    // HACK: Word97 UIDeactivate when we call SetInPlaceSite even with the
    //  same in-place site.
    //
    IOleInPlaceSite* psite;
    hres = _pmsov->GetInPlaceSite(&psite);
    if (SUCCEEDED(hres) && psite) {
        if (psite!=this) {
            _pmsov->SetInPlaceSite(this);
        } else {
            TraceMsg(TF_SHDAPPHACK, "DOH::_ShowMsoView not calling SetInPlaceSite because it's already set");
        }
        psite->Release();

    } else {
        _pmsov->SetInPlaceSite(this);
    }

    GetClientRect(_hwnd, &_rcView);

    if ((_uState != SVUIA_INPLACEACTIVATE)      
        || !(_dwAppHack & BROWSERFLAG_MSHTML)  //   or if it's not Trident (office apps expect this call)
        )
    {
        // Trident is sending progress changed messages here -- and causing Compuserve a problem.
        // Flag the fact that we're UIActivating them, and suppress forwarding ProgressChanged
        // messages to our container when this flag is true.  (IE v4.1 bug 54787)
        //
        _fUIActivatingView = TRUE;
        _pmsov->UIActivate(TRUE);
        _fUIActivatingView = FALSE;
    }

    //
    // HACK:
    //
    //  We call _HideOfficeToolbars when our OnUIActivate is called.
    // SriniK suggested us to do it in order to avoid flashing.
    // It works well with Excel (3404), but does not work with Word.
    // Word does not hide its toolbars correctly. To work around that
    // bug, we call _HideofficeToolbars here again.
    //
    _HideOfficeToolbars();

    hres = _pmsov->SetRect(&_rcView);

    if (FAILED(hres)) {
        TraceMsg(DM_ERROR, "DOC::_ShowMsoView _pmsov->SetRect ##FAILED## %x", hres);
    }

    if (FAILED(hres) && _uState == SVUIA_INPLACEACTIVATE) {
        TraceMsg(TF_SHDAPPHACK, "APPHACK# DOH::_ShowMsoView calling UIActivate");
        // HACKHACK: for word.  they refuse to show if they aren't UIActivated.
        // if the setrect fails, and we didn't do a UIActivate, do it now.
        _fDontInplaceActivate = TRUE;
        TraceMsg(TF_SHDAPPHACK, "HACK: CDOH::_ShowMsoView calling UIActive(TRUE) to work around Word bug");
        _pmsov->UIActivate(TRUE);
        _pmsov->SetRect(&_rcView);
    }

    // This is the other case where Trident sends Progress changed messages.
    //
    _fUIActivatingView = TRUE;
    hres = _pmsov->Show(TRUE);
    _fUIActivatingView = FALSE;

    if (FAILED(hres)) {
        TraceMsg(DM_ERROR, "DOH::_ShowMsoView _pmsov->Show ##FAILED## %x", hres);
    }

    _fDrawBackground = FALSE;   /* now that we've shown the object, no need to paint our own background */
}

HRESULT CDocObjectHost::_ActivateMsoView()
{
    _EnableModeless(FALSE);

#ifdef DEBUG
    PERFMSG(TEXT("_ActivateMsoView"), GetCurrentTime() - g_dwPerf);
    g_dwPerf = GetCurrentTime();
#endif

    HRESULT hres = NOERROR;

    if (!DocCanHandleNavigation() || _fWindowOpen)    
    {
        if (!_phls)
        {
            _pole->QueryInterface(IID_IHlinkSource, (void **)&_phls);
        }

        if (_phls && !_fIsHistoricalObject)
        {
            //
            // Special test case for IHlinkFrame marshaling.
            //

            hres = _phls->Navigate(0, _pszLocation);
    
            //
            // If this is one of our internal error pages, we can ignore the
            // failure on the bogus location.  In this case pwszLocation will
            // be the original url that failed preceeded with a '#'.
            //
            LPOLESTR pwszUrl;

            if (FAILED(hres) && SUCCEEDED(_GetCurrentPageW(&pwszUrl, TRUE)))
            {
                // if it begins with res: it may be our erro page
                if (pwszUrl[0] == L'r' && pwszUrl[1] == L'e' && IsErrorUrl(pwszUrl))
                {
                    // It's our internal error page, so ignore the error
                    hres = S_OK;
                }

                OleFree(pwszUrl);
            }

#ifdef DEBUG
            if (!_fWindowOpen && FAILED(hres))
            {
                TraceMsg(DM_ERROR, "DOC::_ActivateMsoView _phls->Navigate(%s) ##FAILED## %x",
                         _pszLocation ? _pszLocation : TEXT(""), hres);
            }
#endif
        }
        else
        {
            // todo: use _DoVerbHelper? (but careful! ACT_FOCUS different)
            LONG iVerb = OLEIVERB_SHOW;
            MSG msg;
            LPMSG pmsg = NULL;

            if (_uState == SVUIA_INPLACEACTIVATE) {
                iVerb = OLEIVERB_INPLACEACTIVATE;
            }
            if (_pedsHelper)
            {
                if (SUCCEEDED(_pedsHelper->GetDoVerbMSG(&msg)))
                {
                    pmsg = &msg;
                }
            }
            hres = _pole->DoVerb(iVerb, pmsg, this, (UINT)-1, _hwnd, &_rcView);
            if (hres == OLEOBJ_E_INVALIDVERB && iVerb == OLEIVERB_INPLACEACTIVATE)
                hres = _pole->DoVerb(OLEIVERB_SHOW, pmsg, this, (UINT)-1, _hwnd, &_rcView);

            if (FAILED(hres)) {
                TraceMsg(DM_ERROR, "DOC::_ActivateMsoView _pole->DoVerb ##FAILED## %x", hres);
            }
        }
    }

    _fPrevDocHost = TRUE;

    // the doc is activated
    if (SUCCEEDED(hres))
    {
        _ReleasePendingObject();

        if (_fHaveParentSite)
        {
            _HideOfficeToolbars();
        }
    }

    _EnableModeless(TRUE);

    return hres;
}

void CDocObjectHost::OnInitialUpdate()
{
    _fWindowOpen = FALSE;

    ResetRefreshUrl();
}

void CDocObjectHost::ResetRefreshUrl()
{
    if (_pwszRefreshUrl)
    {
        OleFree(_pwszRefreshUrl);
        _pwszRefreshUrl = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_NavigateDocument
//
//  Synopsis : Navigates the document to the given URL
//
//+---------------------------------------------------------------------------

HRESULT
CDocObjectHost::_NavigateDocument(BSTR bstrUrl, BSTR bstrLocation)
{
    HRESULT hres = E_FAIL;
    DWORD   dwFlags = 0;
    IHTMLPrivateWindow * pPrivWindow  = NULL;

    ASSERT(_fDocCanNavigate && (_fPrevDocHost || _uState == SVUIA_DEACTIVATE));
    ASSERT(_pHTMLWindow);

    // Waiting for the real navigate call so we don't get duplicate events
    
    if (_pwb)
    {
        _pwb->SetNavigateState(BNS_NORMAL);
    }
    

    if (_pHTMLWindow)  // Stress fix
    {
        hres = _pHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow, (void**)&pPrivWindow);

        if (S_OK == hres)
        {
            CComBSTR cbstrShortCut;

            IBindStatusCallback * pBindStatusCallback;
            LPTSTR pszHeaders = NULL;
            LPBYTE pPostData = NULL;
            DWORD cbPostData = 0;
            STGMEDIUM stgPostData;
            BOOL fHavePostStg = FALSE;

            BSTR bstrHeaders = NULL;
            VARIANT vaHeaders = {0};
            SAFEARRAY * psaPostData = NULL;
            VARIANT vaPostData = {0};

            if (SUCCEEDED(IUnknown_QueryService(_phf, SID_SHlinkFrame, IID_PPV_ARG(IBindStatusCallback, &pBindStatusCallback))))
            {
                GetHeadersAndPostData(pBindStatusCallback, &pszHeaders, &stgPostData, &cbPostData, NULL);
                pBindStatusCallback->Release();
                fHavePostStg = TRUE;

                if (stgPostData.tymed == TYMED_HGLOBAL) 
                {
                    pPostData = (LPBYTE) stgPostData.hGlobal;

                    if (pPostData && cbPostData)
                    {
                        // make a SAFEARRAY for post data
                        psaPostData = MakeSafeArrayFromData(pPostData, cbPostData);

                        // put the post data SAFEARRAY into a variant so we can pass through automation
                        if (psaPostData)
                        {
                            V_VT(&vaPostData) = VT_ARRAY | VT_UI1;
                            V_ARRAY(&vaPostData) = psaPostData;
                        }
                    }
                }

                if (pszHeaders && pszHeaders[0])
                {
                    bstrHeaders = SysAllocStringT(pszHeaders);
                    V_VT(&vaHeaders) = VT_BSTR;
                    V_BSTR(&vaHeaders) = bstrHeaders;
                }
            }

            _GetShortCutPath(&cbstrShortCut);
            _GetDocNavFlags(&dwFlags);

            // Do the navigate
            //
            hres = pPrivWindow->SuperNavigate(bstrUrl,
                                              bstrLocation,
                                              cbstrShortCut,
                                              NULL,
                                              &vaPostData,
                                              &vaHeaders,
                                              dwFlags);
            pPrivWindow->Release();

            if (fHavePostStg) 
            {
                ReleaseStgMedium(&stgPostData);
            }

            if (bstrHeaders)
            {
                SysFreeString(bstrHeaders);
            }

            if (V_ARRAY(&vaPostData))
            {
                ASSERT(V_VT(&vaPostData) == (VT_ARRAY | VT_UI1));
                VariantClearLazy(&vaPostData);
            }

            _fRefresh = FALSE; // clear the refresh flag.
        }
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_GetShortCutPath
//
//  Synopsis : Returns the shortcut path.
//
//+---------------------------------------------------------------------------

void
CDocObjectHost::_GetShortCutPath(BSTR * pbstrShortCutPath)
{
    HRESULT hres;
    VARIANT varShortCutPath = {0};
    IOleCommandTarget * pcmdt;

    ASSERT(pbstrShortCutPath);

    *pbstrShortCutPath = NULL;

    hres = QueryService(SID_SHlinkFrame, IID_IOleCommandTarget, (void **)&pcmdt);

    if (S_OK == hres)
    {
       hres = pcmdt->Exec(&CGID_Explorer, SBCMDID_GETSHORTCUTPATH, 0, NULL, &varShortCutPath);

       if (S_OK == hres && VT_BSTR == V_VT(&varShortCutPath) && V_BSTR(&varShortCutPath))
       {
           *pbstrShortCutPath = SysAllocString(V_BSTR(&varShortCutPath));
       }
       else if (_pocthf)
       {
           VariantClear(&varShortCutPath);

           // if we couldn't find it on that service, try the cached HLink interface
           // this is necessary for ND & Mars which provide a different implementation for the HLink interface
           hres = _pocthf->Exec(&CGID_Explorer, SBCMDID_GETSHORTCUTPATH, 0, NULL, &varShortCutPath);

           if (S_OK == hres && VT_BSTR == V_VT(&varShortCutPath) && V_BSTR(&varShortCutPath))
           {
               *pbstrShortCutPath = SysAllocString(V_BSTR(&varShortCutPath));
           }
       }

       pcmdt->Release();
    }

    VariantClear(&varShortCutPath);
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_GetDocNavFlags
//
//  Synopsis : Returns the flags for navigation.
//
//+---------------------------------------------------------------------------

void
CDocObjectHost::_GetDocNavFlags(DWORD * pdwDocNavFlags)
{
    // Find out if we are in the middle of an autosearch.
    // If we are, set the necessary document flags.
    //
    HRESULT hr;
    DWORD   dwSuffixIdx     = -1;
    BOOL    fAllowSearch    = FALSE;
    BOOL    fContinueSearch = FALSE;
    DWORD   dwNavFlags      = 0;

    ASSERT(pdwDocNavFlags);

    hr = _GetSearchInfo(_psp, &dwSuffixIdx, &fAllowSearch,
                        &fContinueSearch, NULL, NULL);

    if (SUCCEEDED(hr) && dwSuffixIdx > 1 && fContinueSearch)
    {
        // We aren't really in an autosearch, but are in 
        // a redirection from an autosearch (i.e., there is
        // a long standing bug where the MSN autosearch page
        // is placed in the travel log. When you press back,
        // the search is restarted. However, if the search
        // info is not reset here, the suffix index is incorrect.
        // 
        if (!fAllowSearch)
        {
            _bsc._SetSearchInfo(this, 0, fAllowSearch, fContinueSearch, FALSE);
        }
    }

    // Check to see if the navigation should be suppressed from the history
    //
    if ( _pwb && (S_OK == _pwb->GetFlags(&dwNavFlags))
       && (dwNavFlags & BSF_NAVNOHISTORY))
    {
        *pdwDocNavFlags |= DOCNAVFLAG_DONTUPDATETLOG;
    }

    if ( _fRefresh )
    {
        *pdwDocNavFlags |= DOCNAVFLAG_REFRESH;
    }
}

HRESULT CDocObjectHost::_EnsureActivateMsoView()
{
    HRESULT hres = E_FAIL;

    // if we've got an ole object and
    // either we don't have a view, or we don't have an active view..
    // do the activation
    if (_pole)
    {

        if (!_pmsov || !_ActiveObject()) {

            hres = _ActivateMsoView();

            // Note that we should not UIActivate it here. We should wait
            // until the DocObject calls our ActivateMe
            // _ShowMsoView();
        }
    }

    return hres;
}

//
// This member closes the MsoView window and releases interface
// pointers. This is essentially the reverse of _CreateMsoView.
//
void CDocObjectHost::_CloseMsoView(void)
{
    ATOMICRELEASE(_pmsot);

    if (_pmsov)
    {
        VIEWMSG(TEXT("_CloseMsoView calling pmsov->UIActivate(FALSE)"));
        IOleDocumentView* pmsov = _pmsov;
        _pmsov = NULL;
        _fDontInplaceActivate = FALSE;

#ifdef DONT_UIDEACTIVATE
        if (_uState != SVUIA_DEACTIVATE)
            pmsov->UIActivate(FALSE);
#else // DONT_UIDEACTIVATE
        if (_uState == SVUIA_ACTIVATE_FOCUS)
            pmsov->UIActivate(FALSE);
#endif // DONT_UIDEACTIVATE
       
        _IPDeactivateMsoView(pmsov);

        pmsov->CloseView(0);
        pmsov->SetInPlaceSite(NULL);
        pmsov->Release();
        VIEWMSG(TEXT("_CloseMsoView called pmsov->Release()"));
    }

    ATOMICRELEASE(_pmsoc);


}

void CDocObjectHost::_OnPaint(HDC hdc)
{
    if (_pmsov && !_ActiveObject())
    {
        HRESULT hres;
        RECT rcClient;
        GetClientRect(_hwnd, &rcClient);
        hres = OleDraw(_pmsov, DVASPECT_CONTENT, hdc, &rcClient);
        TraceMsg(0, "shd TR ::_OnPaint OleDraw returns %x", hres);
    }
}

HRESULT _GetDefaultLocation(LPWSTR pszPath, DWORD cchPathSizeIn, UINT id)
{
    WCHAR szPath[MAX_URL_STRING];
    DWORD cbSize = SIZEOF(szPath);
    DWORD cchPathSize = cchPathSizeIn;
    HRESULT hres = E_FAIL;
    HKEY hkey;

    // Share this code!!!
    // This is Internet Explorer Specific

    HKEY hkeyroot = id == IDP_CHANNELGUIDE ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
    if (RegOpenKeyW(hkeyroot,
            L"Software\\Microsoft\\Internet Explorer\\Main",
            &hkey)==ERROR_SUCCESS)
    {
        DWORD dwType;

        LPCWSTR pszName;

        switch(id) {
        default:
            ASSERT(0);
        case DVIDM_GOHOME:
            pszName = L"Default_Page_URL";
            break;

        case DVIDM_GOSEARCH:
            pszName = L"Default_Search_URL";
            break;

        case IDP_UPDATE:
            pszName = L"Default_Update_URL";
            break;

        case IDP_CHANNELGUIDE:
            pszName = L"ChannelsURL";
            break;

        }

        if (RegQueryValueExW(hkey, pszName,
            0, &dwType, (LPBYTE)szPath, &cbSize)==ERROR_SUCCESS)
        {
            // When reading a URL from registry, treat it like it was typed
            // in on the address bar.

            hres = S_OK;

            if(!ParseURLFromOutsideSourceW(szPath, pszPath, &cchPathSize, NULL))
                StrCpyNW(pszPath, szPath, cchPathSizeIn);

            if(IsFileUrlW(pszPath))
            {
                cchPathSize = cchPathSizeIn;
                hres = PathCreateFromUrlW(pszPath, pszPath, &cchPathSize, 0);
            }
        }
        RegCloseKey(hkey);
    }



    HOMEMSG("_GetStdLocation returning",
            (SUCCEEDED(hres) ? pszPath : TEXT("Error")), hres);

    return hres;
}

HRESULT _GetStdLocation(LPTSTR pszPath, DWORD cchPathSize, UINT id)
{
    TCHAR szPathTemp[MAX_URL_STRING];
    DWORD cchTempSize = ARRAYSIZE(szPathTemp);
    HRESULT hres = E_FAIL;
    LPCWSTR pszName = NULL;

    ASSERT(cchPathSize >= cchTempSize);     // If we hit this, we will truncate the URL in some cases.
    ASSERT(pszPath && (cchPathSize > 0)); // Not Optional
    pszPath[0] = TEXT('\0');

    // Share this code!!!
    // This is Internet Explorer Specific
    switch(id) {
    default:
        ASSERT(0);
    case DVIDM_GOHOME:
        pszName = L"Start Page";
        break;

    case DVIDM_GOFIRSTHOME:
    case DVIDM_GOFIRSTHOMERO:
        pszName = L"First Home Page";
        break;

    case DVIDM_GOSEARCH:
        pszName = L"Search Page";
        break;

    case DVIDM_SEARCHBAR:
        pszName = L"Search Bar";
        break;

    case DVIDM_GOLOCALPAGE:
        pszName = L"Local Page";
        break;
    }

    hres = URLSubRegQuery(szRegKey_SMIEM, pszName, TRUE,
                       szPathTemp, cchTempSize, URLSUB_ALL);
    if (FAILED(hres) &&
        ((DVIDM_GOFIRSTHOME == id) || (DVIDM_GOFIRSTHOMERO == id)))
    {
        // The First Home key doesn't exist so use the home key.
        pszName = TEXT("Start Page");
        hres = URLSubRegQuery(szRegKey_SMIEM, pszName, TRUE,
                           szPathTemp, cchTempSize, URLSUB_ALL);
        id = DVIDM_GOHOME;
    }

    if (SUCCEEDED(hres))
    {
        // When reading a URL from registry, treat it like it was typed
        // in on the address bar.

        // Recursion block.  If requesting the home page, and the home page is "about:home", substitute
        // "about:blank" (otherwise we'll recurse to death)

        if (DVIDM_GOHOME == id && !StrCmpI(szPathTemp, TEXT("about:home")) )
        {
            StrCpyN(szPathTemp, TEXT("about:blank"), MAX_URL_STRING);
        }

        if(ParseURLFromOutsideSourceW(szPathTemp, pszPath, &cchPathSize, NULL))
        {
            if(IsFileUrlW(pszPath))
                hres = PathCreateFromUrlW(pszPath, pszPath, &cchPathSize, 0);
        }
    }

    if (DVIDM_GOFIRSTHOME == id)    // Delete that FIRSTHOME key
    {
        HUSKEY hUSKey;

        if (ERROR_SUCCESS == SHRegOpenUSKey(szRegKey_SMIEM, KEY_WRITE, NULL, &hUSKey, FALSE))
        {
            SHRegDeleteUSValue(hUSKey, TEXT("First Home Page"), SHREGDEL_DEFAULT);
            SHRegCloseUSKey(hUSKey);
        }
        hres = S_OK;
    }

    HOMEMSG("_GetStdLocation returning",
            (SUCCEEDED(hres) ? pszPath : TEXT("Error")), hres);

    return hres;
}


HRESULT WINAPI _GetDefaultLocation(UINT idp, LPWSTR pszPath, UINT cchMax)
{
    switch (idp)
    {
    case IDP_UPDATE:
    case IDP_CHANNELGUIDE:
        URLSubLoadString(NULL, IDS_DEF_UPDATE+(idp-IDP_UPDATE), pszPath, cchMax, URLSUB_ALL);
        break;

    default:
        _GetDefaultLocation(pszPath, cchMax, (idp == IDP_SEARCH) ? DVIDM_GOSEARCH : DVIDM_GOHOME);
        break;
    }

    return S_OK;
}


HRESULT WINAPI SHDGetPageLocation(HWND hwndOwner, UINT idp, LPWSTR pszPath, UINT cchMax, LPITEMIDLIST *ppidlOut)
{
    TCHAR szBuf[MAX_URL_STRING];
    if (pszPath==NULL) {
        pszPath = szBuf;
        cchMax = ARRAYSIZE(szBuf);
    }
    *pszPath = L'\0';
    *ppidlOut = NULL;
    HRESULT hres = S_OK;
    switch (idp) {
    case IDP_UPDATE:
    case IDP_CHANNELGUIDE:
        ASSERT(IDP_CHANNELGUIDE-IDP_UPDATE == IDS_DEF_CHANNELGUIDE-IDS_DEF_UPDATE);
        if (FAILED(hres = _GetDefaultLocation(pszPath, cchMax, idp)))
        {
            hres = _GetDefaultLocation(idp, pszPath, cchMax);
        }
        break;

    default:
        ASSERT(idp==IDP_START || idp==IDP_SEARCH);
        hres = _GetStdLocation(pszPath, cchMax,
                    (idp == IDP_SEARCH) ? DVIDM_GOSEARCH : DVIDM_GOHOME);
        if (FAILED(hres))
        {
            hres = _GetDefaultLocation(idp, pszPath, cchMax);
        }
        break;
    }

    if (SUCCEEDED(hres))
    {
        hres = IECreateFromPath(pszPath, ppidlOut);
        if (FAILED(hres))
        {
            // IECreateFromPath() above could have failed if the default location
            // was invalid. (Like file://server_no_exist/
            _GetDefaultLocation(idp, pszPath, cchMax);
            hres = IECreateFromPath(pszPath, ppidlOut);
        }

        HOMEMSG("SHDGetPageLocation SHILCreateFromPage returned", pszPath, hres);
    }

    return hres;
}


void CDocObjectHost::_ChainBSC()
{
    if (!_bsc._pbscChained && _phf) 
    {
        // Get "chaigned" bind status, if any
        IServiceProvider * psp = NULL;

        HRESULT hres = _phf->QueryInterface(IID_IServiceProvider, (void **)&psp);

        CHAINMSG("_StartAsyncBinding hlf->QI returns", hres);

        if (SUCCEEDED(hres)) 
        {
            ASSERT(NULL == _bsc._pbscChained);

            hres = psp->QueryService(SID_SHlinkFrame, IID_IBindStatusCallback, (void **)&_bsc._pbscChained);

            CHAINMSG("_StartAsyncBinding psp(hlf)->QS returns", hres);
            psp->Release();

            if (SUCCEEDED(hres))
            {
                ASSERT(NULL==_bsc._pnegotiateChained);
                _bsc._pbscChained->QueryInterface(IID_IHttpNegotiate, (void **)&_bsc._pnegotiateChained);
            }
        }
    }
}

//
// WARNING: Following two global variables are shared among multiple-threads
//  in a thread. Therefore, all right-access must be serialized and all read
//  access should be blocked when right is going on.
//
//   Right now, we just initialize them once (based on the registry setting)
//  and never update. It allows us to simplify the code quite a bit. If we
//  need to update, then _RegisterMediaTypeClass should be changed significantlly
//  so that we can safely handle multiple access to those hdsa's. (SatoNa)
//
HDSA g_hdsaCls = NULL;
HDSA g_hdsaStr = NULL;

BOOL CDocObjectHost::_BuildClassMapping(void)
{
    if (g_hdsaCls) 
    {
        return DSA_GetItemCount(g_hdsaCls) == DSA_GetItemCount(g_hdsaStr);
    }

    ENTERCRITICAL;
    if (!g_hdsaCls) {
        g_hdsaStr = DSA_Create(SIZEOF(LPCSTR), 32);
        if (g_hdsaStr)
        {
            HDSA hdsaCls = DSA_Create(SIZEOF(CLSID), 32);
            if (hdsaCls)
            {
                HKEY hkey;
                if (RegOpenKey(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\Internet Explorer\\MediaTypeClass"),
                        &hkey) == ERROR_SUCCESS)
                {
                    TCHAR szCLSID[64];  // enough for "{CLSID}"
                    for (int iKey=0;
                         RegEnumKey(hkey, iKey, szCLSID, SIZEOF(szCLSID)/sizeof(szCLSID[0]))==ERROR_SUCCESS;
                         iKey++)
                    {
                        CLSID clsid;
                        if (FAILED(CLSIDFromString(szCLSID, &clsid))) {
                            TraceMsg(DM_WARNING, "CDOH::_RMTC CLSIDFromString(%x) failed", szCLSID);
                            continue;
                        }

                        TraceMsg(DM_MIMEMAPPING, "CDOH::_RMTC RegEnumKey found %s", szCLSID);
                        HKEY hkeyCLSID;
                        if (RegOpenKey(hkey, szCLSID, &hkeyCLSID) == ERROR_SUCCESS)
                        {
                            for (int iValue=0; ; iValue++)
                            {
                                CHAR szFormatName[128];
                                DWORD dwType;
                                DWORD cchValueName = ARRAYSIZE(szFormatName);
                                //
                                // Keep the name ansi because it needs to get
                                // passed to urlmon's RegisterMediaTypeClass as
                                // ansi.
                                //
                                if (RegEnumValueA(hkeyCLSID, iValue, szFormatName, &cchValueName, NULL,
                                                 &dwType, NULL, NULL)==ERROR_SUCCESS)
                                {
                                    TraceMsg(DM_MIMEMAPPING, "CDOH::_RMTC RegEnumValue found %s", szFormatName);
                                    LPSTR psz = StrDupA(szFormatName);
                                    if (psz) {
                                        DSA_InsertItem(hdsaCls, 0xffff, &clsid);
                                        if (DSA_InsertItem(g_hdsaStr, 0xffff, &psz)<0) {
                                            LocalFree(psz);
                                            psz = NULL;
                                            break;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                            RegCloseKey(hkeyCLSID);
                        } else {
                            TraceMsg(DM_WARNING, "CDOH::_RMTC RegOpenKey(%s) failed", szCLSID);
                        }
                    }
                    RegCloseKey(hkey);
                } else {
                    TraceMsg(0, "CDOH::_RMTC RegOpenKey(MediaTypeClass) failed");
                }

                //
                // Update g_hdsaCls at the end so that other thread won't
                // access while we are adding items.
                //
                g_hdsaCls = hdsaCls;
                ASSERT(DSA_GetItemCount(g_hdsaCls)==DSA_GetItemCount(g_hdsaStr));
            }
        }
    }

    LEAVECRITICAL;

    return (g_hdsaCls && DSA_GetItemCount(g_hdsaCls)==DSA_GetItemCount(g_hdsaStr));
}

HRESULT CDocObjectHost::_RegisterMediaTypeClass(IBindCtx* pbc)
{
    HRESULT         hres    = S_FALSE; // Assume no mapping

    if (_BuildClassMapping() && DSA_GetItemCount(g_hdsaCls)) {
        //
        // WARNING: This code assumes that g_hdsaCls/g_hdsaStr never
        //  changes once they are initializes. Read notes above
        //  those global variables for detail.
        //
        hres = RegisterMediaTypeClass(pbc,
                        DSA_GetItemCount(g_hdsaCls),
                        (LPCSTR*)DSA_GetItemPtr(g_hdsaStr, 0),
                        (CLSID*)DSA_GetItemPtr(g_hdsaCls, 0), 0);

        TraceMsg(DM_MIMEMAPPING, "CDOH::_StartAsyncBinding RegisterMTC returns %x", hres);
    }

    // Now see if the container has anything that needs to be registered
    //
    if (_psp)
    {
        IMimeInfo * pIMimeInfo;
        hres = _psp->QueryService(SID_IMimeInfo, IID_IMimeInfo, (void **)&pIMimeInfo);

        if (SUCCEEDED(hres))
        {
            UINT            cTypes  = 0;
            LPCSTR          *ppszTypes = NULL;
            CLSID           *pclsIDs= NULL;
            ASSERT(pIMimeInfo);
            hres = pIMimeInfo->GetMimeCLSIDMapping(&cTypes, &ppszTypes, &pclsIDs);

            if (SUCCEEDED(hres)) {
                if (cTypes && ppszTypes && pclsIDs) {
                    // Last one to register wins, so if the container wants to override what is
                    // already registered this should do it.
                    //  URLMon will handle the duplicates corectly.
                    //
                    hres = RegisterMediaTypeClass(pbc, cTypes, ppszTypes, pclsIDs, 0);

                    TraceMsg(DM_MIMEMAPPING, "CDOH::_StartAsyncBinding RegisterMTC for Container returns %x", hres);
                }
                // RegisterMediaTypeClass should have made copies
                // so free the containers allocations as it expects us to do
                //
                //      CoTaskMemFree(NULL) is OK
                //
                CoTaskMemFree(ppszTypes);
                CoTaskMemFree(pclsIDs);
            }
            pIMimeInfo->Release();
        } else {
            hres = S_FALSE;
        }
    }
    return hres;
}

HRESULT _RegisterAcceptHeaders(IBindCtx* pbc, IShellBrowser* psb)
{
    return RegisterDefaultAcceptHeaders(pbc, psb);
}

HRESULT GetAmbientBoolProp(IExpDispSupport* peds, DISPID dispid, BOOL *pb)
{
    VARIANT var = {0};

    // Assume failure
    *pb = FALSE;

    HRESULT hres = peds->OnInvoke(dispid, IID_NULL, NULL, DISPATCH_PROPERTYGET, (DISPPARAMS *)&g_dispparamsNoArgs, &var, NULL, NULL);
    if (SUCCEEDED(hres))
    {
        // VB returns success with VT_EMPTY, so we can't assert here
        if (var.vt == VT_BOOL)
        {
            *pb = (var.boolVal) ? TRUE : FALSE;
        }
        else
        {
            // Even though VB says VT_EMPTY, we don't know what other containers
            // might shove in here. Make sure we clean up.
            //
            VariantClear(&var);
        }
    }
    else
    {
        hres = E_FAIL;
    }

    return hres;
}

HRESULT CDocObjectHost::_GetOfflineSilent(BOOL *pbIsOffline, BOOL *pbIsSilent)
{
    if (_peds)
    {
        if (pbIsOffline)
            GetAmbientBoolProp(_peds, DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, pbIsOffline);

        if (pbIsSilent)
            GetAmbientBoolProp(_peds, DISPID_AMBIENT_SILENT, pbIsSilent);
    }
    else
    {
        if (pbIsOffline)
            *pbIsOffline = FALSE;
        if (pbIsSilent)
            *pbIsSilent = FALSE;
    }

    return S_OK;
}



/*
    Callback function for RatingObtainQuery
*/
void RatingObtainQueryCallback(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, LPVOID lpvInpageRating)
{
    TraceMsg(DM_PICS, "RatingObtainQueryCallback given result %x", hr);

    /* WARNING: This function is called by MSRATING.DLL on a separate thread,
     * not the main message loop thread.  Touch nothing in important data
     * structures not protected by critical sections!
     *
     * Merely format up a windows message with the info we have;  we'll handle
     * this in the main thread, if we ever get there.
     *
     * Note that pszRating is ignored, we count on the ratings engine to have
     * called RatingCheckUserAccess for us and provide the HRESULT.
     */
    if (!::_PostPicsMessage(dwUserData, hr, lpvInpageRating))
    {
        if ( lpvInpageRating )
        {
            ::RatingFreeDetails(lpvInpageRating);
            lpvInpageRating = NULL;
        }
    }
}


HRESULT CDocObjectHost::_StartAsyncBinding(IMoniker * pmk, IBindCtx * pbc, IShellView * psvPrev)
{
    URLMSG(TEXT("_StartAsyncBinding called"));
    HRESULT hres;

    ASSERT(_bsc._pbc == NULL && _pole == NULL);
    _bsc._RegisterObjectParam(pbc);

    //
    //  Associate the client site as an object parameter to this
    // bind context so that Trident can pick it up while processing
    // IPersistMoniker::Load().
    //
    pbc->RegisterObjectParam(WSZGUID_OPID_DocObjClientSite, SAFECAST(this, IOleClientSite*));

    _ChainBSC();

    IUnknown * punk = NULL;

    _bsc._pbc = pbc;
    pbc->AddRef();


    // Decide right here whether or not this frame is offline
    BOOL bFrameIsOffline = FALSE;
    BOOL bFrameIsSilent = FALSE;


    this->_GetOfflineSilent(&bFrameIsOffline, &bFrameIsSilent);

    _bsc._bFrameIsOffline = bFrameIsOffline ? TRUE : FALSE;
    _bsc._bFrameIsSilent  = bFrameIsSilent ? TRUE : FALSE;
    BOOL bSuppressUI = (_bsc._bFrameIsSilent || _IsDesktopItem(SAFECAST(this, CDocObjectHost*))) ? TRUE : FALSE;

#ifdef DEBUG
    PERFMSG(TEXT("_StartAsyncBinding Calling pmk->BindToObject"), GetCurrentTime()-g_dwPerf);
    g_dwPerf = GetCurrentTime();
#endif

#ifdef DEBUG
    if (g_dwPrototype & 0x00000800) {
        TraceMsg(DM_TRACE, "CDOH::_StartAsyncBinding skipping CLSID mapping");
    }
    else
#endif
    {
        // Register overriding mime->CLSID mapping
        _RegisterMediaTypeClass(pbc);
    }

    // Register accept headers
    _RegisterAcceptHeaders(pbc, _psb);

    if (_pwb)
    {
        _pwb->SetNavigateState(BNS_BEGIN_NAVIGATE);
    }

    _StartBasePicsProcessor();

    //
    //  Crazy sync/async behavior of URLMON.  - zekel - 6-AUG-97
    //  any of the following may occur:
    //
    //  1.  SUCCESS or FAILURE:  we receive sync E_PENDING from BindToObject,
    //      and then get an Async HRESULT on OnStopBinding().
    //      this is the most common case and the basic design.
    //
    //  2.  SUCCESS:  we receive sync S_OK from BindToObject and
    //      need to complete the async behavior on our BSCB ourself
    //      since urlmon started but did not finish.
    //
    //  3.  SUCCESS:  while inside BindToObject(), we receive sync S_OK
    //      from OnStopBinding(), and then BindToObject returns with S_OK.
    //
    //  4.  FAILURE:  simplest case is an error being returned from BindToObject()
    //      but without an any OnStopBinding() so we need to complete
    //      the async behavior on our BSCB ourself since urlmon started but did not finish.
    //      this usually occurs when accessing local files.
    //
    //  5.  FAILURE:  while inside BindToObject(), we receive sync S_OK from OnStopBinding(),
    //      and then BindToObject returns with some other error that needs to be handled.
    //      this occurs with some malformed urls.
    //
    //  6.  FAILURE:  while inside BindToObject(), we receive a sync error from OnStopBinding(),
    //      and then BindToObject returns with some other error (usually E_FAIL).
    //      we need to trust the first one.  this occurs when wininet
    //      returns syncronous errors, and its error is the one returned in OnStopBinding()
    //
    //  7.  FAILURE:  while inside BindToObject(), we receive a sync error from OnStopBinding(),
    //      and then BindToObject returns with E_PENDING.  which we think means everything
    //      is going great, and urlmon thinks it is done.  this happens with a file: to
    //      a resource that is not hostable.  we need to show the download UI.
    //
    //  in order to support all the errors in the most consistent and safe manner,
    //  we defer any errors in OnStopBinding() if they are delivered synchronously
    //  on BindToObject().  the OnStopBinding() error always overrides the BindToObject()
    //  error, but any error will always override any success.
    //


    ASSERT(S_OK == _hrOnStopBinding);

    _fSyncBindToObject = TRUE;

    URLMSG(TEXT("_StartAsyncBinding calling pmk->BindToObject"));

    hres = pmk->BindToObject(pbc, NULL, IID_IUnknown, (void**)&punk);

    URLMSG3(TEXT("_StartAsyncBinding pmk->BindToObject returned"), hres, punk);

    _fSyncBindToObject = FALSE;

    if (SUCCEEDED(_hrOnStopBinding) && (SUCCEEDED(hres) || hres==E_PENDING))
    {
        hres = S_OK;

        if (_bsc._pbc) {
            //
            // In case OnStopBinding hasn't been called.
            //
            if (!_pole)
            {
                if (psvPrev)
                {
                    _bsc._psvPrev = psvPrev;
                    psvPrev->AddRef();
                }
            }
            else
            {
                URLMSG3(TEXT("_StartAsyncBinding we've already got _pole"), hres, _pole);
            }

            //
            // If moniker happen to return the object synchronously, emulate
            // OnDataAvailable callback and OnStopBinding.
            //
            if (punk)
            {
                _bsc.OnObjectAvailable(IID_IUnknown, punk);
                _bsc.OnStopBinding(hres, NULL);
                punk->Release();
                ASSERT(_bsc._pbc==NULL);

            }
        }
        else
        {
            //
            // OnStopBinding has been already called.
            //
            if (punk)
            {
                AssertMsg(0, TEXT("CDOH::_StartAsyncBinding pmk->BindToObject returned punk after calling OnStopBinding")); // Probably URLMON bug.
                punk->Release();
            }
        }
    }
    else
    {
        // Binding failed.
        TraceMsg(DM_WARNING, "CDOH::_StartAsyncBinding failed (%x)", hres);

        //
        //  Urlmon is inconsistent in it's error handling - zekel - 4-AUG-97
        //  urlmon can return errors in three different ways from BindToObject()
        //  1.  it can return back a simple syncronous error.  without calling OnStopBinding()
        //
        //  2.  it can return a sync error,
        //          but call OnStopBinding() with S_OK first on the same thread;
        //
        //  3.  it can return a sync error,
        //          but also call OnStopBinding() with the real Error first on the same thread.
        //
        //  4.  it can return E_PENDING,
        //          but already have called OnStopBinding() with the real error.
        //
        //  SOLUTIONS:
        //  in all cases of error in OnStopBinding(), we will now postpone the OnStopBinding processing util after
        //  we have returned from the BindToObject().  we try to use the best error.
        //  we allow successful OnStopBinding() to pass through unmolested, and trap
        //  the error here if necessary.
        //

        if (FAILED(_hrOnStopBinding))
            hres = _hrOnStopBinding;

        if (_bsc._pbc)
            _bsc.OnStopBinding(hres, NULL);
        else if (!bSuppressUI)
        {
            //
            //  OnStopBinding was already called, but with a success
            //  so we need to handle the error here.  this happens
            //  with some invalid URLs like http:/server
            //

            BOOL fCancelErrorPage = FALSE;

            _FireNavigateErrorHelper(NULL, ERRORPAGE_SYNTAX, &fCancelErrorPage); 

            if (fCancelErrorPage)
            {
                _CancelPendingNavigation(TRUE, FALSE);
            }
            else
            {
                // Fix for W98 webtv app.  If we're in a frame don't
                // blow away the frame set to dispaly the error.
                //
                if (!_fHaveParentSite)
                {
                    _bsc._NavigateToErrorPage(ERRORPAGE_SYNTAX, this, FALSE);
                }
            }
        }

        ASSERT(_bsc._pbc==NULL);
    }

    return hres;
}

void CDocObjectHost::_ReleasePendingObject(BOOL fIfInited)
{
    HRESULT hres;
    IOleObject *polePending;
#ifdef TRIDENT_NEEDS_LOCKRUNNING
    IRunnableObject *pro;
#endif

    if (fIfInited == FALSE && _fPendingWasInited == FALSE)
        return;

    if (_punkPending)
    {
        if (_fCreatingPending)
        {
            _fAbortCreatePending = 1;
            return;
        }

        if (!_fPendingNeedsInit && !IsSameObject(_punkPending, _pole))
        {
            hres = _punkPending->QueryInterface(IID_IOleObject, (void **) &polePending);
            if (SUCCEEDED(hres)) {
                LPOLECLIENTSITE pcs;
                if (SUCCEEDED(polePending->GetClientSite(&pcs)) && pcs)
                {
                    if (pcs == SAFECAST(this, LPOLECLIENTSITE))
                    {
                        polePending->SetClientSite(NULL);
                    }
                    pcs->Release();
                }
                polePending->Release();
            }
        }
#ifdef TRIDENT_NEEDS_LOCKRUNNING
        //  TRIDENT NO LONGER SUPPORTS IRunnableObject
        hres = _punkPending->QueryInterface(IID_IRunnableObject, (void **) &pro);
        if (SUCCEEDED(hres))
        {
            hres = pro->LockRunning(FALSE, TRUE);
            pro->Release();
        }
#endif
        SAFERELEASE(_punkPending);
        _fPendingWasInited = FALSE;
    }
}

void CDocObjectHost::_ReleaseOleObject(BOOL fIfInited)
{
    TraceMsg(DM_DEBUGTFRAME, "CDocObjectHost::_ReleaseOleObject called %x (%x)", _pole, this);

    // Minimize impact by cleaning up in affected cases only.
    if (fIfInited == FALSE && _fPendingWasInited == FALSE)
        return;

    // release _pole object and all the associated QI'ed pointers
    if (_phls) {
        _phls->SetBrowseContext(NULL); // probably no need
        ATOMICRELEASE(_phls);
    }

    if (_pvo) {
        IAdviseSink *pSink;
        // paranoia: only blow away the advise sink if it is still us
        if (SUCCEEDED(_pvo->GetAdvise(NULL, NULL, &pSink)) && pSink) {
            if (pSink == (IAdviseSink *)this) {
                _pvo->SetAdvise(0, 0, NULL);
            } else {
                ASSERT(0);  // do we really hit this case?
            }

            pSink->Release();
        }
        ATOMICRELEASE(_pvo);
    }

    if (_pole)
    {
        LPOLECLIENTSITE pcs;
        if (SUCCEEDED(_pole->GetClientSite(&pcs)) && pcs)
        {
            if (IsSameObject(pcs, SAFECAST(this, LPOLECLIENTSITE)))
            {
                _pole->SetClientSite(NULL);
            }
            pcs->Release();
        }

        // Notes: Make it sure that we don't hold a bogus _pole even
        //  for a moment (while we call Release).
        ATOMICRELEASE(_pole);
    }
}


//
// This member releases all the interfaces to the DocObject, which is
// essentially the reverse of _Bind.
//
void CDocObjectHost::_UnBind(void)
{
    ATOMICRELEASE(_pHTMLWindow);
    ATOMICRELEASE(_pmsot);

    VariantClear(&_varUserEnteredUrl);
    
    ASSERT(!_pmsov); // paranoia
    ATOMICRELEASE(_pmsov);

    ASSERT(!_pmsoc); // paranoia
    ATOMICRELEASE(_pmsoc);

    _xao.SetActiveObject(NULL);

    if (_pole)
    {

        // Just in case we're destroyed while we were waiting
        // for the docobj to display itself.
        //
        _RemoveTransitionCapability();

        //
        //  If this is NOT MSHTML, cache the OLE server so that we don't
        // need to restart or load the OLE server again.
        //
        if (!(_dwAppHack & (BROWSERFLAG_MSHTML | BROWSERFLAG_DONTCACHESERVER)))
        {
            IBrowserService *pbs;
            if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IBrowserService, (void **)&pbs)))
            {
                pbs->CacheOLEServer(_pole);
                pbs->Release();
            }
        }

        TraceMsg(DM_ADVISE, "CDocObjectHost::_UnBind about to call Close of %x", _pole);
        _pole->Close(OLECLOSE_NOSAVE);

        _ReleaseOleObject();
    }

    _ReleasePendingObject();

    ATOMICRELEASE(_pstg);
    ATOMICRELEASE(_pbcCur);
    ATOMICRELEASE(_pmkCur);
}

//
// HACK: If we open Excel95 objects directly, Excel goes crazy and eventually
//  hit GPF. Here is the background info, I've got Office guys (SatoNa).
//
// From:        Rajeev Misra (Xenix)
//
//   1) Excel does not handle the foll. case very well. Taking a normal file
//   loading it through IPersistFile:Load and then bringing it up as an
//   embedded object. The code was always tested so that the embedded
//   objects always got loaded through ScPrsLoad. I am seeing a bunch of
//   asserts in Excel that say that this assumption is being destroyed.
//   ASSERT(_pole);
//
// From:        Srini Koppolu
//
//   For you, there is only one case, i.e. you always deal with the files. Then your code should look like this
//
//     CreateFileMoniker from the file
//     pUIActiveObject->OnFrameWindowActivate(FALSE);
//     pmk->BindToObject(IID_IDataObject, &pdobj)
//     pUIActiveObject->OnFrameWindowActivate(TRUE);
//     OleCreateFromData()
//
//   OnFrameWindowActivate is done to take care of another excel problem.
//   If you currently have and Excel object UIActive in you and you try to
//   do IPersistFile::Load on Excel, then it will cause problems.
//

void CDocObjectHost::_AppHackForExcel95(void)
{
    ASSERT(_pole);

    HRESULT hres;
    IDataObject* pdt = NULL;
    hres = _pole->QueryInterface(IID_IDataObject, (void **)&pdt);
    TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack -- QI(IOleDataObject) returned %x", hres);

    if (SUCCEEDED(hres))
    {
        ASSERT(_pstg==NULL);
        hres = StgCreateDocfile(NULL,
                STGM_DIRECT | STGM_CREATE | STGM_READWRITE
                | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
                0, &_pstg);
        TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack StgCreateDocFile(NULL) returned %x", hres);
        if (SUCCEEDED(hres))
        {
            IOleObject* poleCopy = NULL;
            hres = OleCreateFromData(pdt, IID_IOleObject, OLERENDER_NONE,
                                     NULL, this, _pstg, (void **)&poleCopy);
            TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack OleCreateFromData(IOleObject) returned %x", hres);

            if (SUCCEEDED(hres)) {
                _fCantSaveBack = TRUE;
                ATOMICRELEASE(_pole);
                _pole = poleCopy;
            }
        }

        pdt->Release();
    }
}

//
//  This function get the UserClassID from the object and opens the regkey
// for that CLSID and returns. If pdwAppHack is non-NULL AND CLSID is
// CLSID_HTMLDocument, we skip all and returns the default apphack flag.
// This is a perf optimization, but prevents us from setting browser
// flags for Trident, which is fine. (SatoNa)
//
HKEY _GetUserCLSIDKey(IOleObject* pole, const CLSID* pclsid, DWORD* pdwAppHack)
{
    HKEY hkey = NULL;   // assume error
    HRESULT hres;
    CLSID clsid = CLSID_NULL;
    if (pole) 
    {
        hres = pole->GetUserClassID(&clsid);
        //  GetUserClassID is optional, can return E_FAIL, then is defined to be
        //  the same as that returned by IPersist::GetClassID. cf, msdev documentation
        //  for GetUserClassID
        if (FAILED(hres))
        {
            hres = IUnknown_GetClassID(pole, &clsid);
        }
    }
    else if (pclsid)
    {
        clsid = *pclsid;
        hres = S_OK;
    }
    else
    {
        return NULL;
    }

    //
    // Notice that we check for two CLSIDs to see if this is MSHTML.
    //
    if (pdwAppHack)
    {
        static const IID IID_IVBOleObj =
            {0xb88c9640, 0x14e0, 0x11d0, { 0xb3, 0x49, 0x0, 0xa0, 0xc9, 0xa, 0xea, 0x82 } };
        IUnknown *   pVBOleObj;

        if (    IsEqualGUID(clsid, CLSID_HTMLDocument)
             || IsEqualGUID(clsid, CLSID_MHTMLDocument)
             || IsEqualGUID(clsid, CLSID_HTMLPluginDocument) )
        {
            TraceMsg(TF_SHDAPPHACK, "_GetUserCLSID this is Trident. Skip opening reg key");
            *pdwAppHack = BROWSERFLAG_NEVERERASEBKGND | BROWSERFLAG_SUPPORTTOP
                            | BROWSERFLAG_MSHTML;
            return NULL;
        }
        else if (pole && SUCCEEDED(pole->QueryInterface(IID_IVBOleObj, (void**)&pVBOleObj) ))
        {
            // If the object answers to IID_IVBOleObj, it's a VB doc object and shouldn't be cached.
            //
            pVBOleObj->Release();
            *pdwAppHack = BROWSERFLAG_DONTCACHESERVER;
        }

    }

    //
    // HACK: MSHTML.DLL does not implement GetUserClassID, but
    //  returns S_OK. That's why we need to check for CLSID_NULL.
    //
    if (SUCCEEDED(hres) && !IsEqualGUID(clsid, CLSID_NULL)) {
        TCHAR szBuf[50];        // 50 is enough for GUID
        SHStringFromGUID(clsid, szBuf, ARRAYSIZE(szBuf));

        TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack GetUserClassID = %s", szBuf);
        TCHAR szKey[60];    // 60 is enough for CLSID\\{CLSID_XX}
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s"), szBuf);

        if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hkey)!=ERROR_SUCCESS)
        {
            TraceMsg(DM_WARNING, "_GetUserCLSIDKey RegOpenKey(%s) failed", szKey);
            // I don't trust RegOpenKey.
            hkey = NULL;
        }
    }
    return hkey;
}


BOOL _GetAppHackKey(LPCTSTR pszProgID, DWORD* pdwData)
{
    BOOL fSuccess = FALSE;
    HKEY hkey;
    if (RegOpenKey(HKEY_CLASSES_ROOT, pszProgID, &hkey)==ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cbSize = SIZEOF(*pdwData);
        if (RegQueryValueEx(hkey, TEXT("BrowserFlags"), NULL,
            &dwType, (LPBYTE)pdwData, &cbSize)==ERROR_SUCCESS
            && (dwType==REG_DWORD || (dwType==REG_BINARY && cbSize==SIZEOF(*pdwData))))
        {
            fSuccess = TRUE;
        }
        else
        {
            //
            // Unlike IE3, we make it absolutely sure that the type of object
            // has either "DocObject" key or "BrowseInPlace" key under the
            // ProgID. We can't rely on QI(IID_IOleDocument) because MFC 4.2
            // has a bug and returns S_OK to it. As far as I know, MS-Paint
            // and OmniPage pro are affected by this. We could individually
            // address each of them, but it's probably impossible to catch
            // all. This change has a small risk of breaking existing DocObject
            // server which does not have neither key. If we find such a
            // server, we'll address those individually (which is much easier
            // than covering all MFC apps). (SatoNa)
            //
            TCHAR ach[MAX_PATH];
            LONG cb;
            BOOL fBrowsable = FALSE;
            if ((cb=SIZEOF(ach)) && RegQueryValue(hkey, TEXT("DocObject"), ach, &cb) == ERROR_SUCCESS)
                fBrowsable = TRUE;
            else if ((cb=SIZEOF(ach)) && RegQueryValue(hkey, TEXT("BrowseInPlace"), ach, &cb) == ERROR_SUCCESS)
                fBrowsable = TRUE;

            if (!fBrowsable) {
                TraceMsg(DM_WARNING, "_GetAppHackKey this is neither DocObject or BrowseInPlace");
                *pdwData = BROWSERFLAG_DONTINPLACE;
            }
        }
        RegCloseKey(hkey);
    }
    return fSuccess;
}


void GetAppHackFlags(IOleObject* pole, const CLSID* pclsid, DWORD* pdwAppHack)
{
    HKEY hkey = _GetUserCLSIDKey(pole, pclsid, pdwAppHack);
    if (hkey)
    {
        TCHAR szValue[MAX_PATH];
        LONG cb = SIZEOF(szValue);
        if (RegQueryValue(hkey, TEXT("ProgID"), szValue, &cb) == ERROR_SUCCESS)
        {
            //
            // First, check if we have an BrowserFlags flag in the registry.
            // If there is, use it. Otherwise, try hard-coded progIDs as
            // we did in IE 3.0
            //
            _GetAppHackKey(szValue, pdwAppHack);
            if (!(*pdwAppHack & BROWSERFLAG_REPLACE)) {
                typedef struct _APPHACK {
                    LPCTSTR pszProgID;
                    DWORD   dwAppHack;
                } APPHACK;

                //
                // We no longer need to disable in-place activation of
                // MS-PAINT because we look for "BrowseInPlace" or
                // "DocObject" key
                //
                // { "Paint.Picture", BROWSERFLAG_DONTINPLACE },
                //
                const static APPHACK s_aah[] = {
                    { TEXT("Excel.Sheet.5"), BROWSERFLAG_OPENCOPY },
                    { TEXT("Excel.Chart.5"), BROWSERFLAG_OPENCOPY },
                    { TEXT("SoundRec"), BROWSERFLAG_OPENVERB },
                    { TEXT("Word.Document.6"), BROWSERFLAG_SETHOSTNAME },
                    { TEXT("Word.Document.8"), BROWSERFLAG_DONTUIDEACTIVATE | BROWSERFLAG_SETHOSTNAME },
                    { TEXT("PowerPoint.Show.8"), BROWSERFLAG_DONTUIDEACTIVATE | BROWSERFLAG_PRINTPROMPTUI },
                    { TEXT("Excel.Sheet.8"), BROWSERFLAG_DONTDEACTIVATEMSOVIEW | BROWSERFLAG_INITNEWTOKEEP },
                    { TEXT("Excel.Chart.8"), BROWSERFLAG_DONTDEACTIVATEMSOVIEW | BROWSERFLAG_INITNEWTOKEEP },
                    { TEXT("ABCFlowCharter6.Document"), BROWSERFLAG_DONTINPLACE },
                    { TEXT("ABCFlowCharter7.Document"), BROWSERFLAG_DONTINPLACE },
                    { TEXT("FlowCharter7.Document"), BROWSERFLAG_DONTINPLACE },
                    { TEXT("ChannelFile"), BROWSERFLAG_DONTAUTOCLOSE },
                    { TEXT("Visio.Drawing.5"), BROWSERFLAG_ENABLETOOLSBTN | BROWSERFLAG_SAVEASWHENCLOSING },
                    { TEXT("Visio.Drawing.4"), BROWSERFLAG_ENABLETOOLSBTN | BROWSERFLAG_SAVEASWHENCLOSING }
                };
                const static TCHAR s_ActiveMoveCtx[] = TEXT("AMOVIE.ActiveMovieControl");

                if (!StrCmpN(szValue, s_ActiveMoveCtx, ARRAYSIZE(s_ActiveMoveCtx)-1))
                {
                    *pdwAppHack = BROWSERFLAG_DONTAUTOCLOSE;
                }
                else
                {
                    for (int i=0; i<ARRAYSIZE(s_aah); i++) {
                        if (StrCmp(szValue, s_aah[i].pszProgID)==0)
                        {
                            *pdwAppHack |= s_aah[i].dwAppHack;
                            break;
                        }
                    }
                }
            }

            TraceMsg(DM_BINDAPPHACK, "_GetAppHack ProgID=%s, *pdwAppHack=%x",
                     szValue, *pdwAppHack);

        } else {
            TraceMsg(DM_BINDAPPHACK, "_GetAppHack RegQueryValue(ProgID) failed");
        }

        RegCloseKey(hkey);
    }
}

DWORD CDocObjectHost::_GetAppHack(void)
{
    ASSERT(_pole);
    if (!_fHaveAppHack && _pole)
    {
        _dwAppHack = 0;     // Assume no hack
        _fHaveAppHack = TRUE;
        ::GetAppHackFlags(_pole, NULL, &_dwAppHack);
    }
    return _pole ? _dwAppHack : 0;
}

void CDocObjectHost::_PostBindAppHack(void)
{
    _GetAppHack();

    if (_fAppHackForExcel()) {
        _AppHackForExcel95();
    }
}


//
// This member binds to the object specified by a moniker.
//
HRESULT CDocObjectHost::_BindSync(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev)
{
    ASSERT(pbc || !_pole);

    HRESULT hres = S_OK;
    ASSERT(_pole==NULL);

    // Check if we are in the middle of asynchronous binding
    if (_bsc._fBinding)
    {
        // Yes, wait until it's done or canceled/stopped
        URLMSG(TEXT("_Bind called in the middle of async-binding. Wait in a message loop"));
        while(_bsc._fBinding)
        {
           MSG msg;
           if (GetMessage(&msg, NULL, 0, 0))
           {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
           }
        }

        if (!_pole)
        {
            hres = E_FAIL;      // Get the error code from OnStopBinding
        }
    }
    else
    {
        // No, bind synchronously
        URLMSG(TEXT("_Bind. Performing syncronous binding"));
        hres = pmk->BindToObject(pbc, NULL, IID_IOleObject, (void **)&_pole);
    }

    TraceMsg(0, "sdv TR : _Bind -- pmk->BindToObject(IOleObject) returned %x", hres);

    _OnBound(hres);

    return hres;
}

void CDocObjectHost::_OnBound(HRESULT hres)
{
    if (SUCCEEDED(hres)) {
        _PostBindAppHack();
        _InitOleObject();
    }
}

//
//  This function returns TRUE if the specified file's open command is
// associated with "explorer.exe" or "iexplore.exe".
//
// NOTES: It does not check if the "open" command is actually the default
//  or not, but that's sufficient in 99.99 cases.
//
BOOL IsAssociatedWithIE(LPCWSTR szPath)
{
    LPCTSTR pszExtension = PathFindExtension(szPath);

    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_PATH];
    TCHAR szExt[_MAX_EXT];
    DWORD cchBuf = ARRAYSIZE(szBuf);

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, szExt, TEXT("open"), szBuf, &cchBuf)))
    {
        TraceMsg(TF_SHDBINDING, "IsAssociatedWithIE(%s) found %s as open command", szPath, szBuf);
        LPCTSTR pszFound;
        if ( (pszFound=StrStrI(szBuf, IEXPLORE_EXE))
             || (pszFound=StrStrI(szBuf, EXPLORER_EXE)) )
        {
            if (pszFound==szBuf || *(pszFound - 1)==TEXT('\\'))
            {
                bRet = TRUE;
            }
        }
    }
    TraceMsg(DM_SELFASC, "IsAssociatedWithIE(%s) returning %d", szPath, bRet);

    return bRet;
}


HRESULT CDocObjectHost::_MayHaveVirus(REFCLSID rclsid)
{
    //
    // We'll call this function twice if the file is associated
    // with a bogus CLSID (such as ImageComposer).
    //
    if (_fConfirmed)
    {
        TraceMsg(TF_SHDAPPHACK, "CDOH::_MayHaveVirus called twice. Return S_OK");
        return S_OK;
    }

    TraceMsg(TF_SHDPROGRESS, "DOH::_MayHaveVirus called");

    LPWSTR pwzProgID = NULL;
    HRESULT hresT = E_FAIL;

    if (SUCCEEDED(ProgIDFromCLSID(rclsid, &pwzProgID)))
    {
        if (   StrCmpI(pwzProgID, TEXT("htmlfile")) != 0
            && StrCmpI(pwzProgID, TEXT("htmlfile_FullWindowEmbed")) != 0
            && StrCmpI(pwzProgID, TEXT("mhtmlfile")) != 0
            && StrCmpI(pwzProgID, TEXT("xmlfile")) != 0
            && StrCmpI(pwzProgID, TEXT("xslfile")) != 0)
        {
            TCHAR   szURL[MAX_URL_STRING];
            TCHAR * pszURL = szURL;

            hresT = _GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);

            if (SUCCEEDED(hresT))
            {
                UINT uRet = IDOK;

                if (_PicsProcBase._fbPicsWaitFlags || !_PicsProcBase._fPicsAccessAllowed)
                {
                    _PicsProcBase._fbPicsWaitFlags &= ~(PICS_WAIT_FOR_INDOC | PICS_WAIT_FOR_END);   /* indoc ratings only on htmlfile */
                    TraceMsg(DM_PICS, "CDOH::_MayHaveVirus found non-HTML, waitflags now %x", (DWORD)_PicsProcBase._fbPicsWaitFlags);
                    uRet = _PicsProcBase._PicsBlockingDialog();
                }
                
                if (uRet == IDOK)
                {
                    TraceMsg(TF_SHDPROGRESS, "DOH::_MayHaveVirus calling MayOpenSafeDialogOpenDialog(%s)", pwzProgID);

                    if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
                        pszURL = _bsc._pszRedirectedURL;

                    IUnknown * punk;
                    BOOL  fDisableOpen = TRUE;
                    LPCTSTR pszExt = NULL;

                    if (_bsc._pszCacheFileName)
                        pszExt = PathFindExtension(_bsc._pszCacheFileName);
                    else if (pszURL)
                        pszExt = PathFindExtension(pszURL);

                    if (pszExt)
                    {
                        TCHAR szClassName[MAX_PATH];
                        DWORD cbSize = SIZEOF(szClassName);

                        // if the ProgIDs don't match then disable the open button
                        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szClassName, &cbSize))
                            fDisableOpen = StrCmpI(pwzProgID, szClassName);
                    }

                    QueryInterface(IID_IUnknown, (void**)&punk);

                    uRet = MayOpenSafeOpenDialog(_hwnd, pwzProgID, pszURL, _bsc._pszCacheFileName, NULL, _uiCP, punk, _pmsoctBrowser, fDisableOpen);

                    ATOMICRELEASE(punk);

                    _fCalledMayOpenSafeDlg = TRUE;
                }

                switch(uRet)
                {
                case IDIGNORE:
                    //
                    // allow the safeopen dlg to pop up later if necessary
                    //
                    _fCalledMayOpenSafeDlg = FALSE;
                    _fConfirmed = FALSE;
                    break;  // continue download

                case IDOK:
                    //
                    // Set this flag to avoid poppping this dialog box twice.
                    //
                    _fConfirmed = TRUE;
                    break;  // continue download

                case IDD_SAVEAS:
                    IUnknown *punk;
                    hresT = QueryInterface(IID_IUnknown, (void**)&punk);

                    if(SUCCEEDED(hresT))
                    {
                        CDownLoad_OpenUI(_pmkCur, _bsc._pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _bsc._pszRedirectedURL, _uiCP, punk);
                        punk->Release();
                    }
                    // fall through to abort binding.

                case IDCANCEL:
                    hresT = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
            }
            else
            {
                TraceMsg(DM_ERROR, "DOH::_MayHaveVirus _GetCurrentPage failed %x", hresT);
            }
        }
        else
        {
            TraceMsg(TF_SHDPROGRESS, "DOH::_MayHaveVirus this is htmlfile -- don't call MayOpenSafeDialogOpenDialog");
            _fPicsBlockLate = TRUE;
        }

        OleFree(pwzProgID);
    }

    return hresT;
}

STDMETHODIMP CDocObjectHost::SaveObject(void)
{
    TraceMsg(0, "sdv TR: CDOV::SaveObject called");
    // Implemente it later.
    return S_OK;
}

STDMETHODIMP CDocObjectHost::GetMoniker(DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    HRESULT hres = E_INVALIDARG;
    *ppmk = NULL;
    TraceMsg(TF_SHDBINDING, "CDOH::GetMoniker called dwWhichMoniker=%x", dwWhichMoniker);

    switch(dwWhichMoniker)
    {
    case OLEWHICHMK_OBJREL:
    case OLEWHICHMK_OBJFULL:
        if (_pmkCur)
        {
            *ppmk = _pmkCur;
            _pmkCur->AddRef();
            hres = S_OK;
        }
        else
        {
            hres = E_UNEXPECTED;
        }
        break;
    }

    return hres;
}

STDMETHODIMP CDocObjectHost::GetContainer(
    IOleContainer **ppContainer)
{
    //  According to CKindel, we should implement this method
    //  as the way for a DocObject to access IDispatch interface of
    //  the container (i.e., frame). I'm currently thinking leaving
    //  all it's non-IUnknown memeber unimplemented. If there is no
    //  need to enumerates objects, we can simply QI from IShellBrowser
    //  to IOleContainer and return it. (SatoNa)
    //
    // NOTE: If trident calls this after DestroyHostWindow, we have nothing
    //  to give out. Hopefully this is not bad. (MikeSh)

    TraceMsg(0, "sdv TR: CDOV::GetContainer called");
    if (_psb)
        return _psb->QueryInterface(IID_IOleContainer, (void **)ppContainer);
    return E_FAIL;
}

STDMETHODIMP CDocObjectHost::ShowObject(void)
{
    TraceMsg(0, "sdv TR: CDOV::ShowObject called");
    return E_NOTIMPL;   // As specified in Kraig's document
}

STDMETHODIMP CDocObjectHost::OnShowWindow(BOOL fShow)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::OnShowWindow(%d) called (this=%x)", fShow, this);
    return E_NOTIMPL;   // As specified in Kraig's document
}

STDMETHODIMP CDocObjectHost::RequestNewObjectLayout(void)
{
    TraceMsg(0, "sdv TR: CDOV::RequestNewObjectLayout called");
    return E_NOTIMPL;   // As specified in Kraig's document
}



//
//  This is the standard way for non-active embedding to access
// the IHlinkFrame interface. We happened to use our QI to implement
// this, but the semantics of QueryService is different from QI.
// It does not necessary return the same object.
//
HRESULT CDocObjectHost::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if( IsEqualGUID(guidService, IID_IElementNamespaceTable) )
    {
        return IUnknown_QueryService(_pole, IID_IElementNamespaceTable, riid, ppvObj);
    }
    // In order for the context menu to work correctly inside IFrames, we
    // need to fail a certain query ONLY for IFrames on desktop.
    else if (!IsEqualGUID(guidService, CLSID_HTMLDocument) || !_IsImmediateParentDesktop(this, _psp))
    {
        //
        //  Delegate ISP to the _psb.
        //
        if (_psb && _psp)
            return _psp->QueryService(guidService, riid, ppvObj);
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

/*----------------------------------------------------------
Purpose: Remove the submenu(s) that are in _hmenuFrame
         from _hmenuBrowser.

*/
void CDocObjectHost::_RemoveFrameSubMenus(void)
{
    HMENU hmenu;

    ASSERT(IS_VALID_HANDLE(_hmenuBrowser, MENU));
    ASSERT(IS_VALID_HANDLE(_hmenuFrame, MENU));

    // The file menu in _hmenuBrowser consists of the file menu from
    // _hmenuFrame and IShellBrowser.  The part added by _hmenuFrame
    // includes a submenu (Send To), which must be removed before
    // _hmenuBrowser is destroyed.

    // We could just explicitly remove the Send To submenu.  But to
    // prevent the expensive bug hunt that it took to find this in the
    // first place, we're going to iterate thru the menu and, for
    // any submenus that belong to our template, we'll remove them.

    int citemFile = 0;
    UINT nID = 0;

    // Get the count of menu items in our template's File menu and
    // the ID of the first menu item.
    hmenu = GetMenuFromID(_hmenuFrame, FCIDM_MENU_FILE);
    if (hmenu)
    {
        citemFile = GetMenuItemCount(hmenu);
        nID = GetMenuItemID(hmenu, 0);
    }

    // Now look at the browser menu's File menu and, starting at
    // nID, remove any submenus.
    hmenu = GetMenuFromID(_hmenuBrowser, FCIDM_MENU_FILE);
    if (hmenu)
    {
        int citem = GetMenuItemCount(hmenu);
        int iTop;
        int i;

        // Where does our template file menu start?
        for (iTop = 0; iTop < citem; iTop++)
        {
            if (GetMenuItemID(hmenu, iTop) == nID)
            {
                // Start at where our template file menu ends and work up
                for (i = iTop + citemFile - 1; 0 < citemFile ; i--, citemFile--)
                {
                    HMENU hmenuSub = GetSubMenu(hmenu, i);

                    if (hmenuSub)
                        RemoveMenu(hmenu, i, MF_BYPOSITION);
                }
                break;
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Destroy the browser menu.

*/
HRESULT CDocObjectHost::_DestroyBrowserMenu(void)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::_DestroyBrowserMenu called");

    if (_hmenuBrowser) {
        // First remove any submenus that are held by other menus,
        // so we don't blow them away.

        _RemoveFrameSubMenus();

        if (EVAL(_psb)) {
            _psb->RemoveMenusSB(_hmenuBrowser);
        }

        DestroyMenu(_hmenuBrowser);
        _hmenuBrowser = NULL;
    }
    return S_OK;
}


HRESULT CDocObjectHost::_CreateBrowserMenu(LPOLEMENUGROUPWIDTHS pmw)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::_CreateBrowserMenu called");

    if (_hmenuBrowser) {
        return S_OK;
    }

    _hmenuBrowser = CreateMenu();
    if (!_hmenuBrowser) {
        return E_OUTOFMEMORY;
    }

    HRESULT hres = E_FAIL;

    // Allow IShellBrowser a chance to add its menus
    if (EVAL(_psb))
        hres = _psb->InsertMenusSB(_hmenuBrowser, pmw);

    // HACK: Win95 explorer returns E_NOTIMPL
    if (hres==E_NOTIMPL) {
        hres = S_OK;
    }

    if (SUCCEEDED(hres)) {
        // Load our menu if not loaded yet
        if (!_hmenuFrame)
        {
            _hmenuFrame = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MID_FOCUS));
        }

        // Get the "File" sub-menu from the shell browser.
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_SUBMENU;

        if (GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_FILE, FALSE, &mii))
        {
            HMENU hmenuFileBrowse = mii.hSubMenu;

            // Merge our menuitems into this submenu.
            if (_hmenuFrame)
            {
                MENUITEMINFO miiItem;
                miiItem.cbSize = SIZEOF(MENUITEMINFO);
                miiItem.fMask = MIIM_SUBMENU;

                if (GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_FILE, FALSE, &miiItem))
                {
                    TCHAR szItem[128];
                    HMENU hmenuFileT = miiItem.hSubMenu;
                    UINT citem = GetMenuItemCount(hmenuFileT);
                    for (int i=citem-1; i>=0 ; i--)
                    {
                        // We need to reset for each item.
                        miiItem.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;
                        miiItem.fType = MFT_STRING;
                        miiItem.cch = ARRAYSIZE(szItem);
                        miiItem.dwTypeData = szItem;
                        miiItem.dwItemData = 0;
                        if (GetMenuItemInfo(hmenuFileT, i, TRUE, &miiItem)) {
                            InsertMenuItem(hmenuFileBrowse, 0, TRUE, &miiItem);
                        }
                    }
                }
            }
        }
        else
        {
            TraceMsg(TF_SHDUIACTIVATE, "DOH::_CreateBrowseMenu parent has no File menu (it's probably a browser OC)");
            ASSERT(0); // DocObject in OC is not supposed to call InsertMenus.
        }
    }

    DEBUG_CODE( _DumpMenus(TEXT("after _CreateBrowserMenu"), TRUE); )

    return hres;
}

//
// IOleInPlaceFrame::InsertMenus equivalent
//
HRESULT CDocObjectHost::_InsertMenus(
    /* [in] */ HMENU hmenuShared,
    /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    HRESULT hres = S_OK;
    int nMenuOffset = 0;
    TraceMsg(TF_SHDUIACTIVATE, "DOH::InsertMenus called (this=%x)", this);

    // Assume error (no menu merge)
    lpMenuWidths->width[0] = 0;
    lpMenuWidths->width[2] = 0;
    lpMenuWidths->width[4] = 0;
    lpMenuWidths->width[5] = 0;

    // be extra safe and don't attempt menu merging if we're not top level
    if (_fHaveParentSite)
        return S_OK;

    OLEMENUGROUPWIDTHS mw = { {0} };
    hres = _CreateBrowserMenu(&mw);
    if (FAILED(hres)) {
        TraceMsg(DM_ERROR, "DOH::InsertMenus _CreateBrpwserMenu failed");
        return hres;
    }

    // Get the "File" sub-menu from the shell browser.
    MENUITEMINFO mii;
    TCHAR szSubMenu[128];

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
    mii.cch = ARRAYSIZE(szSubMenu);
    mii.dwTypeData = szSubMenu;

    if (EVAL(GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_FILE, FALSE, &mii)))
    {
        ASSERT(szSubMenu == mii.dwTypeData);
        InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
        lpMenuWidths->width[0] = 1;
    }

    // Note that we need to re-initialize mii
    mii.cch = ARRAYSIZE(szSubMenu);

    if (EVAL(GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_EXPLORE, FALSE, &mii)))
    {
        // GetMenuItemInfo is recursive (why?).  The item it retrieves 
        // for FCIDM_MENU_EXPLORE can either be the top level Go menu, or if that
        // does not exist (NT5 case), it returns the Go To submenu of View.  
        // 
        // Code has been added in in the SetMenu implementations of Shell Browser 
        // and Dochost to detect the second case, because the menu dispatch list
        // does not recognize this kind of menu merging (80734).

        DeleteMenu(mii.hSubMenu, FCIDM_PREVIOUSFOLDER, MF_BYCOMMAND);
        InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
        lpMenuWidths->width[4]++;
    }

    mii.cch = ARRAYSIZE(szSubMenu);

    if (EVAL(GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_FAVORITES, FALSE, &mii)))
    {
        InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
        lpMenuWidths->width[4]++;
    }

    if (_hmenuFrame)
    {
        // Micro-merge the help menu.
        mii.cch = ARRAYSIZE(szSubMenu);

        if (EVAL(GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_HELP, FALSE, &mii)))
        {
            InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
            lpMenuWidths->width[5]++;
        }
    }

    DEBUG_CODE( _DumpMenus(TEXT("after InsertMenus"), TRUE); )

    return hres;
}


/*----------------------------------------------------------
Purpose: Different objects may add their own Help menu (like
         Word and Excel).  This function detects if the object
         added its own help menu, or if it added items to our
         help menu, or if it is just using our help menu.

         If they added their own help menu, we remove ours.

*/
void CDocObjectHost::_CompleteHelpMenuMerge(HMENU hmenu)
{
    HMENU hmenuHelp;
    MENUITEMINFO mii;
    TCHAR szSubMenu[80];

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU;

    // see if they added anything to our menu
    if (GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_HELP, FALSE, &mii))
    {
        hmenuHelp = mii.hSubMenu;
        int iMenuCount = GetMenuItemCount(mii.hSubMenu);

        // Did the number of items in the help menu change?
        if (iMenuCount != HELP_ITEM_COUNT) {
            // Yes; that means they added something.  This has been micro-merged.
            _hmenuMergedHelp = mii.hSubMenu;
            _hmenuObjHelp = GetSubMenu(mii.hSubMenu, iMenuCount -1);
            goto Bail;
        }

        // Our menu didn't change.  Now find out if they added their own
        // help menu or if we ARE the help.  If they added their own, we need
        // to remove our help menu.

        _hmenuMergedHelp = NULL;
        _hmenuObjHelp = NULL;

        int iCount = GetMenuItemCount(hmenu) - 1;
        int i;
        for (i = iCount ; i >= 0 ; i--) {

            mii.fMask = MIIM_SUBMENU|MIIM_TYPE;
            mii.cch = ARRAYSIZE(szSubMenu);
            mii.dwTypeData = szSubMenu;

            if (GetMenuItemInfo(hmenu, i, TRUE, &mii)) {
                if (mii.hSubMenu == hmenuHelp) {

                    BOOL bRemove = FALSE;

                    if (iCount != i) {
                        // if we're not the last one, then we're not it
                        bRemove = TRUE;
                    } else {
                        // if we are the last one see if the help menu was added
                        // right before us
                        TCHAR szMenuTitle[80];
                        mii.cch = ARRAYSIZE(szMenuTitle);
                        mii.dwTypeData = szMenuTitle;
                        if (GetMenuItemInfo(hmenu, i-1, TRUE, &mii)) {
                            if (!StrCmpI(szMenuTitle, szSubMenu)) {
                                // same menu string yank ours
                                bRemove = TRUE;
                            }
                        }
                    }

                    if (bRemove) {
                        RemoveMenu(hmenu, i, MF_BYPOSITION);
                    }
                }
            }
        }
    }

Bail:;
    DEBUG_CODE( _DumpMenus(TEXT("after _CompleteHelpMenuMerge"), TRUE); )
}


//
// IOleInPlaceFrame::SetMenu equivalent
//
HRESULT CDocObjectHost::_SetMenu(
    /* [in] */ HMENU hmenuShared,           OPTIONAL
    /* [in] */ HOLEMENU holemenu,           OPTIONAL
    /* [in] */ HWND hwndActiveObject)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::SetMenus(%x) called (this=%x)",
             hmenuShared, this);

    // be extra safe and don't attempt menu merging if we're not top level
    if (_fHaveParentSite)
        return S_OK;

    // A NULL hmenuShared means to reinstate the container's original menu.
    if (hmenuShared)
    {
        // Clean up duplicate help menus
        _CompleteHelpMenuMerge(hmenuShared);
    }

    // Simply forwarding it to IShellBrowser
    _hmenuSet = hmenuShared;
    HRESULT hres = E_FAIL;
    if (EVAL(_psb))
        hres = _psb->SetMenuSB(hmenuShared, holemenu, hwndActiveObject);

    if (SUCCEEDED(hres))
    {
        // need to tell the shell browser that we want doc obj style menu merging
        if (_pmsoctBrowser)
            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_ACTIVEOBJECTMENUS, 0, NULL, NULL);

        // Compose our list of object/frame menus, so our menuband
        // can dispatch the messages correctly.  Essentially this is
        // the same as the contents of holemenu, but since we don't
        // have access to the internal struct, we must derive this
        // info ourselves.
        _menulist.Set(hmenuShared, _hmenuBrowser);

        if (_hmenuMergedHelp)
            _menulist.RemoveMenu(_hmenuMergedHelp);

        if (_hmenuObjHelp)
            _menulist.AddMenu(_hmenuObjHelp);

        _hmenuCur = hmenuShared;
        HWND hwndFrame;
        _psb->GetWindow(&hwndFrame);

        // 80734: Was the Go To menu taken from the View menu and grafted onto the
        // main menu by DocHost?  The menulist won't detect this graft, so we have
        // to check ourselves and make sure it's not marked as belonging to the 
        // docobject.
        //
        // This test is duplicated in CShellBrowser2::SetMenuSB

        MENUITEMINFO mii;
        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_SUBMENU;

        if (hmenuShared && _hmenuBrowser && 
            GetMenuItemInfo(hmenuShared, FCIDM_MENU_EXPLORE, FALSE, &mii))
        {
            HMENU hmenuGo = mii.hSubMenu;

            if (GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_EXPLORE, FALSE, &mii) &&
                mii.hSubMenu == hmenuGo && _menulist.IsObjectMenu(hmenuGo))
            {
                _menulist.RemoveMenu(hmenuGo);
            }
        }

        // (scotth): why are we calling this, since this isn't compatible
        // with menubands?  That's the whole reason we have _menulist.
        hres = OleSetMenuDescriptor(holemenu, hwndFrame, hwndActiveObject, &_dof, _ActiveObject());
    }

    DEBUG_CODE( _DumpMenus(TEXT("after SetMenu"), TRUE); )

    return hres;
}


void CDocObjectHost::_SetStatusText(LPCSTR pszText)
{
    if (_psb)
    {
        WPARAM wParam = STATUS_PANE_NAVIGATION;

        if (g_bBiDiW95Loc && *pszText)
        {
            char szBuf[256];

            szBuf[0] = szBuf[1] = TEXT('\t');
            StrCpyNA(&szBuf[2], pszText, ARRAYSIZE(szBuf)-2);
            pszText = szBuf;
            wParam = SBT_RTLREADING;
        }

        _psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, wParam | SBT_NOTABPARSING, (LPARAM)pszText, NULL);
        _psb->SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, wParam, (LPARAM)pszText, NULL);
    }
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given menu belongs to the browser
         (as opposed to the object)

*/
BOOL CDocObjectHost::_IsMenuShared(HMENU hmenu)
{
    ASSERT(hmenu);

    // (scotth): can we use _menulist here? (it would be faster)

    if (_hmenuBrowser) {
        for (int i = GetMenuItemCount(_hmenuBrowser) - 1 ; i >= 0; i--) {
            if (GetSubMenu(_hmenuBrowser, i) == hmenu)
                return TRUE;
        }
    }

    // We have to special case the help menu.  It's possible that the
    // help menu in the shared menu actually came from _hmenuFrame
    // (not _hmenuBrowser).  We need to detect this case, otherwise
    // the help menu gets destroyed but it is still referenced in
    // _hmenuFrame.

    MENUITEMINFO mii;

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU;

    ASSERT(IS_VALID_HANDLE(_hmenuFrame, MENU));

    // Is this our help menu from _hmenuFrame?
    if (GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_HELP, FALSE, &mii) &&
        mii.hSubMenu == hmenu)
    {
        // Yes
        return TRUE;
    }

    return FALSE;
}

//
// IOleInPlaceFrame::RemoveMenus equivalent
//
HRESULT CDocObjectHost::_RemoveMenus(/* [in] */ HMENU hmenuShared)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::RemoveMenus called (this=%x)", this);

    // be extra safe and don't attempt menu merging if we're not top level
    if (_fHaveParentSite)
        return S_OK;

    ASSERT(GetMenuItemCount(hmenuShared) != (UINT)-1);

    //
    // It is ok to simply remove sub-menus here.
    // because ours are shared with the _hmenuBrowser
    // and destroying that below will take care of cleanup.
    // However, we need to only remove menus that are ours.
    //
    for (int i = (int)GetMenuItemCount(hmenuShared) - 1 ; i >= 0; i--)
    {
        // TraceMsg(0, "sdv TR - ::RemoveMenus calling RemoveMenu(0)");
        HMENU hmenu = GetSubMenu(hmenuShared, i);

        if (hmenu && _IsMenuShared(hmenu)) {
            RemoveMenu(hmenuShared, i, MF_BYPOSITION);
        }
    }

    // TraceMsg(0, "sdv TR - ::RemoveMenus exiting");
    return S_OK;
}

//
// IOleInPlaceFrame::SetStatusText equivalent
//
HRESULT CDocObjectHost::_SetStatusText(/* [in] */ LPCOLESTR pszStatusText)
{
    LPCOLESTR pszForward;

    if (_psb != NULL)
    {
        // if it's NULL or just "" then give precedence to
        // _strPriorityStatusText, otherwise we display
        // whatever we're given

        if (pszStatusText != NULL && pszStatusText[0] != TEXT('\0') ||
            _strPriorityStatusText == NULL)
        {
            pszForward = pszStatusText;
        }
        else
        {
            pszForward = _strPriorityStatusText;
        }

        _psb->SetStatusTextSB(pszForward);
    }

    // Always return S_OK or scripting will put up an error dialog.
    return S_OK;
}

void CDocObjectHost::_SetPriorityStatusText(LPCOLESTR pszPriorityStatusText)
{
    // if they gave us a new string, replace the old one,
    // otherwise just NULL out the old one

    if (_strPriorityStatusText != NULL)
    {
        SysFreeString(_strPriorityStatusText);
    }

    if (pszPriorityStatusText != NULL)
    {
        _strPriorityStatusText = SysAllocString(pszPriorityStatusText);
    }
    else
    {
        _strPriorityStatusText = NULL;
    }

    _SetStatusText(_strPriorityStatusText);
}

HRESULT CDocObjectHost::_EnableModeless(/* [in] */ BOOL fEnable)
{
    TraceMsg(0, "sdv TR - ::EnableModeless called");

    // Note that we used call _CancelPendingNavigation here.
    // We do it in CBaseBrowser:::EnableModelesSB intead. (Satona)

    // Simply forwarding it (which is not implemented)
    if (EVAL(_psb))
        return _psb->EnableModelessSB(fEnable);

    return E_FAIL;
}

HRESULT CDocObjectHost::TranslateHostAccelerators(LPMSG lpmsg)
{
    if (_hacc && ::TranslateAccelerator(_hwnd, _hacc, lpmsg)) {
        return S_OK;
    }
    return S_FALSE;
}

// IOleInPlaceFrame equivalent ::TranslateAccelerator
//  Forwarding it from DocObject -> Browser
HRESULT CDocObjectHost::_TranslateAccelerator(
    /* [in] */ LPMSG lpmsg,
    /* [in] */ WORD wID)
{
    // TranslateAccelerator goes to the guy with the focus first
    if (EVAL(_psb))
        if (S_OK == _psb->TranslateAcceleratorSB(lpmsg, wID))
            return S_OK;

#ifdef DEBUG
    if (lpmsg->message == WM_KEYDOWN) {
        TraceMsg(0, "CDocObjectHost::TrAcc(UP) called");
    }
#endif
    return TranslateHostAccelerators(lpmsg);
}

// IViewObject
HRESULT CDocObjectHost::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
    DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
    const RECTL *lprcBounds, const RECTL *lprcWBounds,
    BOOL (*pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    if (_pvo && lprcBounds)
    {
        if (_uState == SVUIA_DEACTIVATE && _hwnd)
        {
            HRESULT hresT = S_OK;
            RECT rcClient;
            GetClientRect(_hwnd, &rcClient);

            //
            // We should not call SetExtent with an empty rectangle.
            // It happens when we print a page with a floating frame.
            //
            if (rcClient.right > 0 && rcClient.bottom > 0)
            {
                SIZEL sizel;
                sizel.cx = MulDiv( rcClient.right, 2540, GetDeviceCaps( hdcDraw, LOGPIXELSX ) );
                sizel.cy = MulDiv( rcClient.bottom, 2540, GetDeviceCaps( hdcDraw, LOGPIXELSY ) );
                hresT = _pole->SetExtent(DVASPECT_CONTENT, &sizel);
            }

#ifdef DEBUG
            MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->top, NULL);
            LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom);
            LineTo(hdcDraw, lprcBounds->left, lprcBounds->bottom);
            LineTo(hdcDraw, lprcBounds->right, lprcBounds->top);
#endif

            if (hresT!=S_OK) {
                TraceMsg(DM_ERROR, "CDOH::Draw SetExtent returns non S_OK %x", hresT);
            }
        }
        return _pvo->Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev,
            hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
    }

    return OLE_E_BLANK;
}

HRESULT CDocObjectHost::GetColorSet(DWORD dwAspect, LONG lindex,
    void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    if (_pvo)
    {
        return _pvo->GetColorSet(dwAspect, lindex, pvAspect, ptd, hicTargetDev,
            ppColorSet);
    }

    if (ppColorSet)
        *ppColorSet = NULL;

    return S_FALSE;
}

HRESULT CDocObjectHost::Freeze(DWORD, LONG, void *, DWORD *pdwFreeze)
{
    if (pdwFreeze)
        *pdwFreeze = 0;

    return E_NOTIMPL;
}

HRESULT CDocObjectHost::Unfreeze(DWORD)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectHost::SetAdvise(DWORD dwAspect, DWORD advf,
    IAdviseSink *pSink)
{
    if (dwAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    if (advf & ~(ADVF_PRIMEFIRST | ADVF_ONLYONCE))
        return E_INVALIDARG;

    if (pSink != _padvise)
    {
        ATOMICRELEASE(_padvise);

        _padvise = pSink;

        if (_padvise)
            _padvise->AddRef();
    }

    if (_padvise)
    {
        _advise_aspect = dwAspect;
        _advise_advf = advf;

        if (advf & ADVF_PRIMEFIRST)
            OnViewChange(_advise_aspect, -1);
    }
    else
        _advise_aspect = _advise_advf = 0;

    return S_OK;
}

HRESULT CDocObjectHost::GetAdvise(DWORD *pdwAspect, DWORD *padvf,
    IAdviseSink **ppSink)
{
    if (pdwAspect)
        *pdwAspect = _advise_aspect;

    if (padvf)
        *padvf = _advise_advf;

    if (ppSink)
    {
        if (_padvise)
            _padvise->AddRef();

        *ppSink = _padvise;
    }

    return S_OK;
}

// IAdviseSink
void CDocObjectHost::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CDocObjectHost::OnViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _advise_aspect;

    if (dwAspect && _padvise)
    {
        IAdviseSink *pSink = _padvise;
        IUnknown *punkRelease;

        if (_advise_advf & ADVF_ONLYONCE)
        {
            punkRelease = pSink;
            _padvise = NULL;
            _advise_aspect = _advise_advf = 0;
        }
        else
            punkRelease = NULL;

        pSink->OnViewChange(dwAspect, lindex);

        if (punkRelease)
            punkRelease->Release();
    }
}

void CDocObjectHost::OnRename(IMoniker *)
{
}

void CDocObjectHost::OnSave()
{
}

void CDocObjectHost::OnClose()
{
    //
    // the doc object below went away so tell our advisee something changed
    //
    if (_padvise)
        OnViewChange(_advise_aspect, -1);
}

// IOleWindow
HRESULT CDocObjectHost::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return S_OK;
}

HRESULT CDocObjectHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    // NOTES: This is optional
    return E_NOTIMPL;   // As specified in Kraig's document (optional)
}

// IOleInPlaceSite
HRESULT CDocObjectHost::CanInPlaceActivate(void)
{
    OIPSMSG(TEXT("CanInPlaceActivate called"));
    return S_OK;
}

HRESULT CDocObjectHost::OnInPlaceActivate(void)
{
    OIPSMSG(TEXT("OnInPlaceActivate called"));
    return S_OK;
}

HRESULT CDocObjectHost::OnUIActivate( void)
{
    TraceMsg(TF_SHDUIACTIVATE, "-----------------------------------");
    TraceMsg(TF_SHDUIACTIVATE, "OH::OnUIActivate called (this=%x)", this);

    //
    //  Hide Office toolbars early enough so that it won't flash.
    //
    _HideOfficeToolbars();

    // REVIEW:
    //  Should we remove 'our' menu here instead?
    //
    // [Copied from OLE 2.01 Spec]
    //  The container should remove any UI associated with its own
    // activation. This is significant if the container is itself
    // an embedded object.
    //
    OIPSMSG(TEXT("OnUIActivate called"));
    if (EVAL(_psb))
    {
        // If we had the DocObject in SVUIA_INPLACEACTIVATE send it to SVUIA_ACTIVATE_FOCUS
        //
        // NOTES: Unlike IE3.0, we don't call _psv->UIActivate which has a side
        //  effect. We just update the _uState.
        //
        // _psv->UIActivate(SVUIA_ACTIVATE_FOCUS);
        //
        _uState = SVUIA_ACTIVATE_FOCUS;

        return _psb->OnViewWindowActive(_psv);
    }

    return E_FAIL;
}

void CDocObjectHost::_GetClipRect(RECT* prc)
{
    GetClientRect(_hwnd, prc);
    prc->right -= _bwTools.right;
    prc->bottom -= _bwTools.bottom;
}

IOleInPlaceSite* CDocObjectHost::_GetParentSite()
{
    IOleInPlaceSite* pparentsite = NULL; // the parent's inplace site
    if (_pwb)
    {
        _pwb->GetParentSite(&pparentsite);
    }
    return pparentsite;

}

HRESULT CDocObjectHost::GetWindowContext(
    /* [out] */ IOleInPlaceFrame **ppFrame,
    /* [out] */ IOleInPlaceUIWindow **ppDoc,
    /* [out] */ LPRECT lprcPosRect,
    /* [out] */ LPRECT lprcClipRect,
    /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    OIPSMSG(TEXT("GetWindowContext called"));

    // Todo: verify that lpFrameInfo->cb is the correct size!

    // TraceMsg(0, "sdv TR - ::GetWindowContext called with lpFI->cb=%d (%d)",
    //           lpFrameInfo->cb, sizeof(*lpFrameInfo));
    *ppFrame = &_dof; AddRef();
    *ppDoc = NULL; // indicating that doc window == frame window

    _GetClipRect(lprcClipRect);

    lpFrameInfo->fMDIApp = FALSE;

    //
    //  If the frame has IOleInPlaceUIWindow (both IE and Shell have),
    // return that hwnd as hwndFrame so that OLE's menu dispatching
    // code works correctly.
    //
    _dof.GetWindow(&lpFrameInfo->hwndFrame);

    //
    //  We need to find out (from SriniK or KraigB), what is the
    //  implecation of this accelerator. Dealing with Word, it seems that
    //  Word does not call our TranslateAccelerator at all, unless the key
    //  stroke is the accelerator. If that's the spec. (of DocObject),
    //  there is no way to process the accelerator of the browser.
    //
    lpFrameInfo->haccel = _hacc;

    if (!SHRestricted(REST_NOFILEMENU))
    {
#ifdef DEBUG
        lpFrameInfo->cAccelEntries = DBG_ACCELENTRIES_WITH_FILEMENU; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#else
        lpFrameInfo->cAccelEntries = OPT_ACCELENTRIES_WITH_FILEMENU; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#endif
    }
    else
    {
#ifdef DEBUG
        lpFrameInfo->cAccelEntries = DBG_ACCELENTRIES; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#else
        lpFrameInfo->cAccelEntries = OPT_ACCELENTRIES; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#endif
    }

    *lprcPosRect = _rcView;
    return S_OK;
}

HRESULT CDocObjectHost::Scroll(
    /* [in] */ SIZE scrollExtant)
{
    TraceMsg(0, "sdv TR - ::Scroll called");
    return E_NOTIMPL;   // As specified in Kraig's document
}

HRESULT CDocObjectHost::OnUIDeactivate(
    /* [in] */ BOOL fUndoable)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::OnUIDeactivate called (this=%x)", this);

    DEBUG_CODE( _DumpMenus(TEXT("on OnUIDeactivate"), TRUE); )

    if (_hmenuSet) {
        OIPSMSG(TEXT("OnUIDeactivate We need to SetMenu(NULL, NULL, NULL)"));
        _SetMenu(NULL, NULL, NULL);
    }

    return S_OK;
}

HRESULT CDocObjectHost::OnInPlaceDeactivate( void)
{
    OIPSMSG(TEXT("OnInPlaceDeactivate called"));
    return S_OK;
}


HRESULT CDocObjectHost::DiscardUndoState( void)
{
    TraceMsg(0, "sdv TR - ::DiscardUndoState called");
    return S_OK;
}

HRESULT CDocObjectHost::DeactivateAndUndo( void)
{
    TraceMsg(0, "sdv TR - ::DeactivateAndUndo called");
    return S_OK;
}

HRESULT CDocObjectHost::OnPosRectChange(
    /* [in] */ LPCRECT lprcPosRect)
{
    return E_NOTIMPL;   // As specified in Kraig's document
}

HRESULT CDocObjectHost::OnInPlaceActivateEx(
    /* [out] */ BOOL __RPC_FAR *pfNoRedraw,
    /* [in] */ DWORD dwFlags)
{
    OIPSMSG(TEXT("OnInPlaceActivateEx called"));
    return S_OK;
}

HRESULT CDocObjectHost::OnInPlaceDeactivateEx(
    /* [in] */ BOOL fNoRedraw)
{
    OIPSMSG(TEXT("OnInPlaceDeactivateEx called"));
    return S_OK;
}

HRESULT CDocObjectHost::RequestUIActivate( void)
{
    if (_pWebOCInPlaceSiteEx)
        return _pWebOCInPlaceSiteEx->RequestUIActivate();
    else
        return TRUE;
}

void CDocObjectHost::_OnNotify(LPNMHDR lpnm)
{
    switch(lpnm->code) {

    case TBN_BEGINDRAG:
#define ptbn ((LPTBNOTIFY)lpnm)
        _OnMenuSelect(ptbn->iItem, 0, NULL);
        break;
    }
}

void MapAtToNull(LPTSTR psz)
{
    while (*psz)
    {
        if (*psz == TEXT('@'))
        {
            LPTSTR pszNext = CharNext(psz);
            *psz = 0;
            psz = pszNext;
        }
        else
        {
            psz = CharNext(psz);
        }
    }
}

void BrowsePushed(HWND hDlg)
{
    TCHAR szText[MAX_PATH];
    DWORD cchText = ARRAYSIZE(szText);
    TCHAR szFilter[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    LPITEMIDLIST pidl;
    LPCITEMIDLIST pidlChild;
    IShellFolder * pSF;

    // load the filter and then replace all the @ characters with NULL.  The end of the string will be doubly
    // null-terminated
    MLLoadShellLangString(IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter));
    MapAtToNull(szFilter);

    GetDlgItemText(hDlg, IDD_COMMAND, szText, ARRAYSIZE(szText));
    PathUnquoteSpaces(szText);

    // eliminate the "file://" stuff if necessary
    if (IsFileUrlW(szText))
        PathCreateFromUrl(szText, szText, &cchText, 0);

    MLLoadShellLangString(IDS_TITLE, szTitle, ARRAYSIZE(szTitle));

    if (GetFileNameFromBrowse(hDlg, szText, ARRAYSIZE(szText), NULL,
            TEXT(".htm"), szFilter, szTitle))
    {
        if (SUCCEEDED(IECreateFromPath(szText, &pidl)))
        {
            if (SUCCEEDED(IEBindToParentFolder(pidl, &pSF, &pidlChild)))
            {
                HWND hWndCombo = GetDlgItem(hDlg, IDD_COMMAND);

                COMBOBOXEXITEM cbexItem = {0};
                cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                cbexItem.pszText = szText;
                cbexItem.cchTextMax = ARRAYSIZE(szText);
                cbexItem.iItem = -1;
                cbexItem.iImage = IEMapPIDLToSystemImageListIndex(pSF, pidlChild, &cbexItem.iSelectedImage);
                INT_PTR iPosition = SendMessage(hWndCombo, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM)iPosition, (LPARAM)0);
                pSF->Release();
            }
            ILFree(pidl);
        }
        else
        {
            PathUnquoteSpaces(szText);
            SetDlgItemText(hDlg, IDD_COMMAND, szText);
        }

        EnableOKButtonFromID(hDlg, IDD_COMMAND);
        // place the focus on OK
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
    }
}

struct SOpenDlg {
    TCHAR           szURL[MAX_URL_STRING];
    IAddressEditBox *paebox;   // Object that controls ComboBoxEx
    IBandSite       *pbs;   // Used in AEBox Init call (used as a Connection Site)
    IWinEventHandler *pweh;    // Used to funnel IDD_COMMAND messages to the AEBox
};

const DWORD c_mapCtrlToContextIds[] = { 0, 0 };

const DWORD c_aRunHelpIds[] = {
        IDD_ICON,             NO_HELP,
        IDD_PROMPT,           NO_HELP,
        IDD_RUNDLGOPENPROMPT, IDH_IE_RUN_COMMAND,
        IDD_COMMAND,          IDH_IE_RUN_COMMAND,
        IDD_BROWSE,           IDH_RUNBROWSE,
        IDC_ASWEBFOLDER,      IDH_WEB_FOLDERS_CKBOX,

        0, 0
};

#ifndef UNIX
HRESULT OpenDlgOnWebFolderOK(HWND hDlg, SOpenDlg * podlg)
{
    ASSERT(podlg);

    HRESULT hr = S_OK;

    HWND hWndOpenBox = GetDlgItem(hDlg, IDD_COMMAND);
    ComboBox_GetText(hWndOpenBox, podlg->szURL, ARRAYSIZE(podlg->szURL));
    PathRemoveBlanks(podlg->szURL);

//    int iScheme = GetUrlScheme(podlg->szURL);

//    if ((URL_SCHEME_HTTP != iScheme) &&
//        (URL_SCHEME_HTTPS != iScheme))
//    {
        // no, we don't support that protocol!!
//        WCHAR wszMessage[MAX_PATH];
//        WCHAR wszTitle[MAX_PATH];
//        WCHAR wszErrorMessage[MAX_PATH + MAX_URL_STRING + 1];

//        MLLoadShellLangString(IDS_ERRORBADURL, wszMessage, ARRAYSIZE(wszMessage));
//        MLLoadShellLangString(IDS_ERRORBADURLTITLE, wszTitle, ARRAYSIZE(wszTitle));
//        wnsprintf(wszErrorMessage, ARRAYSIZE(wszErrorMessage), wszMessage, podlg->szURL);
//        MessageBox(hDlg, wszErrorMessage, wszTitle, MB_OK | MB_ICONERROR);
//        hr = E_FAIL;
//    }
    return hr;
}
#endif // UNIX

HRESULT OpenDlgOnOK(HWND hDlg, SOpenDlg * podlg)
{
    ASSERT(podlg);

    HRESULT hr = S_OK;
    /*
        Try to use newer parsing code if we have an AddressEditBox object
    */
    if (podlg->paebox)
        hr = podlg->paebox->ParseNow(SHURL_FLAGS_NONE);
    else
    {
        HWND hWndOpenBox = GetDlgItem(hDlg, IDD_COMMAND);
        ComboBox_GetText(hWndOpenBox, podlg->szURL, ARRAYSIZE(podlg->szURL));
        PathRemoveBlanks(podlg->szURL);
    }

    return hr;
}

void CleanUpAutoComplete(SOpenDlg *podlg)
{
    ATOMICRELEASE(podlg->paebox);
    ATOMICRELEASE(podlg->pweh);
    ATOMICRELEASE(podlg->pbs);

    ZeroMemory((PVOID)podlg, SIZEOF(SOpenDlg));
}


BOOL_PTR CALLBACK CDocObjectHost::s_RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SOpenDlg* podlg = (SOpenDlg*)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_INITDIALOG:
    {
        ASSERT(lParam);

        HWND hWndOpenBox = GetDlgItem(hDlg, IDD_COMMAND);
        HWND hWndEditBox = (HWND)SendMessage(hWndOpenBox, CBEM_GETEDITCONTROL, 0,0);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        podlg = (SOpenDlg *)lParam;

        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_COMMAND);

        if (podlg->paebox)
        {
            if ( FAILED(podlg->paebox->Init(hWndOpenBox, hWndEditBox, AEB_INIT_DEFAULT | AEB_INIT_NOASYNC, podlg->pbs)) ||
                 FAILED(IUnknown_SetOwner(podlg->paebox, podlg->pbs)))
                CleanUpAutoComplete(podlg);
        }
#ifdef UNIX
        // BUG BUG : Win32 should also verify and take this change.
        // IEUNIX : Limiting text, faulting under stress test. Need to set
        // this limit.
        SendMessage(hWndOpenBox, CB_LIMITTEXT, CBEMAXSTRLEN-1, 0L);
#endif
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        if (SHRestricted(REST_NORUN))
            EnableWindow(GetDlgItem(hDlg, IDC_ASWEBFOLDER), FALSE); // disable open as web folder
            
        break;

    }

    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) c_aRunHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR) c_aRunHelpIds);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
       {
        case IDHELP:
            break;

        case IDD_BROWSE:
            BrowsePushed(hDlg);
            break;

        case IDD_COMMAND:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case CBN_SELCHANGE:
                break;

            case CBN_EDITCHANGE:
            case CBN_SELENDOK:
                if (podlg->pweh)
                    podlg->pweh->OnWinEvent(hDlg, uMsg, wParam, lParam, NULL);
                EnableOKButtonFromID(hDlg, IDD_COMMAND);
                break;

            default:
                if (podlg->pweh)
                    podlg->pweh->OnWinEvent(hDlg, uMsg, wParam, lParam, NULL);
                break;
            }
            break;

        case IDOK:
            {
                // UNIX doesn't support this checkbox -- so we don't need
                // to check.
#ifndef UNIX
                HWND hwndCheckBox = GetDlgItem(hDlg, IDC_ASWEBFOLDER);
                if (hwndCheckBox)
                {
                    LRESULT lrState = SendMessage(hwndCheckBox, BM_GETCHECK,
                        0, 0);
                    if (lrState == BST_CHECKED)
                    {
                        if (SUCCEEDED(OpenDlgOnWebFolderOK(hDlg, podlg)))
                            EndDialog(hDlg, IDC_ASWEBFOLDER);
                        break;
                    }
                    else
#endif
                        if (FAILED(OpenDlgOnOK(hDlg, podlg)))
                            break;
#ifndef UNIX
                }
#endif
            }
            // Fall through to IDCANCEL to close dlg

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void CDocObjectHost::_Navigate(LPCWSTR pwszURL)
{
    IWebBrowser2* pwb2;
    if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SContainerDispatch, IID_IWebBrowser2, (void **)&pwb2)))
    {
        //
        // HACK: We are not passing BSTR, but LPWSTR, which
        //  will work as far as IWebBrowser2 can handle
        //  NULL-terminated string correctly.
        //
        pwb2->Navigate((BSTR)pwszURL, NULL, NULL, NULL, NULL);
        pwb2->Release();
    }
}


HRESULT CDocObjectHost::_PrepFileOpenAddrBand(IAddressEditBox ** ppaeb, IWinEventHandler ** ppweh, IBandSite ** ppbs)
{
    HRESULT hr;

    *ppaeb = NULL;
    *ppweh = NULL;
    *ppbs = NULL;

    //  If our CoCreateInstance fails, s_rundlgproc will know because paebox
    //  will be NULL
    hr = CoCreateInstance(CLSID_AddressEditBox, NULL, CLSCTX_INPROC_SERVER, IID_IAddressEditBox, (void **)ppaeb);
    if (EVAL(SUCCEEDED(hr)))
    {
        IServiceProvider *pspT;
        hr = (*ppaeb)->QueryInterface(IID_IWinEventHandler, (void **)ppweh);

        //  Travel up the object hierarchy, and obtain the same pointer that
        //  the address bar was ::Init'ed with
        //  WARNING: This is not optional.  The addressband will fault if this fails.
        if (EVAL(SUCCEEDED(hr) && _psp))
        {
            hr = _psp->QueryService(SID_SExplorerToolbar, IID_IServiceProvider, (void **)&pspT);
            // In framed cases, CBaseBrowser2::QueryService() will filter out SID_SExplorerToolbar
            // because it's afraid of Toolbars appearing in the frame.  We won't have that problem,
            // so we may need to go the TopLevelBrowser first and then ask around there.
            if (FAILED(hr))
            {
                IServiceProvider *pspT2;

                hr = _psp->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&pspT2);
                if (EVAL(SUCCEEDED(hr)))
                {
                    hr = pspT2->QueryService(SID_SExplorerToolbar, IID_IServiceProvider, (void **)&pspT);
                    pspT2->Release();
                }
            }

            if (EVAL(SUCCEEDED(hr)))
            {
                if (EVAL(SUCCEEDED(hr = pspT->QueryService(IID_IBandSite, IID_IBandSite, (void **)ppbs))))
                {
                    IDeskBand *pdbT;
                    // Had to include "ITBAR.H" to access CBIDX_ADDDRESS
// HACKHACK
#define CBIDX_ADDRESS           4
                    // If any of the following fails, I don't care because the MRU can be out of
                    // synch.
                    if (SUCCEEDED((*ppbs)->QueryBand(CBIDX_ADDRESS, &pdbT, NULL, NULL, 0)))
                    {
                        IUnknown_Exec(pdbT, &CGID_AddressEditBox, AECMDID_SAVE, 0, NULL, NULL);
                        pdbT->Release();
                    }
                }
                pspT->Release();
            }
        }

    }

    if (FAILED(hr))
    {
        ATOMICRELEASE(*ppaeb);
        ATOMICRELEASE(*ppweh);
        ATOMICRELEASE(*ppbs);
    }

    return hr;
}

void CDocObjectHost::_OnOpen(void)
{
    HWND hwndFrame;
    SOpenDlg odlg ={0};

    _psb->GetWindow(&hwndFrame);

    if (SHIsRestricted2W(_hwnd, REST_NoFileOpen, NULL, 0))
        return;

    if (EVAL(SUCCEEDED(_PrepFileOpenAddrBand(&(odlg.paebox), &odlg.pweh, &odlg.pbs))))
    {
        // TODO: Make it a helper member, which notifies up and down.
        _psb->EnableModelessSB(FALSE);

#ifdef UNIX
        UINT iRet;
        if (TRUE || MwCurrentLook() == LOOK_MOTIF)
           iRet = DialogBoxParam(MLGetHinst(),
                                 MAKEINTRESOURCE(DLG_RUNMOTIF),
                                 hwndFrame,
                                 s_RunDlgProc,
                                 (LPARAM)&odlg);
        else
           iRet = DialogBoxParam(MLGetHinst(),
                                 MAKEINTRESOURCE(DLG_RUN),
                                 hwndFrame,
                                 s_RunDlgProc,
                                 (LPARAM)&odlg);
#else
        INT_PTR iRet = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_RUN), hwndFrame, s_RunDlgProc, (LPARAM)&odlg);
#endif /* UNIX */

        _psb->EnableModelessSB(TRUE);

        if (iRet==IDOK)
        {
            if (g_dwStopWatchMode)   // Perf mode to mark start time
                StopWatch_MarkSameFrameStart(hwndFrame);

            if (odlg.paebox)
                odlg.paebox->Execute(SHURL_EXECFLAGS_NONE);
            else
                _Navigate(odlg.szURL);
        }

#ifndef UNIX

        if (iRet == IDC_ASWEBFOLDER)
        {
            BSTR bstrUrl = SysAllocString(odlg.szURL);
            if (bstrUrl != NULL)
            {
                _NavigateFolder(bstrUrl);
                SysFreeString(bstrUrl);
            }
        }

#endif /*!UNIX*/

        IUnknown_SetOwner(odlg.paebox, NULL);
    }

    // Cleanup ref counts
    CleanUpAutoComplete(&odlg);
}

void CDocObjectHost::_OnClose() const
{
    ASSERT(_pwb);

    if (!_HideBrowserBar())
    {
        HRESULT hr = E_FAIL;
        HWND    hwnd = NULL;
        IOleWindow * pOleWindow;

        if ( _pwb )
        {
            hr = _pwb->QueryInterface(IID_PPV_ARG(IOleWindow, &pOleWindow));
        }

        if (SUCCEEDED(hr))
        {
            pOleWindow->GetWindow(&hwnd);
            pOleWindow->Release();

            if ( hwnd )
            {
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
    }
}

BOOL CDocObjectHost::_HideBrowserBar() const
{
    ASSERT(_pwb);
    
    // Get the proxy browser. We only have
    // a proxy browser if we are in a band.
    //
    IShellBrowser * pPrxyBrowser;
    HRESULT hr = IUnknown_QueryService(_pwb,
                               SID_SProxyBrowser,
                               IID_IShellBrowser,
                               (void**)&pPrxyBrowser);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_ShowBrowserBar(_psb, CLSID_SearchBand, FALSE);
    }

    return (SUCCEEDED(hr) ? TRUE : FALSE);
}

void CDocObjectHost::_OnImportExport(HWND hwnd)
{
    RunImportExportFavoritesWizard(hwnd);
}

UINT_PTR CALLBACK DocHostSaveAsOFNHook(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            /* Hide the "Save as Type" text box */
            CommDlg_OpenSave_HideControl(GetParent(hDlg), stc2);
            /* Hide the listbox with save type extensions */
            CommDlg_OpenSave_HideControl(GetParent(hDlg), cmb1);
            /* Hide the Open as read-only control */
            CommDlg_OpenSave_HideControl(GetParent(hDlg), chx1);
            break;
        }

        default:
                break;
    }
    return FALSE;
}

#define IDS_HELPURL_SUPPORT         IDS_HELPMSWEB+4
#define SZ_REGKEY_HELPURL_OVERRIDE  TEXT("Software\\Microsoft\\Internet Explorer\\Help_Menu_URLs")
#define SZ_REGVAL_HELPURL_SUPPORT   TEXT("Online_Support")
#define SZ_REGVAL_HELPURL_TEMPLATE  TEXT("%d")

void CDocObjectHost::_OnHelpGoto(UINT idRes)
{
    HRESULT hr = E_FAIL;
    WCHAR szURL[MAX_PATH];  // this is enough for our own

    // First try to get a copy from the registry because this is where Admins (with the IEAK) over ride
    // our default values.

    // We special case the Online_Support URL because it was supported in IE3.
    if (IDS_HELPURL_SUPPORT == idRes)
    {
        hr = URLSubRegQuery(SZ_REGKEY_HELPURL_OVERRIDE, SZ_REGVAL_HELPURL_SUPPORT, TRUE, szURL, ARRAYSIZE(szURL), URLSUB_ALL);
    }
    else
    {
        WCHAR szValue[MAX_PATH];

        wnsprintfW(szValue, ARRAYSIZE(szValue), SZ_REGVAL_HELPURL_TEMPLATE, (idRes - IDS_HELPMSWEB + 1));
        hr = URLSubRegQuery(SZ_REGKEY_HELPURL_OVERRIDE, szValue, TRUE, szURL, ARRAYSIZE(szURL), URLSUB_ALL);
    }

    if (FAILED(hr))
        hr = URLSubLoadString(NULL, idRes, szURL, ARRAYSIZE(szURL), URLSUB_ALL);

    if (SUCCEEDED(hr))
    {
        _Navigate(szURL);
    }
}

STDAPI_(void) IEAboutBox( HWND hWnd );


// WM_COMMAND from _WndProc - execs are going down
void CDocObjectHost::_OnCommand(UINT wNotify, UINT id, HWND hwndControl)
{
    if (_ShouldForwardMenu(WM_COMMAND, MAKEWPARAM(id, wNotify), (LPARAM)hwndControl))
    {
        _ForwardObjectMsg(WM_COMMAND, MAKEWPARAM(id, wNotify), (LPARAM)hwndControl);
        return;
    }

    switch(id)
    {
    case DVIDM_HELPTUTORIAL:
        _OnHelpGoto(IDS_HELPTUTORIAL);
        break;

    // ShabbirS (980917): BugFix# 34259 - Repair IE option.

    case DVIDM_HELPREPAIR:
        RepairIE();
        break;

    case DVIDM_HELPABOUT:
        IEAboutBox( _hwnd );
        break;

    case DVIDM_HELPSEARCH:
    {
#ifdef UNIX
        ContentHelp(_psb);
        break;
#else
        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };
        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_IEHelp;

        HRESULT hres = FaultInIEFeature(_hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);

        if ( SUCCEEDED( hres ) )
        {
            // MLHtmlHelp runs on a separate thread and should therefore be
            // safe against the kinds of message loops problems indicated above

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            MLHtmlHelp(_hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, 0, ML_CROSSCODEPAGE);
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }
        else
        {
            TraceMsg( TF_WARNING, "CDocObjectHost::_OnCommand() - FaultInIEFeature() Failed with hr=0x%x!", hres );
        }
        break;
#endif
    }

    case DVIDM_DHFAVORITES:
        _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
        break;

    case DVIDM_GOHOME:
    case DVIDM_GOSEARCH:
        {
            TCHAR szPath[MAX_URL_STRING];
            LPITEMIDLIST pidl;
            HRESULT hres = SHDGetPageLocation(_hwnd,
                                      (id==DVIDM_GOSEARCH) ? IDP_SEARCH : IDP_START,
                                      szPath, ARRAYSIZE(szPath), &pidl);
            if (SUCCEEDED(hres))
            {
                _psb->BrowseObject(pidl, SBSP_ABSOLUTE | SBSP_SAMEBROWSER);
                ILFree(pidl);
            }
            else
            {
                TCHAR szMessage[256];
                BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL, hres, 0, szMessage, ARRAYSIZE(szMessage), (va_list *)&szPath);
                if (!fSuccess)
                    szMessage[0] = 0;

                MLShellMessageBox(_hwnd,
                                MAKEINTRESOURCE(IDS_CANTACCESSDOCUMENT),
                                szPath, MB_OK | MB_SETFOREGROUND | MB_ICONSTOP, szMessage);
            }
        }
        break;

    case DVIDM_STOPDOWNLOAD:
        // We need to tell the container to cancel a pending navigation
        // if any. Notice that the Cancel button serves for two purposes:
        //  (1) canceling a pending navigation
        //  (2) cancel any downloading
        if (_psb)
            _CancelPendingNavigation(FALSE);
        goto TryDocument;

    case DVIDM_NEWWINDOW:
        // make sure the top level browser gets cloned, not an explorer bar
        IShellBrowser* psbTop;
        if (!SHIsRestricted2W(_hwnd, REST_NoOpeninNewWnd, NULL, 0)     &&
            !SHIsRestricted2W(_hwnd, REST_NoFileNew, NULL, 0) &&
            EVAL(SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_IShellBrowser, (void **)&psbTop))) && psbTop)
        {
            BOOL fHandled = FALSE;

            if (_pWebOCUIHandler)
            {
                // Give the WebOC host a chance to handle this command, since it may
                // not want an IE window to be created

                if (S_OK == IUnknown_Exec(_pWebOCUIHandler, &CGID_DocHostCommandHandler, 
                     IDM_NEW_TOPLEVELWINDOW, 0, NULL, NULL))
                {
                    fHandled = TRUE;
                }
            }

            if (!fHandled)
            {
                // tell the top level browser to save its window size to the registry so 
                // that our new window can pick it up and cascade properly
                IUnknown_Exec(psbTop, &CGID_Explorer, SBCMDID_SUGGESTSAVEWINPOS, 0, NULL, NULL);
            
                psbTop->BrowseObject(&s_idNull, SBSP_RELATIVE|SBSP_NEWBROWSER);
                psbTop->Release();
            }
        }
        break;

    case DVIDM_OPEN:
        _OnOpen();
        break;

    case DVIDM_SAVE:
        if (!SHIsRestricted2W(_hwnd, REST_NoBrowserSaveAs, NULL, 0))
        {
            // There's a scenario where the XML MimeViewer, when aggregating Trident, answers "disabled" to 
            // OLECMDID_SAVE.  However, since we don't call QueryStatus on the ACCELERATOR key sequence,
            // we end up calling into Trident's IPersistFile::Save(), overwriting the XML file with the converted
            // HTML.
            //
            // The right thing to do is to QS and beep if disabled.
            //
            if (_dwAppHack & BROWSERFLAG_MSHTML)
            {
                if (_pmsot)
                {
                    OLECMD rgcmds[] = { { OLECMDID_SAVE, 0 }, };

                    _pmsot->QueryStatus(NULL, ARRAYSIZE(rgcmds), rgcmds, NULL);

                    if (!(rgcmds[0].cmdf & OLECMDF_ENABLED))
                    {
                        // If SAVE is disabled, provide user feedback.
                        MessageBeep(0);
                        break;
                    }
                }
            }
            _OnSave();
        }
        break;

    case DVIDM_DESKTOPSHORTCUT:
        IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_CREATESHORTCUT, 0, NULL, NULL);
        break;

    case DVIDM_SENDPAGE:
        IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_SENDPAGE, 0, NULL, NULL);
        break;

    case DVIDM_SENDSHORTCUT:
        IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_SENDSHORTCUT, 0, NULL, NULL);
        break;

    case DVIDM_NEWMESSAGE:
#ifdef UNIX
        if ( OEHandlesMail() )
            _UnixSendDocToOE(NULL, 0,  MAIL_ACTION_SEND);
        else
            SendDocToMailRecipient(NULL, 0, MAIL_ACTION_SEND);
#else
        if (FAILED(DropOnMailRecipient(NULL, 0))) 
        {
            SHRunIndirectRegClientCommand(_hwnd, NEW_MAIL_DEF_KEY);
        }
#endif
        break;

    case DVIDM_NEWPOST:
#ifdef UNIX
        if (!CheckAndExecNewsScript(_hwnd))
#endif
        SHRunIndirectRegClientCommand(_hwnd, NEW_NEWS_DEF_KEY);
        break;

    case DVIDM_NEWCONTACT:
        SHRunIndirectRegClientCommand(_hwnd, NEW_CONTACTS_DEF_KEY);
        break;

    case DVIDM_NEWAPPOINTMENT:
        SHRunIndirectRegClientCommand(_hwnd, NEW_APPOINTMENT_DEF_KEY);
        break;

    case DVIDM_NEWMEETING:
        SHRunIndirectRegClientCommand(_hwnd, NEW_MEETING_DEF_KEY);
        break;

    case DVIDM_NEWTASK:
        SHRunIndirectRegClientCommand(_hwnd, NEW_TASK_DEF_KEY);
        break;

    case DVIDM_NEWTASKREQUEST:
        SHRunIndirectRegClientCommand(_hwnd, NEW_TASKREQUEST_DEF_KEY);
        break;

    case DVIDM_NEWJOURNAL:
        SHRunIndirectRegClientCommand(_hwnd, NEW_JOURNAL_DEF_KEY);
        break;

    case DVIDM_NEWNOTE:
        SHRunIndirectRegClientCommand(_hwnd, NEW_NOTE_DEF_KEY);
        break;

    case DVIDM_CALL:
        SHRunIndirectRegClientCommand(_hwnd, NEW_CALL_DEF_KEY);
        break;

    case DVIDM_SAVEASFILE:
        //
        //  Handle the case where DocObject does not support "SaveAs"
        // and we have enabled the menuitem anyway.
        //
        if (SHIsRestricted2W(_hwnd, REST_NoBrowserSaveAs, NULL, 0))
            break;

        if (_pmsot)
        {
            OLECMD rgcmds[] = { { OLECMDID_SAVEAS, 0 }, };

            _pmsot->QueryStatus(NULL, ARRAYSIZE(rgcmds), rgcmds, NULL);

            ASSERT(rgcmds[0].cmdf & OLECMDF_ENABLED);
            if (!(rgcmds[0].cmdf & OLECMDF_ENABLED))
                _OnSaveAs();
            else
                goto TryDocument;
        }
        break;

    case DVIDM_IMPORTEXPORT:
        _OnImportExport(_hwnd);
        break;

    default:
        if (IsInRange(id, DVIDM_HELPMSWEB, DVIDM_HELPMSWEBLAST))
        {
        #ifndef UNIX
            if (id == FCIDM_HELPNETSCAPEUSERS)
                SHHtmlHelpOnDemandWrap(_hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("lvg_nscp.htm"), ML_CROSSCODEPAGE);
            else
        #else
            if (id == FCIDM_HELPNETSCAPEUSERS)
                UnixHelp(L"Netscape User Help", _psb);
            else
        #endif
                _OnHelpGoto(IDS_HELPMSWEB + (id - DVIDM_HELPMSWEB));
        }
        else if (IsInRange(id, DVIDM_MSHTML_FIRST, DVIDM_MSHTML_LAST))
        {
            TraceMsg(DM_PREMERGEDMENU, "Processing merged menuitem %d", id - DVIDM_MSHTML_FIRST);
            ASSERT(_pcmdMergedMenu);
            if (_pcmdMergedMenu) {
                HRESULT hresT=_pcmdMergedMenu->Exec(&CGID_MSHTML, id - DVIDM_MSHTML_FIRST, 0, NULL, NULL);
                if (FAILED(hresT)) {
                    TraceMsg(DM_ERROR, "CDOH::_OnCommand _pcmdMergedMenu->Exec(%d) failed %x",
                             id - DVIDM_MSHTML_FIRST, hresT);
                }
            }
        }
        else if (IsInRange (id, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
        {
            // Menu Extensions
            IUnknown_Exec(_pBrowsExt, &CLSID_ToolbarExtButtons, id, 0, NULL, NULL);
        }
        else
        {
TryDocument:
            if (_pmsot)
            {
                // Check if we need to call object's Exec.
                UINT idMso = _MapToMso(id);
                if (idMso != (UINT)-1)
                {
                    // Yes. Call it.
                    _pmsot->Exec(NULL, idMso, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                }
                else if (id == DVIDM_PRINTFRAME)
                {
                    _pmsot->Exec(&CGID_ShellDocView, SHDVID_PRINTFRAME, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                }
            }
        }
        break;
    }
}

HRESULT CDocObjectHost::_OnSaveAs(void)
{
    HRESULT hres = S_OK;

    TraceMsg(DM_SAVEASHACK, "DOH::_OnSaveAs called");

    ASSERT(_pole);

    if (_dwAppHack & BROWSERFLAG_MSHTML)
    {
        SaveBrowserFile( _hwnd, _pole );
    }
    else // old dochost stuff
    {
        TCHAR szSaveTo[MAX_PATH];   // ok with MAX_PATH
        MLLoadString(IDS_DOCUMENT, szSaveTo, ARRAYSIZE(szSaveTo));
        TCHAR szDesktop[MAX_PATH];

        SHGetSpecialFolderPath(_hwnd, szDesktop, CSIDL_DESKTOPDIRECTORY, FALSE);

        OPENFILENAME OFN;
        OFN.lStructSize        = sizeof(OPENFILENAME);
        OFN.hwndOwner          = _hwnd;
        OFN.lpstrFileTitle     = 0;
        OFN.nMaxCustFilter     = 0;
        OFN.nFilterIndex       = 0;

        OFN.nMaxFile           = ARRAYSIZE(szSaveTo);
        OFN.lpfnHook           = DocHostSaveAsOFNHook;
        OFN.Flags              = 0L;/* for now, since there's no readonly support */
        OFN.lpstrTitle         = NULL;
        OFN.lpstrInitialDir    = szDesktop;

        OFN.lpstrFile = szSaveTo;
        OFN.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK | OFN_EXPLORER |
                    OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST;
        OFN.lpstrFilter      = NULL;
        OFN.lpstrCustomFilter = NULL;


        OFN.lpstrDefExt = TEXT("");     // no extension
        TCHAR szValue[MAX_PATH+1];      // +1 for for double-null
        TCHAR szExt[40];

        HKEY hkey = _GetUserCLSIDKey(_pole, NULL, NULL);
        if (hkey)
        {
            LONG cb = SIZEOF(szValue);
            if (RegQueryValue(hkey, TEXT("DefaultExtension"), szValue, &cb) == ERROR_SUCCESS)
            {
                TraceMsg(DM_SAVEASHACK, "DOH::_OnSaveAs DefExt is %s", szValue);

                // It is suposed to be like ".xls, Excel Workbook (*.xls)"
                if (szValue[0]==TEXT('.')) {
                    StrCpyN(szExt, szValue+1, ARRAYSIZE(szExt));
                    LPTSTR pszEnd = StrChr(szExt, TEXT(','));
                    if (pszEnd) {
                        *pszEnd = 0;
                    }

                    OFN.lpstrDefExt = szExt;
                    OFN.lpstrFilter = szValue;
                    OFN.Flags &= ~OFN_ENABLEHOOK;

                    TraceMsg(DM_SAVEASHACK, "DOH::_OnSaveAs OFN.lpstrDefExt is %s", OFN.lpstrDefExt);
                }
            }
        }

        if (GetSaveFileName(&OFN))
        {
            IPersistFile* ppf;
            ASSERT(_pole);
            hres = _pole->QueryInterface(IID_IPersistFile, (void **)&ppf);
            if (SUCCEEDED(hres))
            {
                TraceMsg(DM_APPHACK, "APPHACK DOH SaveAs'ing to %s", szSaveTo);
                hres = ppf->Save(szSaveTo, FALSE);
                ppf->Release();
            }
            else
            {
                ASSERT(0);
            }
        }
        else
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

#ifndef POSTPOSTSPLIT
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IDropTarget, (void**)&pdrop);

    if (SUCCEEDED(hres))
    {
        hres = SimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    return hres;
}


HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState)
{
#ifndef UNIX
    IDataObject *pdtobj;
    HRESULT hres = GetDataObjectForPidl(pidl, &pdtobj);
    if (SUCCEEDED(hres))
    {
        IQueryCodePage * pQcp;
        if (SUCCEEDED(pdtobj->QueryInterface(IID_IQueryCodePage, (void **)&pQcp)))
        {
            pQcp->SetCodePage(uiCodePage);
            pQcp->Release();
        }
        hres = DropOnMailRecipient(pdtobj, grfKeyState);
        pdtobj->Release();
    }

    return hres;
#else
    return UnixSendDocToMailRecipient(pidl, uiCodePage, grfKeyState);
#endif
}
#endif

void _EnableRemoveMenuItem(HMENU hmenu, DWORD cmdf, UINT uCmd)
{
    if (!(cmdf & (OLECMDF_SUPPORTED | OLECMDF_ENABLED)))
        RemoveMenu(hmenu, uCmd, MF_BYCOMMAND);
    else
        _EnableMenuItem(hmenu, uCmd,
                        cmdf & OLECMDF_ENABLED);
}

void CDocObjectHost::_OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu)
{
    if (!_hmenuCur)
        return;

    DEBUG_CODE( _DumpMenus(TEXT("on _OnInitMenuPopup"), TRUE); )

    if (GetMenuFromID(_hmenuCur, FCIDM_MENU_VIEW) == hmInit) {
        OLECMD rgcmd1[] = {
            { IDM_SCRIPTDEBUGGER, 0 },
        };

        DeleteMenu (hmInit, DVIDM_MSHTML_FIRST+IDM_SCRIPTDEBUGGER, MF_BYCOMMAND);
        if (SUCCEEDED(QueryStatusDown(&CGID_MSHTML, ARRAYSIZE(rgcmd1), rgcmd1, NULL)) && (rgcmd1[0].cmdf & OLECMDF_ENABLED)) {
            //
            // We need the script debugger popup menu.  We should check to see if this
            // needs to be loaded.
            //

            HMENU           hMenuDebugger;
            MENUITEMINFO   mii;
            const UINT      cchBuf = 128;
            TCHAR           szItem[cchBuf];

            hMenuDebugger = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_SCRDEBUG));

            mii.fMask = MIIM_SUBMENU | MIIM_TYPE | MIIM_ID;
            mii.fType = MFT_STRING;
            mii.cch = cchBuf;
            mii.dwTypeData = szItem;
            mii.cbSize = sizeof(mii);
            GetMenuItemInfo(hMenuDebugger, 0, TRUE, &mii);

            mii.fMask |= MIIM_STATE;
            mii.fState = MFS_ENABLED;

            InsertMenuItem(hmInit, FCIDM_THEATER, FALSE, &mii);


            OLECMD rgcmd[] = {
                { IDM_BREAKATNEXT, 0 },
                { IDM_LAUNCHDEBUGGER, 0 },
            };

            HRESULT hr = QueryStatusDown(&CGID_MSHTML, ARRAYSIZE(rgcmd), rgcmd, NULL);
            _EnableMenuItem(mii.hSubMenu, DVIDM_MSHTML_FIRST+rgcmd[0].cmdID, SUCCEEDED(hr) && (rgcmd[0].cmdf & OLECMDF_ENABLED));
            _EnableMenuItem(mii.hSubMenu, DVIDM_MSHTML_FIRST+rgcmd[1].cmdID, SUCCEEDED(hr) && (rgcmd[1].cmdf & OLECMDF_ENABLED));

        }

        if (_pmsot)
        {
            OLECMD rgcmd2[] = {
                { IDM_VIEWSOURCE, 0 },
            };

            if (SHRestricted2(REST_NoViewSource, NULL, 0) == 0)
            {
                // we only want to modify the state of the view source item
                // if it isn't restricted by the IEAK. if it's restricted, we
                // need to leave it disabled regardles of what the object
                // we're hosting says

                HRESULT hr = _pmsot->QueryStatus(&CGID_MSHTML, ARRAYSIZE(rgcmd2), rgcmd2, NULL);
        
                _EnableMenuItem(hmInit, DVIDM_MSHTML_FIRST + rgcmd2[0].cmdID, 
                    SUCCEEDED(hr) && (rgcmd2[0].cmdf & OLECMDF_ENABLED));
            }
        }

    }
    else if (GetMenuFromID(_hmenuCur, FCIDM_MENU_FILE) == hmInit)
    {
        if (_pmsot)
        {
            TraceMsg(0, "sdv TR _OnInitMenuPopup : step 5");
            OLECMD rgcmds[] = {
                { OLECMDID_PRINT, 0 },
                { OLECMDID_PAGESETUP, 0 },
                { OLECMDID_PROPERTIES, 0 },
                { OLECMDID_SAVE, 0 },
                { OLECMDID_SAVEAS, 0 },
                { OLECMDID_PRINTPREVIEW, 0 },
            };

            _pmsot->QueryStatus(NULL, ARRAYSIZE(rgcmds), rgcmds, NULL);

            // Adding a comment for my sanity: we use SHDVID_PRINTFRAME instead
            // of OLECMDID_PRINT because IE40 is going to support the printing
            // of entire framesets, instead of the current behavior or forwarding
            // the command to the active frame.
            //
            OLECMD rgcmds1[] = {
                { SHDVID_PRINTFRAME, 0 },
            };

            _pmsot->QueryStatus(&CGID_ShellDocView, ARRAYSIZE(rgcmds1), rgcmds1, NULL);

            //
            //  If OLECMDID_SAVEAS is not supported (neither ENABLED nor
            // SUPPORTED is set) by the DocObject, check if the object
            // support IPersistFile. If it does, enable it. Note that
            // this mechanism allows the DocObject to disable this menu
            // item (by setting only OLECMDF_SUPPORTED). (SatoNa)
            //
            ASSERT(rgcmds[4].cmdID == OLECMDID_SAVEAS);

            // Only apply the save as restriction to the browser. If it is the
            // browser, and save as is restricted, then make the item disappear.
            if ( (_dwAppHack & BROWSERFLAG_MSHTML) &&
                 SHRestricted2( REST_NoBrowserSaveAs, NULL, 0 ))
                rgcmds[4].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);
            else if (!(rgcmds[4].cmdf & (OLECMDF_ENABLED | OLECMDF_SUPPORTED)))
            {
                IPersistFile* ppf;
                ASSERT(_pole);
                HRESULT hresT = _pole->QueryInterface(IID_IPersistFile, (void **)&ppf);
                if (SUCCEEDED(hresT))
                {
                    TraceMsg(DM_APPHACK, "APPHACK DOH Enabling SaveAs menu for Excel95");
                    rgcmds[4].cmdf |= OLECMDF_ENABLED;
                    ppf->Release();
                }
            }

            if (SHRestricted2(REST_NoPrinting, NULL, 0))
            {
                rgcmds[0].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);   // print
                rgcmds[1].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);   // page setup
                rgcmds[5].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);   // print preview
            }

            //
            // APPHACK: Office apps do not enable "Save" correctly.
            //  Automatically enable it if the moniker is a FILE moniker
            //  AND the document has been altered by the user.
            //
            if (_fFileProtocol && _IsDirty(NULL))
            {
                if (!(rgcmds[3].cmdf & OLECMDF_ENABLED))
                {
                    TraceMsg(DM_APPHACK, "APPHACK DOH Enabling Save for Office Apps");
                }
                rgcmds[3].cmdf |= OLECMDF_ENABLED;
            }

            // Remove/disable/enable the "Print" command as appropriate.
            // Excel doesn't set SUPPORTED bit when it sets ENABLED bit
            // so we have to check both bits.
            _EnableRemoveMenuItem(hmInit, rgcmds[0].cmdf, DVIDM_PRINT);

            _EnableMenuItem(hmInit, DVIDM_PAGESETUP,
                    (rgcmds[1].cmdf & OLECMDF_ENABLED));
            _EnableMenuItem(hmInit, DVIDM_PROPERTIES,
                    (rgcmds[2].cmdf & OLECMDF_ENABLED));

            _EnableRemoveMenuItem(hmInit, rgcmds[3].cmdf, DVIDM_SAVE);
            _EnableRemoveMenuItem(hmInit, rgcmds[4].cmdf, DVIDM_SAVEASFILE);
            _EnableRemoveMenuItem(hmInit, rgcmds[5].cmdf, DVIDM_PRINTPREVIEW);
            _EnableRemoveMenuItem(hmInit, rgcmds1[0].cmdf, DVIDM_PRINTFRAME);


            HMENU hmFileNew = SHGetMenuFromID(hmInit, DVIDM_NEW);

            if (hmFileNew) 
            {
                const static struct {
                    LPCTSTR pszClient;
                    UINT idCmd;
                } s_Clients[] = {
                    { NEW_MAIL_DEF_KEY, DVIDM_NEWMESSAGE },
                    { NEW_CONTACTS_DEF_KEY, DVIDM_NEWCONTACT },
                    { NEW_NEWS_DEF_KEY, DVIDM_NEWPOST },
                    { NEW_APPOINTMENT_DEF_KEY, DVIDM_NEWAPPOINTMENT },
                    { NEW_MEETING_DEF_KEY, DVIDM_NEWMEETING },
                    { NEW_TASK_DEF_KEY, DVIDM_NEWTASK },
                    { NEW_TASKREQUEST_DEF_KEY, DVIDM_NEWTASKREQUEST },
                    { NEW_JOURNAL_DEF_KEY, DVIDM_NEWJOURNAL },
                    { NEW_NOTE_DEF_KEY, DVIDM_NEWNOTE },
                    { NEW_CALL_DEF_KEY, DVIDM_CALL }
                };

                BOOL bItemRemoved = FALSE;

                for (int i = 0; i < ARRAYSIZE(s_Clients); i++)
                {
                    if (!SHIsRegisteredClient(s_Clients[i].pszClient))
                    {
                        if (RemoveMenu(hmFileNew, s_Clients[i].idCmd, MF_BYCOMMAND))
                          bItemRemoved = TRUE;
                    }
                }

                // Menu item "File/New/Window Ctrl+N" needs to be disabled if the restriction is set
                if( SHRestricted2W(REST_NoOpeninNewWnd, NULL, 0))
                {
                    EnableMenuItem(hmFileNew, DVIDM_NEWWINDOW, MF_BYCOMMAND | MF_GRAYED);
                }

                if (bItemRemoved) // ensure the last item is not a separator
                    _SHPrettyMenu(hmFileNew);
            }
        }
    }
    else if (GetMenuFromID(_hmenuCur, FCIDM_VIEWFONTS) == hmInit
            || GetMenuFromID(_hmenuCur, FCIDM_ENCODING) == hmInit)
    {
        if (_pmsot)
        {
            // Handling fonts popup in view menu
            OLECMD rgcmd[] = {
                { SHDVID_GETFONTMENU,  0 },
                { SHDVID_GETMIMECSETMENU, 0 },
            };

            _pmsot->QueryStatus(&CGID_ShellDocView, ARRAYSIZE(rgcmd), rgcmd, NULL);

            int idx = (GetMenuFromID(_hmenuCur, FCIDM_VIEWFONTS) == hmInit ? 0 : 1);

            if (rgcmd[idx].cmdf & OLECMDF_ENABLED)
            {
                VARIANTARG v = {0};
                HRESULT hr;

                hr = _pmsot->Exec(&CGID_ShellDocView, rgcmd[idx].cmdID, 0, NULL, &v);
                if (S_OK == hr)
                {
                    // (on NT/Unix) DestroyMenu(hmInit) shouldn't work, because
                    // we're inside the processing of WM_INITMENUPOPUP message
                    // for hmInit. DestroyMenu will make the hmInit handle
                    // invalid.
                    //
                    // Instead of that we'll empty hmInit and copy hmenuFonts
                    // over. hmenuFonts will be destroyed to prevent the
                    // memory leak.
                    //
                    //
                    MENUITEMINFO mii;
                    UINT uItem = 0;
//$ WIN64: mshtml\src\site\base\formmso.cxx needs to return VT_INT_PTR instead
//                  HMENU hmenuFonts = (HMENU)v.byref;
                    HMENU hmenuFonts = (HMENU)LongToHandle(v.lVal);

#ifndef UNIX
                    // deleting menu while processing WM_INITMENUPOPUP
                    // can cause assertion failure on NT. However, copying
                    // submenu using InsertMenuItem() doesn't work on Win9x.
                    // see the comments above and Menu_Replace() in menu.cpp
                    //
                    if (!g_fRunningOnNT)
                        DestroyMenu(hmInit);
#endif

                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID|MIIM_SUBMENU;
                    while (GetMenuItemInfo(hmenuFonts, uItem, TRUE, &mii))
                    {
                        if (idx == 1 && mii.hSubMenu != NULL)
                        {
                            UINT uItemSub = 0;
                            HMENU hMenuSub = mii.hSubMenu;
                            while (GetMenuItemInfo(hMenuSub, uItemSub, TRUE, &mii))
                            {
                                mii.wID += DVIDM_MSHTML_FIRST;
                                SetMenuItemInfo(hMenuSub, uItemSub++, TRUE, &mii);
                            }
                        }
                        else
                        {
                            mii.wID += DVIDM_MSHTML_FIRST;
                            SetMenuItemInfo(hmenuFonts, uItem, TRUE, &mii);
                        }
                        uItem++;
                    }

#ifndef UNIX
                    if (!g_fRunningOnNT)
                    {
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_SUBMENU;
                        mii.hSubMenu = hmenuFonts;
                        SetMenuItemInfo(_hmenuCur,
                                       (idx == 0 ? FCIDM_VIEWFONTS:FCIDM_ENCODING),
                                        FALSE, &mii);
                    }
                    else
#endif
                    {
                        Menu_Replace(hmInit, hmenuFonts);
                        DestroyMenu(hmenuFonts);
                    }
                }
            }
        }
    }
    else  if (GetMenuFromID(_hmenuCur, FCIDM_MENU_TOOLS) == hmInit ||
              GetMenuFromID(_hmenuCur, FCIDM_MENU_HELP) == hmInit)
    {
        // Add Tools and help Menu Extensions
        if (_pBrowsExt)
        {
            _pBrowsExt->OnCustomizableMenuPopup(_hmenuCur, hmInit);
        }
    }
}

//
// ATTEMPT: Handling WM_SETFOCUS message here caused several problems
//  under IE 3.0. Since we can't find any code scenario that requires
//  this code, I'm yanking out. If might introduce a new bug, but dealing
//  with those bugs is probably better than dealing with this code.
//  (SatoNa)
//

/*----------------------------------------------------------
Purpose: Determines if this message should be forwarded onto
         the object.

Returns: TRUE if the message needs to be forwarded
*/
BOOL CDocObjectHost::_ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_MENUSELECT:
    {
        // In USER menu bars, the first menuselect will be sent for the
        // selected top-level menu item, in which case hmenu == _hmenuCur.
        // We expect menubands to behave similarly.
        //
        // We check that hmenu == _hmenuCur because we only keep a list
        // of the top-level popup menus.  We don't keep track of any
        // cascading submenus.  We should only need to check who owns
        // the menu at the initial popup, all subsequent messages for
        // that menu should go to the same destination (frame or object).
        //
        // The same goes for CShellBrowser::_ShouldForwardMenu().
        //
        HMENU hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
        if (hmenu && (MF_POPUP & GET_WM_MENUSELECT_FLAGS(wParam, lParam)))
        {
            HMENU hmenuSub = GetSubMenu(hmenu, GET_WM_MENUSELECT_CMD(wParam, lParam));

            if (hmenu == _hmenuCur)
            {
                // Normal case, where we just look at the topmost popdown menus
                _fForwardMenu = _menulist.IsObjectMenu(hmenuSub);
            }
            else if (_menulist.IsObjectMenu(hmenuSub))
            {
                // This happens if the cascading submenu (micro-merged help menu for
                // example) should be forwarded on, but the parent menu should
                // not.
                _fForwardMenu = TRUE;
            }
            else if (GetMenuFromID(_hmenuCur, FCIDM_MENU_HELP) == hmenu 
                     && !_menulist.IsObjectMenu(hmenu) )
            {
                // 80430 Appcompat: notice that our menu fowarding doesn't work for the 
                // micro-merged Help menu.  If the user previously selected the merged
                // submenu, and we end up here, it means a non-merged submenu was just
                // selected and our _fForwardMenu was still set to TRUE.  If we don't 
                // reset it, the next WM_INITMENUPOPUP gets forwarded, which crashes Visio.
                //
                // We know that a submenu of the Help menu has just popped up, and we know
                // the submenu belongs to us.  So don't forward to the docobj until the
                // next popup.

                _fForwardMenu = FALSE;
            }
        }
        break;
    }

    case WM_COMMAND:
        if (_fForwardMenu)
        {
            // Stop forwarding menu messages after WM_COMMAND
            _fForwardMenu = FALSE;

            // If it wasn't from an accelerator, forward it
            if (0 == GET_WM_COMMAND_CMD(wParam, lParam))
                return TRUE;
        }
        break;
    }
    return _fForwardMenu;
}


/*----------------------------------------------------------
Purpose: Forwards messages to the in-place object.

         This is used to forward menu messages to the object for
         menu bands, since the menu bands do not work with the
         standard OLE FrameFilterWndProc.

         Also, the help menu is sometimes a combination of the
         object and the frame.  This function will forward as
         appropriate.

*/
LRESULT CDocObjectHost::_ForwardObjectMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;
    IOleInPlaceActiveObject *piact = _xao.GetObject();
    ASSERT(IS_VALID_CODE_PTR(piact, IOleInPlaceActiveObject));

    if (piact)
    {
        HWND hwnd;

        piact->GetWindow(&hwnd);
        ASSERT(IS_VALID_HANDLE(hwnd, WND));

        if (hwnd)
        {
            if (uMsg == WM_COMMAND)
                PostMessage(hwnd, uMsg, wParam, lParam);
            else
                lRet = SendMessage(hwnd, uMsg, wParam, lParam);
        }
    }

    return lRet;
}


void CDocObjectHost::_OnMenuSelect(UINT id, UINT mf, HMENU hmenu)
{
    if (_psb)
    {
        if (IsInRange(id, DVIDM_MSHTML_FIRST, DVIDM_MSHTML_LAST))
        {
            if (_pcmdMergedMenu) {
                OLECMD rgcmd = { id - DVIDM_MSHTML_FIRST, 0 };
                struct {
                    OLECMDTEXT  cmdtxt;
                    WCHAR       szExtra[MAX_PATH];
                } cmdt;

                cmdt.cmdtxt.cmdtextf = OLECMDTEXTF_STATUS;
                cmdt.cmdtxt.cwActual = 0;
                cmdt.cmdtxt.cwBuf    = MAX_PATH;
                cmdt.cmdtxt.rgwz[0]  = 0;

                HRESULT hresT=_pcmdMergedMenu->QueryStatus(&CGID_MSHTML, 1, &rgcmd, &cmdt.cmdtxt);
                if (SUCCEEDED(hresT) && cmdt.cmdtxt.rgwz[0]) {
                    _psb->SetStatusTextSB(cmdt.cmdtxt.rgwz);
                } else {
                    TraceMsg(DM_ERROR, "CDOH::_OnMenuSelect QueryStatus failed %x %d",
                        hresT, cmdt.cmdtxt.cwActual);
                }
            }
            else
                // An ASSERT was replaced with this TraceMsg to allow testing on Win9x.
                // 70240 which reported the assert was pushed to IE6.
                TraceMsg(TF_WARNING, "CDocObjectHost::_OnMenuSelect   _pcmdMergedMenu == NULL");
        }
        else if (IsInRange(id, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
        {
            // Menu Extensions go here
            if (_pBrowsExt)
            {
                _pBrowsExt->OnMenuSelect(id);
            }
        }
        else
        {
            WCHAR wszT[MAX_STATUS_SIZE];
            if (MLLoadStringW(IDS_HELP_OF(id), wszT, ARRAYSIZE(wszT)))
            {
                _psb->SetStatusTextSB(wszT);
            }
        }
    }
}

LRESULT CDocObjectHost::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;

    switch(uMsg)
    {
    case WM_TIMER:
        if (wParam == IDTIMER_PROGRESS)
        {
            _OnSetProgressPos(0, PROGRESS_TICK);
            break;
        }
        else if (wParam == IDTIMER_PROGRESSFULL)
        {
            _OnSetProgressPos(-2, PROGRESS_RESET);
            break;
        }
        else
        {
#ifdef TEST_DELAYED_SHOWMSOVIEW
            MessageBeep(0);
            KillTimer(_hwnd, 100);
            ActivateMe(NULL);
            break;
#else
            ASSERT(FALSE);
            break;
#endif // TEST_DELAYED_SHOWMSOVIEW
        }

    /* WM_PICS_ASYNCCOMPLETE is posted by the async thread fetching ratings
     * from label bureaus, etc.
     */
    case WM_PICS_ASYNCCOMPLETE:
    {
        TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_ASYNCCOMPLETE");

        PicsQuery pq;
        HRESULT hr;
        LPVOID lpvRatingDetails;
        DWORD dwSerialComplete = (DWORD)lParam;
        CPicsProcessor * pPicsProc = NULL;

        if (::_GetPicsQuery(dwSerialComplete, &pq)) {
            ::_RemovePicsQuery(dwSerialComplete);
            hr = (HRESULT)wParam;
            lpvRatingDetails = pq.lpvRatingDetails;
        }
        else {
            hr = E_FAIL;
            lpvRatingDetails = NULL;
        }

        pPicsProc = _GetPicsProcessorFromSerialNumber(dwSerialComplete);
        
        if (pPicsProc)
        {
            pPicsProc->_GotLabel(hr, lpvRatingDetails, PICS_WAIT_FOR_ASYNC);
        }
        else
        {
            TraceMsg( DM_PICS, "CDOH::v_WndProc no PicsProc for ASYNCCOMPLETE %x", dwSerialComplete);

            if ( lpvRatingDetails )
            {
                ::RatingFreeDetails(lpvRatingDetails);
                lpvRatingDetails = NULL;
            }
        }

        break;
    }

    case WM_PICS_ROOTDOWNLOADCOMPLETE:
    {
        TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_ROOTDOWNLOADCOMPLETE %x", lParam);

        if (_PicsProcBase._pRootDownload != NULL) 
        {
            _PicsProcBase._pRootDownload->CleanUp();
            ATOMICRELEASET(_PicsProcBase._pRootDownload,CPicsRootDownload);
        }

        break;
    }

    /* WM_PICS_ALLCHECKSCOMPLETE is posted when we finally want to either
     * cancel the navigation or go through with it, according to ratings
     * checks.  Posting a message allows all denial blocking message loops
     * to unwind before we cancel navigation, which could otherwise delete
     * objects that still have functions operating on them.
     */
    case WM_PICS_ALLCHECKSCOMPLETE:
        TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_ALLCHECKSCOMPLETE, lParam=%x", lParam);

        if (lParam == IDOK) {
            if (!_fSetTarget)
            {
                TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_ASYNCCOMPLETE) execing SHDVID_ACTIVATEMENOW");
                _pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_ACTIVATEMENOW, NULL, NULL, NULL);
            }
            else {
                TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_ASYNCCOMPLETE) not execing SHDVID_ACTIVATEMENOW");
            }
        }
        else {
            ASSERT(!_fSetTarget);
            TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_ASYNCCOMPLETE) calling _CancelPendingNavigation");
            _CancelPendingNavigation(FALSE);
//        _pmsoctBrowser->Exec(NULL, OLECMDID_STOP, NULL, NULL, NULL);
        }
        break;

    /* WM_PICS_DOBLOCKINGUI is posted when we decide we need to put up
     * denial UI.  Posting a message allows download of this object and
     * other frames to continue while we post the UI, which in turn allows
     * any denials from other frames to be coalesced into the one dialog.
     */
    case WM_PICS_DOBLOCKINGUI:
        {
            TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_DOBLOCKINGUI %x", lParam);

            CPicsProcessor * pPicsProc = _GetPicsProcessorFromKey(lParam);

            if (pPicsProc)
            {
                UINT id = pPicsProc->_PicsBlockingDialog();

                if (pPicsProc->_pPrivWindow)
                {
                    ASSERT( _fDocCanNavigate );
                    TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) posting WM_PICS_RESULTTOPRIVWIN");
                    if (!PostMessage( _hwnd, WM_PICS_RESULTTOPRIVWIN, id, lParam))
                    {
                        TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) couldn't post message!");
                    }
                }
                else
                {
                    TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) posting WM_PICS_ALLCHECKSCOMPLETE");
                    if (!PostMessage(_hwnd, WM_PICS_ALLCHECKSCOMPLETE, 0, id)) 
                    {
                        TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) couldn't post message!");
                    }
                }

                // We may have been terminated while the
                // dialog was up -- finish cleaning up here.
                if (   !pPicsProc->_fInDialog 
                    &&  pPicsProc->_fTerminated 
                    &&  pPicsProc != &_PicsProcBase)
                {
                    delete pPicsProc;
                }

            }
            else
            {
                TraceMsg( DM_PICS, "CDOH::v_WndProc no PicsProc for DOBLOCKINGUI");
            }
        }
        break;

    case WM_PICS_RESULTTOPRIVWIN:
        {
            ASSERT( _fDocCanNavigate );

            TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_RESULTTOPRIVWIN %x", lParam);

            CPicsProcessor * pPicsProc = _GetPicsProcessorFromKey(lParam);

            if (pPicsProc)
            {
                ASSERT( pPicsProc->_pPrivWindow );

                IHTMLPrivateWindow * pPrivWindow = pPicsProc->_pPrivWindow;
                pPrivWindow->AddRef();

                if (pPicsProc->_pRootDownload != NULL) 
                {
                    pPicsProc->_pRootDownload->CleanUp();
                    ATOMICRELEASET(pPicsProc->_pRootDownload,CPicsRootDownload);
                }

                // Remove ourselves from the list
                _RemovePicsProcessorByKey( lParam );

                // Make Trident let go of our command target
                pPrivWindow->SetPICSTarget(NULL);

                // Tell the window the answer
                pPrivWindow->PICSComplete( wParam == IDOK );

                pPrivWindow->Release();
            }
            else
            {
                TraceMsg( DM_PICS, "CDOH::v_WndProc no PicsProc for WM_PICS_RESULTTOPRIVWIN");
            }
        }
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        MessageBeep(0);
        break;


    case WM_MENUSELECT:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            lRet = _ForwardObjectMsg(uMsg, wParam, lParam);
        else
        {
            UINT uMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
            WORD wID = GET_WM_MENUSELECT_CMD(wParam, lParam);
            HMENU hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);

            // Check for popup menus so we can display help strings for them
            if (uMenuFlags & MF_POPUP)
            {
                MENUITEMINFO miiSubMenu;

                miiSubMenu.cbSize = SIZEOF(MENUITEMINFO);
                miiSubMenu.fMask = MIIM_SUBMENU|MIIM_ID;
                if (GetMenuItemInfoWrap(hMenu, wID, TRUE, &miiSubMenu))
                {
                    // Change the parameters to simulate a "normal" menu item
                    wID = (WORD)miiSubMenu.wID;
                }
            }

            _OnMenuSelect(wID, uMenuFlags, hMenu);
        }
        break;

    case WM_INITMENUPOPUP:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            lRet = _ForwardObjectMsg(uMsg, wParam, lParam);
        else
            _OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            lRet = _ForwardObjectMsg(uMsg, wParam, lParam);
        else
            goto DoDefault;
        break;

    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        break;

    case WM_COMMAND:
        _OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        break;

    case WM_SIZE:
        if (_pmsov)
        {
            RECT rcClient;
            GetClientRect(_hwnd, &rcClient);
            //
            // We should call ResizeBorder only if the browser is
            // not an IOleInPlaceUIWindow.
            //
            if (_pipu==NULL)
            {
                TraceMsg(TF_SHDUIACTIVATE, "DOH::WM_SIZE calling _piact->ResizeBorder");
                _xao.ResizeBorder(&rcClient, &_dof, TRUE);
            }

            _rcView.left = _bwTools.left;
            _rcView.top = _bwTools.top;
            _rcView.right = rcClient.right - _bwTools.right;
            _rcView.bottom = rcClient.bottom - _bwTools.bottom;

            TraceMsg(TF_SHDUIACTIVATE, "DOH::WM_SIZE calling SetRect (%d, %d, %d, %d)", _rcView.left, _rcView.top, _rcView.right, _rcView.bottom);
            _pmsov->SetRect(&_rcView);
        }

        _PlaceProgressBar(TRUE);

        break;

//
// ATTEMPT: Handling WM_SETFOCUS message here caused several problems
//  under IE 3.0. Since we can't find any code scenario that requires
//  this code, I'm yanking out. If might introduce a new bug, but dealing
//  with those bugs is probably better than dealing with this code.
//  (SatoNa)
//

    case WM_PRINT:
        _OnPaint((HDC)wParam);
        break;

    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
    case WM_ENTERSIZEMOVE:
    case WM_EXITSIZEMOVE:
    {
        HWND hwndT;
        if (_pole && SUCCEEDED(IUnknown_GetWindow(_pole, &hwndT)) && hwndT)
            return SendMessage(hwndT, uMsg, wParam, lParam);
        return 0;
    }

    case WM_PAINT:
        PAINTSTRUCT ps;
        HDC hdc;
        hdc = BeginPaint(_hwnd, &ps);

        // we don't need them to paint into our dc...
        // docobj has own hwnd.
        //_OnPaint(hdc);

        EndPaint(_hwnd, &ps);
        break;

    case WM_LBUTTONUP:
        if (_uState != SVUIA_ACTIVATE_FOCUS) {
            SetFocus(_hwnd);
        }
        break;

    case WM_ERASEBKGND:
        // Checking _bsc._fBinding will catch the first page case.
        
        if (_fDrawBackground ||
            (!(_dwAppHack & BROWSERFLAG_NEVERERASEBKGND)
             && ((_pmsov && _uState!=SVUIA_DEACTIVATE)
                 || _bsc._fBinding)))
        {
            PAINTMSG("WM_ERASEBKGND", this);
            goto DoDefault;
        }
        
        // Don't draw WM_ERASEBKGND if we have no view activated.
        return TRUE; // TRUE = fErased

    case WM_HELP:
        //
        // Give it to the parent to do.  we need to do this in case we're hosted as a
        // control
        //
    {
        IOleCommandTarget *pcmdtTop;
        if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (void **)&pcmdtTop))) {
            pcmdtTop->Exec(&CGID_ShellDocView, SHDVID_HELP, 0, NULL, NULL);
            pcmdtTop->Release();
        }
        // do nothing in failure...  let the parent own completely
    }
        break;

    case WM_WININICHANGE:
        _PlaceProgressBar(TRUE);
        break;

    default:
        // Handle the MSWheel message
        if ((uMsg == GetWheelMsg()) && _pole)
        {
            HWND hwndT;

            // If for some reason our window has focus we just need to
            // swallow the message. If we don't we may create an infinite loop
            // because most clients send the message to the focus window.
            if (GetFocus() == _hwnd)
                return 1;

            //
            // try to find a window to forward along to
            //
            if (SUCCEEDED(IUnknown_GetWindow(_pole, &hwndT)))
            {
                PostMessage(hwndT, uMsg, wParam, lParam);
                return 1;
            }
            // Fall through...
        }
DoDefault:

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lRet;
}

const TCHAR c_szViewClass[] = TEXT("Shell DocObject View");

void CDocObjectHost::_RegisterWindowClass(void)
{
    WNDCLASS wc = {0};

    wc.style         = CS_PARENTDC;
    wc.lpfnWndProc   = s_WndProc ;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(CDocObjectHost*);
    wc.hInstance     = g_hinst ;
    //wc.hIcon         = NULL ;
    //wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    //wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szViewClass;

    SHRegisterClass(&wc);

}

void CDocObjectHost::_InitOleObject()
{
    if (!_fClientSiteSet)
    {
        _fClientSiteSet = TRUE;

#ifdef DEBUG
        IOleClientSite * pcliT = NULL;

        if (SUCCEEDED(_pole->GetClientSite(&pcliT)) && pcliT)
        {
            // Trident now grabs the client site from the bind context.
            // We don't want to hit this assertin this case (pcliT==this).
            //
            AssertMsg(IsSameObject(pcliT, SAFECAST(this, IOleClientSite*)),
                      TEXT("CDocObjectHost::_InitOleObject _pole (%x) already has a client site (%x) (this=%x)"),
                      _pole, pcliT, this);

            pcliT->Release();
        }
#endif

        HRESULT hresT = _pole->SetClientSite(this);

        if (FAILED(hresT))
        {
            TraceMsg(TF_SHDAPPHACK, "DOH::_InitOleObject SetClientSite failed (%x). Don't in-place navigate", hresT);
            _dwAppHack |= BROWSERFLAG_DONTINPLACE;
        }

        ASSERT(NULL==_pvo);

        _pole->QueryInterface(IID_IViewObject, (void **)&_pvo);

        if (_pvo)
        {
            TraceMsg(DM_DEBUGTFRAME, "CDocObjectHost::_InitOleObject about call SetAdvise on %x (%x)", _pole, this);
            _pvo->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, this);
        }
        //
        //  According to SteveRa (Word developer), a word object has an
        // internal flag which indicates whether or not it is created
        // from a file. If that flag is set, UIActivate will open the
        // window in Word. Calling SetHostName will reset that flag.
        //
        _GetAppHack(); // Make it sure that we have _dwAppHack

        if (_fCallSetHostName())
        {
            TraceMsg(TF_SHDAPPHACK, "DOH::_InitOleObject calling SetHostName for Word95");

            WCHAR wszTitle[128];
            MLLoadStringW(IDS_TITLE, wszTitle, ARRAYSIZE(wszTitle));

            _pole->SetHostNames(wszTitle, wszTitle);
        }
    }
}

BOOL CDocObjectHost::_OperationIsHyperlink()
{
    _ChainBSC();

    DWORD dw = 0;
    BINDINFO bindinfo;

    ZeroMemory(&bindinfo, sizeof(BINDINFO));
    bindinfo.cbSize = sizeof(BINDINFO);

    HRESULT hr = _bsc.GetBindInfo(&dw, &bindinfo);

    if (SUCCEEDED(hr))
    {
        ReleaseBindInfo(&bindinfo);
        return BOOLIFY(dw & BINDF_HYPERLINK);
    }

    return FALSE;
}


//+-----------------------------------------------------------------------------
//
// IE Media Bar hook
// -----------------
// At least one and only one of the args must be non-null.
//
// If pbc is non-null:
//  If this bind ctx is for a media url and was delegated to shdocvw from trident,
//  trident has already stored the mime-type as a string on the bind ctx.
//
// If pwzMimeType is non-null:
//  The given mime type is used
// 
// Ask the media bar if it wants to handle this mime-type and if it does,
// return true, else return false.
//
//-------------------------------------------------------------------------------
BOOL CDocObjectHost::_DelegateToMediaBar(IBindCtx * pbc, LPCWSTR pwzMimeType)
{
    USES_CONVERSION;

    LPWSTR pstrMime  = NULL;
    TCHAR szURL[MAX_URL_STRING];
    BOOL fRet = FALSE;
    CComVariant svarMime(pstrMime);

    CComPtr<IUnknown>           spUnkObj;
    CComPtr<IOleCommandTarget>  spOCTMimeType;
    CComPtr<IOleCommandTarget>  spOCTMediaBar;

    // We want to delegate only under the following conditions:
    // 1. In Explorer or IE
    // 2. If autoplay is enabled
    // 3. If autoplay is not turned off for the first navigation
    // 4. If NOT NT4 or IA64 (WMP7/8 doesn't support these platforms)
    // 5. If WMP7/8 is present (if it isn't, we will try to fault-in once.)
    // 6. the media bar isn't restricted
    if (!(IsInternetExplorerApp() 
          && CMediaBarUtil::GetAutoplay()
          && !SHRestricted2(REST_No_LaunchMediaBar, NULL, 0)
          && CMediaBarUtil::IsWMP7OrGreaterCapable()
          && FAILED(QueryService(CLSID_MediaBand, IID_PPV_ARG(IUnknown, &spUnkObj)))))
    {
        goto done;
    }

    // release so we can reuse the pointer later
    spUnkObj.Release();

    // get the current URL
    if (FAILED(_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE)))
        goto done;

    // At least one and only one of the args must be non-null.
    if (pbc && !pwzMimeType)
    {
        // get the custom parameter that trident uses to set the media mime-type
        // QI for IOleCommandTarged to access the mime-type string. 
        // get the mime-type string
        if (FAILED(pbc->GetObjectParam(L"MediaBarMime", &spUnkObj))
           || FAILED(spUnkObj->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &spOCTMimeType)))
           || FAILED(spOCTMimeType->Exec(&CGID_DownloadObjectBindContext, 0, NULL, NULL, &svarMime)))
            goto done;
    }
    else if (!pbc && pwzMimeType)
    {
        svarMime = pwzMimeType;
    }
    else
    {
        ASSERT(FALSE && L"Either one of bind ctx or mime-type is expected"); 
        goto done;
    }

    // proceed only if mime type string is available
    if ((VT_BSTR == svarMime.vt)
       && svarMime.bstrVal)
    {
        // Ask the media bar if it wants to handle this mime-type
        BOOL fShouldPlay = FALSE;
        BOOL fShow = TRUE;
        CComVariant svarUrl;
        HRESULT hr = S_OK;
        
        svarUrl = !StrCmpNIW(WZ_RADIO_PROTOCOL, szURL, wcslen(WZ_RADIO_PROTOCOL)) ? (szURL + wcslen(WZ_RADIO_PROTOCOL)) : szURL;

        if (!(V_BSTR(&svarMime) && V_BSTR(&svarUrl)))
            goto done;

        // check if we can play this mime type
        hr = CMediaBarUtil::ShouldPlay(W2T(V_BSTR(&svarMime)), &fShouldPlay);
        if (FAILED(hr) 
           || (!fShouldPlay))
        {
            goto done;
        }

        // ShouldPlay returns S_FALSE if this is the first time playing this mime type.
        if (S_FALSE == hr)
        {
            BOOL bSaveSetting = FALSE;
            LONGLONG iRetCode = PLAYMIME_NO;

            iRetCode = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_MEDIA_MIME), _hwnd, s_MimeDlgProc, NULL);

            switch (iRetCode)
            {
                case PLAYMIME_YES:
                {
                    fShouldPlay = TRUE;
                    bSaveSetting = FALSE;
                }
                break;

                case PLAYMIME_YESSAVE:
                {
                    fShouldPlay = TRUE;
                    bSaveSetting = TRUE;
                }
                break;
        
                case PLAYMIME_NO:
                {
                    fShouldPlay = FALSE;
                    bSaveSetting = FALSE;
                }
                break;
        
                case PLAYMIME_NOSAVE:
                {
                    fShouldPlay = FALSE;
                    bSaveSetting = TRUE;
                }
                break;
        
                default:
                {
                    ASSERT(FALSE && L"Unexpected return value");
                }
                break;
            }

            // check if the setting needs to be saved
            if (TRUE == bSaveSetting)
            {
                DWORD dwVal = fShouldPlay ? 0x1 : 0x0;

                hr = CMediaBarUtil::SetMediaRegValue(V_BSTR(&svarMime), REG_BINARY, (void*) &dwVal, (DWORD) 1, TRUE);     
                ASSERT(SUCCEEDED(hr));
            }

            // Bail if user told us not to play this mime type
            if (!fShouldPlay)
                goto done;
        }
        else
        {
            // "don't prompt" means "play all types", unless autoplay is turned off
            // in which case we have already bailed
        }

        // Yay. They want to try out our feature. But WAIT. We need WMP7/8. Is that installed? No? Well, let's go get it.
        // If the user decides _not_ to install WMP7, though, we should disable ourselves.
        if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
        {
            if (!IsOS(OS_WHISTLERORGREATER))
            {
                // Here we do the stuff to web-jit WMP7. ISSUE: We assume that it'll always be on Whistler
                uCLSSPEC ucs;
                QUERYCONTEXT qc = { 0 };

                ucs.tyspec = TYSPEC_CLSID;
                ucs.tagged_union.clsid = CLSID_JITWMP8;

                hr = FaultInIEFeature(_hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
            }
            if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
            {
                // We give up. Delegate. We'll never try autoplay again.
                MLShellMessageBox(_hwnd, MAKEINTRESOURCE(IDS_MEDIABAR_NOWMP7), MAKEINTRESOURCE(IDS_MEDIABAR_NOWMP7TITLE), MB_OK);
                CMediaBarUtil::ToggleAutoplay(FALSE);
                goto done;
            }
        }

        // QS for the media bar
        if (FAILED(QueryService(SID_SMediaBar, IID_PPV_ARG(IOleCommandTarget, &spOCTMediaBar))))
        {
            // The media bar may not have been created yet
            _ForceCreateMediaBar();

            // QS for the media bar once again
            if (FAILED(QueryService(SID_SMediaBar, IID_PPV_ARG(IOleCommandTarget, &spOCTMediaBar))))
                goto done;

            fShow = FALSE;
        }

        hr = IUnknown_Exec(spOCTMediaBar, &CGID_MediaBar, MBID_PLAY, 0, &svarMime, &svarUrl);
        ASSERT(SUCCEEDED(hr));

        // The Media Bar clears the URL if it accepts the navigation
        if (VT_BSTR != svarUrl.vt)
        {
            // Cancel the navigation
            fRet = TRUE; 

            // Ensure that the media bar is visible
            if (fShow)
            {
                CComVariant svarPopout;
                if (SUCCEEDED(IUnknown_Exec(spOCTMediaBar, &CGID_MediaBar, MBID_POPOUT, 0, NULL, &svarPopout))
                   && ((VT_BOOL!=svarPopout.vt)
                       || (VARIANT_FALSE==svarPopout.boolVal)))
                {
                    _ForceCreateMediaBar();
                }
            }
        }
    }

done:
    return fRet;
}


//+---------------------------------------------------------------------------------
//
// IE Media Bar Hook
// ------------------
// 
// Force the Media Bar to be displayed
//
//----------------------------------------------------------------------------------
void CDocObjectHost::_ForceCreateMediaBar()
{
    IUnknown_ShowBrowserBar(_psp, CLSID_MediaBand, TRUE);
}

//+---------------------------------------------------------------------------------
//
// IE Media Bar Hook
// ------------------
// 
// Dialog proc for Media Bar per-mime-type dialog
//
//----------------------------------------------------------------------------------

INT_PTR CALLBACK 
CDocObjectHost::s_MimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT id;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, IDC_MEDIA_MIME_CHKBOX, TRUE);  // The first option is always checked
            if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
            {
                TCHAR szTemp[500];
                if (MLLoadString(IDS_MEDIABAR_NEEDWMP7, szTemp, ARRAYSIZE(szTemp)))
                {
                    SetDlgItemText(hDlg, IDC_MEDIABAR_EXTRA, szTemp);
                }
            }
            return TRUE;

        case WM_DESTROY:
            return FALSE;

        case WM_COMMAND:
        {
            id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id) 
            {
                case IDOK:
                {
                    if (IsDlgButtonChecked(hDlg, IDC_MEDIA_MIME_CHKBOX))
                    {
                        id = PLAYMIME_YESSAVE;
                    }
                    else
                    {
                        id = PLAYMIME_YES;
                    }

                    EndDialog(hDlg, id);
                }
                break;

                case IDCANCEL:
                {
                    if (IsDlgButtonChecked(hDlg, IDC_MEDIA_MIME_CHKBOX))
                    {
                        id = PLAYMIME_NOSAVE;
                    }
                    else
                    {
                        id = PLAYMIME_NO;
                    }
                    EndDialog(hDlg, id);
                }
                break;

                case IDC_MEDIA_MOREINFO:
                {
                    SHHtmlHelpOnDemandWrap(GetParent(hDlg), TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("mediabar_settings.htm"), ML_CROSSCODEPAGE);
                }
                break;
            }
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}


HRESULT CDocObjectHost::SetTarget(IMoniker* pmk, UINT uiCP, LPCTSTR pszLocation, LPITEMIDLIST pidlKey,
                                  IShellView* psvPrev, BOOL fFileProtocol)
{
    HRESULT hres = NOERROR;
    BOOL fLoadedHistory = FALSE;
    ATOMICRELEASE(_pmkCur);

    _pmkCur = pmk;
    pmk->AddRef();

    ILFree(_pidl);
    _pidl = ILClone(pidlKey);
    
    _fFileProtocol = fFileProtocol;
    _pszLocation = pszLocation;
    _uiCP = uiCP;

    //  this is only set if we did a successful LoadHistory()
    _fIsHistoricalObject = FALSE;

    if (_bsc._hszPostData)
    {
        GlobalFree(_bsc._hszPostData);
        _bsc._hszPostData = NULL;
    }
    if (_bsc._pszHeaders)
    {
        LocalFree(_bsc._pszHeaders);
        _bsc._pszHeaders = NULL;
    }

    ATOMICRELEASE(_bsc._pbc);

    //
    //  this replaces the old style of caching.
    //  if something has been cached, it was cached
    //  way above us before we ever existed.  now it is
    //  waiting for us.
    //
    IBrowserService * pbs;
    IStream  * pstm = NULL;
    IBindCtx * pbcHistory = NULL;

    if (SUCCEEDED(QueryService(SID_SShellBrowser, IID_IBrowserService, (void **)&pbs)))
    {
        //  just in case there is one already there, like in the case of local anchor navigates
        ATOMICRELEASE(_pole);

        pbs->GetHistoryObject(&_pole, &pstm, &pbcHistory);
        TraceMsg(TF_TRAVELLOG, "DOH::SetTarget History object: _pole = %X, pstm = %X, pbc = %X", _pole, pstm, pbcHistory);
        pbs->Release();

    }

    if (_pole) 
    {
        //  some objects (MSHTML for one)  need their clientsite before anything else.
        //  so we need to init first
        _InitOleObject();

        if (pstm)
        {
            IPersistHistory *pph;
            if (SUCCEEDED(_pole->QueryInterface(IID_IPersistHistory, (void **)&pph)))
            {
                if (SUCCEEDED(pph->LoadHistory(pstm, pbcHistory)))
                {
                    //
                    //  this is to make sure that we wait for
                    //  the pole to tell us when it is ready.
                    //  when there is a pstm, that means that they may have
                    //  to do a full reparse or whatever, and we cant make
                    //  any assumptions about the readystate.
                    //
                    hres = S_FALSE;
                    _fIsHistoricalObject = TRUE;
                    _SetUpTransitionCapability();
                    fLoadedHistory = TRUE;
                    
                    // we may need to redo the pics stuff too.
                    // PrepPicsForAsync();
                    TraceMsg(TF_TRAVELLOG, "DOH::SetTarget pph->LoadHistory Successful");
                }
                else
                    ATOMICRELEASE(_pole);

                pph->Release();
            }

            ATOMICRELEASE(pstm);
        }
        else
            hres = S_OK;

        ATOMICRELEASE(pbcHistory);

        //  we shouldnt fail a load history, because the data in
        //  is just what the document gave us in SaveHistory...
        AssertMsg(NULL != _pole, TEXT("DOH::SetTarget pph->LoadHistory Failed"));

        // if we were already up and created, just scroll to it.
        // if we were created DEACTIVATED, (possible in the ocx case)
        // don't do this activation
        if (_uState != SVUIA_DEACTIVATE && !DocCanHandleNavigation())
        {
            hres = _ActivateMsoView();
        }

        //    
        // allow navigation - when you're deactivated. So you can navigate an invisible WebOC. 
        // IE6 Bug# 5449
        // 

        if ( DocCanHandleNavigation() ||
             ( _fDocCanNavigate &&
               _uState == SVUIA_DEACTIVATE && 
               !fLoadedHistory ) )
        {
            // If the _fPrevDocHost flag is not
            // set, we better be deactivated.
            //
            AssertMsg((_fPrevDocHost || _uState == SVUIA_DEACTIVATE),
                      _T("_fPrevDocHost is not set and we are activated"));
            
            // If the document is handling the navigation,
            // we must store the user entered URL here. 
            // Otherwise, if the navigation fails,
            // the user-entered URL is NULL by the time
            // _bsc._HandleFailedNavigationSearch is called,
            //
            VariantClear(&_varUserEnteredUrl);
            _GetSearchString(_psp, &_varUserEnteredUrl);

            WCHAR wzUrl[MAX_URL_STRING];

            hres = IEGetNameAndFlagsEx(_pidl, SHGDN_FORPARSING, IEGDN_NOFRAGMENT, wzUrl, ARRAYSIZE(wzUrl), NULL);

            if (S_OK == hres)
            {
                _EnableModeless(FALSE);

                WCHAR wzLocation[MAX_URL_STRING] = {0};

                IEILGetFragment(_pidl, wzLocation, SIZECHARS(wzLocation));

                hres = _NavigateDocument(CComBSTR(wzUrl), CComBSTR(wzLocation));

                _EnableModeless(TRUE);
            }
        }
    }

    if (!_pole)
    {
        ASSERT(!pstm);
        ASSERT(!pbcHistory);

        IBindCtx * pbc = NULL;

        TraceMsg(TF_TRAVELLOG, "DOH::SetTarget No obj from TravelLog, calling pmk->BindToObject");

        if (_psp)
        {
            hres = _psp->QueryService(SID_SShellBrowser, IID_IBindCtx, (void **)&pbc);
        }

        if (pbc == NULL)
        {
            hres = CreateBindCtx(0, &pbc);
        }
        else
        {
            hres = S_OK;
        }

        if (SUCCEEDED(hres))
        {
            HRESULT    hr         = E_FAIL;
            IBindCtx * pbcAsync   = NULL;
            IBindCtx * pbcWrapper = NULL;

            if (pbc)
            {
                // If the bind context supports IAsyncBindCtx, then it
                // is a bind context that was created by UrlMon and passed
                // to us to reuse. We must pass this bind context to UrlMon
                // as-is and not wrapped in a BCW object.
                // Note: IAsyncBindCtx has identicial interface as IBindCtx
                //
                hr = pbc->QueryInterface(IID_IAsyncBindCtx, (void**)&pbcAsync);
                ATOMICRELEASE(pbcAsync);
            }

            if (SUCCEEDED(hr))
            {
                // If this is a media url delegated to shdocvw from trident,
                // and if the IE Media Bar wants to handle the url, cancel
                // the navigation, else continue the navigation. 

                if (_DelegateToMediaBar(pbc, NULL))
                {
                    _CancelPendingNavigation(TRUE);

                    if (_pwb)
                    {
                        _pwb->SetNavigateState(BNS_NORMAL);
                    }
                    
                    ATOMICRELEASE(pbc);
                    return S_FALSE;
                }
                else
                {
                    ATOMICRELEASE(_pbcCur);
                    _fDelegatedNavigation = TRUE;

                   _pbcCur = pbc;  // No need to AddRef - pbc is AddRef'ed by QS.
                }
            }
            else
            {
                pbcWrapper = BCW_Create(pbc);

                if (pbcWrapper == NULL)
                {
                    pbcWrapper = pbc;
                }
                else
                {
                    pbc->Release();
                }

                pbc = NULL;

                hres = CreateAsyncBindCtxEx(pbcWrapper, 0, NULL, NULL, &pbcAsync, 0);

                if (SUCCEEDED(hres))
                {

                    ASSERT(pbcAsync);
                    ATOMICRELEASE(_pbcCur);

                    _pbcCur = pbcAsync;
                    _pbcCur->AddRef();

                    pbcWrapper->Release();
                    pbcWrapper = pbcAsync;
                }
            }

            if (SUCCEEDED(hres))
            {
#ifdef DEBUG
                DWORD dwMksys;
                hres = pmk->IsSystemMoniker(&dwMksys);
                ASSERT((SUCCEEDED(hres) && dwMksys!=MKSYS_FILEMONIKER));
#endif
                ASSERT(FALSE == _fSetTarget);

                BOOL fWindowOpen = FALSE;

                if (_pbcCur)
                {
                    IUnknown * punkBindCtxParam = NULL;

                    hres = _pbcCur->GetObjectParam(KEY_BINDCONTEXTPARAM, &punkBindCtxParam);
                    if (SUCCEEDED(hres))
                    {
                        fWindowOpen = TRUE;
                        punkBindCtxParam->Release();
                    }
                }

                // If we are being called in response to window.open
                // we create the document here and call InitNew on it
                // to load about:blank. We do this so that the user won't
                // see a transparent window while the URL is being
                // located. When Trident calls Invoke to get the 
                // new window object, we will then load the real document.
                // 
                if (fWindowOpen)
                {
                    hres = _CreatePendingDocObject(TRUE, TRUE);

                    ASSERT(S_OK == hres && _punkPending);

                    if (_punkPending)
                    {
                        ATOMICRELEASE(_pole);
                        hres = _punkPending->QueryInterface(IID_IOleObject, (void**)&_pole);

                        ASSERT(SUCCEEDED(hres));

                        // IE Media Bar: turn auto-play off for the first navigation
                        // This is needed to make the target="_blank" feature work.
                        CMediaBarHelper::DisableFirstAutoPlay(_punkPending);
                    }
                }
                else
                {
                    // Hack: The AddRef & Release protect against an error page
                    // navigation from freeing the pdoh out from under us (edwardp)
                    AddRef();

                    _fSetTarget = TRUE;
                    hres = _StartAsyncBinding(pmk, _pbcCur, psvPrev);
                    _fSetTarget = FALSE;

                    // Hack: Matching Release()
                    //
                    Release();

                    if (SUCCEEDED(hres))
                    {
                        hres = S_FALSE;
                    }
                }
            }

            ATOMICRELEASE(pbcWrapper);  // CreateAsyncBindCtx addrefs as well.
        }

    }

    return hres;
}

#define USE_HISTBMOFFSET 0
#define USE_MYBMOFFSET   1
#define USE_STDBMOFFSET  2

void CDocObjectHost::_MergeToolbarSB()
{
}

HICON _LoadSmallIcon(int id)
{
    return (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(id),
                                IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
}

void _InitIcons(void)
{
    ENTERCRITICAL;

    if (g_hiconScriptErr == NULL)
    {
        g_hiconScriptErr = _LoadSmallIcon(IDI_STATE_SCRIPTERROR);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconScriptErr, NULL);
    }


    if (!g_hiconSSL)
    {
        g_hiconSSL = _LoadSmallIcon(IDI_SSL);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconSSL, NULL);
    }


    if (!g_hiconFortezza)
    {
        g_hiconFortezza = _LoadSmallIcon(IDI_FORTEZZA);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconFortezza, NULL);
    }

    for (UINT id = IDI_STATE_FIRST; id <= IDI_STATE_LAST; id++)
    {
        if (!g_ahiconState[id-IDI_STATE_FIRST])
        {
            g_ahiconState[id-IDI_STATE_FIRST]= _LoadSmallIcon(id);
            if (IS_BIDI_LOCALIZED_SYSTEM())
                 MirrorIcon(&g_ahiconState[id-IDI_STATE_FIRST], NULL);
        }
    }


    if (!g_hiconOffline)
    {
        g_hiconOffline = _LoadSmallIcon(IDI_OFFLINE);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconOffline, NULL);
    }


    if (!g_hiconPrinter)
    {
        g_hiconPrinter = _LoadSmallIcon(IDI_PRINTER);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconPrinter, NULL);
    }

    if (!g_hiconPrivacyImpact)
    {
        g_hiconPrivacyImpact = _LoadSmallIcon( IDI_PRIVACY_IMPACT);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconPrivacyImpact, NULL);
    }

    LEAVECRITICAL;
}

// This function initializes whatever the Class needs for manipulating the history
// we try to delay this till absolutely needed in order to not load
// wininet till the end

IUnknown *
CDocObjectHost::get_punkSFHistory()
{
    if (_pocthf && !_punkSFHistory)
    {
        VARIANT var;

        VariantInit(&var);
        if (SUCCEEDED(_pocthf->Exec(&CGID_Explorer, SBCMDID_HISTSFOLDER, TRUE, NULL, &var)))
        {
            if (VT_UNKNOWN == var.vt && NULL != var.punkVal)
            {
                _punkSFHistory = var.punkVal;
                _punkSFHistory->AddRef();
            }
        }
        VariantClearLazy(&var);
    }
    return _punkSFHistory;
}


//
//  This function (re)initializes CDocObjectHost object with the buddy
// IShellView (which is always CShellDocView) and the IShellBrowser.
// If this is the first time (_hwnd==NULL), it creates the view window
// and other associated windows as well. Otherwise (_hwnd!=NULL) -- it
// means this object is passed from one CDocViewObject to another because
// of intra-page jump -- we move it to the specified location (prcView)
// to make it really sure that we show it at the right place.
//
BOOL CDocObjectHost::InitHostWindow(IShellView* psv, IShellBrowser* psb,
                                    LPRECT prcView)
{
    HWND hwndParent;
    IServiceProvider  * pspTop;
    IOleObject        * pTopOleObject;
    IOleClientSite    * pOleClientSite;

    _ResetOwners();

    ASSERT(psv);
    _psv = psv;
    _psv->AddRef();
    ASSERT(NULL==_pmsoctView);
    _psv->QueryInterface(IID_IOleCommandTarget, (void **)&_pmsoctView);
    ASSERT(NULL==_pdvs);
    _psv->QueryInterface(IID_IDocViewSite, (void **)&_pdvs);

    ASSERT(psb);
    _psb = psb;
    _psb->AddRef();

    ASSERT(NULL==_pwb);
    _psb->QueryInterface(IID_IBrowserService, (void **)&_pwb);
    ASSERT(NULL==_pmsoctBrowser);
    _psb->QueryInterface(IID_IOleCommandTarget, (void **)&_pmsoctBrowser);

    ASSERT(NULL==_psp);
    _psb->QueryInterface(IID_IServiceProvider, (void **)&_psp);
    ASSERT(NULL==_pipu);
    _psb->QueryInterface(IID_IOleInPlaceUIWindow, (void **)&_pipu);
    ASSERT(_pipu);

    _Init();
    
    ASSERT(_psp);
    if (_psp)
    {

        // Get the object that manages the extended buttons from the top-level browser
        // But only if we don't already have it.
        if (NULL == _pBrowsExt)
            _psp->QueryService(SID_STopLevelBrowser, IID_IToolbarExt, (void **)&_pBrowsExt);

        //
        // LATER: I don't like that CDocObjectHost is directly accessing
        //  the automation service object to fire events. We should
        //  probably move all the progress UI code above IShellBrowser
        //  so that we don't need to do this shortcut. (SatoNa)
        //
        ASSERT(NULL==_peds);
        _psp->QueryService(IID_IExpDispSupport, IID_IExpDispSupport, (void **)&_peds);
        ASSERT(_peds);
        ASSERT(NULL==_pedsHelper);
        _peds->QueryInterface(IID_IExpDispSupportOC, (void **)&_pedsHelper);
        ASSERT(NULL==_phf);
        _psp->QueryService(SID_SHlinkFrame, IID_IHlinkFrame, (void **)&_phf);
        if (_phf)
        {
            _phf->QueryInterface(IID_IUrlHistoryNotify, (void **)&_pocthf);
        }
        // _punkSFHistory was being initialized here - but in order to delay the load of wininet.dll
        // we initialize it just before we use it

        ASSERT(_pWebOCUIHandler == NULL);
        ASSERT(_pWebOCUIHandler2 == NULL);
        ASSERT(_pWebOCInPlaceSiteEx == NULL);
        ASSERT(_fDocCanNavigate || _fWebOC == FALSE);

        if (SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&pspTop)) && pspTop)
        {
            if (SUCCEEDED(pspTop->QueryService(SID_SContainerDispatch, IID_IOleObject, (void **)&pTopOleObject)) && pTopOleObject)
            {
                _fWebOC = TRUE; // there was a container so we're a WebOC

                pTopOleObject->GetClientSite(&pOleClientSite);
                if (pOleClientSite)
                {
                    pOleClientSite->QueryInterface(IID_IDocHostUIHandler, (void**)&_pWebOCUIHandler);
                    pOleClientSite->QueryInterface(IID_IDocHostUIHandler2, (void**)&_pWebOCUIHandler2);
                    pOleClientSite->QueryInterface(IID_IDocHostShowUI, (void**)&_pWebOCShowUI);
                    pOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void**)&_pWebOCInPlaceSiteEx);
                    pOleClientSite->Release();
                }
                pTopOleObject->Release();
            }
            pspTop->Release();
        }
    }

    _dhUIHandler.SetSite( (IDocHostUIHandler *) this); // Apparently we need to disamiguate the IUnknown reference.

    _psb->GetWindow(&hwndParent);

    if (!_hwnd) {
        // There are several things we don't attempt to do when
        // we're not toplevel. Frameset type DOH should never
        // try to menu merge or dork with the statusbar.
        // Do this before the CreateWindowEx call 'cuz during
        // creation we party on the status bar.
        {
            IOleInPlaceSite* pparentsite = _GetParentSite();

            if (pparentsite) {
                _fHaveParentSite = TRUE;
                pparentsite->Release();
            }
        }

        _RegisterWindowClass();

        // really create the window
        DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE | WS_TABSTOP;
        //
        //  In Office 95, Excel and PowerPoint don't draw the client edge,
        //  while Word does draw the client edge. To avoid having double edges,
        //  we remove it for now. SriniK (Office) will find out which will be
        //  the standard for Office 96. (SatoNa)
        //
        _hwnd = SHNoFusionCreateWindowEx(0 /* WS_EX_CLIENTEDGE */,
                                c_szViewClass, NULL,
                                dwStyle,
                                prcView->left, prcView->top, prcView->right-prcView->left, prcView->bottom-prcView->top,
                                hwndParent,
                                (HMENU)0,
                                HINST_THISDLL,
                                (LPVOID)SAFECAST(this, CImpWndProc*));

        if (!_hwnd) {
            goto Bail;
        }

        UINT uiAcc = ACCEL_DOCVIEW;
        if (SHRestricted(REST_NOFILEMENU))
            uiAcc = ACCEL_DOCVIEW_NOFILEMENU;

        if (_hacc)
        {
            DestroyAcceleratorTable(_hacc);
            _hacc = NULL;
        }

        _hacc = LoadAccelerators(MLGetHinst(), MAKEINTRESOURCE(uiAcc));
        _InitIcons();

    } else {
        ASSERT(GetParent(_hwnd) == hwndParent);
        MoveWindow(_hwnd, prcView->left, prcView->top,
                   prcView->right-prcView->left, prcView->bottom - prcView->top, TRUE);
    }



Bail:

    return (bool) _hwnd;
}

void CDocObjectHost::_CleanupProgress(void)
{
    TraceMsg(TF_SHDPROGRESS, "CDOH::CleanupProgress fTimer = %d, fFull = %d, hwndProg = %X", _fProgressTimer, _fProgressTimerFull, _hwndProgress);

    if (_fProgressTimer)
    {
        KillTimer(_hwnd, IDTIMER_PROGRESS);
        _fProgressTimer = FALSE;
    }

    if (_fProgressTimerFull)
    {
        //  we are being stopped, and the hwnd is destroyed
        //  before we clear the status bar.  zekel - 22-JUL-97
        _OnSetProgressPos(-2, PROGRESS_RESET);
        KillTimer(_hwnd, IDTIMER_PROGRESSFULL);
        ASSERT(!_fProgressTimerFull);
    }

    _OnSetProgressMax(0);

    _hwndProgress = NULL;
}

void CDocObjectHost::DestroyHostWindow()
{
    // Turn off the simple mode when we are leaving.
    if (_psb)
        _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 0, 0, NULL);

    // really destroy the window

    _fCanceledByBrowser = TRUE;
    _bsc.AbortBinding();

    _RemoveAllPicsProcessors();

    _CloseMsoView();

    //
    // Notes: We need to delete OLE object from this side (container),
    //  otherwise, we leak because of circular reference.
    //
    _UnBind();

    _CleanupProgress();

    if (_hwndTooltip) {
        DestroyWindow(_hwndTooltip);
        _hwndTooltip = NULL;
    }

    //
    // Note that we need to destroy the parent after destroying children.
    //
    // OLE seems to recurse back into this function when we destroy the hwnd
    // and we try to destroy it a second time causing a RIP. Avoid this RIP
    // by NULLing out our internal variables before we destroy the hwnds.
    if (_hwnd) {
        HWND hwndT = _hwnd;
        _hwnd = NULL;
        DestroyWindow(hwndT);
    }

    ATOMICRELEASE(_psp);

    _ResetOwners();
}


//
// This member creates a view (IOleDocumentView) of the DocObject we have (_pole).
// This function is called only once from ::CreateViewWindow.
//
HRESULT CDocObjectHost::_CreateMsoView(void)
{
    ASSERT(_pmsov == NULL);
    ASSERT(_pmsoc == NULL);
    HRESULT hres = OleRun(_pole);
    if (SUCCEEDED(hres))
    {

        //// WARNING:
        // if you add anything to here, you should also pass it along
        // in _CreateDocObjHost
        //

        IOleDocument* pmsod = NULL;
        hres = _pole->QueryInterface(IID_IOleDocument, (void **)&pmsod);
        if (SUCCEEDED(hres)) {
            hres = pmsod->CreateView(this, NULL ,0,&_pmsov);

            if (SUCCEEDED(hres)) {
                //
                //  HACK: Working about MSHTML bug (#28756). We really
                //  want to take this hack out before we ship. (SatoNa)
                //
                _pmsov->SetInPlaceSite(this);
            } else {
                TraceMsg(DM_ERROR, "DOH::_CreateMsoView pmsod->CreateView() ##FAILED## %x", hres);
            }

            if (SUCCEEDED(hres) && !_pmsot) {
                _pmsov->QueryInterface(IID_IOleCommandTarget, (void **)&_pmsot);
            }

            if (SUCCEEDED(hres) && !_pmsoc) {
                _pmsov->QueryInterface(IID_IOleControl, (void **)&_pmsoc);
            }
#ifdef HLINK_EXTRA
            if (_pihlbc)
            {
                if (_phls)
                {
                    _phls->SetBrowseContext(_pihlbc);
                }

                ASSERT(_pmkCur);
                hres = HlinkOnNavigate(this, _pihlbc, 0,
                                       _pmkCur, NULL, NULL);
                // TraceMsg(0, "sdv TR : _CreateMsoView HlinkOnNavigate returned %x", hres);
            }
#endif // HLINK_EXTRA
            pmsod->Release();
        } else {
            TraceMsg(DM_ERROR, "DOH::_CreateMsoView _pole->QI(IOleDocument) ##FAILED## %x", hres);
        }
    } else {
        TraceMsg(DM_ERROR, "DOH::_CreateMsoView OleRun ##FAILED## %x", hres);
    }

    return hres;
}

HRESULT CDocObjectHost::_ForwardSetSecureLock(int lock)
{
    HRESULT hr = E_FAIL;
    TraceMsg(DM_SSL, "[%X}DOH::ForwardSecureLock() lock = %d",this, lock, hr);

    VARIANT va = {0};
    va.vt = VT_I4;
    va.lVal = lock;

    //  we should only suggest if we are not the topframe
    if (_psp && _psb && !IsTopFrameBrowser(_psp, _psb))
    {
        IOleCommandTarget *pmsoct;

        if (SUCCEEDED(_psp->QueryService(SID_STopFrameBrowser, IID_IOleCommandTarget, (void **)&pmsoct)))
        {
            ASSERT(pmsoct);
            if (lock < SECURELOCK_FIRSTSUGGEST)
                va.lVal += SECURELOCK_FIRSTSUGGEST;

            hr = pmsoct->Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &va, NULL);
            pmsoct->Release();
        }
    }
    else
        if (_pmsoctBrowser)
            hr = _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &va, NULL);

    return hr;
}

//
// This is the only method of IOleDocumentSite, which we MUST implement.
//
HRESULT CDocObjectHost::ActivateMe(IOleDocumentView *pviewToActivate)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOC::ActivateMe called when _pmsov is %x", _pmsov);

    HRESULT hres = S_OK;
    if (_pmsov==NULL) {



        hres = _CreateMsoView();

#ifdef TEST_DELAYED_SHOWMSOVIEW
        SetTimer(_hwnd, 100, 1500, NULL);
        MessageBeep(0);
        return hres;
#endif // TEST_DELAYED_SHOWMSOVIEW
    }

    if (SUCCEEDED(hres)) 
    {
        _ShowMsoView();
        _MergeToolbarSB();
        _InitToolbarButtons();

        ASSERT(_pmsoctBrowser);
        if (_fSetSecureLock)
            _ForwardSetSecureLock(_eSecureLock);
    }

    return hres;
}

//Helper routine for QueryStatus for status messages
ULONG ulBufferSizeNeeded(wchar_t *wsz, int ids, ULONG ulBufferLen)
{
    TraceMsg(0, "sdv TR ulBufferSizeNeeded called with (%x)", ids);

    DWORD dwLen;
    WCHAR szTemp[MAX_STATUS_SIZE+1];
    dwLen = MLLoadStringW(ids, szTemp, MAX_STATUS_SIZE);
    dwLen += 1; // for NULL terminator
    if (dwLen <= (DWORD)ulBufferLen)
        MoveMemory(wsz, szTemp, dwLen * sizeof(WCHAR));
    else
        *wsz = 0;
    return ((ULONG)dwLen);
}

HRESULT CDocObjectHost::OnQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext, HRESULT hres)
{
    if (pguidCmdGroup == NULL)
    {
        ULONG i;

        if (rgCmds == NULL)
            return E_INVALIDARG;

        for (i=0 ; i<cCmds ; i++)
        {
            // ONLY say that we support the stuff we support in ::OnExec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_OPEN:
            case OLECMDID_SAVE:
            case OLECMDID_UPDATECOMMANDS:
            case OLECMDID_SETPROGRESSMAX:
            case OLECMDID_SETPROGRESSPOS:
            case OLECMDID_SETPROGRESSTEXT:
            case OLECMDID_SETTITLE:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                if (SUCCEEDED(hres))
                {
                    // _pmsoctBrowser already filled this in
                }
                else
                {
                    rgCmds[i].cmdf = 0;
                }
                break;
            }
        }

        /* for now we deal only with status text*/
        if (pcmdtext)
        {
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_OPEN:
            case OLECMDID_SAVE:
                pcmdtext->cwActual = ulBufferSizeNeeded(pcmdtext->rgwz,
                        IDS_HELP_OF(_MapFromMso(rgCmds[0].cmdID)),
                        pcmdtext->cwBuf);
                break;

            default:
                if (SUCCEEDED(hres))
                {
                    // _pmsoctBrowser already filled this in
                }
                else
                {
                    pcmdtext->cmdtextf = OLECMDTEXTF_NONE;
                    pcmdtext->cwActual = 0;
                    if (pcmdtext->rgwz && pcmdtext->cwBuf>0)
                        *pcmdtext->rgwz = TEXT('\0');
                }
                break;
            }
        }

        hres = S_OK;
    }
    else if (IsEqualGUID(*pguidCmdGroup, CLSID_InternetButtons) ||
             IsEqualGUID(*pguidCmdGroup, CLSID_MSOButtons))
    {
        for (UINT i = 0 ; i < cCmds ; i++)
        {
            // CommandIDs from DVIDM_MENUEXT_FIRST to DVIDM_MENUEXT_LAST are reserved for toolbar extension buttons
            // Do NOT use this range for constants within the scope of CLSID_InternetButtons/CLSID_MSOButtons!
            if (IsInRange(rgCmds[i].cmdID, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
            {
                // We'll pass specificially this OLECMD through to the custom button
                IUnknown_QueryStatus(_pBrowsExt, &CLSID_ToolbarExtButtons, 1, &rgCmds[i], pcmdtext);
            }
            else
            {
                switch (rgCmds[i].cmdID)
                {
                case DVIDM_PRINT:
                case DVIDM_PRINTPREVIEW:
                    if (_pmsoctBrowser)
                    {
                        OLECMD ocButton;
                        static const int tbtab[] =
                        {
                            DVIDM_PRINT,
                            DVIDM_FONTS,
                            DVIDM_PRINTPREVIEW,
                        };
                        static const int cttab[] =
                        {
                            OLECMDID_PRINT,
                            OLECMDID_ZOOM,
                            OLECMDID_PRINTPREVIEW,
                        };
                        ocButton.cmdID = SHSearchMapInt(tbtab, cttab, ARRAYSIZE(tbtab), rgCmds[i].cmdID);
                        ocButton.cmdf = 0;
                        _pmsoctBrowser->QueryStatus(NULL, 1, &ocButton, NULL);
                        rgCmds[i].cmdf = ocButton.cmdf;
                    }
                    break;

                case DVIDM_FONTS:   // Always enable for IE5B2
                case DVIDM_CUT:
                case DVIDM_COPY:
                case DVIDM_PASTE:
                case DVIDM_ENCODING:
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DVIDM_SHOWTOOLS:
                    if (_ToolsButtonAvailable())
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DVIDM_MAILNEWS:
                    if (_MailButtonAvailable())
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DVIDM_DISCUSSIONS:
                    // In addition to enabled/disabled, discussions button is checked/unchecked
                    rgCmds[i].cmdf = _DiscussionsButtonCmdf();
                    break;

                case DVIDM_EDITPAGE:
                    if (_psp)
                    {
                        // Temp code -- forward to itbar
                        // itbar edit code is moving here soon
                        IExplorerToolbar* pxtb;
                        if (SUCCEEDED(_psp->QueryService(SID_SExplorerToolbar, IID_IExplorerToolbar, (void **)&pxtb)))
                        {
                            OLECMD ocButton = { CITIDM_EDITPAGE, 0 };
                            IUnknown_QueryStatus(pxtb, &CGID_PrivCITCommands, 1, &ocButton, NULL);
                            rgCmds[i].cmdf = ocButton.cmdf;
                            pxtb->Release();
                        }
                    }
                    break;
                }
            }
        }
        hres = S_OK;
    }
    return hres;
}

HRESULT CDocObjectHost::QueryStatus(
    /* [unique][in] */ const GUID *pguidCmdGroup,
    /* [in] */ ULONG cCmds,
    /* [out][in][size_is] */ OLECMD rgCmds[  ],
    /* [unique][out][in] */ OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    // Now that BaseBrowser understands that CGID_MSHTML should be directed to the DocObject, we'll
    // get caught in a loop if we send those Execs through here.  Cut it off at the pass.
    if (pguidCmdGroup && IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
        return hres;

    if (_pmsoctBrowser)
        hres = _pmsoctBrowser->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return OnQueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext, hres);
}

void CDocObjectHost::_OnSave(void)
{
    if (_pole && _fFileProtocol)
    {
        IPersistFile * ppf = 0;
        HRESULT hres = _pole->QueryInterface(IID_IPersistFile, (void **)&ppf);

        if (SUCCEEDED(hres))
        {
            LPOLESTR pszDisplayName = NULL;
            hres = _GetCurrentPageW(&pszDisplayName);

            if (SUCCEEDED(hres))
            {
                // fRemember = TRUE for normal case
                hres = ppf->Save(pszDisplayName, !_fCantSaveBack);

                if (FAILED(hres))
                {
                    TraceMsg(DM_ERROR, "DOH::_OnSave ppf->Save(psz, FALSE) failed with %x", hres);
                }

                OleFree(pszDisplayName);
            }
            ppf->Release();
        }
    }
}

HRESULT CDocObjectHost::_OnContentDisposition()
{
    HRESULT hr = S_OK;
    TCHAR   szURL[MAX_URL_STRING];    
    HRESULT hresT;
        
    hresT = _GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);

    if (SUCCEEDED(hresT)) 
    {
        TCHAR    * pszURL;
        UINT       uRet;
        IUnknown * punk;

        if (_bsc._pszRedirectedURL && lstrlen(_bsc._pszRedirectedURL))
        {
            pszURL = _bsc._pszRedirectedURL;
        }
        else
        {
            pszURL = szURL;
        }

        hresT = QueryInterface(IID_IUnknown, (void**)&punk);

        if (SUCCEEDED(hresT))
        {
            uRet = OpenSafeOpenDialog(_hwnd, DLG_SAFEOPEN, NULL, pszURL, NULL, NULL, NULL, _uiCP, punk);

            switch(uRet) 
            {
                case IDOK:
                    //
                    // Set this flag to avoid poppping this dialog box twice.
                    // 
                    _fConfirmed = TRUE;
                    break;  // continue download

                case IDD_SAVEAS:
                    CDownLoad_OpenUI(_pmkCur, _bsc._pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _bsc._pszRedirectedURL, _uiCP, punk);
                    // fall thru to AbortBinding

                case IDCANCEL:
                    _CancelPendingNavigation(FALSE);
                    hr = E_ABORT;
                    break;
            }

            punk->Release();
        }
    }

    return hr;
}

void CDocObjectHost::_OnSetProgressPos(DWORD dwPos, DWORD state)
{
    //  trident will reset with -1
    if (dwPos == -1)
        state = PROGRESS_RESET;

    switch(state)
    {
    case PROGRESS_RESET:
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() RESET, timer = %d", _fProgressTimer);
        if (_fProgressTimer)
        {
            KillTimer(_hwnd, IDTIMER_PROGRESS);
            _fProgressTimer = FALSE;
        }

        if (_dwProgressMax)
        {
            // this will always finish up the progress bar
            //  so that when trident doesnt send us the last update
            //  we do it anyway
            if (_fProgressTimerFull && dwPos == -2)
            {
                _fProgressTimerFull = FALSE;
                KillTimer(_hwnd, IDTIMER_PROGRESSFULL);
                _dwProgressPos = 0;
                _OnSetProgressMax(0);
                _fShowProgressCtl = FALSE;
                _PlaceProgressBar(TRUE);
            }
            else if (!_fProgressTimerFull)
            {
                _OnSetProgressPos(0, PROGRESS_FULL);
                _fProgressTimerFull = TRUE;
                SetTimer(_hwnd, IDTIMER_PROGRESSFULL, 500, NULL);
            }
        }
        else
        {
            _fShowProgressCtl = FALSE;
            _PlaceProgressBar(TRUE);
        }

        break;

    case PROGRESS_FINDING:
        //this covers the first 10%
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() FINDING, timer = %d", _fProgressTimer);
        ASSERT(!dwPos);
        if (!_fProgressTimer)
            SetTimer(_hwnd, IDTIMER_PROGRESS, 500, NULL);
        _fProgressTimer = TRUE;
        _OnSetProgressMax(10000);
        _dwProgressInc = PROGRESS_INCREMENT;
        _dwProgressPos = 100;
        _dwProgressTicks = 0;
        _dwProgressMod = (PROGRESS_FINDMAX - _dwProgressPos) / (2 * _dwProgressInc);
        break;

    case PROGRESS_SENDING:
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() SENDING, timer = %d, dwPos = %d", _fProgressTimer, dwPos);
        ASSERT(!dwPos);
        if (!_fProgressTimer)
            SetTimer(_hwnd, IDTIMER_PROGRESS, 500, NULL);
        _fProgressTimer = TRUE;
        _OnSetProgressMax(10000);
        _dwProgressInc = PROGRESS_INCREMENT;
        _dwProgressTicks = 0;
        //dwProgressPos is already set from FINDING
        _dwProgressMod = (PROGRESS_SENDMAX - _dwProgressPos) / (2 * _dwProgressInc);
        break;

    case PROGRESS_RECEIVING:
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() RECEIVING, timer = %d, dwPos = %d", _fProgressTimer, dwPos);
        if (_fProgressTimer)
        {
            KillTimer(_hwnd, IDTIMER_PROGRESS);
            _fProgressTimer = FALSE;

            //  this is the base spot on the progress bar for trident
            _dwProgressBase = _dwProgressPos / PROGRESS_REBASE;
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() Rebasing at %d%%", _dwProgressPos * 100/ PROGRESS_TOTALMAX);
        }
        // progress max should be set from outside of here....
        _dwProgressPos = ADJUSTPROGRESSPOS(dwPos);
        break;

    case PROGRESS_TICK:
        if (_fProgressTimer)
        {
            if (_dwProgressInc)
                _dwProgressPos += _dwProgressInc;

            // Else we post the still waiting message...
            //
            if (_dwProgressMod && 0 == (++_dwProgressTicks % _dwProgressMod))
            {
                // this means we are about half way.
                _dwProgressInc /= 2;
            }

            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() TICK, dwPos = %d, ticks = %d, inc = %d", _dwProgressPos, _dwProgressTicks, _dwProgressInc);
        }
        else
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() TICKNOT");
        break;

    case PROGRESS_FULL:
        {
            _dwProgressPos = _dwProgressMax;

            // if there are script errors, make sure the status
            // bar is properly set (re: icon and text)
            if (_pScriptErrList != NULL &&
                !_pScriptErrList->IsEmpty())
            {
                TCHAR   szMsg[MAX_PATH];

                // set the script error icon
                if (g_hiconScriptErr != NULL)
                {
                    if (_psb != NULL)
                    {
                        _psb->SendControlMsg(FCW_STATUS,
                                             SB_SETICON,
                                             STATUS_PANE_NAVIGATION,
                                             (LPARAM)g_hiconScriptErr,
                                             NULL);
                    }
                }

                // set the script error text
                MLLoadString(IDS_DONE_WITH_SCRIPT_ERRORS, szMsg, ARRAYSIZE(szMsg));
                _SetPriorityStatusText(szMsg);
            }

            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() FULL");
        }
        break;

    default:
        ASSERT(FALSE);
    }

    if (_hwndProgress)
    {
        _psb->SendControlMsg(FCW_PROGRESS, PBM_SETPOS, _dwProgressPos, 0, NULL);
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() updating, pos = %d, %d%% full", _dwProgressPos, _dwProgressMax ? _dwProgressPos * 100/ _dwProgressMax : 0);

    }

    // fire an event that progress has changed
    if (_peds)
    {
        //  if we are sent a -1, we must forward the event on so that
        //  our host gets it too.  some containers rely on this.
        //  specifically DevStudio's HTMLHelp
        //
        if (dwPos != -1)
            dwPos = _dwProgressPos;

        if (!_fUIActivatingView)
        {
            FireEvent_DoInvokeDwords(_peds,DISPID_PROGRESSCHANGE,dwPos,_dwProgressMax);
        }
    }
}


void CDocObjectHost::_OnSetProgressMax(DWORD dwMax)
{
    // remember the maximum range so we have it when we want to fire progress events
    if (_dwProgressMax != dwMax && _psb)
    {
        _dwProgressMax = dwMax;

        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressMax() max = %d", _dwProgressMax);

        if (!_hwndProgress) {
            _psb->GetControlWindow(FCW_PROGRESS, &_hwndProgress);
        }

        if (_hwndProgress) {
            _psb->SendControlMsg(FCW_PROGRESS, PBM_SETRANGE32, 0, dwMax, NULL);
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressMax() updating (%d of %d)", _dwProgressPos, _dwProgressMax);
        }
        else
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressMax() No hwndProgress");
    }
}

UINT CDocObjectHost::_MapCommandID(UINT id, BOOL fToMsoCmd)
{
    // HEY, this maps OLECMDID commands *only*
    static const UINT s_aicmd[][2] = {
        { DVIDM_PROPERTIES, OLECMDID_PROPERTIES },
        { DVIDM_PRINT,      OLECMDID_PRINT },
        { DVIDM_PRINTPREVIEW, OLECMDID_PRINTPREVIEW },
        { DVIDM_PAGESETUP,  OLECMDID_PAGESETUP},
        { DVIDM_SAVEASFILE, OLECMDID_SAVEAS },
        { DVIDM_CUT,        OLECMDID_CUT },
        { DVIDM_COPY,       OLECMDID_COPY },
        { DVIDM_PASTE,      OLECMDID_PASTE },
        { DVIDM_REFRESH,          OLECMDID_REFRESH },
        { DVIDM_STOPDOWNLOAD,     OLECMDID_STOP },
        // subset - above this line document handles
        { DVIDM_OPEN,       OLECMDID_OPEN },
        { DVIDM_SAVE,       OLECMDID_SAVE },
        { DVIDM_SHOWTOOLS,  OLECMDID_HIDETOOLBARS },
    };
#define CCMD_MAX        (sizeof(s_aicmd)/sizeof(s_aicmd[0]))

    UINT iFrom = fToMsoCmd ? 0 : 1;

    for (UINT i = 0; i < CCMD_MAX; i++) {
        if (s_aicmd[i][iFrom]==id) {
            return s_aicmd[i][1-iFrom];
        }
    }
    return (UINT)-1;
#undef CCMD_MAX
}

void CDocObjectHost::_InitToolbarButtons()
{
    OLECMD acmd[] = {
        { OLECMDID_ZOOM,  0 },  // Notes: This must be the first one
        { OLECMDID_PRINT, 0 },
        { OLECMDID_CUT,   0 },
        { OLECMDID_COPY,  0 },
        { OLECMDID_PASTE, 0 },
        { OLECMDID_REFRESH, 0 },
        { OLECMDID_STOP,  0 },  // Notes: This must be the last one
    };

    if (_pmsot) {
        _pmsot->QueryStatus(NULL, ARRAYSIZE(acmd), acmd, NULL);
    }
    if (_pmsoctBrowser) {
        // the browser may support stop also, so override the document
        // with what the browser says. this is okay because the browser
        // forwards stop back down the chain.
        _pmsoctBrowser->QueryStatus(NULL, 1, &acmd[ARRAYSIZE(acmd)-1], NULL);
    }

    if (_psb)
    {
        for (int i=1; i<ARRAYSIZE(acmd); i++)
        {
            UINT idCmd = _MapFromMso(acmd[i].cmdID);
            _psb->SendControlMsg(FCW_TOOLBAR, TB_ENABLEBUTTON, idCmd,
                        (LPARAM)acmd[i].cmdf, NULL);
        }
    }

    // Check if ZOOM command is supported.
    if (acmd[0].cmdf) 
    {
        VARIANTARG var;
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = 0;

        // get the current zoom depth
        _pmsot->Exec(NULL, OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &var);
        if (var.vt == VT_I4) 
        {
            _iZoom = var.lVal;
        }
        else
        {
            VariantClear(&var);
        }

        // get the current zoom range
        var.vt = VT_I4;
        var.lVal = 0;
        _pmsot->Exec(NULL, OLECMDID_GETZOOMRANGE, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &var);
        if (var.vt == VT_I4) 
        {
            _iZoomMin = (int)(short)LOWORD(var.lVal);
            _iZoomMax = (int)(short)HIWORD(var.lVal);
        }
        else
        {
            VariantClear(&var);
        }
    }
}

void CDocObjectHost::_OnSetStatusText(VARIANTARG* pvarIn)
{
    LPCWSTR pwch = VariantToStrCast(pvarIn);
    if (pwch && _psb) 
    {
        IShellView *psvActive;
        _psb->QueryActiveShellView(&psvActive);
        if (psvActive)
        {
            // Suppress sending status messages if we aren't the active view - else
            // we could be reporting nasties from unapproved PICS pages
            if (IsSameObject(_psv, psvActive))
            {
                TCHAR szHint[256];

                if (pwch)
                    SHUnicodeToTChar(pwch, szHint, ARRAYSIZE(szHint));
                else
                    szHint[0] = 0;

                _SetStatusText(szHint);
            }
            psvActive->Release();
        }
    }
}

//
// This function returns TRUE if
//  (1) the DocObject supports IPersistFile and
//  (2) IPersistFile::IsDirty returns S_OK.
// Caller may pass pppf to retrieve IPersistFile*, which will be AddRef'ed
// and returned only when this function returns TRUE.
//
BOOL CDocObjectHost::_IsDirty(IPersistFile** pppf)
{
    BOOL fDirty = FALSE;    // Assume non-dirty
    if (pppf)
        *pppf = NULL;

    if (_pole) 
    {
        IPersistFile* ppf;
        HRESULT hresT = _pole->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hresT))
        {
            if (ppf->IsDirty()==S_OK) 
            {
                fDirty = TRUE;
                if (pppf) 
                {
                    *pppf = ppf;
                    ppf->AddRef();
                }
            }
            ppf->Release();
        }
    }
    return fDirty;
}

void CDocObjectHost::_OnSetTitle(VARIANTARG *pvTitle)
{
    LPCWSTR pwch = VariantToStrCast(pvTitle);
    if (pwch) 
    {
        if (_pwb)
        {
            _pwb->SetTitle(_psv, pwch);
        }
    }

    // tell our parent DocObjectView about this as well
    if (_pdvs)
        _pdvs->OnSetTitle(pvTitle);
}


void CDocObjectHost::_OnCodePageChange(const VARIANTARG* pvarargIn)
{
    if (pvarargIn && pvarargIn->vt == VT_I4) 
    {
        TraceMsg(DM_DOCCP, "CDOH::OnExec SHDVID_ONCOEPAGECHANGE got %d", pvarargIn->lVal);
        VARIANT var = *pvarargIn;

        //
        // Since the UI (View->Fond) does not say "default codepage",
        // we don't need to be smart about it.
        //
        // if ((UINT)var.lVal == GetACP()) {
        //     var.lVal = CP_ACP;
        // }

        //
        // Change the 'current' codepage.
        //
        IBrowserService *pbs;
        if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->GetSetCodePage(&var, NULL);
            pbs->Release();
        }

        //
        // Write the codepage to the URL history
        //
        IUniformResourceLocator *   purl = NULL;
        HRESULT hresT = CoCreateInstance(CLSID_InternetShortcut, NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IUniformResourceLocator, &purl));

        if (SUCCEEDED(hresT)) 
        {
            TCHAR szURL[MAX_URL_STRING];
            _GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);
            _ValidateURL(szURL, UQF_DEFAULT);

            hresT = purl->SetURL(szURL, 0);
            if (SUCCEEDED(hresT)) 
            {
                IPropertySetStorage *ppropsetstg;
                hresT = purl->QueryInterface(IID_PPV_ARG(IPropertySetStorage, &ppropsetstg));
                if (SUCCEEDED(hresT)) 
                {
                    IPropertyStorage *ppropstg;
                    hresT = ppropsetstg->Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
                    if (SUCCEEDED(hresT)) 
                    {
                        const static PROPSPEC c_aprop[] = {
                            { PRSPEC_PROPID, PID_INTSITE_CODEPAGE},
                        };
                        PROPVARIANT prvar = { 0 };
                        prvar.vt = VT_UI4;
                        prvar.lVal = var.lVal;
                        hresT = ppropstg->WriteMultiple(1, c_aprop, &prvar, 0);
                        TraceMsg(DM_DOCCP, "CDOH::_OnCodePageChange WriteMultile returned %x", hresT);

                        ppropstg->Commit(STGC_DEFAULT);
                        ppropstg->Release();
                    }
                    else
                    {
                        TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange Open failed %x", hresT);
                    }

                    ppropsetstg->Release();
                }
                else
                {
                    TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange QI failed %x", hresT);
                }
            }
            else
            {
                TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange SetURL failed %x", hresT);
            }
            purl->Release();
        }
        else
        {
            TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange CoCreate failed %x", hresT);
        }
    }
    else
    {
        ASSERT(0);
    }
}


void CDocObjectHost::_MappedBrowserExec(DWORD nCmdID, DWORD nCmdexecopt)
{
    if (_pmsoctBrowser)
    {
        DWORD nCmdIDCT = _MapToMso(nCmdID);
        ASSERT(nCmdIDCT != -1);     // if this rips, need to add missing case to _MapCommandID

        OLECMD rgcmd = {nCmdIDCT, 0};

        // Trident sometimes executes commands that are disabled (cut, paste) so
        // ensure that the command is enabled first
        
        BOOL fEnabled = (S_OK == _pmsoctBrowser->QueryStatus(NULL, 1, &rgcmd, NULL)) &&
                        (rgcmd.cmdf & OLECMDF_ENABLED);

        // APPHACK - 80104 Visio doesn't return OLECMDF_ENABLED, but we need to 
        // be able to execute the command to show the toolbars because they start off hidden. 

        if (!fEnabled && (nCmdID == DVIDM_SHOWTOOLS) && 
            (_GetAppHack() & BROWSERFLAG_ENABLETOOLSBTN))
        {
            fEnabled = TRUE;
        }

        if (fEnabled)
        {
            _pmsoctBrowser->Exec(NULL, nCmdIDCT, nCmdexecopt, NULL, NULL);
        }
    }
}

HRESULT CDocObjectHost::OnExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        // _InitToolbarButtons and _OnSetStatusText reference _psb directly
        if (!_psb)
            return E_FAIL;

        switch (nCmdID)
        {
        //
        // The containee has found an http-equiv meta tag; handle it
        // appropriately (client pull, PICS, etc)
        //
        case OLECMDID_HTTPEQUIV:
        case OLECMDID_HTTPEQUIV_DONE:
            if (_pwb)
            {
                _pwb->OnHttpEquiv(_psv, (nCmdID == OLECMDID_HTTPEQUIV_DONE), pvarargIn, pvarargOut);

                // Always return S_OK so that we don't try other codepath.
            }
            return S_OK;

        case OLECMDID_PREREFRESH:
            _fShowProgressCtl = TRUE;
            _PlaceProgressBar(TRUE);
            _OnSetProgressPos(0, PROGRESS_FINDING);
            if (IsGlobalOffline())
            {
                // This is pointing to a web address and we're offline
                // Ask the user if (s)he wants to go online
                TCHAR szURL[MAX_URL_STRING];
                if (SUCCEEDED(_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE)) &&
                    UrlHitsNet(szURL))
                {
                    if (InternetGoOnline(szURL, _hwnd, TRUE) && _psb)
                    {
                        // Tell all browser windows to update their title and status pane
                        SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000);
                    }
                }
            }
            return S_OK;

        case OLECMDID_REFRESH:
            if (_pmsot)
                _pmsot->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            return S_OK;

        case OLECMDID_OPEN:
            _OnOpen();
            return S_OK;

        case OLECMDID_SAVE:
            _OnSave();
            return S_OK;

        case OLECMDID_CLOSE:
            _OnClose();
            return S_OK;

        case OLECMDID_UPDATECOMMANDS:
            _InitToolbarButtons();
            return E_FAIL; // lie and say we don't do anything to forward the command on

        case OLECMDID_SETPROGRESSMAX:
            ASSERT(pvarargIn->vt == VT_I4);
            TraceMsg(TF_SHDPROGRESS, "DOH::Exec() SETPROGRESSMAX = %d", pvarargIn->lVal );
            if (pvarargIn->lVal)
                _OnSetProgressMax(ADJUSTPROGRESSMAX((DWORD) pvarargIn->lVal));
            return S_OK;

        case OLECMDID_SETPROGRESSPOS:
            ASSERT(pvarargIn->vt == VT_I4);
            TraceMsg(TF_SHDPROGRESS, "DOH::Exec() SETPROGRESSPOS = %d", pvarargIn->lVal );
            if (pvarargIn->lVal)
                _OnSetProgressPos((DWORD) pvarargIn->lVal, PROGRESS_RECEIVING);
            return S_OK;

        case OLECMDID_SETPROGRESSTEXT:
            _OnSetStatusText(pvarargIn);
            return S_OK;

        case OLECMDID_SETTITLE:
            if (!pvarargIn)
                return E_INVALIDARG;

            _OnSetTitle(pvarargIn); // We are guaranteed to get atleast 1 OLECMDID_SETTITLE.
            return S_OK;

        // case OLECMDID_PRINT:
        //   In the up direction, this case is handled by the outermost frame as
        // a request to print from the docobj. It handles it by sending an OLECMDID_PRINT
        // back to the docobj to print. (Or, as in Binder, to all the docobjects.)

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
            case SHDVID_SSLSTATUS:
            {
                // Ask the user if (s)he wants to go online
                TCHAR szURL[MAX_URL_STRING];
                if (SUCCEEDED(_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE)))
                {
                    if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
                        StrCpyN(szURL, _bsc._pszRedirectedURL, ARRAYSIZE(szURL));

                    ULONG_PTR uCookie = 0;
                    SHActivateContext(&uCookie);
                    InternetShowSecurityInfoByURL(szURL, _hwnd);
                    if (uCookie)
                    {
                        SHDeactivateContext(uCookie);
                    }
                }

                break;
            }

            case SHDVID_ZONESTATUS:
            {
                // Load the current url into the properties page
                if (!SHRestricted2W(REST_NoBrowserOptions, NULL, 0))
                {
                    TCHAR szBuf[MAX_URL_STRING];
                    _GetCurrentPage(szBuf, ARRAYSIZE(szBuf));

                    ULONG_PTR uCookie = 0;
                    SHActivateContext(&uCookie);
                    ZoneConfigureW(_hwnd, szBuf);
                    if (uCookie)
                    {
                        SHDeactivateContext(uCookie);
                    }
                }
                return S_OK;
            }

            case SHDVID_PRIVACYSTATUS:
            {
                IEnumPrivacyRecords     *pEnum = NULL;
                LPOLESTR                pszName = NULL;
                BOOL                    fReportAllSites = (nCmdexecopt == TRUE);

                if(_pmkCur)
                {
                    if(FAILED(_pmkCur->GetDisplayName(_pbcCur, NULL, &pszName)))
                    {
                        pszName = NULL;
                    }
                }

                if(_psp && SUCCEEDED(_psp->QueryService(IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, (void **)&(pEnum))))
                {
                    BOOL fImpacted;

                    if(fReportAllSites ||
                        (SUCCEEDED(pEnum->GetPrivacyImpacted(&fImpacted)) && fImpacted))
                    {
                        DoPrivacyDlg(_hwnd, pszName, pEnum, fReportAllSites);
                    }
                    pEnum->Release();
                }

                if(pszName)
                {
                    OleFree(pszName);
                }

                return S_OK;
            }

            case SHDVID_QUERYMERGEDHELPMENU:
                if (_hmenuMergedHelp)
                {
                    pvarargOut->vt = VT_INT_PTR;
                    pvarargOut->byref = _hmenuMergedHelp;
                    return S_OK;
                }
                return S_FALSE;

            case SHDVID_QUERYOBJECTSHELPMENU:
                if (_hmenuObjHelp)
                {
                    pvarargOut->vt = VT_INT_PTR;
                    pvarargOut->byref = _hmenuObjHelp;
                    return S_OK;
                }
                return S_FALSE;

            case SHDVID_GETSYSIMAGEINDEX:
                if (_dwAppHack & BROWSERFLAG_MSHTML) {
                    ASSERT(pvarargOut->vt==0);
                    pvarargOut->vt = VT_I4;
                    pvarargOut->lVal = _GetIEHTMLImageIndex();
                    return S_OK;
                }
                return E_FAIL;

            case SHDVID_AMBIENTPROPCHANGE:
                // An ambient property above us has changed, let the docobj know
                if (_pmsoc)
                {
                    ASSERT(pvarargIn->vt == VT_I4);
                    return(_pmsoc->OnAmbientPropertyChange(pvarargIn->lVal));
                }
                return E_FAIL;

            case SHDVID_CANDOCOLORSCHANGE:
                return IUnknown_Exec(_pole, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

            case SHDVID_ONCOLORSCHANGE:
                // this comes from trident and needs passing back up to our parent ...
                if ( _pmsoctBrowser )
                {
                    return _pmsoctBrowser->Exec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut );
                }
                else
                    return E_FAIL;

            case SHDVID_GETOPTIONSHWND:
                if ( _pmsoctBrowser )
                {
                    return _pmsoctBrowser->Exec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut );
                }
                else
                {
                    return E_FAIL;
                }

            case SHDVID_DOCWRITEABORT:
                //  pending DocObject wants to us to abort any binding and activate
                //  it directly
                if (_bsc._pib && _bsc._fBinding && _punkPending && !_pole)
                {
                    _bsc._fDocWriteAbort = 1;
                    _bsc.OnObjectAvailable(IID_IUnknown, _punkPending);
                    _bsc.AbortBinding();
                }
                //  report READYSTATE_COMPLETE so that when document.open() falls
                //  back to READYSTATE_INTERACTIVE Trident doesn't get confused...
                //
                //  chrisfra 4/15/97, is this the only way to force TRIDENT
                //  to not lose fact of download complete when document.open()
                //  falls back to READYSTATE_INTERACTIVE.
                //
                //  During the above OnObjectAvailable call, we fire a READYSTATE_COMPLETE
                //  event if (1) object doesn't support it or (2) object already at it.
                //  (Neither of these should be the case, but we should be careful, eh?)
                //  We want to force a READYSTATE_COMPLETE here in other cases, so unhook
                //  the IPropertyNotifySink (to prevent multiple _COMPLETE events). If we
                //  unhook the sink, then we didn't fire _COMPLETE above, so fire it now.
                //
                if (_dwPropNotifyCookie)
                {
                    _OnReadyState(READYSTATE_COMPLETE);
                }

                return S_OK;

            case SHDVID_CANACTIVATENOW:
            {
                HRESULT hres = (_PicsProcBase._fPicsAccessAllowed && !_PicsProcBase._fbPicsWaitFlags && _pole && _fReadystateInteractiveProcessed) ? S_OK : S_FALSE;
                TraceMsg(DM_PICS, "CDOH::OnExec(SHDVID_CANACTIVATENOW) returning %ls", (hres == S_OK) ? "S_OK" : "S_FALSE");
                return hres;
            }

            case SHDVID_SETSECURELOCK:
                {
                    //
                    //  if we are already active, then we need to go ahead
                    //  and forward this up the browser. otherwise, cache it
                    //  and wait until activated to forward it
                    //
                    TraceMsg(DM_SSL, "[%X]DOH::Exec() SETSECURELOCK lock = %d", this, pvarargIn->lVal);

                    _fSetSecureLock = TRUE;
                    _eSecureLock = pvarargIn->lVal;

                    IShellView *psvActive;
                    if (_psb && SUCCEEDED(_psb->QueryActiveShellView(&psvActive) ))
                    {
                        if (psvActive && IsSameObject(_psv, psvActive))
                            _ForwardSetSecureLock(pvarargIn->lVal);

                        ATOMICRELEASE(psvActive);
                    }
                    return S_OK;
                }

            case SHDVID_FORWARDSECURELOCK:
                _ForwardSetSecureLock(_fSetSecureLock ? _eSecureLock : SECURELOCK_SET_UNSECURE);
                return S_OK;

            case SHDVID_ONCODEPAGECHANGE:
                _OnCodePageChange(pvarargIn);
                return S_OK;

            case SHDVID_DISPLAYSCRIPTERRORS:
            case SHDVID_NAVIGATIONSTATUS:
            {
                // if we're a weboc then this script err list should be null
                ASSERT(!_fWebOC || _pScriptErrList == NULL);

                if (_pScriptErrList != NULL && !_pScriptErrList->IsEmpty())
                {
                    // do the script error info dialog
                    _ScriptErr_Dlg(TRUE);
                }

                return S_OK;
            }
            break;

            case SHDVID_RESETSTATUSBAR:
                {
                    _ResetStatusBar();
                    return S_OK;
                }
                break;

            default:
                return OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch (nCmdID) {
        case SBCMDID_MAYSAVECHANGES:
            return _OnMaySaveChanges();

        case SBCMDID_GETPANE:
            switch(nCmdexecopt)
            {
                case PANE_NAVIGATION:
                    V_I4(pvarargOut) = STATUS_PANE_NAVIGATION;
                    return S_OK;

                case PANE_PROGRESS:
                    V_I4(pvarargOut) = STATUS_PANE_PROGRESS;
                    return S_OK;

                case PANE_ZONE:
                    V_I4(pvarargOut) = STATUS_PANE_ZONE;
                    return S_OK;

                case PANE_OFFLINE:
                    V_I4(pvarargOut) = STATUS_PANE_OFFLINE;
                    return S_OK;

                case PANE_PRINTER:
                    V_I4(pvarargOut) = STATUS_PANE_PRINTER;
                    return S_OK;

                case PANE_SSL:
                    V_I4(pvarargOut) = STATUS_PANE_SSL;
                    return S_OK;

                case PANE_PRIVACY:
                    V_I4(pvarargOut) = STATUS_PANE_PRIVACY;
                    return S_OK;

                default:
                    V_I4(pvarargOut) = PANE_NONE;
                    return S_OK;
            }

        case SBCMDID_ONCLOSE:
            _fClosing = TRUE;
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        } // switch
    }
    else if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case OLECMDID_SAVEAS:
            _OnSaveAs();
            return S_OK;

        case OLECMDID_SHOWSCRIPTERROR:
            {
                HRESULT hr;

                hr = S_OK;

                if (_fWebOC)
                {
                    // we're a web oc.
                    // pass the handling of this script error to
                    // an appropriate CDocHostUIHandler

                    if (_pWebOCUIHandler != NULL)
                    {
                        IOleCommandTarget * pioct;

                        ASSERT(IS_VALID_CODE_PTR(_pWebOCUIHandler, IDocHostUIHandler));

                        hr = _pWebOCUIHandler->QueryInterface(IID_IOleCommandTarget, (void **) &pioct);
                        if (SUCCEEDED(hr))
                        {
                            hr = pioct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

                            pioct->Release();
                        }
                    }
                    else
                    {
                        hr = _dhUIHandler.Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                    }
                }
                else
                {
                    ASSERT(IS_VALID_READ_PTR(pvarargIn, VARIANTARG));
                    ASSERT(IS_VALID_WRITE_PTR(pvarargOut, VARIANTARG));

                    // we're not a web oc so we have to handle this
                    // ourselves, so cache the errors for later
                    // display in the new script error dialog

                    if (pvarargIn == NULL || pvarargOut == NULL)
                    {
                        hr = E_INVALIDARG;
                    }

                    if (SUCCEEDED(hr))
                    {
                        if (_pScriptErrList == NULL)
                        {

                            // create a new script error list
                            _pScriptErrList = new CScriptErrorList;
                            if (_pScriptErrList == NULL)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }

                        if (SUCCEEDED(hr))
                        {
                            TCHAR   szMsg[MAX_PATH];

                            // stuff the error icon into the status bar
                            if (g_hiconScriptErr != NULL)
                            {
                                if (_psb != NULL)
                                {
                                    _psb->SendControlMsg(FCW_STATUS,
                                                         SB_SETICON,
                                                         STATUS_PANE_NAVIGATION,
                                                         (LPARAM)g_hiconScriptErr,
                                                         NULL);
                                }
                            }

                            // stuff the error text into the status bar
                            MLLoadString(IDS_SCRIPT_ERROR_ON_PAGE, szMsg, ARRAYSIZE(szMsg));
                            _SetPriorityStatusText(szMsg);

                            // stuff the error data into the cache
                            _ScriptErr_CacheInfo(pvarargIn);

                            // pop up the dialog
                            _ScriptErr_Dlg(FALSE);

                            V_VT(pvarargOut) = VT_BOOL;
                            if (_pScriptErrList->IsFull())
                            {
                                // stop running scripts
                                V_BOOL(pvarargOut) = VARIANT_FALSE;
                            }
                            else
                            {
                                // keep running scripts
                                V_BOOL(pvarargOut) = VARIANT_TRUE;
                            }
                        }
                    }
                }

                return hr;
            }
            break;

        case OLECMDID_SHOWMESSAGE:
        case OLECMDID_SHOWFIND:
        case OLECMDID_SHOWPAGESETUP:
        case OLECMDID_SHOWPRINT:
        case OLECMDID_PROPERTIES:
            {
                return _dhUIHandler.Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            break;

        //
        // Refresh the original page if an error page is dispalyed.
        //

        case IDM_REFRESH:
        case IDM_REFRESH_TOP:
        case IDM_REFRESH_TOP_FULL:
        case IDM_REFRESH_THIS:
        case IDM_REFRESH_THIS_FULL:
        {
            HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

            if (_pScriptErrList != NULL)
            {
                // clear out the script error list
                _pScriptErrList->ClearErrorList();
                _SetPriorityStatusText(NULL);

                // reset the text and icon
                _ResetStatusBar();
            }

            //
            // If there is a refresh url for this object use it for the refresh.
            // Otherwise fall through and let the client handle it.
            //

            if (_pwszRefreshUrl)
            {
                _fRefresh = TRUE;
                _DoAsyncNavigation(_pwszRefreshUrl);
                hr = S_OK;
            }
            else
            {
                //
                // Non http errors (syntax, DNS, etc) are handled by a async nav
                // to res://shdocvw/error.htm#originalurl.  Handle the refresh
                // for those pages here.
                //
                if (_pmkCur)
                {
                    LPOLESTR pstrUrl;

                    if (SUCCEEDED(_pmkCur->GetDisplayName(_pbcCur, NULL, &pstrUrl)))
                    {

                        if (IsErrorUrl(pstrUrl) && _pszLocation && *_pszLocation)
                        {
                            //
                            // The error url has the form:
                            // "res://shdocvw.dll/http404.htm#http://foo.bar"
                            // Where foo.bar is the the url the user tried to navigate to.
                            // _pszLocation points to "#foo.bar"
                            DWORD dwScheme = GetUrlScheme(_pszLocation + 1);
                            BOOL fDoNavigation = ((URL_SCHEME_HTTP == dwScheme) ||
                               (URL_SCHEME_HTTPS == dwScheme) ||
                               (URL_SCHEME_FTP == dwScheme) ||
                               (URL_SCHEME_GOPHER == dwScheme));

                            //
                            if (fDoNavigation) // otherwise it's a security problem !
                            {
                                _fRefresh = TRUE;
                                _DoAsyncNavigation(_pszLocation + 1);
                            }
                            hr = S_OK;
                        }

                        OleFree(pstrUrl);
                    }
                }
            }

            return hr;
            break;
        }
        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CLSID_InternetButtons) ||
             IsEqualGUID(*pguidCmdGroup, CLSID_MSOButtons))
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT, UIG_OTHER, nCmdID);
        if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER) {
            // the user hit the drop down
            if (_pmsoctBrowser && pvarargIn && pvarargIn->vt == VT_INT_PTR)
            {
                // v.vt = VT_INT_PTR;
                POINT pt;
                RECT* prc = (RECT*)pvarargIn->byref;
                pt.x = prc->left;
                pt.y = prc->bottom;

                switch (nCmdID)
                {
                case DVIDM_MAILNEWS:
                    {
                        VARIANTARG v = {VT_I4};
                        v.lVal = MAKELONG(prc->left, prc->bottom);
                        _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_DOMAILMENU, 0, &v, NULL);
                        break;
                    }

                case DVIDM_FONTS:
                    {
                        VARIANTARG v = {VT_I4};
                        v.lVal = MAKELONG(prc->left, prc->bottom);
                        _pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FONTMENUOPEN, 0, &v, NULL);
                        break;
                    }

                case DVIDM_ENCODING:
                    {
                        VARIANTARG v = {VT_I4};
                        v.lVal = MAKELONG(prc->left, prc->bottom);
                        _pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_MIMECSETMENUOPEN, 0, &v, NULL);
                        break;
                    }
                }
            }
            return S_OK;
        }

        // CommandIDs from DVIDM_MENUEXT_FIRST to DVIDM_MENUEXT_LAST are reserved for toolbar extension buttons
        // Do NOT use this range for constants within the scope of CLSID_InternetButtons/CLSID_MSOButtons!
        if (InRange(nCmdID, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
        {
            IUnknown_Exec(_pBrowsExt, &CLSID_ToolbarExtButtons, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
        else
        {
            switch(nCmdID) {

            case DVIDM_DISCUSSIONS:
                if (_pmsoctBrowser)
                    _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_DISCUSSIONBAND, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
                break;

            case DVIDM_CUT:
            case DVIDM_COPY:
            case DVIDM_PASTE:
                _MappedBrowserExec(nCmdID, 0);
                break;

            case DVIDM_PRINT:
            case DVIDM_PRINTPREVIEW:
            case DVIDM_SHOWTOOLS:
                _MappedBrowserExec(nCmdID, OLECMDEXECOPT_DONTPROMPTUSER);
                break;

            case DVIDM_EDITPAGE:
                if (_psp) {
                    // temp code -- forward to itbar
                    // itbar edit code is moving here soon
                    IExplorerToolbar* pxtb;
                    if (SUCCEEDED(_psp->QueryService(SID_SExplorerToolbar, IID_IExplorerToolbar, (void **)&pxtb))) {
                        IUnknown_Exec(pxtb, &CGID_PrivCITCommands, CITIDM_EDITPAGE, nCmdexecopt, pvarargIn, pvarargOut);
                        pxtb->Release();
                    }
                }
                break;
            }
        }
        return S_OK;
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case ETCMDID_GETBUTTONS:
        {
            int nNumExtButtons = 0;

            if (_pBrowsExt)
            {
                _pBrowsExt->GetNumButtons((UINT*)&nNumExtButtons);
            }

            int nNumButtons = nNumExtButtons + ARRAYSIZE(c_tbStd);

            if ((_nNumButtons != nNumButtons) && (_ptbStd != NULL))
            {
                delete [] _ptbStd;
                _ptbStd = NULL;
            }

            if (_ptbStd == NULL)
            {
                _ptbStd = new TBBUTTON[nNumButtons];
                if (_ptbStd == NULL)
                {
                    return E_OUTOFMEMORY;
                }
                _nNumButtons = nNumButtons;
            }

            memcpy(_ptbStd, c_tbStd, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbStd));

            // Init the string ids
            ASSERT(_ptbStd[6].idCommand == DVIDM_CUT);
            ASSERT(_ptbStd[7].idCommand == DVIDM_COPY);
            ASSERT(_ptbStd[8].idCommand == DVIDM_PASTE);
            ASSERT(_ptbStd[9].idCommand == DVIDM_ENCODING);
            ASSERT(_ptbStd[10].idCommand == DVIDM_PRINTPREVIEW);

            if (-1 != _iString)
            {
                _ptbStd[6].iString = _iString;
                _ptbStd[7].iString = _iString + 1;
                _ptbStd[8].iString = _iString + 2;
                _ptbStd[9].iString = _iString + 3;
                _ptbStd[10].iString = _iString + 4;
            }
            else
            {
                _ptbStd[6].iString = _ptbStd[7].iString = _ptbStd[8].iString = _ptbStd[9].iString = _ptbStd[10].iString = -1;
            }

            if (_pBrowsExt)
            {
                _pBrowsExt->GetButtons(&_ptbStd[ARRAYSIZE(c_tbStd)], nNumExtButtons, FALSE);
            }

            ASSERT(_ptbStd[0].idCommand == DVIDM_SHOWTOOLS);
            if (!_ToolsButtonAvailable())
                _ptbStd[0].fsState |= TBSTATE_HIDDEN;

            ASSERT(_ptbStd[1].idCommand == DVIDM_MAILNEWS);
            if (!_MailButtonAvailable())
                _ptbStd[1].fsState |= TBSTATE_HIDDEN;

            ASSERT(_ptbStd[5].idCommand == DVIDM_DISCUSSIONS);
            if (!_DiscussionsButtonAvailable())
                _ptbStd[5].fsState |= TBSTATE_HIDDEN;

            nNumButtons = RemoveHiddenButtons(_ptbStd, nNumButtons);

            pvarargOut->vt = VT_BYREF;
            pvarargOut->byref = (LPVOID)_ptbStd;
            *pvarargIn->plVal = nNumButtons;
            break;
        }
        case ETCMDID_RELOADBUTTONS:
            _AddButtons(TRUE);
            break;
        }
        return S_OK;
    }
    else if (IsEqualGUID(CGID_InternetExplorer, *pguidCmdGroup))
    {
        switch (nCmdID) {
        case IECMDID_BEFORENAVIGATE_GETSHELLBROWSE:
        case IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE: 
        case IECMDID_BEFORENAVIGATE_GETIDLIST:
            if ( _pmsoctBrowser )
            {
                return _pmsoctBrowser->Exec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut );
            }
            else
            {
                return E_FAIL;
            }

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


HRESULT CDocObjectHost::_OnMaySaveChanges(void)
{
   HRESULT hres = S_OK;

    //
    // ASSUMPTIONS:
    //  1. Not supporting IPersistFile indicates we don't need to worry
    //   about prompting the user for "save as".
    //  2. DocObject which returns S_OK for IPersistFile::S_OK implements
    //   OLECMDID_SAVEAS.
    //
    if (_fFileProtocol || _pmsot)
    {
        IPersistFile* ppf;
        if (_IsDirty(&ppf))
        {
            ASSERT(ppf);

            TCHAR szBuf[MAX_URL_STRING];
            UINT id;

            _GetCurrentPage(szBuf, ARRAYSIZE(szBuf));
            id = MLShellMessageBox(_hwnd,
                MAKEINTRESOURCE(IDS_MAYSAVEDOCUMENT), szBuf, MB_YESNOCANCEL);
            switch(id) {
            case IDCANCEL:
                hres = S_FALSE;
                break;

            case IDYES:
                if (_fFileProtocol) {
                    // 80105 APPHACK: Due to valid fixes in Urlmon, Visio is unable to save
                    // because we are loading the object with read-only flags.  So we show
                    // the Save As dialog to let the user choose another filename.

                    if (_GetAppHack() & BROWSERFLAG_SAVEASWHENCLOSING)
                    {
                        if (_OnSaveAs() != S_OK)
                            hres = S_FALSE;
                    }
                    else
                        _OnSave();

                } else {
                    HRESULT hresT=_pmsot->Exec(NULL, OLECMDID_SAVEAS, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                    SAVEMSG("Exec(OLECMDID_SAVEAS) returned", hresT);

                    // Cancel the navigation if it failed.
                    if (FAILED(hresT)) {
                        // Beep if it is not canceled by the end user.
                        TraceMsg(DM_WARNING, "CDOH::_OnMaySaveChanges Exec(OELCMDID_SAVEAS) returned %x", hresT);
                        if (hresT != OLECMDERR_E_CANCELED) {
                            MessageBeep(0);
                        }
                        hres = S_FALSE;
                    }
                }

                break;

            case IDNO:
                //
                //  If user says 'No' to save changes to this page,
                // we should remove it from the cache so that
                // the user won't see that discarded change.
                //
                //  (pri-2) This object discarding mechanism
                // does not work for POSTed result, which is cached
                // in the travel log.
                //
                break;
            }

            ppf->Release();
        } else {
            ASSERT(ppf==NULL);
        }
    }

    //
    //  In addition, we give a chance to save the contents of the page (when
    // the document is acted as a form -- data-bound Trident page is a good
    // example) to the backend database.
    //
    
    if (hres == S_OK && _pmsot && (!_fDocCanNavigate || _fClosing))
    {
        VARIANT varOut = {0};
        HRESULT hresT = _pmsot->Exec(NULL, OLECMDID_ONUNLOAD, OLECMDEXECOPT_PROMPTUSER, NULL, &varOut);

        if (varOut.vt == VT_BOOL && varOut.boolVal != VARIANT_TRUE)
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

BOOL _ExecNearest(const GUID *pguidCmdGroup, DWORD nCmdID, BOOL fDown)
{
    // Some commands we want to do in the closest frame to the docobj,
    // some in the farthest-away frame, and some we want to handle
    // in the top-most dochost. Look at the command to figure out
    // the routing and then do it.
    BOOL fNearest = FALSE; // most everything goes to the farthest-away frame
    if (pguidCmdGroup==NULL)
    {
        switch(nCmdID)
        {
        case OLECMDID_OPEN:
        case OLECMDID_SAVE:
        case OLECMDID_SETTITLE:
        case OLECMDID_HTTPEQUIV:
        case OLECMDID_HTTPEQUIV_DONE:
            fNearest = TRUE;
            break;

        // some are top-most down, so nearest depends on direction.
        case OLECMDID_REFRESH:
        // say top-most for commands that only work on the topmost guy.
        // (ie, these probably should be implemented in CShellBrowser!)
        // do this even though these are really "upwards-only" commands.
        case OLECMDID_UPDATECOMMANDS:
        case OLECMDID_SETPROGRESSMAX:
        case OLECMDID_SETPROGRESSPOS:
        case OLECMDID_SETPROGRESSTEXT:
        case OLECMDID_SHOWSCRIPTERROR:
            fNearest = fDown;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_AMBIENTPROPCHANGE:
        case SHDVID_GETSYSIMAGEINDEX:
        case SHDVID_DOCWRITEABORT:
        case SHDVID_ONCODEPAGECHANGE:
        case SHDVID_CANDOCOLORSCHANGE:
        case SHDVID_SETSECURELOCK:
        case SHDVID_QUERYMERGEDHELPMENU:
        case SHDVID_QUERYOBJECTSHELPMENU:
            fNearest = TRUE;
            break;

        case SHDVID_DISPLAYSCRIPTERRORS:
            fNearest = fDown;
            break;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case SBCMDID_MAYSAVECHANGES:    // since OLECMDID_SAVE is to the nearest frame
            fNearest = TRUE;
            break;
        }
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup) ||
             IsEqualGUID(CLSID_InternetButtons, *pguidCmdGroup) ||
             IsEqualGUID(CLSID_MSOButtons, *pguidCmdGroup))
    {
        fNearest = TRUE;
    }

    return fNearest;
}

HRESULT CDocObjectHost::Exec(const GUID * pguidCmdGroup,
                             DWORD        nCmdID,
                             DWORD        nCmdexecopt,
                             VARIANTARG * pvarargIn,
                             VARIANTARG * pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup)
    {
        // Now that BaseBrowser understands that CGID_MSHTML should be directed to the DocObject, we'll
        // get caught in a loop if we send those Execs through here.  Cut it off at the pass.
        if (IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
        {
            return hres;
        }
        else if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
        {
            BOOL fHandled = FALSE;

            HRESULT hr = _HandleDocHostCmds(nCmdID,
                                            nCmdexecopt, 
                                            pvarargIn, 
                                            pvarargOut,
                                            &fHandled);
            if (fHandled)
            {
                return hr;
            }
        }
        else if (IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
        {
            BOOL fHandled = FALSE;

            HRESULT hr = _HandleDocHostCmdPriv(nCmdID,
                                               nCmdexecopt,
                                               pvarargIn,
                                               pvarargOut,
                                               &fHandled);
            if (fHandled)
            {
                return hr;
            }
        }
        else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
        {
            if (_HandleShdocvwCmds(nCmdID, nCmdexecopt, pvarargIn, pvarargOut))
            {
                return S_OK;
            }
        }
    }

    BOOL fNearest = _ExecNearest(pguidCmdGroup, nCmdID, FALSE);

    if (fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    if (FAILED(hres) && _pmsoctBrowser)
    {
        hres = _pmsoctBrowser->Exec(pguidCmdGroup, nCmdID, nCmdexecopt,
                                    pvarargIn, pvarargOut);
    }

    // If this is a command that puts up UI and the user presses
    // cancel in the above call, we may try to handle the call here,
    // and that would be bad. Steal OleCmdHRHandled() from MSHTML.
    if (FAILED(hres) && !fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleDocHostCmds
//
//  Synopsis : Handles the CMD IDs for CGID_DocHostCommandHandler.
//
//+---------------------------------------------------------------------------

HRESULT
CDocObjectHost::_HandleDocHostCmds(DWORD nCmdID,
                                   DWORD nCmdexecopt,
                                   VARIANTARG * pvarargIn,
                                   VARIANTARG * pvarargOut,
                                   BOOL       * pfHandled)
{
    HRESULT hres = E_FAIL;

    ASSERT(pfHandled);

    *pfHandled = TRUE;

    switch(nCmdID) 
    {
    // Call from Trident printing with the page # of the currently spooling page.
    // Convert it to a bool indicating whether or not to draw the print icon in the browser.
    case OLECMDID_UPDATEPAGESTATUS:
        hres = E_INVALIDARG;

        if (pvarargIn && pvarargIn->vt == VT_I4)
        {
            VARIANTARG varIn;
            V_VT(&varIn) = VT_BOOL;
            V_BOOL(&varIn)= (pvarargIn->lVal > 0) ? VARIANT_TRUE : VARIANT_FALSE;

            hres = _pmsoctBrowser->Exec(&CGID_ShellDocView,
                                        SHDVID_SETPRINTSTATUS,
                                        0,
                                        &varIn,
                                        NULL);

        } 

        break;

    case OLECMDID_REFRESH:
        // if the print Preview template is up, then we need to block refresh. IE bug (99685)
        hres = _dhUIHandler.Exec(&CGID_DocHostCommandHandler,
                                  OLECMDID_REFRESH,
                                  nCmdexecopt, pvarargIn, pvarargOut);
        break;

    // Allow the command ID to be passed down the Exec chain.
    //
    default:
        *pfHandled = FALSE;
        break;
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleDocHostCmdPriv
//
//  Synopsis : Handles the CMD IDs for CGID_DocHostCmdPriv
//
//+---------------------------------------------------------------------------

HRESULT
CDocObjectHost::_HandleDocHostCmdPriv(DWORD nCmdID,
                                      DWORD nCmdexecopt,
                                      VARIANTARG * pvarargIn,
                                      VARIANTARG * pvarargOut,
                                      BOOL       * pfHandled)
{
    HRESULT hres = E_FAIL;

    ASSERT(pfHandled);

    *pfHandled = TRUE;

    switch(nCmdID) 
    {
    case DOCHOST_DOCCANNAVIGATE:
        {
            // We only set the navigation window for the top-level browser.
            // Even though the WebOC is no longer in frames, it can still
            // be present on a web page as a view link or control.
            //
            DWORD dwFlags = 0;

            if ( _pwb )
            {
                hres = _pwb->GetFlags(&dwFlags);
            }

            if ((dwFlags & BSF_TOPBROWSER) || _IsInBrowserBand())
            {
                ATOMICRELEASE(_pHTMLWindow);

                if (pvarargIn && VT_UNKNOWN == V_VT(pvarargIn) && V_UNKNOWN(pvarargIn))
                {
                    _fDocCanNavigate = TRUE;
        
                    hres = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLWindow2,
                                                                (void**)&_pHTMLWindow);
                }
                else
                {
                    _fDocCanNavigate = FALSE;
                }
            }

            // Pass to the parent shell browser.
            if (_pmsoctBrowser)
            {
                hres = _pmsoctBrowser->Exec(&CGID_DocHostCmdPriv, nCmdID,
                                            nCmdexecopt, pvarargIn, pvarargOut);
            }
        }

        break;

    case DOCHOST_READYSTATE_INTERACTIVE:
        if ( _pScriptErrList != NULL)
            ClearScriptError();
        hres = S_OK;            
        break;
        
    case DOCHOST_NAVIGATION_ERROR:
        hres = _HandleFailedNavigation(pvarargIn, pvarargOut );
        break;

    case DOCHOST_NOTE_ERROR_PAGE:
        _fErrorPage = TRUE;
        break;

    case DOCHOST_CONTENTDISPOSITIONATTACH:
        hres = _OnContentDisposition();
        break;

    case DOCHOST_RESETSEARCHINFO:
        // Reset search info.
        _bsc._SetSearchInfo(this, 0, FALSE, FALSE, FALSE);
        break;

    case DOCHOST_SENDINGREQUEST:
        _OnSetProgressPos(0, PROGRESS_SENDING);

        _fShowProgressCtl = TRUE;
        _PlaceProgressBar(TRUE);

        hres = S_OK;
        break;

    case DOCHOST_FINDINGRESOURCE:
        _OnSetProgressPos(0, PROGRESS_FINDING);

        _fShowProgressCtl = TRUE;
        _PlaceProgressBar(TRUE);

        hres = S_OK;
        break;

    // Allow the command ID to be passed down the Exec chain.
    //
    default:
        *pfHandled = FALSE;
        break;
    }

    return (S_FALSE == hres) ? S_OK : hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleShdocvwCmds
//
//  Synopsis : Handles the CMD IDs for CGID_ShellDocView.
//
//+---------------------------------------------------------------------------

BOOL
CDocObjectHost::_HandleShdocvwCmds(DWORD        nCmdID,
                                   DWORD        nCmdexecopt,
                                   VARIANTARG * pvarargIn,
                                   VARIANTARG * pvarargOut)
{
    BOOL fHandled = TRUE;

    switch(nCmdID)
    {
    case SHDVID_STARTPICSFORWINDOW:
        _StartPicsForWindow(pvarargIn, pvarargOut);
        break;
        
    case SHDVID_CANCELPICSFORWINDOW:
        _CancelPicsForWindow(pvarargIn);
        break;

    case SHDVID_ISPICSENABLED:
        _IsPicsEnabled(pvarargOut);
        break;

    default:
        fHandled = FALSE;
    }

    return fHandled;
}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_StartPicsForWindow
//
//+-----------------------------------------------------------------------------

void
CDocObjectHost::_StartPicsForWindow(VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    ASSERT(pvarargIn);
    ASSERT(VT_UNKNOWN == V_VT(pvarargIn));
    ASSERT(V_UNKNOWN(pvarargIn));
    ASSERT(pvarargOut);
    ASSERT(V_VT(pvarargOut) == VT_EMPTY);

    IHTMLPrivateWindow * pPrivWin;

    V_VT(pvarargOut)   = VT_BOOL;
    V_BOOL(pvarargOut) = VARIANT_FALSE;

    if (SUCCEEDED(V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLPrivateWindow, (void**)&pPrivWin)))
    {
        // Ignore the HR
        //
        if (_StartSecondaryPicsProcessor(pPrivWin) == S_OK)
        {
            V_BOOL(pvarargOut) = VARIANT_TRUE;
        }

        pPrivWin->Release();
    }
}

BOOL
CDocObjectHost::_IsInBrowserBand() const
{
    if (_psp)
    {
        IShellBrowser * pShlBrowser;

        HRESULT hr = _psp->QueryService(SID_SProxyBrowser,
                                        IID_PPV_ARG(IShellBrowser, &pShlBrowser));
        if (SUCCEEDED(hr))
        {
            pShlBrowser->Release();
            return TRUE;
        }
    }

    return FALSE;
}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_CancelPicsForWindow
//
//+-----------------------------------------------------------------------------

void
CDocObjectHost::_CancelPicsForWindow(VARIANTARG * pvarargIn)
{
    ASSERT(pvarargIn);
    ASSERT(VT_UNKNOWN == V_VT(pvarargIn));
    ASSERT(V_UNKNOWN(pvarargIn));

    IUnknown * pUnkPrivWin;

    if (SUCCEEDED(V_UNKNOWN(pvarargIn)->QueryInterface(IID_IUnknown, (void**)&pUnkPrivWin)))
    {
        _RemovePicsProcessorByPrivWindowUnk(pUnkPrivWin);

        pUnkPrivWin->Release();
    }

}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_IsPicsEnabled
//
//  Synopsis : Returns a variant that specifies whether or not PICS is enabled.
//
//+-----------------------------------------------------------------------------

void
CDocObjectHost::_IsPicsEnabled(VARIANTARG * pvarargOut)
{
    ASSERT(pvarargOut);
    ASSERT(VT_EMPTY == V_VT(pvarargOut));

    V_VT(pvarargOut)   = VT_BOOL;
    V_BOOL(pvarargOut) = VARIANT_FALSE;

    IRatingNotification* pRatingNotify;
    HRESULT hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        V_BOOL(pvarargOut) = pRatingNotify->IsRatingsEnabled() ? VARIANT_FALSE : VARIANT_TRUE;
        pRatingNotify->Release();
    }
    else
    {
        if (IS_RATINGS_ENABLED() && S_OK == ::RatingEnabledQuery())
        {
            V_BOOL(pvarargOut) = VARIANT_TRUE;
        }
    }
}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_UpdateState
//
//  Synopsis : Updates the state of the dochost.
//
//+-----------------------------------------------------------------------------

HRESULT
CDocObjectHost::_UpdateState(LPITEMIDLIST pidl, BOOL fIsErrorUrl)
{
    HRESULT hres;

    if (_fSetSecureLock)
    {
        _ForwardSetSecureLock(_eSecureLock);
    }

    ASSERT(_pwb);

    if (!fIsErrorUrl)
    {
        ResetRefreshUrl();
    }
    
    IMoniker * pmk;
    BOOL fFileProtocol;

    hres = ::_URLMONMonikerFromPidl(pidl, &pmk, &fFileProtocol);

    if (S_OK == hres)
    {
        ATOMICRELEASE(_pmkCur);
        _pmkCur = pmk;

        DEBUG_CODE(_TraceMonikerDbg(_pmkCur, _T("CDocObjectHost::_UpdateState")));
    }

    _fFileProtocol = fFileProtocol;

    // This is only set if we did a successful LoadHistory()
    //
    _fIsHistoricalObject = FALSE;

    // This flag used to be set to false in IE5 
    // for each navigation because the dochost was
    // destroyed and a new one was created. Now that Trident
    // knows how to navigate, this flag doesn't get reset. This
    // prevents activation of the view in the case where a 
    // modal dialog is being displayed.
    //
    _fReadystateInteractiveProcessed = FALSE;

    return hres;
}


//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_Init
//
//  Synopsis : Clears the cached redirection URL in case the previous navigation
//             was a redirection. THis is needed so that further navigations to https://
//             sites don't get the redirection URL as their SSL base.
//+-----------------------------------------------------------------------------
void
CDocObjectHost::_Init()
{
    _fDelegatedNavigation = FALSE;
    _fErrorPage = FALSE;

    if (_bsc._pszRedirectedURL)
    {
        LocalFree(_bsc._pszRedirectedURL);
        _bsc._pszRedirectedURL = NULL;
    }
}

#ifdef DEBUG
void 
CDocObjectHost::_TraceMonikerDbg(IMoniker * pmk, TCHAR * pszCaller) const
{
    ASSERT(pmk);

    LPOLESTR pstrDisplayName;
    HRESULT  hr = pmk->GetDisplayName(NULL, NULL, &pstrDisplayName);

    if (S_OK == hr)
    {
        TraceMsg(DM_TRACE, "%ws - Moniker=\"%ws\"", pszCaller, pstrDisplayName);
        OleFree(pstrDisplayName);
    }
}
#endif

//+-------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleFailedNavigation
//
//  Synopsis : Handles a failed navigation by initiating 
//             the AutoSearch function or displaying an
//             error page.
//
//  Scenario : - The user navigates to a bogus URL such as "sdfg".
//             - _HandleFailedNavigation is called via Exec with
//               DOCHOST_NAVIGATION_ERROR.
//             - The AutoSearch initiates with a search index of 0.
//             - AutoSearch expands the URL with the first 
//               UrlTemplate from the registry (usually www.%s.com).
//             - Navigation to the new URL is attempted.
//             - Upon failure, this method is called again with
//               an error code of HTTP_STATUS_BAD_GATEWAY or
//               HTTP_STATUS_GATEWAY_TIMEOUT.
//             - The search index in the property bag is incremented (by
//               two if it is currently 0.)
//             - AutoSearch then tries the next UrlTemplate, and so on.
//
//             If this method is called with an error code other than
//             HTTP_STATUS_BAD_GATEWAY, HTTP_STATUS_GATEWAY_TIMEOUT,
//             INET_E_RESOURCE_NOT_FOUND, INET_E_DATA_NOT_AVAILABLE or
//             if the error code is INET_E_RESOURCE_NOT_FOUND or
//             INET_E_DATA_NOT_AVAILABLEthe and the URL entered by the
//             user contains a protocol identifier (e.g., http://) an
//             error page contained in shdoclc.dll is displayed.
//
//  Input    : pvarargIn - a SafeArray that contains the following 
//                         data in this order.
//                     0 - Binding error or HTTP status code. (VT_I4)
//                     1 - URL being navigated to. (VT_BSTR)
//                     2 - IBinding interface (VT_UNKNOWN)
//                     3 - IHTMLWindow2 of the current window (VT_UNKNOWN)
//
//-------------------------------------------------------------------------

HRESULT
CDocObjectHost::_HandleFailedNavigation(VARIANTARG * pvarargIn, VARIANTARG* pvarargOut /*=NULL*/)
{
    HRESULT hr = E_FAIL;

    ASSERT(pvarargIn);
    ASSERT(_fDocCanNavigate);
    
    if (pvarargIn && VT_ARRAY == V_VT(pvarargIn) && V_ARRAY(pvarargIn))
    {
        // Get the error code from the SafeArray.
        //
        CComVariant cvarErrorCode;
        CComVariant cvarAddrBarNav;
        CComVariant cvarRefresh;

        long  lIdx    = 0;
        DWORD dwError = ERRORPAGE_DNS;
        BOOL  fShouldDisplayError = TRUE;
        BOOL  fDidSuperNavigate = TRUE;

        //
        // We use to use the window only in one place. To avoid QI several times
        // We QI just before the first use, and keep track if we were successful.
        //
        CComVariant cvarWindow;
        IHTMLWindow2 * pCurrentWindow = NULL;
        HRESULT hrWinQI = E_FAIL;
        
        hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarErrorCode);

        if (SUCCEEDED(hr) && V_VT(&cvarErrorCode) == VT_I4)
        {
            lIdx = 4;
            hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarAddrBarNav);

            if (SUCCEEDED(hr) && V_VT(&cvarAddrBarNav) == VT_BOOL)
            {
                // We fire NavigateError and if the host wishes to cancel
                // we can skip the rest of this method.

                BOOL fCancelAutoSearch = FALSE;
                DWORD dwStatusCode = V_I4(&cvarErrorCode);

                CComVariant cvarWindow;

                // Get the pending URL from the SafeArray.
                //
                CComVariant cvarUrl;

                lIdx = 1;
                hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarUrl);

                if (SUCCEEDED(hr) && (VT_BSTR == V_VT(&cvarUrl)) && V_BSTR(&cvarUrl))
                {
                    // Get the current window from the SafeArray.
                    //
                    lIdx = 3;
                    hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarWindow);
    
                    if (SUCCEEDED(hr) && V_VT(&cvarWindow) == VT_UNKNOWN && V_UNKNOWN(&cvarWindow))
                    {
                        hr = V_UNKNOWN(&cvarWindow)->QueryInterface(IID_IHTMLWindow2, (void**)&pCurrentWindow);

                        _FireNavigateErrorHelper(SUCCEEDED(hr) ? pCurrentWindow : NULL,
                                                 dwStatusCode,
                                                 &fCancelAutoSearch,
                                                 V_BSTR(&cvarUrl)); 
                        hrWinQI = hr;
                    }
                }

                if (fCancelAutoSearch)
                {
                   if (!_fCanceledByBrowser)
                   {
                       _CancelPendingNavigation(FALSE, TRUE);
                   }

                   return hr;
                }
        
                lIdx = 0;

                switch (V_I4(&cvarErrorCode))
                {
                    case HTTP_STATUS_BAD_GATEWAY:
                    case HTTP_STATUS_GATEWAY_TIMEOUT:

                        if (VARIANT_TRUE == V_BOOL(&cvarAddrBarNav))
                        {
                            hr = _DoAutoSearch(pvarargIn,
                                               ++lIdx,
                                               V_I4(&cvarErrorCode),
                                               FALSE,
                                               &fShouldDisplayError);

                            if ( fShouldDisplayError )
                            {
                                fDidSuperNavigate = FALSE;
                            }
                        }
                        break;
            
                    // Only autosearch if the error code is
                    // INET_E_RESOURCE_NOT_FOUND or INET_E_DATA_NOT_AVAILABLE
                    //
                    case INET_E_RESOURCE_NOT_FOUND:
                    case INET_E_DATA_NOT_AVAILABLE:

                        if (VARIANT_TRUE == V_BOOL(&cvarAddrBarNav))
                        {
                            hr = _DoAutoSearch(pvarargIn,
                                               ++lIdx,
                                               0,
                                               TRUE,
                                               &fShouldDisplayError);

                            // We must reset here so that the index will be
                            // correct the next time around.
                            //

                        }
                
                    // Intentional fall-through

                    case INET_E_DOWNLOAD_FAILURE:
                        if (IsGlobalOffline())
                            break; 
                
                    // otherwise fall through to do default handling
            
                    default:
                        if (hr || fShouldDisplayError)
                        {
                            if (  V_I4(&cvarErrorCode) >= HTTP_STATUS_BAD_REQUEST
                               && V_I4(&cvarErrorCode) <= HTTP_STATUS_LAST)
                            {
                               dwError = V_I4(&cvarErrorCode);
                            }

                            // Get the pending URL from the SafeArray.
                            //
                            CComVariant cvarUrl;

                            lIdx = 1;
                            hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarUrl);

                            if (SUCCEEDED(hr) && V_VT(&cvarUrl) == VT_BSTR && V_BSTR(&cvarUrl))
                            {
                                if (SUCCEEDED(hrWinQI))
                                {
                                    //
                                    // Get the refresh flag - indicating whether this is a refresh.
                                    // ( this was originally set when we called SuperNavigate )
                                    // 
                                    lIdx = 5;
                                    hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarRefresh);

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = _DisplayHttpErrorPage(pCurrentWindow,
                                                                   V_BSTR(&cvarUrl),
                                                                   dwError,
                                                                   V_BOOL(&cvarAddrBarNav),
                                                                   V_BOOL(&cvarRefresh ) );
                                        ATOMICRELEASE(pCurrentWindow);
                                    }
                                }
                            }
                        }
            
                        break;
                
                }  // switch

                if ( pvarargOut && ( V_VT( pvarargOut ) == VT_BOOL ) )
                {
                    V_BOOL( pvarargOut ) = fDidSuperNavigate ? VARIANT_TRUE : VARIANT_FALSE;
                }
                
            }  // if (SUCCEEDED(hr) && V_VT(&cvarAddrBarNav) == VT_BOOL)
        } // if (SUCCEEDED(hr) && V_VT(&cvarErrorCode) == VT_I4)
    }
    
    return (S_FALSE == hr ? S_OK : hr);
}

//+------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_DoAutoSearch
//
//  Synopsis : Performs the autosearch function. 
//
//  Input    : pvarargIn    - a SafeArray of arguments. See 
//                            _HandleFailedNavigation for info about
//                            the format of pvarargIn.
//             lStartIdx    - the position in the SafeArray where
//                            the data begins.
//             dwStatusCode - the HTTP status code.
//
//  Output   : pfShouldDisplayError - TRUE if an error page
//                                    should be displayed.
//
//------------------------------------------------------------------

HRESULT
CDocObjectHost::_DoAutoSearch(VARIANTARG   * pvarargIn,
                              long           lStartIdx,
                              DWORD          dwStatusCode,
                              BOOL           fAddMRU,
                              BOOL         * pfShouldDisplayError)
{
    ASSERT(pvarargIn);
    ASSERT(_fDocCanNavigate);
    ASSERT(pfShouldDisplayError);

    *pfShouldDisplayError = TRUE;
    
    // Url
    CComVariant cvarUrl;
    HRESULT hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lStartIdx, &cvarUrl);

    if (SUCCEEDED(hr) && V_VT(&cvarUrl) == VT_BSTR && V_BSTR(&cvarUrl))
    {
       CComVariant cvarBinding;
       IBinding  * pBinding;
    
       // Binding interface pointer
       lStartIdx++;
       hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lStartIdx, &cvarBinding);
    
       if (SUCCEEDED(hr) && V_VT(&cvarBinding) == VT_UNKNOWN && V_UNKNOWN(&cvarBinding))
       {
           hr = V_UNKNOWN(&cvarBinding)->QueryInterface(IID_IBinding, (void**)&pBinding);
           if (SUCCEEDED(hr))
           {
               hr = _bsc._HandleFailedNavigationSearch(pfShouldDisplayError, dwStatusCode, this, 0, V_BSTR(&cvarUrl),
                                                       L"Resource Not Found", pBinding, fAddMRU, TRUE);

               if (hr == S_FALSE)
                   _fErrorPage = TRUE;  // Don't update the history if no auto-search
               ATOMICRELEASE(pBinding);
           }
        }
    }
        
    return (S_FALSE == hr ? S_OK : hr);
}

//+---------------------------------------------------------------
//
//  Member   : CDocObjectHost::_DisplayHttpErrorPage
//
//  Synopsis : Displays the HTML page that corresponds to 
//             the given error code.
//
//  Input    : pCurrentWindow - the window to use for navigation.
//             dwError        - the error code.
//
//---------------------------------------------------------------

HRESULT
CDocObjectHost::_DisplayHttpErrorPage(IHTMLWindow2 * pCurrentWindow,
                                      BSTR           bstrUrl,
                                      DWORD          dwError,
                                      BOOL           fAddrBarNav,
                                      BOOL           fRefresh /*=FALSE*/)
{
    HRESULT hr = E_FAIL;
    TCHAR   szErrorUrl[MAX_URL_STRING];
    const   WCHAR * const pszFmt = L"#%s";
    IHTMLPrivateWindow * pPrivWindow = NULL;

    ASSERT(pCurrentWindow);
    ASSERT(_fDocCanNavigate);
    
    _bsc._DontAddToMRU(this);
    
    if (IsErrorHandled(dwError))
    {
        _fErrorPage = TRUE;
        if (_bsc._DisplayFriendlyHttpErrors())
        {
            hr = MLBuildResURLWrap(_T("shdoclc.dll"),
                                   HINST_THISDLL,
                                   ML_CROSSCODEPAGE,
                                   (TCHAR*)c_aErrorUrls[EUIndexFromError(dwError)].pszUrl,
                                   szErrorUrl,
                                   ARRAYSIZE(szErrorUrl),
                                   _T("shdocvw.dll"));
            if (SUCCEEDED(hr))
            {
                LPOLESTR pwszLocation = OLE2W(bstrUrl);

                if (!IsFrameWindow(pCurrentWindow))
                {
                    // Save the url the user attempted to navigate to.  It will be used
                    // to refresh the page.
                    //
                    OleFree(_pwszRefreshUrl);
                    hr = SHStrDupW(OLE2W(bstrUrl), &_pwszRefreshUrl);
                }

                if (SUCCEEDED(hr))
                {
                    int nLenWritten = lstrlen(szErrorUrl);

                    // Append the #<refresh URL>
                    //
                    wnsprintf(szErrorUrl + nLenWritten,
                              ARRAYSIZE(szErrorUrl) - nLenWritten,
                              pszFmt,
                              pwszLocation ? pwszLocation : L"");


                    hr = pCurrentWindow->QueryInterface(IID_IHTMLPrivateWindow,
                                                        (void**)&pPrivWindow);
                    if (SUCCEEDED(hr))
                    {
                        // Navigate to the URL
                        //
                        BSTR bstrErrorUrl = SysAllocString(szErrorUrl);

                        DWORD dwFlags = (fAddrBarNav ? 
                                            DOCNAVFLAG_DONTUPDATETLOG | DOCNAVFLAG_HTTPERRORPAGE :
                                            DOCNAVFLAG_HTTPERRORPAGE) ;

                        if ( fRefresh )
                            dwFlags |= DOCNAVFLAG_REFRESH;
                            
                        if (bstrErrorUrl)
                        {
                            hr = pPrivWindow->SuperNavigate(bstrErrorUrl,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            dwFlags);
                            SysFreeString(bstrErrorUrl);
                        }

                        pPrivWindow->Release();
                    }
                }
            }
        }
    }
    
    return hr;
}

HRESULT CDocObjectHost::_GetUrlVariant(VARIANT *pvarargOut)
{
    ASSERT( pvarargOut);

    if (_pmkCur)
    {
        LPOLESTR pszDisplayName = NULL;
        LPTSTR pszRedirectedURL = NULL;

        if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
            pszRedirectedURL = _bsc._pszRedirectedURL;

        if (pszRedirectedURL || SUCCEEDED(_GetCurrentPageW(&pszDisplayName, TRUE)))
        {
            pvarargOut->bstrVal = SysAllocString(pszRedirectedURL ? pszRedirectedURL : pszDisplayName);

            if (pvarargOut->bstrVal)
                pvarargOut->vt = VT_BSTR;

            if (pszDisplayName)
                OleFree(pszDisplayName);
        }
    }
    return (pvarargOut->bstrVal == NULL) ? E_FAIL : S_OK;
}

HRESULT CDocObjectHost::_CoCreateHTMLDocument(REFIID riid, void ** ppvOut)
{
    IOleCommandTarget* pcmd;
    
    HRESULT hres = QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (void **)&pcmd);
    if (SUCCEEDED(hres)) {
        VARIANT varOut = { 0 };
        hres = pcmd->Exec(&CGID_Explorer, SBCMDID_COCREATEDOCUMENT, 0, NULL, &varOut);
        if (SUCCEEDED(hres) && varOut.vt == VT_UNKNOWN) {
            hres = varOut.punkVal->QueryInterface(riid, ppvOut);
            // Clean it up by ourself so that we don't load OLEAUT32
            varOut.punkVal->Release();
        } else {
            ASSERT(varOut.vt == VT_EMPTY);
            VariantClear(&varOut);
        }
        pcmd->Release();
    }
    return hres;
}

HRESULT CDocObjectHost::_CreatePendingDocObject(BOOL fMustInit, BOOL fWindowOpen /* = FALSE */)
{
    HRESULT hres = S_OK;

    if (_punkPending == NULL)
    {
        hres = _CoCreateHTMLDocument(IID_IUnknown, (void **)&_punkPending);
        _fPendingNeedsInit = 1;   // lazy InitNew only if absolutely necessary

        if (fWindowOpen)
        {
            IUnknown_Exec(_punkPending, &CGID_ShellDocView, SHDVID_WINDOWOPEN, 0, NULL, NULL);
        }
    }

    if (_fPendingNeedsInit && fMustInit && SUCCEEDED(hres))
    {
        IOleObject * polePending;
#ifdef TRIDENT_NEEDS_LOCKRUNNING
        IRunnableObject * pro;
#endif
        _fCreatingPending = 1;    // we are creating _punkPending
        _fAbortCreatePending = 0;
        _fPendingNeedsInit = 0;

        IPersistStreamInit * pipsi;

        hres = _punkPending->QueryInterface(IID_IPersistStreamInit, (void**)&pipsi);
        if (SUCCEEDED(hres))
        {
            hres = pipsi->InitNew();
            pipsi->Release();
        }

        // if the InitNew is a re-entrant request (such as doing execDown to get a securityctx
        //  while in the process of loading the document), trident will respond with E_PENDING
        //  since there is already a load in progress, this call/init is a timing issue, and
        //  we can use the exisitng one.
        //
        if (SUCCEEDED(hres) || hres==E_PENDING)
        {
            hres = _punkPending->QueryInterface(IID_IOleObject, (void**)&polePending);
            if (SUCCEEDED(hres))
            {
                hres = polePending->SetClientSite(this);
                polePending->Release();
            }

#ifdef TRIDENT_NEEDS_LOCKRUNNING
        //  TRIDENT NO LONGER SUPPORTS IRunnableObject
            //  RegisterObjectParam/RevokeObjectParam calls LockRunning on object being
            //  registered.  LockRunning(FALSE,FALSE) implied in the Revoke will result
            //  in OleClose being called on _punkPending if we haven't activated it
            //  by end of binding.  Thus we must call LockRunning ourself
            if (SUCCEEDED(hres))
            {
                hres = _punkPending->QueryInterface(IID_IRunnableObject, (void**)&pro);
                if (SUCCEEDED(hres))
                {
                    hres = pro->LockRunning(TRUE, TRUE);
                    pro->Release();
                }
            }
#endif
        }

        _fCreatingPending = 0;
        _fPendingWasInited = 1;

        if (FAILED(hres))
        {
            SAFERELEASE(_punkPending);
        }
        else if (_fAbortCreatePending)
        {
            //  Detect AOL pumping messages and reentering and attempting to release
            //  _punkPending
            _fAbortCreatePending = 0;
            _ReleasePendingObject();
            hres = E_FAIL;
        }
        else
        {
            //  Pass URL for pending object to it in advance of IPersistMoniker::Load

            //
            // Notes: We don't want to call _GetUrlVariant which will load
            // OLEAUT32.DLL
            //

            LPOLESTR pszDisplayName = NULL;
            LPTSTR pszURL = NULL;

            if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
                pszURL = _bsc._pszRedirectedURL;

            if (pszURL || SUCCEEDED(_GetCurrentPageW(&pszDisplayName, TRUE)))
            {
                LBSTR::CString              strDisplay;

                strDisplay = ( pszURL ? pszURL : pszDisplayName );

                VARIANT varIn;
                varIn.vt = VT_BSTR;
                varIn.bstrVal = strDisplay;

                IUnknown_Exec(_punkPending, &CGID_ShellDocView, SHDVID_SETPENDINGURL, 0, &varIn, NULL);

                if (pszDisplayName)
                    OleFree(pszDisplayName);
            }
        }

        _fAbortCreatePending = 0;
    }

    return hres;
}

HRESULT
CDocObjectHost::_LoadDocument()
{
    if (!_punkPending)
        return E_FAIL;

    IPersistMoniker * pPersistMk;

    HRESULT hres = _punkPending->QueryInterface(IID_IPersistMoniker, (void**)&pPersistMk);
    if (SUCCEEDED(hres))
    {
        ITridentService * pTridentSvc;

        if ( _pwb )
        {
            hres = _pwb->QueryInterface(IID_ITridentService, (void**)&pTridentSvc);
        }
        else
        {
            TraceMsg( TF_ERROR, "CDocObjectHost::_LoadDocument() - _pwb is NULL!" );
            hres = E_FAIL;
        }

        if (SUCCEEDED(hres))
        {
            BSTR bstrUrl;

            hres = pTridentSvc->GetPendingUrl(&bstrUrl);
            if (SUCCEEDED(hres))
            {
                IMoniker * pMoniker;
                TCHAR *pstr;

                // Parse the URL, removing any location info
                pstr = wcsrchr(bstrUrl, '#');
                if (pstr)
                {
                    *pstr = '\0';
                }

                hres = CreateURLMoniker(NULL, bstrUrl, &pMoniker);
                if (SUCCEEDED(hres))
                {
                    ATOMICRELEASE(_pole);

                    hres = _punkPending->QueryInterface(IID_IOleObject, (void**)&_pole);
                    if (SUCCEEDED(hres))
                    {
                        _GetAppHack();

                        // Call _SetUpTransitionCapability() to set up the advisory sinks
                        // and set readystate to complete. If we don't do this here, the 
                        // view will never be activated after the first navigation
                        // which means that the view will never switched and the
                        // new document will not be displayed. Also, setting readystate
                        // to complete here, is what prevents the window from being transparent
                        // when it is first opened.
                        //
                        _SetUpTransitionCapability(TRUE);
                    }

                    hres = pPersistMk->Load(TRUE, pMoniker, _pbcCur, 0);
                    pMoniker->Release();
                }

                SysFreeString(bstrUrl);
            }

            pTridentSvc->Release();
        }

        pPersistMk->Release();
    }

    return S_OK;
}

// called from CDocObjectView to exec and forward these calls down
//
HRESULT CDocObjectHost::ExecDown(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    //  Special case Exec's that are used to fetch info on pending docobject
    //  for scripting access before OnObjectAvailable
    if (pguidCmdGroup && IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case SHDVID_GETPENDINGOBJECT:
            ASSERT( pvarargOut);
            VariantClearLazy(pvarargOut);

            if (_pole)
            {
                _pole->QueryInterface(IID_IUnknown, (void **) &(pvarargOut->punkVal));

                // Check to see if this is a window.open case. If so,
                // the document was created and Init'ed in SetTarget 
                // and the real Url will be loaded now.
                //
                if (_pbcCur)
                {
                    IUnknown * punkBindCtxParam = NULL;

                    hres = _pbcCur->GetObjectParam(KEY_BINDCONTEXTPARAM, &punkBindCtxParam);
                    if (SUCCEEDED(hres))
                    {
                        punkBindCtxParam->Release();

                        _fWindowOpen = TRUE;

                        hres = _LoadDocument();
                        _ActivateMsoView();
                    }
                }
            }
            else
            {
                _CreatePendingDocObject(TRUE);

                if (_punkPending)
                {
                    pvarargOut->punkVal = _punkPending;
                    _punkPending->AddRef();
                }
                else if (_pole)
                {
                    _pole->QueryInterface(IID_IUnknown, (void **) &(pvarargOut->punkVal));
                }
            }

            if (pvarargOut->punkVal != NULL)
            {
                pvarargOut->vt = VT_UNKNOWN;
                hres = S_OK;

            }
            else
            {
                hres = E_FAIL;
            }

            return hres;
            break;

        case SHDVID_GETPENDINGURL:
            ASSERT( pvarargOut);

            VariantClearLazy(pvarargOut);
            hres = _GetUrlVariant(pvarargOut);

            return hres;
            break;

        default:
            break;
        }
    }

    BOOL fNearest = _ExecNearest(pguidCmdGroup, nCmdID, TRUE);

    if (fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    if (FAILED(hres) && _pmsot) {
        hres = _pmsot->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

        //
        // APPHACK:
        //  PPT in Office 97 fails to print if we pass PRINTFLAG_PROMPTUSER
        // and returns E_INVALIDARG. If we detect this case, we should retry
        // without this flag. PPT will popup the print dialog. (SatoNa)
        //
        if (hres == E_INVALIDARG
            && (_dwAppHack & BROWSERFLAG_PRINTPROMPTUI)
            && pguidCmdGroup == NULL
            && nCmdID == OLECMDID_PRINT)
        {
            TraceMsg(TF_SHDAPPHACK, "DOH::ExecDown(OLECMDID_PRINT) removing PRINTFLAG_PROMPTUSER");
            nCmdexecopt &= ~OLECMDEXECOPT_DONTPROMPTUSER;
        hres = _pmsot->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    if (FAILED(hres) && !fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}
HRESULT CDocObjectHost::QueryStatusDown(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres;

    if (_pmsot)
        hres = _pmsot->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
    else if (pguidCmdGroup && IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
        hres = IUnknown_QueryStatus(_pole, pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return OnQueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext, hres);
}


HRESULT CDocObjectHost::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr)
{
    if (!_peds)
        return(E_NOTIMPL);

    return _peds->OnInvoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult,pexcepinfo,puArgErr);
}

//*** IOleControlSite {

HRESULT CDocObjectHost::OnControlInfoChanged()
{
    HRESULT hres = E_NOTIMPL;

    if (_pedsHelper)
    {
        hres = _pedsHelper->OnOnControlInfoChanged();
    }

    return(hres);
}

//***   CDOH::TranslateAccelerator (IOCS::TranslateAccelerator)
// NOTES
//  trident (or any other DO that uses IOCS::TA) calls us back when TABing
//  off the last link.  to handle it, we flag it for our original caller
//  (IOIPAO::TA), and then pretend we handled it by telling trident S_OK.
//  trident returns S_OK to IOIPAO::TA, which checks the flag and says
//  'trident did *not* handle it' by returning S_FALSE.  that propagates
//  way up to the top where it sees it was a TAB so it does a CycleFocus.
//
//  that's how we do it when we're top-level.  when we're a frameset, we
//  need to do it the 'real' way, sending it up to our parent IOCS.
HRESULT CDocObjectHost::TranslateAccelerator(MSG __RPC_FAR *pmsg,DWORD grfModifiers)
{

    HRESULT hres = S_FALSE;

    if (_peds) {
        // try it the real way in case we're in a frameset
        // top level: we'll do CImpIExpDispSupport::OnTA which does E_NOTIMPL,
        // frameset:  we'll do CWebBrowserOC::OnTA which talks to trident
        // What if trident (or OC?) gives back E_NOTIMPL too?
        TraceMsg(DM_FOCUS, "DOH::IOCS::TA peds!=NULL forward");
        hres = _peds->OnTranslateAccelerator(pmsg, grfModifiers);
    }
    if (hres != S_OK) {
        // we're at top level (E_NOTIMPL), so we can fake it
        // (or alternately we're not, but our parent said S_FALSE)
#ifdef DEBUG
        if (_peds && SUCCEEDED(hres)) {
            // i'm curious if we ever hit this
            TraceMsg(DM_WARNING, "DOH::IOCS::TA parent hres=%x (!=S_OK)", hres);
        }
#endif
        hres = S_FALSE;
        if (IsVK_TABCycler(pmsg)) {
            TraceMsg(TF_SHDUIACTIVATE, "DOH::TranslateAccelerator called with VK_TAB");
            TraceMsg(DM_FOCUS, "DOH::IOCS::TA(wParam=VK_TAB) ret _fCycleFocus=TRUE hr=S_OK (lie)");
            // defer it, set flag for CDOH::IOIPAO::TA, and pretend we handled it
            ASSERT(!_fCycleFocus);
            _fCycleFocus = TRUE;
            hres = S_OK;
        }
    }

    return hres;
}

// }

//========================================================================
// CDocObjectHost::CPicsProcessor
//========================================================================
CDocObjectHost::CPicsProcessor::CPicsProcessor()
{
    _fPicsAccessAllowed = TRUE;     /* assume no ratings checks unless we download */
    _fInDialog = FALSE;
    _fTerminated = FALSE;
    _fbPicsWaitFlags = 0;
}

STDMETHODIMP CDocObjectHost::CPicsProcessor::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IOleCommandTarget) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    CDocObjectHost* pdoh = _pdoh;

    return pdoh->AddRef();
}

STDMETHODIMP_(ULONG) CDocObjectHost::CPicsProcessor::AddRef(void)
{
    return _pdoh->AddRef();
}

STDMETHODIMP_(ULONG) CDocObjectHost::CPicsProcessor::Release(void)
{
    return _pdoh->Release();
}

STDMETHODIMP CDocObjectHost::CPicsProcessor::QueryStatus(const GUID *pguidCmdGroup,
            ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocObjectHost::CPicsProcessor::Exec(const GUID *pguidCmdGroup,
            DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_PICSLABELFOUND:
            if (pvarargIn->vt == (VT_BSTR)) {
                _dwPicsLabelSource = PICS_LABEL_FROM_PAGE;
                _HandleInDocumentLabel(pvarargIn->bstrVal);
            }
            return NOERROR;
        case SHDVID_PICSLABELFOUNDINHTTPHEADER:
            if (pvarargIn->vt == (VT_BSTR)) {
                _dwPicsLabelSource = PICS_LABEL_FROM_HEADER;
                _HandleInDocumentLabel(pvarargIn->bstrVal);
            }
            return NOERROR;
        case SHDVID_NOMOREPICSLABELS:
            _HandleDocumentEnd();
            return NOERROR;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}

UINT CDocObjectHost::CPicsProcessor::_PicsBlockingDialog()
{
    LPCTSTR pszURL = _pszPicsURL;

    TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog() %s", pszURL);

    _StartPicsRootQuery(pszURL);

    _pdoh->_fDrawBackground = TRUE;
    ::InvalidateRect(_pdoh->_hwnd, NULL, TRUE);    /* mega cheesy, but only way to get browser window erased */

    /* This message loop is used to block in non-HTML cases, where we really
     * want to block the download process until ratings are checked.  In the
     * HTML case, this function is never called until the wait flags are all
     * clear, so the message loop is skipped and we go straight to the denial
     * dialog.
     */
    while (_fbPicsWaitFlags) {
        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog entering msg loop, waitflags=%x", (DWORD)_fbPicsWaitFlags);

        MSG msg;
        if (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (!_fPicsAccessAllowed) {

        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog, access denied");

        BOOL fOldInDialog;

        // If this is silent-mode (no UI == screensaver), always deny access
        // without any dialog.
        BOOL fFrameIsSilent = FALSE;    // Assume non-silent
        _pdoh->_GetOfflineSilent(NULL, &fFrameIsSilent);
        if (fFrameIsSilent) {
            TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog access denied in silent mode, aborting");
            return IDCANCEL;
        }

        // Protect against us getting whacked out
        // from under ourselves
        fOldInDialog = _fInDialog;
        _fInDialog = TRUE;

        // This doesn't get down to trident to stop it from navigating.
        // We need some sort of navigation freeze mechanism.
        _pdoh->_EnableModeless(FALSE);

        HRESULT hres = S_OK;
        IOleCommandTarget *pcmdtTop;
        if (SUCCEEDED(_pdoh->QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (void **)&pcmdtTop))) {
            VARIANTARG v = { 0 };
            v.vt = VT_INT_PTR;
            v.byref = _pRatingDetails;
            hres = pcmdtTop->Exec(&CGID_ShellDocView, SHDVID_PICSBLOCKINGUI, 0, &v, NULL);
            pcmdtTop->Release();
        }

        UINT uRet = (hres == S_OK) ? IDOK : IDCANCEL;
        _pdoh->_EnableModeless(TRUE);
        _fPicsAccessAllowed = (uRet == IDOK);

        _fInDialog = fOldInDialog;

        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog returning %d", uRet);

        return uRet;
    }
    else {
        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog, access allowed");

        return IDOK;
    }
}

HRESULT CDocObjectHost::CPicsProcessor::_StartPicsQuery(LPCOLESTR pwszRawURL)
{
#ifdef DEBUG

    HRESULT hres;
    IRatingNotification* pRatingNotify;
    hres = _pdoh->QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        ASSERT(S_OK == pRatingNotify->IsRatingsEnabled());
        pRatingNotify->Release();
    }
    else
    {
        ASSERT(IS_RATINGS_ENABLED() && ::RatingEnabledQuery() == S_OK);
    }
#endif DEBUG

    TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery entered with ratings enabled");

    BOOL fEnforce = TRUE;
    if (_pszPicsURL != NULL) {
        delete _pszPicsURL;
        _pszPicsURL = NULL;
    }

    {
        /* We have to call CoInternetGetSecurityUrl to convert pluggable
         * protocols into known schemes, so we know whether we need to
         * enforce ratings on them.
         */
        LPOLESTR pwszSecurityURL = NULL;

        if (SUCCEEDED(CoInternetGetSecurityUrl(pwszRawURL, &pwszSecurityURL,
                                               PSU_SECURITY_URL_ONLY, 0)))
        {
            // List of protocols for which we never enforce ratings.
            if (!StrCmpNIW(pwszSecurityURL, L"file:", 5) ||
                !StrCmpNIW(pwszSecurityURL, L"about:", 6) ||
                !StrCmpNIW(pwszSecurityURL, L"mk:", 3)) {
                fEnforce = FALSE;
            }
            else {
                Str_SetPtr(&_pszPicsURL, pwszSecurityURL);
            }

            OleFree(pwszSecurityURL);
        }
    }

    if (fEnforce) {

        TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery (%s) turning on wait flags", _pszPicsURL);

        _fbPicsWaitFlags = PICS_WAIT_FOR_ASYNC
                         | PICS_WAIT_FOR_INDOC
                         | PICS_WAIT_FOR_END
                         | PICS_WAIT_FOR_ROOT
                         ;
        _fPicsAccessAllowed = 0;

        HRESULT hr;
        _dwPicsSerialNumber = ::_AddPicsQuery(_pdoh->_hwnd);
        if (_dwPicsSerialNumber == 0)
            hr = E_OUTOFMEMORY;
        else
        {
            //
            // The ratings apis are ansi.
            //

            CHAR szURL[MAX_URL_STRING];

            SHUnicodeToAnsi(_pszPicsURL, szURL, ARRAYSIZE(szURL));
            hr = RatingObtainQuery(szURL, _dwPicsSerialNumber, RatingObtainQueryCallback, &_hPicsQuery);
        }
        if (FAILED(hr)) {
            TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery no async query queued");
            ::_RemovePicsQuery(_dwPicsSerialNumber);
            _dwPicsSerialNumber = 0;
            _fbPicsWaitFlags &= ~PICS_WAIT_FOR_ASYNC;
        }
        else {
            TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery async query queued");
        }
    }
    else {
        // JHarding: IF we're not enforcing, we need to tell anyone who's waiting on an answer.
        return S_FALSE;
    }   

    return S_OK;
}
void CDocObjectHost::CPicsProcessor::_HandleDocumentEnd(void)
{
    BYTE bFlag = (_pRootDownload != NULL) ? PICS_WAIT_FOR_ROOT : PICS_WAIT_FOR_END;

    TraceMsg(DM_PICS, "CDOH::CPP::_HandleDocumentEnd -- no more PICS labels from source %x", (DWORD)bFlag);

    // If we have a private window, we'll make sure the root download is gone when we
    // notify the window.  This simplifies the lifetime of the secondary CPicsProcessors
    if (!_pPrivWindow)
    {
        if (_pRootDownload != NULL) {
            ::PostMessage(_pdoh->_hwnd, WM_PICS_ROOTDOWNLOADCOMPLETE, 0, 0);
        }
        else {
            /* End of document;  revoke the IOleCommandTarget we gave to the document,
             * so it won't send us any more notifications.
             */
            VARIANTARG v;
            v.vt = VT_UNKNOWN;
            v.punkVal = NULL;

            IUnknown_Exec(_pdoh->_pole, &CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
        }
    }
    else
    {
        if (_pRootDownload == NULL)
        {
            _pPrivWindow->SetPICSTarget(NULL);
        }
    }

    if (!(_fbPicsWaitFlags & bFlag)) {
        TraceMsg(DM_PICS, "CDOH::CPP::_HandleDocumentEnd skipping due to waitflags %x", (DWORD)_fbPicsWaitFlags);
        return;
    }

    _fbPicsWaitFlags &= ~PICS_WAIT_FOR_INDOC;   /* we know we won't get any more indoc labels */

    LPVOID pDetails = NULL;

    //
    // Ratings has only ansi apis!
    //
    CHAR szURL[MAX_URL_STRING];
    SHUnicodeToAnsi(_pszPicsURL, szURL, ARRAYSIZE(szURL));

    HRESULT hres = ::RatingCheckUserAccess(NULL, szURL, NULL, NULL, _dwPicsLabelSource, &pDetails);

    _GotLabel(hres, pDetails, bFlag);

    if (_pRootDownload == NULL) {
        if (_fbPicsWaitFlags)
            _StartPicsRootQuery(_pszPicsURL);
    }
}

void CDocObjectHost::CPicsProcessor::_GotLabel(HRESULT hres, LPVOID pDetails, BYTE bfSource)
{
    TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel hres=%x, source=%x, waitflags=%x", hres, (DWORD)bfSource, (DWORD)_fbPicsWaitFlags);

    /* If we've already gotten a result from this or a more significant source,
     * ignore this one.
     */
    if (!(_fbPicsWaitFlags & bfSource)) {
        TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel already got label from that source");

        if (pDetails != NULL)
        {
            ::RatingFreeDetails(pDetails);
            pDetails = NULL;
        }
    }
    else {
        /* If the result is an error somehow (label doesn't apply, etc.), and
         * we can expect more labels from this source, then we don't do anything
         * except save the rating details if we haven't got any yet.
         */
        if (FAILED(hres) && (PICS_MULTIPLE_FLAGS & bfSource)) {
            TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel label error and may be multiple");

            if (_pRatingDetails == NULL)
            {
                _pRatingDetails = pDetails;
            }
            else
            {
                if ( pDetails )
                {
                    ::RatingFreeDetails(pDetails);
                    pDetails = NULL;
                }
            }
        }
        else {
            /* Either we got a definitive answer from this rating source, or
             * this is the only answer we'll get from it.  We clear at least
             * the flag for this source so we know we've heard from it.  If
             * the response was not an error, then clear flags for all less
             * significant sources as well, so that we'll ignore them.  On
             * the other hand, if this source returned an error, it didn't
             * give us anything useful, so we keep looking at other sources.
             */
            if (SUCCEEDED(hres))
                _fbPicsWaitFlags &= bfSource - 1;
            else
                _fbPicsWaitFlags &= ~bfSource;

            TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel, waitflags now %x", (DWORD)_fbPicsWaitFlags);

            if (hres == S_OK) {
                TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel allowing access");

                if ( pDetails )
                {
                    ::RatingFreeDetails( pDetails );  /* don't need this if access allowed */
                    pDetails = NULL;
                }

                _fPicsAccessAllowed = 1;
            }
            else {
                /* Access denied or error.  Meaningful details from this result
                 * can override details from an earlier, less significant
                 * result.  Only explicitly deny access if not an error,
                 * though (this handles the valid root label followed by
                 * invalid in-document label, for example).
                 */
                if (pDetails != NULL) {
                    if (_pRatingDetails != NULL)
                    {
                        ::RatingFreeDetails(_pRatingDetails);
                    }

                    _pRatingDetails = pDetails;
                }
                if (SUCCEEDED(hres))
                    _fPicsAccessAllowed = 0;
            }
        }
    }

    // If we are a secondary processor (_pPrivWindow != NULL) then
    // we always want to report when the check is complete
    //
    if ((_pPrivWindow || _pdoh->_fPicsBlockLate) && !_fbPicsWaitFlags)
    {
        _HandlePicsChecksComplete();
    }
}


void CDocObjectHost::CPicsProcessor::_HandleInDocumentLabel(LPCTSTR pszLabel)
{
    BYTE bFlag = (_pRootDownload != NULL) ? PICS_WAIT_FOR_ROOT : PICS_WAIT_FOR_INDOC;

    TraceMsg(DM_PICS, "CDOH::CPP::_HandleInDocumentLabel source %x gave label %s", (DWORD)bFlag, pszLabel);

    if (!(_fbPicsWaitFlags & bFlag)) {
        TraceMsg(DM_PICS, "CDOH::CPP::_HandleInDocumentLabel rejecting based on waitflags %x", (DWORD)_fbPicsWaitFlags);
        return;
    }

    LPVOID pDetails = NULL;
    //
    // Ratings has only ansi apis!
    //
    CHAR szURL[MAX_URL_STRING];
    SHUnicodeToAnsi(_pszPicsURL, szURL, ARRAYSIZE(szURL));


    UINT cbMultiByte = WideCharToMultiByte(CP_ACP, 0, pszLabel,
                                           -1, NULL, 0, NULL, NULL);
    if (cbMultiByte > 0) {
        char *pszLabelAnsi = new char[cbMultiByte+1];
        if (pszLabelAnsi != NULL)
        {
            if (WideCharToMultiByte(CP_ACP, 0, pszLabel, -1, pszLabelAnsi,
                                    cbMultiByte+1, NULL, NULL))
            {
                HRESULT hres = ::RatingCheckUserAccess(NULL, szURL,
                                                       pszLabelAnsi, NULL, _dwPicsLabelSource,
                                                       &pDetails);
                _GotLabel(hres, pDetails, bFlag);
            }

            delete [] pszLabelAnsi;
        }
    }
}

/* This function parses the URL being downloaded and, if the URL doesn't
 * already refer to the root document of the site, sets up a subordinate
 * CDocObjectHost to download that root document, so we can get ratings
 * out of it.
 */
void CDocObjectHost::CPicsProcessor::_StartPicsRootQuery(LPCTSTR pszURL)
{
    if (_fbPicsWaitFlags & PICS_WAIT_FOR_ROOT) {
        BOOL fQueued = FALSE;

        TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery parsing %s", pszURL);

        WCHAR wszRootURL[MAX_URL_STRING+1];
        DWORD cchResult;

        /* The pszURL we're passed is actually the result of calling
         * CoInternetGetSecurityUrl, and so may not be the scheme that
         * the caller is browsing to.  To support pluggable protocols
         * determining the root location themselves, we first use the
         * URL reported by _GetCurrentPage, which may refer to a
         * pluggable protocol; if that fails, we use the more standard
         * URL.
         */
        HRESULT hres = INET_E_DEFAULT_ACTION;

        LPOLESTR pwszURL = NULL;
        if (SUCCEEDED(_pdoh->_GetCurrentPageW(&pwszURL, TRUE)))
        {
            hres = CoInternetParseUrl(pwszURL, PARSE_ROOTDOCUMENT, 0, wszRootURL,
                                      ARRAYSIZE(wszRootURL), &cchResult, 0);

            OleFree(pwszURL);
        }

        if (pszURL != NULL && (hres == INET_E_DEFAULT_ACTION || hres == E_FAIL)) {
            /* Pluggable protocol doesn't support PARSE_ROOTDOCUMENT.  Use the
             * more standard URL we were supplied with.
             */
            hres = CoInternetParseUrl(pszURL, PARSE_ROOTDOCUMENT, 0, wszRootURL,
                                      ARRAYSIZE(wszRootURL), &cchResult, 0);
        }

        if (SUCCEEDED(hres)) {
            IMoniker *pmk = NULL;
            hres = MonikerFromURL(wszRootURL, &pmk);

            if (SUCCEEDED(hres)) {
                BOOL fFrameIsSilent = FALSE;
                BOOL fFrameIsOffline = FALSE;

                _pdoh->_GetOfflineSilent(&fFrameIsOffline, &fFrameIsSilent);

                _pRootDownload = new CPicsRootDownload(this, fFrameIsOffline, fFrameIsSilent);
                if (_pRootDownload != NULL) {
                    TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery starting download");
                    hres = _pRootDownload->StartDownload(pmk);
                    if (SUCCEEDED(hres))
                        fQueued = TRUE;
                }
            }
            if (pmk != NULL)
                pmk->Release();
        }
        if (!fQueued) {
            _fbPicsWaitFlags &= ~PICS_WAIT_FOR_ROOT;
            TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery queueing failed, waitflags now %x", (DWORD)_fbPicsWaitFlags);
            if (!_fbPicsWaitFlags) {
                _HandlePicsChecksComplete();
            }
        }
    }
    else {
        TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery no query queued, waitflags=%x", (DWORD)_fbPicsWaitFlags);
    }
}

void CDocObjectHost::CPicsProcessor::_HandlePicsChecksComplete(void)
{
    if (!_fPicsAccessAllowed) 
    {
        TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete access denied, posting WM_PICS_DOBLOCKINGUI to hwnd %x", (DWORD_PTR)_pdoh->_hwnd);

        /* Allow download of this and other frames to continue while we post
         * the denial UI.
         */
        if (!PostMessage(_pdoh->_hwnd, WM_PICS_DOBLOCKINGUI, 0, _GetKey())) {
            TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete couldn't post message!");
        }
    }
    else 
    {
        if( _pPrivWindow )
        {
            TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete access allowed, posting WM_PICS_RESULTTOPRIVWIN");

            if (!PostMessage( _pdoh->_hwnd, WM_PICS_RESULTTOPRIVWIN, IDOK, _GetKey()))
            {
                TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete couldn't post message!");
            }
        }
        else
        {
            TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete access allowed, execing ACTIVATEMENOW");
            if (!_pdoh->_fSetTarget && _pdoh->_pmsoctBrowser)
            {
                _pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_ACTIVATEMENOW, NULL, NULL, NULL);
            }
        }
    }
}



void CDocObjectHost::CPicsProcessor::_ReInit()
{
    TraceMsg(DM_PICS, "CDOH::CPP::_ReInit");

    _fPicsAccessAllowed = TRUE;
    _fInDialog = FALSE;
    _fTerminated = FALSE;

    _fbPicsWaitFlags = 0;
    _dwPicsLabelSource = 0;

    if (_pPrivWindow)
    {
        _pPrivWindow->SetPICSTarget(NULL);
        _pPrivWindow->Release();
        _pPrivWindow = NULL;
    }

    if (_pRootDownload != NULL) {
        _pRootDownload->CleanUp();
        ATOMICRELEASET(_pRootDownload,CPicsRootDownload);
    }

    _pPicsProcNext = NULL;

    if (_pRatingDetails){
        ::RatingFreeDetails(_pRatingDetails);
        _pRatingDetails = NULL;
    }

    if (_dwPicsSerialNumber) {
        ::_RemovePicsQuery(_dwPicsSerialNumber);
        _dwPicsSerialNumber = 0;
    }

    if (_hPicsQuery)
    {
        RatingObtainCancel(_hPicsQuery);
        _hPicsQuery = NULL;
    }

    if ( _pszPicsURL )
    {
        delete _pszPicsURL;
        _pszPicsURL = NULL;
    }
}

void 
CDocObjectHost::CPicsProcessor::_Terminate()
{
    ASSERT( this != &(_pdoh->_PicsProcBase) );

    if (!_fInDialog)
    {
        delete this;
    }
    else
    {
        _fTerminated = TRUE;
    }
    
}


CDocObjectHost::CPicsProcessor * 
CDocObjectHost::_GetPicsProcessorFromKey(LONG_PTR lKey)
{
    CPicsProcessor * ppp = &_PicsProcBase;

    while( ppp )
    {
        if (ppp->_GetKey() == lKey)
            return ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return NULL;
}

CDocObjectHost::CPicsProcessor * 
CDocObjectHost::_GetPicsProcessorFromSerialNumber(DWORD dwSerial)
{
    CPicsProcessor * ppp = &_PicsProcBase;

    ASSERT( dwSerial != NULL );

    while( ppp )
    {
        if (ppp->_dwPicsSerialNumber == dwSerial)
            return ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return NULL;
}

void CDocObjectHost::_StartBasePicsProcessor()
{
    HRESULT hres;
    BOOL bRatingsEnabled;
    IRatingNotification* pRatingNotify;

    hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        bRatingsEnabled = pRatingNotify->IsRatingsEnabled() ? FALSE : TRUE;
        pRatingNotify->Release();
    }
    else
    {
        bRatingsEnabled = IS_RATINGS_ENABLED() && ::RatingEnabledQuery() == S_OK;
    }

    if(bRatingsEnabled)
    {
        TraceMsg(DM_PICS, "CDOH::_StartBasePicsProcessor entered with ratings enabled");

        LPOLESTR pwszRawURL = NULL;

        if (SUCCEEDED(_GetCurrentPageW(&pwszRawURL, TRUE)))
        {
            _PicsProcBase._StartPicsQuery(pwszRawURL);

            OleFree(pwszRawURL);
        }
    }
}

HRESULT CDocObjectHost::_StartSecondaryPicsProcessor(IHTMLPrivateWindow * pPrivWin)
{
    HRESULT hr = S_FALSE;

    ASSERT( pPrivWin );

    HRESULT hres;
    BOOL bRatingsEnabled;
    IRatingNotification* pRatingNotify;

    hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        bRatingsEnabled = pRatingNotify->IsRatingsEnabled() ? FALSE : TRUE;
        pRatingNotify->Release();
    }
    else
    {
        bRatingsEnabled = IS_RATINGS_ENABLED() && ::RatingEnabledQuery() == S_OK;
    }
    
    if (bRatingsEnabled)
    {
        LPOLESTR          pwszURL = NULL;

        // CWindow::GetPendingUrl() has LPOLESTR * parameter. 
        hr = pPrivWin->GetPendingUrl( &pwszURL );
        if ( SUCCEEDED(hr) && pwszURL )
        {
            CPicsProcessor * pPicsProc = new CPicsProcessor;
            if( pPicsProc )
            {
                pPicsProc->_pdoh = this;
                pPicsProc->_pPrivWindow = pPrivWin;
                pPrivWin->AddRef();
                pPicsProc->_dwKey = _dwPicsKeyBase++;

                hr = pPicsProc->_StartPicsQuery( pwszURL );
                if( hr == S_FALSE )
                {
                    delete pPicsProc;
                }
                else
                {
                    pPicsProc->_pPicsProcNext = _PicsProcBase._pPicsProcNext;
                    _PicsProcBase._pPicsProcNext = pPicsProc;
                    pPrivWin->SetPICSTarget( SAFECAST(pPicsProc, IOleCommandTarget *) );
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            OleFree( pwszURL );
        }
    }

    return hr;
}

HRESULT CDocObjectHost::_RemovePicsProcessorByKey(LONG_PTR lKey)
{
    ASSERT( lKey != 0 );

    // The base Proc has a 0 key and should never be removed

    CPicsProcessor * ppp = &_PicsProcBase;
    CPicsProcessor * pppLast = NULL;

    while( ppp )
    {
        if (ppp->_GetKey() == lKey)
        {
            ASSERT(pppLast);
            pppLast->_pPicsProcNext = ppp->_pPicsProcNext;

            ppp->_Terminate();
            return S_OK;
        }

        pppLast = ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return S_FALSE;
}

HRESULT CDocObjectHost::_RemovePicsProcessorByPrivWindowUnk(IUnknown* pUnkFind)
{
    ASSERT( pUnkFind );

    // The base Proc has a 0 key and should never be removed

    CPicsProcessor * ppp = &_PicsProcBase;
    CPicsProcessor * pppLast = NULL;

    while( ppp )
    {
        if (ppp->_pPrivWindow)
        {
            IUnknown * pUnkThisOne;

            if (SUCCEEDED( ppp->_pPrivWindow->QueryInterface( IID_IUnknown, (void**)&pUnkThisOne ) ))
            {
                if (pUnkThisOne == pUnkFind)
                {
                    ASSERT(pppLast);
                    pppLast->_pPicsProcNext = ppp->_pPicsProcNext;

                    ppp->_Terminate();

                    pUnkThisOne->Release();
                    return S_OK;
                }
                pUnkThisOne->Release();
            }
        }

        pppLast = ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return S_FALSE;
}

HRESULT CDocObjectHost::_RemoveAllPicsProcessors()
{
    CPicsProcessor * ppp = &_PicsProcBase;
    CPicsProcessor * pppNext;

    while( ppp )
    {
        pppNext = ppp->_pPicsProcNext;
        if (ppp != &_PicsProcBase)
            ppp->_Terminate();
        else
            ppp->_ReInit();
        ppp = pppNext;
    }

    return S_OK;
}

HRESULT CDocObjectFrame::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    return _pdoh->QueryService(guidService, riid, ppvObj);
}

HRESULT CDocObjectFrame::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IOleInPlaceFrame) ||
        IsEqualIID(riid, IID_IOleInPlaceUIWindow) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceFrame*);
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget*);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IInternetSecurityMgrSite))
    {
        *ppvObj = SAFECAST(this, IInternetSecurityMgrSite*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    _pdoh->AddRef();
    return NOERROR;
}

ULONG CDocObjectFrame::AddRef(void)
{
    return _pdoh->AddRef();
}

ULONG CDocObjectFrame::Release(void)
{
    return _pdoh->Release();
}

HRESULT CDocObjectFrame::GetWindow(HWND * lphwnd)
{
    DOFMSG(TEXT("GetWindow called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->GetWindow(lphwnd) :
        _pdoh->_psb ? _pdoh->_psb->GetWindow(lphwnd) :
        _pdoh->GetWindow(lphwnd);
}

HRESULT CDocObjectFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    DOFMSG(TEXT("ContextSensitiveHelp called"));
    return _pdoh->ContextSensitiveHelp(fEnterMode);
}

HRESULT CDocObjectFrame::GetBorder(LPRECT lprectBorder)
{
    // DOFMSG(TEXT("GetBorder called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->GetBorder(lprectBorder) : E_UNEXPECTED;
}

HRESULT CDocObjectFrame::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    DOFMSG(TEXT("RequestBorderSpace called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->RequestBorderSpace(pborderwidths) : E_UNEXPECTED;
}

HRESULT CDocObjectFrame::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    // DOFMSG(TEXT("SetBorderSpace called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->SetBorderSpace(pborderwidths) : E_UNEXPECTED;
}

HRESULT CDocObjectFrame::SetActiveObject(
        IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    DOFMSG(TEXT("SetActiveObject called"));

    // Note that we need to call both.
    _pdoh->_xao.SetActiveObject(pActiveObject);

    if (_pdoh->_pipu) {
        //
        // Note that we should pass proxy IOleActiveObject pointer instead.
        //
        _pdoh->_pipu->SetActiveObject(pActiveObject ? &_pdoh->_xao : NULL, pszObjName);
    }
    return S_OK;
}

HRESULT CDocObjectFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    DOFMSG2(TEXT("InsertMenus called with"), hmenuShared);
    return _pdoh->_InsertMenus(hmenuShared, lpMenuWidths);
}

HRESULT CDocObjectFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    DOFMSG2(TEXT("SetMenu called with"), hmenuShared);
    return _pdoh->_SetMenu(hmenuShared, holemenu, hwndActiveObject);
}

HRESULT CDocObjectFrame::RemoveMenus(HMENU hmenuShared)
{
    DOFMSG(TEXT("RemoveMenus called"));
    return _pdoh->_RemoveMenus(hmenuShared);
}

HRESULT CDocObjectFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    DOFMSG(TEXT("SetStatusText called"));
    return _pdoh->_SetStatusText(pszStatusText);
}

HRESULT CDocObjectFrame::EnableModeless(BOOL fEnable)
{
    DOFMSG(TEXT("EnableModeless called"));
    return _pdoh->_EnableModeless(fEnable);
}

// IOleInPlaceFrame::TranslateAccelerator
HRESULT CDocObjectFrame::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // NOTES: This code remains as-is. If we have something special
    //  it should be done in CDocObjectHost::TranslateAccelerator
    return _pdoh->_TranslateAccelerator(lpmsg, wID);
}

HRESULT CDocObjectFrame::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    DOFMSG(TEXT("QueryStatus called"));
    return _pdoh->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CDocObjectFrame::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    DOFMSG(TEXT("Exec called"));
    return _pdoh->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

//***   CPAO::TranslateAccelerator (IOIPAO::TranslateAccelerator)
//
HRESULT CProxyActiveObject::TranslateAccelerator(
    LPMSG lpmsg)
{
    HRESULT hres = E_FAIL;

    // IShellBrowser is supporsed to call ISV::TranslateAcceleratorSV,
    // but why not be nice?
    ASSERT(!_pdoh->_fCycleFocus);

    //
    // Don't call DocObject's TranslateAccelarator with non-key messages.
    // It's better to be IE compatible.
    //
    BOOL fKeybrdMsg = IsInRange(lpmsg->message, WM_KEYFIRST, WM_KEYLAST);
    if (fKeybrdMsg && _piact && (hres = _piact->TranslateAccelerator(lpmsg)) == S_OK) {
        if (_pdoh->_fCycleFocus) {
            // we got called back by trident (IOCS::TA), but deferred it.
            // time to pay the piper.
            TraceMsg(DM_FOCUS, "DOH::IOIPAO::TA piao->TA==S_OK ret _fCycleFocus=FALSE hr=S_FALSE (piper)");
            _pdoh->_fCycleFocus = FALSE;
            return S_FALSE;     // time to pay the piper
        }
        return S_OK;
    }
    if (_pdoh->_fCycleFocus) {
        TraceMsg(DM_ERROR, "DOH::IOIPAO::TA _fCycleFocus && hres=%x (!=S_OK)", hres);
        _pdoh->_fCycleFocus = FALSE;
        return S_FALSE;
    }

    return _pdoh->TranslateHostAccelerators(lpmsg);
}

HRESULT CProxyActiveObject::OnFrameWindowActivate(
    BOOL fActivate)
{
    TraceMsg(TF_SHDUIACTIVATE, "CProxyAO::OnFrameWindowActivate called with %d (_piact=%x)",
             fActivate, _piact);
    if (_piact) {
        return _piact->OnFrameWindowActivate(fActivate);
    }
    return S_OK;
}

HRESULT CProxyActiveObject::OnDocWindowActivate(
    BOOL fActivate)
{
    return S_OK;
}

HRESULT CProxyActiveObject::ResizeBorder(
    LPCRECT prcBorder,
    IOleInPlaceUIWindow *pUIWindow,
    BOOL fFrameWindow)
{
    if (_piact) {
        //
        // Note that we must pass our proxy frame instead!
        //
        return _piact->ResizeBorder(prcBorder, &_pdoh->_dof, TRUE);
    }
    return E_FAIL;
}
void CProxyActiveObject::SetActiveObject(IOleInPlaceActiveObject *piact )
{
    if (_piact)
    {
        ATOMICRELEASE(_piact);
        _hwnd = NULL;
    }

    if (piact) {
        _piact = piact;
        _piact->AddRef();
        _piact->GetWindow(&_hwnd);
    }
}

HRESULT CProxyActiveObject::EnableModeless(
    BOOL fEnable)
{
    // IShellBrowser is supporsed to call ISV::EnableModelessSV,
    // but why not be nice?
    HRESULT hres = S_OK;
    if (_piact)
        hres = _piact->EnableModeless(fEnable);
    return hres;
}

HRESULT CProxyActiveObject::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IOleInPlaceActiveObject) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceActiveObject*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    _pdoh->AddRef();
    return NOERROR;
}

ULONG CProxyActiveObject::AddRef(void)
{
    return _pdoh->AddRef();
}

ULONG CProxyActiveObject::Release(void)
{
    return _pdoh->Release();
}

HRESULT CProxyActiveObject::GetWindow(HWND * lphwnd)
{
    return _pdoh->GetWindow(lphwnd);
}

HRESULT CProxyActiveObject::ContextSensitiveHelp(BOOL fEnterMode)
{
    return _pdoh->ContextSensitiveHelp(fEnterMode);
}

#define ANIMATION_WND_WIDTH     (100+3)

void CDocObjectHost::_PlaceProgressBar(BOOL fForcedLayout)
{
    if (_psb) {
        HWND hwndStatus = NULL;
        _psb->GetControlWindow(FCW_STATUS, &hwndStatus);
        if (hwndStatus) {
            RECT rc;
            INT_PTR fSimple = SendMessage(hwndStatus, SB_ISSIMPLE, 0, 0);

            if (!fSimple || fForcedLayout) {
                // While processing WM_SIZE, turn off the simple mode temporarily.
                if (fSimple)
                    _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 0, 0, NULL);

                GetClientRect(hwndStatus, &rc);
                const UINT cxZone = ZoneComputePaneSize(hwndStatus);
                UINT cxProgressBar = (_fShowProgressCtl) ? 100 : 0;

                INT nSBWidth = rc.right - rc.left;
                INT arnRtEdge[STATUS_PANES] = {1};
                INT nIconPaneWidth = GetSystemMetrics(SM_CXSMICON) +
                                     (GetSystemMetrics(SM_CXEDGE) * 4);
                INT nWidthReqd = cxZone + cxProgressBar + (nIconPaneWidth * 3);

                arnRtEdge[STATUS_PANE_NAVIGATION] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= cxProgressBar;
                arnRtEdge[STATUS_PANE_PROGRESS] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= (nIconPaneWidth);
                arnRtEdge[STATUS_PANE_OFFLINE] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= (nIconPaneWidth);
                arnRtEdge[STATUS_PANE_PRIVACY] = max(1, nSBWidth - nWidthReqd);

//                nWidthReqd -= (nIconPaneWidth);
//                arnRtEdge[STATUS_PANE_PRINTER] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= (nIconPaneWidth);
                arnRtEdge[STATUS_PANE_SSL] = max(1, nSBWidth - nWidthReqd);

                arnRtEdge[STATUS_PANE_ZONE] = -1;

                LRESULT nParts = 0;
                nParts = SendMessage(hwndStatus, SB_GETPARTS, 0, 0L);
                if (nParts != STATUS_PANES)
                {
                    for ( int n = 0; n < nParts; n++)
                    {
                        SendMessage(hwndStatus, SB_SETTEXT, n | SBT_NOTABPARSING, NULL);
                        SendMessage(hwndStatus, SB_SETICON, n, NULL);
                    }
                    SendMessage(hwndStatus, SB_SETPARTS, 0, 0L);
                }

                SendMessage(hwndStatus, SB_SETPARTS, STATUS_PANES, (LPARAM)arnRtEdge);

                if (!_hwndProgress) {
                    _psb->GetControlWindow(FCW_PROGRESS, &_hwndProgress);
                }

                if (_hwndProgress) {
                    if (SendMessage(hwndStatus, SB_GETRECT, 1, (LPARAM)&rc))
                    {
                        InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE));
                    }
                    else
                    {
                        rc.left = rc.top = rc.right = rc.bottom = 0;
                    }

                    SetWindowPos(_hwndProgress, NULL,
                                 rc.left, rc.top,
                                 rc.right-rc.left, rc.bottom-rc.top,
                                 SWP_NOZORDER | SWP_NOACTIVATE);
                }

                SendMessage(hwndStatus, SB_SETTEXT, 1 | SBT_NOTABPARSING, (LPARAM)TEXT(""));
                SendMessage(hwndStatus, SB_SETMINHEIGHT, GetSystemMetrics(SM_CYSMICON) +
                                                         GetSystemMetrics(SM_CYBORDER) * 2, 0L);

                // Restore
                if (fSimple)
                     SendMessage(hwndStatus, SB_SIMPLE, TRUE, 0);
            }
        }
    } else {
        TraceMsg(TF_WARNING, "_PlaceProgressBar ASSERT(_psb) this=%x", this);
    }
}

void CDocObjectHost::_ActivateOleObject(void)
{
    HRESULT hres;
    _pole->SetClientSite(NULL);

    if (_fDontInPlaceNavigate())
    {
        TraceMsg(TF_SHDAPPHACK, "CDOH::_ActivateOleObject calling DoVerb because of _fDontInPlaceNavigate()");
    }

    _EnableModeless(FALSE);

    hres = _pole->DoVerb(
                _fUseOpenVerb() ? OLEIVERB_OPEN : OLEIVERB_PRIMARY,
                NULL, NULL, (UINT)-1, NULL, NULL);

    _EnableModeless(TRUE);

    if (SUCCEEDED(hres))
    {
        CShdAdviseSink_Advise(_pwb, _pole);
    }
#ifdef DEBUG
    else if (!_fDelegatedNavigation)
    {
        TraceMsg(DM_ERROR, "CDOH::_ActivateOleObject DoVerb failed %x.", hres);
    }
#endif

    // We must release the OLE object to avoid calling Close
    // from _UnBind.
    _ReleaseOleObject();

    _ReleasePendingObject();

}

void CDocObjectHost::ClearScriptError()
{
    // clear out the script error list
    _pScriptErrList->ClearErrorList();
    _SetPriorityStatusText(NULL);

    // reset the text and icon
    _ResetStatusBar();
}

//
// The docobject's READYSTATE property may have changed
//
void CDocObjectHost::_OnReadyState(long lVal, BOOL fUpdateHistory /* = TRUE */)
{
    // Forward this to the browser so we can source ReadyState events properly
    //  TRACE this zekel
    if (_psb)
    {
        IDocNavigate *pdn;
        if (SUCCEEDED(_psb->QueryInterface(IID_IDocNavigate, (void **)&pdn)))
        {
            ASSERT(_psv);
            pdn->OnReadyStateChange(_psv, lVal);
            pdn->Release();
        }
    }

    // NOTE: The below code is rather wasteful. The OmWindow stuff
    // should trigger off the above ReadyState code.
    //
    IShellHTMLWindowSupport *phtmlWS;
    if (_psp && SUCCEEDED(_psp->QueryService(SID_SOmWindow, IID_IShellHTMLWindowSupport, (void**)&phtmlWS)))
    {
        phtmlWS->ReadyStateChangedTo(lVal, _psv);
        phtmlWS->Release();
    }

    if (    (lVal == READYSTATE_INTERACTIVE)
        &&  (_pScriptErrList != NULL))
    {
        ClearScriptError();
    }    

    if (lVal >= READYSTATE_INTERACTIVE)
    {
        // Technically we can get this value multiple times,
        // so make sure we call _Navigate only once.
        //
        if (!_fReadystateInteractiveProcessed)
        {
            _fReadystateInteractiveProcessed = TRUE;

            _Navigate();
        }

        if (lVal == READYSTATE_COMPLETE)
        {
            _OnSetProgressPos(0, PROGRESS_RESET);

            // We aren't going to commit error pages to the history
            //
            if (_pwb && !_fErrorPage && fUpdateHistory)
            {
                WCHAR szTitle[MAX_PATH]; // titles are only stored up to this size

                if (SUCCEEDED(_pwb->GetTitle(_psv, szTitle, ARRAYSIZE(szTitle))))
                {
                    // BharatS : 01/09/97 : There is no need to tie the updating of the title in the
                    // history to the updating of the INTSITE database. Thus the INTSITE database
                    // update can be moved out of AddUrlToUrlHistoryStg() in history.cpp when time permits
                    // to a more logical place such as someplace in dochost.cpp
                    //
                    _UpdateHistoryAndIntSiteDB(szTitle);
                }
                else
                {
                    _UpdateHistoryAndIntSiteDB(NULL);
                }
            }
        }
    }
}

HRESULT CDocObjectHost::_OnChangedReadyState()
{
    IDispatch * p_idispatch;

    ASSERT(_pole || _fFriendlyError);
    if (!_pole)
        return E_UNEXPECTED;

    if (SUCCEEDED(_pole->QueryInterface( IID_IDispatch, (void **) &p_idispatch)))
    {
        VARIANTARG va;
        EXCEPINFO exInfo;

        va.vt = 0;
        if (EVAL(SUCCEEDED(p_idispatch->Invoke( DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, (DISPPARAMS *)&g_dispparamsNoArgs, &va, &exInfo, NULL))
          && va.vt == VT_I4))
        {
            _OnReadyState(va.lVal);

            // If we are hosting Trident's native frames build,
            // we don't want to call _RemoveTransitionCapability().
            //
            if (!_fDocCanNavigate && va.lVal == READYSTATE_COMPLETE)
            {
                _RemoveTransitionCapability();
            }

        }
        p_idispatch->Release();
    }

    return( NOERROR );
}

HRESULT CDocObjectHost::OnRequestEdit(DISPID dispid)
{
    return E_NOTIMPL;
}

//
// OnChanged
//
//   Notification from the DocObject that one of its
//   properties has changed.
//
HRESULT CDocObjectHost::OnChanged(DISPID dispid)
{
    if (DISPID_READYSTATE == dispid || DISPID_UNKNOWN == dispid)
        return _OnChangedReadyState();

    return S_OK;
}

extern BOOL _ValidateURL(LPTSTR pszName);

void CDocObjectHost::_UpdateHistoryAndIntSiteDB(LPCWSTR pwszTitle)
{
    TCHAR szUrl[MAX_URL_STRING];

    if (SUCCEEDED(_GetCurrentPage(szUrl, MAX_URL_STRING, TRUE)) &&
        _ValidateURL(szUrl, UQF_DEFAULT))
    {
        // update history and intsite if this isn't a silent browse
        BOOL bSilent = FALSE;
        HRESULT hr   = _GetOfflineSilent(NULL, &bSilent);

        if (SUCCEEDED(hr) && (!bSilent))
        {
            BOOL fWriteHistory,
                 fSelectHistory;

            fWriteHistory  = TRUE;
            fSelectHistory = TRUE;

            if (NULL != _pocthf)
            {
                MSOCMD rgCmd[] = { { SBCMDID_WRITEHIST, 0 }, { SBCMDID_SELECTHISTPIDL, 0 } };

                _pocthf->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgCmd), rgCmd, NULL);

                fWriteHistory  = BOOLIFY(rgCmd[0].cmdf & MSOCMDF_ENABLED);
                fSelectHistory = BOOLIFY(rgCmd[1].cmdf & MSOCMDF_ENABLED);
            }

            AddUrlToUrlHistoryStg(szUrl,
                      pwszTitle,
                      _psb,
                      fWriteHistory,
                      fSelectHistory ? _pocthf : NULL,
                      get_punkSFHistory(), NULL);

            //
            //  Satona had the redirect code ifdef'd out, but for
            //  netscape compatibility, we need to update the history
            //  for the redirected URL as well.  - zekel - 22-JUL-97
            //

            // If this page is a redirect, update intsite for destination too
            INTERNET_CACHE_ENTRY_INFO *pCacheEntry = NULL;

#ifndef UNIX
            WCHAR    chBuf[MAX_CACHE_ENTRY_INFO_SIZE];

            // Find entry in cache using redirect map
            pCacheEntry = (INTERNET_CACHE_ENTRY_INFO *)chBuf;
#else
            union
            {
                double _alignOn8;
                WCHAR   _chBuf[MAX_CACHE_ENTRY_INFO_SIZE];
            } chBuf;

            // Find entry in cache using redirect map
            pCacheEntry = (INTERNET_CACHE_ENTRY_INFO *)&chBuf;
#endif /* !UNIX */

            DWORD dwSize = SIZEOF(chBuf);
            BOOL fSuccess = GetUrlCacheEntryInfoEx(szUrl, pCacheEntry, &dwSize, NULL, 0, NULL, 0);

            if (fSuccess)
            {
                // If we have a different url than we started with, update it too
                if (StrCmp(szUrl, pCacheEntry->lpszSourceUrlName)) 
                {
                    AddUrlToUrlHistoryStg(pCacheEntry->lpszSourceUrlName,
                              pwszTitle,
                              _psb,
                              fWriteHistory,
                              fSelectHistory ? _pocthf : NULL,
                              get_punkSFHistory(), NULL);
                }
            }
        }
    }
}



//
// CDocObjectHost::_SetUpTransitionCapability()
//
//   Returns TRUE if all the following hold true:
//      - object has readystate property
//      - readystate property is currently < interactive
//      - Object supports IPropertyNotifySink
//   Then this object supports delayed switching when it
//   it tells us that it is ready...
//
//   This is how we switch pages only when the new page is ready to be
//   switched to.    Also, by doing this we can also make the switch smooth
//   by applying graphical transitions.
//

BOOL CDocObjectHost::_SetUpTransitionCapability(BOOL fWindowOpen /* = FALSE */)
{
    // By default DocObject doesn't have gray-flash communication
    BOOL fSupportsReadystate = FALSE;
    long lReadyState = 0;   // Init to avoid a bogus C4701 warning

    // Sanity Check
    if (!_pole)
        return(fSupportsReadystate);

    // Check for proper readystate support
    BOOL fReadyStateOK = FALSE;
    IDispatch * p_idispatch;
    if (SUCCEEDED(_pole->QueryInterface( IID_IDispatch, (void **) &p_idispatch )))
    {
        VARIANTARG va;
        EXCEPINFO exInfo;

        if (SUCCEEDED(p_idispatch->Invoke( DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT,  DISPATCH_PROPERTYGET, (DISPPARAMS *)&g_dispparamsNoArgs, &va, &exInfo, NULL)))
        {
            if ((va.vt == VT_I4) && (va.lVal < READYSTATE_COMPLETE))
            {
                lReadyState = fWindowOpen ? READYSTATE_COMPLETE : va.lVal;
                fReadyStateOK = TRUE;
            }
        }

        p_idispatch->Release();
    }

    if (fReadyStateOK)
    {
        // Check and Set-Up IPropertyNotifySink
        if (SUCCEEDED(ConnectToConnectionPoint(SAFECAST(this, IPropertyNotifySink*), IID_IPropertyNotifySink, TRUE, _pole, &_dwPropNotifyCookie, NULL)))
        {
            fSupportsReadystate = TRUE;
            _OnReadyState(lReadyState);
        }
    }

    // If no ReadyState, we simulate it
    if (!fSupportsReadystate)
    {
        if (fWindowOpen)
        {
            // Connect the property notify sink or we
            // will never activate the pending view.
            //
            ConnectToConnectionPoint(SAFECAST(this, IPropertyNotifySink*),
                                     IID_IPropertyNotifySink, 
                                     TRUE, 
                                     _pole,
                                     &_dwPropNotifyCookie,
                                     NULL);
        }

        _OnReadyState(READYSTATE_COMPLETE, !fWindowOpen);
    }

    return(fSupportsReadystate);
}

// This removes any property notify sink we set up
//
BOOL CDocObjectHost::_RemoveTransitionCapability()
{
    BOOL fRet = FALSE;

    if (_dwPropNotifyCookie)
    {
        ConnectToConnectionPoint(NULL, IID_IPropertyNotifySink, FALSE, _pole, &_dwPropNotifyCookie, NULL);
        fRet = TRUE;
    }

    return(fRet);
}

HRESULT _GetRequestFlagFromPIB(IBinding *pib, DWORD *pdwOptions)
{
    HRESULT hres = E_FAIL;
    *pdwOptions = 0;
    if (pib)
    {
        IWinInetInfo* pwinet;
        hres = pib->QueryInterface(IID_IWinInetInfo, (void **)&pwinet);
        if (SUCCEEDED(hres)) {
            DWORD cbSize = SIZEOF(*pdwOptions);
            hres = pwinet->QueryOption(INTERNET_OPTION_REQUEST_FLAGS,
                                (LPVOID)pdwOptions, &cbSize);
            TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() pwinet->QueryOptions hres=%x dwOptions=%x", hres, *pdwOptions);

            pwinet->Release();
        }
    }
    return hres;
}

void CDocObjectHost::_Navigate()
{
    NAVMSG3(TEXT("_Navigate calling SHDVID_ACTIVATEMENOW"), 0, NULL);

    if (_pmsoctBrowser)
    {
        VARIANT varSynch;

        V_VT(&varSynch)   = VT_BOOL;
        V_BOOL(&varSynch) = _fDocCanNavigate ? VARIANT_TRUE : VARIANT_FALSE;

        _pmsoctBrowser->Exec(&CGID_ShellDocView,
                             SHDVID_ACTIVATEMENOW,
                             NULL,
                             &varSynch,
                             NULL);
    }
}

#ifndef UNIX
void CDocObjectHost::_NavigateFolder(BSTR bstrUrl)
{
    // This code accesses one of IE's default behaviors which
    // allows for navigation to a web folder.
    // ------------------------------------------------------

    Iwfolders * pWF = NULL;
    IElementBehaviorFactory * pebf = NULL;
    IElementBehavior * pPeer = NULL;
    HWND hwndOwner = NULL;
    IServiceProvider * psp = NULL;
    IUnknown * punkwb = NULL;

    // Make the peer factory
    if  ( !_psb || (FAILED(_psb->GetWindow (&hwndOwner))) ||
          (FAILED(CoCreateInstance(CLSID_PeerFactory, NULL, CLSCTX_INPROC,
                          IID_IElementBehaviorFactory, (void **)&pebf))) ||
          (FAILED(pebf->FindBehavior(L"httpFolder", NULL, NULL, &pPeer))) ||
          (FAILED(pPeer->QueryInterface(IID_Iwfolders, (void **)&pWF))) ||
          (FAILED(QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&psp))) ||
          (FAILED(psp->QueryService(SID_SContainerDispatch, IID_IUnknown, (void **)&punkwb))) )
    {
        WCHAR wszMessage[MAX_PATH];
        WCHAR wszTitle[MAX_PATH];

        MLLoadShellLangString(IDS_ERRORINTERNAL, wszMessage, ARRAYSIZE(wszMessage));
        MLLoadShellLangString(IDS_NAME, wszTitle, ARRAYSIZE(wszTitle));

        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        MessageBox(hwndOwner, wszMessage, wszTitle, MB_OK | MB_ICONERROR);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        goto done;
    }

    // Sundown: coercion to unsigned long is valid for HWNDs
    pWF->navigateNoSite(bstrUrl, NULL, PtrToUlong(hwndOwner), punkwb);

done:
    if (pebf)
        pebf->Release();
    if (pPeer)
        pPeer->Release();
    if (pWF)
        pWF->Release();
    if (punkwb)
        punkwb->Release();
    if (psp)
        psp->Release();
}
#endif //UNIX

void CDocObjectHost::_CancelPendingNavigation(BOOL fAsyncDownload,
                                              BOOL fSyncReally, /* = FALSE */
                                              BOOL fDontShowNavCancelPage, /* = FALSE */
                                              BOOL fForceClose /* = FALSE */)
{
    ASSERT(_phf);

     // TODO: We need to clean up the call to this method and eliminate need for fSyncReally
    //
    // Passing NULL for the 4th argument (instead of passing in a
    // variant like we do in the case when fAsyncDownload is TRUE) looks plain wrong!
    // See how this command+argument is interpreted in CBaseBrowser2::Exec.
    // It is too close to RTM (of IE5.5) now to fix this. The net result is that
    // when this function is called with fAsyncDownload=FALSE, we end up posting
    // ASYNCOP_CANCELPENDINGNAVIGATION, which is just what the caller does not want.
    // To workaround this, I have introduced the argument fSyncReally.

    // the hlframe no longer knows if the clear was a cancel or a start of navigation
    // because we don't call anything tosignal a successfull navigation
    if (_pmsoctBrowser)
    {
        TraceMsg(DM_TRACE, "DOH::_CancelPendingNavigation calling _pmsc->Exec");

        if (_pwb && fDontShowNavCancelPage)
        {
            _pwb->SetFlags(BSF_DONTSHOWNAVCANCELPAGE, BSF_DONTSHOWNAVCANCELPAGE);
        }

        if (fForceClose && _fWindowOpen)  // Force the browser to close
        {
             HideBrowser();  // Makes the browser appear to go away faster.

            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELANDCLOSE, 0, NULL, NULL);
        }
        else if (fAsyncDownload)
        {
            VARIANT var = {0};
            var.vt = VT_I4;
            ASSERT(var.lVal == FALSE);    // asynd download is done.

            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, &var, NULL);
        }
        else if (fSyncReally)
        {
            VARIANT var = { 0 };
            var.vt = VT_I4;
            var.lVal = TRUE;

            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, &var, NULL);
        }
        else
        {
            // This actually causes an async cancel
            //
            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, NULL, NULL);
        }
    }

    // Release our navigation state.
    // Doing a "fSyncReally" may cause us to lose our _phf member value.  Check it again.
    //
    if (_phf)
    {
        _phf->Navigate(0, NULL, NULL, (IHlink*)-1);
    }
}

void CDocObjectHost::_ResetStatusBar()
{
    _SetStatusText(TEXT(""));
    if (_psb)
        _psb->SendControlMsg(FCW_STATUS, SB_SETICON, STATUS_PANE_NAVIGATION,
                              (LPARAM)g_ahiconState[IDI_STATE_NORMAL-IDI_STATE_FIRST], NULL);
    return;
}

void CDocObjectHost::_DoAsyncNavigation(LPCTSTR pszURL)
{
    if (_pmsoctBrowser) {
        VARIANT vararg = {0};

        vararg.vt = VT_BSTR;
        vararg.bstrVal = SysAllocStringT(pszURL);
        if (vararg.bstrVal)
        {
            TraceMsg(DM_TRACE, "DOH::_DoAsyncNavigation calling _pmsc->Exec");
            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_ASYNCNAVIGATION, 0, &vararg, NULL);
            VariantClear(&vararg);
        }
    }
}

// note: szError is never used, so don't waste time setting it
UINT SHIEErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCTSTR pszURLparam,
                    UINT idResource, UINT wFlags)
{
    UINT uRet = IDCANCEL;
    TCHAR szMsg[MAX_PATH];
    LPCTSTR pszURL = TEXT("");
    HWND hwndParent = hwndOwner;
    IShellBrowser *psbParent = NULL;

    // if a URL was specified, use it; otherwise use empty string
    if (pszURLparam)
        pszURL = pszURLparam;

    //
    // NOTES: This table of error code will be mapped to (IDS_ERRMSG_FIRST +
    //  offset) and we MLLoadString it.
    //
    const static c_ahres[] = {
        HRESULT_FROM_WIN32(ERROR_INTERNET_INVALID_URL),
        HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED),
        INET_E_UNKNOWN_PROTOCOL,
        INET_E_REDIRECT_FAILED,
        INET_E_DATA_NOT_AVAILABLE,
    };

    for (int i=0; i<ARRAYSIZE(c_ahres); i++) {
        if (c_ahres[i]==hrError) {
            MLLoadString(IDS_ERRMSG_FIRST+i, szMsg, ARRAYSIZE(szMsg));
            break;
        }
    }

    if (i >= ARRAYSIZE(c_ahres))
    {
        // Default message if FormatMessage doesn't recognize dwLastError
        MLLoadString(IDS_UNDEFINEDERR, szMsg, ARRAYSIZE(szMsg));

        if (hrError >= HRESULT_FROM_WIN32(INTERNET_ERROR_BASE)
            && hrError <= HRESULT_FROM_WIN32(INTERNET_ERROR_LAST))
        {
            HMODULE hmod = GetModuleHandle(TEXT("WININET"));
            ASSERT(hmod);
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)hmod, HRESULT_CODE(hrError), 0L,
                szMsg, ARRAYSIZE(szMsg), NULL);

        } else {
            // See if one of the system components has an error message
            // for this error.  If not, szMsg will retain our default
            // message to handle this.
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hrError, 0L,
                szMsg, ARRAYSIZE(szMsg), NULL);
        }
    }

    psbParent = psb;
    if (psbParent)
    {
        psbParent->AddRef();
    }

    //  Here we make an heroic effort to find a visible window to run the dialog against
    //  If we can't, then we bail, to avoid weird UI effect (particularly when the frametop
    //  browser is in kiosk mode
    if (!IsWindowVisible(hwndParent))
    {
        if (NULL == psb || FAILED(psb->GetWindow(&hwndParent)) || !IsWindowVisible(hwndParent))
        {
            hwndParent = NULL;
            ATOMICRELEASE(psbParent);
        }
        if (NULL == hwndParent && psb)
        {
            IUnknown_QueryService(psb, SID_STopFrameBrowser, IID_IShellBrowser, (void **)&psbParent);
            if (NULL == psbParent || FAILED(psbParent->GetWindow(&hwndParent)) || !IsWindowVisible(hwndParent))
            {
                hwndParent = NULL;
            }
        }
    }

    if (hwndParent)
    {
        if (psbParent) {
            psbParent->EnableModelessSB(FALSE);
        }

        uRet = MLShellMessageBox(hwndParent,
                               MAKEINTRESOURCE(idResource),
                               MAKEINTRESOURCE(IDS_TITLE),
                               wFlags, pszURL,szMsg);

        if (psbParent) {
            psbParent->EnableModelessSB(TRUE);
        }
    }

    if (psbParent)
    {
        UINT cRef = psbParent->Release();

        AssertMsg(cRef>0, TEXT("IE_ErrorMsgBox psb->Release returned 0."));
    }

    return uRet;
}

//
// See if the URL is of a type that we should
// ShellExecute()
//
HRESULT IsProtocolRegistered(LPCTSTR pcszProtocol);

BOOL ShouldShellExecURL(LPTSTR pszURL)
{
    BOOL fRet = FALSE;
    PARSEDURL pu = {sizeof(pu)};
    HRESULT hr = ParseURL(pszURL, &pu);
    if (SUCCEEDED(hr) && pu.nScheme != URL_SCHEME_SHELL)
    {
        TCHAR sz[MAX_PATH];
        hr = StringCchCopyN(sz, ARRAYSIZE(sz), pu.pszProtocol, pu.cchProtocol);
        if (SUCCEEDED(hr))
        {
            hr = IsProtocolRegistered(sz);
            if (SUCCEEDED(hr))
            {
                //
                //  HACKHACK - telnet.exe will fault on buffer overrun
                //      if the url is > 230. we special case here.
                //
                if (lstrlen(pszURL) <= 230 ||
                        (StrCmpI(sz, TEXT("telnet")) && 
                         StrCmpI(sz, TEXT("rlogin")) &&
                         StrCmpI(sz, TEXT("tn3270"))
                        )
                   )
                {
                    fRet = TRUE;
                }
            }
        }
    }
    return fRet;
}


//========================================================================
// class CShdAdviseSink
//========================================================================

class CShdAdviseSink : public IAdviseSink
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdviseSink methods ***
    virtual void __stdcall OnDataChange(
        FORMATETC *pFormatetc,
        STGMEDIUM *pStgmed);
    virtual void __stdcall OnViewChange(
        DWORD dwAspect,
        LONG lindex);
    virtual void __stdcall OnRename(
        IMoniker *pmk);
    virtual void __stdcall OnSave( void);
    virtual void __stdcall OnClose( void);

    CShdAdviseSink(IBrowserService* pwb, IOleObject* pole);
    ~CShdAdviseSink();

protected:
    UINT _cRef;
    IOleObject* _pole;
    DWORD       _dwConnection;
};

//
//  We'd better maintain the list of those CShdAdviseSink
//  per-thread so that we don't leak all those oleobjects when
//  the thread is terminated before those objects are closed.
//
void CShdAdviseSink_Advise(IBrowserService* pwb, IOleObject* pole)
{
    IAdviseSink* padv = new CShdAdviseSink(pwb, pole);
    // If pole->Advise succeeds, it will addreff to IAdviseSink.
    if (padv != NULL)
    {
        padv->Release();
    }
}

CShdAdviseSink::CShdAdviseSink(IBrowserService* pwb, IOleObject* pole)
    : _cRef(1)
{
    ASSERT(pole);
    TraceMsg(DM_ADVISE, "CShdAdviseSink(%x) being constructed", this);
    HRESULT hres = pole->Advise(this, &_dwConnection);
    if (SUCCEEDED(hres)) {
        _pole = pole;
        pole->AddRef();

        TraceMsg(DM_ADVISE, "CShdAdviseSink(%x) called pole->Advise. new _cRef=%d (%x)", this, _cRef, _dwConnection);
    }
}

CShdAdviseSink::~CShdAdviseSink()
{
    TraceMsg(DM_ADVISE, "CShdAdviseSink(%x) being destroyed", this);
    ATOMICRELEASE(_pole);
}

ULONG CShdAdviseSink::AddRef()
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CShdAdviseSink(%x)::AddRef called, new _cRef=%d", this, _cRef);
    return _cRef;
}

ULONG CShdAdviseSink::Release()
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CShdAdviseSink(%x)::Release called, new _cRef=%d", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CShdAdviseSink::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IAdviseSink) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IAdviseSink*)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

void CShdAdviseSink::OnDataChange(
    FORMATETC *pFormatetc,
    STGMEDIUM *pStgmed)
{
}

void CShdAdviseSink::OnViewChange(
    DWORD dwAspect,
    LONG lindex)
{
}

void CShdAdviseSink::OnRename(
    IMoniker *pmk)
{
}

void CShdAdviseSink::OnSave( void)
{
}

void CShdAdviseSink::OnClose( void)
{
    TraceMsg(DM_ADVISE, "CShdAdviseSink(%x)::OnClose called. Calling Unadvise. _cRef=%d", this, _cRef);
    HRESULT hres;
    AddRef();
    ASSERT(_pole);
    if (_pole)  // paranoia
    {
        hres = _pole->Unadvise(_dwConnection);
        ATOMICRELEASE(_pole);
        TraceMsg(DM_ADVISE, "CShdAdviseSink(%x)::OnClose. Called Unadvise(%x). new _cRef=%d", this, hres, _cRef);
    }
    Release();
}

/// adding property sheet pages

HRESULT CDocObjectHost::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HRESULT hres = S_OK;
    IShellPropSheetExt *pspse;
    /*
     * Create a property sheet page for required page, including imported File
     * Types property sheet.
     */
    // add stuff that the docobj itself has.
    if (_pole)
    {
        if (SUCCEEDED(_pole->QueryInterface(IID_IShellPropSheetExt, (void **)&pspse)))
        {
            hres = pspse->AddPages(lpfnAddPage, lParam);
            pspse->Release();
        }
        else
        {
            // Some docobjects don't know about IShellPropSheetExt (ie, Visual Basic),
            // so do it ourselves.

            if (NULL == _hinstInetCpl)
                _hinstInetCpl = LoadLibrary(TEXT("inetcpl.cpl"));

            if (_hinstInetCpl)
            {
                PFNADDINTERNETPROPERTYSHEETSEX pfnAddSheet = (PFNADDINTERNETPROPERTYSHEETSEX)GetProcAddress(_hinstInetCpl, STR_ADDINTERNETPROPSHEETSEX);
                if (pfnAddSheet)
                {
                    IEPROPPAGEINFO iepi = {0};

                    // we just want the security page.
                    iepi.cbSize = sizeof(iepi);
                    iepi.dwFlags = (DWORD)-1;       // all pages

                    hres = pfnAddSheet(lpfnAddPage, lParam, 0, 0, &iepi);
                }
                // Don't FreeLibrary here, otherwise PropertyPage will GP-fault!
            }
        }
    }

    return hres;
}


//==========================================================================
// IDocHostUIHandler implementation
//==========================================================================

HRESULT CDocObjectHost::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
    return _dhUIHandler.TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
}


HRESULT CDocObjectHost::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    // REVIEW: Does this apply anymore?
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget called");

    HRESULT hres;

    if (_pWebOCUIHandler)
    {
        hres = _pWebOCUIHandler->GetDropTarget(pDropTarget, ppDropTarget);
        
        if (SUCCEEDED(hres))
            return hres;
    }
     
    if (pDropTarget) 
    {   
        hres = S_OK;
        IDropTarget *pdtFrame;
        IDropTarget *pdt3;
        IDropTarget *pdtBlocking;

        QueryService(SID_STopFrameBrowser, IID_IDropTarget, (void **)&pdtFrame);

        // hack: this is because we need to look all the way through to top parents for a containing drop target
        // what we really need is a per dataobject drop target
        //
        // this is not required to be obtained
        QueryService(SID_ITopViewHost, IID_IDropTarget, (void **)&pdt3);
        if (IsSameObject(pdt3, pdtFrame)) {
            ATOMICRELEASE(pdt3);
        }

        // allow constrained browser bands like Search to prevent drop
        QueryService(SID_SDropBlocker, IID_IUnknown, (void **)&pdtBlocking);
        if (pdtBlocking)
        {
            ATOMICRELEASE(pdt3);
            pDropTarget = NULL;
        }

        if (pdtFrame) 
        {
            *ppDropTarget = DropTargetWrap_CreateInstance(pDropTarget, pdtFrame, _hwnd, pdt3);
            if (!*ppDropTarget)
                hres = E_OUTOFMEMORY;

            TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget returning S_OK");
            ASSERT(hres == S_OK);

            pdtFrame->Release();
        } 
        else 
        {
            ASSERT(0);
            hres = E_UNEXPECTED;
        }

        ATOMICRELEASE(pdtBlocking);
        ATOMICRELEASE(pdt3);
    } 
    else 
    {
        hres = E_INVALIDARG;
    }

    return hres;
}

HRESULT CDocObjectHost::ShowUI(
    DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
    IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
    IOleInPlaceUIWindow *pDoc)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc);

    if (_dwAppHack & BROWSERFLAG_MSHTML) // Who else will call on this interface?
    {
        if (_pmsoctBrowser)
        {
            TraceMsg(DM_PREMERGEDMENU, "DOH::ShowUI called this=%x pcmd=%x",
                     this,pCommandTarget);
            VARIANT var = { 0 };
            HRESULT hresT=_pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_SETMERGEDWEBMENU, 0, NULL, &var);
            if (SUCCEEDED(hresT))
            {
                if (_pcmdMergedMenu)
                {
                    // Tell Trident to stop calling us twice
                    TraceMsg(DM_WARNING, "DOH::ShowUI called twice! "
                             "this=%x pcmdCur=%x pcmdNew=%x",
                             this, _pcmdMergedMenu, pCommandTarget);
                    _pcmdMergedMenu->Release();
                }
                _pcmdMergedMenu = pCommandTarget;
                _pcmdMergedMenu->AddRef();
                ASSERT(var.vt == VT_INT_PTR);
                _hmenuCur = (HMENU)var.byref;

                DEBUG_CODE( _DumpMenus(TEXT("after ShowUI"), TRUE); )
                return S_OK;
            }
        }
    }

    return S_FALSE;
}


HRESULT CDocObjectHost::HideUI(void)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->HideUI();

    if (_pcmdMergedMenu) {
        _pcmdMergedMenu->Release();
        _pcmdMergedMenu = NULL;
    }

    return S_FALSE;
}

HRESULT CDocObjectHost::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    IServiceProvider * psp = NULL;
    IWebBrowser2     * pwb = NULL;
    VARIANT_BOOL       b = VARIANT_FALSE;
    DWORD              dwFlagsWebOC = 0;
    HRESULT            hr;

    if (_pWebOCUIHandler
        && SUCCEEDED(_pWebOCUIHandler->GetHostInfo(pInfo))
        )
    {
        dwFlagsWebOC = pInfo->dwFlags;
    }

    _dhUIHandler.GetHostInfo(pInfo);

    // Merge flags
    //
    pInfo->dwFlags |= dwFlagsWebOC;
    
    // Add the local machine flag, if we're in iexplore.exe or explorer.exe.
    if (IsInternetExplorerApp())
        pInfo->dwFlags |= DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK;

    // Get the top level browser
    //
    hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &psp));
    if (hr)
        goto Cleanup;

    // Get the IWebBrowser2 object/interface
    //
    hr = psp->QueryService(SID_SContainerDispatch, IID_IWebBrowser2, (void **)&pwb);
    if (hr)
        goto Cleanup;

    // Tell the browser what our dochost flags are
    IEFrameAuto *pIEFrameAuto;
    if (SUCCEEDED(pwb->QueryInterface(IID_PPV_ARG(IEFrameAuto, &pIEFrameAuto))))
    {
        pIEFrameAuto->SetDocHostFlags(pInfo->dwFlags);
        pIEFrameAuto->Release();
    }

    // Is the browser in Theater Mode?
    //
    hr = pwb->get_TheaterMode(&b);
    if (hr)
        goto Cleanup;

    // If so, turn on flat scrollbars.
    //
    if (b == VARIANT_TRUE)
        pInfo->dwFlags |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;

Cleanup:
    ATOMICRELEASE(psp);
    ATOMICRELEASE(pwb);
    
    return S_OK;
}

HRESULT CDocObjectHost::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    HRESULT             hr;
    OLECMD              rgcmd = { IDM_BROWSEMODE, 0 };

    // If we're in the WebOC and it has a IDocHostUIHandler, use it.
    //
    if (_pWebOCUIHandler)
    {
        hr = _pWebOCUIHandler->ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved);
        if (hr == S_OK)
            goto Cleanup;
    }

    // Find out if the DocObject is in Edit mode
    // Don't need apphack here as only Trident responds to CGID_MSHTML
    //

    hr = IUnknown_QueryStatus(pcmdtReserved, &CGID_MSHTML, 1, &rgcmd, NULL);
    if (    hr == S_OK
        &&  !(rgcmd.cmdf & OLECMDF_LATCHED))   // if not LATCHED means we're in edit mode.
    {
        hr = S_FALSE;
    }
    else
    {
        hr = _dhUIHandler.ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved);
    }

Cleanup:
    return hr;
}

HRESULT CDocObjectHost::UpdateUI(void)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->UpdateUI();
    return _dhUIHandler.UpdateUI();
}

HRESULT CDocObjectHost::EnableModeless(BOOL fEnable)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->EnableModeless(fEnable);
    return _dhUIHandler.EnableModeless(fEnable);
}

HRESULT CDocObjectHost::OnDocWindowActivate(BOOL fActivate)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->OnDocWindowActivate(fActivate);
    return _dhUIHandler.OnDocWindowActivate(fActivate);
}

HRESULT CDocObjectHost::OnFrameWindowActivate(BOOL fActivate)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->OnFrameWindowActivate(fActivate);
    return _dhUIHandler.OnFrameWindowActivate(fActivate);
}

HRESULT CDocObjectHost::ResizeBorder( LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->ResizeBorder(prcBorder, pUIWindow, fRameWindow);
    return _dhUIHandler.ResizeBorder(prcBorder, pUIWindow, fRameWindow);
}

HRESULT CDocObjectHost::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->GetOptionKeyPath(pbstrKey, dw);
    return _dhUIHandler.GetOptionKeyPath(pbstrKey, dw);
}

HRESULT CDocObjectHost::GetExternal(IDispatch **ppDisp)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->GetExternal(ppDisp);
    return _dhUIHandler.GetExternal(ppDisp);
}

HRESULT CDocObjectHost::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);
    return _dhUIHandler.TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);
}

HRESULT CDocObjectHost::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->FilterDataObject(pDO, ppDORet);
    return _dhUIHandler.FilterDataObject(pDO, ppDORet);
}

HRESULT CDocObjectHost::GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    if (_pWebOCUIHandler2)
        return _pWebOCUIHandler2->GetOverrideKeyPath(pchKey, dw);
    return _dhUIHandler.GetOverrideKeyPath(pchKey, dw);
}

HRESULT CDocObjectHost::ShowMessage(HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption,
           DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT __RPC_FAR *plResult)
{
    if (_pWebOCShowUI)
    {
        return _pWebOCShowUI->ShowMessage(hwnd, lpstrText, lpstrCaption, dwType,
                                            lpstrHelpFile, dwHelpContext, plResult);
    }

    return E_FAIL;
}

HRESULT CDocObjectHost::ShowHelp(HWND hwnd, LPOLESTR pszHelpFile, UINT uCommand, DWORD dwData,
           POINT ptMouse, IDispatch __RPC_FAR *pDispatchObjectHit)
{
    if (_pWebOCShowUI)
    {
        return _pWebOCShowUI->ShowHelp(hwnd, pszHelpFile, uCommand, dwData, ptMouse,
                                                pDispatchObjectHit);
    }

    return E_FAIL;
}

void
CDocObjectHost::HideBrowser() const
{
    if (_psp && _fWindowOpen && !(_dwAppHack & BROWSERFLAG_DONTAUTOCLOSE))
    {
        IWebBrowser2 * pWebBrowser;

        HRESULT hres = _psp->QueryService(SID_SWebBrowserApp,
                                          IID_PPV_ARG(IWebBrowser2, &pWebBrowser));
        if (SUCCEEDED(hres))
        {
            pWebBrowser->put_Visible(VARIANT_FALSE);
            pWebBrowser->Release();
        }
    }
}

//
// support for script error caching and status bar notification
//

void
CDocObjectHost::_ScriptErr_Dlg(BOOL fOverridePerErrorMode)
{
    // we can get reentered through the message pump ShowHTMLDialog runs
    // therefore we might already have a dialog open when a second dialog
    // is requested

    if (_fScriptErrDlgOpen)
    {
        // a dialog is already open lower in the callstack
        // request an up-to-date dialog be shown
        // we have to do this because otherwise we might
        // be in per-error-mode and miss some errors which
        // arrived while the dialog lower in the callstack
        // was open. note that we only do this if we're set
        // to show notifications for every error.

        _fShowScriptErrDlgAgain = SHRegGetBoolUSValue(szRegKey_SMIEM,
                                                      szRegVal_ErrDlgPerErr,
                                                      FALSE,
                                                      TRUE);
    }
    else
    {
        _fScriptErrDlgOpen = TRUE;

        // keep showing dialogs as long as someone farther up the
        // call stack keeps requesting them

        do
        {
            BOOL    fShowDlg;

            _fShowScriptErrDlgAgain = FALSE;

            // if the user double clicked on the status bar, then we
            // show the dialog regardless of per-error-mode settings

            if (fOverridePerErrorMode)
            {
                fShowDlg = TRUE;

                // because of other script errors hitting the
                // _fScriptErrDlgOpen code above, we can arrive
                // here multiple times. The first time we show a
                // dialog can be because the user requested it,
                // but all subsequent times must be because we're
                // in "show every error" mode.

                fOverridePerErrorMode = FALSE;
            }
            else
            {
                fShowDlg = SHRegGetBoolUSValue(szRegKey_SMIEM,
                                               szRegVal_ErrDlgPerErr,
                                               FALSE,
                                               TRUE);
            }

            if (fShowDlg)
            {
                HRESULT hr;
                TCHAR   szResURL[MAX_URL_STRING];

                hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                       HINST_THISDLL,
                                       ML_CROSSCODEPAGE,
                                       TEXT("ieerror.dlg"),
                                       szResURL,
                                       ARRAYSIZE(szResURL),
                                       TEXT("shdocvw.dll"));
                if (SUCCEEDED(hr))
                {
                    IMoniker *  pmk;
                    HWND        hwnd;

                    hr = CreateURLMoniker(NULL, szResURL, &pmk);
                    if (SUCCEEDED(hr))
                    {
                        VARIANT varErrorCache;

                        V_VT(&varErrorCache) = VT_DISPATCH;
                        V_DISPATCH(&varErrorCache) = _pScriptErrList;

                        GetWindow(&hwnd);
                        ShowHTMLDialog(hwnd, pmk, &varErrorCache, L"help:no", NULL);
                        ATOMICRELEASE(pmk);
                    }
                }
            }
        } while (_fShowScriptErrDlgAgain);

        _fScriptErrDlgOpen = FALSE;
    }
}

HRESULT
CDocObjectHost::_ScriptErr_CacheInfo(VARIANTARG *pvarIn)

{
    IHTMLDocument2 *    pOmDoc;
    IHTMLWindow2 *      pOmWindow;
    IHTMLEventObj *     pEventObj;
    HRESULT             hr;

    TCHAR *       apchNames[] =
                            { TEXT("errorLine"),
                              TEXT("errorCharacter"),
                              TEXT("errorCode"),
                              TEXT("errorMessage"),
                              TEXT("errorUrl")
                            };
    DISPID              aDispid[ARRAYSIZE(apchNames)];
    VARIANT             varOut[ARRAYSIZE(apchNames)];
    int                 i;

    pOmDoc = NULL;
    pOmWindow = NULL;
    pEventObj = NULL;

    // load the script error object

    hr = V_UNKNOWN(pvarIn)->QueryInterface(IID_IHTMLDocument2, (void **) &pOmDoc);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pOmDoc->get_parentWindow(&pOmWindow);
    ATOMICRELEASE(pOmDoc);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pOmWindow->get_event(&pEventObj);
    ATOMICRELEASE(pOmWindow);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // copy the interesting data out of the event object
    //

    for (i = 0; i < ARRAYSIZE(apchNames); i++)
    {
        DISPPARAMS  params;

        // get the property's dispid
        hr = pEventObj->GetIDsOfNames(IID_NULL, &apchNames[i], 1, LOCALE_SYSTEM_DEFAULT, &aDispid[i]);
        if (hr != S_OK)
        {
            ATOMICRELEASE(pEventObj);
            return hr;
        }

        params.cArgs = 0;
        params.cNamedArgs = 0;

        hr = pEventObj->Invoke(aDispid[i], IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, &params, &varOut[i], NULL, NULL);
        if (hr != S_OK)
        {
            ATOMICRELEASE(pEventObj);
            return hr;
        }
    }

    ATOMICRELEASE(pEventObj);

    ASSERT(V_VT(&varOut[0]) == VT_I4);
    ASSERT(V_VT(&varOut[1]) == VT_I4);
    ASSERT(V_VT(&varOut[2]) == VT_I4);
    ASSERT(V_VT(&varOut[3]) == VT_BSTR);
    ASSERT(V_VT(&varOut[4]) == VT_BSTR);
    ASSERT(ARRAYSIZE(apchNames) == 5);

    hr = _pScriptErrList->AddNewErrorInfo(V_I4(&varOut[0]),         // line
                                          V_I4(&varOut[1]),       // char
                                          V_I4(&varOut[2]),       // code
                                          V_BSTR(&varOut[3]),     // message
                                          V_BSTR(&varOut[4]));    // url

    return hr;
}

//
// CScriptErrorList manages an array of _CScriptErrInfo objects
// the script error handler dialogs access this information
// when requested by the user
//

CScriptErrorList::CScriptErrorList() :
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IScriptErrorList)
{
    ASSERT(_lDispIndex == 0);

    _ulRefCount = 1;

    _hdpa = DPA_Create(4);
}

CScriptErrorList::~CScriptErrorList()
{
    if (_hdpa != NULL)
    {
        ClearErrorList();
        DPA_Destroy(_hdpa);
        _hdpa = NULL;
    }
}

HRESULT
CScriptErrorList::AddNewErrorInfo(LONG lLine,
                                  LONG lChar,
                                  LONG lCode,
                                  BSTR strMsg,
                                  BSTR strUrl)
{
    HRESULT             hr;
    _CScriptErrInfo *   pNewData;

    if (strMsg == NULL || strUrl == NULL)
    {
        return E_INVALIDARG;
    }

    pNewData = new _CScriptErrInfo;
    if (pNewData != NULL)
    {
        hr = pNewData->Init(lLine, lChar, lCode, strMsg, strUrl);
        if (SUCCEEDED(hr))
        {
            if (_hdpa != NULL)
            {
                DPA_AppendPtr(_hdpa, (LPVOID)pNewData);
                _lDispIndex = DPA_GetPtrCount(_hdpa)-1;
            }
            else
            {
                delete pNewData;
                hr = E_FAIL;
            }
        }
        else
        {
            delete pNewData;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

void
CScriptErrorList::ClearErrorList()
{
    if (_hdpa != NULL)
    {
        int iDel;
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        // delete from end to beginning to avoid unnecessary packing
        for (iDel = cPtr-1; iDel >= 0; iDel--)
        {
            delete ((_CScriptErrInfo *)DPA_GetPtr(_hdpa, iDel));
            DPA_DeletePtr(_hdpa, iDel);
        }

        _lDispIndex = 0;
    }
}

STDMETHODIMP
CScriptErrorList::QueryInterface(REFIID iid, void ** ppObj)
{
    ASSERT(ppObj != NULL);

    if (IsEqualIID(iid, IID_IUnknown) ||
        IsEqualIID(iid, IID_IDispatch) ||
        IsEqualIID(iid, IID_IScriptErrorList))
    {
        *ppObj = (IScriptErrorList *)this;
    }
    else
    {
        *ppObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG)
CScriptErrorList::AddRef()
{
    _ulRefCount++;
    return _ulRefCount;
}

STDMETHODIMP_(ULONG)
CScriptErrorList::Release()
{
    _ulRefCount--;
    if (_ulRefCount > 0)
    {
        return _ulRefCount;
    }

    delete this;
    return 0;
}

STDMETHODIMP
CScriptErrorList::advanceError()
{
    HRESULT hr;

    hr = E_FAIL;

    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        if (_lDispIndex < cPtr-1)
        {
            _lDispIndex++;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::retreatError()
{
    if (_lDispIndex < 1)
    {
        return E_FAIL;
    }

    _lDispIndex--;

    return S_OK;
}

STDMETHODIMP
CScriptErrorList::canAdvanceError(BOOL * pfCanAdvance)
{
    HRESULT hr;

    ASSERT(pfCanAdvance != NULL);

    hr = E_FAIL;

    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);
        *pfCanAdvance = _lDispIndex < cPtr-1;

        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::canRetreatError(BOOL * pfCanRetreat)
{
    ASSERT(pfCanRetreat != NULL);

    *pfCanRetreat = _lDispIndex > 0;

    return S_OK;
}

STDMETHODIMP
CScriptErrorList::getErrorLine(LONG * plLine)
{
    HRESULT hr;

    ASSERT(plLine != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *    pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *plLine = pInfo->_lLine;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorChar(LONG * plChar)
{
    HRESULT hr;

    ASSERT(plChar != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *plChar  = pInfo->_lChar;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorCode(LONG * plCode)
{
    HRESULT hr;

    ASSERT(plCode != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *plCode = pInfo->_lCode;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorMsg(BSTR * pstrMsg)
{
    HRESULT hr;

    ASSERT(pstrMsg != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *pstrMsg = SysAllocString(pInfo->_strMsg);

            if (*pstrMsg != NULL)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorUrl(BSTR * pstrUrl)
{
    HRESULT hr;

    ASSERT(pstrUrl != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int     cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *pstrUrl = SysAllocString(pInfo->_strUrl);

            if (*pstrUrl != NULL)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getAlwaysShowLockState(BOOL * pfAlwaysShowLocked)
{
    *pfAlwaysShowLocked = IsInetcplRestricted(TEXT("Advanced"));

    return S_OK;
}

STDMETHODIMP
CScriptErrorList::getDetailsPaneOpen(BOOL * pfDetailsPaneOpen)
{
    *pfDetailsPaneOpen =
        SHRegGetBoolUSValue(szRegKey_SMIEM,
                            szRegVal_ErrDlgDetailsOpen,
                            FALSE,
                            FALSE);
    return S_OK;
}

STDMETHODIMP
CScriptErrorList::setDetailsPaneOpen(BOOL fDetailsPaneOpen)
{
    TCHAR   szYes[] = TEXT("yes");
    TCHAR   szNo[] = TEXT("no");
    LPTSTR  pszVal;
    int     cbSize;

    if (fDetailsPaneOpen)
    {
        pszVal = szYes;
        cbSize = sizeof(szYes);
    }
    else
    {
        pszVal = szNo;
        cbSize = sizeof(szNo);
    }

    SHRegSetUSValue(szRegKey_SMIEM,
                    szRegVal_ErrDlgDetailsOpen,
                    REG_SZ,
                    pszVal,
                    cbSize,
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

    // even if it failed, we can't do anything about it...
    return S_OK;
}

STDMETHODIMP
CScriptErrorList::getPerErrorDisplay(BOOL * pfPerErrorDisplay)
{
    *pfPerErrorDisplay =
        SHRegGetBoolUSValue(szRegKey_SMIEM,
                            szRegVal_ErrDlgPerErr,
                            FALSE,
                            FALSE);
    return S_OK;
}

STDMETHODIMP
CScriptErrorList::setPerErrorDisplay(BOOL fPerErrorDisplay)
{
    TCHAR   szYes[] = TEXT("yes");
    TCHAR   szNo[] = TEXT("no");
    LPTSTR  pszVal;
    int     cbSize;

    if (fPerErrorDisplay)
    {
        pszVal = szYes;
        cbSize = sizeof(szYes);
    }
    else
    {
        pszVal = szNo;
        cbSize = sizeof(szNo);
    }

    SHRegSetUSValue(szRegKey_SMIEM,
                    szRegVal_ErrDlgPerErr,
                    REG_SZ,
                    pszVal,
                    cbSize,
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

    // even if it failed, we can't do anything about it...
    return S_OK;
}

HRESULT
CScriptErrorList::_CScriptErrInfo::Init(LONG lLine,
                                        LONG lChar,
                                        LONG lCode,
                                        BSTR strMsg,
                                        BSTR strUrl)
{
    ASSERT(_strMsg == NULL);
    ASSERT(_strUrl == NULL);

    _strMsg = SysAllocString(strMsg);
    if (_strMsg == NULL)
    {
        return E_OUTOFMEMORY;
    }

    _strUrl = SysAllocString(strUrl);
    if (_strUrl == NULL)
    {
        SysFreeString(_strMsg);
        return E_OUTOFMEMORY;
    }

    _lLine = lLine;
    _lChar = lChar;
    _lCode = lCode;

    return S_OK;
}

CScriptErrorList::_CScriptErrInfo::~_CScriptErrInfo()
{
    if (_strMsg != NULL)
    {
        SysFreeString(_strMsg);
    }
    if (_strUrl != NULL)
    {
        SysFreeString(_strUrl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\explband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "nscband.h"
#include "resource.h"
#include "uemapp.h"   // KMTF: Included for instrumentation
#include "shlguid.h"
#include <dpa.h>
#include <mluisupp.h>
#include "varutil.h"
#include "apithk.h"

#define TF_EXPLORERBAND  0

typedef struct
{
    LPITEMIDLIST pidl;
    IShellFolder *psf;
} SFCITEM;

class CExplorerBand : public CNSCBand,
                    public IDispatch
{
public:

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CNSCBand::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CNSCBand::Release(); };

    // *** IOleCommandTarget methods ***
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    STDMETHODIMP CloseDW(DWORD dw);
    STDMETHODIMP ShowDW(BOOL fShow);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** INamespaceProxy methods ***
    STDMETHODIMP Invoke(LPCITEMIDLIST pidl);
    STDMETHODIMP OnSelectionChanged(LPCITEMIDLIST pidl);
    STDMETHODIMP CacheItem(LPCITEMIDLIST pidl) {_MaybeAddToLegacySFC(pidl); return S_OK;}
    
    // *** IDispatch methods ***
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) {return E_NOTIMPL;}
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                  DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

protected:
    CExplorerBand() : _fCanSelect(TRUE), _fIgnoreSelection(TRUE)
    {}
    virtual ~CExplorerBand();
    
    virtual HRESULT _TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _InitializeNsc();
    virtual DWORD _GetTVStyle();
    virtual DWORD _GetTVExStyle();
    virtual DWORD _GetEnumFlags();
    void _MaybeAddToLegacySFC(LPCITEMIDLIST pidl);
    void _AddToLegacySFC(LPCITEMIDLIST pidl, IShellFolder *psf);
    BOOL _IsInSFC(LPCITEMIDLIST pidl);
    BOOL _IsFloppy(LPCITEMIDLIST pidl);
    void _OnNavigate();
    HRESULT _ConnectToBrowser(BOOL fConnect);    
    HRESULT _BrowserExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    friend HRESULT CExplorerBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    static void s_DVEnumReadyCallback(void *pvData);

    CDSA<SFCITEM> *_pdsaLegacySFC;
    DWORD _dwcpCookie;
    LPITEMIDLIST _pidlView; //pidl view is navigated to
    BOOL _fCanSelect;
    BOOL _fIgnoreSelection; //so we don't navigate away from the web page when user opens explorer pane
    BOOL _fFloppyRefresh;
};

HRESULT CExplorerBand::_BrowserExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT _UnwrapRootedPidl(LPCITEMIDLIST pidlRooted, BOOL bOnlyIfRooted, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    if (ILIsRooted(pidlRooted))
    {
        hr = SHILCombine(ILRootedFindIDList(pidlRooted), _ILNext(pidlRooted), ppidl);
    }
    else if (!bOnlyIfRooted)
    {
        hr = SHILClone(pidlRooted, ppidl);
    }

    return hr;
}


BOOL IsFTPPidl(LPCITEMIDLIST pidl)
{
    BOOL fIsFTP = FALSE;
    IShellFolder * psf;

    if (pidl && SUCCEEDED(IEBindToObject(pidl, &psf)))
    {
        fIsFTP = IsFTPFolder(psf);
        psf->Release();
    }

    return fIsFTP;
}


void CExplorerBand::_OnNavigate()
{
    IBrowserService* pbs;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = pbs->GetPidl(&pidl);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlNew;
            hr = _UnwrapRootedPidl(pidl, FALSE, &pidlNew);
            if (SUCCEEDED(hr))
            {
                // We must go in this code path if the pidl is an FTP pidl.  FTP pidls can contain
                // passwords so it needs to replace any existing pidl.  Whistler #252206.
                if (!_pidlView || !ILIsEqual(pidlNew, _pidlView) || IsFTPPidl(pidlNew))
                {
                    DWORD dwAttributes = SFGAO_FOLDER;
                    // only let folders go through (to filter out Web pages)
                    hr = IEGetAttributesOf(pidlNew, &dwAttributes);
                    if (SUCCEEDED(hr) && (dwAttributes & SFGAO_FOLDER))
                    {
                        BOOL fExpand = (_pidlView == NULL); //the very first time we expand the folder the view is navigated to
                        Pidl_Set(&_pidlView, pidlNew);
                        _fIgnoreSelection = FALSE; //in the web page case we don't come here because the page does not have folder attribute
                        
                        if (_fCanSelect)
                        {
                            if (fExpand)
                            {
                                VARIANT var;
                                hr = InitVariantFromIDList(&var, _pidlView);
                                if (SUCCEEDED(hr))
                                {
                                    IShellNameSpace *psns;
                                    hr = _pns->QueryInterface(IID_PPV_ARG(IShellNameSpace, &psns));
                                    if (SUCCEEDED(hr))
                                    {
                                        psns->Expand(var, 1);
                                        psns->Release();
                                    }
                                    VariantClear(&var);
                                }
                            }
                            else
                            {
                                _pns->SetSelectedItem(_pidlView, TRUE, FALSE, 0);
                            }
                        }
                    }
                }
                // view navigation is asynchronous so we don't know if it failed in OnSelectionChanged
                // but the view is getting navigated to the old pidl and _fCanSelect is false (which happens after we try
                // to navigate the view) so it is safe to assume that navigation failed.
                // we need to update the selection to match the view
                else if (ILIsEqual(pidlNew, _pidlView) && !_fCanSelect)
                {
                    _pns->SetSelectedItem(_pidlView, TRUE, FALSE, 0);
                }
                
                _fCanSelect = TRUE;
                ILFree(pidlNew);
            }
            ILFree(pidl);
        }
        pbs->Release();
    }

    if (FAILED(hr))
    {
        Pidl_Set(&_pidlView, NULL);
    }
}

HRESULT CExplorerBand::Invoke(DISPID dispidMember, REFIID riid,LCID lcid, WORD wFlags,
                  DISPPARAMS *pdispparams, VARIANT *pvarResult,
                  EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr = S_OK;

    if (!pdispparams)
        return E_INVALIDARG;

    switch(dispidMember)
    {
    case DISPID_NAVIGATECOMPLETE2:
    case DISPID_DOCUMENTCOMPLETE:
        {
            BOOL fCallNavigateFinished = TRUE;
            IDVGetEnum *pdvge;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge))))
            {
                // callback will call it
                fCallNavigateFinished = FALSE;
                if (dispidMember == DISPID_NAVIGATECOMPLETE2)
                    pdvge->SetEnumReadyCallback(s_DVEnumReadyCallback, this);
                    
                pdvge->Release();
            }
            _OnNavigate();
            if (fCallNavigateFinished && DISPID_DOCUMENTCOMPLETE == dispidMember)
            {
                // need to let nsc know the navigation finished in case we navigated to a 3rd party namespace extension (w/ its own view impl)
                // because it does not implement IDVGetEnum, hence s_DVEnumReadyCallback will not get called
                LPITEMIDLIST pidlClone = ILClone(_pidlView);
                // should we unwrap this pidl if rooted?
                if (pidlClone)
                    _pns->RightPaneNavigationFinished(pidlClone); // takes ownership
            }
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

void CExplorerBand::s_DVEnumReadyCallback(void *pvData)
{
    CExplorerBand *peb = (CExplorerBand *) pvData;
    IBrowserService* pbs;
    if (SUCCEEDED(IUnknown_QueryService(peb->_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
    {
        LPITEMIDLIST pidlTemp;
        if (SUCCEEDED(pbs->GetPidl(&pidlTemp)))
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_UnwrapRootedPidl(pidlTemp, FALSE, &pidl)))
            {
                peb->_pns->RightPaneNavigationFinished(pidl);   // takes ownership
            }
            ILFree(pidlTemp);
        }
        pbs->Release();
    }
}

const TCHAR c_szLink[] = TEXT("link");
const TCHAR c_szRename[] = TEXT("rename");
const TCHAR c_szMove[] = TEXT("cut");
const TCHAR c_szPaste[] = TEXT("paste");
const TCHAR c_szCopy[] = TEXT("copy");
const TCHAR c_szDelete[] = TEXT("delete");
const TCHAR c_szProperties[] = TEXT("properties");

// IOleCommandTarget
HRESULT CExplorerBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup == NULL)
    {
        IContextMenu *pcm = NULL;
        HRESULT hr = _QueryContextMenuSelection(&pcm);
        if (SUCCEEDED(hr))
        {
            HMENU hmenu = CreatePopupMenu();
            if (hmenu)
            {
                hr = pcm->QueryContextMenu(hmenu, 0, 0, 255, 0);
                if (SUCCEEDED(hr))
                {
                    UINT ilast = GetMenuItemCount(hmenu);
                    for (UINT ipos=0; ipos < ilast; ipos++)
                    {
                        MENUITEMINFO mii = {0};
                        TCHAR szVerb[40];
                        UINT idCmd;

                        mii.cbSize = SIZEOF(MENUITEMINFO);
                        mii.fMask = MIIM_ID|MIIM_STATE;

                        if (!GetMenuItemInfoWrap(hmenu, ipos, TRUE, &mii)) continue;
                        if (0 != (mii.fState & (MF_GRAYED|MF_DISABLED))) continue;
                        idCmd = mii.wID;

                        hr = ContextMenu_GetCommandStringVerb(pcm, idCmd, szVerb, ARRAYSIZE(szVerb));
                        if (SUCCEEDED(hr))
                        {
                            LPCTSTR szCmd = NULL;

                            for (ULONG cItem = 0; cItem < cCmds; cItem++)
                            {
                                switch (rgCmds[cItem].cmdID)
                                {
                                case OLECMDID_CUT:
                                    szCmd = c_szMove;
                                    break;
                                case OLECMDID_COPY:
                                    szCmd = c_szCopy;
                                    break;
                                case OLECMDID_PASTE:
                                    szCmd = c_szPaste;
                                    break;
                                case OLECMDID_DELETE:
                                    szCmd = c_szDelete;
                                    break;
                                case OLECMDID_PROPERTIES:
                                    szCmd = c_szProperties;
                                    break;
                                }
                                
                                if (StrCmpI(szVerb, szCmd)==0)
                                {
                                    rgCmds[cItem].cmdf = OLECMDF_ENABLED;
                                }
                            }
                        }
                    }
                }
                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_FAIL;
            }
            pcm->Release();
        }
            
        if (SUCCEEDED(hr))
            return hr;
    }

    return CNSCBand::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CExplorerBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        HRESULT hr;
        
        switch(nCmdID) 
        {
        case OLECMDID_CUT:
            hr = _InvokeCommandOnItem(c_szMove);
            break;
        case OLECMDID_COPY:
            hr = _InvokeCommandOnItem(c_szCopy);
            break;
        case OLECMDID_PASTE:
            hr = _InvokeCommandOnItem(c_szPaste);
            break;
        case OLECMDID_DELETE:
            hr = _InvokeCommandOnItem(c_szDelete);
            break;
        case OLECMDID_PROPERTIES:
            hr = _InvokeCommandOnItem(c_szProperties);
            break;
        default:
            hr = E_FAIL;
            break;
        }

        if (SUCCEEDED(hr))
            return hr;
    }

    return CNSCBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

// IDockingWindow
HRESULT CExplorerBand::CloseDW(DWORD dw)
{
    _ConnectToBrowser(FALSE);
    return CNSCBand::CloseDW(dw);
}

HRESULT CExplorerBand::ShowDW(BOOL fShow)
{
    return CNSCBand::ShowDW(fShow);
}

// IObjectWithSite
HRESULT CExplorerBand::SetSite(IUnknown* punkSite)
{
    HRESULT hr = CNSCBand::SetSite(punkSite);

    if (punkSite)
        _ConnectToBrowser(TRUE);

    return hr;
}

int _SFCDestroyCB(SFCITEM *psfcItem, void *pv)
{
    psfcItem->psf->Release();
    ILFree(psfcItem->pidl);
    return 1;
}

CExplorerBand::~CExplorerBand()
{
    ILFree(_pidlView);
    if (_pdsaLegacySFC)
    {
        _pdsaLegacySFC->DestroyCallback(_SFCDestroyCB, NULL);
        delete _pdsaLegacySFC;
    }
}

HRESULT CExplorerBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CExplorerBand, IDispatch),
        { 0 },
    };
    
    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
        hr = CNSCBand::QueryInterface(riid, ppvObj);
    return hr;
}

DWORD CExplorerBand::_GetEnumFlags()
{
    DWORD dwFlags = SHCONTF_FOLDERS;
    SHELLSTATE ss = {0};
    
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    if (ss.fShowAllObjects)
        dwFlags |= SHCONTF_INCLUDEHIDDEN;
        
    return dwFlags;
}

DWORD CExplorerBand::_GetTVExStyle()
{
    DWORD dwExStyle = 0;
    
    if (IsOS(OS_WHISTLERORGREATER) &&
        SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
        TEXT("FriendlyTree"), FALSE, TRUE))
    {
        dwExStyle |= TVS_EX_NOSINGLECOLLAPSE;
    }

    return dwExStyle;
}

DWORD CExplorerBand::_GetTVStyle()
{
    DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | WS_TABSTOP | WS_HSCROLL | TVS_EDITLABELS | TVS_SHOWSELALWAYS;

    if (IsOS(OS_WHISTLERORGREATER) &&
        SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
        TEXT("FriendlyTree"), FALSE, TRUE))
    {
        dwStyle |= TVS_HASBUTTONS | TVS_SINGLEEXPAND | TVS_TRACKSELECT;
    }
    else
    {
        dwStyle |= TVS_HASBUTTONS | TVS_HASLINES;
    }

    // If the parent window is mirrored then the treeview window will inheret the mirroring flag
    // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.
    if (_hwndParent && IS_WINDOW_RTL_MIRRORED(_hwndParent)) 
    {
        // This means left to right reading order because this window will be mirrored.
        _dwStyle |= TVS_RTLREADING;
    }

    return dwStyle;
}

HRESULT CExplorerBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CExplorerBand * peb = new CExplorerBand();
    if (!peb)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(peb->_Init((LPCITEMIDLIST)CSIDL_DESKTOP)))
    {
        peb->_pns = CNscTree_CreateInstance();
        if (peb->_pns)
        {
            ASSERT(poi);
            peb->_poi = poi;   
            // if you change this cast, fix up CFavBand_CreateInstance
            *ppunk = SAFECAST(peb, IDeskBand *);

            IUnknown_SetSite(peb->_pns, *ppunk);
            peb->_SetNscMode(MODE_NORMAL);

            return S_OK;
        }
    }
    
    peb->Release();

    return E_FAIL;
}

HRESULT CExplorerBand::_ConnectToBrowser(BOOL fConnect)
{
    IBrowserService* pbs;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs));
    if (SUCCEEDED(hr))
    {
        if (fConnect)
        {
            LPITEMIDLIST pidlTemp = NULL;
            // try to get the pidl the browser is navigated to
            // this usually fails if user just opened Explorer window because navigation is asynchronous
            // so we're not initialized yet
            if (FAILED(pbs->GetPidl(&pidlTemp)))
            {
                IBrowserService2 *pbs2;
                if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IBrowserService2, &pbs2))))
                {
                    LPCBASEBROWSERDATA pbbd;
                    // our last hope is the pidl browser is navigating to...
                    if (SUCCEEDED(pbs2->GetBaseBrowserData(&pbbd)) && pbbd->_pidlPending)
                    {
                        pidlTemp = ILClone(pbbd->_pidlPending);
                    }
                    pbs2->Release();
                }
            }

            if (pidlTemp)
            {
                LPITEMIDLIST pidl;
                // see if we're dealing with a rooted namespace
                if (SUCCEEDED(_UnwrapRootedPidl(pidlTemp, TRUE, &pidl)))
                {
                    _Init(pidl); //if so, reinitialize ourself with the rooted pidl
                    ILFree(pidl);
                }
                ILFree(pidlTemp);
            }
        }
        
        IConnectionPointContainer* pcpc;
        hr = IUnknown_QueryService(pbs, SID_SWebBrowserApp, IID_PPV_ARG(IConnectionPointContainer, &pcpc));
        // Let's now have the Browser Window give us notification when something happens.
        if (SUCCEEDED(hr))
        {
            hr = ConnectToConnectionPoint(SAFECAST(this, IDispatch*), DIID_DWebBrowserEvents2, fConnect,
                                          pcpc, &_dwcpCookie, NULL);
            pcpc->Release();
        }

        pbs->Release();
    }
    
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT CExplorerBand::_InitializeNsc()
{
    HRESULT hr = _pns->Initialize(_pidl, _GetEnumFlags(), NSS_DROPTARGET | NSS_BROWSERSELECT);
    if (SUCCEEDED(hr))
        _OnNavigate();

    return hr;
}

HRESULT CExplorerBand::_TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl && ppidlTarget && pulAttrib)
    {
        hr = IEGetAttributesOf(pidl, pulAttrib);
        if (SUCCEEDED(hr))
        {
            hr = SHILClone(pidl, ppidlTarget);
        }
    }
    
    return hr;
}

BOOL CExplorerBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    return ulAttrib & SFGAO_FOLDER;
}

BOOL CExplorerBand::_IsFloppy(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    WCHAR szPath[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
    {
        if (DRIVE_REMOVABLE == GetDriveType(szPath))
        {
            fRet = (L'A' == szPath[0] || L'B' == szPath[0] || L'a' == szPath[0] || L'b' == szPath[0]);
        }
    }

    return fRet;
}

HRESULT CExplorerBand::Invoke(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // allow user to navigate to an already selected item if they opened Explorer band in Web browser
    // (because we put selection on the root node but don't navigate away from the web page, if they click
    // on the root we don't navigate there, because selection never changed)
    
    if (!_pidlView)
    {
        _fIgnoreSelection = FALSE;
        hr = OnSelectionChanged(pidl);
    }
    else if (ILIsEqual(pidl, _pidlView) && _IsFloppy(pidl))
    {
        // If the drive is a floppy and the user reselects the drive refresh the contents.  This enables
        // a user to refresh when a floppy is replaced.
        _fFloppyRefresh = TRUE;
        hr = OnSelectionChanged(pidl);
        _fFloppyRefresh = FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CExplorerBand::OnSelectionChanged(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;

    if (!_fIgnoreSelection)
    {
        if (pidl)
        {
            ULONG ulAttrib = SFGAO_FOLDER;
            LPITEMIDLIST pidlTarget;

            hr = GetNavigateTarget(pidl, &pidlTarget, &ulAttrib);
            if (hr == S_OK)
            {
                if (!_pidlView || _fFloppyRefresh || !ILIsEqual(pidlTarget, _pidlView))
                {
                    hr = CNSCBand::Invoke(pidlTarget);
                    if (SUCCEEDED(hr))
                        _fCanSelect = FALSE;
                    _pns->RightPaneNavigationStarted(pidlTarget);
                    pidlTarget = NULL;  // ownership passed
                }
                ILFree(pidlTarget);
            }
#ifdef DEBUG
            else if (hr == S_FALSE)
            {
                ASSERT(pidlTarget == NULL);
            }
#endif
        }
    }
    else
    {
        _fIgnoreSelection = FALSE; //we ignore only first selection
    }
    
    return hr;
}

void CExplorerBand::_MaybeAddToLegacySFC(LPCITEMIDLIST pidl)
{
    IShellFolder *psf = NULL;
    if (pidl && SUCCEEDED(SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IShellFolder, &psf))))
    {
        //
        //  APPCOMPAT LEGACY - Compatibility.  needs the Shell folder cache,  - ZekeL - 4-MAY-99
        //  some apps, specifically WS_FTP and AECO Zip Pro,
        //  rely on having a shellfolder existing in order for them to work.
        //  we pulled the SFC because it wasnt any perf win.
        //
        if (OBJCOMPATF_OTNEEDSSFCACHE & SHGetObjectCompatFlags(psf, NULL))
            _AddToLegacySFC(pidl, psf);
        psf->Release();
    }
}

BOOL CExplorerBand::_IsInSFC(LPCITEMIDLIST pidl)
{
    BOOL bReturn = FALSE;

    ASSERT(_pdsaLegacySFC);
    for (int i=0; i<_pdsaLegacySFC->GetItemCount(); i++)
    {
        SFCITEM *psfcItem = _pdsaLegacySFC->GetItemPtr(i);
        if (ILIsEqual(psfcItem->pidl, pidl))
        {
            bReturn = TRUE;
            break;
        }
    }

    return bReturn;
}

void CExplorerBand::_AddToLegacySFC(LPCITEMIDLIST pidl, IShellFolder *psf)
{
    if (!_pdsaLegacySFC)
    {
        _pdsaLegacySFC = new CDSA<SFCITEM>;
        if (_pdsaLegacySFC && !_pdsaLegacySFC->Create(4))
        {
            delete _pdsaLegacySFC;
            _pdsaLegacySFC = NULL;
        }
    }

    if (_pdsaLegacySFC)
    {
        LPITEMIDLIST pidlCache;
        if (!_IsInSFC(pidl) && SUCCEEDED(SHILClone(pidl, &pidlCache)))
        {
            SFCITEM sfc = {pidlCache, psf};
            if (-1 != _pdsaLegacySFC->InsertItem(0, &sfc))
                psf->AddRef();
            else
                ILFree(pidlCache);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\favband.cpp ===
//
// favband.cpp
//
// favorites band implementation
//

#include "priv.h"
#include "sccls.h"
#include "nscband.h"
#include "resource.h"
#include "favorite.h"
#include "uemapp.h"   // KMTF: Included for instrumentation

#include <mluisupp.h>

#define SUPERCLASS CNSCBand

#define TF_FAVBAND  0

class CFavBand : public CNSCBand
{
public:

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);

protected:
    virtual void _AddButtons(BOOL fAdd);
    HRESULT _BrowserExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    void _OrganizeFavorites();
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl);
    virtual HRESULT _TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    friend HRESULT CFavBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    BOOL       _fStrsAdded;
    LONG_PTR       _lStrOffset;
};

HRESULT CFavBand::_BrowserExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

void CFavBand::_OrganizeFavorites()
{
    DoOrganizeFavDlgW(_hwnd, NULL);
}

// *** IOleCommandTarget methods ***
HRESULT CFavBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup && IsEqualGUID(CLSID_FavBand, *pguidCmdGroup))
    {
        TraceMsg(TF_FAVBAND, "CFavBand::Exec CLSID_FavBand -- nCmdID == %x", nCmdID);

        switch(nCmdID)
        {
        case FCIDM_ADDTOFAVORITES:
        {
            _BrowserExec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
            // Instrument addition to favorites by pane
            UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_ADDTOFAV, UIBL_PANE);     
            return S_OK;
        }

        case FCIDM_ORGANIZEFAVORITES:
        {
            _OrganizeFavorites();
            return S_OK;
        }
        }
    }

    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

static const TBBUTTON c_tbFavorites[] =
{
    {  0, FCIDM_ADDTOFAVORITES,     TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0,0}, 0, 0 },
    {  1, FCIDM_ORGANIZEFAVORITES,  TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0,0}, 0, 1 },
};

void CFavBand::_AddButtons(BOOL fAdd)
{
    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_IExplorerToolbar, (void**)&piet)))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CLSID_FavBand, 0);

            if (!_fStrsAdded)
            {
                piet->AddString(&CLSID_FavBand, MLGetHinst(), IDS_FAVS_BAR_LABELS, &_lStrOffset);
                _fStrsAdded = TRUE;
            }

            _EnsureImageListsLoaded();
            piet->SetImageList(&CLSID_FavBand, _himlNormal, _himlHot, NULL);

            TBBUTTON tbFavorites[ARRAYSIZE(c_tbFavorites)];
            memcpy(tbFavorites, c_tbFavorites, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbFavorites));
            for (int i = 0; i < ARRAYSIZE(c_tbFavorites); i++)
                tbFavorites[i].iString += (long) _lStrOffset;

            piet->AddButtons(&CLSID_FavBand, ARRAYSIZE(tbFavorites), tbFavorites);
        }
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }
}

// *** IDockingWindow methods ***
HRESULT CFavBand::ShowDW(BOOL fShow)
{
    HRESULT hres = SUPERCLASS::ShowDW(fShow);
    _AddButtons(fShow);
    return hres;
}


HRESULT CFavBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CFavBand * pfb = new CFavBand();
    if (!pfb)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(pfb->_Init((LPCITEMIDLIST)CSIDL_FAVORITES)))
    {
        pfb->_pns = CNscTree_CreateInstance();
        if (pfb->_pns)
        {
            ASSERT(poi);
            pfb->_poi = poi;   
            // if you change this cast, fix up CChannelBand_CreateInstance
            *ppunk = SAFECAST(pfb, IDeskBand *);

            IUnknown_SetSite(pfb->_pns, *ppunk);
            pfb->_SetNscMode(MODE_FAVORITES);
            return S_OK;
        }
    }
    pfb->Release();

    return E_FAIL;
}

HRESULT CFavBand::_TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl && ppidlTarget && pulAttrib)
    {
        hr = IEGetAttributesOf(pidl, pulAttrib);
        if (SUCCEEDED(hr))
        {
            hr = SHILClone(pidl, ppidlTarget);
        }
    }
    
    return hr;
}

BOOL CFavBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    return !(ulAttrib & SFGAO_FOLDER);
}

HRESULT CFavBand::_NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;

    if (psb && pidl)
    {
        TCHAR szPath[MAX_PATH];

        hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
        if (SUCCEEDED(hr))
        {
            hr = NavFrameWithFile(szPath, psb);
            if (FAILED(hr))
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlLast;
                if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast)))
                {
                    LPITEMIDLIST pidlTarget;
                    if (SUCCEEDED(SHGetNavigateTarget(psf, pidlLast, &pidlTarget, NULL)))
                    {
                        hr = psb->BrowseObject(pidlTarget, SBSP_SAMEBROWSER);
                        ILFree(pidlTarget);
                    }
                    psf->Release();
                }
            }
                
            if (SUCCEEDED(hr))
            {
                UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVFAVS);
                UEMFireEvent(&UEMIID_BROWSER, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)NULL, (LPARAM)pidl);
                SHSendChangeMenuNotify(NULL, SHCNEE_PROMOTEDITEM, 0, pidl);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\favorite.h ===
#ifndef _FAVORITE_H_
#define _FAVORITE_H_

STDAPI        AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle, BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);
STDAPI_(BOOL) DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir);
STDAPI_(BOOL) DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir);

BOOL IsSubscribed(LPCITEMIDLIST pidlCur);
BOOL IsSubscribed(LPWSTR pwzUrl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\favorite.cpp ===
#include "priv.h"

#include <mstask.h>
#include "favorite.h"
#include "iehelpid.h"
#ifdef UNIX
#include "subsmgr.h"
#else
#include "webcheck.h"
#endif
#include "chanmgr.h"
#include "chanmgrp.h"
#include "resource.h"
#include <platform.h>
#include <mobsync.h>
#include <mobsyncp.h>

#include <mluisupp.h>

#ifdef UNIX
#include "unixstuff.h"
#include "shalias.h"
#endif

UINT IE_ErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCTSTR pszURLparam,
                    UINT idResource, UINT wFlags);
void ReplaceTransplacedControls (HWND hDlgMaster, HWND hDlgTemplate);

///////////////////////////////////////////////////////////////////////
// helper function for DoOrganizeFavDlgEx
// the org favs dialog returns a list of null terminated strings containing
//   all the urls to update.
void OrgFavSynchronize(HWND hwnd, VARIANT *pvarUrlsToSynch)
{
#ifndef DISABLE_SUBSCRIPTIONS

    ASSERT(pvarUrlsToSynch);
    
    //if there are no urls to update, it's an empty string so bail
    if ( (pvarUrlsToSynch->vt == VT_BSTR) && (pvarUrlsToSynch->bstrVal) &&
         *(pvarUrlsToSynch->bstrVal) )
    {
        PWSTR pwzUrls = pvarUrlsToSynch->bstrVal;

        ISubscriptionMgr *psm;

        if (SUCCEEDED(JITCoCreateInstance(CLSID_SubscriptionMgr, NULL,
                              CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                              (void**)&psm, hwnd, FIEF_FLAG_FORCE_JITUI)))
        {
            //SysStringLen doesn't look at the string contents, just the cb of the alloc
            while (pwzUrls < (pvarUrlsToSynch->bstrVal + SysStringLen(pvarUrlsToSynch->bstrVal)))
            {
                psm->UpdateSubscription(pwzUrls);
                pwzUrls += lstrlenW(pwzUrls) + 1;
            }

            psm->Release();
        }
    }
#endif /* !DISABLE_SUBSCRIPTIONS */
}


/*
 * DoOrganizeFavDlgEx
 *
 * HWND hwnd             Owner window for the dialog.
 * LPWSTR pszInitDir     Dir to use as root. if null, the user's favorites dir is used.
 *
 * Returns:
 *  BOOL.  TRUE if succeeds. FALSE otherwise.
 *
 */

BOOL WINAPI DoOrganizeFavDlgEx(HWND hwnd, LPWSTR pszInitDir)
{
    // The easy answer would be to add an about:OrganizeFavorites that
    // gets registered in our selfreg.inx file.  Unfortunately, multilanguage
    // support requires us to generate the URL on the fly.

    WCHAR wszUrl[6 + MAX_PATH + 11 + 1]; // "res://MAX_PATH/orgfav.dlg"

    StrCpyNW(wszUrl, L"res://", 7);

#ifndef UNIX
    GetModuleFileNameWrapW(MLGetHinst(), wszUrl+6, MAX_PATH);
#else
    // IEUNIX : GetModuleFilename returns /vobs/...../libbrowseui.so
    // We need actual dllname here.
    StrCpyNW(wszUrl + 6, L"shdocvw.dll" , 12);
#endif

    StrCatW(wszUrl, L"/orgfav.dlg");

    IMoniker *pmk;
    if (SUCCEEDED(CreateURLMoniker(NULL, wszUrl, &pmk)))
    {
        ASSERT(pmk);
        VARIANT varUrlsToSynch, varInitialDir;
        BSTR    bstrInitDir;

        VariantInit(&varUrlsToSynch);
        VariantInit(&varInitialDir);

        if (pszInitDir)
        {
            bstrInitDir = SysAllocString(pszInitDir);
            if (bstrInitDir)
            {
                varInitialDir.vt = VT_BSTR;
                varInitialDir.bstrVal = bstrInitDir;
            }
        }
        
        ShowHTMLDialog(hwnd, pmk, &varInitialDir, L"Resizable=1", &varUrlsToSynch);
        OrgFavSynchronize(hwnd, &varUrlsToSynch);

        if (pszInitDir && bstrInitDir)
            SysFreeString(bstrInitDir);
        VariantClear(&varUrlsToSynch);
        pmk->Release();
        return TRUE;
    }
    else
        return FALSE;
}



/*
 * DoOrganizeFavDlg
 *
 * This API is exported so that it may be called by explorer and mshtml in
 * addition to being called internally by shdocvw.
 *
 * HWND   hwndOwner       Owner window for the dialog.
 * LPWSTR pszInitDir      Dir to use as root. if null, the user's favorites dir is used.
 *
 * Returns:
 *  BOOL.  TRUE if succeeds. FALSE otherwise.
 *
 */

BOOL WINAPI DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir)
{
    BOOL fRet;
    WCHAR szInitDir[MAX_PATH];

    if (pszInitDir)
    {
        SHAnsiToUnicode(pszInitDir, szInitDir, ARRAYSIZE(szInitDir));
        fRet = DoOrganizeFavDlgEx(hwnd, szInitDir);
    }
    else
    {
        fRet = DoOrganizeFavDlgEx(hwnd, NULL);
    }

    return fRet;
}

BOOL WINAPI DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir)
{
    return DoOrganizeFavDlgEx(hwnd, pszInitDir);
}


#define ADDTOFAVPROP TEXT("SHDOC_ATFPROP")

typedef enum { ATF_FAVORITE,
               ATF_CHANNEL,
               ATF_CHANNEL_MODIFY,
               ATF_CHANNEL_SOFTDIST
} FAVDLGTYPE;

typedef struct _ADDTOFAV
{
    PTSTR pszInitDir;
    UINT cchInitDir;
    PTSTR pszFile;
    UINT cchFile;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlSelected;
    LPCITEMIDLIST pidlFavorite;
    FAVDLGTYPE iDlgType;
    SUBSCRIPTIONINFO siSubsInProg;
    SUBSCRIPTIONTYPE subsType;
    BOOL bIsSoftdist;
    BOOL bStartSubscribed;
    BOOL bSubscribed;
} ADDTOFAV;

BOOL IsSubscribed(ADDTOFAV *patf);

typedef struct _BFFFavSubStruct
{
    WNDPROC lpfnOldWndProc;
    HWND hwndNew;
    HWND hwndTV;
    HWND hwndSave;
    HWND hTemplateWnd;
    ADDTOFAV * patf;
    RECT rcRestored;
} BFFFAVSUBSTRUCT;

BOOL_PTR CALLBACK NewFavDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        HWND hwnd;
        ASSERT(lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_NAME);
        hwnd = GetDlgItem(hDlg, IDD_NAME);
#ifndef UNIX
        SendMessage(hwnd, EM_LIMITTEXT, MAX_PATH - 1, 0);
#else
        // IEUNIX : file/dir name on unix is limited to _MAX_FNAME.
        SendMessage(hwnd, EM_LIMITTEXT, (WPARAM)(_MAX_FNAME - 1), (LPARAM)0);
#endif
        EnableOKButtonFromID(hDlg, IDD_NAME);
        break;
    }    
    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_NAME:
            {
                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
                {
                    LPTSTR lpstrName = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
                    EnableOKButtonFromID(hDlg, IDD_NAME);
                    GetDlgItemText(hDlg, IDD_NAME, lpstrName, MAX_PATH);
                }
                break;
            }

        case IDOK:
        {
            TCHAR  szTmp[MAX_PATH];
            StrCpyN(szTmp, (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER), ARRAYSIZE(szTmp));
            if (PathCleanupSpec(NULL,szTmp))
            {
               HWND hwnd;

             MLShellMessageBox(
                             hDlg,
                             MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                             MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                             MB_OK | MB_ICONHAND);
             hwnd = GetDlgItem(hDlg, IDD_NAME);
             SetWindowText(hwnd, TEXT('\0'));
             EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
             SetFocus(hwnd);
             break;
            }
        }
        // fall through

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// BOGUS - these id's stolen from SHBrowseForFolder implementation
#define IDD_FOLDERLIST 0x3741
#define IDD_BROWSETITLE 0x3742
#define IDD_BROWSESTATUS 0x3743

const static DWORD aAddToFavHelpIDs[] = {  // Context Help IDs
    IDC_FAVORITE_DESC,          NO_HELP,
    IDD_BROWSETITLE,            NO_HELP,
    IDD_BROWSESTATUS,           NO_HELP,
    IDC_FAVORITE_ICON,          NO_HELP,
    IDC_NAMESTATIC,             IDH_NAMEEDIT,
    IDC_FOLDERLISTSTATIC,       IDH_BROWSELIST,
    IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER,     IDH_BROWSELIST,
    IDC_FAVORITE_NEWFOLDER,     IDH_CREATEIN,
    IDC_SUBSCRIBE_CUSTOMIZE,    IDH_CHANNEL_SUBSCR_CUST_BUTTON,
    IDC_FAVORITE_CREATEIN,      IDH_NEWFOLDER,
    IDC_FAVORITE_NAME,          IDH_NAMEEDIT,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    0, 0
};

const static DWORD aAddToChanHelpIDs[] = {  // Context Help IDs
    IDC_FAVORITE_DESC,          NO_HELP,
    IDD_BROWSETITLE,            NO_HELP,
    IDD_BROWSESTATUS,           NO_HELP,
    IDC_FAVORITE_ICON,          NO_HELP,
    IDC_NAMESTATIC,             IDH_NAMEEDIT,
    IDC_FOLDERLISTSTATIC,       IDH_BROWSELIST,
    IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER,     IDH_BROWSELIST,
    IDC_FAVORITE_NEWFOLDER,     IDH_CREATEIN,
    IDC_SUBSCRIBE_CUSTOMIZE,    IDH_CHANNEL_SUBSCR_CUST_BUTTON,
    IDC_FAVORITE_CREATEIN,      IDH_NEWFOLDER,
    IDC_FAVORITE_NAME,          IDH_NAMEEDIT,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    0, 0
};

/*
 * Makes sure the item being added to favorites doesn't already exist.  If it does,
 * puts up a message box to have the user confirm whether they want to overwrite
 * the old favorite or not.  
*/
BOOL ConfirmAddToFavorites(HWND hwndOwner, ADDTOFAV * patf)
{
    BOOL fRet = FALSE;
    BOOL fExists;
    int iPromptString = 0;

    if (patf->subsType == SUBSTYPE_CHANNEL)
    {
        //patf->pszInitDir now contains the path with a .url on the end; the channel
        //will be stored in a directory of that name without .url.  Strip it.
        TCHAR szPath[MAX_PATH];
        StrCpyN(szPath, patf->pszInitDir, ARRAYSIZE(szPath));
        PathRemoveExtension (szPath);
        fExists = PathFileExists(szPath);

        iPromptString = IDS_CHANNELS_FILEEXISTS;

    }
    else
    {
        fExists = PathFileExists(patf->pszInitDir);
        iPromptString = IDS_FAVS_FILEEXISTS;

    }

    fRet = ! fExists ||
        (MLShellMessageBox(
                         hwndOwner,
                         MAKEINTRESOURCE(iPromptString),
                         NULL,    //use owner's title
                         MB_ICONQUESTION | MB_YESNO) == IDYES);
    return fRet;
}

//
// Get the localized date and time
//

typedef HRESULT (*PFVARIANTTIMETOSYSTEMTIME)(DOUBLE, LPSYSTEMTIME);


//
// Subscribe to the current site.
//

HRESULT SubscribeToSite(HWND hwnd, LPCTSTR pszFile, LPCITEMIDLIST pidl, DWORD dwFlags,
                        SUBSCRIPTIONINFO* pSubs, SUBSCRIPTIONTYPE subsType)
{
#ifndef DISABLE_SUBSCRIPTIONS

    TCHAR szURL[MAX_URL_STRING];
    ISubscriptionMgr *pISubscriptionMgr;

    //
    // Get a displayable URL.
    //

    IEGetDisplayName(pidl, szURL, SHGDN_FORPARSING);

    //
    // Get a pointer to the subscription manager.
    //

    HRESULT hr = JITCoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&pISubscriptionMgr, hwnd, FIEF_FLAG_FORCE_JITUI);

    if (SUCCEEDED(hr)) 
    {
        //
        // Create a default subscription.
        //
        BSTR bstrURL = SysAllocStringT(szURL);
        if (bstrURL) 
        {
            BSTR bstrName = SysAllocStringT(pszFile);
            if (bstrName) 
            {
                hr = pISubscriptionMgr->CreateSubscription(hwnd, 
                    bstrURL, bstrName, dwFlags, subsType,  pSubs);
                SysFreeString(bstrName);
            }
            SysFreeString(bstrURL);
        }

        //
        // Clean up.
        //

        pISubscriptionMgr->Release();
    }

    return hr;
#else  /* !DISABLE_SUBSCRIPTIONS */

    return E_FAIL;

#endif /* !DISABLE_SUBSCRIPTIONS */
}


//
// Create in-memory subscription, but only optionally save it to subscription manager
//

BOOL StartSiteSubscription (HWND hwnd, ADDTOFAV* patf, BOOL bFinalize)
{
#ifndef DISABLE_SUBCRIPTIONS

    //update the changes-only flag (radio buttons here are, effectively, direct access to this flag)
    if (patf->subsType == SUBSTYPE_CHANNEL || patf->subsType == SUBSTYPE_DESKTOPCHANNEL)
    {
        //if set, leave alone; otherwise, put to full download
        if (!(patf->siSubsInProg.fChannelFlags & CHANNEL_AGENT_PRECACHE_SOME))
            patf->siSubsInProg.fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;

        patf->siSubsInProg.fUpdateFlags |= SUBSINFO_CHANNELFLAGS | SUBSINFO_SCHEDULE;
    }

    if (S_OK != SubscribeToSite(hwnd, patf->pszFile, patf->pidlFavorite,
                                   bFinalize ? CREATESUBS_NOUI | CREATESUBS_FROMFAVORITES : CREATESUBS_NOSAVE,
                                   &patf->siSubsInProg, patf->subsType))
    {
        return FALSE;
    }

    return TRUE;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return FALSE;

#endif /* !DISABLE_SUBSCRIPTIONS */
}

/*
   Combines the path and the filename of the favorite
   and puts it into patf->pszInitDir, so that it has the fully qualified pathname.
*/
#define SZ_URLEXT    TEXT(".url")
#define CCH_URLEXT   SIZECHARS(SZ_URLEXT)

BOOL QualifyFileName(ADDTOFAV *patf)
{
    TCHAR szTemp[MAX_PATH];
    BOOL fRet = FALSE;
    LPTSTR  pstr;

    // Can we safely add the extension to this?
    if (lstrlen(patf->pszFile) < (int)(patf->cchFile - CCH_URLEXT))
    {
        //Add extension .url if its not already there
        //This is to prevent strings like "com"  in "www.microsoft.com" from being interpreted as extensions

        pstr = PathFindExtension(patf->pszFile);
        if (!pstr || (pstr && StrCmpI(pstr, SZ_URLEXT)))// && StrCmpI(pstr, SZ_CDFEXT)))
            StrCatBuff(patf->pszFile, SZ_URLEXT, patf->cchFile);
            
        // Is there a folder associated with the filename?
        if (patf->pidlSelected && SHGetPathFromIDList(patf->pidlSelected, szTemp)) 
        {
            // Yes
            if (PathCombine(szTemp, szTemp, patf->pszFile))
            {
                if ((UINT)lstrlen(szTemp) < patf->cchInitDir)
                {
                    StrCpyN(patf->pszInitDir, szTemp, patf->cchInitDir);
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}


BOOL SubscriptionFailsChannelAuthentication (HWND hDlg, SUBSCRIPTIONINFO* psi)
{
#ifndef DISABLE_SUBSCRIPTIONS  

    if (psi->bNeedPassword && !(psi->bstrPassword && psi->bstrPassword[0]
                             && psi->bstrUserName && psi->bstrUserName[0]))
    {   //password would be required
        if (IsDlgButtonChecked (hDlg, IDC_MAKE_OFFLINE))
        {   //they're trying to subscribe...  WRONG!
            MLShellMessageBox(
                hDlg,
                MAKEINTRESOURCE(IDS_NEED_CHANNEL_PASSWORD),
                NULL,
                MB_ICONINFORMATION | MB_OK);
            return TRUE;
        }
    }

    return FALSE;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return FALSE;

#endif /* !DISABLE_SUBSCRIPTIONS */
}


LRESULT CALLBACK BFFFavSubclass(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BFFFAVSUBSTRUCT * pbffFS = (BFFFAVSUBSTRUCT *)GetProp(hwnd, ADDTOFAVPROP);
    WNDPROC lpfnOldWndProc = pbffFS->lpfnOldWndProc;
    RECT rc;

    switch (uMsg) {
        case WM_COMMAND:
            // Intercept the command for the New Folder button we hacked into
            // the SHBrowseForFolder dialog.
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_FAVORITE_NAME:
            {
                HWND hwndedit;
                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) 
                    EnableOKButtonFromID(hwnd, IDC_FAVORITE_NAME);
                hwndedit = GetDlgItem(hwnd, IDC_FAVORITE_NAME);
                SendMessage(hwndedit, EM_LIMITTEXT, MAX_PATH - 1, 0);
                break;
            }    

#ifndef UNIX
// IEUNIX (OFFLINE) : No offline ability

            case IDC_MAKE_OFFLINE:
                EnableWindow(GetDlgItem(hwnd, IDC_SUBSCRIBE_CUSTOMIZE), 
                             IsDlgButtonChecked(hwnd, IDC_MAKE_OFFLINE));
                break;

            case IDC_SUBSCRIBE_CUSTOMIZE:
                //need to create -- but not store -- subscription
                if (StartSiteSubscription (hwnd, pbffFS->patf, FALSE))
                    SendMessage (hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwnd, IDOK), TRUE);
                break;
#endif

            case IDC_FAVORITE_NEWFOLDER:
                TCHAR szPath[MAX_PATH];
                TCHAR szName[MAX_PATH];
                HWND hwndTV;
                TV_ITEM tv_item;

                // Bring up the Create New Folder dialog
                if ((DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_NEWFOLDER), hwnd,
                    NewFavDlgProc, (LPARAM)szName) == IDOK) &&
                    (SHGetPathFromIDList(pbffFS->patf->pidlSelected, szPath)) &&
                    ((lstrlen(szPath) + lstrlen(szName) + 1) < MAX_PATH))
                {
                    PathCombine(szPath, szPath, szName);

                    BOOL bSuccess = FALSE;

#ifdef CREATEFOLDERSINCHANNELSDIR
                    if (pbffFS->patf->subsType == SUBSTYPE_CHANNEL)
                    {
                        ASSERT(0);  //should not be possible in this release
                                    //(I removed this button in the .rc dialogs for channels)

                        //Note: to make this work in a future release, reenable this code -- it's
                        //functional.  But the folders created here show up ugly in the channel bar
                        //(just a default folder icon) and if you click on them, you get a shell
                        //Explorer window instead of a theater-mode browser window.  The reason
                        //for this second happening is that the desktop.ini file created in the new
                        //folder has no URL=.  To remedy this: AddCategory() has to be fixed so it
                        //doesn't interpret the pszURL argument as a UNC name (I was using a resouce moniker
                        //pointing into cdfview.dll for the html target), and the OC hosted by the default
                        //html pages has to learn how to be hosted from a html page without a path -- or we
                        //actually have to create an html page in the new directory, which is messy.
                        IChannelMgr* pChanMgr;
                        HRESULT hr;

                        hr = JITCoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                                              IID_IChannelMgr, (void**)&pChanMgr, 
                                              hwnd, FIEF_FLAG_FORCE_JITUI);

                        if (SUCCEEDED(hr))
                        {
                            IChannelMgrPriv* pChanMgrPriv;
                            hr = pChanMgr->QueryInterface (IID_IChannelMgrPriv, (void**)&pChanMgrPriv);
                            if (SUCCEEDED(hr))
                            {
                                char szCFPath[MAX_PATH];
                                WCHAR wszFolder[MAX_PATH];
                                IChannelMgrPriv::CHANNELFOLDERLOCATION cflLocation =
                                    (pbffFS->patf->iDlgType == ATF_CHANNEL_SOFTDIST ?
                                        IChannelMgrPriv::CF_SOFTWAREUPDATE :
                                        IChannelMgrPriv::CF_CHANNEL);
                                hr = pChanMgrPriv->GetChannelFolderPath (szCFPath, ARRAYSIZE(szCFPath), cflLocation);

                                int cchCommon = PathCommonPrefix (szPath, szCFPath, NULL);
                                AnsiToUnicode (szPath + cchCommon, wszFolder, ARRAYSIZE(wszFolder));

                                CHANNELCATEGORYINFO info = {0};
                                info.cbSize = sizeof(info);
                                info.pszTitle = wszFolder;
                                bSuccess = SUCCEEDED (pChanMgr->AddCategory (&info));

                                pChanMgrPriv->Release();
                            }

                            pChanMgr->Release();
                        }
                    }
                    else
#endif
                    {
                        bSuccess = CreateDirectory(szPath, NULL);
                    }

                    if (bSuccess)
                    {
                        // This code assumes the layout of SHBrowseForFolder!

                        // directory successfully created, must notify registered shell components.
                        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, NULL);
                        // Get the TreeView control
                        hwndTV = GetDlgItem(hwnd, IDD_FOLDERLIST);
                        if (hwndTV) {
                            HTREEITEM hti = TreeView_GetSelection(hwndTV);
                            // Take the selected item and reset it, then reexpand it so
                            // that it shows the new directory we just created.
                            tv_item.mask = TVIF_CHILDREN;
                            tv_item.hItem = hti;
                            tv_item.cChildren = -1;
                            TreeView_SetItem(hwndTV, &tv_item);
                            TreeView_Expand(hwndTV, hti, TVE_COLLAPSE | TVE_COLLAPSERESET);
                            TreeView_Expand(hwndTV, hti, TVE_EXPAND);

                            // Find the new directory we just created and select it by
                            // walking the tree from the selected item down.
                            if (hti = TreeView_GetChild(hwndTV, hti)) {
                                tv_item.mask = TVIF_TEXT;
                                tv_item.pszText = szPath;
                                tv_item.cchTextMax = MAX_PATH;
                                do {
                                    tv_item.hItem = hti;
                                    TreeView_GetItem(hwndTV, &tv_item);
                                    if (StrCmp(szName, szPath) == 0) {
                                        TreeView_Select(hwndTV, hti, TVGN_CARET);
                                        break;
                                    }
                                } while (hti = TreeView_GetNextSibling(hwndTV, hti));
                            }
                            SetFocus(hwndTV);
                        }
                    } else {
                        
                        LPVOID lpMsgBuf;

                        FormatMessage( 
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            GetLastError(),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &lpMsgBuf,
                            0,
                            NULL 
                        );
                        MLShellMessageBox(
                                        hwnd,
                                        (LPCTSTR)lpMsgBuf,
                                        MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                                        MB_ICONINFORMATION | MB_OK);
                        
                        // Free the buffer.
                        LocalFree( lpMsgBuf );
                        lpMsgBuf = NULL;                        
                    }
                }
                break;

            case IDOK:
                // first, make sure they're not trying to subscribe to an authenticated
                // channel without entering a password.
                if (SubscriptionFailsChannelAuthentication (hwnd, &pbffFS->patf->siSubsInProg))
                    return FALSE;

                // Retrieve the text from the Name edit control.
                GetDlgItemText(hwnd, IDC_FAVORITE_NAME, pbffFS->patf->pszFile, pbffFS->patf->cchFile);
                { // Just  a block to declare variables
                    BOOL fTooBig = TRUE;        // assume failure
                    TCHAR  szTmp[MAX_PATH];
                                       
                    if (lstrlen(pbffFS->patf->pszFile) < MAX_PATH)
                    {
                        StrCpyN(szTmp, pbffFS->patf->pszFile, ARRAYSIZE(szTmp));

                        // PathCleanupSpec deals with MAX_PATH buffers, so we should be fine
                        if (PathCleanupSpec(NULL, szTmp))
                        {
                            MLShellMessageBox(
                                            hwnd,
                                            MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                                            MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                                            MB_OK | MB_ICONHAND);
                            return FALSE;
                        }
                                       
                        // Make sure the name is unique and if not, that the user has
                        // specified that it is OK to override.
                        if (QualifyFileName(pbffFS->patf))
                        {
                            if (!ConfirmAddToFavorites(hwnd, pbffFS->patf))
                                return FALSE;

                            //  Bogus hack since the ATF stuff is only half done
                            //  Depending on which dlg is shown, look for the appropriate
                            //  check.
                            if (IsDlgButtonChecked (hwnd, IDC_MAKE_OFFLINE))
                            {
                               //they want to subscribe!  save subscription we already have in memory
                                //trouble is, pbffFS->patf->pszFile ends in a bogus .url
                                TCHAR* pszTemp = pbffFS->patf->pszFile;
                                TCHAR szNoExt[MAX_PATH];
                                StrCpyN(szNoExt, pbffFS->patf->pszFile, ARRAYSIZE(szNoExt));
                                pbffFS->patf->pszFile = szNoExt;
                                PathRemoveExtension (szNoExt);
                                pbffFS->patf->bSubscribed = 
                                    StartSiteSubscription (hwnd, pbffFS->patf, TRUE);
                                pbffFS->patf->pszFile = pszTemp;
                            }
                            else if (pbffFS->patf->bStartSubscribed)
                            {
                                //  If we started subscribed and they unchecked make available
                                //  offline, then delete the subscription.

                                ISubscriptionMgr* pSubsMgr;
                                if (SUCCEEDED (CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                                                IID_ISubscriptionMgr, (void**)&pSubsMgr)))
                                {
                                    //url is in patf->pidlFavorite
                                    WCHAR wszURL[MAX_URL_STRING];
                                    IEGetDisplayName(pbffFS->patf->pidlFavorite, wszURL, SHGDN_FORPARSING);

                                    pSubsMgr->DeleteSubscription(wszURL, NULL);
                                    pSubsMgr->Release();
                                }
                            }

                            // Enable and set focus to the tree view so that it is sure to
                            // be selected so that SHBrowseForFolder will return a pidl.
                            EnableWindow(pbffFS->hwndTV, TRUE);
                            SetFocus(pbffFS->hwndTV);
                            fTooBig = FALSE;
                        }
                    }

#ifdef UNIX_FEATURE_ALIAS
                    if( !fTooBig )
                    {
                        TCHAR alias[MAX_ALIAS_LENGTH];
                        TCHAR szThisURL[MAX_URL_STRING];
                        HDPA  aliasList = GetGlobalAliasList();

                        if( aliasList )
                        {
#ifdef UNICODE
                            // TODO :
#else
                            // Retrieve the text from the Alias edit control.
                            GetDlgItemText(hwnd, IDC_ALIAS_NAME, alias, MAX_ALIAS_LENGTH-1);
                            IEGetDisplayName(pbffFS->patf->pidlFavorite, 
                                szThisURL, SHGDN_FORPARSING);
                            if(AddAliasToListA( aliasList, alias, szThisURL, hwnd ))
                                SaveAliases(aliasList);
#endif
                        }
                    }
#endif /* UNIX_FEATURE_ALIAS */

                    if (fTooBig)
                    {
                        MLShellMessageBox(
                                        hwnd,
                                        MAKEINTRESOURCE(IDS_FAVS_FNTOOLONG),
                                        MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                                        MB_OK | MB_ICONHAND);
                        return FALSE;
                    }
                }
                break;

            case IDC_FAVORITE_CREATEIN:
                // The advanced button has been clicked.  Enable/disable the tree view
                // and New button, set focus to the tree view or ok button, disable the advanced
                // button and then resize the dialog.
            {
                BOOL fExpanding = !IsWindowEnabled(GetDlgItem(hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER)); //random control that gets enabled when dialog expanded
                TCHAR szBuffer[100];

                EnableWindow(pbffFS->hwndTV, fExpanding);
                //don't show New Folder button for channels in the channels folder,
                // see code for case IDC_FAVORITE_NEWFOLDER for why
                if (fExpanding && pbffFS->patf->subsType == SUBSTYPE_CHANNEL)
                {
                    LPITEMIDLIST pidlFavs = NULL;
                    TCHAR tzFavsPath[MAX_PATH];
                
                    if (SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_FAVORITES, &pidlFavs)) 
                    &&  SUCCEEDED(SHGetNameAndFlags(pidlFavs, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, tzFavsPath, SIZECHARS(tzFavsPath), NULL))
                    &&  StrCmpNI(tzFavsPath, pbffFS->patf->pszInitDir, ARRAYSIZE(tzFavsPath))==0)
                    {
                        EnableWindow(pbffFS->hwndNew, TRUE);
                    }
                    if(pidlFavs)
                        ILFree(pidlFavs);
                }
                else
                    EnableWindow(pbffFS->hwndNew, fExpanding);

                GetWindowRect(hwnd, &rc);
                if (fExpanding)
                {
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_COLLAPSE, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);
                    
                    SetFocus(pbffFS->hwndTV);

                    MoveWindow(hwnd, rc.left, rc.top,
                        pbffFS->rcRestored.right - pbffFS->rcRestored.left,
                        pbffFS->rcRestored.bottom - pbffFS->rcRestored.top, TRUE);
                }
                else
                {
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_EXPAND, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);
                    
                    SetFocus(GetDlgItem(hwnd, IDC_FAVORITE_NAME));

                    MoveWindow(hwnd, rc.left, rc.top,
                        pbffFS->rcRestored.right - pbffFS->rcRestored.left,
                        pbffFS->rcRestored.bottom - pbffFS->rcRestored.top, TRUE);

                    // hide the bottom part of the dialog
                    int cx, cy;
                    RECT rc;
                    GetWindowRect (GetDlgItem (hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER), &rc);
                    cy = rc.top;
                    GetWindowRect (hwnd, &rc);
                    cx = rc.right - rc.left;
                    cy = cy /*top of ctrl*/ - rc.top; /*top of window*/
                    SetWindowPos (hwnd, NULL, 0, 0, cx, cy, SWP_NOMOVE | SWP_NOZORDER);
                }
                SetWindowText(GetDlgItem(hwnd, IDC_FAVORITE_CREATEIN), szBuffer);

                break;
            }
            }
            break;

        case WM_DESTROY:
        {
            DWORD dwValue = IsWindowEnabled(GetDlgItem(hwnd, IDC_FAVORITE_NEWFOLDER)); //random control that gets enabled when dialog expanded

            SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("AddToFavoritesExpanded"),
                REG_DWORD, &dwValue, 4, SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
            ReplaceTransplacedControls (hwnd, pbffFS->hTemplateWnd);
            DestroyWindow (pbffFS->hTemplateWnd);
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) lpfnOldWndProc);
            RemoveProp(hwnd, ADDTOFAVPROP);
            SHRemoveDefaultDialogFont(hwnd);
            ILFree(pbffFS->patf->pidlSelected);
            LocalFree((HLOCAL)pbffFS);
            pbffFS = NULL;
            break;
        }
        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) (pbffFS->patf->iDlgType == ATF_FAVORITE
                                ? aAddToFavHelpIDs : aAddToChanHelpIDs));
            return TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) (pbffFS->patf->iDlgType == ATF_FAVORITE
                             ? aAddToFavHelpIDs : aAddToChanHelpIDs));
            return TRUE;
            break;

    }

    return CallWindowProc(lpfnOldWndProc, hwnd, uMsg, wParam, lParam);
}


static const TCHAR szTransplacedProp[] = TEXT("tp");
void ReplaceTransplacedControls (HWND hDlgMaster, HWND hDlgTemplate)
{
    /*
     * This function moves the controls that we moved from our temporary
     * dialog over to SHBrowseForFolder's dialog, back to their original
     * home, before they get destroyed.  This is because otherwise we have
     * problems when destroying the template dialog -- specifically, we get
     * a GP fault in user.exe when destroying the edit control, because it
     * looks to its parent window to figure out where its data segment is.
     *
     * Solution: (for safety) -- put everything back where it came from.
     * Other possibilities: just move the edit control (by ID) back, or
     *       move all edit controls back, or use DS_LOCALEDIT for edit controls
     *       (but this is documented only for use with multiline edits.)
     *       Or modify SHBrowseForFolder to allow other dialog templates...
     *       but that's over in shell32.
     */
    HWND hCtrl = GetWindow (hDlgMaster, GW_CHILD);
    while (hCtrl)
    {
        HWND hNext = GetWindow (hCtrl, GW_HWNDNEXT);

        if (GetProp (hCtrl, szTransplacedProp) != NULL)
        {
            RemoveProp (hCtrl, szTransplacedProp);
            SetParent (hCtrl, hDlgTemplate);
        }

        hCtrl = hNext;
    }
}

#define szOriginalWND TEXT("WorkaroundOrigWndProc")
INT_PTR CALLBACK MergeFavoritesDialogControls(HWND hDlgTemplate, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        HWND hDlgMaster = (HWND)lParam;
        ASSERT (IsWindow (hDlgMaster));

        TCHAR szT[200];
        RECT rc;

        //resize master like us
        GetWindowText (hDlgTemplate, szT, ARRAYSIZE(szT));
        SetWindowText (hDlgMaster, szT);
        GetClientRect (hDlgTemplate, &rc);
        AdjustWindowRect (&rc, GetWindowLong (hDlgMaster, GWL_STYLE), FALSE);
        SetWindowPos (hDlgMaster, NULL, 0, 0, rc.right - rc.left, rc.bottom - rc.top,
            SWP_NOMOVE | SWP_NOZORDER);
        // a-msadek; If the owned window is mirrored, a dialog with specifed 
        // coordinates, the dialog get moved to the worng direction
        HWND hWndOwner = GetWindow(hDlgMaster, GW_OWNER);

        if(IS_WINDOW_RTL_MIRRORED(hWndOwner))
            {
                RECT rcOwner, rcDlg;            
                GetWindowRect(hWndOwner, &rcOwner);
                GetWindowRect(hDlgMaster, &rcDlg);
                SetWindowPos(hDlgMaster, NULL, rcDlg.left - (rcDlg.right - rcOwner.right), rcDlg.top, 0 ,0,
                SWP_NOSIZE | SWP_NOZORDER);
            }
            

#if 0   //now we do this as part of the "move controls from template to master" process,
        //if we notice that a ctrl with that id already exists.  This way we pick up the
        //tab order too.  If someone decides my hack (SetParent) to change tab order is
        //broken, then that code can be nuked and this reenabled.

        //position already-existing controls in master like us
        int ID_PREEXIST_CTRLS[] = { IDOK_PLACEHOLDER, IDCANCEL_PLACEHOLDER,
            IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER };

        for (int iCtrl = 0; iCtrl < ARRAYSIZE(ID_PREEXIST_CTRLS); iCtrl++)
        {
            GetWindowRect (GetDlgItem (hDlgTemplate, ID_PREEXIST_CTRLS[iCtrl]), &rc);
            MapWindowPoints (NULL, hDlgTemplate, (LPPOINT)&rc, 2);
            MoveWindow (GetDlgItem (hDlgMaster, ID_PREEXIST_CTRLS[iCtrl]),
                rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);

            DestroyWindow (GetDlgItem (hDlgTemplate, ID_PREEXIST_CTRLS[iCtrl]));
        }
#endif

        //copy other controls from us to master
        //find last child
        HWND hCtrlTemplate = NULL;
        HWND hNextCtrl = GetWindow (hDlgTemplate, GW_CHILD);
        if (hNextCtrl)      //can't see how this would fail, but...
            hCtrlTemplate = GetWindow (hNextCtrl, GW_HWNDLAST);

        //have last window in hCtrlTemplate
        //now move controls over in reverse order -- they'll end up stacking up in original order from template
        while (hCtrlTemplate)
        {
            hNextCtrl = GetWindow (hCtrlTemplate, GW_HWNDPREV);
            DWORD id = GetWindowLong (hCtrlTemplate, GWL_ID);
            HWND hCtrlExisting;
            if (id != (USHORT)IDC_STATIC && NULL != (hCtrlExisting = GetDlgItem (hDlgMaster, id)))
                //it's one of the controls pre-created by SHBrowseForFolder
            {   //so don't move this one over -- adjust existing control for size, position, tab order
                RECT rc;
                GetWindowRect (hCtrlTemplate, &rc);
                MapWindowPoints (NULL, hDlgTemplate, (LPPOINT)&rc, 2);
                SetWindowPos (hCtrlExisting, NULL, rc.left, rc.top,
                    rc.right - rc.left, rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOZORDER);
                DestroyWindow (hCtrlTemplate);
                //REVIEW
                //hack -- send control to end of tab order
                SetParent (hCtrlExisting, hDlgTemplate);
                SetParent (hCtrlExisting, hDlgMaster);
            }
            else    //we should move this control from template to master
            {
                SetProp (hCtrlTemplate, szTransplacedProp, (HANDLE)TRUE);  //anything -- it's the existence of the prop that we check for
                SetParent (hCtrlTemplate, hDlgMaster);          //to know to move this control back later
            }
            hCtrlTemplate = hNextCtrl;
        }
        // Let Template know about the child so that it can forward WM_COMMAND notifications to it
        // to work around the fact that edit controls cache their parent pointers and ignore SetParents
        // when it comes to sending parent notifications
        SetProp(hDlgTemplate, szOriginalWND, hDlgMaster);
    }

        break;
    case WM_COMMAND:
        // Workaround for above bug
        SendMessage((HWND)GetProp(hDlgTemplate, szOriginalWND), uMsg, wParam, lParam);
        break;
    }

    return FALSE;
}


int CALLBACK BFFFavCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
        case BFFM_INITIALIZED:
        {
            ADDTOFAV* patf = (ADDTOFAV*)lpData;
            ASSERT (patf);

            HWND hDlgTemp = CreateDialogParam(MLGetHinst(), 
                                MAKEINTRESOURCE(IDD_ADDTOFAVORITES_TEMPLATE),
                                NULL, MergeFavoritesDialogControls, (LPARAM)hwnd);
            //this results in all the controls being copied over
            
            //if successful, make our other modifications
            BFFFAVSUBSTRUCT * pbffFavSubStruct;
            if ((IsWindow(GetDlgItem(hwnd, IDC_SUBSCRIBE_CUSTOMIZE)))   //verify existence of randomly-selected control
                && (pbffFavSubStruct = (BFFFAVSUBSTRUCT *) LocalAlloc(LPTR, sizeof(BFFFAVSUBSTRUCT))))
            {
                //done with template, but don't destroy it:
                //see MSKB Q84190, owner/owned vs parent/child -- the children
                // of template are now children of master, but still OWNED
                // by template, and are destroyed when template is destroyed...
                // but we'll just keep template around
                // invisibly.
                //we'll take care of it when we go away

                //Do we need to do SetDefaultDialogFont stuff for localization still, since it all comes from the .rc?

                //set up window stuff for subclass:
                // Get the TreeView control so we can muck with the style bits and move it down
                HWND hwndT;
                if (hwndT = GetDlgItem(hwnd, IDD_FOLDERLIST))
                {
                    DWORD dwStyle = GetWindowLong(hwndT, GWL_STYLE);
                    dwStyle |= TVS_SHOWSELALWAYS;
                    dwStyle &= ~TVS_LINESATROOT;
                    SetWindowLong(hwndT, GWL_STYLE, dwStyle);
                }

                // don't allow subscriptions if the URL is not "http:" protocol, or if already subscribed
                TCHAR szURL[MAX_URL_STRING];

                if (!patf->pidlFavorite ||
                    FAILED(IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING)) ||
                    SHRestricted2(REST_NoAddingSubscriptions, szURL, 0) ||
                    !IsSubscribable(szURL) ||
                    !IsFeaturePotentiallyAvailable(CLSID_SubscriptionMgr) ||
                    !IsBrowserFrameOptionsPidlSet(patf->pidlFavorite, BFO_USE_IE_OFFLINE_SUPPORT))
                {
                    CheckDlgButton(hwnd, IDC_MAKE_OFFLINE, 0);
                    EnableWindow(GetDlgItem (hwnd, IDC_MAKE_OFFLINE), FALSE);
                    EnableWindow(GetDlgItem (hwnd, IDC_SUBSCRIBE_CUSTOMIZE), FALSE);
                }
                else if (IsSubscribed(patf))
                {
                    patf->bStartSubscribed = TRUE;
                    CheckDlgButton(hwnd, IDC_MAKE_OFFLINE, 1);
                }
                else if (patf->bIsSoftdist)
                {
                    CheckDlgButton(hwnd, IDC_MAKE_OFFLINE, 1);
                }
                EnableWindow(GetDlgItem(hwnd, IDC_SUBSCRIBE_CUSTOMIZE),
                             IsDlgButtonChecked(hwnd, IDC_MAKE_OFFLINE));

                //set the name
                Edit_LimitText(GetDlgItem(hwnd, IDC_FAVORITE_NAME), MAX_PATH - 1);

                // Use URL if title string is not displayable
                if (SHIsDisplayable(patf->pszFile, g_fRunOnFE, g_bRunOnNT5))
                {  
                    SetDlgItemText(hwnd, IDC_FAVORITE_NAME, patf->pszFile);
                }
                else
                {
                    TCHAR szUrlTemp[MAX_URL_STRING];
                    IEGetDisplayName(patf->pidlFavorite, szUrlTemp, SHGDN_FORPARSING);
                    SetDlgItemText(hwnd, IDC_FAVORITE_NAME, szUrlTemp);
                }

                EnableOKButtonFromID(hwnd, IDC_FAVORITE_NAME);


                // hide the (empty) SHBrowseForFolder prompt control
                ShowWindow(GetDlgItem (hwnd, IDD_BROWSETITLE), SW_HIDE);

                // Fill out the structure and set it as a property so that our subclass
                // proc can get to this data.
                pbffFavSubStruct->lpfnOldWndProc = (WNDPROC) SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)BFFFavSubclass);
                pbffFavSubStruct->hwndNew = GetDlgItem(hwnd, IDC_FAVORITE_NEWFOLDER);
                pbffFavSubStruct->patf = patf;
                pbffFavSubStruct->hwndTV = GetDlgItem(hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER);
                pbffFavSubStruct->hwndSave = GetDlgItem(hwnd, IDC_FAVORITE_CREATEIN);
                pbffFavSubStruct->hTemplateWnd = hDlgTemp;  //save for explicit destruction later
                GetWindowRect(hwnd, &(pbffFavSubStruct->rcRestored));

                SetProp(hwnd, ADDTOFAVPROP, (HANDLE)pbffFavSubStruct);

                patf->pidlSelected = ILClone(patf->pidl);

                DWORD dwType, dwValue = 0, dwcData = sizeof(dwValue);
                TCHAR szBuffer[100];
                
                SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("AddToFavoritesExpanded"),
                        &dwType, &dwValue, &dwcData, 0, NULL, sizeof(dwValue));

                if (dwValue == 0)
                {
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_EXPAND, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);

                    // Disable the tree view and new button so that we can't tab to them.
                    EnableWindow(GetDlgItem (hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER), FALSE);
                    EnableWindow(GetDlgItem (hwnd, IDC_FAVORITE_NEWFOLDER), FALSE);

                    // hide the bottom part of the dialog
                    int cx, cy;
                    RECT rc;
                    GetWindowRect (GetDlgItem (hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER), &rc);
                    cy = rc.top;
                    GetWindowRect (hwnd, &rc);
                    cx = rc.right - rc.left;
                    cy = cy /*top of ctrl*/ - rc.top; /*top of window*/
                    SetWindowPos (hwnd, NULL, 0, 0, cx, cy, SWP_NOMOVE | SWP_NOZORDER);
                }
                else
                {
                    //don't show New Folder button for channels in the channels folder,
                    // see code for case IDC_FAVORITE_NEWFOLDER for why
                    if (patf->subsType == SUBSTYPE_CHANNEL)
                    {
                        LPITEMIDLIST pidlFavs = NULL;
                        TCHAR tzFavsPath[MAX_PATH];
                    
                        if (SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_FAVORITES, &pidlFavs)) 
                        && SUCCEEDED(SHGetNameAndFlags(pidlFavs, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, tzFavsPath, SIZECHARS(tzFavsPath), NULL))
                        && 0 == StrCmpNI(tzFavsPath, patf->pszInitDir, ARRAYSIZE(tzFavsPath)))
                        {
                            EnableWindow(pbffFavSubStruct->hwndNew, TRUE);
                        }
                        else
                            EnableWindow(pbffFavSubStruct->hwndNew, FALSE);

                        if(pidlFavs)
                            ILFree(pidlFavs);
                    }
                    else
                        EnableWindow(pbffFavSubStruct->hwndNew, TRUE);
                    
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_COLLAPSE, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);
                }
                SetWindowText(GetDlgItem(hwnd, IDC_FAVORITE_CREATEIN), szBuffer);
                
            }
            else
            {
                EndDialog(hwnd, IDCANCEL);
            }
            break;
        }
        case BFFM_SELCHANGED:
        {
            //the first of these comes during BFFM_INITIALIZED, so ignore it
            if (((ADDTOFAV *)lpData)->pidlSelected != NULL)
            {
                ILFree(((ADDTOFAV *)lpData)->pidlSelected);
                ((ADDTOFAV *)lpData)->pidlSelected = ILClone((LPITEMIDLIST)lParam);
            }
            break;
        }
    }

    return 0;
}


// This API is not exported.  See below (DoAddToFavDlg) for the exported version
//
// hwnd        parent window for the dialog.
// pszInitDir  input: initial path
//             output: fully qualified path and filename
// chInitDir   Length of pszInitDir buffer
// pszFile     initial (default) filename for shortcut
// cchFile     Length of pszFile buffer
// pidlBrowse  associated with pszInitDir
//
// Returns:
//  TRUE if a directory and filename were selected by user, and no error
//  occurs.  In this case pszInitDir contains the new destination directory
//  and filename, pszFile contains the new file name.
//
//  FALSE if an error occurs or the user selects CANCEL.

STDAPI_(BOOL) DoAddToFavDlgEx(HWND hwnd, 
                            TCHAR *pszInitDir, UINT cchInitDir,
                            TCHAR *pszFile, UINT cchFile, 
                            LPITEMIDLIST pidlBrowse,
                            LPCITEMIDLIST pidlFavorite,
                            FAVDLGTYPE atfDlgType,
                            SUBSCRIPTIONINFO* pInfo)
{
    ADDTOFAV atf = {pszInitDir, cchInitDir - 1, pszFile, cchFile - 1, pidlBrowse, NULL,
                    pidlFavorite, atfDlgType, {sizeof(SUBSCRIPTIONINFO), 0}, SUBSTYPE_URL };
    TCHAR szTemp[1];    //NOTE: we're not using SHBrowseForFolder's prompt string (see below)
    TCHAR szDisplayName[MAX_PATH];
    BROWSEINFO bi = {
            hwnd,
            pidlBrowse,
            szDisplayName,
            szTemp,
            BIF_RETURNONLYFSDIRS,
            // (BFFCALLBACK)
            BFFFavCallback,
            (LPARAM)&atf,
            0
    };
    LPITEMIDLIST pidl;

    if (pInfo)
        atf.siSubsInProg = *pInfo;

    switch (atfDlgType)
    {
        case ATF_CHANNEL_SOFTDIST:
            atf.bIsSoftdist = TRUE;
            //  fall through
        case ATF_CHANNEL:
            atf.subsType = SUBSTYPE_CHANNEL;
            break;

        //default:
        //  set in initialize to SUBSTYPE_URL
    }

    //this string is now in the template dialog in the .rc
    //REVIEW -- do we want to do it this way (we're hiding SHBrowse...'s control)? then the template dialog looks more like the finished product...
    szTemp[0] = 0;
 
    //init native font control, otherwise dialog may fail to initialize
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_NATIVEFNTCTL_CLASS;
        InitCommonControlsEx(&icc);
    }
    
    pidl = SHBrowseForFolder(&bi);

    if (pidl)
    {
        ILFree(pidl);
    }

    //  If the user created a new subscription, start a download.
    if (atf.bSubscribed && !atf.bStartSubscribed)
    {
        ISubscriptionMgr* pSubsMgr;
        if (SUCCEEDED (CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                        IID_ISubscriptionMgr, (void**)&pSubsMgr)))
        {
            WCHAR wszURL[MAX_URL_STRING];

            IEGetDisplayName(atf.pidlFavorite, wszURL, SHGDN_FORPARSING);

            pSubsMgr->UpdateSubscription(wszURL);
            pSubsMgr->Release();
        }
    }

    return (pidl != NULL);
}

STDAPI_(BOOL) DoSafeAddToFavDlgEx(HWND hwnd, 
                            TCHAR *pszInitDir, UINT cchInitDir,
                            TCHAR *pszFile, UINT cchFile, 
                            LPITEMIDLIST pidlBrowse,
                            LPCITEMIDLIST pidlFavorite,
                            FAVDLGTYPE atfDlgType,
                            SUBSCRIPTIONINFO* pInfo)
{
    BOOL fRet;

    if (IEIsLinkSafe(hwnd, pidlFavorite, ILS_ADDTOFAV))
    {
        fRet = DoAddToFavDlgEx(hwnd, pszInitDir, cchInitDir, pszFile, cchFile,
                               pidlBrowse, pidlFavorite, atfDlgType, pInfo);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}


// This API is exported so that it may be called by explorer and mshtml (and MSNVIEWR.EXE)
// in addition to being called internally by shdocvw.
// THEREFORE YOU MUST NOT CHANGE THE SIGNATURE OF THIS API
//

STDAPI_(BOOL) DoAddToFavDlg(HWND hwnd, 
                            CHAR *pszInitDir, UINT cchInitDir,
                            CHAR *pszFile, UINT cchFile, 
                            LPITEMIDLIST pidlBrowse)
{
    BOOL fRet;

    WCHAR szInitDir[MAX_PATH];
    WCHAR szFile[MAX_PATH];

    SHAnsiToUnicode(pszInitDir, szInitDir, ARRAYSIZE(szInitDir));
    SHAnsiToUnicode(pszFile, szFile, ARRAYSIZE(szFile));

    fRet = DoSafeAddToFavDlgEx(hwnd, szInitDir, ARRAYSIZE(szInitDir), szFile, ARRAYSIZE(szFile), pidlBrowse, NULL, ATF_FAVORITE, NULL);

    SHUnicodeToAnsi(szInitDir, pszInitDir, cchInitDir);
    SHUnicodeToAnsi(szFile, pszFile, cchFile);

    return fRet;
}


STDAPI_(BOOL) DoAddToFavDlgW(HWND hwnd, 
                             WCHAR *pszInitDir, UINT cchInitDir,
                             WCHAR *pszFile, UINT cchFile, 
                             LPITEMIDLIST pidlBrowse)
{
    return DoSafeAddToFavDlgEx(hwnd, pszInitDir, cchInitDir, pszFile, cchFile, pidlBrowse, NULL, ATF_FAVORITE, NULL);
}


STDAPI AddToFavoritesEx(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle, DWORD dwFlags,
                        SUBSCRIPTIONINFO *pInfo, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);
STDAPI AddToChannelsEx (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, LPCWSTR pwszURL,
                        DWORD dwFlags, SUBSCRIPTIONINFO* pInfo);
STDAPI SubscribeFromFavorites (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO *pInfo);


// This API is exported privately, and is called by ISubscriptionMgr::CreateSubscription.
// shuioc uses it too.

STDAPI SHAddSubscribeFavoriteEx (
        HWND hwnd, 
        LPCWSTR pwszURL, 
        LPCWSTR pwszName, 
        DWORD dwFlags,
        SUBSCRIPTIONTYPE subsType, 
        SUBSCRIPTIONINFO* pInfo, 
        IOleCommandTarget *pcmdt,
        IHTMLDocument2 *pDoc)
{
    TCHAR           szName[MAX_PATH];
    LPITEMIDLIST    pidl = NULL;
    HRESULT         hr;
    
    if (pwszURL==NULL || pwszName == NULL)
        return E_INVALIDARG;
    //
    // Need to put pwszName into a buffer because it comes in const
    // but gets modified in SubscribeFromFavorites.
    //
    StrCpyN(szName, pwszName, ARRAYSIZE(szName));

    hr = IECreateFromPath(pwszURL, &pidl);
    if (SUCCEEDED(hr))
    {
        ASSERT (pidl);

        if (dwFlags & CREATESUBS_FROMFAVORITES)
        {
            if (subsType != SUBSTYPE_URL && subsType != SUBSTYPE_CHANNEL)
            {
                ASSERT(0);
                hr = E_INVALIDARG;
            }
            else
            {
                hr = SubscribeFromFavorites (hwnd, pidl, szName, dwFlags, subsType, pInfo);
            }
        }
        else
        {
            if (subsType == SUBSTYPE_URL)
            {
                hr = AddToFavoritesEx (hwnd, pidl, szName, dwFlags, pInfo, pcmdt, pDoc);
            }
            else if (subsType == SUBSTYPE_CHANNEL && !SHIsRestricted2W(hwnd, REST_NoChannelUI, NULL, 0))
            {
                hr = AddToChannelsEx (hwnd, pidl, szName, pwszURL, dwFlags, pInfo);
            }
            else
            {
                ASSERT (0);
                hr = E_INVALIDARG;
            }
        }

        ILFree(pidl);
    }
    return hr;    
}

STDAPI SHAddSubscribeFavorite (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo)
{
    return SHAddSubscribeFavoriteEx ( hwnd, pwszURL, pwszName, dwFlags,
                                subsType, pInfo, NULL, NULL);
}

// this API is also exported via the .def
// Use for backward compatibility only -- note that it is only for URL's (not channels)
// and doesn't know how to subscribe.
STDAPI AddUrlToFavorites(HWND hwnd, LPWSTR pszUrlW, LPWSTR pszTitleW, BOOL fDisplayUI)
{
    return SHAddSubscribeFavorite (hwnd, pszUrlW, pszTitleW,
        fDisplayUI ? CREATESUBS_NOUI : 0, SUBSTYPE_URL, NULL);
}


// this API is in the .h and is used elsewhere in shdocvw, but is not exported
// Backward compatibility only -- only for URL's (not channels) and can subscribe, but can't
// pass in subscriptioninfo starter.
STDAPI AddToFavorites(
    HWND hwnd, 
    LPCITEMIDLIST pidlCur, 
    LPCTSTR pszTitle, 
    BOOL fDisplayUI, 
    IOleCommandTarget *pCommandTarget,
    IHTMLDocument2 *pDoc)
{
    return AddToFavoritesEx (hwnd, pidlCur, pszTitle,
        fDisplayUI ? 0 : CREATESUBS_NOUI, NULL, pCommandTarget, pDoc);
}


//helper function to create one column in a ListView control, add one item to that column,
//size the column to the width of the control, and color the control like a static...
//basically, like SetWindowText for a ListView.  Because we use a lot of ListViews to display
//urls that would otherwise be truncated... the ListView gives us automatic ellipsis and ToolTip.
void SetListViewToString (HWND hLV, LPCTSTR pszString)
{
    ASSERT(hLV);
    
    LV_COLUMN   lvc = {0};
    RECT lvRect;
    GetClientRect (hLV, &lvRect);
    lvc.mask = LVCF_WIDTH;
    lvc.cx = lvRect.right - lvRect.left;
    if (-1 == ListView_InsertColumn(hLV, 0, &lvc))   {
        ASSERT(0);
    }

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, LVS_EX_INFOTIP);

    LV_ITEM lvi = {0};
    lvi.iSubItem = 0;
    lvi.pszText = (LPTSTR)pszString;
    lvi.mask = LVIF_TEXT;
    ListView_InsertItem(hLV, &lvi);
    ListView_EnsureVisible(hLV, 0, TRUE);
    
    ListView_SetBkColor(hLV, GetSysColor(COLOR_BTNFACE));
    ListView_SetTextBkColor(hLV, GetSysColor(COLOR_BTNFACE));
}


INT_PTR CALLBACK SubscribeFavoriteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ADDTOFAV * patf = (ADDTOFAV*)GetProp(hDlg, ADDTOFAVPROP);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szURL[MAX_URL_STRING];

            patf = (ADDTOFAV*)lParam;
            SetProp(hDlg, ADDTOFAVPROP, (HANDLE)patf);

            //set up name and url displays
            SetDlgItemText (hDlg, IDC_CHANNEL_NAME, patf->pszFile);
            //url is in patf->pidlFavorite
            IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING);
            SetListViewToString (GetDlgItem (hDlg, IDC_CHANNEL_URL), szURL);

            //now the tricky part... this is for modifying the subscription associated with
            //an existing ChannelBar shortcut.  We need to find out if they are subscribed --
            //if so, load the existing subscription into memory so it can be modified in the
            //wizard.  If not, leave the information that was passed up because it's got the
            //schedule extracted from the CDF.  In either case, check the radio button that
            //corresponds to their current subscription level.
            ISubscriptionMgr* pSubsMgr;
            BOOL bSubs = FALSE;

            HRESULT hr = JITCoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                             IID_ISubscriptionMgr, (void**)&pSubsMgr, 
                                             hDlg, FIEF_FLAG_FORCE_JITUI | FIEF_FLAG_PEEK);

            if (SUCCEEDED(hr))
            {
                pSubsMgr->IsSubscribed(szURL, &bSubs);

                patf->bStartSubscribed = bSubs;

                pSubsMgr->Release();
            }
            else if ((E_ACCESSDENIED == hr) || !IsBrowserFrameOptionsPidlSet(patf->pidlFavorite, BFO_USE_IE_OFFLINE_SUPPORT))
            {
                EnableWindow(GetDlgItem(hDlg, IDC_MAKE_OFFLINE), FALSE);
            }

            if (!bSubs && patf->bIsSoftdist)
            {
                bSubs = TRUE;
            }

            CheckDlgButton(hDlg, IDC_MAKE_OFFLINE, bSubs ? 1 : 0);
            EnableWindow(GetDlgItem (hDlg, IDC_SUBSCRIBE_CUSTOMIZE), bSubs);
        }
        break;

    case WM_DESTROY:
        RemoveProp (hDlg, ADDTOFAVPROP);
        break;

    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) (patf->iDlgType == ATF_FAVORITE
                            ? aAddToFavHelpIDs : aAddToChanHelpIDs));
        return TRUE;
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) (patf->iDlgType == ATF_FAVORITE
                         ? aAddToFavHelpIDs : aAddToChanHelpIDs));
        return TRUE;
        break;

    case WM_COMMAND:
        ASSERT (patf);
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
            // first, make sure they're not trying to subscribe to an authenticated
            // channel without entering a password.
            if (SubscriptionFailsChannelAuthentication (hDlg, &patf->siSubsInProg))
                return FALSE;

            //find out whether they WERE subscribed, so if they click OK and they
            //were already subscribed, we delete that subscription -- and either leave it
            //deleted if "No subs" was the choice, or create the new one.
            ISubscriptionMgr* pSubsMgr;
            if (SUCCEEDED (JITCoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                            IID_ISubscriptionMgr, (void**)&pSubsMgr, 
                                            hDlg, FIEF_FLAG_FORCE_JITUI)))
            {
                //url is in patf->pidlFavorite
                TCHAR szURL[MAX_URL_STRING];
                IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING);

                BOOL bAlreadySubs;
                if (SUCCEEDED (pSubsMgr->IsSubscribed (szURL, &bAlreadySubs)) && bAlreadySubs)
                {
                    pSubsMgr->DeleteSubscription(szURL, NULL);
                }

                pSubsMgr->Release();
            }

            if (IsDlgButtonChecked (hDlg, IDC_MAKE_OFFLINE))
            {
               //they want to subscribe!  save subscription we already have in memory
                patf->bSubscribed = StartSiteSubscription (hDlg, patf, TRUE);
            }
            EndDialog(hDlg, IDOK);
            break;

        // common code with ATF dialog

        case IDC_SUBSCRIBE_CUSTOMIZE:
            //need to create -- but not store -- subscription
            //need to (temporarily) trash patf->pidlFavorite so that we can go through the
            //wizard without colliding with an existing subscription.  When we actually create
            //the subscription, we'll use the real name.
            LPCITEMIDLIST pidlSave = patf->pidlFavorite;
            TCHAR szUrlTemp[MAX_URL_STRING+1];
            IEGetDisplayName(patf->pidlFavorite, szUrlTemp, SHGDN_FORPARSING);
            StrCat (szUrlTemp, TEXT("."));   //just put something nearly invisible on the end
            if (SUCCEEDED (IECreateFromPath(szUrlTemp, (LPITEMIDLIST*)&patf->pidlFavorite)))
            {
                if (StartSiteSubscription (hDlg, patf, FALSE))
                    SendMessage (hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
                ILFree ((LPITEMIDLIST)patf->pidlFavorite);
            }
            patf->pidlFavorite = pidlSave;
            break;
        }
        break;
    }

    return FALSE;
}


static const int CREATESUBS_ACTIVATE = 0x8000;      //hidden flag meaning channel is already on system

STDAPI SubscribeFromFavorites (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO *pInfo)
{
    //used to subscribe to a channel that's already in the Favorites
    //or a URL that's already a Favorite

    //flags are same as ISubscriptionMgr::CreateSubscription

    //display our part of the fav's dialog -- no need to go through SHBrowseForFolder
    //or any of that, just our radio buttons in a fixed-size dialog with our own DlgProc

    INT_PTR iDlgResult;
    HRESULT hr = S_OK;
    ADDTOFAV atf = {0};
    atf.pszFile = pszName;
    atf.siSubsInProg.cbSize = sizeof(SUBSCRIPTIONINFO);
    if (pInfo && pInfo->cbSize == sizeof(SUBSCRIPTIONINFO))
        atf.siSubsInProg = *pInfo;

    atf.subsType = subsType;

    //figure out what dialog to use
    atf.iDlgType = (subsType == SUBSTYPE_URL ? ATF_FAVORITE :
        (dwFlags & CREATESUBS_ACTIVATE ? ATF_CHANNEL_MODIFY : ATF_CHANNEL));
    // Do we potentially need ANOTHER dialog type for softdist channels?

    if (dwFlags & CREATESUBS_SOFTWAREUPDATE)
    {
        atf.bIsSoftdist = TRUE;
    }

    atf.pidlFavorite = pidlUrl;

#ifdef OLD_FAVORITES
    int iTemplate;
    switch (atf.iDlgType)
    {
    case ATF_CHANNEL_SOFTDIST: // Inappropriate, but it doesn't currently get used
    case ATF_CHANNEL:
        iTemplate = IDD_SUBSCRIBE_FAV_CHANNEL;
        break;
    case ATF_CHANNEL_MODIFY:
        iTemplate = IDD_ACTIVATE_PLATINUM_CHANNEL;
        break;
    case ATF_FAVORITE:
        iTemplate = IDD_SUBSCRIBE_FAVORITE;
        break;
    }

    iDlgResult = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(iTemplate), hwnd,
            SubscribeFavoriteDlgProc, (LPARAM)&atf);

#endif

    iDlgResult = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ADDTOFAVORITES_TEMPLATE), hwnd,
            SubscribeFavoriteDlgProc, (LPARAM)&atf);


    switch (iDlgResult)
    {
    case -1:
        hr = E_FAIL;
        break;
    case IDCANCEL:
        hr = S_FALSE;
        break;
    default:
        if (pInfo && (pInfo->cbSize == sizeof(SUBSCRIPTIONINFO))
                  && (dwFlags & CREATESUBS_NOSAVE))
            *pInfo = atf.siSubsInProg;
        hr = S_OK;
        break;
    }

    return hr;
}


STDAPI AddToChannelsEx (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, LPCWSTR pwszURL,
                        DWORD dwFlags, SUBSCRIPTIONINFO* pInfo)
{
    HRESULT hr = S_OK;
    IChannelMgrPriv* pIChannelMgrPriv;

    hr = JITCoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)&pIChannelMgrPriv, 
                          hwnd, FIEF_FLAG_FORCE_JITUI);

    if (SUCCEEDED(hr))
    {
        if (S_OK == pIChannelMgrPriv->IsChannelInstalled (pwszURL))
        {
            hr = SubscribeFromFavorites (hwnd, pidlUrl, pszName, dwFlags | CREATESUBS_ACTIVATE,
                SUBSTYPE_CHANNEL, pInfo);
        }
        else
        {
            LPITEMIDLIST pidlChannelFolder;
            TCHAR szPath[MAX_PATH];
            TCHAR szCFPath[MAX_PATH];

            ASSERT(pIChannelMgrPriv);

            IChannelMgrPriv::CHANNELFOLDERLOCATION cflLocation =
                ((dwFlags & CREATESUBS_SOFTWAREUPDATE) ?
                    IChannelMgrPriv::CF_SOFTWAREUPDATE :
                    IChannelMgrPriv::CF_CHANNEL);

            hr = pIChannelMgrPriv->GetChannelFolder(&pidlChannelFolder, cflLocation);
            if (SUCCEEDED (hr))
            {
                //
                // Change IChannelMgrPriv to unicode!  This has to get fixed to
                // support a unicode "Channels" name. (edwardp)
                //

                CHAR szBuff[MAX_PATH];

                hr = pIChannelMgrPriv->GetChannelFolderPath (szBuff, ARRAYSIZE(szBuff), cflLocation);

                if (SUCCEEDED(hr))
                    SHAnsiToUnicode(szBuff, szCFPath, ARRAYSIZE(szCFPath));
                

                if (SUCCEEDED (hr))
                {
                    TCHAR szDspName[MAX_URL_STRING];
                    DWORD cchDspName = ARRAYSIZE(szDspName);

                    StrCpyN(szPath, szCFPath, ARRAYSIZE(szPath));
            
                    // When we create a short cut for the URL, we have to make sure it's readable for
                    // the end user. PrepareURLForDisplay() will unescape the string if it's escaped.
                    if (!UrlIs(pszName, URLIS_URL) ||
                        !PrepareURLForDisplay(pszName, szDspName, &cchDspName))
                    {
                        // Unescaping wasn't wanted or didn't work.
                        StrCpyN(szDspName, pszName, ARRAYSIZE(szDspName));
                    }
                         
                    PathCleanupSpec(szPath, szDspName);

                    FAVDLGTYPE iDlgType = (dwFlags & CREATESUBS_SOFTWAREUPDATE ? ATF_CHANNEL_SOFTDIST : ATF_CHANNEL);

                    if ((dwFlags & CREATESUBS_NOUI) || 
                        DoSafeAddToFavDlgEx(hwnd, szPath, ARRAYSIZE(szPath), 
                                        szDspName, ARRAYSIZE(szDspName), pidlChannelFolder,
                                        pidlUrl, iDlgType, pInfo))
                    {
                        //we create the channelbar entry here, instead of cdfview, because here
                        //we know where in the channels folder the user wants it to go.
                        IChannelMgr* pChannelMgr = NULL;
                        hr = pIChannelMgrPriv->QueryInterface (IID_IChannelMgr, (void**)&pChannelMgr);
                        if (SUCCEEDED (hr))
                        {
                            //prepare strings
                            PathRemoveExtension(szPath);

                            //strip off absolute part of folder path, and convert to Unicode
                            int cchCommon = PathCommonPrefix (szPath, szCFPath, NULL);

                            //pack in the info we have
                            CHANNELSHORTCUTINFO csiChannel = {0};
                            csiChannel.cbSize = sizeof(csiChannel);
                            csiChannel.pszTitle = szPath + cchCommon;
                            csiChannel.pszURL = (LPWSTR)pwszURL;
                            csiChannel.bIsSoftware = (dwFlags & CREATESUBS_SOFTWAREUPDATE) ? TRUE : FALSE;
                            //and tell the channel mgr to add the channel
                            hr = pChannelMgr->AddChannelShortcut (&csiChannel);
                            pChannelMgr->Release();
                        }
                    }
                    else
                    {
                        hr = S_FALSE;       //no failure, but no add
                    }
                }

                ILFree (pidlChannelFolder);
            }
        }
        pIChannelMgrPriv->Release();
    }

    return hr;
}


STDAPI AddToFavoritesEx(
    HWND hwnd, 
    LPCITEMIDLIST pidlCur, 
    LPCTSTR pszTitle,
    DWORD dwFlags, 
    SUBSCRIPTIONINFO *pInfo, 
    IOleCommandTarget *pCommandTarget,
    IHTMLDocument2 *pDoc)
{
    HRESULT hres = S_FALSE;
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (pidlCur)
    {
        TCHAR szName[MAX_URL_STRING];
        TCHAR szPath[MAX_PATH];
        if (pszTitle)
        {
            StrCpyN(szName, pszTitle, ARRAYSIZE(szName));
        }
        else
        {
            szName[0] = 0;

            IEGetNameAndFlags(pidlCur, SHGDN_INFOLDER | SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
        }

        LPITEMIDLIST pidlFavorites;

        if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE) &&
            (pidlFavorites = SHCloneSpecialIDList(NULL, CSIDL_FAVORITES, TRUE)))
        {
            TCHAR szDspName[MAX_PATH];
            DWORD cchDspName = ARRAYSIZE(szDspName);
            
            // When we create a short cut for the URL, we have to make sure it's readable for
            // the end user. PrepareURLForDisplay() will unescape the string if it's escaped.
            if (!UrlIs(szName, URLIS_URL) ||
                !PrepareURLForDisplay(szName, szDspName, &cchDspName))
            {
                // Unescaping wasn't wanted or didn't work.
                StrCpyN(szDspName, szName, ARRAYSIZE(szDspName));
            }

            PathCleanupSpec(szPath, szDspName);

            // if left with spaces only, use the filename friendly version of the url instead.
            StrTrim(szDspName, L" ");
            if (szDspName[0] == 0)
            {
                if (SUCCEEDED(IEGetNameAndFlags(pidlCur, SHGDN_FORPARSING, szDspName, ARRAYSIZE(szDspName), NULL)))
                    PathCleanupSpec(szPath, szDspName);
            }

            BOOL fDisplayUI = (dwFlags & CREATESUBS_NOUI) ? FALSE : TRUE;
            if (!fDisplayUI || 
                DoSafeAddToFavDlgEx(hwnd, szPath, ARRAYSIZE(szPath), 
                                    szDspName, ARRAYSIZE(szDspName), pidlFavorites,
                                    pidlCur, ATF_FAVORITE, NULL))
            {
                if (fDisplayUI)
                    PathRemoveFileSpec(szPath);
                    
                ISHCUT_PARAMS ShCutParams = {0};
                
                PathRemoveExtension(szDspName);
                
                ShCutParams.pidlTarget = pidlCur;
                ShCutParams.pszTitle = PathFindFileName(szDspName); 
                ShCutParams.pszDir = szPath; 
                ShCutParams.pszOut = NULL;
                ShCutParams.bUpdateProperties = FALSE;
                ShCutParams.bUniqueName = FALSE;
                ShCutParams.bUpdateIcon = TRUE;
                ShCutParams.pCommand = pCommandTarget;
                ShCutParams.pDoc = pDoc;
                hres = CreateShortcutInDirEx(&ShCutParams);
                if (fDisplayUI && FAILED(hres)) 
                {
                    IE_ErrorMsgBox(NULL, hwnd, GetLastError(), NULL, szDspName, IDS_FAV_UNABLETOCREATE, MB_OK| MB_ICONSTOP);
                }
            }
            else
            {
                hres = S_FALSE;
            }
            ILFree(pidlFavorites);
        }
    }

    SetCursor(hCursorOld);
    
    return hres;
}


BOOL IsSubscribed(ADDTOFAV *patf)
{
    BOOL bSubscribed = FALSE;

    TCHAR szURL[MAX_URL_STRING];
    if (SUCCEEDED(IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING)))
    {
        ISubscriptionMgr *pSubscriptionMgr;
        if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_ISubscriptionMgr,
                                       (void**)&pSubscriptionMgr)))
        {
            BSTR bstrURL = SysAllocStringT(szURL);
            if (bstrURL)
            {
                if (SUCCEEDED(pSubscriptionMgr->IsSubscribed(bstrURL, &bSubscribed)) &&
                    bSubscribed)
                {
                    patf->siSubsInProg.fUpdateFlags = SUBSINFO_ALLFLAGS;
                    pSubscriptionMgr->GetSubscriptionInfo(bstrURL, &patf->siSubsInProg);
                }
                SysFreeString(bstrURL);
            }
            pSubscriptionMgr->Release();
        }
    }

    return bSubscribed;
}

BOOL IsSubscribed(LPCITEMIDLIST pidl)
{
    BOOL bSubscribed = FALSE;

    TCHAR szURL[MAX_URL_STRING];
    if (FAILED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szURL, SIZEOF(szURL), NULL)))
        return FALSE;

    bSubscribed = IsSubscribed(szURL);    

    return bSubscribed;
}

BOOL IsSubscribed(LPWSTR pwzUrl)
{
#ifndef DISABLE_SUBSCRIPTIONS

    BOOL bSubscribed = FALSE;

    ISubscriptionMgr * pSubscriptionMgr;
    if (FAILED(CoCreateInstance(CLSID_SubscriptionMgr,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_ISubscriptionMgr,
                                (void**)&pSubscriptionMgr)))
    {
        return FALSE;
    }

    pSubscriptionMgr->IsSubscribed(pwzUrl, &bSubscribed);
    pSubscriptionMgr->Release();

    return bSubscribed;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return FALSE;

#endif /* !DISABLE_SUBSCRIPTIONS */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\history.cpp ===
#include "priv.h"
#include "dochost.h"
#include "resource.h"
#include "urlprop.h"
#include "ishcut.h"
#include "shlguid.h"
#include "mlang.h"

#include <mluisupp.h>

#define DM_HISTORY 0

HRESULT PersistShortcut(IUniformResourceLocator * purl, LPCWSTR pwszFile)
{
    IPersistFile *ppf;
    HRESULT hres = purl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hres))
    {
        hres = ppf->Save(pwszFile, TRUE);

        if (SUCCEEDED(hres))
            ppf->SaveCompleted(pwszFile);   // return value always S_OK

        ppf->Release();
    }

    return hres;
}


/*************************************************************\
    FUNCTION: GenerateUnknownShortcutName

    PARAMETERS:
        pwzSourceFilename - TCHAR Source Path and Filename that cannot be created.
                      This value will be changed to a valid path\filename
        pwzDestFilename - After pwzSourceFilename is converted to a valid filename,
                      the valid path will be returned here in a UNICODE string.
        dwSize - Size of the pwzDestFilename buffer in chars.

    DESCRIPTION:
      This function will replace the filename at the end of 
    the path in pwzFilename with "Untitled.url".  If that file
    exists, it will try, "Untitled1.url" and so on until it can
    be unique.

    WARNING:
       This function will only allow the incoming value be in ANSI
    because these helper functions (like PathRemoveFileSpecW) won't
    work on Win95 when compiled in UNICODE.  (CharNextW isn't supported
    on Win95)
\*************************************************************/


#define MAX_GEN_TRIES    100
#define GEN_EXTION_LEN   (7 * sizeof(TCHAR))    // size == L"000.url" in chars

BOOL GenerateUnknownShortcutName(
                     IN  LPCTSTR  pszSourceFilename,    
                     IN  LPWSTR  pwzDestFilename, 
                     IN  DWORD   dwSize)
{
    TCHAR       szTempFilename[MAX_PATH];
    TCHAR       szUntitledStr[MAX_PATH];
    LONG        lTry    = 1;

    if (MLLoadString(IDS_UNTITLE_SHORTCUT, szUntitledStr, ARRAYSIZE(szUntitledStr)))
    {
        StrCpyN(szTempFilename, pszSourceFilename, ARRAYSIZE(szTempFilename));
        PathRemoveFileSpec(szTempFilename);   // "Path"
        PathAddBackslash(szTempFilename);     // "Path\"

        // Make sure the string is large enough (including terminator).  (Counting chars, not bytes)
        if (dwSize > (DWORD)(lstrlen(szTempFilename) + lstrlen(szUntitledStr) + GEN_EXTION_LEN))  
        {
            PathCombine(szUntitledStr, szTempFilename, szUntitledStr);    // "Path\untitled"
            wnsprintf(szTempFilename, ARRAYSIZE(szTempFilename), TEXT("%s.url"), szUntitledStr);           // "Path\untitled.url"

            // Make a reasonable number of tries (MAX_GEN_TRIES) to find a unique
            // filename.  "path\Untitled.url", "path\Untitled1.url", ...
            while ((PathFileExists(szTempFilename)) && (lTry < MAX_GEN_TRIES))
                wnsprintf(szTempFilename, ARRAYSIZE(szTempFilename), TEXT("%s%ld.url"), szUntitledStr, lTry++);
        
            if (!PathFileExists(szTempFilename))
            {
                if (SHTCharToUnicode(szTempFilename, pwzDestFilename, dwSize) > 0)
                    return(TRUE);
            }
        }
    }
    return(FALSE);
}

//
// If no directory is specified then it is simply made into a path name without any dir attached
// 
STDAPI_(BOOL) GetShortcutFileName(LPCTSTR pszTarget, LPCTSTR pszTitle, LPCTSTR pszDir, LPTSTR pszOut, int cchOut)
{
    TCHAR szFullName[MAX_PATH];
    BOOL fAddDotUrl = TRUE;
    UINT cchMax;

    static const TCHAR c_szDotURL[] = TEXT(".url");

    TraceMsg(DM_HISTORY, "GetShortcutFileName pszDir          = %s", pszDir);

     // Check if the title has some characters that just cannot be 
     // displayed 
    if(IsOS(OS_WIN95ORGREATER) || (IsOS(OS_NT) && !IsOS(OS_WIN2000ORGREATER)))
    {
        IMultiLanguage2 *pMultiLanguage  = NULL;
        if (pszTitle &&
            S_OK == CoCreateInstance(
                    CLSID_CMultiLanguage,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMultiLanguage2,
                    (void**)&pMultiLanguage))
        {
            ASSERT(pMultiLanguage);
            DWORD dwMode = 0;
            UINT  uSrcSize = lstrlenW(pszTitle);
            UINT  uDestSize;
            if (S_OK != pMultiLanguage->ConvertStringFromUnicodeEx(&dwMode, GetACP(), (LPTSTR)pszTitle, &uSrcSize, 
                                            NULL, &uDestSize, MLCONVCHARF_NOBESTFITCHARS, NULL))

            {
                pszTitle = NULL; // Don't Use the title
            }

            pMultiLanguage->Release();    
        }
    }

    cchMax = ARRAYSIZE(szFullName) - lstrlen(c_szDotURL);

    if (pszTitle && pszTitle[0])
        StrCpyN(szFullName, pszTitle, cchMax);
    else if (pszTarget && pszTarget[0])
    {
        UINT cchLen;
        StrCpyN(szFullName, PathFindFileName(pszTarget), cchMax);
        cchLen = lstrlen(szFullName);
        if(szFullName[cchLen -1] == TEXT('/')) // Catch the common case of ftp://foo/
            szFullName[cchLen -1] = TEXT('\0');   
        PathRemoveExtension(szFullName);
    }
    else
    {
        fAddDotUrl = FALSE;
        MLLoadString(IDS_NEW_INTSHCUT, szFullName, SIZECHARS(szFullName));
    }

    // We need at least this many characters for the directory + extension + " (nn)" + the null terminator

    // If there are multiple shortcuts with the same beginning, we'll append " (nn)", where
    // nn represents a two-digit maxiumum
    DWORD cc = (DWORD)(lstrlen(pszDir) + (fAddDotUrl ? ARRAYSIZE(c_szDotURL) : 1) + 5);
    // We want to allow for at least a one letter filename
    if ((cc + 1) > ARRAYSIZE(szFullName))
    {
        return FALSE;
    }
    szFullName[ARRAYSIZE(szFullName)-cc] = TEXT('\0');
    
    if(fAddDotUrl)
        StrCatBuff(szFullName, c_szDotURL, ARRAYSIZE(szFullName));

    if(pszDir)
    {
        if (PathCleanupSpec(pszDir, szFullName) & PCS_FATAL)
        {
            return FALSE;
        }
        PathCombine(pszOut, pszDir, szFullName);
    }
    else
    {
        StrCpyN(pszOut, szFullName, cchOut);
    }
    
    TraceMsg(DM_HISTORY, "GetShortcutFileName pszOut      = %s", pszOut);
    
    return TRUE;
}

// Unfortunately we do not already have something like this around
// If you find duplicate, please nuke this (dli)
// Warning: This function does not consider all possible URL cases.  
BOOL _GetPrettyURLName(LPCTSTR pcszURL, LPCTSTR pcszDir, LPTSTR pszUrlFile, int cchUrlFile)
{
    BOOL bRet = FALSE;
    PARSEDURL pu = {0};
    pu.cbSize = SIZEOF(PARSEDURL);
    
    if (SUCCEEDED(ParseURL(pcszURL, &pu)))
    {
        LPCTSTR pszPrettyName = pu.pszSuffix;
        
        // Get rid of the forward '/' 
        while (*pszPrettyName && *pszPrettyName == TEXT('/'))
            pszPrettyName++;
        
        if (!StrCmpN(pszPrettyName, TEXT("www."), 4))
            pszPrettyName += 4;
        
        if (*pszPrettyName)
            bRet = GetShortcutFileName(pcszURL, pszPrettyName, pcszDir, pszUrlFile, cchUrlFile);
    }
    return bRet;
}
/*
 * pcszURL -> "ftp://ftp.microsoft.com"
 * pcszPath -> "c:\windows\desktop\internet\Microsoft FTP.url"
 */
HRESULT 
CreateNewURLShortcut(
                     IN  LPCTSTR pcszURL, 
                     IN  LPCITEMIDLIST pidlURL, 
                     IN  LPCTSTR pcszURLFile,
                     IN  LPCTSTR pcszDir,
                     OUT LPTSTR  pszOut,
                     IN  int     cchOut,
                     IN  BOOL    bUpdateProperties,
                     IN  BOOL    bUpdateIcon,
                     IN  IOleCommandTarget *pCommandTarget)
{
    HRESULT hr;

    WCHAR wszFile[MAX_URL_STRING];

    if (SHTCharToUnicode(pcszURLFile, wszFile, ARRAYSIZE(wszFile)))
    {
        IUniformResourceLocator *purl;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IUniformResourceLocator, &purl));

        if (SUCCEEDED(hr))
        {
            if (pidlURL)
            {
                // if we're given a pidl, try to set pidl first.
                
                IShellLink *psl;
                hr = purl->QueryInterface(IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    hr = psl->SetIDList(pidlURL);
                    psl->Release();
                }
            }
            
            if (!pidlURL || FAILED(hr))
                hr = purl->SetURL(pcszURL, 0);

            if (S_OK == hr)
                IUnknown_SetSite(purl, pCommandTarget);
                
            if (SUCCEEDED(hr))
            {
                // Persist the internet shortcut
                hr = PersistShortcut(purl, wszFile);

                // If the previous call fails, try again with a new Filename.
                // This is needed because the other filename could have been invalid,
                // which will happen if the web page's title was stored in DBCS with
                // a non-English code page.
    
                // (dli) First try a file name related to the URL, then the default untitled
                if (FAILED(hr))
                {
                    TCHAR tszFile[MAX_PATH];
                    BOOL bURLname = _GetPrettyURLName(pcszURL, pcszDir, tszFile, ARRAYSIZE(tszFile));
                    if ((bURLname && SHTCharToUnicode(tszFile, wszFile, ARRAYSIZE(wszFile)) > 0) ||
                        (!bURLname && GenerateUnknownShortcutName(pcszURLFile, wszFile, ARRAYSIZE(wszFile))))
                    {
                        hr = PersistShortcut(purl, wszFile);
                    }

                }

                if (SUCCEEDED(hr))
                {
                    TCHAR   szFile[MAX_PATH];
                    VARIANT varIn = {0};

                    if (bUpdateIcon)
                    {
                        HRESULT hrTemp = IUnknown_Exec(purl, &CGID_ShortCut, ISHCUTCMDID_DOWNLOADICON, 0, NULL, NULL);
                        ASSERT(SUCCEEDED(hrTemp));
                    }

                    varIn.vt = VT_UNKNOWN;
                    varIn.punkVal = purl;
                
                    SHUnicodeToTChar(wszFile, szFile,  ARRAYSIZE(szFile));
#ifndef UNIX
                    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szFile, NULL);
#else
                    // IEUNIX : Synchronous notifications for unix.
                    SHChangeNotify(SHCNE_CREATE, ( SHCNF_PATH | SHCNF_FLUSH ), szFile, NULL);
#endif
                    if (pszOut) 
                    {
                        StrCpyN(pszOut, wszFile, cchOut);
                    }
                }
            }
            purl->Release();
        }
    }
    else
        hr = E_FAIL;

    return(hr);
}


BOOL ILCanCreateLNK(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

    // Should call IsBrowserFrameOptionsPidlSet(BIF_PREFER_INTERNET_SHORTCUT) instead.  Some URL delegate
    //         NSEs (FTP for one) may want .lnks instead of .url files.
    //         This would be great for CDocObjFolder to not set this bit so
    //         for .doc files so they will use the .lnk versions.
    if (!pidl || IsURLChild(pidl, TRUE))
        return FALSE;

    hr = IEGetAttributesOf(pidl, &dwAttributes);
    return (SUCCEEDED(hr) && 
         (IsFlagSet(dwAttributes, SFGAO_FOLDER) ||
          IsFlagSet(dwAttributes, SFGAO_FILESYSANCESTOR) )
        );
}


// This API makes a callback via the IN parameter
// pCommand to inform that shortcut creation is over.
// The callback it currently sends back are : 
// 


STDAPI
CreateShortcutInDirEx(ISHCUT_PARAMS *pParams)
{
    LPCITEMIDLIST pidlTarget = pParams->pidlTarget;
    TCHAR szFileName[MAX_PATH];
    TCHAR szTarget[MAX_URL_STRING];
    HRESULT hres;
    BOOL bIsURL = IsURLChild(pidlTarget, TRUE);

    if (!ILCanCreateLNK(pidlTarget) &&
        SUCCEEDED(IEGetDisplayName(pidlTarget, szTarget, SHGDN_FORPARSING)) &&
        _ValidateURL(szTarget, UQF_DEFAULT))
    {
        BOOL bUsePidl;
     
        SHCleanupUrlForDisplay(szTarget);
           
        // Note that _ValidateURL() calls IURLQualify() which adds "file://"
        // prefix to szTarget as appropriate.
        
        if (bIsURL ||
            (GetUrlScheme(szTarget) == URL_SCHEME_FILE))
        {
            bUsePidl = FALSE;
        }
        else
        {
            // use pidl if it's not URL or file: compatible.
            bUsePidl = TRUE;
        }
        
        GetShortcutFileName(szTarget, pParams->pszTitle, pParams->pszDir, szFileName, ARRAYSIZE(szFileName));
        if(pParams->bUniqueName)
            PathYetAnotherMakeUniqueName(szFileName, szFileName, NULL, NULL);
        hres = CreateNewURLShortcut(szTarget, bUsePidl ? pidlTarget : NULL, szFileName, pParams->pszDir, 
                                    pParams->pszOut, pParams->cchOut, pParams->bUpdateProperties,
                                    pParams->bUpdateIcon, pParams->pCommand);

        
    } else {
        hres = CreateLinkToPidl(pidlTarget, pParams->pszDir, pParams->pszTitle, pParams->pszOut, pParams->cchOut);
    }

    return hres;
}


// pidlTarget ... the thing the shortcut is going to point to
// pszDir .. the directory that should hold the shortcut

// WARNING:  if you change any parameters for this function, you 
//           need to fix up explorer.exe
STDAPI CreateShortcutInDirA(
                     IN  LPCITEMIDLIST pidlTarget, 
                     IN  LPSTR   pszTitle, 
                     IN  LPCSTR  pszDir, 
                     OUT LPSTR   pszOut,
                     IN  BOOL    bUpdateProperties)
{
    HRESULT hres = E_FAIL;
    TCHAR szTitle[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szOut[MAX_URL_STRING];
    ISHCUT_PARAMS ShCutParams = {0};
    SHAnsiToTChar(pszTitle, szTitle, ARRAYSIZE(szTitle));
    SHAnsiToTChar(pszDir, szDir, ARRAYSIZE(szDir));

    ShCutParams.pidlTarget = pidlTarget;
    ShCutParams.pszTitle = szTitle; 
    ShCutParams.pszDir = szDir; 
    ShCutParams.pszOut = (pszOut ? szOut : NULL);
    ShCutParams.cchOut = (int)((pszOut ? ARRAYSIZE(szOut) : 0));
    ShCutParams.bUpdateProperties = bUpdateProperties;
    ShCutParams.bUniqueName = FALSE;
    ShCutParams.bUpdateIcon = FALSE;
    ShCutParams.pCommand = NULL;
    ShCutParams.pDoc = NULL;
    
    hres = CreateShortcutInDirEx(&ShCutParams);

    if (pszOut && SUCCEEDED(hres))
        SHTCharToAnsi(szOut, pszOut, MAX_URL_STRING);

    return hres;
}


STDAPI CreateShortcutInDirW(
                     IN  LPCITEMIDLIST pidlTarget, 
                     IN  LPWSTR  pwszTitle, 
                     IN  LPCWSTR pwszDir, 
                     OUT LPWSTR  pwszOut,
                     IN  BOOL    bUpdateProperties)
{
    HRESULT hres = E_FAIL;
    TCHAR szTitle[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szOut[MAX_URL_STRING];
    ISHCUT_PARAMS ShCutParams = {0};
    
    SHUnicodeToTChar(pwszTitle, szTitle, ARRAYSIZE(szTitle));
    SHUnicodeToTChar(pwszDir, szDir, ARRAYSIZE(szDir));

    ShCutParams.pidlTarget = pidlTarget;
    ShCutParams.pszTitle = szTitle; 
    ShCutParams.pszDir = szDir; 
    ShCutParams.pszOut = (pwszOut ? szOut : NULL);
    ShCutParams.cchOut = (int)((pwszOut ? ARRAYSIZE(szOut) : 0));
    ShCutParams.bUpdateProperties = bUpdateProperties;
    ShCutParams.bUniqueName = FALSE;
    ShCutParams.bUpdateIcon = FALSE;
    ShCutParams.pCommand = NULL;
    ShCutParams.pDoc = NULL;
    hres = CreateShortcutInDirEx(&ShCutParams);

    if (pwszOut && SUCCEEDED(hres))
        SHTCharToUnicode(szOut, pwszOut, MAX_URL_STRING);

    return hres;
}


//////////////////////////////
//
// Adds the given URL to the history storage
//
//   pwzTitle may be NULL if no title exists
//   
//   Note this function may be called multiple times in a single
//   page-visit.  bUpdateProperties is TRUE only once during 
//   those sequence of calls.
//
HRESULT 
AddUrlToUrlHistoryStg(
    IN LPCWSTR   pwszUrl, 
    IN LPCWSTR   pwszTitle, 
    IN LPUNKNOWN punk,
    IN BOOL fWriteHistory,
    IN IOleCommandTarget *poctNotify,
    IN IUnknown *punkSFHistory,
    OUT UINT* pcodepage)
{
    TraceMsg(DM_HISTORY, "AddUrlToUrlHistoryStg() entered url = %s, title = %s, punk = %X, fwrite = %d, poct = %X, punkHist = %X, cp = %d",
        pwszUrl, pwszTitle, punk,fWriteHistory,poctNotify,punkSFHistory,pcodepage);


    IUrlHistoryPriv *pUrlHistStg;
    HRESULT hr;
    
    if (!pwszUrl)
        return E_POINTER;

    if (punk == NULL)
    {
        
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, 
            IID_IUrlHistoryPriv, (void **)&pUrlHistStg);
    }
    else
    {       
        
        // query the pointer for IServiceProvider so we can get the IUrlHistoryStg
        hr = IUnknown_QueryService(punk,SID_SUrlHistory, IID_IUrlHistoryPriv, (LPVOID *)&pUrlHistStg);
    }
    
    if (SUCCEEDED(hr))
    {
        //
        // This demostrate the mechanism to get the codepage for URL.
        //
        hr = pUrlHistStg->AddUrlAndNotifyCP(pwszUrl, 
                                 pwszTitle, 
                                 0, 
                                 fWriteHistory, 
                                 poctNotify,
                                 punkSFHistory,
                                 pcodepage);
        pUrlHistStg->Release();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\fldset.cpp ===
#include "priv.h"

#include "fldset.h"

#define IShellView_CreateViewWindow(_pi, _piPrev, _pfs, _psb, _prc, _phw) \
    (_pi)->CreateViewWindow(_piPrev, _pfs, _psb, _prc, _phw)

#define IShellView2_GetView(_pi, _pv, _flg) \
    (_pi)->GetView(_pv, _flg)
#define IShellView2_CreateViewWindow2(_pi, _cParams) \
    (_pi)->CreateViewWindow2(_cParams)

#define IUnknown_QueryInterface(_pu, _riid, _pi) \
        (_pu)->QueryInterface(_riid, (LPVOID*)_pi)
#define IUnknown_AddRef(_pu)    (_pu)->AddRef()
#define IUnknown_Release(_pu)   (_pu)->Release()

typedef struct CViewSet
{
    HDSA _dsaViews;
} CViewSet;


CViewSet* CViewSet_New()
{
    CViewSet* pThis = (CViewSet*)LocalAlloc(LPTR, SIZEOF(CViewSet));
    if (!pThis)
    {
        return(NULL);
    }

    pThis->_dsaViews = DSA_Create(SIZEOF(SHELLVIEWID), 8);
    if (!pThis->_dsaViews)
    {
        LocalFree(pThis);
        pThis = NULL;
    }

    return(pThis);
}


int CViewSet_Add(CViewSet* that, SHELLVIEWID const* pvid)
{
    return(DSA_AppendItem(that->_dsaViews, (LPVOID)pvid));
}


void CViewSet_Delete(CViewSet* that)
{
    DSA_Destroy(that->_dsaViews);
    that->_dsaViews = NULL;
    LocalFree((HLOCAL)that);
    that = NULL;
}


void CViewSet_GetDefaultView(CViewSet* that, SHELLVIEWID* pvid)
{
    DSA_GetItem(that->_dsaViews, 0, (LPVOID)pvid);
}


void CViewSet_SetDefaultView(CViewSet* that, SHELLVIEWID const* pvid)
{
    DSA_SetItem(that->_dsaViews, 0, (LPVOID)pvid);
}


// PERF: A linear search for the view
BOOL CViewSet_IsViewSupported(CViewSet* that, SHELLVIEWID const* pvid)
{
    int i;

    // Only go down to 1 since item 0 is the default view
    for (i=DSA_GetItemCount(that->_dsaViews)-1; i>=1; --i)
    {
        if (0 == memcmp(pvid, DSA_GetItemPtr(that->_dsaViews, i),
            SIZEOF(SHELLVIEWID)))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


// PERF: a linear check
BOOL CViewSet_IsSame(CViewSet* that, CViewSet* pThatView)
{
    int iView = DSA_GetItemCount(pThatView->_dsaViews);

    if (DSA_GetItemCount(that->_dsaViews) != iView)
    {
        return(FALSE);
    }

    for (--iView; iView>=1; --iView)
    {
        if (!CViewSet_IsViewSupported(that,
            (SHELLVIEWID const*)DSA_GetItemPtr(pThatView->_dsaViews, iView)))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL CShellViews_Init(CShellViews* that)
{
    if (that->_dpaViews)
    {
        return(TRUE);
    }

    {
        HDPA dpaViews = DPA_Create(4);
        if (!dpaViews)
        {
            return(FALSE);
        }

        {
            CViewSet* pCommViews = CViewSet_New();
            if (!pCommViews)
            {
                DPA_Destroy(dpaViews);
                dpaViews = NULL;
                return(FALSE);
            }

            // The first one is the last known view for that set
            CViewSet_Add(pCommViews, &VID_LargeIcons);
            CViewSet_Add(pCommViews, &VID_LargeIcons);
            CViewSet_Add(pCommViews, &VID_SmallIcons);
            CViewSet_Add(pCommViews, &VID_Thumbnails);
            CViewSet_Add(pCommViews, &VID_List      );
            CViewSet_Add(pCommViews, &VID_Details   );
            CViewSet_Add(pCommViews, &VID_Tile      );

            if (0 != DPA_InsertPtr(dpaViews, 0, pCommViews))
            {
                CViewSet_Delete(pCommViews);
                DPA_Destroy(dpaViews);
                dpaViews = NULL;
                return(FALSE);
            }

            that->_dpaViews = dpaViews;
            return(TRUE);
        }
    }
}


void CShellViews_GetDefaultView(CShellViews* that, UINT uViewSet,
    SHELLVIEWID* pvid)
{
    CViewSet* pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, uViewSet);
    if (!pViewSet)
    {
        pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, 0);
        if (!pViewSet)
        {
            *pvid = VID_LargeIcons;
            return;
        }
    }

    CViewSet_GetDefaultView(pViewSet, pvid);
}


void CShellViews_SetDefaultView(CShellViews* that, UINT uViewSet,
    SHELLVIEWID const* pvid)
{
    CViewSet* pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, uViewSet);
    if (!pViewSet)
    {
        return;
    }

    CViewSet_SetDefaultView(pViewSet, pvid);
}


// PERF: a linear search for the view set
int CShellViews_Add(CShellViews* that, CViewSet* pThisView, BOOL *pbNew)
{
    int iViewSet;

    *pbNew = FALSE;

    for (iViewSet=0; ; ++iViewSet)
    {
        CViewSet* pThatView = (CViewSet*)DPA_GetPtr(that->_dpaViews, iViewSet);
        if (!pThatView)
        {
            break;
        }

        if (CViewSet_IsSame(pThatView, pThisView))
        {
            // Found the same set; delete the one passed in and hand back the
            // existing one
            CViewSet_Delete(pThisView);
            return(iViewSet);
        }
    }

    // I guess we didn't find it
    iViewSet = DPA_AppendPtr(that->_dpaViews, (LPVOID)pThisView);
    if (iViewSet < 0)
    {
        CViewSet_Delete(pThisView);
        return(0);
    }

    *pbNew = TRUE;
    return(iViewSet);
}


BOOL CShellViews_IsViewSupported(CShellViews* that, UINT uViewSet,
    SHELLVIEWID  const*pvid)
{
    CViewSet* pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, uViewSet);
    if (!pViewSet)
    {
        return(FALSE);
    }

    return(CViewSet_IsViewSupported(pViewSet, pvid));
}


int DPA_CViewSet_DeleteCallback(LPVOID p, LPVOID d)
{
    if (p)
        CViewSet_Delete((CViewSet*)p);
    return 1;
}

void CShellViews_Delete(CShellViews* that)
{
    if (that && that->_dpaViews)
    {
        DPA_DestroyCallback(that->_dpaViews, DPA_CViewSet_DeleteCallback, 0);
        that->_dpaViews = NULL;
    }
}


BOOL FileCabinet_GetDefaultViewID2(FOLDERSETDATABASE* that, SHELLVIEWID* pvid)
{
    if (CShellViews_Init(&that->_cViews))
    {
        CShellViews_GetDefaultView(&that->_cViews, that->_iViewSet, pvid);
        return(TRUE);
    }

    return(FALSE);
}


HRESULT FileCabinet_CreateViewWindow2(IShellBrowser* psb, FOLDERSETDATABASE* that, IShellView *psvNew,
    IShellView *psvOld, RECT *prcView, HWND *phWnd)
{
    SHELLVIEWID vid, vidOld, vidRestore;
    IShellView2 *psv2New;
    CViewSet *pThisView;
    DWORD dwViewPriority;
    BOOL bCalledSV2 = FALSE;
    HRESULT hres = S_OK;  // init to avoid a bogus C4701 warning

    if (!CShellViews_Init(&that->_cViews))
    {
        // Can't do anything with view sets; just do the old thing
        goto OldStyle;
    }

    // Default to whatever the last "old-style" view is
    CShellViews_GetDefaultView(&that->_cViews, 0, &vidOld);

    if (psvOld)
    {
        IShellView2 *psv2Old;

        if (SUCCEEDED(IUnknown_QueryInterface(psvOld, IID_IShellView2,
                                              &psv2Old)))
        {
            // Try to get the current view
            if (NOERROR == IShellView2_GetView(psv2Old, &vidOld, SV2GV_CURRENTVIEW))
            {
                CShellViews_SetDefaultView(&that->_cViews, that->_iViewSet, &vidOld);
            }

            IUnknown_Release(psv2Old);
        }
        else
        {
            // Get the view ID from the folder settings
            ViewIDFromViewMode(that->_fld._fs.ViewMode, &vidOld);
            CShellViews_SetDefaultView(&that->_cViews, 0, &vidOld);
        }
    }

    pThisView = CViewSet_New();
    if (!pThisView)
    {
        goto OldStyle;
    }

    if (SUCCEEDED(IUnknown_QueryInterface(psvNew, IID_IShellView2, &psv2New)))
    {
        SHELLVIEWID vidFolderDefault;
        if (NOERROR == IShellView2_GetView(psv2New, &vidFolderDefault, SV2GV_DEFAULTVIEW))
        {
            // we can now make up a view set for that folder
            if (CViewSet_Add(pThisView, &vidFolderDefault) >= 0)
            {
                int iViewSet;
                UINT uView;
                BOOL bNew;

                // NOTE: This usage of IShellView2::GetView is not documented in MSDN...
                for (uView=0; NOERROR==IShellView2_GetView(psv2New, &vid, uView);
                    ++uView)
                {
                    CViewSet_Add(pThisView, &vid);
                }

                // Add that view set.  we will get an existing view set if it is
                // a duplicate
                iViewSet = CShellViews_Add(&that->_cViews, pThisView, &bNew);
                // This is now owned by CShellViews
                pThisView = NULL;

                
                //
                // Here is where we decide which view we want to use.
                //

                // Start with what came from the FOLDERSETDATABASE, then see if
                // anyone else has a higher VIEW_PRIORITY_XXX that would override this one.
                vidRestore = that->_fld._vidRestore;
                dwViewPriority = that->_fld._dwViewPriority;

                // ToddB, 8-18-99:
                // When we set the _fld._dwViewPriority in WebBrowserOc::Load(IPropertyBag *...) we want that ViewID to stick
                // around.  Only failing the CShellViews_IsViewSupported call below should set a different view.  Even then
                // we want to go back to this view on the next navigate.  To accomplish this we need to keep the priority of
                // that view at what it was originally set to.  This can be done by removing the following line of code:
                //
                //  that->_fld._dwViewPriority = VIEW_PRIORITY_NONE;
                //
                // However, its possible that the line of code above was there for a good reason.  I suspect that line was
                // originally added simply as a precaution or because the meaning of _vidRestore was not clearly defined in
                // relation to navigation inside a WebBrowserOC.  I'm leaving the line here and commented out just in case.
                // If any new bugs arise about changing the view window and getting the wrong view I would look here first.


                // Make sure that what we got is a supported view
                if (!CShellViews_IsViewSupported(&that->_cViews, iViewSet, &vidRestore))
                {
                    // Oops, that view isn't supported by this shell ext.
                    // Set the priority to NONE so that one of the others will override it.
                    dwViewPriority = VIEW_PRIORITY_NONE;
                }

                
                DWORD cbSize;
                DWORD dwValue;
                DWORD dwShellExtPriority;
                cbSize = SIZEOF(dwValue);
                if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                            TEXT("ClassicViewState"), NULL, &dwValue, &cbSize)
                        && dwValue)
                {
                    // We want to inherit from the previous folder if at all possible
                    // Otherwise, we will use the new shell extended view.
                    // To do this, we set the shell ext view priority lower than inherit
                    dwShellExtPriority = VIEW_PRIORITY_SHELLEXT_ASBACKUP;
                }
                else
                {
                    dwShellExtPriority = VIEW_PRIORITY_SHELLEXT;
                }

                // Let the shell ext select the view if it has higher priority than
                // what we already have, and it is supported as well.
                if (dwViewPriority <= dwShellExtPriority &&
                    ((GetUIVersion() >= 5) || (vidFolderDefault != VID_LargeIcons)) && // downlevel browser assumes VID_LargeIcons means "default"
                    CShellViews_IsViewSupported(&that->_cViews, iViewSet, &vidFolderDefault))
                {
                    // shell extension is more important
                    vidRestore = vidFolderDefault;
                    dwViewPriority = dwShellExtPriority;
                }
                
                // Maybe we can inherit it from the previous view...
                if (dwViewPriority <= VIEW_PRIORITY_INHERIT &&
                    psvOld &&
                    bNew &&
                    CShellViews_IsViewSupported(&that->_cViews, iViewSet, &vidOld))
                {
                    // We just navigated from another shell view. Use the same view as the last
                    // folder.
                    vidRestore = vidOld;
                    dwViewPriority = VIEW_PRIORITY_INHERIT;
                }

                // We're getting really desperate now...
                if (dwViewPriority <= VIEW_PRIORITY_DESPERATE)
                {
                    // Try the last view for the folders current viewset.
                    CShellViews_GetDefaultView(&that->_cViews, iViewSet, &vidRestore);
                    dwViewPriority = VIEW_PRIORITY_DESPERATE;
                }
                  
                // All finished trying to figure out what view to use
                ASSERT(dwViewPriority > VIEW_PRIORITY_NONE);

                // assure webview no in vid, it is persisted in shellstate now.
                {
                    SV2CVW2_PARAMS cParams =
                    {
                        SIZEOF(SV2CVW2_PARAMS),

                        psvOld,
                        &that->_fld._fs,
                        psb,
                        prcView,
                        &vidRestore,

                        NULL,
                    } ;

                    hres = IShellView2_CreateViewWindow2(psv2New, &cParams);
                    bCalledSV2 = TRUE;
                    *phWnd = cParams.hwndView;
                }

                if (SUCCEEDED(hres))
                {
                    that->_iViewSet = iViewSet;
                }
            }
        }

        IUnknown_Release(psv2New);
    }

    if (pThisView)
    {
        CViewSet_Delete(pThisView);
    }

    if (bCalledSV2)
    {
        return(hres);
    }

OldStyle:
    that->_iViewSet = 0;
    return IShellView_CreateViewWindow(psvNew, psvOld, &that->_fld._fs, (IShellBrowser*)psb, prcView, phWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hlframe.cpp ===
#include "priv.h"
#include "resource.h"
#include "hlframe.h"
#include "bindcb.h"
#include "winlist.h"
#include "iface.h"
#include "shdocfl.h"
#include <optary.h>
#include <mluisupp.h>

#define DM_SHELLEXECOBJECT    0x80000000


// flags for SHDVID_DOCFAMILYCHARSET communication
#define DFC_URLCHARSET  1

#ifdef FEATURE_PICS
#include "dochost.h"    /* for IID_IsPicsBrowser */
#endif

#ifdef DEBUG
extern DWORD g_dwPerf;
#endif

#define DM_HLINKTRACE DM_TRACE

#define DM_WEBCHECKDRT          0
#define JMPMSG(psz, psz2)    TraceMsg(0, "shlf TR-CDOV::%s %s", psz, psz2)
#define JMPMSG2(psz, x)        TraceMsg(0, "shlf TR-CDOV::%s %x", psz, x)
#define DOFMSG(psz)        TraceMsg(0, "shlf TR-DOF::%s", psz)
#define DOFMSG2(psz, x)        TraceMsg(0, "shlf TR-DOF::%s %x", psz, x)
#define URLMSG(psz)        TraceMsg(0, "shlf TR-DOF::%s", psz)
#define URLMSG2(psz, x)        TraceMsg(0, "shlf TR-DOF::%s %x", psz, x)
#define URLMSG3(psz, x, y)    TraceMsg(0, "shlf TR-DOF::%s %x %x", psz, x, y)
#define BSCMSG(psz, i, j)    TraceMsg(0, "shlf TR-BSC::%s %x %x", psz, i, j)
#define BSCMSG3(psz, i, j, k)    TraceMsg(0, "shlf TR-BSC::%s %x %x %x", psz, i, j, k)
#define BSCMSGS(psz, sz)    TraceMsg(0, "shlf TR-BSC::%s %s", psz, sz)
#define OIPSMSG(psz)        TraceMsg(0, "shlf TR-OIPS::%s", psz)
#define OIPSMSG3(psz, sz, p)    TraceMsg(0, "shlf TR-OIPS::%s %s,%x", psz, sz,p)
#define REFMSG0(psz)        TraceMsg(0, "shlf TR-CDOV::%s", psz)
#define REFMSG(psz, cRef)    TraceMsg(0, "shlf TR-CDOV::%s new _cRef==%d", psz, cRef)
#define REFMSG2(psz, if, cRef)    TraceMsg(0, "shlf TR-CDOV::%s(%s) new _cRef==%d", psz, if, cRef)
#define VIEWMSG(psz)        TraceMsg(0, "shlf TR CDOV::%s", psz)
#define VIEWMSG2(psz,xx)    TraceMsg(0, "shlf TR CDOV::%s %x", psz,xx)
#define CACHEMSG(psz, d)        TraceMsg(0, "shlf TR CDocObjectCtx::%s %d", psz, d)
#define HFRMMSG(psz)        TraceMsg(TF_SHDNAVIGATE, "shlf HFRM::%s", psz)
#define HFRMMSG2(psz, x, y)    TraceMsg(TF_SHDNAVIGATE, "shlf HFRM::%s %x %x", psz, x, y)
#define MNKMSG(psz, psz2)    TraceMsg(0, "shlf MNK::%s (%s)", psz, psz2)
#define SERVMSG(psz, x, y)    TraceMsg(0, "shlf SERV::%s %x %x", psz, x, y)

#define KEY_BINDCONTEXTPARAM            _T("BIND_CONTEXT_PARAM")
#define SZ_DWNBINDINFO_OBJECTPARAM      _T("__DWNBINDINFO")

BOOL g_fHlinkDLLLoaded = FALSE;        // must be per-process

STDAPI HlinkFrameNavigate(DWORD grfHLNF, IBindCtx *pbc,
                           IBindStatusCallback *pibsc,
                           IHlink* pihlNavigate,
                           IHlinkBrowseContext *pihlbc);
STDAPI HlinkFrameNavigateNHL(DWORD grfHLNF, IBindCtx *pbc,
                           IBindStatusCallback *pibsc,
                           LPCWSTR pszTargetFrame,
                           LPCWSTR pszUrl,
                           LPCWSTR pszLocation);

// IHlinkFrame members
HRESULT CIEFrameAuto::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    if (pihlbc)
        pihlbc->AddRef();

    if (_phlbc)
    {
        if (_dwRegHLBC) 
        {
            _phlbc->Revoke(_dwRegHLBC);
            _dwRegHLBC = 0;
        }
        _phlbc->Release();
    }

    _phlbc = pihlbc;

    return NOERROR;
}

HRESULT CIEFrameAuto::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    TraceMsg(0, "shlf TR ::GetBrowseContext called");
    
    *ppihlbc = _phlbc;

    if (_phlbc) 
    {
        _phlbc->AddRef();
        return S_OK;
    }
    
    return E_FAIL;
}

void CIEFrameAuto::_SetPendingNavigateContext(IBindCtx *pbc, IBindStatusCallback *pibsc)
{
    if (_pbscPending) 
    {
        _pbscPending->Release();
        _pbscPending = NULL;
    }

    if (_pbcPending) 
    {
        _pbcPending->Release();
        _pbcPending = NULL;
    }

    if (pibsc) 
    {
        _pbscPending = pibsc;
        _pbscPending->AddRef();
    }

    if (pbc) 
    {
        // as long as we are cacheing the pending BindCtx, if it specifies
        // a shortcut URL we need to cache that too. (IE:98431)
        IUnknown *          pUnk = NULL;
        IHtmlLoadOptions *  pHtmlLoadOptions  = NULL;

        _pbcPending = pbc;
        _pbcPending->AddRef();

        pbc->GetObjectParam(_T("__HTMLLOADOPTIONS"), &pUnk);
        if (pUnk)
        {
            pUnk->QueryInterface(IID_IHtmlLoadOptions, (void **) &pHtmlLoadOptions);

            if (pHtmlLoadOptions)
            {
                TCHAR    achCacheFile[MAX_PATH+1];
                ULONG    cchCacheFile = ARRAYSIZE(achCacheFile)-1;

                memset(&achCacheFile, 0, (cchCacheFile+1)*sizeof(TCHAR) );
                
                // now determine if this is a shortcut-initiated load
                pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                                       &achCacheFile,
                                                       &cchCacheFile);

                if (_pwszShortcutPathPending)
                    LocalFree(_pwszShortcutPathPending);

                _pwszShortcutPathPending = StrDup(achCacheFile);

                pHtmlLoadOptions->Release();
            }

            pUnk->Release();
        }

   }
}

//
//  NavigateContext is a set of parameters passed from one CIEFrameAuto
// to another.
//
void CIEFrameAuto::_ActivatePendingNavigateContext()
{
    if (_pbsc) 
    {
        _pbsc->Release();
        _pbsc = NULL;
    }

    if (_pbc) 
    {
        _pbc->Release();
        _pbc = NULL;
    }

    if (_pwszShortcutPath)
    {
        LocalFree(_pwszShortcutPath);
        _pwszShortcutPath = NULL;
    }

    if (_pbscPending) 
    {
        _pbsc = _pbscPending;
        _pbscPending = NULL;
    }

    if (_pbcPending) 
    {
        _pbc = _pbcPending;
        _pbcPending = NULL;
    }

    if (_pwszShortcutPathPending) 
    {
        _pwszShortcutPath = _pwszShortcutPathPending;
        _pwszShortcutPathPending = NULL;
    }
        
}

//  Called to guarantee a newly created HLinkFrame's window is
//  visible after the navigate.
HRESULT ShowHlinkFrameWindow(IUnknown *pUnkTargetHlinkFrame)
{
    IWebBrowserApp* pdie;
    HRESULT hres = pUnkTargetHlinkFrame->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pdie));
    if (SUCCEEDED(hres)) 
    {
        pdie->put_Visible(TRUE);
        pdie->Release();
    }
    return hres;
}

HRESULT CIEFrameAuto::_NavigateMagnum(DWORD grfHLNF, IBindCtx *pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation, IHlink *pihlNavigate, IMoniker *pmkTarget)
{
    HRESULT hres = NOERROR;
    HFRMMSG2("Navigate called", grfHLNF, pihlNavigate);
    BOOL fNavigateForReal = pszUrl || (pihlNavigate && (pihlNavigate != (IHlink*)-1));

    _fSuppressHistory = _psbProxy != _psb;  // no history for search band, etc
    _fSuppressSelect = _psbProxy != _psb;   // no need to record select pidl
    if (grfHLNF != (DWORD)-1)
    {
        if (SHHLNF_WRITENOHISTORY & grfHLNF)
        {
            _fSuppressHistory = TRUE;
        }
        if (SHHLNF_NOAUTOSELECT & grfHLNF)
        {
            _fSuppressSelect = TRUE;
        }
    }

    if (pbc == NULL && pibsc == NULL && pihlNavigate == NULL && pszUrl == NULL) 
    {
        //
        //  This is a private interface so that mshtml can do navigation
        // if it is hosted by the shell.  When IHlinkBrowseContext is implemented
        // in the shell this special code can be removed and the associated
        // code in mshtml that calls Navigate with these special parameters
        // can be removed so that it just goes through the
        // IHlinkBrowseContext->SetCurrentHlink interface.
        //
        //  We also use this private mechanism to release the navigation
        // context with grfHLNF==0.
        // 

        switch (grfHLNF&~(SHHLNF_WRITENOHISTORY|SHHLNF_NOAUTOSELECT)) 
        {
        case HLNF_NAVIGATINGBACK:
            hres = _BrowseObject(PIDL_LOCALHISTORY, SBSP_SAMEBROWSER|SBSP_NAVIGATEBACK);
            break;

        case HLNF_NAVIGATINGFORWARD:
            hres = _BrowseObject(PIDL_LOCALHISTORY, SBSP_SAMEBROWSER|SBSP_NAVIGATEFORWARD);
            break;

        case 0:
            _ActivatePendingNavigateContext();
            break;

        default:
            hres = E_INVALIDARG;
            break;
        }

        return hres;
    }

#ifdef FEATURE_PICS
    /* As part of checking ratings, the PICS code will silently download the
     * root document of a site to look for rating labels in it.  If that's a
     * frameset page, Trident will create OCXs for the subframes and try to
     * navigate them, which will invoke ratings checks for them and cause
     * infinite recursion.  So here we check to see if our top-level browser
     * is really this PICS download, and if it is, we don't do any navigation.
     */
    IUnknown *punkPics;
    if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IsPicsBrowser, (void **)&punkPics)))
    {
        punkPics->Release();
        return S_OK;
    }
#endif

    //
    // If we've got this call while we are busy (EnableModeless is FALSE),
    // we should just bail here (instead of doing somthing and let _JumpTo
    // call fail. 
    //
    // This can happen if someone has a window.location="foobar.htm" in their unload
    // event handler.  
    if (fNavigateForReal && !(grfHLNF & HLNF_OPENINNEWWINDOW)) 
    {
        // If _pbs is NULL, it is bad news; we can't navigate.
        // An allowable reason for this condition is that someone has called CIEFrameAuto::Quit()
        // and we are in the process of shutting down.
        //
        if (_pbs == NULL)
        {
            if (_fQuitInProgress)
            {
                TraceMsg(TF_WARNING, "CIEFrameAuto::_NavigateMagnum quitting due to browser closing.");
                return S_OK;
            }
            TraceMsg(TF_WARNING, "CIEFrameAuto::_NavigateMagnum _pbs is NULL, but we are not shutting down.");
            return E_FAIL;
        }

        // If we have a _pbs but the browser says that it can't navigate now, then return S_FALSE.
        //
        else if (_pbs->CanNavigateNow() != S_OK) 
        {
            TraceMsg(TF_WARNING, "CIEFrameAuto::Navigate CanNavigateNow returns non S_OK, bail out.");
            return S_FALSE;
        }
    }

    //
    // This Navigate method is not re-entrant (because of _SetPendingNavigateContext)
    //
    if (_fBusy) 
    {
        TraceMsg(DM_WARNING, "CIEA::Navigate re-entered. Returning E_FAIL");
        return E_FAIL;
    }
    _fBusy = TRUE;

    //
    // HACK: To let Webcheck DRT go.
    //
    if (fNavigateForReal  && !(grfHLNF & HLNF_OPENINNEWWINDOW)) 
    {
        TraceMsg(DM_WEBCHECKDRT, "CIFA::Navigate calling _CancelPendingNavigation");
        VARIANT var = { 0 };
        var.vt = VT_I4;
        var.lVal = TRUE;    // synchronous

        _CancelPendingNavigation(&var);
    }

    if (pszUrl && SHRestricted2(REST_NOFILEURL, NULL, 0) && PathIsFilePath(pszUrl))
    {
        TCHAR szPath[MAX_URL_STRING];
        SHUnicodeToTChar(pszUrl, szPath, ARRAYSIZE(szPath));
        MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_SHURL_ERR_PARSE_NOTALLOWED),
                        szPath, MB_OK | MB_ICONERROR, szPath);
    
        _fBusy = FALSE;
        return E_ACCESSDENIED;
    }


    _SetPendingNavigateContext(pbc, pibsc);

#ifdef DEBUG
    g_dwPerf = GetCurrentTime();

#endif

    if (pihlNavigate == (IHlink*)-1) 
    {
        //
        // HACK: -1 means "release the navigation state".
        // CDocObjectHost::_CancelPendingNavigation is the only caller.
        // It Exec's SBCMDID_CANCELNAVIGATION which will asynchronously
        // cancel the pending navigation. Therefore, we no longer need
        // to call _CancelPendingNavigation here. (SatoNa)
        // 
        // _CancelPendingNavigation();
    }
    else if (pihlNavigate || pszUrl) 
    {
        hres = S_OK;

        if (SUCCEEDED(hres))
        {
            if ((grfHLNF & HLNF_EXTERNALNAVIGATE) && (grfHLNF & HLNF_NAVIGATINGBACK))
                GoBack();
            else if ((grfHLNF & HLNF_EXTERNALNAVIGATE) && (grfHLNF & HLNF_NAVIGATINGFORWARD))
                GoForward();
            else 
            {
                hres = _JumpTo(pbc,(LPWSTR) pszLocation, grfHLNF, pibsc, pihlNavigate, pszTargetName, pszUrl);
                if (FAILED(hres)) 
                {
                    TraceMsg(DM_ERROR, "IEAuto::Navigate _JumpTo failed %x", hres);
                }
            }
            if (pihlNavigate)
            {
                //
                //  Hopefully, we'll come up with a clean solution to
                //  solve this problem nicely. I made a proposal to NatBro/SriniK
                //  that CreateHlink will CoCreateInstance IHlink so that OLE
                //  LoadLibrary it and maintains it as an InProc server. (SatoNa)
                //
                // HACK: If we AddRef to IHlink, we need to make it sure that
                //  HLINK.DLL is stay loaded even though the DocObject InProc
                //  server (that implicitly links to HLINK.DLL) is unloaded.
                //
                if (!g_fHlinkDLLLoaded) 
                {
                    LoadLibrary(TEXT("hlink.dll"));
                    g_fHlinkDLLLoaded = TRUE;
                }
            }
        }
        else
        {
            TraceMsg(DM_ERROR, "CIEFA::Nav phl->GetMonRef failed %x", hres);
        }
    }

    _fBusy = FALSE;

    HFRMMSG2("Navigate returning", hres, 0);
    
    if (SUCCEEDED(hres) && (pihlNavigate != (IHlink*)-1)) 
    {
        if (grfHLNF & HLNF_EXTERNALNAVIGATE) 
        {
            HWND hwndFrame;
            _psb->GetWindow(&hwndFrame);
            
            if (_phlbc) 
            {
                // if we have a browse context, then we're navigating from it and
                // we should size our window to match it.
                HLBWINFO hlbwi;
                
                hlbwi.cbSize = SIZEOF(hlbwi);
                if (SUCCEEDED(_phlbc->GetBrowseWindowInfo(&hlbwi)) &&
                    (hlbwi.grfHLBWIF & HLBWIF_HASFRAMEWNDINFO)) 
                {
                    WINDOWPLACEMENT wp;
                    
                    wp.length = sizeof(WINDOWPLACEMENT);
                    GetWindowPlacement(hwndFrame, &wp);
                    wp.rcNormalPosition = hlbwi.rcFramePos;
                    wp.showCmd = (hlbwi.grfHLBWIF & HLBWIF_FRAMEWNDMAXIMIZED) 
                                    ? SW_SHOWMAXIMIZED : SW_SHOWNORMAL;

                    // This is not broken in AOL because this
                    // is an external navigate (word has cocreateinstance()d
                    // Internet.Explorer and navigated it.
                    //
                    SetWindowPlacement(hwndFrame, &wp);
                }

                // Register the hlinkframe interface with the browse context, if it has not already
                // been registered
                if (_dwRegHLBC == 0)
                    _phlbc->Register(0, (IHlinkFrame *) this, pmkTarget, &_dwRegHLBC); 

                // add the link to browse context and
                // REVIEW: need to pass the proper friendly name
                _phlbc->OnNavigateHlink(grfHLNF, pmkTarget, pszLocation, NULL, NULL);
            }

            put_Visible(TRUE);
            
            SetForegroundWindow(hwndFrame);
        }

        //
        // According to SriniK, we need to call IHlinkSite::OnNavigationComplete
        // before returning from IHlinkFrame::Navigate with S_OK. (SatoNa)
        //
        if (pihlNavigate) 
        {
            BOOL fExternal = FALSE;
            if (_phlbc && _pbs) 
            {
                ITravelLog* ptl;
                if (SUCCEEDED(_pbs->GetTravelLog(&ptl))) 
                {
                    if (FAILED(ptl->GetTravelEntry(_pbs, 0, NULL))) 
                    {
                        TraceMsg(DM_HLINKTRACE, "CIEFA::_NavMag this is external nav. Don't call OnNavigationComplete");
                        fExternal = TRUE;
                    }
                    else if (SUCCEEDED(ptl->GetTravelEntry(_pbs, TLOG_BACKEXTERNAL, NULL))) 
                    {
                        TraceMsg(DM_HLINKTRACE, "CIEFA::_NavMag this is external for. Don't call OnNavigationComplete");
                        fExternal = TRUE;
                    }
                    ptl->Release();
                }
            }

            //
            // Don't call OnNavigationComplete if this is an external navigation.
            //
            if (!fExternal) 
            {
                IHlinkSite* pihlSite = NULL;
                DWORD dwSiteData;
                HRESULT hresT = pihlNavigate->GetHlinkSite(&pihlSite, &dwSiteData);
                if (SUCCEEDED(hresT) && pihlSite) 
                {
                    TraceMsg(DM_HLINKTRACE, "CIEFA::_NavMag calling OnNavigationComplete");
                    hresT = pihlSite->OnNavigationComplete(dwSiteData, 0, S_OK, L"");
                    if (FAILED(hresT)) 
                    {
                        TraceMsg(DM_ERROR, "CIEFA::Navigat OnNavComplete failed %x", hresT);
                    }
                    pihlSite->Release();
                }
            }
        }
    }

    return hres;
}

//
//  HACK - what we really want is a good private marshalled interface - zekel 8-AUG-97
//  to the Browser.  but for now we will overload the NavigateHack method, 
//  because it is simple and quick for ship.
//
#define HLNF_REFERRERHACK       0x40000000
HRESULT CIEFrameAuto::_ReferrerHack(LPCWSTR pszUrl)
{
    if (_pbs == NULL)    //Make sure we have a IBrowserService.
        return S_FALSE;

    LPITEMIDLIST pidl;

    if (SUCCEEDED(_pbs->IEParseDisplayName(CP_ACP, pszUrl, &pidl)))
    {
        ASSERT(pidl);
        _pbs->SetReferrer(pidl);
        ILFree(pidl);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::NavigateHack(DWORD grfHLNF, IBindCtx *pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation)
{
    HRESULT     hres = E_FAIL;
    IBindCtx *  pBindCtx = pbc;
    IUnknown *  pNotify = NULL;
    IUnknown *  pBindCtxParam = NULL;
    BOOL        fAsyncCalled = FALSE;
       
    // Check if we are actually a native frame build... 
    if (pbc)
    {
        hres = pbc->GetObjectParam(KEY_BINDCONTEXTPARAM, &pBindCtxParam);
    }
    
    if (SUCCEEDED(hres) && pBindCtxParam)
    {
        // NavigateHack can be called multiple times, and we only want to create the 
        // new bind context the first time. Since the ITargetNotify pointer is removed
        // after the first use, we can check that to make sure.
        // get and transfer the target notify pointer.
        hres = pbc->GetObjectParam(TARGET_NOTIFY_OBJECT_NAME, &pNotify);
        if (SUCCEEDED(hres) && pNotify)
        {
            // The call is coming from a native frame build of MSHTML. 
            // We can not use their bind context, create a new one and transfer
            // parameters.
            // The old bind context is going to be released by the creator, so do not
            // make a release call on it.
            hres = CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBindCtx, 0);
            if(FAILED(hres))
                goto Exit;

            fAsyncCalled = TRUE;

            // carry over the ITargetNotify2 pointer.
            hres = pBindCtx->RegisterObjectParam( TARGET_NOTIFY_OBJECT_NAME, pNotify );
            if (FAILED(hres))
                goto Exit;

            pNotify->Release();
            pNotify = NULL;

            // carry over the bind context parameter.
            hres = pBindCtx->RegisterObjectParam( KEY_BINDCONTEXTPARAM, pBindCtxParam );
            if (FAILED(hres))
                goto Exit;

            {
                IUnknown * pDwnBindInfo = NULL;

                if (SUCCEEDED(pbc->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pDwnBindInfo)) && pDwnBindInfo)
                {
                    pBindCtx->RegisterObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, pDwnBindInfo);
                    pDwnBindInfo->Release();
                }
            }
        }

        pBindCtxParam->Release();
        pBindCtxParam = NULL;
    }
    
    if (IsFlagSet(grfHLNF, HLNF_REFERRERHACK))
        hres =  _ReferrerHack(pszUrl);
    else
        hres = _NavigateMagnum(grfHLNF, pBindCtx, pibsc, pszTargetName, pszUrl, pszLocation, NULL, NULL);

Exit:
    SAFERELEASE(pNotify); 
    SAFERELEASE(pBindCtxParam);

    // If the call failed anywhere, we can not be sure the new document
    // will free the object parameter that is in the bind context 
    // we have created in this function.
    if (FAILED(hres) && pBindCtx)
    {
        // we don't want to change the return code here.
        pBindCtx->RevokeObjectParam(KEY_BINDCONTEXTPARAM);
        pBindCtx->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
    }
    
    if (fAsyncCalled)
        pBindCtx->Release();

    return hres;
}

// passing NULL pibsc and pbc will make be like "ReleaseNavigationState"
// passing -1 for pihlNavigate will cancel pending navigation

HRESULT CIEFrameAuto::Navigate(DWORD grfHLNF, IBindCtx *pbc,
     IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    IMoniker* pmkTarget = NULL;
    LPOLESTR pwszDisplayName = NULL;
    LPOLESTR pwszLocation = NULL;
    LPOLESTR pwszFrameName = NULL;
    HRESULT hres = S_OK;

    if (pihlNavigate && ((IHlink *)-1) != pihlNavigate)
    {
        pihlNavigate->GetTargetFrameName(&pwszFrameName);

        //
        // Note that we are discarding "relative" portion.
        //
        hres = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmkTarget, &pwszLocation);

        HFRMMSG2("Navigate pihl->GetMonRef returned", hres, pmkTarget);

        if (SUCCEEDED(hres))
        {
            IBindCtx* pbcLocal;
    
            if (pbc) 
            {
                pbcLocal = pbc;
                pbcLocal->AddRef();
            }
            else 
            {
                hres = CreateBindCtx(0, &pbcLocal);
            }

            if (SUCCEEDED(hres))
            {
                hres = pmkTarget->GetDisplayName(pbcLocal, NULL, &pwszDisplayName);
                pbcLocal->Release();
            }
        }
    }

    if (SUCCEEDED(hres))
    {
        hres = _NavigateMagnum(grfHLNF, pbc, pibsc, pwszFrameName, pwszDisplayName, pwszLocation, pihlNavigate, pmkTarget);
    }
    if (pwszFrameName)
    {
        OleFree(pwszFrameName);
    }
    if (pwszDisplayName)
    {
        OleFree(pwszDisplayName);
    }
    if (pwszLocation)
    {
        OleFree(pwszLocation);
    }
    if (pmkTarget)
    {
        pmkTarget->Release();
    }
    return hres;
}

HRESULT CIEFrameAuto::OnNavigate(DWORD grfHLNF,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ DWORD dwreserved)
{
    TraceMsg(0, "shlf TR ::OnNavigate called");
    return S_OK;
}

void CIEFrameAuto::_CancelPendingNavigation(VARIANTARG* pvar)
{
    TraceMsg(0, "shd TR _CancelPendingNavigation called");
    if (_pmsc) 
    {
        TraceMsg(0, "shd TR _CancelPendingNavigation calling _pmsc->Exec");
        _pmsc->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, pvar, NULL);
    }
}

// *** ITargetNotify ***

void 
CIEFrameAuto::_HandleOpenOptions( IUnknown * pUnkDestination, ITargetNotify * ptgnNotify)
{
    HRESULT             hres = S_OK;
    ITargetNotify2 *    ptgnNotify2 = NULL; 

    if (!pUnkDestination || !ptgnNotify)
        return;

    if (SUCCEEDED(ptgnNotify->QueryInterface( IID_ITargetNotify2, (void **)&ptgnNotify2)))
    {
        BSTR    bstrOptions = NULL;

        ASSERT(ptgnNotify2);

        // Apply the options only if the initator of the navigation 
        // asks for it.

        if (S_OK == ptgnNotify2->GetOptionString(&bstrOptions))
        {
            _omwin._OpenOptions.ReInitialize();

            if (bstrOptions)
            {
                _omwin._ParseOptionString(bstrOptions, ptgnNotify2);

                // We are done with the options string, release it
                SysFreeString(bstrOptions);
            }

            // Apply the options now.
            //
            IWebBrowser2 * pNewIE;

            if (SUCCEEDED(pUnkDestination->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pNewIE))))
            {
                _omwin._ApplyOpenOptions(pNewIE);
                pNewIE->Release();
            }
        }

        ptgnNotify2->Release();
    
    }
}

HRESULT CIEFrameAuto::OnCreate(IUnknown *pUnkDestination, ULONG cbCookie)
{
    HRESULT             hres = S_OK;

    if (cbCookie == (ULONG)_cbCookie && _ptgnNotify)
    {
        _HandleOpenOptions( pUnkDestination, _ptgnNotify);
    
        hres = _ptgnNotify->OnCreate(pUnkDestination, cbCookie);
        SAFERELEASE(_ptgnNotify);
    }
    return hres;
}

HRESULT CIEFrameAuto::OnReuse(IUnknown *pUnkDestination)
{
    return S_OK;
}

#define NOTIFY_WAIT_TIMEOUT (60000)
//  chrisfra 10/10/96: do we need EnableModeless(FALSE)/(TRUE) around 
//  our little loop, or is the busy flag (which is set) sufficient?

HRESULT CIEFrameAuto::_WaitForNotify()
{
    if (_ptgnNotify && IsInternetExplorerApp())
    {
        DWORD dwObject, msWait, msStart = GetTickCount();

        goto DOPEEK;

        while (_ptgnNotify)
        {
            // NB We need to let the run dialog become active so we have to half handle sent
            // messages but we don't want to handle any input events or we'll swallow the
            // type-ahead.
            msWait = GetTickCount();
            if (msWait - msStart > NOTIFY_WAIT_TIMEOUT) 
                break;

            msWait = NOTIFY_WAIT_TIMEOUT - (msWait - msStart);
            dwObject = MsgWaitForMultipleObjects(0, NULL, FALSE, msWait, QS_ALLINPUT);
            // Are we done waiting?
            switch (dwObject) 
            {
            case WAIT_FAILED:
                break;
                
            case WAIT_OBJECT_0:
DOPEEK:
                // got a message, dispatch it and wait again
                MSG msg;
                while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) 
                {
                    DispatchMessage(&msg);
                    if (_ptgnNotify == NULL || 
                        ((GetTickCount() - msStart) > NOTIFY_WAIT_TIMEOUT)) 
                        break;
                    
                }
                break;
            }
        }
    }
    return S_OK;
}

HRESULT CIEFrameAuto::_RegisterCallback(TCHAR *szFrameName, ITargetNotify *ptgnNotify)
{
    HRESULT hr = S_OK;

    SAFERELEASE(_ptgnNotify);

    _fRegistered = 0;

    if (ptgnNotify)
    {
        IDispatch *pid;
        hr = QueryInterface(IID_PPV_ARG(IDispatch, &pid));
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            IShellWindows *psw = WinList_GetShellWindows(TRUE);
            if (psw != NULL)
            {
                long cbCookie;
                hr = psw->Register(pid, NULL, SWC_CALLBACK, &cbCookie);
                if (SUCCEEDED(hr))
                {
                    TCHAR szCookie[25];   // big enough for "_[cbCookie]"
                    int slenCookie;
                    int slenName;
                    int slenMin;

                    _cbCookie = cbCookie;
                    _fRegistered = 1;
                    _ptgnNotify = ptgnNotify;
                    _ptgnNotify->AddRef();

                    //  prepend unique id to target -- tells created WebBrowserOC to
                    //  register the remainder (if any) as frame name and to perform
                    //  callbacks on all registered callbacks
                    wnsprintf(szCookie, ARRAYSIZE(szCookie), TEXT("_[%ld]"), cbCookie);
                    slenCookie = lstrlen(szCookie);
                    slenName = lstrlen(szFrameName);
                    slenMin =  min((int)MAX_URL_STRING-slenCookie,slenName);
                    MoveMemory(&szFrameName[slenCookie], szFrameName, CbFromCch(slenMin));
                    szFrameName[slenCookie+slenMin] = 0;
                    CopyMemory(szFrameName, szCookie, CbFromCch(slenCookie));
                }
                psw->Release();
            }
            pid->Release();
        }
    }

    return hr;
}


HRESULT CIEFrameAuto::_RevokeCallback()
{
    HRESULT hr = S_OK;

    if (_fRegistered)
    {
        IShellWindows *psw = WinList_GetShellWindows(TRUE);
        if (psw != NULL)
        {
            hr = psw->Revoke(_cbCookie);
            psw->Release();
        }
    }
    SAFERELEASE(_ptgnNotify);
    _fRegistered = 0;
    return hr;
}


//
//  HACK - what we really want is a good private marshalled interface - zekel 8-AUG-97
//  to the Browser.  but for now we will overload the NavigateHack method, 
//  because it is simple and quick for ship.
//
void CIEFrameAuto::_SetReferrer(ITargetFramePriv *ptgfp)
{
    LPITEMIDLIST pidl;
    WCHAR szUrl[MAX_URL_STRING];

    ASSERT(ptgfp);

    //Make sure we have a IBrowserService.
    if (_psb && SUCCEEDED(_pbs->GetPidl(&pidl)))
    {
        if (SUCCEEDED(_pbs->IEGetDisplayName(pidl, szUrl, SHGDN_FORPARSING)))
            ptgfp->NavigateHack(HLNF_REFERRERHACK, NULL, NULL, NULL, szUrl, NULL);

        ILFree(pidl);
    }
}


HRESULT CIEFrameAuto::_JumpTo(IBindCtx *pbc, LPWSTR pszLocation, DWORD grfHLNF, IBindStatusCallback *pibsc, IHlink *pihlNavigate, LPCWSTR pszFrameName, LPCWSTR pszUrl)
{
    LPITEMIDLIST pidl = NULL;
    HRESULT hres;
    ITargetNotify *ptgnNotify = NULL;
    IUnknown *punkNotify = NULL;
    IUnknown *punkThis = NULL;
    UINT uiCP = CP_ACP;

    // Get the current document codepage from Trident and use it for url string conversion if necessary.
    if (!(grfHLNF & HLNF_ALLOW_AUTONAVIGATE) && _pmsc)
    {
        VARIANT varOut = { 0 };
        VARIANT varIn = { 0 };

        varIn.vt = VT_I4;
        varIn.lVal = DFC_URLCHARSET; // we want the doc's url charset

        if (SUCCEEDED(_pmsc->Exec(&CGID_ShellDocView, SHDVID_DOCFAMILYCHARSET, 0, &varIn, &varOut)))
            uiCP = (UINT)varOut.lVal;
    }

    //  Note that we are simply passing the pidl to ISB::BrowseObject,
    // assuming that new shell32.dll allows us to bind to DocObject
    // documents.
    //

    DWORD flags = (grfHLNF & HLNF_OPENINNEWWINDOW) ?
        (SBSP_NEWBROWSER | SBSP_ABSOLUTE | SBSP_INITIATEDBYHLINKFRAME) :
        (SBSP_SAMEBROWSER | SBSP_ABSOLUTE | SBSP_INITIATEDBYHLINKFRAME);


    flags |= ((grfHLNF & HLNF_ALLOW_AUTONAVIGATE) ? (SBSP_ALLOW_AUTONAVIGATE) : 0);
    flags |= ((grfHLNF & SHHLNF_WRITENOHISTORY) ? (SBSP_WRITENOHISTORY) : 0);
    flags |= ((grfHLNF & SHHLNF_NOAUTOSELECT) ? (SBSP_NOAUTOSELECT) : 0);

    if (pbc && SUCCEEDED(pbc->GetObjectParam(TARGET_NOTIFY_OBJECT_NAME, &punkNotify)))
    {
        if (FAILED(punkNotify->QueryInterface(IID_PPV_ARG(ITargetNotify, &ptgnNotify))))
            ptgnNotify = NULL;
        
        punkNotify->Release();
        QueryInterface(IID_PPV_ARG(IUnknown, &punkThis));
    }

    if (grfHLNF & HLNF_CREATENOHISTORY)
        flags |= SBSP_REDIRECT;

    if (flags & SBSP_NEWBROWSER)
    {
        TCHAR *pszHeaders = NULL;
        BYTE *pPostData = NULL;
        DWORD cbPostData = 0;
        TCHAR szFrameName[MAX_URL_STRING+1];
        STGMEDIUM stgPostData = { TYMED_NULL, NULL, NULL };

        //Qfe:1478 If restricted to open in new window, return failure.
        if ((grfHLNF & HLNF_OPENINNEWWINDOW) 
            && SHIsRestricted2W(_hwnd, REST_NoOpeninNewWnd, NULL, 0))
        {
            SAFERELEASE(punkThis);
            return E_ACCESSDENIED;
        }

        szFrameName[0] = 0;

        //  Here is where if we are doing a new window we must
        //  extract frame, post etc and append to pidl.  These must
        //  be done in the following order (to match extraction code):
        //      URLID_FRAMENAME,URLID_POSTDATA,URLID_HEADERS

        if (pszFrameName)
        {
            SHUnicodeToTChar(pszFrameName, szFrameName, ARRAYSIZE(szFrameName));
        }


        if (pibsc)
        {
            GetHeadersAndPostData(pibsc,&pszHeaders,&stgPostData,&cbPostData, NULL);

            if (stgPostData.tymed == TYMED_HGLOBAL) 
            {
                pPostData = (LPBYTE) stgPostData.hGlobal;
            }
        }

        hres = _PidlFromUrlEtc(uiCP, pszUrl, pszLocation, &pidl);

        HFRMMSG2("_JumpTo _PidlFromUrlEtc returned", hres, pidl);

        if (SUCCEEDED(hres))
        {
            IUnknown* punkNewWindow = NULL;
            BOOL fCancel = FALSE;

            // The NewWindow2 event may return the window for us.
            FireEvent_NewWindow2(_GetOuter(), &punkNewWindow, &fCancel);
            if (!fCancel)
            {
                BOOL fProcessed = FALSE;

                // We might need the old NewWindow event...
                if (!punkNewWindow)
                {
                    _RegisterCallback(szFrameName, ptgnNotify);
        
                    // fire an event to indicate a new window needs to be created
                    // to allow a container to handle it itself if it wants
                    // since we may be aggregated, QI our parent

                    // Yet another Compuserve workaround (IE 60688):
                    // If the target frame name is "_blank", Compuserve will pass that name
                    // in to the Navigate call of the new window.  We would then create a new window
                    // (which would fire this event) causing a loop.  Break the recursion by sending
                    // an empty string for the frame name.
                    HWND hwnd = _GetHWND();
                    
                    if (hwnd)
                    {
                        FireEvent_NewWindow(_GetOuter(), hwnd, pidl,pszLocation,0,
                            StrCmpI(szFrameName, TEXT("_blank")) ? szFrameName : TEXT(""),  // Target frame name
                            pPostData,cbPostData,pszHeaders,&fProcessed);
                    }
                }
    
                if (!fProcessed)
                {
                    if (!punkNewWindow)
                    {
#ifdef INCLUDE_BUSTED_OC_QI
                        IUnknown* pdvb = NULL;
#endif
                        _RevokeCallback();

#ifdef INCLUDE_BUSTED_OC_QI
                        // For some unidentifiable reason the old code did NOT
                        // create a new window if we were hosted in the WebBrowserOC.
                        // mikesh/cheechew/jeremys/chrisfra don't know why this happens.
                        // Who knows what app will break if we change this...
                        // (Note: IDefViewBrowser is a CWebBrowseSB only interface)
                        //
                        // NOTE: chrisfra 3/11/97, this code breaks open a
                        // new window for a non-existent target, when in
                        // desktop component or browser band
                        fCancel = !(_psbTop && FAILED(_psbTop->QueryInterface(IID_PPV_ARG(IDefViewBrowser, &pdvb))));
                        if (pdvb)
                            pdvb->Release();
#endif
                    }
    
                    // what we really want to do is just hand this off to
                    // _psbTop->BrowseObject and let it (CWebBrowserSB or CShellBrowser)
                    // decide whether to use HlinkFrameNavigate or not, but if we
                    // do that, then we lose the grfHLNF and pihlNavigate.
                    // So put that logic here...
                    //
                    if (!fCancel)
                    {
                        hres = CreateTargetFrame(pszFrameName, &punkNewWindow);
                        if (SUCCEEDED(hres))
                        {
                            //  Notify ptgnNotify, then release and remove from bindctx
                            if (ptgnNotify)
                            {
                                _HandleOpenOptions( punkNewWindow, ptgnNotify);

                                ptgnNotify->OnCreate(punkNewWindow, GetTickCount());

                                ptgnNotify->Release();
                                ptgnNotify = NULL;

                                pbc->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
                            }

                            LPHLINKFRAME phf;

                            hres = punkNewWindow->QueryInterface(IID_PPV_ARG(IHlinkFrame, &phf));
                            if (SUCCEEDED(hres))
                            {
                                ITargetFramePriv * ptgfp;

                                if (NULL == pihlNavigate)
                                {
                                    hres = punkNewWindow->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfp));
                                }

                                if (SUCCEEDED(hres))
                                {
                                    if (pihlNavigate)
                                    {
                                        hres = phf->Navigate(grfHLNF & ~HLNF_OPENINNEWWINDOW, 
                                                             pbc, 
                                                             pibsc, 
                                                             pihlNavigate);
                                    }
                                    else
                                    {
                                        // HACK - see this methods comments 
                                        _SetReferrer(ptgfp);

                                        hres = ptgfp->NavigateHack(grfHLNF & ~HLNF_OPENINNEWWINDOW, 
                                                             pbc, 
                                                             pibsc,
                                                             NULL,
                                                             pszUrl,
                                                             pszLocation);
                                    }
    
                                    if (FAILED(hres)) 
                                    {
                                        TraceMsg(DM_ERROR, "CIEFA::_JumpTo marshalled IHlinkFrame::Navigate failed %x", hres);
                                    }

                                    ShowHlinkFrameWindow(punkNewWindow);
                                    if (NULL == pihlNavigate)
                                    {
                                        ptgfp->Release();
                                    }

                                    if(SUCCEEDED(hres) && pibsc)
                                    {
                                        _SetPendingNavigateContext(NULL, NULL);
                                    }

                                }
                                phf->Release();
                            }
                        }
                    }
                    else 
                    {
                        //
                        //  If NEWBROWSER is specified when there is no top level
                        // browser, we should ask IE/Shell to do browsing.
                        // We don't pass HLNF_OPENINNEWWINDOW in this case.
                        //
                        
                        //  Notify object doing navigation that we are the object implementing IWebBrowserApp
                        if (ptgnNotify) ptgnNotify->OnReuse(punkThis);
    
                        if (pihlNavigate)
                        {
                            hres = HlinkFrameNavigate(grfHLNF & ~HLNF_OPENINNEWWINDOW,
                                                        NULL, NULL, pihlNavigate, NULL);
                        }
                        else
                        {
                            hres = HlinkFrameNavigateNHL(grfHLNF & ~HLNF_OPENINNEWWINDOW,
                                       NULL, NULL, NULL, pszUrl, pszLocation);
                        }
                    }
                }
                else
                {
                    //  Oldstyle AOL or other 3rd Party, wait for registration of 
                    //  WebBrowserOC, which calls us back on _ptgnNotify
                    _WaitForNotify();
                    //  We timed out the window create, notify caller
                    if (_ptgnNotify) 
                        _ptgnNotify->OnCreate(NULL, 0);
                    _RevokeCallback();
                }
            }

            if (punkNewWindow)
                punkNewWindow->Release();

        }
        else
        {
            TraceMsg(DM_ERROR, "IEAuto::_JumpTo _PidlFromUrlEtc (1) failed %x", hres);
        }
        if (pszHeaders) 
        {
            LocalFree(pszHeaders);
            pszHeaders = NULL;
        }

        if (stgPostData.tymed != TYMED_NULL)
        {
            ReleaseStgMedium(&stgPostData);
        }

    }
    else
    {
        //  Notify object doing navigation that we are the object implementing IWebBrowserApp
        if (ptgnNotify) ptgnNotify->OnReuse(punkThis);

        hres = _PidlFromUrlEtc(uiCP, pszUrl, pszLocation, &pidl);
        if (SUCCEEDED(hres))
        {
            hres = _psb->BrowseObject(pidl, flags);
        }
        else 
        {
            TraceMsg(DM_ERROR, "IEAuto::_JumpTo _PidlFromUrlEtc (2) failed %x", hres);
        }
    }

    if (pidl)
    {
        HFRMMSG2("_JumpTo _psb->BrowseObject returned", hres, 0);
        ILFree(pidl);
    }
    
    if (ptgnNotify)
    {
        ptgnNotify->Release();
        pbc->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
    }

    SAFERELEASE(punkThis);

    return hres;
}


HRESULT CIEFrameAuto::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
    *ppvObj = NULL;

    // WARNING: Note that we are not following the strict semantics of
    //  ISP::QueryService. It is, however, OK because this (the fact that
    //  IHlinkFrame support IServiceProvider) is not public.

    if (IsEqualIID(guidService, SID_SOmWindow)) 
    {
        return _omwin.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, IID_IHlinkFrame)) 
    {
        SERVMSG("QueryService called", _pbc, _pbsc);

        if (IsEqualIID(riid, IID_IBindCtx) && _pbc) 
        {
            *ppvObj = _pbc;
            _pbc->AddRef();
        }
        else if (IsEqualIID(riid, IID_IBindStatusCallback) && _pbsc)
        {
            *ppvObj = _pbsc;
            _pbsc->AddRef();
        }         
        else
        {
            return QueryInterface(riid, ppvObj);
        }
    }
    else if (IsEqualIID(guidService, SID_PendingBindStatusCallback)) 
    {
        if (IsEqualIID(riid, IID_IBindStatusCallback) && _pbscPending)
        {
            *ppvObj = _pbscPending;
            _pbscPending->AddRef();
        }
    } 
    else if (_psp) 
    {
        return _psp->QueryService(guidService, riid, ppvObj);
    }

    return *ppvObj ? S_OK : E_FAIL;
}


HRESULT CIEFrameAuto::Exec(
    /* [unique][in] */ const GUID *pguidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [in] */ DWORD nCmdexecopt,
    /* [unique][in] */ VARIANTARG *pvarargIn,
    /* [unique][out][in] */ VARIANTARG *pvarargOut)
{
    HRESULT hres = S_OK;

    if (pguidCmdGroup)
    {
        if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
        {
            switch(nCmdID)
            {
            case SBCMDID_CANCELNAVIGATION:
                _CancelPendingNavigation(NULL);
                break;

            case SBCMDID_SELECTHISTPIDL:
            case SBCMDID_HISTSFOLDER:
                if (_poctFrameTop)
                    hres = _poctFrameTop->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                else
                    hres = S_OK;
                break;

            case SBCMDID_IESHORTCUT:
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
                // If this is an IE shortcut and browse in a new process is turned on
                // and we are explorer.exe - we should pass on the request to navigate to
                // this shortcut. The caller is expected to create a new window/process to
                // launch this shortcut
                if (IsBrowseNewProcessAndExplorer())  
                    hres = E_FAIL;
                else
#endif
                    hres = _NavIEShortcut(pvarargIn,pvarargOut);
                
                break;

            case SBCMDID_GETSHORTCUTPATH:
               if (_pwszShortcutPath && pvarargOut)
               {
                    pvarargOut->bstrVal = SysAllocString(_pwszShortcutPath);
                    if (pvarargOut->bstrVal)
                        pvarargOut->vt = VT_BSTR;        //no need to set hres=S_OK since it is inited already
                    else 
                        hres = E_OUTOFMEMORY;
               }
               else 
               {
                    if (pvarargOut)
                        pvarargOut->vt = VT_EMPTY;

                    hres = E_FAIL;
               }
               
               break;    
            default:
                hres = OLECMDERR_E_NOTSUPPORTED; 
            }
        }
        else if (IsEqualGUID(CGID_ShortCut, *pguidCmdGroup))
        {
            if (_poctFrameTop) // we must check!
                hres = _poctFrameTop->Exec(&CGID_ShortCut, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            else
                hres = OLECMDERR_E_NOTSUPPORTED;
        } 
        else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
        {
            switch (nCmdID)
            {
                case SHDVID_DELEGATEWINDOWOM:
                    _omwin.SetDelegationPolicy(V_BOOL(pvarargIn));
                    break;
                default:
                    hres = OLECMDERR_E_NOTSUPPORTED;
            }
        }
        else if (IsEqualGUID(CGID_InternetExplorer, *pguidCmdGroup))
        // CGID_InternetExplorer are public defined in msiehost.h
        {
            switch (nCmdID)
            {
                case IECMDID_CLEAR_AUTOCOMPLETE_FOR_FORMS:
                {
                    if (pvarargIn->vt == VT_I4)
                    {
                        hres = ClearAutoSuggestForForms(V_I4(pvarargIn));
                    }
                    else
                        hres = E_INVALIDARG;
                }
                break;

                case IECMDID_SETID_AUTOCOMPLETE_FOR_FORMS:
                {
                    if ((pvarargIn->vt == VT_UI8) ||
                        (pvarargIn->vt == VT_I8))
                    {
                        hres = SetIdAutoSuggestForForms(((GUID *)(&pvarargIn->ullVal)), _omwin.IntelliForms());
                    }
                    else
                        hres = E_INVALIDARG;
                }
                break;

                default:
                    hres = OLECMDERR_E_NOTSUPPORTED;
            }
        }
        else
        {
            hres = OLECMDERR_E_UNKNOWNGROUP;
        }
    }
    else
    {
        hres = OLECMDERR_E_UNKNOWNGROUP;
    }

    return hres;
}


BOOL CIEFrameAuto::_fNavigationPending()
{
    // unfortunately, the hyperlink frame doesn't REALLY know when there's
    // a navigation pending or not because people might not call OnReleaseNavigation.
    // only the real browser knows.

    if (_pmsc) 
    {
        MSOCMD rgCmd;
        rgCmd.cmdID = SBCMDID_CANCELNAVIGATION;
        rgCmd.cmdf = 0;

        _pmsc->QueryStatus(&CGID_Explorer, 1, &rgCmd, NULL);
        return (rgCmd.cmdf & MSOCMDF_ENABLED);
    }
    return FALSE;
}

HRESULT CIEFrameAuto::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        for (ULONG i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SBCMDID_CANCELNAVIGATION:
                rgCmds[i].cmdf = _fNavigationPending() ? MSOCMDF_ENABLED : 0;
                break;

            case SBCMDID_WRITEHIST:
                rgCmds[i].cmdf = _fSuppressHistory ? 0:MSOCMDF_ENABLED;
                break;
            
            case SBCMDID_SELECTHISTPIDL:
                rgCmds[i].cmdf = _fSuppressSelect || !_poctFrameTop ? 0:MSOCMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
    }
    else
    {
        return OLECMDERR_E_UNKNOWNGROUP;
    }

    if (pcmdtext)
    {
        pcmdtext->cmdtextf = MSOCMDTEXTF_NONE;
        pcmdtext->cwActual = 0;
    }

    return NOERROR;
}

HRESULT CIEFrameAuto::_PidlFromUrlEtc(UINT uiCP, LPCWSTR pszUrl, LPWSTR pszLocation, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;      // assumes error

    // ALGORITHM:
    //  - First, we call IEParseDisplayName to generate the pidl
    //    to the specified URL or file name.
    //  - if we have fragment (pszLocation) specified,
    //    we call IEILAppendFragment() to add the hidden fragment id
    if (_pbs == NULL)  //Make sure we have a IBrowserService.
        return (S_FALSE);
        
    HRESULT hr = _pbs->IEParseDisplayName(uiCP, pszUrl, ppidl);

    // This is ugly, if it's a file path that failed to parse because
    // it doesn't exist, we want to create a SimpleIDList so we display
    // a res: navigation failed IFrame instead of the err dlg displayed
    // in DisplayParseError() below.
    if (FAILED(hr)) 
    {
        TCHAR szPath[MAX_PATH];
        DWORD cchBuf = ARRAYSIZE(szPath);

        // If it's a FILE URL, convert it to a path.
        if (IsFileUrlW(pszUrl) && SUCCEEDED(PathCreateFromUrl(pszUrl, szPath, &cchBuf, 0)))
        {
            // That worked, we are done because our buffer is now full.
        }
        else        
        {
            // We now need to copy to the buffer and we assume it's a path.
            StrCpyN(szPath, pszUrl, ARRAYSIZE(szPath));
        }

        *ppidl = SHSimpleIDListFromPath(szPath);
        if (*ppidl)
            hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (pszLocation && *pszLocation)
        {
            *ppidl = IEILAppendFragment(*ppidl, pszLocation);
            hr = *ppidl ? S_OK : E_OUTOFMEMORY;
        }
    } 
    else 
    {
        //
        // NOTES: This behavior is new in IE4.0. We are adding
        //  this message box based on the request (bug-report)
        //  from Office guys. (SatoNa)
        //
        hr = _pbs->DisplayParseError(hr, pszUrl);
    }
    return hr;
}

HRESULT CIEFrameAuto::_NavIEShortcut(VARIANT *pvarIn, VARIANT *pvarargOut)
{
    //  need to validate verb and clsid
    HRESULT hr = E_ACCESSDENIED;
    READYSTATE ready;
    BOOL fForceNavigate = pvarargOut ? ((VT_BOOL == pvarargOut->vt ) && (pvarargOut->boolVal)) : FALSE;
    
    get_ReadyState(&ready);

    ASSERT(pvarIn);
    ASSERT(pvarIn->vt == VT_BSTR);
    //
    //  we dont want to allow the exec to go through if this window
    //  is busy with something else.  we should probably allow
    //  READYSTATE_COMPLETE and READYSTATE_UNINITIALIZED.
    //  if we use READYSTATE_UNINITIALIZED, we need to init the browser
    //  and make it visible and stuff like that.  something to the 
    //  check that IPersisteHistory->LoadHistory() does in shvocx.cpp.
    //  right now we will only allow COMPLETE.
    //
    TraceMsgW(DM_SHELLEXECOBJECT, "[%X] IEAuto_NavIEShortcut entered '%s' ready = %d", this, pvarIn->bstrVal, ready);

    
    if (((ready == READYSTATE_COMPLETE || ready == READYSTATE_UNINITIALIZED) || (fForceNavigate))
        && S_OK == IUnknown_Exec(_psbTop, &CGID_Explorer, SBCMDID_ISIEMODEBROWSER, 0, NULL, NULL))
        
    {
        IPersistFile *ppf;
        if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_ALL, IID_PPV_ARG(IPersistFile, &ppf))))
        {
            if (SUCCEEDED(ppf->Load(pvarIn->bstrVal, STGM_READ)))
            {
                LPWSTR pszUrl = NULL;
                TraceMsg(DM_SHELLEXECOBJECT, "[%X] IEAuto_NavIEShortcut shortcut inited with file", this);

                IUniformResourceLocatorW *purl;
                if (SUCCEEDED(ppf->QueryInterface(IID_PPV_ARG(IUniformResourceLocatorW, &purl))))
                {
                    purl->GetURL(&pszUrl);
                    purl->Release();
                }
                
                if (pszUrl)
                {
                    TraceMsgW(DM_SHELLEXECOBJECT, "[%X] IEAuto_NavIEShortcut found %s", this, pszUrl);
                    
                    LPITEMIDLIST pidl;
                    IEParseDisplayNameW(CP_ACP, pszUrl, &pidl);
                    if (pidl)
                    {
                        ASSERT(NULL == _pwszShortcutPathPending);
                        if (_pwszShortcutPathPending)
                            LocalFree(_pwszShortcutPathPending);

                        _pwszShortcutPathPending = StrDupW(pvarIn->bstrVal);

                        hr = _BrowseObject(pidl, SBSP_SAMEBROWSER);

                        if (SUCCEEDED(hr))
                        {
                            if (ready == READYSTATE_UNINITIALIZED)
                                put_Visible(VARIANT_TRUE);
                            HWND hwnd = _GetHWND();
                            if (hwnd)
                            {
                                if (IsIconic(hwnd))
                                    ShowWindow(hwnd, SW_RESTORE);
                                else
                                    SetForegroundWindow(hwnd);
                            }
                        }
                        ILFree(pidl);
                    }
                    SHFree(pszUrl);
                }
            }
            ppf->Release();
        }
    }
    TraceMsg(DM_SHELLEXECOBJECT, "IEAuto_NavIEShortcut returns 0x%X", hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hlframe.h ===
#ifndef _HLFRAME_H_
#define _HLFRAME_H_

#include "iface.h"
#include <mshtml.h>
#include "cnctnpt.h"
#include "dspsprt.h"
#include "expdsprt.h"
#include "caggunk.h"
#include <opsprof.h>
#include <msiehost.h>
#include "iforms.h"
#include <limits.h>

#ifdef _USE_PSTORE_
#include "pstore.h"
#else
#include "wab.h"
#endif  // _USE_PSTORE_

#ifndef HLNF_EXTERNALNAVIGATE
#define HLNF_EXTERNALNAVIGATE 0x10000000
#endif

#ifndef HLNF_ALLOW_AUTONAVIGATE
#define HLNF_ALLOW_AUTONAVIGATE 0x20000000
#endif

// structure for information about event sinks we hold
typedef struct tagSINKINFO {
    LPUNKNOWN pUnknown;
    IConnectionPoint *pCP; // the connection point we're connected to
    DWORD dwConnectionCookie;
} SINKINFO;

// Helper function in mshtml.dll.
typedef HRESULT (STDAPICALLTYPE *PFN_MatchExactGetIDsOfNames)(ITypeInfo *pTI,
                                               REFIID riid,
                                               LPOLESTR *rgzNames,
                                               UINT cNames,
                                               LCID lcid,
                                               DISPID *rgdispid,
                                               BOOL fCaseSensitive);
STDAPI ResetProfileSharing(HWND hwin);

class CIEFrameAutoProp;

class CIEFrameAuto : protected CImpIDispatch
        , public IWebBrowser2
        , public CImpIConnectionPointContainer
        , public CImpIExpDispSupport
        , public IExternalConnection
        , public IShellService
        , public IHlinkFrame
        , public IServiceProvider
        , public IUrlHistoryNotify
        , public ITargetFrame2
        , public ITargetNotify
        , public ITargetFramePriv
        , public CAggregatedUnknown
        , public IEFrameAuto
        , public IWebBrowserPriv
{

public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CAggregatedUnknown::QueryInterface(riid, ppvObj); }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CAggregatedUnknown::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CAggregatedUnknown::Release(); }

    /* forward IDispatch to CImpIDispatch */
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames, LCID lcid, DISPID FAR* rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    /* IWebBrowser methods */
    STDMETHOD(GoBack)(THIS);
    STDMETHOD(GoForward)(THIS);
    STDMETHOD(GoHome)(THIS);
    STDMETHOD(GoSearch)(THIS);
    STDMETHOD(Navigate)(THIS_ BSTR URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers);
    STDMETHOD(Refresh)(THIS);
    STDMETHOD(Refresh2)(THIS_ VARIANT FAR* Level);
    STDMETHOD(Stop)(THIS);
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_Container)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_Document)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_TopLevelContainer)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrType);
    STDMETHOD(get_Left)(THIS_ long FAR* pl);
    STDMETHOD(put_Left)(THIS_ long Left);
    STDMETHOD(get_Top)(THIS_ long FAR* pl);
    STDMETHOD(put_Top)(THIS_ long Top);
    STDMETHOD(get_Width)(THIS_ long FAR* pl);
    STDMETHOD(put_Width)(THIS_ long Width);
    STDMETHOD(get_Height)(THIS_ long FAR* pl);
    STDMETHOD(put_Height)(THIS_ long Height);
    STDMETHOD(get_LocationName)(THIS_ BSTR FAR* pbstrLocationName);
    STDMETHOD(get_LocationURL)(THIS_ BSTR FAR* pbstrLocationURL);
    STDMETHOD(get_Busy)(THIS_ VARIANT_BOOL FAR* pBool);

    /* IWebBrowserApp methods */
    STDMETHOD(Quit)(THIS);
    STDMETHOD(ClientToWindow)(THIS_ int FAR* pcx, int FAR* pcy);
    STDMETHOD(PutProperty)(THIS_ BSTR szProperty, VARIANT vtValue);
    STDMETHOD(GetProperty)(THIS_ BSTR szProperty, VARIANT FAR* pvtValue);
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName);
    STDMETHOD(get_HWND)(THIS_ LONG_PTR* pHWND);
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* pbstrFullName);
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pbstrPath);
    STDMETHOD(get_FullScreen)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_FullScreen)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusBar)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_StatusBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusText)(THIS_ BSTR FAR* pbstr);
    STDMETHOD(put_StatusText)(THIS_ BSTR bstr);
    STDMETHOD(get_ToolBar)(THIS_ int FAR* pBool);
    STDMETHOD(put_ToolBar)(THIS_ int Value);
    STDMETHOD(get_MenuBar)(THIS_ VARIANT_BOOL FAR* pValue);
    STDMETHOD(put_MenuBar)(THIS_ VARIANT_BOOL Value);

    // IWebBrowser2 methods
    STDMETHOD(Navigate2)(THIS_ VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers);
    STDMETHOD(ShowBrowserBar)(THIS_ VARIANT FAR* pvaClsid, VARIANT FAR* pvaShow, VARIANT FAR* pvaSize);
    STDMETHOD(QueryStatusWB)(THIS_ OLECMDID cmdID, OLECMDF FAR* pcmdf);
    STDMETHOD(ExecWB)(THIS_ OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT FAR* pvaIn, VARIANT FAR* pvaOut);
    STDMETHOD(get_ReadyState)(THIS_ READYSTATE FAR* plReadyState);
    STDMETHOD(get_Offline)(THIS_ VARIANT_BOOL FAR* pbOffline);
    STDMETHOD(put_Offline)(THIS_ VARIANT_BOOL bOffline);
    STDMETHOD(get_Silent)(THIS_ VARIANT_BOOL FAR* pbSilent);
    STDMETHOD(put_Silent)(THIS_ VARIANT_BOOL bSilent);
    STDMETHOD(get_RegisterAsBrowser)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsBrowser)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_RegisterAsDropTarget)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsDropTarget)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_TheaterMode)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_TheaterMode)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_AddressBar)(THIS_ VARIANT_BOOL FAR* Value);
    STDMETHOD(put_AddressBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Resizable)(THIS_ VARIANT_BOOL FAR* Value);
    STDMETHOD(put_Resizable)(THIS_ VARIANT_BOOL Value);

    // IWebBrowserPriv
    STDMETHOD(NavigateWithBindCtx)(VARIANT FAR * pvarUrl,
                                   VARIANT FAR * pvarFlags,
                                   VARIANT FAR * pvarTargetFrameName,
                                   VARIANT FAR * pvarPostData,
                                   VARIANT FAR * pvarHeaders,
                                   IBindCtx    * pBindCtx,
                                   BSTR          bstrLocation);
    STDMETHOD(OnClose)();

    // *** CImpIConnectionPointContainer ***
    virtual STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS FAR* ppEnum);

    // *** CImpIExpDispSupport override ***
    virtual STDMETHODIMP OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);

    // *** IExternalConnection ***
    virtual DWORD __stdcall AddConnection(DWORD extconn, DWORD reserved);
    virtual DWORD __stdcall ReleaseConnection(DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses);

    // *** IShellService ***
    virtual STDMETHODIMP SetOwner(IUnknown* punkOwner);

    // *** IEFrameAuto ***
    virtual STDMETHODIMP SetOwnerHwnd(HWND hwndOwner);
    virtual STDMETHODIMP put_DefaultReadyState(DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState);
    virtual STDMETHODIMP OnDocumentComplete(void);
    virtual STDMETHODIMP OnWindowsListMarshalled(void);
    virtual STDMETHODIMP SetDocHostFlags(DWORD dwDocHostFlags);

    DWORD GetDocHostFlags() { return _dwDocHostInfoFlags; };

    // Embed our Connection Point object - implmentation in cnctnpt.cpp
    CConnectionPoint m_cpWebBrowserEvents;
    CConnectionPoint m_cpWebBrowserEvents2;
    CConnectionPoint m_cpPropNotify;

    HRESULT put_Titlebar(BOOL fValue);

    // Embed handler for defunct ITargetFrame interface for backwards compat.
    // HTML frames - implementation in iedisp.cpp
    class CTargetFrame : public ITargetFrame {
        friend CIEFrameAuto;

        public:

        // IUnknown methods
        //
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        // ITargetFrame methods
        //
        virtual STDMETHODIMP SetFrameName(LPCOLESTR pszFrameName);
        virtual STDMETHODIMP GetFrameName(LPOLESTR *ppszFrameName);
        virtual STDMETHODIMP GetParentFrame(LPUNKNOWN *ppunkParentFrame);
        virtual STDMETHODIMP FindFrame(LPCOLESTR pszTargetName, LPUNKNOWN punkContextFrame, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame);
        virtual STDMETHODIMP SetFrameSrc(LPCOLESTR pszFrameSrc);
        virtual STDMETHODIMP GetFrameSrc(LPOLESTR *ppszFrameSrc);
        virtual STDMETHODIMP GetFramesContainer(LPOLECONTAINER *ppContainer);
        virtual STDMETHODIMP SetFrameOptions(DWORD dwFlags);
        virtual STDMETHODIMP GetFrameOptions(LPDWORD pdwFlags);
        virtual STDMETHODIMP SetFrameMargins(DWORD dwWidth, DWORD dwHeight);
        virtual STDMETHODIMP GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight);
        virtual STDMETHODIMP RemoteNavigate(ULONG cLength,ULONG *pulData);
        virtual STDMETHODIMP OnChildFrameActivate(LPUNKNOWN pUnkChildFrame) { return S_OK; }
        virtual STDMETHODIMP OnChildFrameDeactivate(LPUNKNOWN pUnkChildFrame) { return S_OK; }
    } _TargetFrame;
    friend class CTargetFrame;

    // IHlinkFrame
    virtual STDMETHODIMP GetBrowseContext(IHlinkBrowseContext **ppihlbc);
    virtual STDMETHODIMP OnNavigate(
        /* [in] */ DWORD grfHLNF,
        /* [unique][in] */ IMoniker *pimkTarget,
        /* [unique][in] */ LPCWSTR pwzLocation,
        /* [unique][in] */ LPCWSTR pwzFriendlyName,
        /* [in] */ DWORD dwreserved) ;

    virtual STDMETHODIMP UpdateHlink(ULONG uHLID, 
        IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName) 
            { return E_NOTIMPL;};

    virtual STDMETHODIMP SetBrowseContext(
            /* [unique][in] */ IHlinkBrowseContext *pihlbc);

#ifdef OLD_HLIFACE
    virtual STDMETHODIMP PrepareForNavigation(
             DWORD grfHLBF, LPBC pbc,
             IBindStatusCallback *pibsc, IHlink *pihlNavigate);
    virtual STDMETHODIMP Navigate(
             DWORD grfHLNF, IHlink *pihlNavigate);
    virtual STDMETHODIMP OnReleaseNavigationState(
             IHlink *pihlNavigate, DWORD dwReserved);
#else

    virtual STDMETHODIMP Navigate(
        /* [in] */ DWORD grfHLNF,
        /* [in] */ LPBC pbc,
        /* [in] */ IBindStatusCallback *pibsc,
        /* [in] */ IHlink *pihlNavigate);


#endif

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // IOleCommandTarget and IUrlHistoryNotify
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    
    // *** ITargetFrame2 ***
    virtual STDMETHODIMP SetFrameName(LPCOLESTR pszFrameName);
    virtual STDMETHODIMP GetFrameName(LPOLESTR *ppszFrameName);
    virtual STDMETHODIMP GetParentFrame(LPUNKNOWN *ppunkParentFrame);
    virtual STDMETHODIMP SetFrameSrc(LPCOLESTR pszFrameSrc);
    virtual STDMETHODIMP GetFrameSrc(LPOLESTR *ppszFrameSrc);
    virtual STDMETHODIMP GetFramesContainer(LPOLECONTAINER *ppContainer);
    virtual STDMETHODIMP SetFrameOptions(DWORD dwFlags);
    virtual STDMETHODIMP GetFrameOptions(LPDWORD pdwFlags);
    virtual STDMETHODIMP SetFrameMargins(DWORD dwWidth, DWORD dwHeight);
    virtual STDMETHODIMP GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight);
    virtual STDMETHODIMP FindFrame(LPCWSTR pszTargetName,DWORD dwFlags,LPUNKNOWN *ppunkTargetFrame);
    virtual STDMETHODIMP GetTargetAlias(LPCOLESTR pszTargetName, LPOLESTR *ppszTargetAlias);

    // *** ITargetFramePriv ***
    virtual STDMETHODIMP FindFrameDownwards(LPCWSTR pszTargetName, DWORD dwFlags,LPUNKNOWN *ppunkTargetFrame);
    virtual STDMETHODIMP FindFrameInContext(LPCWSTR pszTargetName, LPUNKNOWN punkContextFrame,DWORD dwFlags,LPUNKNOWN *ppunkTargetFrame);
    virtual STDMETHODIMP OnChildFrameActivate(LPUNKNOWN pUnkChildFrame) { return E_NOTIMPL; }
    virtual STDMETHODIMP OnChildFrameDeactivate(LPUNKNOWN pUnkChildFrame) { return E_NOTIMPL; }
    virtual STDMETHODIMP NavigateHack(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation);    
    virtual STDMETHODIMP FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser);

    // *** ITargetNotify ***
    virtual STDMETHODIMP OnCreate(LPUNKNOWN pUnkDestination, ULONG cbCookie);
    virtual STDMETHODIMP OnReuse(LPUNKNOWN pUnkDestination);

protected:
    void Exception(WORD wException);
    HWND    _GetHWND(void);
    HRESULT _PidlFromUrlEtc(UINT uiCP, LPCWSTR pszUrl, LPWSTR pszLocation, LPITEMIDLIST* ppidl);
    HRESULT _BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    HRESULT _GoStdLocation(DWORD dwWhich);
    HRESULT _NavigateMagnum(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation, IHlink *pihlNavigate, IMoniker *pmkTarget);

    //  methods to pass the referring url to a new window
    HRESULT _ReferrerHack(LPCWSTR pszUrl);
    void    _SetReferrer(LPTARGETFRAMEPRIV ptgfp);

    // *** misc helper methods for ITargetFrame implementation
    void _SetPendingNavigateContext(LPBC pbc, IBindStatusCallback *pibsc);
    void _ActivatePendingNavigateContext(void);
    HRESULT _JumpTo(LPBC pbc, LPWSTR pszLocation, DWORD grfHLNF, IBindStatusCallback __RPC_FAR *pibsc,
            /* [in] */ IHlink __RPC_FAR *pihlNavigate, LPCWSTR pszFrameName, LPCWSTR pszUrl);
    void _CancelPendingNavigation(VARIANTARG* pvar);
    BOOL _fNavigationPending();
    HRESULT _DoNamedTarget(LPCOLESTR pszTargetName, LPUNKNOWN punkContextFrame, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame);
    HRESULT _GetOleObject(IOleObject** ppobj);
    IShellView* _GetShellView(void);
    HRESULT _get_Location(BSTR FAR* pbstr, UINT uFlags);
    void _ClearPropertyList(void);
    HRESULT _WaitForNotify();
    HRESULT _RegisterCallback(TCHAR  *szFrameName, LPTARGETNOTIFY ptgnNotify);
    HRESULT _RevokeCallback();
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);
    HRESULT _QueryDelegate(IDispatch **pidDelegate);
    HRESULT _QueryPendingUrl(VARIANT *pvarResult);
    HRESULT _RetryNavigate();
    HRESULT _QueryPendingDelegate(IDispatch **ppDisp, VARIANT *pvarargIn);
    BOOL    _fDesktopComponent();
    HRESULT _GetParentFramePrivate(LPUNKNOWN *ppunkParentFrame);

    HRESULT _FindWindowByName(IOleContainer * pOleContainer,
                              LPCOLESTR       pszTargetName,
                              LPUNKNOWN     * ppunkTargetFrame);

    HRESULT _NavigateHelper(BSTR URL,
                            VARIANT  * Flags,
                            VARIANT  * TargetFrameName,
                            VARIANT  * PostData,
                            VARIANT  * Headers,
                            IBindCtx * pNavBindCtx  = NULL,
                            BSTR       bstrLocation = NULL);

    HRESULT _NavIEShortcut(VARIANT *pvarIn, VARIANT *pvarFlags);
    void     _HandleOpenOptions( IUnknown * pUnkDestination, ITargetNotify * ptgnNotify);
    
    // constructor and destructor are private...
    // use CIEFrameAuto_CreateInstance to get at this object
    CIEFrameAuto(IUnknown* punkAgg=NULL);
    ~CIEFrameAuto();
    friend HRESULT CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk);
    friend HRESULT GetRootDelegate( CIEFrameAuto* pauto, IDispatch ** const ppRootDelegate );
    friend DWORD OpenAndNavigateToURL(CIEFrameAuto *pauto, BSTR *pbstrURL, const WCHAR *pwzTarget, ITargetNotify *pNotify, BOOL bNoHistory, BOOL bSilent);

    // Member variables for automation
    IBrowserService *_pbs;
    ITypeInfo      *_pITI;      //Type information
    HWND            _hwnd;
    UINT            _cLocks;
    CIEFrameAutoProp *_pProps;
    DWORD           _dwDefaultReadyState;
    BOOL            m_bOffline:1; // Indicates if this frame is offline or not
    BOOL            m_bSilent:1; // Indicates if this frame is silent or not
    DWORD           _dwDocHostInfoFlags;    // Flags from GetHostInfo (CDocObjectHost)

    // for IHlinkFrame implementation
    IServiceProvider*           _psp;       // browser
    LPBC                        _pbc;
    IBindStatusCallback *       _pbsc;
    LPBC                        _pbcPending;
    IBindStatusCallback *       _pbscPending;
    IShellBrowser*              _psb;
    IShellBrowser*              _psbTop;
    IShellBrowser*              _psbFrameTop;
    IOleCommandTarget*          _poctFrameTop;
    IShellBrowser*              _psbProxy;
    IOleCommandTarget*          _pmsc;
    IHlinkBrowseContext*        _phlbc;
    LPWSTR                      _pwszShortcutPath;
    LPWSTR                      _pwszShortcutPathPending;
    DWORD                       _dwRegHLBC;
    BOOL                        _fBusy:1;
    BOOL                        _fRegistered:1;
    BOOL                        _fDesktopFrame:1;
    BOOL                        _fSuppressHistory:1;
    BOOL                        _fSuppressSelect:1;
    BOOL                        _fWindowsListMarshalled:1;
    BOOL                        _fRegisterAsBrowser:1;
    BOOL                        _fQuitInProgress:1;
    long                        _cbCookie;
    LPTARGETNOTIFY              _ptgnNotify;
    DWORD                       _dwTickPropertySweep;   

    // for ITargetFrame implementation
    LPOLESTR m_pszFrameName;    // Name of our frame
    LPOLESTR m_pszFrameSrc;     // Original source of our frame (for embedded OC's)
    DWORD m_dwFrameOptions;     // Frame options
    DWORD m_dwFrameMarginWidth; // Frame marginwidth
    DWORD m_dwFrameMarginHeight;// Frame marginheight


    HINSTANCE           _hinstMSHTML;
    PFN_MatchExactGetIDsOfNames _pfnMEGetIDsOfNames;

    class CAutomationStub : public IDispatchEx, public IProvideClassInfo
    {
        friend class CIEFrameAuto;
    public:
        CAutomationStub( DISPID min, DISPID max, BOOL fOwnDefaultDispid );
        HRESULT Init( void *instance, REFIID iid, REFIID clsid, CIEFrameAuto *pauto );
        virtual ~CAutomationStub();

        // Only used internally so we don't need to Addref
        CIEFrameAuto *IEFrameAuto() const { return _pAuto; }
        
        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);
        
        // *** IDispatch members ***
        virtual STDMETHODIMP GetTypeInfoCount(UINT *);
        virtual STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        virtual STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        virtual STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);       
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex);
        STDMETHODIMP DeleteMemberByDispID(DISPID id);
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);

        // *** IProvideClassInfo members ***
        STDMETHODIMP GetClassInfo( ITypeInfo** ppTI );

    protected:
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const ) = 0;
        virtual HRESULT _InternalQueryInterface( REFIID riid, void** const ppvObj ) = 0;

        CIEFrameAuto *_pAuto;

    private:
        HRESULT ResolveTypeInfo2( );

        void *_pInstance;
        ITypeInfo2 *_pInterfaceTypeInfo2;
        ITypeInfo2 *_pCoClassTypeInfo2;
        BOOL _fLoaded;
        IID   _iid;
        CLSID _clsid;
        const DISPID _MinDispid;
        const DISPID _MaxDispid;
        const BOOL _fOwnDefaultDispid;
    };
    friend class CAutomationStub;

public:
    class COmWindow :
        public IHTMLWindow2,
        public CAutomationStub,
        public ITargetNotify,
        public IShellHTMLWindowSupport2,
        public IProvideMultipleClassInfo,
        public IConnectionPointCB,
        public IConnectionPointContainer,
        public IServiceProvider,
#ifndef NO_MARSHALLING
        public IHTMLWindow3
#else
        public IHTMLWindow3,
        public IWindowStatus
#endif
    {
    public:
        friend class CIEFrameAuto;
    
        COmWindow();
        HRESULT Init();
        ~COmWindow() { VariantClear(&_varOpener); UnsinkDelegate(); DestroyIntelliForms( ); }
        HRESULT DeInit( ) { VariantClear(&_varOpener); return S_OK; }

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IHTMLFramesCollection2 ***
        STDMETHODIMP item( VARIANT *pvarIndex, VARIANT* pvarResult );
        STDMETHODIMP get_length(long* pl);


        // *** IHTMLWindow2 ***
        STDMETHODIMP get_name (BSTR FAR* retval);
        STDMETHODIMP put_name (BSTR theName);
        STDMETHODIMP get_parent(IHTMLWindow2** retval);
        STDMETHODIMP get_top(IHTMLWindow2** retval);
        STDMETHODIMP get_self(IHTMLWindow2** retval);
        STDMETHODIMP get_opener(VARIANT* retval);
        STDMETHODIMP put_opener(VARIANT opener);
        STDMETHODIMP get_window(IHTMLWindow2** retval);
        STDMETHODIMP get_document(IHTMLDocument2** retval);
        STDMETHODIMP get_frames(IHTMLFramesCollection2** retval);
        STDMETHODIMP get_location(IHTMLLocation** retval);
        STDMETHODIMP get_navigator(IOmNavigator** retval);
        STDMETHODIMP get_history(IOmHistory** retval);
        STDMETHODIMP put_defaultStatus(BSTR statusmsg);
        STDMETHODIMP get_defaultStatus(BSTR *retval);
        STDMETHODIMP put_status(BSTR statusmsg);
        STDMETHODIMP get_status(BSTR *retval);
        STDMETHODIMP open( BSTR url, BSTR name, BSTR features, VARIANT_BOOL replace, IHTMLWindow2** ppomWindowResult );
        STDMETHODIMP alert(BSTR message);
        STDMETHODIMP close();
        STDMETHODIMP confirm(BSTR message, VARIANT_BOOL* confirmed);
        STDMETHODIMP prompt(BSTR message, BSTR defstr, VARIANT* textdata);
        STDMETHODIMP setTimeout(BSTR expression, long msec, VARIANT* language, long FAR* timerID);
        STDMETHODIMP clearTimeout(long timerID);
        STDMETHODIMP navigate(BSTR url);
        STDMETHODIMP get_Image(IHTMLImageElementFactory** retval);
        STDMETHODIMP get_event( IHTMLEventObj* * p);
        STDMETHODIMP get__newEnum(IUnknown* * p);
        STDMETHODIMP showModalDialog(BSTR dialog,VARIANT* varArgIn, VARIANT* varOptions,VARIANT* varArgOut);
        STDMETHODIMP showHelp(BSTR helpURL, VARIANT helpArg, BSTR features);
        STDMETHODIMP execScript(BSTR bstrCode, BSTR bstrLanguage, VARIANT * pvarRet);
        STDMETHODIMP get_screen( IHTMLScreen ** p);
        STDMETHODIMP get_Option(IHTMLOptionElementFactory** retval);
        STDMETHODIMP focus();
        STDMETHODIMP get_closed(VARIANT_BOOL*retval);
        STDMETHODIMP blur();
        STDMETHODIMP scroll(long x, long y);
        STDMETHODIMP put_onblur(VARIANT v);
        STDMETHODIMP get_onblur(VARIANT*p);
        STDMETHODIMP put_onfocus(VARIANT v);
        STDMETHODIMP get_onfocus(VARIANT*p);
        STDMETHODIMP put_onload(VARIANT v);
        STDMETHODIMP get_onload(VARIANT*p);
        STDMETHODIMP put_onunload(VARIANT v);
        STDMETHODIMP get_onunload(VARIANT*p);
        STDMETHODIMP put_onhelp(VARIANT v);
        STDMETHODIMP get_onhelp(VARIANT*p);
        STDMETHODIMP put_onerror(VARIANT v);
        STDMETHODIMP get_onerror(VARIANT*p);
        STDMETHODIMP put_onscroll(VARIANT v);
        STDMETHODIMP get_onscroll(VARIANT*p);
        STDMETHODIMP put_onresize(VARIANT v);
        STDMETHODIMP get_onresize(VARIANT*p);
        STDMETHODIMP get_clientInformation( IOmNavigator ** retval );
        STDMETHODIMP setInterval(BSTR expression,long msec,VARIANT* language,long* timerID);
        STDMETHODIMP clearInterval(long timerID);
        STDMETHODIMP put_offscreenBuffering(VARIANT var);
        STDMETHODIMP get_offscreenBuffering(VARIANT *retval);
        STDMETHODIMP put_onbeforeunload(VARIANT v);
        STDMETHODIMP get_onbeforeunload(VARIANT*p);
        STDMETHODIMP toString(BSTR *String);
        STDMETHODIMP scrollBy(long x, long y);
        STDMETHODIMP scrollTo(long x, long y);
        STDMETHODIMP moveTo(long x, long y);
        STDMETHODIMP moveBy(long x, long y);
        STDMETHODIMP resizeTo(long x, long y);
        STDMETHODIMP resizeBy(long x, long y);
        STDMETHODIMP get_external(IDispatch **ppDisp);

        // *** IHTMLWindow3 ***
        STDMETHODIMP get_screenTop(long*p);
        STDMETHODIMP get_screenLeft(long*p);
        STDMETHODIMP attachEvent(BSTR event, IDispatch * pDisp, VARIANT_BOOL *pResult);
        STDMETHODIMP detachEvent(BSTR event, IDispatch * pDisp);
        STDMETHODIMP setTimeout(VARIANT *pExpression, long msec, VARIANT* language, long FAR* timerID);
        STDMETHODIMP setInterval(VARIANT *pExpression, long msec, VARIANT* language, long FAR* timerID);
        STDMETHODIMP print();
        STDMETHODIMP put_onbeforeprint(VARIANT v);
        STDMETHODIMP get_onbeforeprint(VARIANT*p);
        STDMETHODIMP put_onafterprint(VARIANT v);
        STDMETHODIMP get_onafterprint(VARIANT*p);
        STDMETHODIMP get_clipboardData(IHTMLDataTransfer **ppDataTransfer);
        STDMETHOD(showModelessDialog)(BSTR strUrl, 
                                      VARIANT * pvarArgIn, 
                                      VARIANT * pvarOptions, 
                                      IHTMLWindow2 ** ppDialog);

        // *** IConnectionPointContainer ***
        STDMETHODIMP EnumConnectionPoints( LPENUMCONNECTIONPOINTS *ppEnum );
        STDMETHODIMP FindConnectionPoint( REFIID iid, LPCONNECTIONPOINT *ppCP );

        // *** IConnectionPointCB ***
        STDMETHODIMP OnAdvise(REFIID iid, DWORD cSinks, DWORD_PTR dwCookie);
        STDMETHODIMP OnUnadvise(REFIID iid, DWORD cSinks, DWORD_PTR dwCookie)  { return S_OK; }
        
        // *** ITargetNotify members ***
        STDMETHODIMP OnCreate(IUnknown *pUnkDestination, ULONG cbCookie);
        STDMETHODIMP OnReuse(IUnknown *pUnkDestination);

        // *** IShellHTMLWindowSupport ***
        STDMETHODIMP ViewReleaseIntelliForms();
        STDMETHODIMP ViewReleased();
        STDMETHODIMP ViewActivated();
        STDMETHODIMP ReadyStateChangedTo( long, IShellView* );
        STDMETHODIMP CanNavigate();
        STDMETHODIMP ActiveElementChanged(IHTMLElement * pHTMLElement);
        STDMETHODIMP IsGalleryMeta(BOOL bFlag);

        // *** IProvideMultipleClassInfo members ***
        STDMETHODIMP GetClassInfo( ITypeInfo** ppTI ) { return CAutomationStub::GetClassInfo(ppTI); }
        STDMETHODIMP GetGUID( DWORD dwGuidKind, GUID* pGUID );
        STDMETHODIMP GetMultiTypeInfoCount( ULONG *pcti );
        STDMETHODIMP GetInfoOfIndex( ULONG iti, DWORD dwFlags, ITypeInfo **pptiCoClass, DWORD *pdwTIFlags, ULONG *pcdispidReserved,IID *piidPrimary,IID *piidSource );

        // *** IServiceProvider members ***
        STDMETHODIMP QueryService(REFGUID guidService, REFIID iid, LPVOID * ppv);

#ifdef NO_MARSHALLING
        // *** IWindowStatus members ***
        STDMETHOD(IsWindowActivated)();
#endif

        enum Bogus { BOOL_NOTSET = 2 };

        // Options which apply to a newly created window
        class WindowOpenOptions
        {
        public:
            BOOL fToolbar;      // whether to show the  navigation toolbar
            BOOL fLocation;     // "        "           location bar <NYI>
            BOOL fDirectories;  // "        "           quick links <NYI>
            BOOL fStatus;       // "        "           status bar 
            BOOL fMenubar;      // "        "           menu bar <NYI>
            BOOL fScrollbars;   // "        "           scroll bars
            BOOL fResizable;    // whether the new window should be resizable
            BOOL fFullScreen;   // whether the window should be in full-screen (kiosk) mode
            BOOL fChannelMode;  // whether the window should be in Channel mode.
            BOOL fTitlebar;     // whether to show the  title bar of the window
            int iWidth;         // width of the new window
            int  iHeight;       // height of the new window
            int iLeft;          // left x-coordinate of the new window
            int iTop;           // top y-coordinate of the new window
        
            WindowOpenOptions() { ReInitialize(); }
        
            void ReInitialize()
            {
                fMenubar = TRUE; 
                fToolbar = TRUE;
                fStatus = TRUE;
                fScrollbars = TRUE;
                fResizable = TRUE; 
                fDirectories = TRUE;
                fFullScreen = BOOL_NOTSET;    // whether to use full-screen (kiosk) mode
                fChannelMode = BOOL_NOTSET;
                fLocation = BOOL_NOTSET; 
                fTitlebar = TRUE;
                iWidth = -1; 
                iHeight = -1;
                iLeft = -1;
                iTop = -1;
            }
        };

        HRESULT _GetWindowDelegate(IHTMLWindow2 **ppomwDelegate);
        HRESULT _GetWindowDelegate(IHTMLWindow3 **ppomwDelegate);

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface(REFIID riid, void ** const ppvObj);
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );
        
        WindowOpenOptions _OpenOptions;

        // *** Window Open Helper Methods ***
        BSTR _GenerateUniqueWindowName( );
        HRESULT _ApplyOpenOptions( IWebBrowser2 *pie );
        HRESULT _ParseOptionString( BSTR bstrOptionString, ITargetNotify2 * ptgnNotify2 = NULL);

    private:
        static unsigned long s_uniqueIndex;
        BOOL _fCallbackOK;
        IHTMLWindow2 *_pOpenedWindow;
        VARIANT _varOpener;
        BOOL _fIsChild;

        // Connection point stuff.
        class CWindowEventSink : public IDispatch
        {
        public:
            CWindowEventSink() { }
            ~CWindowEventSink() { }

            // *** IUnknown members ***
            STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
            STDMETHODIMP_(ULONG) AddRef(void);
            STDMETHODIMP_(ULONG) Release(void);

            // *** IDispatch members ***
            STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return E_NOTIMPL; }
            STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo)  { return E_NOTIMPL; }
            STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)   { return E_NOTIMPL; }
            STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr );
        };
        friend CWindowEventSink;
        
        // Event Data
        CWindowEventSink _wesDelegate;
        BOOL _fOnloadFired;
        
        CConnectionPoint _cpWindowEvents;
        IConnectionPoint *_pCP;
        DWORD _dwCPCookie;
               
        // Event Methods
        BOOL IsDelegateComplete( );
        HRESULT SinkDelegate( );
        HRESULT UnsinkDelegate( );
        HRESULT FireOnLoad( );
        HRESULT FireOnUnload( );

        // IntelliForms data and methods
        void *_pIntelliForms;
        HRESULT AttachIntelliForms( );
        HRESULT ReleaseIntelliForms( );
        HRESULT DestroyIntelliForms( );

        BOOL   _fIntelliFormsAskUser;
        BOOL   _fDelegateWindowOM;
 
    public:
        HRESULT IntelliFormsAskUser(LPCWSTR pwszValue);
        void   *IntelliForms() { return _pIntelliForms; }
        void    SetDelegationPolicy(BOOL fFlag) { _fDelegateWindowOM = fFlag; }		        
    }; // COmWindow

protected:
    
    friend class COmWindow;
    COmWindow  _omwin;


    class COmLocation : public IHTMLLocation, public CAutomationStub, public IObjectIdentity, public IServiceProvider
    {
    public:
        COmLocation( );
        HRESULT Init( );
        virtual ~COmLocation();

        // *** IUnknown members ***
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        virtual STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        virtual STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        virtual STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        virtual STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        virtual STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
            { return CAutomationStub::GetDispID(bstrName, grfdex, pid); }
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IObjectIdentity members ***
        STDMETHODIMP IsEqualObject(IUnknown * pUnk);

        // *** IServiceProvider members ***
        STDMETHODIMP QueryService(REFGUID guidService, REFIID iid, LPVOID * ppv);

        // properties 
        STDMETHODIMP get_href(BSTR* pbstr);
        STDMETHODIMP put_href(BSTR bstr);
        STDMETHODIMP get_protocol(BSTR* pbstr);
        STDMETHODIMP put_protocol(BSTR bstr);
        STDMETHODIMP get_hostname(BSTR* pbstr);
        STDMETHODIMP put_hostname(BSTR bstr);
        STDMETHODIMP get_host(BSTR* pbstr);
        STDMETHODIMP put_host(BSTR bstr);
        STDMETHODIMP get_pathname(BSTR* pbstr);
        STDMETHODIMP put_pathname(BSTR bstr);
        STDMETHODIMP get_search(BSTR* pbstr);
        STDMETHODIMP put_search(BSTR bstr);
        STDMETHODIMP get_hash(BSTR* pbstr);
        STDMETHODIMP put_hash(BSTR bstr);
        STDMETHODIMP get_port(BSTR* pbstr);
        STDMETHODIMP put_port(BSTR bstr)  ;
        STDMETHODIMP PrivateGet_href(BSTR* pbstr, BOOL *fdontputinhistory);

        // methods
        STDMETHODIMP reload(VARIANT_BOOL fFlag)  ;
        STDMETHODIMP replace(BSTR bstr)  ;
        STDMETHODIMP assign(BSTR bstr)  ;
        STDMETHODIMP toString(BSTR *pbstr) ;
        
        // Helper function for COmWin
        // Takes a relative URL and returns the absolute URL using this
        // location as the base
        BSTR ComputeAbsoluteUrl( BSTR bstrUrlRelative );

        void RetryNavigate();

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface(REFIID riid, void ** const ppvObj);
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );

        // Helper function for the property access functions
        // Makes sure that the URL has been parsed and returns a copy
        // of the requested field as a BSTR.
        HRESULT GetField(BSTR* bstrField, BSTR* pbstr);
        HRESULT FreeStuff( );
        HRESULT CheckUrl( );
    
        // Helper function for the property setting functions
        // Makes sure that the URL has been parsed
        // Sets the field to its new value 
        // recomposes the URL, IF fRecomposeUrl is true
        // If part of a window, tells the window to go to the new URL
        //
        //
        // @todo JavaScript has some funky behavior on field setting--
        // for example, the protocol field can be set to an entire URL.
        // We need to make sure this functionality is duplicated
        STDMETHODIMP SetField(BSTR* field, BSTR newval, BOOL fRecomposeUrl); 
        
        STDMETHODIMP ComposeUrl();
        STDMETHODIMP DoNavigate();
        STDMETHODIMP ParseUrl();
        
        BSTR m_bstrFullUrl;
        
        BSTR m_bstrProtocol;
        BSTR m_bstrHostName;
        BSTR m_bstrPort;
        BSTR m_bstrPath;
        BSTR m_bstrSearch;
        BSTR m_bstrHash;

        BOOL m_fdontputinhistory:1;        
        BOOL m_fPendingNavigate:1;
        BOOL m_fRetryingNavigate:1;

    }; // COmLocation

    friend class COmLocation;
    COmLocation _omloc;

    class CCommonCollection : public CAutomationStub
    {
    public:
        CCommonCollection();

        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);

        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        STDMETHODIMP get_length(long* retval);

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );
    };

    friend class CCommonCollection;

#ifdef UNIX
nested_cls_access:
#endif
    class CMimeTypes : public IHTMLMimeTypesCollection, public CCommonCollection
    {
    public:
        HRESULT Init( );

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }

        // *** IHTMLMimeTypesCollection members ***
        STDMETHODIMP get_length(long* retval) {return CCommonCollection::get_length(retval);}

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
    };
        
    friend class CMimeTypes;
    CMimeTypes  _mimeTypes;


    class CPlugins : public IHTMLPluginsCollection, public CCommonCollection
    {
    public:
        HRESULT Init( );

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IHTMLPluginsCollection members ***
        STDMETHODIMP get_length(long* retval) {return CCommonCollection::get_length(retval);}
        STDMETHODIMP refresh(VARIANT_BOOL fReload){ return S_OK;}

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
    };

    friend class CPlugins;
    CPlugins  _plugins;

    /*******************/
    class COpsProfile : 
                public IHTMLOpsProfile,
                public CAutomationStub,
                public IOpsProfileSimple
    {

    public:
        COpsProfile();
        ~COpsProfile();

        HRESULT Init();
    
        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
                { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }

        // Returns the named profile attribute in the second argument
        virtual     STDMETHODIMP    getAttribute(BSTR bstrAttribName, BSTR *bstrAttribValue);

        // Sets the named attirubute to the value given in the second argument
        virtual     STDMETHODIMP    setAttribute(BSTR bstrAttribName, BSTR bstrAttribValue, VARIANT vaPrefs, VARIANT_BOOL *pfSuccess);
                                                 
        // Adds a request to the list
        virtual     STDMETHODIMP    addReadRequest(BSTR bstrName, VARIANT reserved, VARIANT_BOOL *pfSuccess);
        virtual     STDMETHODIMP    addRequest  (BSTR bstrName, VARIANT reserved, VARIANT_BOOL *pfSuccess)
            { return addReadRequest(bstrName, reserved, pfSuccess);   }

        // Clears the request list
        virtual     STDMETHODIMP    clearRequest();

        // Retrieves the items in the request list
        virtual     STDMETHODIMP    doRequest(VARIANT usage, VARIANT fname, VARIANT domain, VARIANT path, VARIANT expire, VARIANT reserved);
        virtual     STDMETHODIMP    doReadRequest(VARIANT usage, VARIANT fname, VARIANT domain, VARIANT path, VARIANT expire, VARIANT reserved)
            { return  doRequest(usage, fname, domain, path, expire, reserved); }

        // Attempts to set the attributes in the change list
        virtual     STDMETHODIMP    commitChanges (VARIANT_BOOL *pfSuccess);
        virtual     STDMETHODIMP    doWriteRequest (VARIANT_BOOL *pfSuccess)
            { return  commitChanges(pfSuccess); }

        // *** IOpsProfileSimple members ***
        STDMETHODIMP    ReadProperties(long lNumProperties, const LPCWSTR szProperties[], LPWSTR szReturnValues[]);
        STDMETHODIMP    WriteProperties(long lNumProperties, const LPCWSTR szProperties[], const LPCWSTR szValues[]);

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
        virtual HRESULT _GetIDispatchExDelegate(IDispatchEx ** const delegate);

    private:      
        BOOL                _ValidateElemName(LPCWSTR, INT *pIndex = NULL);

#ifdef _USE_PSTORE_
        HRESULT             _GetPStoreTypes(BSTR bstrField, GUID *pguidType, GUID *pguidSubtype, BSTR *bstrName);
#endif  // _USE_PSTORE_

        HRESULT             _SetFieldValue(const OLECHAR *pszField, BSTR bstrValue);
        HRESULT             _GetFieldValue(const OLECHAR *pszField, BSTR * pbstrValue);
        HRESULT             _CreateStore();
        HRESULT             _ReleaseStore();
        HRESULT             _GetUsageCode(VARIANT vaUsage, LPTSTR bstrUsage, int cLen);
        BOOL                _IsLocalMachine();
        BOOL                _IsUsingSSL();
        static INT          _GetCookieSettings();

        // Common helpers for both dialogs
        static BOOL         _OPSDlg_OnClose(HWND hDlg);

        // Consent dialog functions.
        static INT_PTR      _OPSConsent_DlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
        static BOOL         _OPSConsent_OnInitDlg(HWND hDlg);
        static BOOL         _OPSConsent_ShowRequestedItems(HWND hDlg);
        static BOOL         _OPSConsent_OnCommand(HWND hDlg, UINT id, UINT nCmd);
        static BOOL         _OPSConsent_ViewCertificate(HWND hDlg);
        static BOOL         _OPSConsent_EditProfile(HWND hDlg);

        // Update dialog functions.
        static INT_PTR      _OPSUpdate_DlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
        static BOOL         _OPSUpdate_OnInitDlg(HWND hDlg);
        static BOOL         _OPSUpdate_OnCommand(HWND hDlg, UINT id, UINT nCmd);
         
        static INT          _GetAttrIndexFromName(LPCWSTR);
        static INT          _GetResourceIdFromAttrName(WCHAR *);

        static HRESULT      _StringFromBSTR(BSTR bstrSource, TCHAR *pszDest, DWORD dwDestSize);
        static HRESULT      _StringFromVariant(VARIANT *vaSource, TCHAR *pszDest, DWORD dwDestSize);

#ifdef _USE_PSTORE_
        PST_PROVIDERID      m_provID;
        IPStore            *m_pStore;
#else
        BOOL                m_bWABInit;
        HMODULE             m_hInstWAB;
        LPADRBOOK           m_lpAdrBook;
        LPWABOBJECT         m_lpWABObject;
        HRESULT             m_hrWAB;
        SBinary             m_SBMe;
#endif  // _USE_PSTORE_

        unsigned            m_iStoreRef;
        BSTR                m_bstrLastURL;
        HDPA                m_hdpaRequests;
        HDPA                m_hdpaChanges;
        BOOL                m_fEnabled;
        HKEY                m_hP3Global;
        HKEY                m_hP3Sites;

    public:        
        enum { P3_QUERY, P3_DENY, P3_GRANT, P3_REQSSL };
        enum { P3_REJECT, P3_ACCEPT };
        enum { P3_NONE, P3_GLOBAL, P3_SITELEVEL };

        // Struct for user preferences
        struct P3UserPref {

            short int   m_access;
            short int   m_lastRequest;
        };

        // Struct for holding request information
        struct OPSRequestEntry {
            
            BSTR        m_bstrName;
            BSTR        m_bstrValue;
            BSTR        m_bstrOldVal;
            BOOL        m_fAnswer;
            BOOL        m_fQuery;
            DWORD       m_dwDecision;
            P3UserPref  m_prefs;

            static      int     destWrapper(void *pEntry, void *pUnused);
            static      int     grantRequest(void *pEntry, void *pUnused);

            OPSRequestEntry(); 
            ~OPSRequestEntry();
            void grantRequest();
            void denyRequest();
            void clearValue();
        };
 
        struct AccessSettings {

            TCHAR       m_rgchDomain[INTERNET_MAX_HOST_NAME_LENGTH];
            TCHAR       m_rgchPath[MAX_PATH];
            FILETIME    m_ftExpire;
            BOOL        m_fExactDomain;
            BOOL        m_fExactPath;
            BYTE        m_rgbStdAllow[16];
            BYTE        m_rgbStdDeny[16];
        };

        typedef AccessSettings *LPACS;

        struct OPSDlgInfo {

            HDPA        m_hdpa;
            BSTR        m_bstrFName;
            TCHAR       m_rgchUsage[1024];
            TCHAR       m_rgchURL[MAX_URL_STRING];
            BOOL        m_fRemember;
            BOOL        m_fAllBlank;

            AccessSettings  *m_pacSettings;
            COpsProfile*    m_pOpsProfile;
            
            OPSDlgInfo() : m_bstrFName(NULL), m_pOpsProfile(NULL)   {}
            ~OPSDlgInfo() { SysFreeString(m_bstrFName); }
        };

        typedef struct OPSDlgInfo *LPOPSDLGINFO;
        VARIANT m_vUsage; // a-thkesa to solve Windows BUG:589837. store the usage as a member for the next use.

        BOOL        _IsP3Enabled();
        
        HRESULT     _GetUserPreference(BSTR bstrName, P3UserPref *pusrPref);
        HRESULT     _PutUserPreference(BSTR bstrName, P3UserPref usrPref);

        HRESULT     _ApplyPreferences(URL_COMPONENTS *pucComp, HDPA hdpaReqList);
        HRESULT     _ApplyGlobalSettings(HDPA hdpaReqList);
        HRESULT     _ApplySiteSettings(URL_COMPONENTS *pucComp, HDPA hdpaReqList);
        HRESULT     _ApplyDomainSettings(URL_COMPONENTS *pucComp, HKEY hkey, HDPA hdpaReqList);

        BOOL        _PathMatch(TCHAR *pszRoot, TCHAR *pszPath);
        BOOL        _DomainMatch(TCHAR *pszHostName, TCHAR *pszDomain);
        BOOL        _LegalPath(TCHAR *pszActual, TCHAR *pszReqPath);
        BOOL        _LegalDomain(TCHAR *pszActual, TCHAR *pszReqDomain);

        BOOL        _ReadBitVector(LPCBYTE ucBitVector, DWORD dwIndex);
        VOID        _WriteBitVector(LPBYTE ucBitVector, DWORD dwIndex);

        HRESULT     _GetSiteSettings(URL_COMPONENTS *pucComp, VARIANT vaDomain, VARIANT vaPath, VARIANT vaExpire, AccessSettings *pSettings);
        HRESULT     _UpdateSiteSettings(AccessSettings *pSettings, HDPA hdpaReqList);
        BOOL        _ApplySettings(AccessSettings *pac, URL_COMPONENTS *puc, HDPA hdpaReqList, DWORD *pdwLast);
        BOOL        _ReadSettingsFromRegistry(HKEY hkey, AccessSettings *pac);
        BOOL        _WriteSettingsToRegistry(HKEY hkey, AccessSettings *pac);

        BOOL        _DifferentURL();

        static  HRESULT     _FormatSiteSettings(AccessSettings *pSettings, LPTSTR rgchOut, int cLimit);
        static  HRESULT     _ClearAllSettings(HWND hwin = NULL);
        friend  HRESULT STDAPICALLTYPE ResetProfileSharing(HWND hwin);
    };  // COPSProfile

    friend class COpsProfile;
    COpsProfile _profile;
    /************/

#ifdef UNIX
protected:
#endif
    class COmNavigator : public IOmNavigator, public CAutomationStub
    {
    public:
        COmNavigator();
        HRESULT Init(CMimeTypes *pMimeTypes, CPlugins *pPlugins, COpsProfile *pProfile);
        virtual ~COmNavigator() { if(_UserAgent) SysFreeString(_UserAgent); }

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr );
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
            { return CAutomationStub::GetDispID(bstrName, grfdex, pid); }
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IOmNavigator members ***
        STDMETHODIMP get_appCodeName(BSTR* retval);
        STDMETHODIMP get_appName(BSTR* retval);
        STDMETHODIMP get_appVersion(BSTR* retval);
        STDMETHODIMP get_userAgent(BSTR* retval);
        STDMETHODIMP get_cookieEnabled(VARIANT_BOOL* retval);
        STDMETHODIMP javaEnabled(VARIANT_BOOL* enabled);
        STDMETHODIMP taintEnabled(VARIANT_BOOL* enabled);
        STDMETHODIMP get_mimeTypes (IHTMLMimeTypesCollection**);
        STDMETHODIMP get_plugins (IHTMLPluginsCollection**);
        STDMETHODIMP get_opsProfile (IHTMLOpsProfile **ppOpsProfile);
        STDMETHODIMP toString(BSTR * pbstr) ;
        STDMETHODIMP get_cpuClass(BSTR * p);
        STDMETHODIMP get_systemLanguage(BSTR * p);
        STDMETHODIMP get_browserLanguage(BSTR * p);
        STDMETHODIMP get_userLanguage(BSTR * p);
        STDMETHODIMP get_platform(BSTR * p);
        STDMETHODIMP get_appMinorVersion(BSTR * p);
        STDMETHODIMP get_connectionSpeed(long * p);
        STDMETHODIMP get_onLine(VARIANT_BOOL * p);
        STDMETHODIMP get_userProfile (IHTMLOpsProfile **ppOpsProfile) { return get_opsProfile(ppOpsProfile); }

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );

    private:
        HRESULT LoadUserAgent( );
    
        BSTR _UserAgent;
        BOOL _fLoaded;

        CMimeTypes *_pMimeTypes;
        CPlugins   *_pPlugins;
        COpsProfile *_pProfile;
    }; // COmNavigator

    friend class COmNavigator;
    COmNavigator _omnav;


    class COmHistory : public IOmHistory, public CAutomationStub
    {
    public:
    
        COmHistory();
        HRESULT Init( );
        virtual ~COmHistory() {}
        
        
        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }
        
        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
            { return CAutomationStub::GetDispID(bstrName, grfdex, pid); }
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IOmHistory members ***
        STDMETHODIMP get_length(short* retval);
        STDMETHODIMP back(VARIANT* pvargdistance);
        STDMETHODIMP forward(VARIANT* pvargdistance);
        STDMETHODIMP go(VARIANT* pvargdistance);
    
    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );

    }; // COmHistory
    friend class COmHistory;
    COmHistory _omhist;

private:
    static LONG s_cIEFrameAuto;
};


//  Creates a new window, sets frame name (if appropriate)
HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN *ppunkTargetFrame);
HRESULT GetWindowFromUnknown( IUnknown *pUnk, IHTMLWindow2 ** const pWinOut );
HRESULT _TargetTopLevelWindows(LPTARGETFRAMEPRIV ptgfpThis, LPCOLESTR pszTargetName, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame);

#endif // _HLFRAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\histband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "nscband.h"
#include "nsc.h"
#include "resource.h"
#include "dhuihand.h"
#include <varutil.h>

#include <mluisupp.h>

#define DM_HISTBAND     0x0000000
#define DM_GUIPAINS     0x40000000

#define REGKEY_HISTORY_VIEW TEXT("HistoryViewType")
#define REGKEY_DEFAULT_SIZE 0x10

#define VIEWTYPE_MAX        0x4  // A "guess" at how many viewtypes thare will be
#define VIEWTYPE_REALLOC    0x4  // How many to realloc at a time

// these are temporary
#define MENUID_SEARCH       0x4e4e

// Distance between history search go and stop buttons
#define HISTSRCH_BUTTONDIST 6 

extern HINSTANCE     g_hinst;

#define WM_SEARCH_STATE (WM_USER + 314)

class CHistBand : public CNSCBand,
                  public IShellFolderSearchableCallback
{
    friend HRESULT CHistBand_CreateInstance(IUnknown *punkOuter,
                                            IUnknown **ppunk, LPCOBJECTINFO poi);
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef (void) { return CNSCBand::AddRef();  };
    STDMETHODIMP_(ULONG) Release(void) { return CNSCBand::Release(); };
    
    // *** IOleCommandTarget methods ***
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                  DWORD nCmdID,
                  DWORD nCmdexecopt,
                  VARIANTARG *pvarargIn,
                  VARIANTARG *pvarargOut);

    // *** IOleWindow methods ***
    //  (overriding CNSCBand implementation
    STDMETHODIMP GetWindow(HWND *phwnd);

    // *** IInputObject methods ***
    //  (overriding CNSCBand/CToolBand's implementation)
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IDockingWindow methods ***
    STDMETHODIMP ShowDW(BOOL fShow);

    // *** IShellFolderSearchableCallback methods ***
    STDMETHODIMP RunBegin(DWORD dwReserved);
    STDMETHODIMP RunEnd(DWORD dwReserved);
    
protected:
    virtual void    _AddButtons(BOOL fAdd);
    virtual HRESULT _OnRegisterBand(IOleCommandTarget *poctProxy);
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl);

    ~CHistBand();

    HRESULT       _InitViewPopup();
    HRESULT       _DoViewPopup(int x, int y);
    HRESULT       _ViewPopupSelect(UINT idCmd);

#ifdef SPLIT_HISTORY_VIEW_BUTTON
    UINT          _NextMenuItem();
#endif

    HRESULT       _ChangePidl(LPITEMIDLIST);
    HRESULT       _SelectPidl(LPCITEMIDLIST pidlSelect, BOOL fCreate,
                              LPCITEMIDLIST pidlViewType = NULL,
                              BOOL fReinsert = FALSE);

    virtual HRESULT _InitializeNsc();
    LPITEMIDLIST  _GetCurrentSelectPidl(IOleCommandTarget *poctProxy = NULL);
    HRESULT       _SetRegistryPersistView(int iMenuID);
    int           _GetRegistryPersistView();
    LPCITEMIDLIST _MenuIDToPIDL(UINT uMenuID);
    int           _PIDLToMenuID(LPITEMIDLIST pidl);
    IShellFolderViewType*  _GetViewTypeInfo();
    HRESULT       _GetHistoryViews();
    HRESULT       _FreeViewInfo();

    void          _ResizeChildWindows(LONG width, LONG height, BOOL fRepaint);
    HRESULT       _DoSearchUIStuff();
    HRESULT       _ExecuteSearch(LPTSTR pszSearchString);
    HRESULT       _ClearSearch();
    IShellFolderSearchable *_EnsureSearch();
    static LRESULT CALLBACK s_EditWndSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR    CALLBACK s_HistSearchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    BOOL  _fStrsAdded;  // Strings from resource have been added as buttons on the toolbar
    LONG_PTR  _lStrOffset;

    HMENU _hViewMenu;          // an instance var so we can cache it
    UINT  _uViewCheckedItem;   // which menuitem in the View menu is checked?

    LPITEMIDLIST *_ppidlViewTypes;
    LPTSTR       *_ppszStrViewNames;
    UINT          _nViews;
    int           _iMaxMenuID;

    HWND          _hwndNSC;
    HWND          _hwndSearchDlg;
    LONG          _lSearchDlgHeight;
    LPITEMIDLIST  _pidlSearch;  // current search
    IShellFolderSearchable *_psfSearch;
    
    LPITEMIDLIST  _pidlHistory; // cache the history pidl from SHGetHistoryPIDL
    IShellFolder *_psfHistory;  // cache the history shell folder
    IShellFolderViewType  *_psfvtCache;  // view type information

    LPITEMIDLIST  _pidlLastSelect;
};

CHistBand::~CHistBand() 
{
    DestroyMenu(_hViewMenu);
    if (_pidlLastSelect)
        ILFree(_pidlLastSelect);
    if (_pidlHistory)
        ILFree(_pidlHistory);
    if (_psfHistory)
        _psfHistory->Release();
    if (_psfvtCache)
        _psfvtCache->Release();
   
    _ClearSearch(); // Frees _pidlSearch 
    if (_psfSearch)
        _psfSearch->Release();
    
    _FreeViewInfo();
}

HRESULT CHistBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CHistBand, IShellFolderSearchableCallback),  // IID_IShellFolderSearchableCallback
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
        hr = CNSCBand::QueryInterface(riid, ppvObj);
    return hr;
}

// *** IOleCommandTarget methods ***
HRESULT CHistBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                        DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hRes = S_OK;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(CLSID_HistBand, *pguidCmdGroup))
        {
            switch(nCmdID)
            {
            case FCIDM_HISTBAND_VIEW:
                if (pvarargIn && (pvarargIn->vt == VT_I4))
                {
#ifdef SPLIT_HISTORY_VIEW_BUTTON
                    if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
                        hRes = _DoViewPopup(GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal));
                    else
                        hRes = _ViewPopupSelect(_NextMenuItem());
#else
                    ASSERT(nCmdexecopt == OLECMDEXECOPT_PROMPTUSER);
                    hRes = _DoViewPopup(GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal));
#endif
                }
                else
                    ASSERT(0);
                break;
                
            case FCIDM_HISTBAND_SEARCH:
                _ViewPopupSelect(MENUID_SEARCH);
                break;
            }
        }
        else if ((IsEqualGUID(CGID_Explorer, *pguidCmdGroup)))
        {
            switch (nCmdID)
            {
            case SBCMDID_SELECTHISTPIDL:
#ifdef ANNOYING_HISTORY_AUTOSELECT
                if (_uViewCheckedItem != MENUID_SEARCH)
                {
                    LPCITEMIDLIST pidlSelect = VariantToIDList(pvarargIn);

                    // Get the current view information
                    LPCITEMIDLIST pidlView = _MenuIDToPIDL(_uViewCheckedItem);
                    DWORD dwViewFlags = SFVTFLAG_NOTIFY_CREATE;
                    IShellFolderViewType* psfvtInfo = _GetViewTypeInfo();

                    if (psfvtInfo)
                    {
                        // query for view type properties -- this will tell us how to
                        //   select the item...
                        hRes = psfvtInfo->GetViewTypeProperties(pidlView,
                                                                &dwViewFlags);
                        psfvtInfo->Release();
                    }
                    if (SUCCEEDED(hRes))
                    {
                        hRes = _SelectPidl(pidlSelect, dwViewFlags & SFVTFLAG_NOTIFY_CREATE,
                                           pidlView,   dwViewFlags & SFVTFLAG_NOTIFY_RESORT);
                    }
                    ILFree(pidlSelect);
                }
                else //eat it, so that nsc doesn't get it
                    hRes = S_OK;
#endif //ANNOYING_HISTORY_AUTOSELECT
                hRes = S_OK;
                break;
                
            case SBCMDID_FILEDELETE:
                hRes = _InvokeCommandOnItem(TEXT("delete"));
                break;
            }
        }
        else
            hRes = CNSCBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else
        hRes =  CNSCBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    return hRes;
}

// *** IInputObject methods ***
HRESULT CHistBand::TranslateAcceleratorIO(LPMSG pmsg)
{
#ifdef DEBUG
    if (pmsg->message == WM_KEYDOWN)
        TraceMsg(DM_GUIPAINS, "CHistBand -- TranslateAcceleratorIO called and _hwndSearchDlg is %x", _hwndSearchDlg);
#endif

    HWND hwndFocus = GetFocus();
    
    // Translate accelerator messages for dialog
    if ( (_hwndSearchDlg) && (hwndFocus != _hwndNSC) && (!hwndFocus || !IsChild(_hwndNSC, hwndFocus)) )
    {
        if (pmsg->message == WM_KEYDOWN)
        {
            if (IsVK_TABCycler(pmsg))
            {
                BOOL fBackwards = (GetAsyncKeyState(VK_SHIFT) < 0);
                HWND hwndCur = pmsg->hwnd;
                if (GetParent(pmsg->hwnd) != _hwndSearchDlg)
                    hwndCur = NULL;
                
                HWND hwndNext  = GetNextDlgTabItem(_hwndSearchDlg, hwndCur, fBackwards);
                
                // Get the First dialog item in this searching order
                HWND hwndFirst;
                if (!fBackwards) {
                    hwndFirst = GetNextDlgTabItem(_hwndSearchDlg, NULL, FALSE);
                }
                else
                    // passing NULL for the 2nd parameter returned NULL with ERROR_SUCCESS,
                    //  so this is a workaround
                    hwndFirst = GetNextDlgTabItem(_hwndSearchDlg,
                                                  GetNextDlgTabItem(_hwndSearchDlg,
                                                                    NULL, FALSE), TRUE);
                
                // If the next dialog tabstop is the first dialog tabstop, then
                //   let someone else get focus
                if ((!hwndCur) || (hwndNext != hwndFirst))
                {
                    SetFocus(hwndNext);
                    return S_OK;
                }
                else if (!fBackwards) {
                    SetFocus(_hwndNSC);
                    return S_OK;
                }
            }
            else if ( (pmsg->wParam == VK_RETURN) )
                SendMessage(_hwndSearchDlg, WM_COMMAND, MAKELONG(GetDlgCtrlID(pmsg->hwnd), 0), 0L);
        }
        // The History Search Edit Box is activated
        if (pmsg->hwnd == GetDlgItem(_hwndSearchDlg, IDC_EDITHISTSEARCH)) {
            // If the user pressed tab within the dialog
            return EditBox_TranslateAcceleratorST(pmsg);
        }
    }
    return CNSCBand::TranslateAcceleratorIO(pmsg);
}

// sends appropriate resize messages to our children windows
void CHistBand::_ResizeChildWindows(LONG width, LONG height, BOOL fRepaint)
{
    if (_hwndNSC)
    {
        int y1 = _hwndSearchDlg ? _lSearchDlgHeight : 0;
        int y2 = _hwndSearchDlg ? height - _lSearchDlgHeight : height;

        MoveWindow(_hwndNSC, 0, y1, width, y2, fRepaint);
    }

    if (_hwndSearchDlg)
    {
        MoveWindow(_hwndSearchDlg, 0, 0, width, _lSearchDlgHeight, fRepaint);
    }
}

HRESULT CHistBand::_DoSearchUIStuff()
{
    HRESULT hr;

    // host the search dialog inside my window:
    _hwndSearchDlg = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(DLG_HISTSEARCH2),
                                       _hwnd, s_HistSearchDlgProc, reinterpret_cast<LPARAM>(this));

    if (_hwndSearchDlg)
    {
        RECT rcSelf;
        GetClientRect(_hwnd, &rcSelf);
    
        RECT rcDlg;
        GetClientRect(_hwndSearchDlg, &rcDlg);

        _lSearchDlgHeight = rcDlg.bottom;

        _ResizeChildWindows(rcSelf.right, rcSelf.bottom, TRUE);
        ShowWindow(_hwndSearchDlg, SW_SHOWDEFAULT);

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// WndProc for main window to go in rebar
LRESULT CALLBACK CHistBand::s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CHistBand* phb = reinterpret_cast<CHistBand *>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

    switch (msg)
    {
    case WM_SETFOCUS:
        {
            TraceMsg(DM_GUIPAINS, "Histband Parent -- SETFOCUS");
            // The only way this should be called is via a RB_CYCLEFOCUS->...->UIActivateIO->SetFocus
            //  therefore, we can assume that we're being tabbed into or something with equally good.
            // If we tab into the outer dummy window, transfer the focus to
            //  our appropriate child:
            BOOL fBackwards = (GetAsyncKeyState(VK_SHIFT) < 0);
            if (phb->_hwndSearchDlg) {
                // Select either the first or the last item in the dialog depending on
                //  whether we're shifting in or shifting out
                SetFocus(GetNextDlgTabItem(phb->_hwndSearchDlg, (NULL), fBackwards));
            }
            else {
                TraceMsg(DM_GUIPAINS, "NSC is being given focus!");
                SetFocus(phb->_hwndNSC);
            }
        }
        return 0;
    case WM_CREATE:
        SetWindowLongPtr(hWnd, GWLP_USERDATA,
                      (reinterpret_cast<LONG_PTR>((reinterpret_cast<CREATESTRUCT *>(lParam))->lpCreateParams)));
        return 0;
    case WM_SIZE:
        if (phb)
            phb->_ResizeChildWindows(LOWORD(lParam), HIWORD(lParam), TRUE);
        return 0;
    case WM_NCDESTROY:
        //make sure the search object gets freed when the view/window is destroyed, because it holds a ref to us
        phb->_ClearSearch();
        break;
        
    case WM_NOTIFY:
        {
            if (phb) {
                // We proxy the notification messages to our own parent who thinks that we
                //  are the namespace control
                LPNMHDR pnmh = (LPNMHDR)lParam;
                
                // Notification message coming from NSC
                if (pnmh->hwndFrom == phb->_hwndNSC)
                    return SendMessage(phb->_hwndParent, msg, wParam, lParam);
            }
        } // INTENTIONAL FALLTHROUGH
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

// *** IOleWindow methods ***
HRESULT CHistBand::GetWindow(HWND *phwnd)
{
    if (!_hwnd)
    {
        // we want to wrap a window around the namespace control so
        //  that we can add siblings later
        
        // Get our parent's dimensions
        RECT rcParent;
        GetClientRect(_hwndParent, &rcParent);

        static LPTSTR pszClassName = TEXT("History Pane");

        WNDCLASSEX wndclass    = { 0 };
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_PARENTDC | CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = s_WndProc;
        wndclass.hInstance     = g_hinst;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = pszClassName;

        RegisterClassEx(&wndclass);
    
        _hwnd = CreateWindow(pszClassName, TEXT("History Window"),
                             WS_CHILD | WS_TABSTOP,
                             0, 0, rcParent.right, rcParent.bottom,
                             _hwndParent, NULL, g_hinst, (LPVOID)this);
    }
    
    if (_hwnd)   // Host NSC
        _pns->CreateTree(_hwnd, _GetTVStyle(), &_hwndNSC);

    return CToolBand::GetWindow(phwnd);
}

// *** IDockingWindow methods ***
HRESULT CHistBand::ShowDW(BOOL fShow)
{
    HRESULT hr = CNSCBand::ShowDW(fShow);
    _AddButtons(fShow);
    return hr;
}

static const TBBUTTON c_tbHistory[] =
{
    { I_IMAGENONE, FCIDM_HISTBAND_VIEW,   TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_WHOLEDROPDOWN | BTNS_SHOWTEXT,  {0,0}, 0, 0 },
    {           2, FCIDM_HISTBAND_SEARCH, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_SHOWTEXT,                       {0,0}, 0, 1 },
};

// Adds buttons from the above table to the Explorer
void CHistBand::_AddButtons(BOOL fAdd)
{
    // don't add button if we have no menu
    if (!_hViewMenu)
        return;

    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_IExplorerToolbar, (void**)&piet)))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CLSID_HistBand, 0);

            if (!_fStrsAdded)
            {
                piet->AddString(&CLSID_HistBand, MLGetHinst(), IDS_HIST_BAR_LABELS, &_lStrOffset);
                _fStrsAdded = TRUE;
            }

            _EnsureImageListsLoaded();
            piet->SetImageList(&CLSID_HistBand, _himlNormal, _himlHot, NULL);

            TBBUTTON tbHistory[ARRAYSIZE(c_tbHistory)];
            memcpy(tbHistory, c_tbHistory, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbHistory));
            for (int i = 0; i < ARRAYSIZE(c_tbHistory); i++)
                tbHistory[i].iString += (long) _lStrOffset;

            piet->AddButtons(&CLSID_HistBand, ARRAYSIZE(tbHistory), tbHistory);
        }
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }
}

// *** IShellFolderSearchableCallback methods ***
// enable and disable cancel buttons 
HRESULT CHistBand::RunBegin(DWORD dwReserved)
{
    HRESULT hr = E_FAIL;
    if (_hwndSearchDlg)
    {
        SendMessage(_hwndSearchDlg, WM_SEARCH_STATE, (WPARAM)TRUE, NULL);
        hr = S_OK;
    }
    return hr;
}

HRESULT CHistBand::RunEnd(DWORD dwReserved)
{
    HRESULT hr = E_FAIL;
    if (_hwndSearchDlg)
    {
        SendMessage(_hwndSearchDlg, WM_SEARCH_STATE, (WPARAM)FALSE, NULL);
        hr = S_OK;
    }
    return hr;
}

// A utility function used in the WM_SIZE handling below...
inline HWND _GetHwndAndRect(HWND hwndDlg, int item, BOOL fClient, RECT &rc) {
    HWND hwnd = GetDlgItem(hwndDlg, item);
    if (fClient)
        GetClientRect(hwnd, &rc);
    else {
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hwndDlg, ((LPPOINT)&rc), 2);
    }
    return hwnd;
}

LRESULT CALLBACK CHistBand::s_EditWndSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) {
    case WM_KEYDOWN:
        if ((GetAsyncKeyState(VK_CONTROL) < 0) &&
            (wParam == TEXT('U'))) {
            uMsg   = WM_SETTEXT;
            wParam = 0;
            lParam = ((LPARAM)(LPCTSTR)TEXT(""));
        }
        break;

    case WM_CHAR:
        if (wParam == VK_RETURN) {
            PostMessage(GetParent(hwnd), WM_COMMAND, MAKELONG(IDB_HISTSRCH_GO, 0), 0L);
            return 0L;
        }
        break;
    }
    return CallWindowProc((WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA)), hwnd, uMsg, wParam, lParam);
}


// Please see note at top of file for explanation...
INT_PTR CALLBACK CHistBand::s_HistSearchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) {
    case WM_PAINT:
        {
            // paint a little separator bar on the bottom
            PAINTSTRUCT ps;
            RECT        rcSelf;
            HDC         hdc = BeginPaint(hwndDlg, &ps);
            GetClientRect(hwndDlg, &rcSelf);
            RECT        rcFill = { 0, rcSelf.bottom - 2, rcSelf.right, rcSelf.bottom };
            FillRect(hdc, &rcFill, GetSysColorBrush(COLOR_BTNFACE));
            EndPaint(hwndDlg, &ps);
            break;
        }

    // Supply child controls with correct bkgd color
    case WM_CTLCOLORSTATIC:
        if ((HWND)lParam == GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION)) {
            SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
            return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
        }
        else {
            SetBkMode((HDC)wParam, TRANSPARENT);
            return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
        }
    case WM_CTLCOLORDLG:
        //SetBkColor((HDC)HIWORD(lParam), GetSysColor(COLOR_WINDOW));
        return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
    case WM_INITDIALOG: {
        HWND    hwndEdit       = GetDlgItem(hwndDlg, IDC_EDITHISTSEARCH);
        WNDPROC pfnOldEditProc = (WNDPROC)(GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));

        // subclass the editbox
        SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LPARAM)pfnOldEditProc);
        SetWindowLongPtr(hwndEdit, GWLP_WNDPROC,  (LPARAM)s_EditWndSubclassProc);
        
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
        Animate_Open(GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION),
                     MAKEINTRESOURCE(IDA_HISTSEARCHAVI));

        // limit the edit control to MAX_PATH-1 characters
        Edit_LimitText(hwndEdit, MAX_PATH-1);

        break;
    }
    case WM_DESTROY:
        Animate_Close(GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION));
        break;
    case WM_SIZE: {
        if (wParam == SIZE_RESTORED) {
            UINT uWidth  = LOWORD(lParam);
            UINT uHeight = HIWORD(lParam);

            RECT rcAnimSize, rcCancel, rcSearch, rcEdit, rcStatic;
            HWND hwndAnim   = _GetHwndAndRect(hwndDlg, IDD_HISTSRCH_ANIMATION, TRUE,  rcAnimSize);
            HWND hwndCancel = _GetHwndAndRect(hwndDlg, IDCANCEL,               FALSE, rcCancel);
            HWND hwndSearch = _GetHwndAndRect(hwndDlg, IDB_HISTSRCH_GO,        FALSE, rcSearch);
            HWND hwndEdit   = _GetHwndAndRect(hwndDlg, IDC_EDITHISTSEARCH,     FALSE, rcEdit);
            
            // calculate the minimum tolerable width
            UINT uMinWidth  = ((rcCancel.right - rcCancel.left) +
                               (rcSearch.right - rcSearch.left) + HISTSRCH_BUTTONDIST +
                               rcEdit.left +
                               rcAnimSize.right + 1);

            if (uWidth < uMinWidth)
                uWidth = uMinWidth;

            HDWP hdwp = BeginDeferWindowPos(5);

            if (hdwp)
            {
                // align the animation box with the upper-right corner
                DeferWindowPos(hdwp, hwndAnim, HWND_TOP, uWidth - rcAnimSize.right, 0,
                               rcAnimSize.right, rcAnimSize.bottom, SWP_NOZORDER);
                
                // stretch the textbox as wide as possible
                UINT uNewTextWidth = uWidth - rcAnimSize.right - 1 - rcEdit.left;
                DeferWindowPos(hdwp, hwndEdit, HWND_TOP, rcEdit.left, rcEdit.top, uNewTextWidth,
                               rcEdit.bottom - rcEdit.top, SWP_NOZORDER);
                
                // static text should not be longer than edit textbox
                HWND hwndStatic = _GetHwndAndRect(hwndDlg, IDC_HISTSRCH_STATIC, FALSE, rcStatic);
                DeferWindowPos(hdwp, hwndStatic, HWND_TOP, rcEdit.left, rcStatic.top, uNewTextWidth,
                               rcStatic.bottom - rcStatic.top, SWP_NOZORDER);
                
                // align the cancel button with the right of the edit box
                UINT uCancelLeft = uWidth - rcAnimSize.right - 1 - (rcCancel.right - rcCancel.left);
                DeferWindowPos(hdwp, hwndCancel, HWND_TOP, uCancelLeft, rcCancel.top,
                               rcCancel.right - rcCancel.left, rcCancel.bottom - rcCancel.top, SWP_NOZORDER);
                
                // align the search button so that it ends six pixels (HISTSRCH_BUTTONDIST)
                //   to the left of the cancel button
                DeferWindowPos(hdwp, hwndSearch, HWND_TOP,
                               uCancelLeft - HISTSRCH_BUTTONDIST - (rcSearch.right - rcSearch.left),
                               rcSearch.top, rcSearch.right - rcSearch.left, rcSearch.bottom - rcSearch.top, SWP_NOZORDER);

                EndDeferWindowPos(hdwp);
            }
        }
        else
            return FALSE;
        break;
    }
    case WM_COMMAND:
        {
            CHistBand *phb = reinterpret_cast<CHistBand *>(GetWindowLongPtr(hwndDlg, DWLP_USER));

            switch (LOWORD(wParam))
            {
            case IDC_EDITHISTSEARCH:
                switch (HIWORD(wParam))
                {
                case EN_SETFOCUS:
                    // This guy allows us to intercept TranslateAccelerator messages
                    //  like backspace.  This is the same as calling UIActivateIO(TRUE), but
                    //  doesn't cause an infinite setfocus loop in Win95
                    IUnknown_OnFocusChangeIS(phb->_punkSite, SAFECAST(phb, IInputObject*), TRUE);
                    SetFocus((HWND)lParam);
                    break;
                case EN_CHANGE:
                    // Enable 'Go Fish' button iff there is text in the edit box
                    EnableWindow(GetDlgItem(hwndDlg, IDB_HISTSRCH_GO),
                                 (bool) SendDlgItemMessage(hwndDlg, IDC_EDITHISTSEARCH, EM_LINELENGTH, 0, 0));
                    break;
                }
                break;
            case IDB_HISTSRCH_GO:
                {
                    TCHAR szSearchString[MAX_PATH];
                    if (GetDlgItemText(hwndDlg, IDC_EDITHISTSEARCH, szSearchString, ARRAYSIZE(szSearchString)))
                    {
                        IServiceProvider *pServiceProvider;
                        
                        HRESULT hr = IUnknown_QueryService(phb->_punkSite, 
                                                           SID_SProxyBrowser, 
                                                           IID_IServiceProvider, 
                                                           (void **)&pServiceProvider);

                        if (SUCCEEDED(hr))
                        {
                            IWebBrowser2 *pWebBrowser2;
                            hr = pServiceProvider->QueryService(SID_SWebBrowserApp, 
                                                                IID_IWebBrowser2, 
                                                                (void **)&pWebBrowser2);
                            if (SUCCEEDED(hr))
                            {
                                ::PutFindText(pWebBrowser2, szSearchString);
                                pWebBrowser2->Release();
                            }

                            pServiceProvider->Release();
                        }

                        phb->_ExecuteSearch(szSearchString);
                    }
                }
                break;
            case IDCANCEL:
                {
                    if (phb->_EnsureSearch())
                    {
                        phb->_psfSearch->CancelAsyncSearch(phb->_pidlSearch, NULL);
                    }
                    break;
                }
            default:
                return FALSE;
            }
        }
        return FALSE;

    case WM_SEARCH_STATE:
        {
            BOOL fStart = (BOOL)wParam;
            if (fStart)
                Animate_Play(GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION), 0, -1, -1);
            else {
                HWND hwndAnim = GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION);
                Animate_Stop(hwndAnim);
                Animate_Seek(hwndAnim, 0); // reset the animation

                //HACK for IE5 ship
                //if there's only one item found in history search, the item doesn't display
                //because someone (comctl32?) set redraw to false.
                //so, manually force it to true when the search stops
                CHistBand *phb = reinterpret_cast<CHistBand *>(GetWindowLongPtr(hwndDlg, DWLP_USER));
                if (phb)
                    SendMessage(phb->_hwndNSC, WM_SETREDRAW, TRUE, 0);
            }
            HWND hwndFocus = GetFocus();

            EnableWindow(GetDlgItem(hwndDlg, IDC_EDITHISTSEARCH), !fStart);
            EnableWindow(GetDlgItem(hwndDlg, IDB_HISTSRCH_GO), !fStart);            
            EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), fStart);

            //make sure the focus goes to the right place
            if ((NULL != hwndFocus) && (hwndFocus == GetDlgItem(hwndDlg, IDC_EDITHISTSEARCH) ||
                                       (hwndFocus == GetDlgItem(hwndDlg, IDCANCEL))))
                SetFocus(GetDlgItem(hwndDlg, fStart ? IDCANCEL : IDC_EDITHISTSEARCH));
            break;
        }

    default:
        return FALSE;
    }
    return TRUE;
}

IShellFolderSearchable *CHistBand::_EnsureSearch() {
    ASSERT(_psfHistory);
    if (!_pidlSearch) {
        _psfHistory->QueryInterface(IID_IShellFolderSearchable,
                                    (LPVOID *)&_psfSearch);
    }
    return _psfSearch;
}

HRESULT CHistBand::_ClearSearch() {
    HRESULT hr = S_FALSE;

    if (_pidlSearch) {
        if (_EnsureSearch())
        {
            EVAL(SUCCEEDED(_psfSearch->CancelAsyncSearch(_pidlSearch, NULL)));
            hr = _psfSearch->InvalidateSearch(_pidlSearch, NULL);
        }
        ILFree(_pidlSearch);
        _pidlSearch = NULL;
    }
    return hr;
}
    
HRESULT CHistBand::_ExecuteSearch(LPTSTR pszSearchString)
{
    HRESULT hr = E_FAIL;
    
    if (_EnsureSearch())
    {
        _ClearSearch();
        hr = _psfSearch->FindString(pszSearchString,
                                                     NULL,
                                                     reinterpret_cast<IUnknown *>
                                                     (static_cast<IShellFolderSearchableCallback *>
                                                      (this)),
                                                     &_pidlSearch);
        if (SUCCEEDED(hr))
        {
            _ChangePidl(ILCombine(_pidlHistory, _pidlSearch));
        }
    }
    return hr;
}

#ifdef SPLIT_HISTORY_VIEW_BUTTON
UINT CHistBand::_NextMenuItem() {
    if (_uViewCheckedItem + 1 > _nViews)
        return 1;
    else
        return _uViewCheckedItem + 1;
}
#endif

HRESULT CHistBand::_ViewPopupSelect(UINT idCmd) 
{
    HRESULT hr = E_FAIL;

    if (idCmd == MENUID_SEARCH)
    {
        if (_uViewCheckedItem != MENUID_SEARCH)
        {
            // display the dialog box
            if (SUCCEEDED(hr = _DoSearchUIStuff()))
            {
                _ChangePidl((LPITEMIDLIST)INVALID_HANDLE_VALUE); // blank out NSC
                _uViewCheckedItem = MENUID_SEARCH;
                CheckMenuRadioItem(_hViewMenu, 1, _iMaxMenuID, _uViewCheckedItem, MF_BYCOMMAND);
            }
        }
        if (_hwndSearchDlg)
            SetFocus(GetDlgItem(_hwndSearchDlg, IDC_EDITHISTSEARCH));
    }
    else
    {
        LPCITEMIDLIST pidlNewSelect = _MenuIDToPIDL(idCmd);
        if (pidlNewSelect) {
            if (ILIsEmpty(pidlNewSelect))
                hr = _ChangePidl(ILClone(_pidlHistory));
            else
                hr = _ChangePidl(ILCombine(_pidlHistory, pidlNewSelect));

            if (SUCCEEDED(hr))
                hr = _SelectPidl(NULL, TRUE, pidlNewSelect);

            // deleted "&& _uViewCheckedItem >= 0" from test below
            // because UINTs are by definition always >= 0
            if (SUCCEEDED(hr))
            {
                // get rid of search dialog -- its no longer needed
                if (_hwndSearchDlg) {
                    EndDialog(_hwndSearchDlg, 0);
                    DestroyWindow(_hwndSearchDlg);
                    _hwndSearchDlg = NULL;
                    // invalidate the previous search and prepare for the next
                    _ClearSearch();
                    RECT rcSelf;
                    GetClientRect(_hwnd, &rcSelf);
                    _ResizeChildWindows(rcSelf.right, rcSelf.bottom, TRUE);
                }
                
                _uViewCheckedItem = idCmd;
                CheckMenuRadioItem(_hViewMenu, 1, _iMaxMenuID,
                                   _uViewCheckedItem, MF_BYCOMMAND);
                // write out the new selection to registry
                EVAL(SUCCEEDED(_SetRegistryPersistView(_uViewCheckedItem)));
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CHistBand::_DoViewPopup(int x, int y)
{
    if (!_hViewMenu) return E_FAIL;

    HRESULT hr = E_FAIL;

    UINT idCmd = TrackPopupMenu(_hViewMenu, TPM_RETURNCMD, x, y, 0, _hwnd, NULL);
    // Currently, re-selecting the menu item will cause the item to be refreshed
    //  This makes sense to me, but it can be prevented by
    //  testing idCmd != _uViewCheckedItem
    if ( (idCmd > 0) )
    {
        return _ViewPopupSelect(idCmd);
    }
    else
        hr = S_FALSE;

    return hr;
}

// Change the current select NSC pidl
// WARNING: The pidl passed in will be assimilated by us...
//          We will deallocate it.
HRESULT CHistBand::_ChangePidl(LPITEMIDLIST pidl) 
{
    if (_pidl)
        ILFree(_pidl);

    _pidl = pidl;
    if ((LPITEMIDLIST)INVALID_HANDLE_VALUE == pidl)
        _pidl = NULL;
    _pns->Initialize(pidl, (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS), (NSS_DROPTARGET | NSS_BROWSERSELECT));
    return S_OK;
}

// _SelectPidl - Have NSC change the current selected pidl
//
// passing NULL for pidlSelect will select the current select pidl
HRESULT CHistBand::_SelectPidl(LPCITEMIDLIST pidlSelect,        // <-Standard Hist-type pidl to select
                               BOOL fCreate,                    // <-create NSC item if not there?
                               LPCITEMIDLIST pidlView,/*=NULL*/ // <-special history view type or NULL
                               BOOL fReinsert /*=0*/)           // <-reinsert pidl into NSC and re-sort
{
    HRESULT hRes = S_OK;
    BOOL    fFreePidlSelect = FALSE;

    if ( (!pidlSelect) &&
         ((pidlSelect = _GetCurrentSelectPidl())) )
        fFreePidlSelect = TRUE;

    if (pidlSelect) {
        LPITEMIDLIST pidlNewSelect = NULL;

        // cache the last selected pidl
        if (_pidlLastSelect != pidlSelect) {
            if (_pidlLastSelect)
                ILFree(_pidlLastSelect);
            _pidlLastSelect = ILClone(pidlSelect);
        }

        if (pidlView && !ILIsEmpty(pidlView)) {
            IShellFolderViewType *psfvtInfo = _GetViewTypeInfo();

            if (psfvtInfo) {
                LPITEMIDLIST pidlFromRoot = ILFindChild(_pidlHistory,
                                                        pidlSelect);
                if (pidlFromRoot && !ILIsEmpty(pidlFromRoot))
                {
                    LPITEMIDLIST pidlNewFromRoot;
                    if (SUCCEEDED(psfvtInfo->TranslateViewPidl(pidlFromRoot, pidlView,
                                                               &pidlNewFromRoot)))
                    {
                        if (pidlNewFromRoot) {
                            pidlNewSelect = ILCombine(_pidlHistory, pidlNewFromRoot);
                            if (pidlNewSelect) {
                                _pns->SetSelectedItem(pidlNewSelect, fCreate, fReinsert, 0);
                                ILFree(pidlNewSelect);
                            }
                            ILFree(pidlNewFromRoot);
                        }
                    }
                }
                psfvtInfo->Release();
            }
        }
        else
            _pns->SetSelectedItem(pidlSelect, fCreate, fReinsert, 0);

        if (fFreePidlSelect)
            ILFree(const_cast<LPITEMIDLIST>(pidlSelect));
    }
    return hRes;
}

HRESULT CHistBand::_SetRegistryPersistView(int iMenuID) 
{
    LPCITEMIDLIST pidlReg = _MenuIDToPIDL(iMenuID);

    if (!pidlReg)
        return E_FAIL;

    LONG lRet = (SHRegSetUSValue(REGSTR_PATH_MAIN, REGKEY_HISTORY_VIEW,
                         REG_BINARY, (LPVOID)pidlReg, ILGetSize(pidlReg),
                         SHREGSET_HKCU | SHREGSET_FORCE_HKCU));
    return HRESULT_FROM_WIN32(lRet);
}

// Get the default view from the registry as a menu item
int CHistBand::_GetRegistryPersistView() 
{
    int          iRegMenu = -1;
    DWORD        dwType = REG_BINARY;

    ITEMIDLIST   pidlDefault = { 0 };

    // make a preliminary call to find out the size of the data
    DWORD cbData = 0;
    LONG error   = SHRegGetUSValue(REGSTR_PATH_MAIN, REGKEY_HISTORY_VIEW, &dwType,
                                   NULL, &cbData, FALSE, &pidlDefault,
                                   sizeof(pidlDefault));
    if (cbData)
    {
        LPITEMIDLIST pidlReg = ((LPITEMIDLIST)SHAlloc(cbData));

        if (pidlReg)
        {
            error = SHRegGetUSValue(REGSTR_PATH_MAIN, REGKEY_HISTORY_VIEW, &dwType,
                                    (LPVOID)pidlReg, &cbData, FALSE, &pidlDefault,
                                    sizeof(pidlDefault));

            if (error == ERROR_SUCCESS)
                iRegMenu = _PIDLToMenuID(pidlReg);

            SHFree(pidlReg);
        }
    }

    return iRegMenu;
}

LPCITEMIDLIST CHistBand::_MenuIDToPIDL(UINT uMenuID) 
{
    ASSERT(_ppidlViewTypes);
    if ((uMenuID > 0) && (uMenuID <= _nViews))
        return _ppidlViewTypes[uMenuID - 1];
    return NULL;
}

int CHistBand::_PIDLToMenuID(LPITEMIDLIST pidl) 
{
    ASSERT(_psfHistory && _ppidlViewTypes);

    int iMenuID = -1;

    // handle the empty pidl, which designates the
    //  default view, separately
    if (ILIsEmpty(pidl))
        iMenuID = 1;
    else 
    {
        for (UINT u = 0; u < _nViews; ++u) 
        {
            if (_psfHistory->CompareIDs(0, pidl, _ppidlViewTypes[u]) == 0)
                iMenuID = u + 1;
        }
    }
    return iMenuID;
}

// remember to release return value
IShellFolderViewType* CHistBand::_GetViewTypeInfo() 
{
    IShellFolderViewType* psfvRet = NULL;

    if (_psfvtCache)
    {
        _psfvtCache->AddRef();
        psfvRet = _psfvtCache;
    }
    else if (_psfHistory)
    {
        // QI For the views
        // We set the pointer because of a bad QI somewhere...
        if (SUCCEEDED(_psfHistory->QueryInterface(IID_IShellFolderViewType,
                                                  ((void**)&psfvRet))))
        {
            _psfvtCache = psfvRet;
            psfvRet->AddRef(); // one released in destructor, another by caller
        }
        else
            psfvRet = NULL;
    }
    return psfvRet;
}

HRESULT CHistBand::_FreeViewInfo() 
{
    if (_ppidlViewTypes) 
    {
        // the first pidl in this list is NULL, the default view
        for (UINT u = 0; u < _nViews; ++u)
            if (EVAL(_ppidlViewTypes[u]))
                ILFree(_ppidlViewTypes[u]);
        LocalFree(_ppidlViewTypes);
        _ppidlViewTypes = NULL;
    }
    if (_ppszStrViewNames) 
    {
        for (UINT u = 0; u < _nViews; ++u)
            if (EVAL(_ppszStrViewNames[u]))
                CoTaskMemFree(_ppszStrViewNames[u]);
        LocalFree(_ppszStrViewNames);
        _ppszStrViewNames = NULL;
    }
    return S_OK;
}

// Load the popup menu (if there are views to be had)
HRESULT CHistBand::_InitViewPopup() 
{
    HRESULT hRes = E_FAIL;

    _iMaxMenuID = 0;

    if (SUCCEEDED((hRes = _GetHistoryViews()))) 
    {
        if ((_hViewMenu = CreatePopupMenu()))
        {
            // the IDCMD for the view menu will always be
            //   one more than the index into the view tables
            for (UINT u = 0; u < _nViews; ++u) 
            {
                int iMenuID = _PIDLToMenuID(_ppidlViewTypes[u]);
                if (iMenuID >= 0)
                    AppendMenu(_hViewMenu, MF_STRING, iMenuID,
                               _ppszStrViewNames[u]);
                if (iMenuID > _iMaxMenuID)
                    _iMaxMenuID = iMenuID;
            }

            // retrieve the persisted view information
            //  and check the corresponding menu item
            int iSelectMenuID = _GetRegistryPersistView();
            if (iSelectMenuID < 0 || ((UINT)iSelectMenuID) > _nViews)
                iSelectMenuID = 1; //bogus menuid
            _uViewCheckedItem = iSelectMenuID;
            CheckMenuRadioItem(_hViewMenu, 1, _nViews, _uViewCheckedItem, MF_BYCOMMAND);
        }
    }

#ifdef HISTORY_VIEWSEARCHMENU
    // if this is a searchable shell folder, then add the search menu item
    if (_EnsureSearch())
    {
        hRes = S_OK;

        // only add separator if there is a menu already!
        if (!_hViewMenu)
            _hViewMenu = CreatePopupMenu();
        else
            AppendMenu(_hViewMenu, MF_SEPARATOR, 0, NULL);

        if (_hViewMenu)
        {
            TCHAR szSearchMenuText[MAX_PATH];
            LoadString(MLGetHinst(), IDS_SEARCH_MENUOPT,
                       szSearchMenuText, ARRAYSIZE(szSearchMenuText));
            AppendMenu(_hViewMenu, MF_STRING, MENUID_SEARCH, szSearchMenuText);
            _iMaxMenuID = MENUID_SEARCH;
        }
        else
            hRes = E_FAIL;
    }
#endif
    return hRes;
}

// This guy calls the enumerator
HRESULT CHistBand::_GetHistoryViews() 
{
    ASSERT(_psfHistory);
    HRESULT hRes = E_FAIL;

    UINT cbViews; // how many views are allocated

    ASSERT(VIEWTYPE_MAX > 0);

    EVAL(SUCCEEDED(_FreeViewInfo()));

    IShellFolderViewType *psfViewType = _GetViewTypeInfo();

    if (psfViewType)
    {
        // allocate buffers to store the view information
        _ppidlViewTypes = ((LPITEMIDLIST *)LocalAlloc(LPTR, VIEWTYPE_MAX * sizeof(LPITEMIDLIST)));
        if (_ppidlViewTypes) {
            _ppszStrViewNames = ((LPTSTR *)LocalAlloc(LPTR, VIEWTYPE_MAX * sizeof(LPTSTR)));
            if (_ppszStrViewNames) {
                IEnumIDList *penum = NULL;
                cbViews  = VIEWTYPE_MAX;
                _nViews  = 1;
                // get the default view information
                _ppidlViewTypes[0]   = IEILCreate(sizeof(ITEMIDLIST));
                if (_ppidlViewTypes[0] &&
                    SUCCEEDED((hRes = psfViewType->GetDefaultViewName(0, &(_ppszStrViewNames[0])))))
                {
                    // empty pidl will be the default
                    ASSERT(ILIsEmpty(_ppidlViewTypes[0]));
                    // get the iterator for the other views
                    if (SUCCEEDED((hRes = psfViewType->EnumViews(0, &penum)))) {
                        ULONG cFetched = 0;
                        // iterate to get other view information
                        while(SUCCEEDED(hRes)                                                   &&
                              SUCCEEDED(penum->Next(1, &(_ppidlViewTypes[_nViews]), &cFetched)) &&
                              cFetched)
                        {
                            // get the name of this view
                            if (SUCCEEDED(DisplayNameOfAsOLESTR(_psfHistory, _ppidlViewTypes[_nViews], 0, &(_ppszStrViewNames[_nViews]))))
                            {
                                // prepare for next iteration by reallocating the buffer if necessary
                                if (_nViews > cbViews - 1)
                                {
                                    LPITEMIDLIST *ppidlViewTypes = ((LPITEMIDLIST *)LocalReAlloc(_ppidlViewTypes,
                                                                                       (cbViews + VIEWTYPE_REALLOC) * sizeof(LPITEMIDLIST),
                                                                                       LMEM_MOVEABLE | LMEM_ZEROINIT));
                                    if (ppidlViewTypes)
                                    {
                                        _ppidlViewTypes = ppidlViewTypes;
                                        LPTSTR * ppszStrViewNames = ((LPTSTR *)LocalReAlloc(_ppszStrViewNames,
                                                                                   (cbViews + VIEWTYPE_REALLOC) * sizeof(LPTSTR),
                                                                                   LMEM_MOVEABLE | LMEM_ZEROINIT));
                                        if (ppszStrViewNames)
                                        {
                                            _ppszStrViewNames = ppszStrViewNames;
                                            cbViews += VIEWTYPE_REALLOC;
                                        }
                                        else
                                        {
                                            hRes = E_OUTOFMEMORY;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        hRes = E_OUTOFMEMORY;
                                        break;
                                    }
                                }
                                ++_nViews;
                            }
                        }
                        penum->Release();
                    }
                }
            }
        }
        psfViewType->Release();
    }
    return hRes;
}

HRESULT CHistBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CHistBand * phb = new CHistBand();

    if (!phb)
        return E_OUTOFMEMORY;

    ASSERT(phb->_pidlHistory    == NULL &&
           phb->_pidlLastSelect == NULL &&
           phb->_pidl           == NULL &&
           phb->_psfvtCache     == NULL);


    if (SUCCEEDED(SHGetHistoryPIDL(&(phb->_pidlHistory))) &&
        SUCCEEDED(IEBindToObject(phb->_pidlHistory,
                                 &(phb->_psfHistory))))
    {
        HRESULT hResLocal = E_FAIL;

        // if we can get different views, then init with the persisted
        //   view type, otherwise, init with the top-level history type
        if (SUCCEEDED(phb->_InitViewPopup())) {
            LPCITEMIDLIST pidlInit = phb->_MenuIDToPIDL(phb->_uViewCheckedItem);
            if (pidlInit) {
                LPITEMIDLIST pidlFullInit = ILCombine(phb->_pidlHistory, pidlInit);
                if (pidlFullInit) {
                    hResLocal = phb->_Init(pidlFullInit);
                    ILFree(pidlFullInit);
                }
            }
        }
        else
            hResLocal = phb->_Init(phb->_pidlHistory);

        // From old favband code: // if (SUCCEEDED(phb->_Init((LPCITEMIDLIST)CSIDL_FAVORITES)))
        if (SUCCEEDED(hResLocal))
        {
            phb->_pns = CNscTree_CreateInstance();
            if (phb->_pns)
            {
                ASSERT(poi);
                phb->_poi = poi;
                // if you change this cast, fix up CChannelBand_CreateInstance
                *ppunk = SAFECAST(phb, IDeskBand *);

                IUnknown_SetSite(phb->_pns, *ppunk);
                phb->_SetNscMode(MODE_HISTORY);
                return S_OK;
            }
        }
    }

    phb->Release();

    return E_FAIL;
}

// Ask the powers that be which pidl is selected...
LPITEMIDLIST CHistBand::_GetCurrentSelectPidl(IOleCommandTarget *poctProxy/* = NULL*/) 
{
    LPITEMIDLIST pidlRet = NULL;
    VARIANT var;
    BOOL    fReleaseProxy = FALSE;
    VariantInit(&var);
    var.vt = VT_EMPTY;

    if (poctProxy == NULL) 
    {
        IBrowserService *pswProxy;
        if (SUCCEEDED(QueryService(SID_SProxyBrowser, IID_PPV_ARG(IBrowserService, &pswProxy))))
        {
            ASSERT(pswProxy);
            if (FAILED(pswProxy->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
            {
                pswProxy->Release();
                return NULL;
            }
            else
                fReleaseProxy = TRUE;

            pswProxy->Release();
        }
    }

    //  Inquire the current select pidl
    if ((SUCCEEDED(poctProxy->Exec(&CGID_Explorer, SBCMDID_GETHISTPIDL,
                                   OLECMDEXECOPT_PROMPTUSER, NULL, &var))) &&
        (var.vt != VT_EMPTY))
    {
        pidlRet = VariantToIDList(&var);
        VariantClearLazy(&var);
    }
    if (fReleaseProxy)
        poctProxy->Release();
    return pidlRet;
}

// gets called by CNSCBand::ShowDW every time history band is shown
HRESULT CHistBand::_OnRegisterBand(IOleCommandTarget *poctProxy) 
{
    HRESULT hRes = E_FAIL;
    if (_uViewCheckedItem != MENUID_SEARCH)
    {
        LPITEMIDLIST pidlSelect = _GetCurrentSelectPidl(poctProxy);
        if (pidlSelect)
        {
            _SelectPidl(pidlSelect, TRUE);
            ILFree(pidlSelect);
            hRes = S_OK;
        }
    }
    return hRes;
}

HRESULT CHistBand::_InitializeNsc()
{
    return _pns->Initialize(_pidl, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, NSS_NOHISTSELECT | NSS_DROPTARGET | NSS_BROWSERSELECT);
}

BOOL CHistBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    return !(ulAttrib & SFGAO_FOLDER);
}

HRESULT CHistBand::_NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl)
{
    HRESULT hr = psb->BrowseObject(pidl, SBSP_SAMEBROWSER | SBSP_NOAUTOSELECT);
    if (SUCCEEDED(hr))
    {
        IOleCommandTarget *poctProxy;
        if (SUCCEEDED(QueryService(SID_SProxyBrowser, IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
        {
            VARIANTARG var;
            
            InitVariantFromIDList(&var, pidl);
            poctProxy->Exec(&CGID_Explorer, SBCMDID_SELECTHISTPIDL, OLECMDEXECOPT_PROMPTUSER, &var, NULL);
            VariantClear(&var);
            poctProxy->Release();
        }
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVHIST);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hlink.cpp ===
#include "priv.h"

class CMyHlink : public IHlink
{
public:
    // *** IUnknown methods ***
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual ULONG __stdcall AddRef(void) ;
    virtual ULONG __stdcall Release(void);

    // *** IOleWindow methods ***
    virtual HRESULT __stdcall SetHlinkSite(IHlinkSite *pihlSite);
    virtual HRESULT __stdcall GetHlinkSite(IHlinkSite **ppihlSite);
    virtual HRESULT __stdcall GetMonikerReference(
	 IMoniker **ppimk,
	 LPWSTR *ppwzLocation);
    virtual HRESULT __stdcall GetStringReference(LPWSTR *ppwzRefString);
    virtual HRESULT __stdcall GetFriendlyName(LPWSTR *ppwzFriendlyName);
    virtual HRESULT __stdcall Navigate(
	 IHlinkFrame *pihlFrame,
	 DWORD grfHLNF,
	 LPBC pbc,
	 DWORD dwbscCookie,
	 IBindStatusCallback *pibsc,
	 IHlinkBrowseContext *pihlbc);

protected:
    CMyHlink();
    ~CMyHlink();
    UINT	_cRef;
    IHlinkSite* _pihlSite;
    IMoniker*   _pmk;
    TCHAR	_szLocation[MAX_PATH];
};

CMyHlink::CMyHlink(IMoniker* pmk, LPCTSTR pszLocation, LPCSTR pszFriedlyName)
		    : _cRef(1), _pihlSite(NULL), _pmk(pmk)
{
    if (_pmk) {
	_pmk->AddRef();
    }
    if (pszLocation) {
	lstrcpy(_szLocation, pszLocation);
    } else {
	_szLocation[0] = '\0';
    }
}


CMyHlink::~CMyHlink()
{
    if (_pmk) {
	_pmk->Release();
    }

    if (_pihlSite) {
	_pihlSite->Release();
    }
}

HRESULT CMyHlink::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
}

ULONG CMyHlink::AddRef(void)
{
    return ++_cRef;
}

ULONG CMyHlink::Release(void)
{
    if (--_cRef > 0) {
	return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CMyHlink::SetHlinkSite(IHlinkSite *pihlSite)
{
    if (_pihlSite) {
	_pihlSite->Release();
    }

    _pihlSite = pihlSite;

    if (_pihlSite) {
	_pihlSite->AddRefe();
    }

    return S_OK;
}

HRESULT CMyHlink::GetHlinkSite(IHlinkSite **ppihlSite)
{
    *ppihlSite = _pihlSite;
    if (_pihlSite) {
	_pihlSite->AddRefe();
    }

    return S_OK;
}

HRESULT CMyHlink::GetMonikerReference(
     IMoniker **ppimk,
     LPWSTR *ppwzLocation)
{
    if (ppimk) {
	*ppimk = _pmk;
	if (_pmk) {
	    _pmk->AddRef();
	}
    }

    // Handle ppwszLocation as well!

    return S_OK;
}

HRESULT CMyHlink::GetStringReference(LPWSTR *ppwzRefString)
{
    return E_NOTIMPL;
}

HRESULT CMyHlink::GetFriendlyName(LPWSTR *ppwzFriendlyName)
{

}

HRESULT CMyHlink::Navigate(
     IHlinkFrame *pihlFrame,
     DWORD grfHLNF,
     LPBC pbc,
     DWORD dwbscCookie,
     IBindStatusCallback *pibsc,
     IHlinkBrowseContext *pihlbc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hlinkp.h ===
#define DELAY_LOAD_HLINK

struct Hlink
{
#ifdef DELAY_LOAD_HLINK
#define DELAYHLINKAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
    	HRESULT hres = _Init(); \
	if (SUCCEEDED(hres)) \
	    hres = _pfn##_fn _nargs; \
	return hres;    } \
    HRESULT (STDAPICALLTYPE* _pfn##_fn) _args;

    HRESULT 	_Init(void);

    // _fInited must be the first member
    BOOL	_fInited;
    HMODULE 	_hmod;
#else
#define DELAYHLINKAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { return ::#_fn _nargs; }

#endif

    DELAYHLINKAPI(CreateURLMoniker,
		  (LPCWSTR pwsURL, IMoniker ** ppimk),
		  (pwsURL, ppimk));
    DELAYHLINKAPI(HlinkParseDisplayName,
		  (LPBC pbc, LPCOLESTR pozDisplayName, ULONG* pcchEaten, IMoniker** ppimk),
		  (pbc, pozDisplayName, pcchEaten, ppimk));
};


#ifdef DELAY_LOAD_HLINK

HRESULT Hlink::_Init(void)
{
    if (_fInited) {
	return S_OK;
    }

    _fInited = TRUE;
    _hmod = LoadLibrary(TEXT("HLINKD.DLL"));
    if (!_hmod) {
	return E_UNEXPECTED;
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hmod, #_fn); \
    if (!(_pfn##_fn)) return E_UNEXPECTED;

    CHECKAPI(CreateURLMoniker);
    CHECKAPI(HlinkParseDisplayName);
    return S_OK;
}
#endif

#ifdef DELAY_LOAD_HLINK
Hlink g_hlinkdll = { FALSE } ;
#else // DELAY_LOAD_HLINK
Hlink g_hlinkdll;
#endif // DELAY_LOAD_HLINK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hlsrc.cpp ===
#include "priv.h"


class CMyHlinkSrc : public IHlinkSource
{
    friend HRESULT CMyHlinkSrc_CreateInstance(REFCLSID rclsid, DWORD grfContext, REFIID riid, LPVOID* ppvOut);
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IHlinkSource methods ***
    virtual STDMETHODIMP SetBrowseContext(
	 IHlinkBrowseContext *pihlbc);

    virtual STDMETHODIMP GetBrowseContext(
	 IHlinkBrowseContext **ppihlbc);

    virtual STDMETHODIMP Navigate(
	 DWORD grfHLNF,
	 LPCWSTR pwzJumpLocation);

    virtual STDMETHODIMP GetMoniker(
	 LPCWSTR pwzLocation,
	 DWORD dwAssign,
	 IMoniker **ppimkLocation);

    virtual STDMETHODIMP GetFriendlyName(
	 LPCWSTR pwzLocation,
	 LPWSTR *ppwzFriendlyName);

protected:
    CMyHlinkSrc();
    ~CMyHlinkSrc();

    UINT		_cRef;
    IUnknown*   	_punkInner;	// aggregated inner object
    IHlinkSource* 	 _phlsrc;	// cached IHlinkSource
    IHlinkBrowseContext* _phlbc;
};

CMyHlinkSrc::CMyHlinkSrc() : _cRef(1), _punkInner(NULL), _phlsrc(NULL), _phlbc(NULL)
{
    DllAddRef();
}

CMyHlinkSrc::~CMyHlinkSrc()
{
    DllRelease();
}

//
// This function returns an aggregated object
//
HRESULT CMyHlinkSrc_CreateInstance(REFCLSID rclsid, DWORD grfContext, REFIID riid, LPVOID* ppvOut)
{
    HRESULT hres = E_OUTOFMEMORY;
    *ppvOut = NULL;

    CMyHlinkSrc* phlsrcOuter = new CMyHlinkSrc();
    if (phlsrcOuter)
    {

	hres = CoCreateInstance(rclsid, phlsrcOuter, grfContext, IID_IUnknown,
			        (LPVOID*)&phlsrcOuter->_punkInner);
	if (SUCCEEDED(hres))
	{
	    // TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_CreateInstenace CoCreateSucceeded");
	    // Cache IHlinkSource of the inner object (if any).
	    HRESULT hresT = phlsrcOuter->_punkInner->QueryInterface(
				IID_IHlinkSource, (LPVOID*)&phlsrcOuter->_phlsrc);
	    // TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_CreateInstenace QI(IID_IHlinkSource) returned (%x)", hres);
	    if (SUCCEEDED(hresT)) {
		//
		// Decrement the reference count to avoid cycled reference.
		// See "The COM Programmer's Cookbook for detail.
		//
    		phlsrcOuter->Release();
	    }

	    hres = phlsrcOuter->QueryInterface(riid, ppvOut);
	}
	else
	{
	    TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_CreateInstenace CoCI failed (%x)", hres);
	}

	phlsrcOuter->Release();
    }

    // TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_CreateInstenace leaving");

    return hres;
}

HRESULT CMyHlinkSrc::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IUnknown*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IHlinkSource))
    {
	//
	// If the inner object supports IHlinkSource, return it;
	// otherwise, return our own.
	//
	TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc::QueryInterface IID_IHlinkSource called");
        *ppvObj = _phlsrc ? _phlsrc : (IHlinkSource*)this;
        _cRef++;
        return S_OK;
    }
    else if (_punkInner)
    {
	//
	// Delegate QI down to the inner object. This technique is
	// called "Blind QueryInterfcae" in the COM Programmer's Cookbook.
	// This book says, we shouldn't use this technique unless we modify
	// any behavior of other interfaces. In this case, we don't modify
	// any behavior and it's safe to use this technique.
	//
	// TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc::QueryInterface delegating QI to inner object");
	return _punkInner->QueryInterface(riid, ppvObj);
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CMyHlinkSrc::AddRef(void)
{
    // TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc::AddRef new _cRef is %d", _cRef+1);
    return ++_cRef;
}

ULONG CMyHlinkSrc::Release(void)
{
    if (--_cRef > 0) {
	// TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc::Release new _cRef is %d", _cRef);
	return _cRef;
    }

    TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc::Release deleting this object ----- (YES!)");

    if (_phlbc) {
	_phlbc->Release();
    }

    _cRef = 1;	// guard (to be recursively hit this code)
    if (_phlsrc) {
	AddRef();		// balance the ref. count
	_phlsrc->Release();	// release the cached interface
    }

    if (_punkInner) {
	_punkInner->Release();
    }

    ASSERT(_cRef == 1);
    delete this;
    return 0;
}

// *** IHlinkSource methods ***
HRESULT CMyHlinkSrc::SetBrowseContext(
     IHlinkBrowseContext *pihlbc)
{
    if (_phlbc) {
	_phlbc->Release();
    }

    _phlbc = pihlbc;
    if (_phlbc) {
	_phlbc->AddRef();
    }

    return S_OK;
}

HRESULT CMyHlinkSrc::GetBrowseContext(
     IHlinkBrowseContext **ppihlbc)
{
    *ppihlbc = _phlbc;

    if (_phlbc) {
	_phlbc->AddRef();
    }

    return S_OK;
}

HRESULT CMyHlinkSrc::Navigate(
     DWORD grfHLNF,
     LPCWSTR pwzJumpLocation)
{
    IOleDocumentView* pmsov = NULL;
    HRESULT hres = _punkInner->QueryInterface(IID_IOleDocumentView, (LPVOID*)&pmsov);
    if (SUCCEEDED(hres)) {
	hres = pmsov->UIActivate(TRUE);
	TraceMsg(DM_TRACE, "sdv TR CHS::Navigate pmsov->UIActivate() returned %x", hres);
	if (SUCCEEDED(hres)) {
	    // HlinkOnNavigate
	}
	pmsov->Release();
    } else {
	TraceMsg(DM_TRACE, "sdv TR CHS::Navigate _punkInner->QI(IID_Mso) failed");
    }

    return S_OK;
}

HRESULT CMyHlinkSrc::GetMoniker(
     LPCWSTR pwzLocation,
     DWORD dwAssign,
     IMoniker **ppimkLocation)
{
    return E_NOTIMPL;
}

HRESULT CMyHlinkSrc::GetFriendlyName(
     LPCWSTR pwzLocation,
     LPWSTR *ppwzFriendlyName)
{
    return E_NOTIMPL;
}

//
// Almost identical copy of OleCreate, which allows us to pass
// the punkOuter.
//
HRESULT CMyHlinkSrc_OleCreate(CLSID rclsid, REFIID riid, DWORD renderOpt,
		   FORMATETC* pFormatEtc, IOleClientSite* pclient,
		   IStorage* pstg, LPVOID* ppvOut)
{
    HRESULT hres;
    *ppvOut = NULL;	// assume error

    IUnknown* punk;
    hres = CMyHlinkSrc_CreateInstance(rclsid, CLSCTX_INPROC, IID_IUnknown, (LPVOID*)&punk);
    if (SUCCEEDED(hres))
    {
	// Artificial one-time loop, which allows us to easily
	// handle error cases by saying "if (FAILED(hres)) break;"
	do {
	    // Call IPersistStorage::InitNew
	    IPersistStorage* ppstg;
	    hres = punk->QueryInterface(IID_IPersistStorage, (LPVOID*)&ppstg);
	    if (FAILED(hres))
		break;
	    hres = ppstg->InitNew(pstg);
	    ppstg->Release();
	    if (FAILED(hres))
		break;

	    // Call IOleObject::SetClientSite
	    IOleObject* pole;
	    hres = punk->QueryInterface(IID_IOleObject, (LPVOID*)&pole);
	    if (FAILED(hres))
		break;
	    hres = pole->SetClientSite(pclient);
	    pole->Release();
	    if (FAILED(hres))
		break;

	    hres = punk->QueryInterface(riid, ppvOut);
	} while (0);

	punk->Release();
    }
    return hres;
}

//
// Almost identical copy of OleLoad, which allows us to pass
// the punkOuter.
//
HRESULT CMyHlinkSrc_OleLoad(IStorage* pstg, REFIID riid,
		            IOleClientSite* pclient, LPVOID* ppvOut)
{
    // TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_OleLoad called");

    HRESULT hres;
    *ppvOut = NULL;	// assume error

    STATSTG statstg;
    hres = pstg->Stat(&statstg, STATFLAG_NONAME);
    if (SUCCEEDED(hres))
    {
	IUnknown* punk;
	hres = CMyHlinkSrc_CreateInstance(statstg.clsid, CLSCTX_INPROC, IID_IUnknown, (LPVOID*)&punk);
	if (SUCCEEDED(hres))
	{
	    // Artificial one-time loop, which allows us to easily
	    // handle error cases by saying "if (FAILED(hres)) break;"
	    do {
		// TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_OladLoad calling IPS::Load");
		// Call IPersistStorage::Load
		IPersistStorage* ppstg;
		hres = punk->QueryInterface(IID_IPersistStorage, (LPVOID*)&ppstg);
		if (FAILED(hres))
		    break;
		hres = ppstg->Load(pstg);
		ppstg->Release();
		if (FAILED(hres))
		    break;

		// TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_OladLoad calling IOO::SetClientSite");
		// Call IOleObject::SetClientSite
		IOleObject* pole;
		hres = punk->QueryInterface(IID_IOleObject, (LPVOID*)&pole);
		if (FAILED(hres))
		    break;
		hres = pole->SetClientSite(pclient);
		pole->Release();
		if (FAILED(hres))
		    break;

		// TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_OladLoad calling IUnk::QI");
		hres = punk->QueryInterface(riid, ppvOut);
	    } while (0);

	    punk->Release();
	}
    }

    // TraceMsg(DM_TRACE, "sdv TR CMyHlinkSrc_OleLoad is leaving");

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\htregmng.h ===
/*
 * Registry Association Management
 *
 * HTREGMNG.H
 *
 * Copyright (c) 1995 Microsoft Inc.
 *
 */

#ifndef HTREGMNG_H
#define HTREGMNG_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Registry Management Structures
 *
 * We need a way to specify a set of registry entries to
 * represent an association.   We can then test and
 * set the registry appropriately to restore associations
 * as needed
 *
 */

typedef enum 
{ 
    RC_ADD, 
    RC_RUNDLL,
    RC_DEL,              // Remove key
    RC_CALLBACK
} REGCMD;


// Flags for RegEntry

#define REF_NORMAL      0x00000000      // Required and forcefully set
#define REF_NOTNEEDED   0x00000001      // Ignored during checks
#define REF_IFEMPTY     0x00000002      // Set only if value/key is empty
#define REF_DONTINTRUDE 0x00000004      // Don't intrude at setup time
#define REF_NUKE        0x00000008      // Remove a key, regardless of the subkeys/values
#define REF_PRUNE       0x00000010      // Walk up this path and remove empty keys
#define REF_EDITFLAGS   0x00000020      // Remove edit flags only if the rest of the tree is empty


// NOTE: these structures are deliberately CHAR, not TCHAR, so we don't
// have to mess with the TEXT macro in all the tables.

typedef struct _RegEntry {
    REGCMD  regcmd;         // Special Handling
    DWORD   dwFlags;        // REF_* 
    HKEY    hkeyRoot;       // Root key
    LPCSTR  pszKey;         // Key Name
    LPCSTR  pszValName;     // Value Name
    DWORD   dwType;         // Value Type
    union 
    {
        LPARAM  lParam;     // lParam
        DWORD   dwSize;     // Value Size (in bytes)
    }DUMMYUNIONNAME;
    VOID const * pvValue;   // Value
} RegEntry;

typedef RegEntry RegList[];

typedef struct _RegSet {
    DWORD       cre;       // Count of entries
    const RegEntry * pre;
} RegSet;


#define IEA_NORMAL          0x00000001 // Only install IE assoc. if IE is currently owner.
#define IEA_FORCEIE         0x00000002 // Force IE to take over associations

HRESULT InstallIEAssociations(DWORD dwFlags);   // IEA_* flags

HRESULT UninstallPlatformRegItems(BOOL bIntegrated);
void    UninstallCurrentPlatformRegItems();
BOOL    IsCheckAssociationsOn();
void    SetCheckAssociations( BOOL );
BOOL    GetIEPath(LPSTR szPath, DWORD cch);
BOOL    IsIEDefaultBrowser(void);
BOOL IsIEDefaultBrowserQuick(void);
HRESULT ResetWebSettings(HWND hwnd, BOOL *pfChangedHomePage);

extern const TCHAR c_szCLSID[];

#ifdef __cplusplus
};
#endif

#endif /* HTREGMNG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iedde.h ===
#ifndef _IEDDE_H
#define _IEDDE_H

BOOL IEDDE_Initialize(void);
void IEDDE_Uninitialize(void);
void IEDDE_AutomationStarted(void);
BOOL IEDDE_RunDelayedExecute();
HRESULT IEDDE_BeforeNavigate(LPCWSTR pwszURL, BOOL *pfCanceled);
HRESULT IEDDE_AfterNavigate(LPCWSTR pwszURL, HWND hwnd);
BOOL IEDDE_NewWindow(HWND hwnd);
BOOL IEDDE_WindowDestroyed(HWND hwnd);

#endif  //_IEDDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hnfblock.h ===
#ifndef HNFBLOCK_H_
#define HNFBLOCK_H_
#include <iethread.h>

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

DECLARE_HANDLE(HNFBLOCK);

HNFBLOCK ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId);
IETHREADPARAM *ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock);

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif // HNFBLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\htregmng.cpp ===
/*
 * Registry Management
 *
 * HTREGMNG.C
 *
 * Copyright (c) 1995 Microsoft Corporation
 *
 */

#include "priv.h"
#include "htregmng.h"
#include "resource.h"
#include "regapix.h"
#include <filetype.h>

#include <advpub.h>
#include <mluisupp.h>

//  This file contains the auto-registration code, which smartly performs 
//  the install/uninstall of registry keys and values.  While an inf file
//  is sufficient most of the time, IE needs to be smart about what
//  sort of values to set, based upon certain conditions.  An inf file
//  does not offer this depth of support.  Additionally, IE requires 
//  code to be run when it detects that it is not the default browser,
//  so it can make it the default browser.  Any settings that determine
//  this should be placed here, rather than the inf file.
//
//  This code is table driven.  The idea is simple.  You have a RegSet
//  which is the "Registry Set".  The Registry Set indicates the 
//  root key and contains a list of RegEntries.  Each RegEntry 
//  specifies a command, flags, key and value names, and optional data
//  that provides the essential info to set/change/delete a registry
//  value or key.
//
//  
// NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: 
//-------------------------------------------
// Any new Icon check that uses HTReg_UrlIconProc that gets added
// to any of the Assoc arrays and is REQUIRED for Default Browser check to
// succeed has to be added to the c_rlAssoc_FixIcon[] array also.
//


// Make the tables more compact
#define HKCR    HKEY_CLASSES_ROOT
#define HKLM    HKEY_LOCAL_MACHINE
#define HKCU    HKEY_CURRENT_USER


#define IDEFICON_STD    0
#define IDEFICON_NEWS   1
#define IDEFICON_MAIL   2

#ifndef UNIX

#define IEXPLORE_APP    "IExplore"
#define IEXPLORE_EXE    "iexplore.exe"
#define EXPLORER_EXE    "explorer.exe"
#define RUNDLL_CMD_FMT  "rundll32.exe %s"

#else

#define IEXPLORE_APP    "iexplorer"
#define IEXPLORE_EXE    "iexplorer"
#define EXPLORER_EXE    "explorer"
#define RUNDLL_CMD_FMT  "rundll32 %s"

#endif

BOOL    InstallRegSet(const RegSet *prs, BOOL bDontIntrude);

#ifndef UNIX
const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";
#else
const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORER";
#endif

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Return a string path composed of hkey\pszKey\pszValueName.

Returns: 
Cond:    --
*/
LPTSTR
Dbg_RegStr(
    IN const RegEntry * pre,          
    IN LPTSTR pszBuf)
{
    TCHAR szRoot[5];
    TCHAR szTempKey[MAXIMUM_SUB_KEY_LENGTH];
    TCHAR szTempValue[MAXIMUM_VALUE_NAME_LENGTH];

    ASSERT(pre);
    ASSERT(pszBuf);

    if (HKEY_CLASSES_ROOT == pre->hkeyRoot)
        {
        StrCpyN(szRoot, TEXT("HKCR"), ARRAYSIZE(szRoot));
        }
    else if (HKEY_CURRENT_USER == pre->hkeyRoot)
        {
        StrCpyN(szRoot, TEXT("HKCU"), ARRAYSIZE(szRoot));
        }
    else if (HKEY_LOCAL_MACHINE == pre->hkeyRoot)
        {
        StrCpyN(szRoot, TEXT("HKLM"), ARRAYSIZE(szRoot));
        }
    else
        {
        StrCpyN(szRoot, TEXT("????"), ARRAYSIZE(szRoot));
        ASSERT(0);
        }

    AnsiToTChar(pre->pszKey, szTempKey, ARRAYSIZE(szTempKey));

    szTempValue[0] = TEXT('\0');
    if (pre->pszValName)
        AnsiToTChar(pre->pszValName, szTempValue, ARRAYSIZE(szTempValue));

    ASSERT(lstrlen(pszBuf) < MAX_PATH);
    wnsprintf(pszBuf, MAX_PATH, TEXT("%s\\%hs\\%hs"), szRoot, szTempKey, szTempValue);

    return pszBuf;
}

#else

#define Dbg_RegStr(x, y)    0

#endif // DEBUG



/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/

BOOL
GetIEPath2(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf,
    IN  BOOL  bInsertQuotes)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyA(HKEY_LOCAL_MACHINE, c_szIexploreKey, &hkey))  
    {
#ifndef UNIX
        TraceMsg(TF_ERROR, "InstallRegSet(): RegOpenKey( %s ) Failed", c_szIexploreKey) ;
#endif
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        if (bInsertQuotes)
            StrCatBuffA(pszBuf, "\"", cchBuf);

        cbBrowser = CbFromCchA(cchBuf - lstrlenA(" -nohome") - 4);
        if (NO_ERROR != SHQueryValueExA(hkey, "", NULL, &dwType,
                                         (LPBYTE)&pszBuf[bInsertQuotes?1:0], &cbBrowser))
        {
            TraceMsg(TF_ERROR, "InstallRegSet(): RegQueryValueEx() for Iexplore path failed");
        }
        else
        {
            bRet = TRUE;
        }

        if (bInsertQuotes)
            StrCatBuffA(pszBuf, "\"", cchBuf);

        RegCloseKey(hkey);
    }

    return bRet;
}

BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
{
    return GetIEPath2(pszBuf, cchBuf, TRUE);
}

/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of the shell's Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/
BOOL
GetExplorerPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf, DWORD dwType)
{
    BOOL bRet;

    // Get the path of the Explorer 
    if (dwType == REG_EXPAND_SZ) 
        {
        StrCpyNA (pszBuf, "%SystemRoot%", cchBuf);
        bRet = TRUE;
        }
    else
        bRet = (0 < GetWindowsDirectoryA(pszBuf, cchBuf));
    if (bRet)
        {
        StrCatBuffA(pszBuf, "\\Explorer.exe", cchBuf);
        }
    return bRet;
}

// Callback messages

#define RSCB_QUERY          1
#define RSCB_INSTALL        2

typedef BOOL (CALLBACK* RSPECPROC)(UINT nMsg, const RegEntry * pre, LPVOID pvData, DWORD dwData);


// Win9x to NT5 migration generated file.
#define MIGICONS    "migicons.exe"


/*----------------------------------------------------------
Purpose: This callback sets the default icon to point to a
         given index in url.dll.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_UrlIconProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,       OPTIONAL
    IN DWORD      dwData)
{
    BOOL bRet = TRUE;
    CHAR sz[MAX_PATH + 20];    // Need a bit extra
    LPCSTR pszPath = (LPCSTR) pvData;
    int cch;
    DWORD dwType;  //local type.
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )
    
    ASSERT(RSCB_QUERY == nMsg && pvData ||
           RSCB_INSTALL == nMsg && !pvData);

    if (!g_fRunningOnNT) {
        ASSERT(REG_EXPAND_SZ == pre->dwType);
        dwType = REG_SZ;
    } else
        dwType = (DWORD)pre->dwType;        
    
    if (dwType == REG_EXPAND_SZ) 
        StrCpyNA (sz, "%SystemRoot%\\system32", ARRAYSIZE(sz));
    else
        GetSystemDirectoryA(sz, SIZECHARS(sz));
    cch = lstrlenA(sz);

    // We still have to use url.dll as the source of the internet shortcut
    // icons because the icons need to still be valid on uninstall.
    wnsprintfA(&sz[cch], ARRAYSIZE(sz) - cch, "\\url.dll,%d", (int)pre->DUMMYUNION_MEMBER(lParam));

    switch (nMsg)
    {
    case RSCB_QUERY:
        if (0 != StrCmpNIA(sz, pszPath, dwData / SIZEOF(CHAR)) &&
            0 != StrCmpIA(PathFindFileNameA(sz), PathFindFileNameA(pszPath)))  
        {
            // Failed the Url.Dll test. Check if this is NT5. In that case
            // maybe the icons are in migicons.exe (Win9x to NT5 upgrade).
            if (g_bRunOnNT5 && StrStrIA(pszPath,MIGICONS)!= NULL)
            {    // NT5 and 'migicons.exe' => upgrade. Set global to fix this.
                g_bNT5Upgrade = TRUE;
            }
            else
            {
                TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s is %hs, expecting %hs", Dbg_RegStr(pre, szDbg), pszPath, sz);
                bRet = FALSE;
            }
        }
        break;

    case RSCB_INSTALL:
        if (NO_ERROR != SHSetValueA(pre->hkeyRoot, pre->pszKey,
                                    pre->pszValName, dwType,
                                    sz, CbFromCchA(lstrlenA(sz) + 1)))
        {
            TraceMsg(TF_ERROR, "InstallRegSet(): SHSetValue(%s) Failed", Dbg_RegStr(pre, szDbg));
            bRet = FALSE;
        }
        else
        {
            DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
        }
        break;
    }
    return bRet;
}

/*----------------------------------------------------------
Purpose: This callback sets the default icon to point to a
         given index in iexplore.exe
Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_IEIconProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,       OPTIONAL
    IN DWORD      dwData)
{
    BOOL bRet = TRUE;
    CHAR sz[MAX_PATH + 20];    // Need a bit extra
    LPCSTR pszPath = (LPCSTR) pvData;
    int cch;
    DWORD dwType;  //local type.
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )
    
    ASSERT(RSCB_QUERY == nMsg && pvData ||
           RSCB_INSTALL == nMsg && !pvData);

    if (!g_fRunningOnNT) {
        // Sanity check that we don't coerce to REG_SZ wrongfully.
        // If you hit this assert, it means the table entry has the
        // wrong type in it.
        ASSERT(REG_EXPAND_SZ == pre->dwType || REG_SZ == pre->dwType);
        dwType = REG_SZ;
    } else
        dwType = (DWORD)pre->dwType;        
    
    if (!GetIEPath2(sz, SIZECHARS(sz), FALSE))
        return FALSE;
        
    cch = lstrlenA(sz);
    wnsprintfA(&sz[cch], ARRAYSIZE(sz) - cch, ",%d", (int)pre->DUMMYUNION_MEMBER(lParam));

    switch (nMsg)
    {
    case RSCB_QUERY:
        if (0 != StrCmpNIA(sz, pszPath, dwData / SIZEOF(CHAR)) &&
            0 != StrCmpA(PathFindFileNameA(sz), PathFindFileNameA(pszPath)))  
        {
            TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s is %hs, expecting %hs", Dbg_RegStr(pre, szDbg), pszPath, sz);
            bRet = FALSE;
        }
        break;

    case RSCB_INSTALL:
        if (NO_ERROR != SHSetValueA(pre->hkeyRoot, pre->pszKey,
                                    pre->pszValName, dwType,
                                    sz, CbFromCchA(lstrlenA(sz) + 1)))
        {
            TraceMsg(TF_ERROR, "InstallRegSet(): SHSetValue(%s) Failed", Dbg_RegStr(pre, szDbg));
            bRet = FALSE;
        }
        else
        {
            DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
        }
        break;
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: This callback sets the IExplore path.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_IEPathProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,       OPTIONAL
    IN DWORD      dwData)
{
    BOOL bRet = TRUE;
    CHAR sz[MAX_PATH + 20];    // Need a bit extra
    CHAR szOther[MAX_PATH + 20];    // Need a bit extra
    LPCSTR pszPath = (LPCSTR) pvData;
    int cch;
    DWORD dwType;
    
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )
    
    ASSERT(RSCB_QUERY == nMsg && pvData ||
           RSCB_INSTALL == nMsg && !pvData);
    
    ASSERT(REG_EXPAND_SZ == pre->dwType || REG_SZ == pre->dwType);
    
    if (!g_fRunningOnNT)
    {
        // Expand string is not supported on Win95
        dwType = REG_SZ;
    }
    else 
    {
        dwType = pre->dwType;        
    }
    
    if (GetIEPath(sz, SIZECHARS(sz))) {
        // sz contains the path as listed in AppPaths\IExplore.
        // NOTE NOTE: GetIEPath() uses the default value which has no
        // terminating ';'. Hence this check is not needed. Anyway, do it and
        // then convert to other form.
        cch = lstrlenA(sz) - 1;

        if (*sz && sz[cch] == ';')
            sz[cch] = '\0';

        // Convert this to LFN or SFN as the case may be.
        GetPathOtherFormA(sz, szOther, ARRAYSIZE(szOther));

        if (pre->DUMMYUNION_MEMBER(lParam))
        {
            StrCatBuffA(sz, (LPSTR)pre->DUMMYUNION_MEMBER(lParam), ARRAYSIZE(sz));
            StrCatBuffA(szOther, (LPSTR)pre->DUMMYUNION_MEMBER(lParam), ARRAYSIZE(szOther));
        }

        switch (nMsg)
        {
        case RSCB_QUERY:
            if ((0 != StrCmpNIA(pszPath, sz, dwData / SIZEOF(CHAR)))
                && (0 != StrCmpNIA(pszPath, szOther, dwData / SIZEOF(CHAR))))  
            {
                TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s string is \"%hs\", expecting \"%hs\"", Dbg_RegStr(pre, szDbg), pszPath, sz);
                bRet = FALSE;
            }
            break;

        case RSCB_INSTALL:
            if (NO_ERROR != SHSetValueA(pre->hkeyRoot, pre->pszKey,
                                        pre->pszValName, dwType,
                                        sz, CbFromCchA(lstrlenA(sz) + 1)))
            {
                TraceMsg(TF_ERROR, "InstallRegSet(): SHSetValue(%hs) Failed", pre->pszValName);
                bRet = FALSE;
            }
            else
            {
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
            }
            break;
        }
    }
    
    return bRet;
}

/*----------------------------------------------------------
Purpose: This callback checks for the existence of the string
         value "Exchange" at HKLM\Software\Microsoft.  If it
         exists, the value is copied into the default value
         of HKLM\Software\Clients\Mail\Exchange\shell\open\command.

         This is for Athena.  It only happens when setup is run, 
         not when the browser checks to see if it is the default.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_ExchangeProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,
    IN DWORD      dwData)
{
    TCHAR sz[MAX_PATH+2];  // +2 because we may need to wrap the path in quotes.
    DWORD cbSize;
    
    switch (nMsg)
    {
    case RSCB_QUERY:
        // We shouldn't be called for this one
        ASSERT(0);      
        break;

    case RSCB_INSTALL:
        // Does the Exchange value exist at "HKLM\Software\Microsoft"?  
        cbSize = sizeof(sz);
        if (NO_ERROR == SHGetValue(HKEY_LOCAL_MACHINE, 
            TEXT("Software\\Microsoft"), TEXT("Exchange"), NULL, sz, &cbSize))
        {
            // Yes; copy it to HKLM\Software\Clients\Mail\Exchange\shell\open\command
            TCHAR szT[MAX_PATH+2];

            // Wrap the path in quotes.  Don't wrap any args though!
            StrCpyN(szT, sz, ARRAYSIZE(szT));
            PathProcessCommand(szT, sz, ARRAYSIZE(szT), PPCF_ADDQUOTES|PPCF_ADDARGUMENTS);

            // Set the size again
            cbSize = CbFromCch(lstrlen(sz)+1);

            SHSetValue(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Clients\\Mail\\Exchange\\shell\\open\\command"),
                TEXT(""), REG_SZ, sz, cbSize);

            TraceMsg(TF_REGCHECK, "Copying \"%s\" to HKLM\\Software\\Clients\\Mail\\Exchange", sz);

            // Set any other settings in this condition too?
            if (pre->DUMMYUNION_MEMBER(lParam))
                InstallRegSet((const RegSet *)pre->DUMMYUNION_MEMBER(lParam), TRUE);

            // In OSR2 installs, the mailto handler will get out of
            // sync with the actual default mail client.  (Athena installs
            // itself as the default mail client, but exchange remains 
            // the mailto: handler.)  In this case, if exchange is the
            // mailto: handler, change the default mail client to be
            // exchange.

            // Is Exchange the mailto handler?
            cbSize = SIZEOF(sz);
            if (NO_ERROR == SHGetValue(HKEY_CLASSES_ROOT, TEXT("mailto\\shell\\open\\command"),
                                       TEXT(""), NULL, sz, &cbSize) &&
                StrStrI(sz, TEXT("url.dll,MailToProtocolHandler")))
            {
                // Yes; make it be the default mail client too
                SHSetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Clients\\Mail"),
                           TEXT(""), REG_SZ, TEXT("Exchange"), sizeof(TEXT("Exchange")));

                TraceMsg(TF_REGCHECK, "Setting Exchange to be the default mail client.");
            }
        }
        break;
    }
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Uninstall certain keys, as specified by pre->pszKey.

         We do not uninstall a key if the class\shell\open\command
         does not have iexplore.exe.

         If someone else registered themselves to add more
         verbs under class\shell (other than open) or class\shellex,
         then we remove everything but their keys.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_UninstallProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,
    IN DWORD      dwData)
{
    TCHAR szKey[MAX_PATH];
    TCHAR sz[MAX_PATH + 20];        // add some padding for arguments
    DWORD cbSize;

    switch (nMsg)
    {
    case RSCB_QUERY:
        // We shouldn't be called for this one
        ASSERT(0);      
        break;

    case RSCB_INSTALL:
        ASSERT(pre->pszKey);

        // Does the shell\open\command value have a microsoft browser?
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%hs\\shell\\open\\command"), pre->pszKey);

        cbSize = sizeof(sz);
        if (NO_ERROR == SHGetValue(pre->hkeyRoot, szKey, TEXT(""),
                                   NULL, sz, &cbSize) &&
            (StrStrI(sz, TEXT(IEXPLORE_EXE)) || StrStrI(sz, TEXT(EXPLORER_EXE))))
        {
            // Yes; proceed to prune this key of all of our values
            TraceMsg(TF_REGCHECK, "Pruning HKCR\\%hs", pre->pszKey);

            ASSERT(pre->DUMMYUNION_MEMBER(lParam));

            InstallRegSet((const RegSet *)pre->DUMMYUNION_MEMBER(lParam), FALSE);
        } 
        break;
    }
    return TRUE;
}


// NOTE: these are ANSI strings by design.

const DWORD c_dwEditFlags2            = FTA_Show;
const CHAR  c_szTelnetHandler[]       = "url.dll,TelnetProtocolHandler %l";
const CHAR  c_szMailToHandler[]       = "url.dll,MailToProtocolHandler %l";
const CHAR  c_szNewsHandler[]         = "url.dll,NewsProtocolHandler %l";
const CHAR  c_szFileHandler[]         = "url.dll,FileProtocolHandler %l";
const CHAR  c_szOpenURL[]             = "url.dll,OpenURL %l";
const CHAR  c_szOpenURLNash[]         = "shdocvw.dll,OpenURL %l";
const CHAR  c_szURL[]                 = "url.dll";
const CHAR  c_szShdocvw[]             = "shdocvw.dll";
const CHAR  c_szCheckAssnSwitch[]     = "Software\\Microsoft\\Internet Explorer\\Main";
const CHAR  c_szDDE_Default[]         = "\"%1\",,-1,0,,,,";
const CHAR  c_szDDE_FileDefault[]     = "\"file://%1\",,-1,,,,,";


// Note (scotth): a lot of the strings below have substrings that 
//  are repeated over and over and over again.  Should add some 
//  smarter RC_ values that will concatenate the common strings
//  together to save data space.

const CHAR c_szHTTP[]                = "http";
const CHAR c_szHTTPDefIcon[]         = "http\\DefaultIcon";
const CHAR c_szHTTPOpenCmd[]         = "http\\shell\\open\\command";
const CHAR c_szHTTPDdeexec[]         = "http\\shell\\open\\ddeexec";
const CHAR c_szHTTPDdeTopic[]        = "http\\shell\\open\\ddeexec\\Topic";
const CHAR c_szHTTPDdeApp[]          = "http\\shell\\open\\ddeexec\\Application";

const CHAR c_szHTTPS[]               = "https";
const CHAR c_szHTTPSDefIcon[]        = "https\\DefaultIcon";
const CHAR c_szHTTPSOpenCmd[]        = "https\\shell\\open\\command";
const CHAR c_szHTTPSDdeexec[]        = "https\\shell\\open\\ddeexec";
const CHAR c_szHTTPSDdeTopic[]       = "https\\shell\\open\\ddeexec\\Topic";
const CHAR c_szHTTPSDdeApp[]         = "https\\shell\\open\\ddeexec\\Application";

const CHAR c_szFTP[]                 = "ftp";
const CHAR c_szFTPDefIcon[]          = "ftp\\DefaultIcon";
const CHAR c_szFTPOpenCmd[]          = "ftp\\shell\\open\\command";
const CHAR c_szFTPDdeexec[]          = "ftp\\shell\\open\\ddeexec";
const CHAR c_szFTPDdeTopic[]         = "ftp\\shell\\open\\ddeexec\\Topic";
const CHAR c_szFTPDdeApp[]           = "ftp\\shell\\open\\ddeexec\\Application";
const CHAR c_szFTPDdeifExec[]        = "ftp\\shell\\open\\ddeexec\\ifExec";

const CHAR c_szGOPHER[]              = "gopher";
const CHAR c_szGOPHERDefIcon[]       = "gopher\\DefaultIcon";
const CHAR c_szGOPHEROpenCmd[]       = "gopher\\shell\\open\\command";
const CHAR c_szGOPHERDdeexec[]       = "gopher\\shell\\open\\ddeexec";
const CHAR c_szGOPHERDdeTopic[]      = "gopher\\shell\\open\\ddeexec\\Topic";
const CHAR c_szGOPHERDdeApp[]        = "gopher\\shell\\open\\ddeexec\\Application";

const CHAR c_szMailTo[]              = "mailto";
const CHAR c_szMailToDefIcon[]       = "mailto\\DefaultIcon";
const CHAR c_szMailToOpenCmd[]       = "mailto\\shell\\open\\command";

const CHAR c_szTelnet[]              = "telnet";
const CHAR c_szTelnetDefIcon[]       = "telnet\\DefaultIcon";
const CHAR c_szTelnetOpenCmd[]       = "telnet\\shell\\open\\command";

const CHAR c_szRLogin[]              = "rlogin";
const CHAR c_szRLoginDefIcon[]       = "rlogin\\DefaultIcon";
const CHAR c_szRLoginOpenCmd[]       = "rlogin\\shell\\open\\command";

const CHAR c_szTN3270[]              = "tn3270";
const CHAR c_szTN3270DefIcon[]       = "tn3270\\DefaultIcon";
const CHAR c_szTN3270OpenCmd[]       = "tn3270\\shell\\open\\command";

const CHAR c_szNews[]                = "news";
const CHAR c_szNewsDefIcon[]         = "news\\DefaultIcon";
const CHAR c_szNewsOpenCmd[]         = "news\\shell\\open\\command";

const CHAR c_szFile[]                = "file";
const CHAR c_szFileDefIcon[]         = "file\\DefaultIcon";
const CHAR c_szFileOpenCmd[]         = "file\\shell\\open\\command";

const CHAR c_szHTMDefIcon[]          = "htmlfile\\DefaultIcon";
const CHAR c_szHTMShell[]            = "htmlfile\\shell";
const CHAR c_szHTMOpen[]             = "htmlfile\\shell\\open";
const CHAR c_szHTMOpenCmd[]          = "htmlfile\\shell\\open\\command";
const CHAR c_szHTMOpenDdeexec[]      = "htmlfile\\shell\\open\\ddeexec";
const CHAR c_szHTMOpenDdeTopic[]     = "htmlfile\\shell\\open\\ddeexec\\Topic";
const CHAR c_szHTMOpenDdeApp[]       = "htmlfile\\shell\\open\\ddeexec\\Application";

const CHAR c_szMHTMDefIcon[]         = "mhtmlfile\\DefaultIcon";
const CHAR c_szMHTMShell[]           = "mhtmlfile\\shell";
const CHAR c_szMHTMOpen[]            = "mhtmlfile\\shell\\open";
const CHAR c_szMHTMOpenCmd[]         = "mhtmlfile\\shell\\open\\command";
const CHAR c_szMHTMOpenDdeexec[]     = "mhtmlfile\\shell\\open\\ddeexec";
const CHAR c_szMHTMOpenDdeTopic[]    = "mhtmlfile\\shell\\open\\ddeexec\\Topic";
const CHAR c_szMHTMOpenDdeApp[]      = "mhtmlfile\\shell\\open\\ddeexec\\Application";

const CHAR c_szOpenNew[]             = "opennew";
const CHAR c_szHTMOpenNew[]          = "htmlfile\\shell\\opennew";
const CHAR c_szHTMOpenNewCmd[]       = "htmlfile\\shell\\opennew\\command";
const CHAR c_szHTMOpenNewDdeexec[]   = "htmlfile\\shell\\opennew\\ddeexec";
const CHAR c_szHTMOpenNewDdeIfExec[] = "htmlfile\\shell\\opennew\\ddeexec\\IfExec";
const CHAR c_szHTMOpenNewDdeTopic[]  = "htmlfile\\shell\\opennew\\ddeexec\\Topic";
const CHAR c_szHTMOpenNewDdeApp[]    = "htmlfile\\shell\\opennew\\ddeexec\\Application";

const CHAR c_szMHTMOpenNew[]          = "mhtmlfile\\shell\\opennew";
const CHAR c_szMHTMOpenNewCmd[]       = "mhtmlfile\\shell\\opennew\\command";
const CHAR c_szMHTMOpenNewDdeexec[]   = "mhtmlfile\\shell\\opennew\\ddeexec";
const CHAR c_szMHTMOpenNewDdeIfExec[] = "mhtmlfile\\shell\\opennew\\ddeexec\\IfExec";
const CHAR c_szMHTMOpenNewDdeTopic[]  = "mhtmlfile\\shell\\opennew\\ddeexec\\Topic";
const CHAR c_szMHTMOpenNewDdeApp[]    = "mhtmlfile\\shell\\opennew\\ddeexec\\Application";

const CHAR c_szIntShcut[]            = "InternetShortcut";
const CHAR c_szIntShcutDefIcon[]     = "InternetShortcut\\DefaultIcon";
const CHAR c_szIntShcutCLSID[]       = "InternetShortcut\\CLSID";
const CHAR c_szIntShcutOpen[]        = "InternetShortcut\\shell\\open";
const CHAR c_szIntShcutOpenCmd[]     = "InternetShortcut\\shell\\open\\command";
const CHAR c_szIntShcutIconHandler[] = "InternetShortcut\\shellex\\IconHandler";
const CHAR c_szIntShcutPrshtHandler[]= "InternetShortcut\\shellex\\PropertySheetHandlers\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szIntShcutPropHandler[] = "InternetShortcut\\shellex\\PropertyHandler";
const CHAR c_szIntShcutCMHandler[]   = "InternetShortcut\\shellex\\ContextMenuHandlers\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}";

const CHAR c_szCLSIDCmdFile[]       = "{57651662-CE3E-11D0-8D77-00C04FC99D61}";
const CHAR c_szCLSIDIntshcut[]      = "{FBF23B40-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szCLSIDURLExecHook[]   = "{AEB6717E-7E19-11d0-97EE-00C04FD91972}";

const CHAR c_szIntshcutInproc[]      = "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}\\InProcServer32";
const CHAR c_szIEFrameAuto[]         = "CLSID\\{0002DF01-0000-0000-C000-000000000046}\\LocalServer32";
const CHAR c_szIENameSpaceOpen[]     = "CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\shell\\open\\command";
const CHAR c_szCLSIDURLRoot[]        = "CLSID\\{3DC7A020-0ACD-11CF-A9BB-00AA004AE837}";
const CHAR c_szIntshcutMayChange[]   = "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}\\shellex\\MayChangeDefaultMenu";

// 
// General associations shared across browser-only and full-shell
//

const RegEntry c_rlAssoc[] = {
    // HTTP
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szHTTP, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_HTTPNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTP, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTP, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED
                   |REF_DONTINTRUDE, HKCR, c_szHTTPDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // HTTPS
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szHTTPS, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_HTTPSNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTPS, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTPS, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED|REF_DONTINTRUDE, HKCR, c_szHTTPSDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // FTP
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szFTP, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_FTPNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szFTP, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szFTP, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED|REF_DONTINTRUDE, HKCR, c_szFTPDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // Gopher
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szGOPHER, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_GOPHERNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szGOPHER, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szGOPHER, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED|REF_DONTINTRUDE, HKCR, c_szGOPHERDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // Telnet
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTelnet, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_TELNETNAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTelnet, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTelnet, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szTelnetDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szTelnetOpenCmd, "", REG_SZ, sizeof(c_szTelnetHandler), c_szTelnetHandler },

    // RLogin
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szRLogin, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_RLOGINNAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szRLogin, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szRLogin, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szRLoginDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szRLoginOpenCmd, "", REG_SZ, sizeof(c_szTelnetHandler), c_szTelnetHandler },

    // TN3270
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTN3270, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_TN3270NAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTN3270, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTN3270, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szTN3270DefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szTN3270OpenCmd, "", REG_SZ, sizeof(c_szTelnetHandler), c_szTelnetHandler },

    // Mailto protocol
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szMailTo, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_MAILTONAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szMailTo, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szMailTo, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szMailToDefIcon, "", REG_EXPAND_SZ, IDEFICON_MAIL, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szMailToOpenCmd, "", REG_SZ, sizeof(c_szMailToHandler), c_szMailToHandler },

    // News protocol
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szNews, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_NEWSNAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szNews, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szNews, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szNewsDefIcon, "", REG_EXPAND_SZ, IDEFICON_NEWS, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szNewsOpenCmd, "", REG_SZ, sizeof(c_szNewsHandler), c_szNewsHandler },

    // Internet shortcut
    { RC_ADD,      REF_NORMAL,      HKCR, ".url", "", REG_SZ, sizeof(c_szIntShcut), c_szIntShcut },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcut, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_INTSHNAME) },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szIntShcut, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcut, "IsShortcut", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcut, "NeverShowExt", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcutCLSID, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szIntShcutDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcutIconHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcutPrshtHandler, "", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL,      HKCR, "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_INTSHNAME) },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntshcutInproc, "", REG_SZ, sizeof(c_szShdocvw), c_szShdocvw },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntshcutInproc, "ThreadingModel", REG_SZ, sizeof("Apartment"), "Apartment" },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntshcutInproc, "LoadWithoutCOM", REG_SZ, 1, ""},

    // HTM file type
    { RC_CALLBACK,      REF_NOTNEEDED,   HKCR, c_szHTMDefIcon, "", REG_SZ, (LPARAM)1, HTReg_IEIconProc },

    // MHTML file type
    { RC_CALLBACK,      REF_NOTNEEDED,   HKCR, c_szMHTMDefIcon, "", REG_SZ, (LPARAM)22, HTReg_IEIconProc },
};


const RegSet c_rsAssoc = {
    ARRAYSIZE(c_rlAssoc),
    c_rlAssoc
};


//
// .htm, .html associations for full-shell and browser-only installs
// 

// This is run when the browser is opened, and considered a requirement
// to make IE be the default browser.
#ifdef UNIX
const RegEntry c_rlAssocHTM[] = {
#else
const RegList c_rlAssocHTM = {
#endif
    // .html
    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".htm", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".htm", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },

    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".html", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".html", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },
};

const RegSet c_rsAssocHTM = {
    ARRAYSIZE(c_rlAssocHTM),
    c_rlAssocHTM
};


// This is the minimum set that is queried every time a shell window opens.  
// WARNING: this should be small to reduce the time it takes to open a folder.

// This is needed just to insure webview works.
//
const RegEntry c_rlAssocHTM_WV[] = {
    // .html
    { RC_ADD,      REF_IFEMPTY, HKCR, ".htm", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_IFEMPTY, HKCR, ".htm", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },

    { RC_ADD,      REF_IFEMPTY, HKCR, ".html", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_IFEMPTY, HKCR, ".html", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },
};


const RegSet c_rsAssocHTM_WV = {
    ARRAYSIZE(c_rlAssocHTM_WV),
    c_rlAssocHTM_WV
};


//
// Browser-only specific association settings
// 

const RegEntry c_rlAssoc_Alone[] = {
    // HTTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // HTTPS
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPSOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // FTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szFTPOpenCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeifExec, "", REG_SZ, sizeof("*"), "*" },

    // Gopher
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szGOPHEROpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szGOPHERDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szGOPHERDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szGOPHERDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // File protocol
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFile, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_FILENAME) },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFile, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFile, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szFileDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFileOpenCmd, "", REG_SZ, sizeof(c_szFileHandler), c_szFileHandler },

    // .htm
    //
    //  APPCOMPAT:
    //  HTMOpenCmd needs to be REG_SZ because Office97 reads it out using RegQueryValue.
    //  WebFerret requires the string to be of type REG_SZ.
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // .mht, .mhtml
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szMHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // Internet shortcut
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },

    // Other stuff
    { RC_RUNDLL,   REF_NORMAL,       HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURLNash), c_szOpenURLNash },
    { RC_CALLBACK, REF_NORMAL,       HKCR, c_szIEFrameAuto, "", REG_SZ, 0, HTReg_IEPathProc },
    { RC_CALLBACK, REF_NORMAL,       HKCR, c_szIENameSpaceOpen, "", REG_SZ, 0, HTReg_IEPathProc },
};

const RegSet c_rsAssoc_Alone = {
    ARRAYSIZE(c_rlAssoc_Alone),
    c_rlAssoc_Alone
};


// The reg entries for the browser only case for http, https, and ftp are duplicated here
const RegEntry c_rlAssoc_Quick[] = {
    // HTTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // HTTPS
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPSOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // FTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szFTPOpenCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeifExec, "", REG_SZ, sizeof("*"), "*" },

};

const RegSet c_rsAssoc_Quick = {
    ARRAYSIZE(c_rlAssoc_Quick),
    c_rlAssoc_Quick
};




//
// Full-shell specific association settings
// 

const RegEntry c_rlAssoc_Full[] = {
    // HTTP
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szHTTPOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // HTTPS
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szHTTPSOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // FTP
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szFTPOpenCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeifExec, "", REG_SZ, sizeof("*"), "*" },

    // Gopher
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szGOPHEROpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // .htm
    //
    //  APPCOMPAT:
    //  HTMOpenCmd needs to be REG_SZ because Office97 reads it out using RegQueryValue.
    //  WebFerret requires the string to be of type REG_SZ.
    //  Visual Source Safe reads the Ddeexec string, puts a file in the %1 (NOT %l!),
    //  and performs a dde transaction, so we are pretty much stuck with the "file:%1,,-1,,,,," string now.
    //
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMShell, "", REG_SZ, sizeof(c_szOpenNew), c_szOpenNew },

    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpen, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPENSAME)},
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMShell, "", REG_SZ, sizeof(c_szOpenNew), c_szOpenNew },
   
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNew, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPEN)},
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szHTMOpenNewCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default},
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeIfExec, "", REG_SZ, sizeof("*"), "*"},
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeTopic, "", REG_SZ, sizeof("WWW_OpenURLNewWindow"), "WWW_OpenURLNewWindow" },

    // .mht, .mhtml
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpen, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPENSAME)},
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szMHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNew, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPEN)},
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szMHTMOpenNewCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeIfExec, "", REG_SZ, sizeof("*"), "*"},
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeTopic, "", REG_SZ, sizeof("WWW_OpenURLNewWindow"), "WWW_OpenURLNewWindow" },

    // Internet shortcut
    { RC_ADD,      REF_NORMAL, HKCR, c_szCLSIDURLRoot, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_THEINTERNET) },
    { RC_RUNDLL,   REF_NORMAL, HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURLNash), c_szOpenURLNash },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutOpen, "CLSID", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutOpen, "LegacyDisable", REG_SZ, 1, ""},
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntshcutMayChange, "", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutPropHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },

    //  add ourselves to the applications key
    { RC_CALLBACK, REF_NORMAL, HKCR, "Applications\\iexplore.exe\\shell\\open\\command", "", REG_SZ, (LPARAM)" ""%1""", HTReg_IEPathProc},

    // Other stuff
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szIEFrameAuto, "", REG_SZ, 0, HTReg_IEPathProc },
};


const RegSet c_rsAssoc_Full = {
    ARRAYSIZE(c_rlAssoc_Full),
    c_rlAssoc_Full
};


//
// On upgrading from Win9x to NT5, the icons are shifted to newly created
// file called "migicons.exe". This breaks our Assoc checks. Hence this is
// a list of all HTReg_UrlIconProc checks from the various Assoc arrays that
// MUST BELONG TO US FOR US TO BE DEFAULT BROWSER (REF_NOTNEEDED and
// REF_IFEMPTY ==> not used for check purposes). 
// This list is used to fix the icons.
//
// NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: 
// Any new Icon check that uses HTReg_UrlIconProc that gets added
// to any of the Assoc arrays and is REQUIRED for Default Browser check to
// succeed has to be added here also.
//

const RegEntry c_rlAssoc_FixIcon[] = {
    // Icon checks from c_rlAssoc that are essential for us to be Default
    // Browser
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szIntShcutDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc }
};

const RegSet c_rsAssoc_FixIcon = {
    ARRAYSIZE(c_rlAssoc_FixIcon),
    c_rlAssoc_FixIcon
};


// 
// General browser-only settings
//

const CHAR c_szCLSIDMIME[]           = "{FBF23B41-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szIEOnDesktop[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szShellExecHook[]       = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellExecuteHooks";
const CHAR c_szFileTypesHook[]       = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileTypesPropertySheetHook";

const RegEntry c_rlGeneral_Alone[] = {
    { RC_ADD,   REF_NORMAL, HKLM, c_szIEOnDesktop,   "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_THEINTERNET) },
    { RC_ADD,   REF_NORMAL, HKLM, c_szFileTypesHook, "", REG_SZ, sizeof(c_szCLSIDMIME), c_szCLSIDMIME },

    // URL Exec Hook (CLSID_URLExecHook) (this replaces the old overloaded intshcut CLSID)
    { RC_DEL,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDIntshcut, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDURLExecHook, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_URLEXECHOOK) },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "", REG_SZ, sizeof("url.dll"), "url.dll" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "ThreadingModel", REG_SZ, sizeof("Apartment"), "Apartment" },
};

const RegSet c_rsGeneral_Alone = {
    ARRAYSIZE(c_rlGeneral_Alone),
    c_rlGeneral_Alone
};


//
// General full-shell only settings
//

const RegEntry c_rlGeneral_Full[] = {
    { RC_DEL,   REF_NORMAL, HKLM, c_szIEOnDesktop,        "", REG_SZ, 0, NULL },
    { RC_DEL,   REF_NUKE,   HKLM, c_szFileTypesHook,      "", REG_SZ, sizeof(c_szCLSIDMIME), c_szCLSIDMIME },

    // URL Exec Hook (this replaces the old overloaded intshcut CLSID)
    { RC_DEL,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDIntshcut, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDURLExecHook, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_URLEXECHOOK) },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "", REG_SZ, sizeof("shell32.dll"), "shell32.dll" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "ThreadingModel", REG_SZ, sizeof("Apartment"), "Apartment" },
};

const RegSet c_rsGeneral_Full = {
    ARRAYSIZE(c_rlGeneral_Full),
    c_rlGeneral_Full
};


// XP start menu
// Note: the IE start menu reg entries are created in ie.inx, this table is only needed
// to restore IE as default browser in the start menu (as a result of the user prompts)
const RegEntry c_rlStartMenu_XP[] = {
    // make IE the default internet browser for this machine's Start Menu
    { RC_ADD,      REF_NORMAL, HKLM, "Software\\Clients\\StartMenuInternet", "", REG_SZ, 0, "IEXPLORE.EXE" },
};

const RegSet c_rsStartMenu_XP = {
    ARRAYSIZE(c_rlStartMenu_XP),
    c_rlStartMenu_XP
};

const RegEntry c_rlStartMenu_XP_CU[] = {
    // make IE the default internet browser for this user's Start Menu
    { RC_ADD,      REF_NORMAL, HKCU, "Software\\Clients\\StartMenuInternet", "", REG_SZ, 0, "IEXPLORE.EXE" },
};

const RegSet c_rsStartMenu_XP_CU = {
    ARRAYSIZE(c_rlStartMenu_XP_CU),
    c_rlStartMenu_XP_CU
};

/*
 * S P E C I A L   D Y N A M I C   S E T T I N G S 
 *
 */

#define SZ_EXMAILTO     "Software\\Clients\\Mail\\Exchange\\Protocols\\Mailto"

const RegEntry c_rlExchange[] = {
    { RC_ADD,      REF_NORMAL,    HKLM, "Software\\Clients\\Mail\\Exchange", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_EXCHANGE) },

    { RC_ADD,      REF_IFEMPTY,   HKLM, SZ_EXMAILTO, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_MAILTONAME) },
    { RC_ADD,      REF_IFEMPTY,   HKLM, SZ_EXMAILTO, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKLM, SZ_EXMAILTO, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKLM, SZ_EXMAILTO "\\DefaultIcon", "", REG_EXPAND_SZ, IDEFICON_MAIL, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKLM, SZ_EXMAILTO "\\Shell\\Open\\Command", "", REG_SZ, sizeof(c_szMailToHandler), c_szMailToHandler },
};

const RegSet c_rsExchange = {
    ARRAYSIZE(c_rlExchange),
    c_rlExchange
};

#ifdef UNIX
const RegEntry c_rlAthena[] = {
#else
const RegList c_rlAthena = {
#endif
   { RC_CALLBACK, REF_NORMAL, HKLM, "", "", REG_SZ, (LPARAM)&c_rsExchange, HTReg_ExchangeProc },
};

const RegSet c_rsAthena = {
    ARRAYSIZE(c_rlAthena),
    c_rlAthena
};


/*
 * U N I N S T A L L   S E T T I N G S
 *
 */


// Protocol-specific uninstall (for both full-shell and browser-only)

const RegEntry c_rlUnHTTP[] = {
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTP, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szHTTPOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szHTTP, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTTP = {
    ARRAYSIZE(c_rlUnHTTP),
    c_rlUnHTTP
};

#ifdef UNIX
const RegEntry c_rlUnHTTPS[] = {
#else
const RegList c_rlUnHTTPS = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPS, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szHTTPSOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szHTTPS, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTTPS = {
    ARRAYSIZE(c_rlUnHTTPS),
    c_rlUnHTTPS
};

#ifdef UNIX
const RegEntry c_rlUnFTP[] = { 
#else  
const RegList c_rlUnFTP = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTP, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szFTPOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szFTP, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnFTP = {
    ARRAYSIZE(c_rlUnFTP),
    c_rlUnFTP
};

#ifdef UNIX
const RegEntry c_rlUnGopher[] = {
#else
const RegList c_rlUnGopher = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHER, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szGOPHEROpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szGOPHER, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnGopher = {
    ARRAYSIZE(c_rlUnGopher),
    c_rlUnGopher
};

#ifdef UNIX 
const RegEntry c_rlUnHTM[] = {
#else
const RegList c_rlUnHTM = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMOpenDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMOpenDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMOpenDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szHTMOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, "htmlfile", "", REG_SZ, 0, NULL },

    { RC_DEL, REF_NORMAL,    HKCR, c_szMHTMDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, "mhtmlfile", "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTM = {
    ARRAYSIZE(c_rlUnHTM),
    c_rlUnHTM
};


// Protocol-specific uninstall for full-shell

#ifdef UNIX
const RegEntry c_rlUnHTTP_Full[] = {
#else
const RegList c_rlUnHTTP_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szHTTPDdeexec, "NoActivateHandler", REG_SZ, 0, NULL }
};

const RegSet c_rsUnHTTP_Full = {
    ARRAYSIZE(c_rlUnHTTP_Full),
    c_rlUnHTTP_Full
};

#ifdef UNIX
const RegEntry c_rlUnHTTPS_Full[] = {
#else
const RegList c_rlUnHTTPS_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szHTTPSDdeexec, "NoActivateHandler", REG_SZ, 0, NULL }
};

const RegSet c_rsUnHTTPS_Full = {
    ARRAYSIZE(c_rlUnHTTPS_Full),
    c_rlUnHTTPS_Full
};

#ifdef UNIX
const RegEntry c_rlUnFTP_Full[] = {
#else
const RegList c_rlUnFTP_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szFTPDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
};

const RegSet c_rsUnFTP_Full = {
    ARRAYSIZE(c_rlUnFTP_Full),
    c_rlUnFTP_Full
};

#ifdef UNIX
const RegEntry c_rlUnGopher_Full[] = {
#else
const RegList c_rlUnGopher_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szGOPHERDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
};

const RegSet c_rsUnGopher_Full = {
    ARRAYSIZE(c_rlUnGopher_Full),
    c_rlUnGopher_Full
};

#ifdef UNIX
const RegEntry c_rlUnHTM_Full[] = {
#else
const RegList c_rlUnHTM_Full = {
    // remove the default context menu items
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMShell, NULL, REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMShell, NULL, REG_SZ, 0, NULL },

    // remove the default values
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNew, NULL, REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNew, NULL, REG_SZ, 0, NULL },

    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,  HKCR, c_szHTMOpenNewCmd, "", REG_SZ, 0, NULL },

    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,  HKCR, c_szMHTMOpenNewCmd, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTM_Full = {
    ARRAYSIZE(c_rlUnHTM_Full),
    c_rlUnHTM_Full
};

//
// Browser-only uninstall
//

#ifdef UNIX
const RegEntry c_rlUninstall_Alone[] = {
#else
const RegList c_rlUninstall_Alone = {
#endif
    { RC_DEL,      REF_NORMAL, HKLM, c_szIEOnDesktop,   "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_THEINTERNET) },
    { RC_DEL,      REF_PRUNE,  HKCR, c_szIENameSpaceOpen,   "", REG_SZ, 0, NULL },

    // InternetShortcut
    { RC_DEL,    REF_NORMAL, HKCR, c_szIntShcutOpen, "CLSID", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntshcutMayChange, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutPropHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },

    // Change the inprocserver after removing "MayChangeDefaultMenu" above.  
    // Do this so url.dll doesn't repatch the registry.
    { RC_ADD,    REF_NORMAL, HKCR, c_szIntshcutInproc, "", REG_SZ, sizeof(c_szURL), c_szURL },
    { RC_RUNDLL, REF_NORMAL, HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURL), c_szOpenURL },

    { RC_CALLBACK, REF_NORMAL, HKCR, "http",     "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnHTTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "https",    "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnHTTPS, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "ftp",      "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnFTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "gopher",   "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnGopher, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "htmlfile", "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnHTM, HTReg_UninstallProc },
};

const RegSet c_rsUninstall_Alone = {
    ARRAYSIZE(c_rlUninstall_Alone),
    c_rlUninstall_Alone
};


// 
// Full-shell uninstall
//

#ifdef UNIX
const RegEntry c_rlUninstall_Full[] = {
#else
const RegList c_rlUninstall_Full = {
#endif
    // InternetShortcut
    { RC_DEL,    REF_NORMAL, HKCR, c_szIntShcutOpen, "CLSID", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_DEL,    REF_NORMAL, HKCR, c_szIntShcutOpen, "LegacyDisable", REG_SZ, 1, ""},
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntshcutMayChange, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutPropHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },

    // Change the inprocserver after removing "MayChangeDefaultMenu" above.  
    // Do this so url.dll doesn't repatch the registry.
    { RC_ADD,    REF_NORMAL, HKCR, c_szIntshcutInproc, "", REG_SZ, sizeof(c_szURL), c_szURL },
    { RC_RUNDLL, REF_NORMAL, HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURL), c_szOpenURL },

    // Protocol associations
    { RC_CALLBACK, REF_NORMAL, HKCR, "http",      "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTP_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "http",      "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "https",     "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTPS_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "https",     "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTPS, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "ftp",       "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnFTP_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "ftp",       "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnFTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "gopher",    "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnGopher_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "gopher",    "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnGopher, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "htmlfile",  "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTM_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "htmlfile",  "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTM, HTReg_UninstallProc },
};

const RegSet c_rsUninstall_Full = {
    ARRAYSIZE(c_rlUninstall_Full),
    c_rlUninstall_Full
};



/*
 *   D E F A U L T    S E T    O F    R E G   S E T S
 *
 */


// Common association settings for both browser-only and full-shell

// This is the required set of entries to make IE be the default 
// browser.  Only used if the user hasn't turned this off.

const RegSet * const g_rgprsDefault[] = {
    &c_rsAssoc,
    &c_rsAssocHTM,
};

// Browser-only specific associations

const RegSet * const g_rgprsDefault_Alone[] = {
    &c_rsAssoc_Alone,
};

// Browser-only specific associations for a quick check
const RegSet * const g_rgprsDefault_Quick[] = {
    &c_rsAssoc_Quick,
};


// Full-shell specific associations

const RegSet * const g_rgprsDefault_Full[] = {
    &c_rsAssoc_Full,
};

// This is the set of icon entries that need to be fixed in case of a 
// Win9x to NT5 upgrade.

const RegSet * const g_rgprsDefault_FixIcon[] = {
    &c_rsAssoc_FixIcon,
};



//
// Other registry settings
//

const RegSet * const g_rgprsIE30Only[] = 
    {
    &c_rsGeneral_Alone,
    &c_rsAthena,
    };


const RegSet * const g_rgprsNashOnly[] = 
    {
    &c_rsGeneral_Full,
    &c_rsAthena,
    };


const RegSet * const g_rgprsUninstallIE30[] = 
    {
    &c_rsUninstall_Alone,
    };


const RegSet * const g_rgprsUninstallNash[] = 
    {
    &c_rsUninstall_Full,
    };


/*----------------------------------------------------------
Purpose: Determine if a particular RegSet is installed

Returns: 
Cond:    --
*/
BOOL
IsRegSetInstalled( 
    IN const RegSet * prs)
    {
    BOOL        bRet = FALSE;
    UINT        i;
    HKEY        hkey = NULL;
    const RegEntry * pre;
    CHAR        szBuffer[1024];         // Registry Data Holder
    CHAR        szT[MAX_PATH + 20]; // Need a bit extra for pszIExpAppendage
    DWORD       dwType;
    DWORD       dwSize;
    DWORD       dwSizeExpect;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    // Check each registry entry.  Stop when we encounter the first
    // entry which doesn't match (no need to waste time looking at
    // other entries).
    //
    // In the debug build, we enumerate the whole list, so we can
    // see all the differences at once.
    //

#ifdef DEBUG
    #define BAIL_OUT    bRet = TRUE; continue
#else
    #define BAIL_OUT    goto Bail
#endif


    for (i = 0; i < prs->cre; i++)  
        {
        pre = &(prs->pre[i]);

        // Is this regentry not needed, or can it be set by some third 
        // party?
        if (IsFlagSet(pre->dwFlags, REF_NOTNEEDED))
            {
            // Yes; skip to next
            continue;
            }

        // Does the key exist?
        if (NO_ERROR != RegOpenKeyA(pre->hkeyRoot, pre->pszKey, &hkey))  
        {
            // No; should it?
            if (RC_DEL == pre->regcmd)
            {
                // No; skip to next
                continue;
            }
            else
            {
                // Yes
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s doesn't exist and should", Dbg_RegStr(pre, szDbg)); )
                BAIL_OUT;
            }
        }
        // Yes; should it?
        else if (RC_DEL == pre->regcmd && !*pre->pszValName)
        {
            // No
            DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s exists and shouldn't", Dbg_RegStr(pre, szDbg)); )
            RegCloseKey(hkey);
            BAIL_OUT;
        }

        // Does the value exist?
        dwSize = SIZEOF(szBuffer);
        if (NO_ERROR != RegQueryValueExA(hkey, pre->pszValName, NULL, 
                                         &dwType, (BYTE *)szBuffer, &dwSize))  
        {
            // No; should it?
            if (RC_DEL != pre->regcmd)
            {
                // Yes
                TraceMsg(TF_REGCHECK, "IsRegSetInstalled: RegQueryValueEx( %hs, %hs ) Failed", pre->pszKey, pre->pszValName);
                RegCloseKey(hkey);
                BAIL_OUT;
            }
        }
        // Yes; should it?
        else if (RC_DEL == pre->regcmd)
        {
            // No
            ASSERT(pre->pszValName && *pre->pszValName);

            DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s exists and shouldn't", 
                                 Dbg_RegStr(pre, szDbg)); )
            RegCloseKey(hkey);
            BAIL_OUT;
        }
        RegCloseKey(hkey);

        // Is this a value that cannot be stomped (ie, a 3rd party might have
        // set its value, and that's okay with us)?
        if (IsFlagSet(pre->dwFlags, REF_IFEMPTY))
            {
            // Yes; the existence of the value is good enough for us,
            // skip to next
            continue;
            }

        switch (pre->regcmd)  
            {
        case RC_ADD:
        case RC_RUNDLL:
            if (dwType == REG_SZ)  
            {
                LPCVOID pvValue;

                // Is this a resource string?
                if (0 == HIWORD64(pre->pvValue))
                {
                    // Yes; load it 
                    dwSizeExpect = LoadStringA(g_hinst, PtrToUlong(pre->pvValue), szT, SIZECHARS(szT));

                    // Add null and convert to bytes
                    dwSizeExpect = CbFromCchA(dwSizeExpect + 1);
                    pvValue = szT;
                }
                else
                {
                    // No
                    ASSERT(pre->pvValue);

                    if (RC_RUNDLL == pre->regcmd)
                    {
                        wnsprintfA(szT, ARRAYSIZE(szT), RUNDLL_CMD_FMT, (LPSTR)pre->pvValue);
                        pvValue = szT;

                        // Add null and convert to bytes
                        dwSizeExpect = CbFromCchA(lstrlenA(szT) + 1);
                    }
                    else
                    {
                        pvValue = pre->pvValue;

                        if (0 == pre->DUMMYUNION_MEMBER(dwSize))
                            dwSizeExpect = (DWORD)CbFromCchA(lstrlenA((LPCSTR)pvValue) + 1);
                        else
                            dwSizeExpect = (DWORD)pre->DUMMYUNION_MEMBER(dwSize);
                    }
                }

                if (dwSize != dwSizeExpect)
                {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s string size is %d, expecting %d", Dbg_RegStr(pre, szDbg), dwSize, dwSizeExpect);
                    BAIL_OUT;
                }

                // Compare case-insensitive (otherwise we'd just use 
                // memcmp below)
                if (0 != StrCmpNIA((LPSTR)pvValue, szBuffer, dwSize / SIZEOF(CHAR)))  
                    {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s string is \"%hs\", expecting \"%hs\"", Dbg_RegStr(pre, szDbg), szBuffer, pvValue);
                    BAIL_OUT;
                    }
                } 
            else 
                {
                // Non-string case
                if (dwSize != pre->DUMMYUNION_MEMBER(dwSize))  
                    {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s size is %d, expecting %d", Dbg_RegStr(pre, szDbg), dwSize, pre->DUMMYUNION_MEMBER(dwSize));
                    BAIL_OUT;
                    }

                if (0 != memcmp(pre->pvValue, (BYTE *)szBuffer, dwSize))  
                    {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s value is different, expecting %#08x", Dbg_RegStr(pre, szDbg), *(LPDWORD)pre->pvValue);
                    BAIL_OUT;
                    }
                }
            break;

        case RC_CALLBACK:
        {
            RSPECPROC pfn = (RSPECPROC)pre->pvValue;

            ASSERT(IS_VALID_CODE_PTR(pfn, RSPECPROC));

            // If the callback returns false, it means we're not the
            // default browser.
            if ( !pfn(RSCB_QUERY, pre, szBuffer, dwSize) )
                BAIL_OUT;
            break;
        }

        case RC_DEL:
            // Work is done before the switch statement.  Do nothing here.
            break;

        default:
            ASSERT(0);
            TraceMsg(TF_ERROR, "IsRegSetInstalled: Unhandled Special Type");
            break;
            }
        }

#ifdef DEBUG
    // In the debug build, leaving the above loop with bRet == TRUE means
    // something doesn't match, so we need to flip the boolean value.
    bRet ^= TRUE;
#else
    bRet = TRUE;

Bail:
#endif
    return bRet;
    }
                    

/*----------------------------------------------------------
Purpose: Returns TRUE if the key is empty of all subkeys and
         all (non-default) values.

         If dwFlags has REF_EDITFLAGS set, then this function 
         ignores the EditFlags value.

Returns: see above
Cond:    --
*/
BOOL
IsKeyPsuedoEmpty(
    IN HKEY   hkey,
    IN LPCSTR pszSubKey,
    IN DWORD  dwFlags)          // REF_ flags
{
    BOOL bRet = FALSE;
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_READ, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        DWORD ckeys;
        DWORD cvalues;

        // Are the any subkeys?
        if (NO_ERROR == RegQueryInfoKey(hkeyNew, NULL, NULL, NULL, &ckeys,
                                        NULL, NULL, &cvalues, NULL, NULL,
                                        NULL, NULL) &&
            0 == ckeys)
        {
            // No; how about non-default values?
            DWORD dwRetDef = SHGetValueA(hkey, pszSubKey, "", NULL, NULL, NULL);

            bRet = (0 == cvalues || (1 == cvalues && NO_ERROR == dwRetDef));

            // Should we ignore edit flags?
            if (!bRet && IsFlagSet(dwFlags, REF_EDITFLAGS))
            {
                // Yes
                DWORD dwRetEdit = SHGetValueA(hkey, pszSubKey, "EditFlags", NULL, NULL, NULL);

                bRet = ((1 == cvalues && NO_ERROR == dwRetEdit) || 
                        (2 == cvalues && NO_ERROR == dwRetEdit && 
                         NO_ERROR == dwRetDef));
            }
        }
        RegCloseKey(hkeyNew);
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Prune the key of our keys and values.  Walk back up
         the tree and delete empty keys below us.

Returns: 
Cond:    --
*/
void
PruneKey(
    IN HKEY    hkeyRoot,
    IN LPCSTR  pszKey)
{
    CHAR szPath[MAX_PATH];

    ASSERT(hkeyRoot);
    ASSERT(pszKey);

    StrCpyNA(szPath, pszKey, ARRAYSIZE(szPath));

    while (PathRemoveFileSpecA(szPath) && *szPath)
    {
        SHDeleteOrphanKeyA(hkeyRoot, szPath);
    }
}


/*----------------------------------------------------------
Purpose: Install a regset (set of registry entries).

         If bDontIntrude is TRUE , then behave such that any
         REF_DONTINTRUDE entry is not forcefully installed (i.e., it
         will only get installed if the key doesn't already
         have a value in it).  

Returns: 
Cond:    --
*/
BOOL
InstallRegSet( 
    IN const RegSet *prs,
    IN BOOL  bDontIntrude)
    {
    BOOL        bRet = TRUE;
    UINT        i;
    HKEY        hkey;
    const RegEntry * pre;
    CHAR        szBuffer[MAX_PATH + 20];    // Need additional space for pszIExpAppendage
    DWORD       dwSize;
    LPCVOID     pvValue;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    /*
     * Install each registry entry
     */
    for (i = 0; i < prs->cre; i++)  
        {
        pre = &(prs->pre[i]);

        // Stomp on this value?
        if (bDontIntrude && IsFlagSet(pre->dwFlags, REF_DONTINTRUDE))
            continue;

        if (IsFlagSet(pre->dwFlags, REF_IFEMPTY))
        {
            // No
            if (NO_ERROR == RegOpenKeyA(pre->hkeyRoot, pre->pszKey, &hkey))
            {
                BOOL bSkip;

                // Are we checking the default value?
                if (0 == *pre->pszValName)
                {
                    // Yes; check the size, because default values 
                    // always exist with at least a null terminator.
                    dwSize = 0;
                    RegQueryValueExA(hkey, pre->pszValName, NULL, NULL, NULL, &dwSize);
                    bSkip = (1 < dwSize);
                }
                else
                {
                    // No
                    bSkip = (NO_ERROR == RegQueryValueExA(hkey, pre->pszValName, 
                                            NULL, NULL, NULL, NULL));
                }

                RegCloseKey(hkey);

                // Does it exist?
                if (bSkip)
                {               
                    // Yes; skip it
                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s already exists, skipping", 
                                         Dbg_RegStr(pre, szDbg)); )
                    continue;
                }
            }
        }

        switch (pre->regcmd)  
        {
        case RC_ADD:
        case RC_RUNDLL:
            if (NO_ERROR != RegCreateKeyA(pre->hkeyRoot, pre->pszKey, &hkey))  
            {
                TraceMsg(TF_ERROR, "InstallRegSet(): RegCreateKey(%hs) Failed", pre->pszKey);
                bRet = FALSE;
            }
            else
            {
                // Is the value a resource string? 
                if (REG_SZ == pre->dwType && 0 == HIWORD64(pre->pvValue))
                {
                    UINT idRes = PtrToUlong(pre->pvValue);
                    // Yes; load it
                    dwSize = LoadStringA(g_hinst, idRes, szBuffer, SIZECHARS(szBuffer));

                    // Add null and convert to bytes
                    dwSize = CbFromCchA(dwSize + 1);     
                    pvValue = szBuffer;
                }
                else
                {
                    // No
                    if (RC_RUNDLL == pre->regcmd)
                    {
                        ASSERT(pre->pvValue);
                        ASSERT(REG_SZ == pre->dwType);

                        wnsprintfA(szBuffer, ARRAYSIZE(szBuffer), RUNDLL_CMD_FMT, (LPSTR)pre->pvValue);
                        pvValue = szBuffer;
                        dwSize = CbFromCchA(lstrlenA(szBuffer) + 1);
                    }
                    else
                    {
                        // Normal case
                        pvValue = pre->pvValue;

                        if (0 == pre->DUMMYUNION_MEMBER(dwSize) && REG_SZ == pre->dwType)
                            dwSize = CbFromCchA(lstrlenA((LPCSTR)pvValue) + 1);
                        else
                            dwSize = pre->DUMMYUNION_MEMBER(dwSize);
                    }
                }

                ASSERT(0 < dwSize);

                if (NO_ERROR != RegSetValueExA(hkey, pre->pszValName, 0, pre->dwType, (BYTE*)pvValue, dwSize))  
                {
                    TraceMsg(TF_ERROR, "InstallRegSet(): RegSetValueEx(%hs) Failed", pre->pszValName );
                    bRet = FALSE;
                }
                else
                {
                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
                }
                RegCloseKey(hkey);
            }
            break;

        case RC_CALLBACK:
        {
            RSPECPROC pfn = (RSPECPROC)pre->pvValue;

            ASSERT(IS_VALID_CODE_PTR(pfn, RSPECPROC));

            pfn(RSCB_INSTALL, pre, NULL, 0);
            break;
        }

        case RC_DEL:
            // Delete the default value, a named value, or the key? 
            if (pre->pszValName == NULL)
            {
                // Default value
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting default value %s", Dbg_RegStr(pre, szDbg)); )

                SHDeleteValueA(pre->hkeyRoot, pre->pszKey, pre->pszValName);
            }
            else if (*pre->pszValName)
            {
                // Named value
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting value %s", Dbg_RegStr(pre, szDbg)); )

                SHDeleteValueA(pre->hkeyRoot, pre->pszKey, pre->pszValName);
            }
            else
            {
                // Key
                if (IsFlagSet(pre->dwFlags, REF_NUKE))
                {
                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting key %s", Dbg_RegStr(pre, szDbg)); )

                    SHDeleteKeyA(pre->hkeyRoot, pre->pszKey);
                }
                // If there are keys or values (other than the
                // default value) that are set, then we don't want
                // to delete either the default value or the
                // key.
                else if (IsKeyPsuedoEmpty(pre->hkeyRoot, pre->pszKey, pre->dwFlags))
                {
                    // Delete the default value so SHDeleteOrphanKey 
                    // will work
                    SHDeleteValueA(pre->hkeyRoot, pre->pszKey, "");

                    // Delete the EditFlags value?  (Without the EditFlags,
                    // the user will not be able to specify associations
                    // for this class in the FileTypes dialog, b/c that
                    // dialog requires this value.  So the rule is, this
                    // function will delete the EditFlags if there is
                    // nothing else in the key.)
                    if (IsFlagSet(pre->dwFlags, REF_EDITFLAGS))
                    {
                        DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting %s\\EditFlags", Dbg_RegStr(pre, szDbg)); )
                        
                        SHDeleteValueA(pre->hkeyRoot, pre->pszKey, "EditFlags");
                    }

                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting empty key %s", Dbg_RegStr(pre, szDbg)); )
                    
                    SHDeleteOrphanKeyA(pre->hkeyRoot, pre->pszKey);

                    // Should we prune?  (This mean we'll walk back up
                    // the tree and try deleting empty keys that lead
                    // to this key.)
                    if (IsFlagSet(pre->dwFlags, REF_PRUNE))
                        PruneKey(pre->hkeyRoot, pre->pszKey);
                }
            }
            break;

        default:
            ASSERT(0);
            TraceMsg(TF_ERROR, "InstallRegSet(): Unhandled Special Case");
            break;
            }
        }

    return bRet;
    }


/****************************************************************************

    FUNCTION: CenterWindow (HWND, HWND)

    PURPOSE:  Center one window over another

    COMMENTS:

    Dialog boxes take on the screen position that they were designed at,
    which is not always appropriate. Centering the dialog over a particular
    window usually results in a better position.

****************************************************************************/
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);

    if (hdc)
    {
        wScreen = GetDeviceCaps (hdc, HORZRES);
        hScreen = GetDeviceCaps (hdc, VERTRES);
        ReleaseDC (hwndChild, hdc);
    }
    else
    {
        wScreen = 0;
        hScreen = 0;
    }

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL,
        xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


/*----------------------------------------------------------
Purpose: Dialog proc 

*/
BOOL_PTR
CALLBACK
AssociationDialogProc(HWND hdlg, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    BOOL bMsgHandled = FALSE;

    /* uMsg may be any value. */
    /* wparam may be any value. */
    /* lparam may be any value. */

    switch (uMsg){
    case WM_INITDIALOG:
        CenterWindow( hdlg, GetDesktopWindow());

        if (g_bRunOnNT5)
        {
            // Initialize Checkbox
            // uncheck by default for the first time we show this dialog, 
            // user's action is required. we still persist user's last choice.
            if (FALSE == SHRegGetBoolUSValue(REGSTR_PATH_MAIN, TEXT("ShowedCheckBrowser"), 
                                     FALSE, FALSE)) 
            {
                Button_SetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK), FALSE);

                  // mark we have showed this dialog once.
                LPTSTR sz = TEXT("Yes");
                SHRegSetUSValue(REGSTR_PATH_MAIN, TEXT("ShowedCheckBrowser"), REG_SZ, 
                    (LPBYTE)sz, CbFromCch(lstrlen(sz)+1), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

            }
            else
            {
                Button_SetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK), IsCheckAssociationsOn());
            }
        }
        else
            Button_SetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK), IsCheckAssociationsOn());

        bMsgHandled  = TRUE;
        break;

    //
    // MSN mucks with the registry in a way that causes IE to ask if it's the
    // default browser.  Then after they launch IE they maximize the active
    // window.  Since the default browsre dialog is active, it gets maximized.
    // Handeling the WM_GETMINMAXINFO prevents this dialog from maximizing.
    //
    case WM_GETMINMAXINFO:
        {
            LPMINMAXINFO lpmmi = (LPMINMAXINFO)lparam;

            if (lpmmi)
            {
                RECT rc;

                if (GetWindowRect(hdlg, &rc))
                {
                    lpmmi->ptMaxSize.x = rc.right - rc.left;
                    lpmmi->ptMaxSize.y = rc.bottom - rc.top;

                    lpmmi->ptMaxPosition.x = rc.left;
                    lpmmi->ptMaxPosition.y = rc.top;

                    bMsgHandled = TRUE;
                }
            }
        }
        break;


    case WM_COMMAND:
        switch (LOWORD(wparam))  {
        case IDYES:
        case IDNO:
            SetCheckAssociations( Button_GetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK)) );
            EndDialog( hdlg, LOWORD(wparam));
            break;

        }

    default:
        break;
    }
    return(bMsgHandled);
}


/*----------------------------------------------------------
Purpose: Asks the user whether to make IE be the default browser

*/
BOOL 
AskUserShouldFixReg()
{
    return IDYES == SHFusionDialogBoxParam(MLGetHinst(),
                              MAKEINTRESOURCE(IDD_ASSOC),
                              NULL,
                              AssociationDialogProc,
                              NULL);
}


HRESULT InstallFTPAssociations(void)
{
    IFtpInstaller * pfi;
    HRESULT hr = CoCreateInstance(CLSID_FtpInstaller, NULL, CLSCTX_INPROC_SERVER, IID_IFtpInstaller, (void **) &pfi);

    if (SUCCEEDED(hr))
    {
        hr = pfi->MakeIEDefautlFTPClient();
        pfi->Release();
    }
    else
    {
        // This may fail to create if FTP wasn't installed, which is
        // a valid install case.
        hr = S_OK;
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Install file and protocol association settings in
         registry.

*/
HRESULT
InstallRegAssoc(
    UINT nInstall,          // One of PLATFORM_*
    BOOL bDontIntrude)     // TRUE: be non-intrusive
{
    int i;

    // Install associations common across both IE and Nashville

    for (i = 0; i < ARRAYSIZE(g_rgprsDefault); i++)
        InstallRegSet(g_rgprsDefault[i], bDontIntrude);

    if (PLATFORM_UNKNOWN == nInstall)
    {
        nInstall = WhichPlatform();
    }

    switch (nInstall)
    {
    case PLATFORM_BROWSERONLY:
        for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Alone); i++)
            InstallRegSet(g_rgprsDefault_Alone[i], bDontIntrude);
        break;

    case PLATFORM_INTEGRATED:
        for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Full); i++)
            InstallRegSet(g_rgprsDefault_Full[i], bDontIntrude);
        break;

    default:
        ASSERT(0);
        break;
    }

    InstallFTPAssociations();

    // Notify shell that the associations have changed.
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    return NOERROR;
}

/*----------------------------------------------------------
Purpose: Settings that can only be set after user confirmation.

*/
void
InstallAfterConfirmation(
    BOOL bDontIntrude)     // TRUE: be non-intrusive
{
    // on XP, add IE to show up in the start menu as the Internet app
    if (IsOS(OS_WHISTLERORGREATER))
    {
        // Try to set ourselves as the system default Start Menu web browser
        if (InstallRegSet(&c_rsStartMenu_XP, bDontIntrude))
        {
            // If that succeeds, then clear the per-user setting and let
            // the user float with the system default.  This is necessary
            // to allow downlevel browsers like Netscape to come in and
            // take over the default browser and steal the user away from us.
            // (We're so nice and accomodating.  I bet they won't extend
            // us the same courtesy!)
            SHDeleteValue(HKEY_CURRENT_USER, TEXT("Software\\Clients\\StartMenuInternet"), NULL);
        }
        else
        {
            // We don't have permission to set the global browser, so set ourselves
            // as the browser for this user.
            InstallRegSet(&c_rsStartMenu_XP_CU, bDontIntrude);
        }

        SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Clients\\StartMenuInternet"));
    }
}


/*----------------------------------------------------------
Purpose: Set the CheckAssocation setting in the registry

*/
void
SetCheckAssociations( 
    BOOL fCheck)
{
    HKEY    hk;

    if (RegOpenKeyExA(HKEY_CURRENT_USER, c_szCheckAssnSwitch, 0, KEY_WRITE, &hk) == ERROR_SUCCESS)  {
        LPTSTR szStr;
        DWORD dwSize;

        if (fCheck)
            szStr = TEXT("Yes");
        else
            szStr = TEXT("No");
        dwSize = CbFromCch( lstrlen( szStr ) + 1 );
        RegSetValueEx( hk, TEXT("Check_Associations"), 0, REG_SZ, (LPBYTE) szStr, dwSize );
        RegCloseKey( hk );
    }
}



/*----------------------------------------------------------
Purpose: Determines if the user has turned off the "check for
         default browser" in the registry.

*/
BOOL IsCheckAssociationsOn()
{
    BOOL    rval = TRUE;
    CHAR   szBuf[20];
    DWORD   dwSize = sizeof(szBuf);
    DWORD   dwValType;

    if (NO_ERROR == SHGetValueA(HKEY_CURRENT_USER, c_szCheckAssnSwitch, 
                                 "Check_Associations", &dwValType, 
                                 szBuf, &dwSize))
    {
        if ((dwValType == REG_SZ) && (dwSize < sizeof(szBuf)))  {
            if (StrCmpIA( szBuf, "No") == 0)
                rval = FALSE;
        }
    }

    return( rval );
}

/***********************************************************************

  These routines are used to repair damage done to Internet Explorer's 
  settings by "Netscape Navigator" and "Netscape TuneUp For IE"

 ***********************************************************************/

//
// Prototype for advpack functions
//
HRESULT RunSetupCommand(HWND hWnd, LPCSTR szCmdName, LPCSTR szInfSection, LPCSTR szDir, LPCSTR lpszTitle, HANDLE *phEXE, DWORD dwFlags, LPVOID pvReserved);

//
// This flag tells us whether it's ok to used the
// cached BOOL for IsResetWebSettingsRequired.
//
BOOL g_fAlreadyCheckedForClobber = FALSE;

HRESULT RunSetupCommandW(HWND hWnd, LPCWSTR szCmdName, LPCWSTR szInfSection, LPCWSTR szDir, LPCWSTR lpszTitle, HANDLE *phEXE, DWORD dwFlags, LPVOID pvReserved)
{

    CHAR szCmdNameA[MAX_PATH];
    CHAR szInfSectionA[MAX_PATH];
    CHAR szDirA[MAX_PATH];
    
    SHUnicodeToAnsi(szCmdName,szCmdNameA,ARRAYSIZE(szCmdNameA));
    SHUnicodeToAnsi(szInfSection,szInfSectionA,ARRAYSIZE(szInfSectionA));
    SHUnicodeToAnsi(szDir,szDirA,ARRAYSIZE(szDirA));

    ASSERT(NULL == pvReserved);
    ASSERT(NULL == lpszTitle);

    return RunSetupCommand(hWnd, szCmdNameA, szInfSectionA, szDirA, NULL, phEXE, dwFlags, NULL);
}


//
// Path to the inf file
//
#define IERESTORE_FILENAME  TEXT("iereset.inf")
#define INF_PATH            TEXT("inf")

//
// Names of the sections in our inf file
//
#define INFSECTION_HOMEPAGE  TEXT("RestoreHomePage")
#define INFSECTION_SETTINGS  TEXT("RestoreBrowserSettings")

#define IE_VERIFY_REGKEY     TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define IE_VERIFY_REGVALUE   TEXT("Default_Page_URL")

#define INFSECTION_VERIFY    TEXT("Strings")
#define IE_VERIFY_INFKEY     TEXT("START_PAGE_URL")

void GetIEResetInfFileName(LPWSTR pszBuffer)
{
    TCHAR szWindowsDir[MAX_PATH];

    if (NULL == pszBuffer)
        return;

    GetWindowsDirectory(szWindowsDir,ARRAYSIZE(szWindowsDir));

    wnsprintfW(
        pszBuffer,
        MAX_PATH,
        TEXT("%s\\%s\\%s"),
        szWindowsDir,INF_PATH,IERESTORE_FILENAME);

    return;
}

/*
 * CheckIESettings
 *
 * This function will try to determine whether or not IE's settings
 * have been clobbered by another browser.
 *
 * Returns S_OK if IE settings are intact.
 * Returns S_FALSE if someone has mucked with the IE settings
 * Returns E_FAIL on error
 * 
 */
HRESULT CheckWebSettings(void)
{

    TCHAR szInfPath[MAX_PATH];
    TCHAR szDataFromInf[MAX_PATH];
    TCHAR szDataFromReg[MAX_PATH];
    LONG retval;

    HKEY hkey;
    DWORD dwType;
    DWORD dwSize = sizeof(szDataFromReg);
    //
    // Get the path to the inf file
    //
    GetIEResetInfFileName(szInfPath);

    //
    // Read the string from the inf file
    //
    retval = SHGetIniString(
        INFSECTION_VERIFY,
        IE_VERIFY_INFKEY,
        szDataFromInf,
        ARRAYSIZE(szDataFromInf),
        szInfPath);

    if (retval <= 0)
        return E_FAIL;

    //
    // Open the corresponding key in the registry
    //
    retval = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        IE_VERIFY_REGKEY,
        NULL,
        KEY_READ,
        &hkey);

    if (retval != ERROR_SUCCESS)
        return E_FAIL;

    //
    // Read the data from the registry
    //
    retval = RegQueryValueEx(
        hkey,
        IE_VERIFY_REGVALUE,
        NULL,
        &dwType,
        (LPBYTE)szDataFromReg,
        &dwSize);

    if (retval != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        return E_FAIL;
    }

    ASSERT(dwType == REG_SZ);

    RegCloseKey(hkey);

    //
    // Return S_OK if they match, S_FALSE if they don't
    //
    return StrCmp(szDataFromReg,szDataFromInf) ? S_FALSE : S_OK;

}

extern "C" BOOL IsResetWebSettingsRequired(void)
{
    static BOOL fRequired;

    if (!g_fAlreadyCheckedForClobber)
    {
        fRequired = (S_FALSE == CheckWebSettings());
        g_fAlreadyCheckedForClobber = TRUE;
    }

    return fRequired;

}

HRESULT ResetWebSettingsHelper(BOOL fRestoreHomePage)
{

    HRESULT hr;
    TCHAR szTempPath[MAX_PATH];
    TCHAR szInfPath[MAX_PATH];

    GetTempPath(ARRAYSIZE(szTempPath),szTempPath);
    GetIEResetInfFileName(szInfPath);

    g_fAlreadyCheckedForClobber = FALSE;

    //
    // Run the main part of the inf file
    //
    hr = RunSetupCommandW(
        NULL, 
        szInfPath, 
        INFSECTION_SETTINGS, 
        szTempPath, 
        NULL, 
        NULL, 
        RSC_FLAG_INF|RSC_FLAG_QUIET, 
        NULL);

    //
    // Also, reset their homepage if requested to do so
    //
    if (SUCCEEDED(hr) && fRestoreHomePage)
        hr = RunSetupCommandW(
            NULL, 
            szInfPath, 
            INFSECTION_HOMEPAGE, 
            szTempPath, 
            NULL, 
            NULL, 
            RSC_FLAG_INF|RSC_FLAG_QUIET, 
            NULL);

    return hr;
}

//
// Dialog Procedure for the "reset web settings" dialog
//
// Return values are:
//
//    -1   Something went wrong
//     0   The user changes his/her mind
//     1   We reset everything except the homepage
//     2   We reset everything including the homepage
//

BOOL_PTR CALLBACK ResetWebSettingsDlgProc(HWND hdlg, UINT uMsg, WPARAM wparam, LPARAM lparam)
{

    switch (uMsg)
    {
    case WM_INITDIALOG:

        CenterWindow(hdlg, GetDesktopWindow());
        CheckDlgButton(hdlg,IDC_RESET_WEB_SETTINGS_HOMEPAGE,BST_CHECKED);
        return TRUE;

    case WM_COMMAND:
        
        switch(LOWORD(wparam))
        {
        case IDYES:
            {
                HRESULT hr;
                BOOL fResetHomePage = (BST_CHECKED == IsDlgButtonChecked(hdlg,IDC_RESET_WEB_SETTINGS_HOMEPAGE));

                //
                // Restore the settings to their IE defaults
                //
                hr = ResetWebSettingsHelper(fResetHomePage);

                if (!IsIEDefaultBrowser())
                {
                    InstallRegAssoc(WhichPlatform(), FALSE);
                    InstallAfterConfirmation(FALSE);
                }

                if (FAILED(hr))
                    EndDialog(hdlg, -1);

                else if (fResetHomePage)
                    EndDialog(hdlg, 2);

                else
                    EndDialog(hdlg, 1);

            }
            return TRUE;
            
        case IDCANCEL:
        case IDNO:
            
            EndDialog(hdlg, 0);
            return TRUE;

        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

}

HRESULT ResetWebSettings(HWND hwnd, BOOL *pfChangedHomePage)
{

    HRESULT hr;

    if (pfChangedHomePage)
        *pfChangedHomePage = FALSE;

    switch (DialogBoxParam(
        MLGetHinst(),
        MAKEINTRESOURCE(IDD_RESET_WEB_SETTINGS),
        hwnd,
        ResetWebSettingsDlgProc,
        NULL))
    {
    case -1:
        hr = E_FAIL;
        break;

    case 0:
        hr = S_FALSE;
        break;

    case 1:
        hr = S_OK;
        break;

    case 2:
        if (pfChangedHomePage)
            *pfChangedHomePage = TRUE;
        hr = S_OK;
        break;

    default:
        ASSERT(0);
        hr = E_FAIL;
        break;
    }

    if (FAILED(hr))
    {
        MLShellMessageBox(
            hwnd,
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_FAILURE),
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_TITLE),
            MB_OK | MB_ICONEXCLAMATION);
    }
    else if (hr == S_OK)
    {
        MLShellMessageBox(
            hwnd,
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_SUCCESS),
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_TITLE),
            MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}

void EnsureWebViewRegSettings()
{
    // We do the following mini-check regardless of the user's settings,
    // and for every window we open
    if (!IsRegSetInstalled(&c_rsAssocHTM_WV))
        InstallRegSet(&c_rsAssocHTM_WV, FALSE);
}

void FixIcons()
{
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgprsDefault_FixIcon); i++)  
    {
        // 2nd param FALSE ==> always intrude.
        InstallRegSet(g_rgprsDefault_FixIcon[i], FALSE);
    }
}


/*----------------------------------------------------------
Purpose: Function that determines if we are the default browser.
         If not the default browser, this function will
         ask the user to if they want to become the default
         browser and make those changes.

*/
void 
DetectAndFixAssociations()
{
    TraceMsg(TF_REGCHECK, "Performing expensive registry query for default browser!");

    // We will become the Default browser if:
    // 1. The User has "Check Associations" On,
    // 2. We don't own the associations, and
    // 3. The user said Yes when we displayed the dialog.
    if (IsCheckAssociationsOn() &&
        !IsIEDefaultBrowser() &&
        AskUserShouldFixReg())
    {
        InstallRegAssoc(WhichPlatform(), FALSE);
        InstallAfterConfirmation(FALSE);
    }
}

/*
A really quick - non - through check to see if IE is likely the
default browser
*/

BOOL IsIEDefaultBrowserQuick(void)
{

    int i;
    BOOL bAssociated = TRUE;

    TraceMsg(TF_REGCHECK, "Performing expensive registry query for default browser!");

    // Check the settings common to all platforms
    for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Quick); i++)  
    {
        if (! IsRegSetInstalled(g_rgprsDefault_Quick[i]))  
            bAssociated = FALSE;
    }
    return bAssociated;

}

/*----------------------------------------------------------
Purpose: Function that determines if we are the default browser.

*/
BOOL
IsIEDefaultBrowser(void)
{
    int i;
    BOOL bAssociated = TRUE;
    UINT nInstall = WhichPlatform();

    TraceMsg(TF_REGCHECK, "Performing expensive registry query for default browser!");

    // Check the settings common to all platforms
    for (i = 0; i < ARRAYSIZE(g_rgprsDefault); i++)  
    {
        if (! IsRegSetInstalled(g_rgprsDefault[i]))  
            bAssociated = FALSE;
    }

    if (bAssociated)
    {
        // Check specific to IE or Nashville
        switch (nInstall)
        {
        case PLATFORM_BROWSERONLY:
            for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Alone); i++)  
            {
                if (! IsRegSetInstalled(g_rgprsDefault_Alone[i]))  
                {
                    bAssociated = FALSE;
                    break;
                }
            }
            break;

        case PLATFORM_INTEGRATED:
            for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Full); i++)  
            {
                if (! IsRegSetInstalled(g_rgprsDefault_Full[i]))  
                {
                    bAssociated = FALSE;
                    break;
                }
            }
            break;

        default:
            ASSERT(0);
            break;
        }
    }
        
    // If IE is the default browser and this was an NT5Upgrade scenario,
    // fix the Icons references.
    if (g_bNT5Upgrade && bAssociated)
    {
        FixIcons();
    }

    return bAssociated;
}


/*----------------------------------------------------------
Purpose: Checks if we're installing over IE.  This function
         looks at the associated shell\open\command handler
         for the http protocol.  

Returns: TRUE if we're installing over IE
*/
BOOL
AreWeInstallingOverIE(void)
{
    BOOL bRet = FALSE;
    CHAR sz[MAX_PATH + 20];    // add some padding for arguments
    DWORD cbData = SIZEOF(sz);

    if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, c_szHTTPOpenCmd, "",
                               NULL, sz, &cbData) &&
        StrStrIA(sz, IEXPLORE_EXE) || StrStrIA(sz, EXPLORER_EXE))
    {
        TraceMsg(TF_REGCHECK, "Installing over IEXPLORE.EXE");
        bRet = TRUE;
    }
    return bRet;
}    

#if 0
BOOL ShouldIEBeDefaultBrowser(void)
{
    BOOL bRet = TRUE;          // default to TRUE (eg take over the association)
    CHAR sz[MAX_PATH] = "";
    DWORD cchData = ARRAYSIZE(sz);

    if (SUCCEEDED(AssocQueryStringA(0, ASSOCSTR_COMMAND, ".htm", NULL, sz, &cchData)))
    {
        if (sz[0] && !StrStrIA(sz, IEXPLORE_EXE))
        {
           TraceMsg(TF_REGCHECK, "%s is the default browser (NOT iexplore.exe)", sz);
           bRet = FALSE;
        }
        else
        {
            // if sz[0] is NULL, (probably broken reg) - Let IE be the Default Browser.
            // or IE may be the Default browser setting.
            TraceMsg(TF_REGCHECK, "IEXPLORE.EXE is assumed to be the default browser");
        }
    }
    else
    {
        //May be a Broken Registry  - Default to IE.
        TraceMsg(TF_REGCHECK, "IEXPLORE.EXE is assumed to be the default browser due to broken Association");
    }
    return bRet;

}
#else
BOOL ShouldIEBeDefaultBrowser(void)
{
    BOOL bRet = TRUE;          // default to TRUE (eg take over the association)
    CHAR sz[MAX_PATH + 20];    // add some padding for arguments
    DWORD cbData = ARRAYSIZE(sz);
    sz[0] = '\0';

    if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, ".htm", "", NULL, sz, &cbData))
    {
        if (!sz[0])
        {
            // null key so return TRUE
            return bRet;
        }
        else if (!StrCmpIA(sz, "htmlfile"))
        {
            // Maybe, make sure further
            sz[0] = '\0';
            cbData = ARRAYSIZE(sz);

            if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, c_szHTMOpenCmd, "",
                                       NULL, sz, &cbData))
            {
                if (!sz[0] ||  // if sz[0] is NULL, we will take it over  (probably broken reg)
                    StrStrIA(sz, IEXPLORE_EXE))
                {
                    // Default browser was IE, so we return TRUE 
                    TraceMsg(TF_REGCHECK, "IEXPLORE.EXE is the default browser");
                }
                else
        {
           TraceMsg(TF_REGCHECK, "%s is the default browser (NOT iexplore.exe)", sz);
           bRet = FALSE;
        }
            }
        }
        else
        {
            // the progid does not point to "htmlfile", so IE cant be the default browser
            TraceMsg(TF_REGCHECK, "%s is the .htm progid (NOT htmlfile)", sz);
            bRet = FALSE;
        }
    }
    // .htm progid key does not exist, so we return TRUE

    return bRet;

}

#endif

#define SZ_REGKEY_FTPSHELLOPEN          TEXT("ftp\\shell\\open")
#define SZ_REGKEY_COMMAND               TEXT("command")
#define SZ_REGKEY_DDEEXEC               TEXT("ddeexec\\ifExec")

#define SZ_IEXPLORE_FTP_NEW          TEXT("iexplore.exe\" %1")
#define SZ_IEXPLORE_FTP_OLD          TEXT("iexplore.exe\" -nohome")

HRESULT UpgradeSettings(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    
    LONG lRet = RegOpenKey(HKEY_CLASSES_ROOT, SZ_REGKEY_FTPSHELLOPEN, &hKey);
    hr = HRESULT_FROM_WIN32(lRet);
    if (hKey)
    {
        TCHAR szData[MAX_PATH];
        LONG cbSize = sizeof(szData);
        
        lRet = RegQueryValue(hKey, SZ_REGKEY_COMMAND, szData, &cbSize);
        hr = HRESULT_FROM_WIN32(lRet);
        if (SUCCEEDED(hr))
        {
            DWORD cchStart = (lstrlen(szData) - ARRAYSIZE(SZ_IEXPLORE_FTP_OLD) + 1);

            // Do we own it?
            if (0 == StrCmp(SZ_IEXPLORE_FTP_OLD, &szData[cchStart]))
            {
                // Yes, so we can upgrade it.

                // Buffer Overflow isn't a problem because I know SZ_IEXPLORE_FTP_NEW is smaller
                // than SZ_IEXPLORE_FTP_OLD.
                StrCpyN(&szData[cchStart], SZ_IEXPLORE_FTP_NEW, ARRAYSIZE(szData));

                // Yes, so let's upgrade.
                lRet = RegSetValue(hKey, SZ_REGKEY_COMMAND, REG_SZ, szData, lstrlen(szData));
                hr = HRESULT_FROM_WIN32(lRet);
                if (SUCCEEDED(hr))
                {
                    lRet = RegSetValue(hKey, SZ_REGKEY_DDEEXEC, REG_SZ, TEXT(""), ARRAYSIZE(TEXT("")));
                    hr = HRESULT_FROM_WIN32(lRet);
                }
            }
        }

        RegCloseKey(hKey);
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Install registry info based upon which shell we're running

*/
HRESULT InstallIEAssociations(DWORD dwFlags)   // IEA_* flags
{
    int i;
    UINT nInstall = WhichPlatform();
    BOOL bDontIntrude = TRUE;
    
    // If IE was the default browser before (or the registry is messed up)
    // or setup is forcing us to register then we want to force IE to be 
    // the default browser
    if (ShouldIEBeDefaultBrowser() || IsFlagSet(dwFlags, IEA_FORCEIE))
        bDontIntrude = FALSE;
    
    // Install file and protocol associations
    
    InstallRegAssoc(nInstall, bDontIntrude);
    
    // Install other registry settings
    
    switch (nInstall)
    {
    case PLATFORM_BROWSERONLY:
        for (i = 0; i < ARRAYSIZE(g_rgprsIE30Only); i++)  
        {
            InstallRegSet(g_rgprsIE30Only[i], bDontIntrude);
        }
        break;
        
    case PLATFORM_INTEGRATED:
        for (i = 0; i < ARRAYSIZE(g_rgprsNashOnly); i++)  
        {
            InstallRegSet(g_rgprsNashOnly[i], bDontIntrude);
        }
        break;
        
    default:
        ASSERT(0);
        break;
    }
    
    InstallFTPAssociations();

    return NOERROR;
}


HRESULT UninstallPlatformRegItems(BOOL bIntegrated)
{
    int i;
    UINT uPlatform = bIntegrated ? PLATFORM_INTEGRATED : PLATFORM_BROWSERONLY;
    
    switch (uPlatform)
    {
    case PLATFORM_BROWSERONLY:
        for (i = 0; i < ARRAYSIZE(g_rgprsUninstallIE30); i++)  
        {
            InstallRegSet(g_rgprsUninstallIE30[i], FALSE);
        }
        break;
        
    case PLATFORM_INTEGRATED:
        for (i = 0; i < ARRAYSIZE(g_rgprsUninstallNash); i++)  
        {
            InstallRegSet(g_rgprsUninstallNash[i], FALSE);
        }
        break;
        
    default:
        // Don't do anything
        break;
    }
    
    return NOERROR;
}

void UninstallCurrentPlatformRegItems()
{
    CHAR sz[MAX_PATH + 20];    // add some padding for arguments
    DWORD cbData = SIZEOF(sz);
    if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, c_szHTMOpenNewCmd, "",
                               NULL, sz, &cbData))
    {
        // Remove IE4 shell integrated settings
        UninstallPlatformRegItems(TRUE);
    }
    else if (AreWeInstallingOverIE())
    {
        // Remove IE3 / browser only settings
        UninstallPlatformRegItems(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iedde.cpp ===
/* Copyright 1996 Microsoft */

#include "priv.h"

#ifdef DEBUG

#define ENTERPROC EnterProc
#define EXITPROC ExitProc

void EnterProc(DWORD dwTraceLevel, LPTSTR szFmt, ...);
void ExitProc(DWORD dwTraceLevel, LPTSTR szFmt, ...);

extern DWORD g_dwIEDDETrace;

#else

#pragma warning(disable:4002)

#ifndef UNIX

#ifndef CCOVER
#define ENTERPROC()
#define EXITPROC()
#else //CCOVER

// these are needed because of a bug in cl.exe which causes 
// compilation problems with #pragma when a program is preprocessed
// and compiled separately

#define ENTERPROC 1 ? (void) 0 : (void)
#define EXITPROC 1 ? (void) 0 : (void)
#endif // CCOVER

#else
#define ENTERPROC EnterProc
#define EXITPROC ExitProc
inline void EnterProc(DWORD dwTraceLevel, LPTSTR szFmt, ...){}
inline void ExitProc(DWORD dwTraceLevel, LPTSTR szFmt, ...){}
#endif

#endif

//
// Forward reference.
//
class CIEDDEThread;

//
// Stored in _hdsaWinitem
//
typedef struct _tagWinItem
{
    DWORD           dwWindowID;     // Synthetic window ID exposed in IEDDE interfaces
    HWND            hwnd;           // Actual hwnd of browser window
    DWORD           dwThreadID;     // ThreadID for this browser window
    CIEDDEThread    *pidt;          // Thread specific data and methods
} WINITEM;

//
// Stored in _hdsaProtocolHandler
//
typedef struct _tagProtocolReg
{
    LPTSTR  pszProtocol;
    LPTSTR  pszServer;
} PROTOCOLREG;

#define TEN_SECONDS         (10 * 1000)
#define DXA_GROWTH_AMOUNT   (10)

#ifndef UNIX
#define IEXPLORE_STR "IEXPLORE"
#else
#define IEXPLORE_STR "iexplorer"
#endif

static const TCHAR c_szIExplore[] = TEXT(IEXPLORE_STR);
static const TCHAR c_szReturn[] = TEXT("Return");
static const TCHAR c_szWWWOpenURL[] = TEXT("WWW_OpenURL");
static const TCHAR c_szWWWUrlEcho[] = TEXT("WWW_URLEcho");

typedef struct _tagDDETHREADINFO
{
    DWORD       dwDDEInst;
    HSZ         hszService;
    HSZ         hszReturn;
    HDDEDATA    hddNameService;
} DDETHREADINFO;

class CIEDDEThread {
public:
    CIEDDEThread() { };
    ~CIEDDEThread() { };

    void GetDdeThreadInfo(DDETHREADINFO *pdti) { *pdti = _dti; }
    void SetDdeThreadInfo(DDETHREADINFO *pdti) { _dti = *pdti; }
    HDDEDATA OnRequestPoke(HSZ hszTopic, HSZ hszParams);
    HDDEDATA OnExecute(HSZ hszTopic, HDDEDATA hddParams);

    HDDEDATA CallTopic(DWORD dwType, LPCTSTR pszTopic, LPTSTR pszParams);

protected:
    DDETHREADINFO   _dti;

    HDDEDATA DoNavigate(LPTSTR pszLocation, HWND hwnd, BOOL bLaunchNewWindow);
    BOOL MakeQuotedString(LPCTSTR pszInput, LPTSTR pszOutput, int cchOutput);
    HDDEDATA CreateReturnObject(LPVOID p, DWORD cb);
    HDDEDATA CreateReturnStringObject(LPTSTR pszReturnString, DWORD cch);


    BOOL ParseString(LPTSTR *ppsz, LPTSTR *ppszString);
    BOOL ParseQString(LPTSTR *ppsz, LPTSTR *ppszString);
    BOOL ParseNumber(LPTSTR *ppsz, DWORD *pdw);
    BOOL ParseWinitem(LPTSTR *ppsz, WINITEM *pwi);

    HDDEDATA WWW_GetWindowInfo(LPTSTR pszParams);
    HDDEDATA WWW_OpenURL(LPTSTR pszParams);
    HDDEDATA WWW_OpenURLNewWindow(LPTSTR pszParams);
    HDDEDATA WWW_ShowFile(LPTSTR pszParams);
    HDDEDATA WWW_Activate(LPTSTR pszParams);
    HDDEDATA WWW_Exit(LPTSTR pszParams);
    HDDEDATA WWW_RegisterURLEcho(LPTSTR pszParams);
    HDDEDATA WWW_UnregisterURLEcho(LPTSTR pszParams);
    HDDEDATA WWW_RegisterProtocol(LPTSTR pszParams);
    HDDEDATA WWW_UnregisterProtocol(LPTSTR pszParams);
    HDDEDATA WWW_ListWindows(LPTSTR pszParams);
};

class CIEDDE {
public:
    CIEDDE() { };
    ~CIEDDE() { };

    BOOL IsAutomationReady(void) { return _fAutomationReady; }
    BOOL GetWinitemFromWindowID(DWORD dwWindowID, WINITEM *pwi);
    BOOL GetWinitemFromHwnd(HWND hwnd, WINITEM *pwi);
    BOOL AddUrlEcho(LPCTSTR pszUrlEcho);
    BOOL RemoveUrlEcho(LPCTSTR pszUrlEcho);
    BOOL AddProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol);
    BOOL RemoveProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol);
    HDSA GetHdsaWinitem(void) { return _hdsaWinitem; }
    static HDDEDATA DdeCallback(UINT dwType, UINT dwFmt, HCONV hconv, HSZ hsz1, HSZ hsz2, HDDEDATA hdd, DWORD dwData1, DWORD dwData2);
    void EnterCrit(void) { ASSERT(_fCSInitialized); EnterCriticalSection(&_csIEDDE); }
    void LeaveCrit(void) { ASSERT(_fCSInitialized); LeaveCriticalSection(&_csIEDDE); }
    void SetDelayedExecute(LPCTSTR pszTopic, LPCTSTR pszParams);
    void RunDelayedExecute();
    
protected:
    BOOL _fAutomationReady;
    HDSA _hdsaWinitem;
    HDSA _hdsaProtocolHandler;
    HDPA _hdpaUrlEcho;
    BOOL _fCSInitialized;
    CRITICAL_SECTION _csIEDDE;
    DWORD _dwThreadID;
    LPTSTR _pszTopic;
    LPTSTR _pszParams;

    HDDEDATA _SendDDEMessageHsz(DWORD dwDDEInst, HSZ hszApp, HSZ hszTopic, HSZ hszMessage, UINT wType);
    HDDEDATA _SendDDEMessageSz(DWORD dwDDEInst, LPCTSTR pszApp, LPCTSTR pszTopic, LPCTSTR pszMessage, UINT wType);

    static int _DestroyProtocol(LPVOID p1, LPVOID p2);
    static int _DestroyUrlEcho(LPVOID p1, LPVOID p2);
    static int _DestroyWinitem(LPVOID p1, LPVOID p2);

    BOOL _GetWinitemFromThread(DWORD dwThreadID, WINITEM *pwi);
    BOOL _GetDtiFromThread(DWORD dwThreadID, DDETHREADINFO *pdti);

    BOOL _CreateDdeThreadInfo(DDETHREADINFO *pdti);
    void _DestroyDdeThreadInfo(DDETHREADINFO *pdti);
    BOOL _AddWinitem(WINITEM *pwi);
    BOOL _UpdateWinitem(WINITEM *pwi);
    BOOL _DeleteWinitemByHwnd(HWND hwnd, WINITEM *pwi);

    BOOL _Initialize(void);
    void _Uninitialize(void);
    void _AutomationStarted(void);
    HRESULT _BeforeNavigate(LPCTSTR pszURL, BOOL *pfProcessed);
    HRESULT _AfterNavigate(LPCTSTR pszURL, HWND hwnd);
    BOOL _NewWindow(HWND hwnd);
    BOOL _WindowDestroyed(HWND hwnd);

    friend BOOL IEDDE_Initialize(void);
    friend void IEDDE_Uninitialize(void);
    friend void IEDDE_AutomationStarted(void);
    friend HRESULT IEDDE_BeforeNavigate(LPCWSTR pwszURL, BOOL *pfProcessed);
    friend HRESULT IEDDE_AfterNavigate(LPCWSTR pwszURL, HWND hwnd);
    friend BOOL IEDDE_NewWindow(HWND hwnd);
    friend BOOL IEDDE_WindowDestroyed(HWND hwnd);
};
CIEDDE *g_pIEDDE = NULL;

#define ENTER_IEDDE_CRIT g_pIEDDE->EnterCrit()
#define LEAVE_IEDDE_CRIT g_pIEDDE->LeaveCrit()



//
// There is one CIEDDEThread object per browser window.
// Its private data consists of DDE handles, which are
// necessarily valid only in the thread that created them.
//
// Its methods consist of three broad categories:
//      the parser
//      the dispatcher
//      one handler for each DDE topic
//







//
// CreateReturnObject - creates a dde data item.
//
#define CREATE_HDD(x) CreateReturnObject(&x, SIZEOF(x))
HDDEDATA CIEDDEThread::CreateReturnObject(LPVOID p, DWORD cb)
{
    HDDEDATA hddRet;

    ENTERPROC(2, TEXT("CreateReturnObject(p=%08X,cb=%d)"), p, cb);

    hddRet = DdeCreateDataHandle(_dti.dwDDEInst, (BYTE *)p, cb, 0, _dti.hszReturn, CF_TEXT, 0);

    if (hddRet == 0)
    {
        TraceMsg(TF_WARNING, "IEDDE: Could not create return object");
    }

    EXITPROC(2, TEXT("CreateReturnObject=%08X"), hddRet);
    return hddRet;
}

HDDEDATA CIEDDEThread::CreateReturnStringObject(LPTSTR pszReturnString, DWORD cch)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(2, TEXT("CreateReturnStringObject(p=%s,cb=%d)"), pszReturnString, cch);

    //
    // REVIEW I thought specifying CF_UNICODETEXT should have worked, but... 
    // it didn't, so always return ANSI string as out string params
    // - julianj
    //
    LPSTR pszAnsiBuf = (LPSTR)LocalAlloc(LPTR, cch+1);
    if (pszAnsiBuf)
    {
        SHUnicodeToAnsi(pszReturnString, pszAnsiBuf, cch+1);
        hddRet = DdeCreateDataHandle(_dti.dwDDEInst, (BYTE *)pszAnsiBuf, (cch+1), 0, _dti.hszReturn, CF_TEXT, 0);
        LocalFree(pszAnsiBuf);
        pszAnsiBuf = NULL;
    }
    
    if (hddRet == 0)
    {
        TraceMsg(TF_WARNING, "IEDDE: Could not create return object");
    }

    EXITPROC(2, TEXT("CreateReturnObject=%08X"), hddRet);
    return hddRet;
}


//
// OnRequestPoke - handle XTYP_REQUEST and XTYP_POKE
//
HDDEDATA CIEDDEThread::OnRequestPoke(HSZ hszTopic, HSZ hszParams)
{
    HDDEDATA hddRet = 0;
    ENTERPROC(2, TEXT("OnRequestPoke(hszTopic=%08X,hszParams=%08X)"), hszTopic, hszParams);

    TCHAR szTopic[100];
    TCHAR szParams[1000];

    if (DdeQueryString(_dti.dwDDEInst, hszTopic, szTopic, ARRAYSIZE(szTopic), CP_WINNEUTRAL) != 0)
    {
        if (DdeQueryString(_dti.dwDDEInst, hszParams, szParams, ARRAYSIZE(szParams), CP_WINNEUTRAL))
        {
            hddRet = CallTopic(XTYP_REQUEST, szTopic, szParams);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: OnRequestPoke could not query the parameters");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: OnRequestPoke could not query the topic");
    }

    EXITPROC(2, TEXT("OnRequestPoke=%08X"), hddRet);
    return hddRet;
}

//
// OnExecute - handle XTYP_EXECUTE
//
HDDEDATA CIEDDEThread::OnExecute(HSZ hszTopic, HDDEDATA hddParams)
{
    HDDEDATA hddRet = 0;
    ENTERPROC(2, TEXT("OnExecute(hszTopic=%08X,hddParams=%08X)"), hszTopic, hddParams);

    TCHAR szTopic[100];

    if (DdeQueryString(_dti.dwDDEInst, hszTopic, szTopic, ARRAYSIZE(szTopic), CP_WINNEUTRAL) != 0)
    {
        //
        // Why "cbParams + 3"?
        // UNICODE - if we cut the last unicode character in half, we need
        //           one 0 to finish the character, and two more 0 for the
        //           terminating NULL
        // ANSI - if we cut the last DBCS character in half, we need one 0
        //        to finish the character, and one 0 for the terminating NULL
        //
        //
        DWORD cbParams = DdeGetData(hddParams, NULL, 0, 0) + 3;
        LPTSTR pszParams = (LPTSTR) LocalAlloc(LPTR, cbParams);

        if(pszParams)
        {
            DdeGetData(hddParams, (BYTE *)pszParams, cbParams, 0);
            //
            // DdeGetData can't be wrapped in shlwapi since it can return non
            // string data.  Here we only expect strings so the result can be
            // safely converted.
            //
            if (g_fRunningOnNT)
            {
                hddRet = CallTopic(XTYP_EXECUTE, szTopic, pszParams);
            }
            else
            {
                WCHAR szParams[MAX_URL_STRING];
                SHAnsiToUnicode((LPCSTR)pszParams, szParams, ARRAYSIZE(szParams));
                hddRet = CallTopic(XTYP_EXECUTE, szTopic, szParams);
            }
            LocalFree(pszParams);
            pszParams = NULL;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: OnExecute could not query the topic");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: OnExecute could not query the topic");
    }

    EXITPROC(2, TEXT("OnExecute=%08X"), hddRet);
    return hddRet;
}

//
// CallTopic - Looks up the command in the DDETOPICHANDLER table and calls the
// corresponding function.
//
HDDEDATA CIEDDEThread::CallTopic(DWORD dwType, LPCTSTR pszTopic, LPTSTR pszParams)
{
    HDDEDATA hddRet = DDE_FNOTPROCESSED;
    ENTERPROC(2, TEXT("CallTopic(wType=%d,pszTopic=>%s<,pszParams=>%s<)"), dwType, pszTopic, pszParams);

#define DISPATCH_BEGIN
#define DISPATCH(topic)                                 \
    if (StrCmpI(TEXT("WWW_") TEXT(#topic), pszTopic) == 0)   \
    {                                                   \
        if (fCanRun)                                    \
        {                                               \
            hddRet = WWW_ ## topic(pszParams);          \
        }                                               \
        else                                            \
        {                                               \
            fAbortedRun = TRUE;                         \
        }                                               \
    }                                                   \
    else
#define DISPATCH_END { TraceMsg(TF_WARNING, "IEDDE: CallTopic given unknown topic"); }

    BOOL fAbortedRun = FALSE;
    BOOL fCanRun = ((dwType != XTYP_EXECUTE) || g_pIEDDE->IsAutomationReady());

    DISPATCH_BEGIN
        DISPATCH(GetWindowInfo)
        DISPATCH(OpenURL)
        DISPATCH(ShowFile)
        DISPATCH(Activate)
        DISPATCH(Exit)
        DISPATCH(RegisterURLEcho)
        DISPATCH(UnregisterURLEcho)
        DISPATCH(RegisterProtocol)
        DISPATCH(UnregisterProtocol)
        DISPATCH(ListWindows)
        DISPATCH(OpenURLNewWindow)
    DISPATCH_END

    if (fAbortedRun)
    {
        if (dwType == XTYP_EXECUTE)
        {
            g_pIEDDE->SetDelayedExecute(pszTopic, pszParams);
        }
        hddRet = (HDDEDATA)DDE_FACK;
        TraceMsg(TF_WARNING, "IEDDE: CallTopic received XTYP_EXECUTE before Automation was ready - not processing");
    }

    EXITPROC(2, TEXT("CallTopic=%08X"), hddRet);
    return hddRet;
}

//
// ParseString - parse one string
//
BOOL CIEDDEThread::ParseString(LPTSTR *ppsz, LPTSTR *ppszString)
{
    BOOL fRet = FALSE;

    ENTERPROC(3, TEXT("ParseString(ppsz=%08X,ppszString=%08X)"), ppsz, ppszString);

    LPTSTR pchCurrent, pchNext;
    BOOL fInQuote = FALSE;

    pchCurrent = pchNext = *ppsz;
    while (*pchNext)
    {
        switch (*pchNext)
        {
        case TEXT(' '):
        case TEXT('\t'):
            if (fInQuote)
            {
                //
                // Skip over whitespace when not inside quotes.
                //
                *pchCurrent++ = *pchNext;
            }
            pchNext++;
            break;

        case TEXT('"'):
            //
            // Always copy quote marks.
            //
            fInQuote = !fInQuote;
            *pchCurrent++ = *pchNext++;
            break;

        case TEXT(','):
            if (!fInQuote)
            {
                goto done_parsing;
            }
            *pchCurrent++ = *pchNext++;
            break;

        case TEXT('\\'):
            if (fInQuote &&
                (*(pchNext+1) == TEXT('"')))
            {
                //
                // When in quotes, a \" becomes a ".
                //
                pchNext++;
            }
            *pchCurrent++ = *pchNext++;
            break;

        default:
            *pchCurrent++ = *pchNext++;
            break;
        }
    }
done_parsing:

    //
    // Advance past the comma separator.
    //
    if (*pchNext == TEXT(','))
    {
        pchNext++;
    }

    //
    // NULL terminate the return string.
    //
    *pchCurrent = TEXT('\0');

    //
    // Set the return values.
    //
    *ppszString = *ppsz;
    *ppsz = pchNext;
    fRet = TRUE;

    EXITPROC(3, TEXT("ParseString=%d"), fRet);
    return fRet;
}

//
// ParseQString - parse one quoted string
//
BOOL CIEDDEThread::ParseQString(LPTSTR *ppsz, LPTSTR *ppszString)
{
    BOOL fRet = FALSE;

    ENTERPROC(3, TEXT("ParseQString(ppsz=%08X,ppszString=%08X)"), ppsz, ppszString);

    if (ParseString(ppsz, ppszString))
    {
        LPTSTR pszString = *ppszString;
        int cch = lstrlen(pszString);

        //
        // Strip off optional outer quotes.
        //
        if ((cch >= 2) &&
            (pszString[0] == TEXT('"')) &&
            (pszString[cch-1] == TEXT('"')))
        {
            pszString[0] = pszString[cch-1] = TEXT('\0');
            *ppszString = pszString + 1;
        }

        fRet = TRUE;
    }

    EXITPROC(3, TEXT("ParseQString=%d"), fRet);
    return fRet;
}

//
// ParseNumber - parse one numeric value
//
BOOL CIEDDEThread::ParseNumber(LPTSTR *ppsz, DWORD *pdw)
{
    BOOL fRet = FALSE;
    LPTSTR pszNumber;

    ENTERPROC(3, TEXT("GetNumber(ppsz=%08X,pdw=%08X)"), ppsz, pdw);

    if (ParseString(ppsz, &pszNumber) && pszNumber[0])
    {
        StrToIntEx(pszNumber, STIF_SUPPORT_HEX, (int *)pdw);
        fRet = TRUE;
    }

    EXITPROC(3, TEXT("GetNumber=%d"), fRet);
    return fRet;
}

//
// ParseWinitem - parse one window ID, and return the winitem
//
BOOL CIEDDEThread::ParseWinitem(LPTSTR *ppsz, WINITEM *pwi)
{
    BOOL fRet = FALSE;
    DWORD dwWindowID;

    ENTERPROC(3, TEXT("ParseWinitem(ppsz=%08X,pwi=%08X)"), ppsz, pwi);

    if (ParseNumber(ppsz, &dwWindowID))
    {
        switch (dwWindowID)
        {
        case 0:
        case -1:
            ZeroMemory(pwi, SIZEOF(*pwi));
            pwi->dwWindowID = dwWindowID;
            pwi->hwnd = (HWND)LongToHandle(dwWindowID);
            fRet = TRUE;
            break;

        default:
            fRet = g_pIEDDE->GetWinitemFromWindowID(dwWindowID, pwi);
            break;
        }
    }

    EXITPROC(3, TEXT("ParseWinitem=%d"), fRet);
    return fRet;
}

//
//  WWW_GetWindowInfo - get information about a browser window
//
//  Parameters:
//      dwWindowID - Window ID to examine (-1 = last active window)
//
//  Returns:
//      qcsURL,qcsTitle
//
HDDEDATA CIEDDEThread::WWW_GetWindowInfo(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_GetWindowInfo(pszParams=>%s<)"), pszParams);

    if (ParseWinitem(&pszParams, &wi) &&
        (wi.hwnd != 0))
    {
        BSTR bstrURL;

        if (SUCCEEDED(CDDEAuto_get_LocationURL(&bstrURL, wi.hwnd)) && (bstrURL != (BSTR)-1))
        {
            BSTR bstrTitle;

            if (SUCCEEDED(CDDEAuto_get_LocationTitle(&bstrTitle, wi.hwnd)) && (bstrTitle != (BSTR)-1))
            {
                LPTSTR pszURL, pszTitle;


                pszURL = bstrURL;
                pszTitle = bstrTitle;

                if (pszURL && pszTitle)
                {
                    TCHAR szURLQ[MAX_URL_STRING];
                    TCHAR szTitleQ[MAX_URL_STRING];

                    if (MakeQuotedString(pszURL, szURLQ, ARRAYSIZE(szURLQ)) &&
                        MakeQuotedString(pszTitle, szTitleQ, ARRAYSIZE(szTitleQ)))
                    {
                        DWORD cchBuffer = lstrlen(szURLQ) + 1 + lstrlen(szTitleQ) + 1;
                        LPTSTR pszBuffer = (LPTSTR)LocalAlloc(LPTR, cchBuffer * SIZEOF(TCHAR));

                        if (pszBuffer)
                        {
                            wnsprintf(pszBuffer, cchBuffer, TEXT("%s,%s"), szURLQ, szTitleQ);
                            hddRet = CreateReturnStringObject(pszBuffer, lstrlen(pszBuffer));
                            LocalFree(pszBuffer);
                            pszBuffer = NULL;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not alloc buffer");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not quote return strings");
                    }
                }

                SysFreeString(bstrTitle);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not get title");
            }

            SysFreeString(bstrURL);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not get URL");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_GetWindowInfo=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_OpenURLNewWindow - navigate to a URL (but make sure to spawn a new window)
//
//  NOTE: this code was stolen from IEDDEThread::WWW_OpenURL below
//
HDDEDATA CIEDDEThread::WWW_OpenURLNewWindow(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    LPTSTR pszUrl, pszFile;

    ENTERPROC(1, TEXT("WWW_OpenURLNewWindow(pszParams=>%s<)"), pszParams);

    if (*pszParams == TEXT('\0') || *pszParams == TEXT('*'))
    {
        // An empty string is a NOOP.
    }
    else if (ParseQString(&pszParams, &pszUrl) &&
        ParseQString(&pszParams, &pszFile))
    {
        // null hwnd & bLaunchNewWindow = TRUE means "launch a new window",
        // which is exactly what we want to do in the WWW_OpenURLNewWindow case
        hddRet = DoNavigate(pszUrl, NULL, TRUE);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: WWW_OpenURLNewWindow could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_OpenURL=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_OpenURL - navigate to a URL
//
//  Parameters:
//      qcsURL - url to navigate to
//      qcsSaveFile - [optional] file to save contents in
//      dwWindowID - Window ID to perform navigation
//      dwFlags - flags for navigation
//      qcsPostFormData - [optional] form data to post to URL
//      qcsPostMIMEType - [optional] mime type for form data
//      csProgressServer - [optional] DDE server to get progress updates
//
//  Returns:
//      dwWindowID - window which is doing the work
//
HDDEDATA CIEDDEThread::WWW_OpenURL(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    LPTSTR pszUrl, pszFile;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_OpenURL(pszParams=>%s<)"), pszParams);

    if (*pszParams == TEXT('\0') || *pszParams == TEXT('*'))
    {
        // An empty string is a NOOP.  Needed for NT #291766
    }
    else if (ParseQString(&pszParams, &pszUrl) &&
             ParseQString(&pszParams, &pszFile))
    {
        //
        // APPCOMPAT - a missing hwnd parameter implies -1.
        //
        if (!ParseWinitem(&pszParams, &wi))
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required hwnd parameter to WWW_OpenURL, assuming -1");
            wi.hwnd = (HWND)-1;
        }

#ifdef DEBUG
        DWORD dwFlags;
        if (!ParseNumber(&pszParams, &dwFlags))
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required dwFlags parameter to WWW_OpenURL");
        }
#endif

        hddRet = DoNavigate(pszUrl, wi.hwnd, FALSE);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: OpenURL could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_OpenURL=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_ShowFile - navigate to a file
//
//  Parameters:
//      qcsFilename - file to load
//      qcsPostMIMEType - [optional] mime type for form data
//      dwWindowID - Window ID to perform navigation
//      qcsURL - URL of the same document
//
//  Returns:
//      dwWindowID - window which is doing the work
//
HDDEDATA CIEDDEThread::WWW_ShowFile(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    LPTSTR pszFilename, pszMIMEType;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_ShowFile(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszFilename) && pszFilename[0])
    {
        if (!ParseQString(&pszParams, &pszMIMEType) || !pszMIMEType[0])
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required MIMEType parameter to WWW_ShowFile");
        }
        if (!ParseWinitem(&pszParams, &wi))
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required dwWindowID parameter to WWW_ShowFile, assuming -1");
            wi.hwnd = (HWND)-1;
        }

#ifdef DEBUG
        LPTSTR pszURL;

        if (!ParseQString(&pszParams, &pszURL) || !pszURL[0])
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required szURL parameter to WWW_ShowFile");
        }
#endif
        hddRet = DoNavigate(pszFilename, wi.hwnd, FALSE);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: ShowFile could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_ShowFile=%08X"), hddRet);
    return hddRet;
}

//
// DoNavigate - navigate to a location
//
HDDEDATA CIEDDEThread::DoNavigate(LPTSTR pszLocation, HWND hwnd, BOOL bLaunchNewWindow)
{
    HDDEDATA hddRet = 0;
    HRESULT hr = S_OK;
    TCHAR szParsedPath[MAX_URL_STRING+1];
    DWORD cchParsedPath = ARRAYSIZE(szParsedPath);

    ENTERPROC(2, TEXT("DoNavigate(pszLocation=>%s<,hwnd=%08X)"), pszLocation, hwnd);

    //
    // Convert URL from outside format to internal format.
    //
    if (ParseURLFromOutsideSource(pszLocation, szParsedPath, &cchParsedPath, NULL))
    {
        pszLocation = szParsedPath;
    }

    //
    // In the case of a file:// URL, convert the location to a path.
    //
    cchParsedPath = ARRAYSIZE(szParsedPath);
    if (IsFileUrlW(pszLocation) && SUCCEEDED(PathCreateFromUrl(pszLocation, szParsedPath, &cchParsedPath, 0)))
    {
        pszLocation = szParsedPath;
    }

    LPWSTR pwszPath;

    pwszPath = pszLocation;

    if (SUCCEEDED(hr))
    {
        hr = CDDEAuto_Navigate(pwszPath, &hwnd, bLaunchNewWindow ? 1 : 0);
    }

    DWORD dwServicingWindow = SUCCEEDED(hr) ? -2 : -3;

    hddRet = CREATE_HDD(dwServicingWindow);

    EXITPROC(2, TEXT("DoNavigate=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_Activate - activate a browser window
//
//  Parameters:
//      dwWindowID - Window ID to activate
//      dwFlags - should always zero
//
//  Returns:
//      dwWindowID - window ID that got activated
//
HDDEDATA CIEDDEThread::WWW_Activate(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_Activate(pszParams=>%s<)"), pszParams);

    if (ParseWinitem(&pszParams, &wi) &&
        wi.dwWindowID != 0)
    {
#ifdef DEBUG
        DWORD dwFlags;
        if (ParseNumber(&pszParams, &dwFlags))
        {
            //
            // Netscape spec says this should always be zero.
            //
            ASSERT(dwFlags == 0);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required dwFlags parameter to WWW_Activate");
        }
#endif

        //
        // dwWindowID of -1 means use the active window.
        //
        if (wi.dwWindowID == -1)
        {
            HWND hwnd;

            CDDEAuto_get_HWND((long *)&hwnd);

            if (hwnd)
            {
                if (g_pIEDDE->GetWinitemFromHwnd(hwnd, &wi) == FALSE)
                {
                    wi.dwWindowID = (DWORD)-1;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: Activate could not find an active window");
            }
        }

        //
        // Activate the window.
        //
        if (wi.dwWindowID != -1)
        {
            if ((GetForegroundWindow() == wi.hwnd) || (SetForegroundWindow(wi.hwnd)))
            {
                if (IsIconic(wi.hwnd))
                {
                    ShowWindow(wi.hwnd, SW_RESTORE);
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: Activate could not set foreground window");
            }
            
            hddRet = CREATE_HDD(wi.dwWindowID);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: Activate could not find a browser window to activate");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: Activate could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_Activate=%08X"), hddRet);
    return hddRet;
}


//
//  WWW_Exit - close all browser windows
//
//  Parameters:
//      none
//
//  Returns:
//      none
//
HDDEDATA CIEDDEThread::WWW_Exit(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(1, TEXT("WWW_Exit(pszParams=>%s<)"), pszParams);

    CDDEAuto_Exit();

    EXITPROC(1, TEXT("WWW_Exit=%08X"), hddRet);
    return hddRet;
}


//
//  WWW_RegisterURLEcho - register a server for URL change notifications
//
//  Parameters:
//      qcsServer - the DDE server to get notifications
//
//  Returns:
//      fSuccess
//
HDDEDATA CIEDDEThread::WWW_RegisterURLEcho(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer;

    ENTERPROC(1, TEXT("WWW_RegisterURLEcho(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0])
    {
        LPTSTR pszServerCopy = StrDup(pszServer);

        if (pszServerCopy)
        {
            if (g_pIEDDE->AddUrlEcho(pszServerCopy))
            {
                fSuccess = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: RegisterURLEcho could not add an URLEcho");
            }

            if (!fSuccess)
            {
                LocalFree(pszServerCopy);
                pszServerCopy = NULL;
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: RegisterURLEcho could not dup a string");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RegisterURLEcho could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_RegisterURLEcho=%08X"), hddRet);
    return hddRet;
}


//
//  WWW_UnregisterURLEcho - unregister a DDE server
//
//  Parameters:
//      qcsServer - the DDE server to stop getting notifications
//
//  Returns:
//      fSuccess
//
HDDEDATA CIEDDEThread::WWW_UnregisterURLEcho(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer;

    ENTERPROC(1, TEXT("WWW_UnregisterURLEcho(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0])
    {
        if (g_pIEDDE->RemoveUrlEcho(pszServer))
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: UnregisterURLEcho could not find the server");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: UnregisterURLEcho could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_UnregisterURLEcho=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_RegisterProtocol - register a server for handling a protocol
//
//  Parameters:
//      qcsServer - the DDE server to handle URLs
//      qcsProtocol - the protocol to handle
//
//  Returns:
//      fSuccess - this is the first server to register the protocol
//
HDDEDATA CIEDDEThread::WWW_RegisterProtocol(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer, pszProtocol;

    ENTERPROC(1, TEXT("WWW_RegisterProtocol(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0] &&
        ParseQString(&pszParams, &pszProtocol) && pszProtocol[0])
    {
        if (g_pIEDDE->AddProtocolHandler(pszServer, pszProtocol))
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: RegisterProtocol unable to register");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RegisterProtocol could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_RegisterProtocol=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_UnregisterProtocol - unregister a server handling a protocol
//
//  Parameters:
//      qcsServer - the DDE server which is handling URLs
//      qcsProtocol - the protocol getting handled
//
//  Returns:
//      fSuccess - this server was registered, but now isn't
//
HDDEDATA CIEDDEThread::WWW_UnregisterProtocol(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer, pszProtocol;

    ENTERPROC(1, TEXT("WWW_UnregisterProtocol(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0] &&
        ParseQString(&pszParams, &pszProtocol) && pszProtocol[0])
    {
        if (g_pIEDDE->RemoveProtocolHandler(pszServer, pszProtocol))
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: UnregisterProtocol unable to unregister");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: UnregisterProtocol could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_UnregisterProtocol=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_ListWindows - Get a list of DDE supported browser window IDs
//
//  Parameters:
//      none
//
//  Returns:
//      pdwWindowID (terminated with 0)
//
HDDEDATA CIEDDEThread::WWW_ListWindows(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    ENTERPROC(1, TEXT("WWW_ListWindows(pszParams=>%s<)"), pszParams);

    ENTER_IEDDE_CRIT;

    DWORD cbAlloc, *pdwWindowID;
    int cWindows = 0;
    HDSA hdsaWinitem = g_pIEDDE->GetHdsaWinitem();

    if (hdsaWinitem)
    {
        cWindows = DSA_GetItemCount(hdsaWinitem);
    }

    //
    // Note: we are following the Netscape spec (null terminated pdw) here,
    // whereas IE3 followed the Spyglass spec (pdw[0] = count of windows).
    //

    cbAlloc = (cWindows + 1) * SIZEOF(DWORD);

    pdwWindowID = (DWORD *)LocalAlloc(LPTR, cbAlloc);
    if (pdwWindowID)
    {
        DWORD *pdw;

        pdw = pdwWindowID;

        for (int i=0; i<cWindows; i++)
        {
            WINITEM wi;

            int iResult = DSA_GetItem(hdsaWinitem, i, &wi);

            if (iResult != -1)
            {
                *pdw++ = wi.dwWindowID;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: ListWindows could not get a DSA item");
            }
        }

        hddRet = CreateReturnObject(pdwWindowID, cbAlloc);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: ListWindows could not allocate a window list");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(1, TEXT("WWW_ListWindows=%08X"), hddRet);
    return hddRet;
}

//
// MakeQuotedString - wrap a string in " marks, escaping internal "s as \"
//
BOOL CIEDDEThread::MakeQuotedString(LPCTSTR pszInput, LPTSTR pszOutput, int cchOutput)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("MakeQuotedString(pszInput=>%s<,pszOutput=%08X,cchOutput=%08X)"), pszInput, pszOutput, cchOutput);

    if (cchOutput < 3)
    {
        TraceMsg(TF_WARNING, "IEDDE: MakeQuotedString has no room for minimal quoted string");
    }
    else if ((pszInput == NULL) || (*pszInput == TEXT('\0')))
    {
        StrCpyN(pszOutput, TEXT("\"\""), cchOutput);
        fRet = TRUE;
    }
    else
    {
        //
        // Copy first quote mark.
        //
        *pszOutput++ = TEXT('"');
        cchOutput--;

        //
        // Copy pszInput, escaping quote marks and making
        // sure to leave room for final quote and NULL.
        //
        while ((cchOutput > 2) && (*pszInput))
        {
            if (*pszInput == TEXT('"'))
            {
                *pszOutput++ = TEXT('\\');
                cchOutput--;
            }
            *pszOutput++ = *pszInput++;
            cchOutput--;
        }

        //
        // Copy final quote and NULL if we're done and there is room.
        //
        if ((*pszInput == TEXT('\0')) && (cchOutput >= 2))
        {
            StrCpyN(pszOutput, TEXT("\""), cchOutput);
            fRet = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: MakeQuotedString ran out of room in output buffer");
        }
    }

    EXITPROC(2, TEXT("MakeQuotedString=%d"), fRet);
    return fRet;
}
















#undef CIEDDEThread

//
// There is one global CIEDDE object per process.
// It maintains the global information, such as
// the list of all browsers & what threads they are on,
// and the list of all apps who have registered an URL Echo.
//
// Its methods consist of these categories:
//      the DDE callback function
//      an internal handler for each exposed IEDDE_ function
//      database (hdsa, hdpa) access and manipulation functions
//
// This object creates and destroys CIEDDEThread objects
// (at NewWindow and WindowDestroyed time) and also initializes /
// uninitializes DDE services on a per thread (not per hwnd!) basis.
//



//
// DdeCallback - DDE callback function for IEDDE.
//
#define DDETYPESTR(x) (x == XTYP_REQUEST ? TEXT("Request") : \
                       (x == XTYP_POKE ? TEXT("Poke") : \
                       (x == XTYP_EXECUTE ? TEXT("Execute") : \
                       (x == XTYP_CONNECT ? TEXT("Connect") : TEXT("Unknown")))))
HDDEDATA CIEDDE::DdeCallback(UINT dwType, UINT dwFmt, HCONV hconv, HSZ hsz1, HSZ hsz2, HDDEDATA hdd, DWORD dwData1, DWORD dwData2)
{
    HDDEDATA    hddRet = 0;
    ENTERPROC(2, TEXT("DdeCallback(dwType=%08X(%s),dwFmt=%d,hconv=%d,hsz1=%08X,hsz2=%08X,hdd=%08X,dwData1=%08X,dwData2=%08X)"),
                dwType, DDETYPESTR(dwType), dwFmt, hconv, hsz1, hsz2, hdd, dwData1, dwData2);

    WINITEM wi;

    switch (dwType)
    {
    case XTYP_REQUEST:
    case XTYP_POKE:
        if (g_pIEDDE->_GetWinitemFromThread(GetCurrentThreadId(), &wi))
        {
            hddRet = wi.pidt->OnRequestPoke(hsz1, hsz2);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: DdeCallback unable to get thread info on request / poke");
        }
        break;

    case XTYP_EXECUTE:
        if (g_pIEDDE->_GetWinitemFromThread(GetCurrentThreadId(), &wi))
        {
            hddRet = wi.pidt->OnExecute(hsz1, hdd);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: DdeCallback unable to get thread info on execute");
        }
        break;

    case XTYP_CONNECT:
        if (g_pIEDDE->_GetWinitemFromThread(GetCurrentThreadId(), &wi))
        {
            DDETHREADINFO dti;
            wi.pidt->GetDdeThreadInfo(&dti);
            hddRet = (HDDEDATA)(hsz2 == dti.hszService);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: DdeCallback unable to get thread info on connect");
        }
        break;

    case XTYP_ADVREQ:
    case XTYP_ADVSTOP:
        hddRet = DDE_FNOTPROCESSED;
        break;
    }

    EXITPROC(2, TEXT("DdeCallback=%08X"), hddRet);
    return hddRet;
}

//
// SendDDEMessageHsz - handle based wrapper for doing one DDE client transaction
//
HDDEDATA CIEDDE::_SendDDEMessageHsz(DWORD dwDDEInst, HSZ hszApp, HSZ hszTopic, HSZ hszMessage, UINT wType)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(2, TEXT("_SendDDEMessageHsz(dwDDEInst=%08X,hszApp=%08X,hszTopic=%08X,hszMessage=%08X,wType=%d)"), dwDDEInst, hszApp, hszTopic, hszMessage, wType);

    if (hszApp && hszTopic)
    {
        HCONV hconv;
        
        hconv = DdeConnect(dwDDEInst, hszApp, hszTopic, NULL);
        if (hconv)
        {
            hddRet = DdeClientTransaction(NULL, 0, hconv, hszMessage, CF_TEXT, wType, TEN_SECONDS, NULL);
            DdeDisconnect(hconv);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageHsz could not connect to app");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageHsz is missing either App or Topic");
    }

    EXITPROC(2, TEXT("_SendDDEMessageHsz=%08X"), hddRet);
    return hddRet;
}

//
// SendDDEMessageSz - string based wrapper for doing one DDE client transaction
//
HDDEDATA CIEDDE::_SendDDEMessageSz(DWORD dwDDEInst, LPCTSTR pszApp, LPCTSTR pszTopic, LPCTSTR pszMessage, UINT wType)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(2, TEXT("_SendDDEMessageSz(dwDDEInst=%08X,pszApp=>%s<,pszTopic=>%s<,pszMessage=>%s<,wType=%d)"), dwDDEInst, pszApp, pszTopic, pszMessage, wType);

    HSZ hszApp = DdeCreateStringHandle(dwDDEInst, pszApp, CP_WINNEUTRAL);
    if (hszApp)
    {
        HSZ hszTopic = DdeCreateStringHandle(dwDDEInst, pszTopic, CP_WINNEUTRAL);
        if (hszTopic)
        {
            HSZ hszMessage = DdeCreateStringHandle(dwDDEInst, pszMessage, CP_WINNEUTRAL);
            if (hszMessage)
            {
                hddRet = _SendDDEMessageHsz(dwDDEInst, hszApp, hszTopic, hszMessage, wType);
                DdeFreeStringHandle(dwDDEInst, hszMessage);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageSz could not convert message");
            }
            DdeFreeStringHandle(dwDDEInst, hszTopic);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageSz could not convert topic");
        }
        DdeFreeStringHandle(dwDDEInst, hszApp);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageSz could not convert app");
    }

    EXITPROC(2, TEXT("_SendDDEMessageSz=%08X"), hddRet);
    return hddRet;
}

//
// Initialize - called when ready to start IEDDE server
//
BOOL CIEDDE::_Initialize(void)
{
    BOOL fSuccess = TRUE;
    ENTERPROC(2, TEXT("_Initialize()"));

    ASSERT(_fCSInitialized == FALSE);
    InitializeCriticalSection(&_csIEDDE);
    _fCSInitialized = TRUE;

    EXITPROC(2, TEXT("_Initialize=%d"), fSuccess);
    return fSuccess;
}

//
// _DestroyWinitem - DSA callback to partially free the contents of a WINITEM*
//  In practice this should never get called, the hdsaWinItem list should be
//  empty at uninit time.
//
int CIEDDE::_DestroyWinitem(LPVOID p1, LPVOID p2)
{
    WINITEM *pwi = (WINITEM *)p1;
    ASSERT(IS_VALID_READ_PTR(pwi, WINITEM));
    ASSERT(IS_VALID_READ_PTR(pwi->pidt, CIEDDEThread));

    //
    // It would be good to unregister the DDE server at this point,
    // but we'd need to be on its thread to do it.
    //

    delete pwi->pidt;

    return 1;
}

//
// _DestroyProtocol - DSA callback to free the contents of a PROTOCOLREG*
//
int CIEDDE::_DestroyProtocol(LPVOID p1, LPVOID p2)
{
    PROTOCOLREG *pr = (PROTOCOLREG *)p1;
    ASSERT(IS_VALID_READ_PTR(pr, PROTOCOLREG));

    LocalFree(pr->pszProtocol);
    pr->pszProtocol = NULL;
    LocalFree(pr->pszServer);
    pr->pszServer = NULL;

    return 1;
}

//
// _DestroyUrlEcho - DPA callback to free allocated memory
//
int CIEDDE::_DestroyUrlEcho(LPVOID p1, LPVOID p2)
{
    ASSERT(IS_VALID_STRING_PTR((LPTSTR)p1, -1));
    LocalFree(p1);
    p1 = NULL;

    return 1;
}

//
// Uninitialize - called when ready to stop IEDDE server
//
void CIEDDE::_Uninitialize(void)
{
    ENTERPROC(2, TEXT("_Uninitialize()"));

    _fAutomationReady = FALSE;

    if (_hdsaWinitem)
    {
        if (DSA_GetItemCount(_hdsaWinitem))
        {
            //ASSERT(DSA_GetItemCount(_hdsaWinitem)==0);
            TraceMsg(TF_ERROR, "IEDDE: Browser windows still open on uninitialize");
        }

        DSA_DestroyCallback(_hdsaWinitem, _DestroyWinitem, 0);
        _hdsaWinitem = NULL;
    }

    if (_hdsaProtocolHandler)
    {
        DSA_DestroyCallback(_hdsaProtocolHandler, _DestroyProtocol, 0);
        _hdsaProtocolHandler = NULL;
    }

    if (_hdpaUrlEcho)
    {
        DPA_DestroyCallback(_hdpaUrlEcho, _DestroyUrlEcho, 0);
        _hdpaUrlEcho = NULL;
    }

    if (_fCSInitialized)
    {
        DeleteCriticalSection(&_csIEDDE);
    }

    EXITPROC(2, TEXT("_Uninitialize!"));
}

void CIEDDE::SetDelayedExecute(LPCTSTR pszTopic, LPCTSTR pszParams)
{
    _dwThreadID = GetCurrentThreadId();
    Str_SetPtr(&_pszTopic, pszTopic);
    Str_SetPtr(&_pszParams, pszParams);
}

void CIEDDE::RunDelayedExecute()
{
    if (_pszTopic && _pszParams)
    {
        WINITEM wi;
        if (_GetWinitemFromThread(_dwThreadID, &wi) && wi.pidt)
        {
            HDDEDATA h = wi.pidt->CallTopic(XTYP_EXECUTE, _pszTopic, _pszParams);
            DdeFreeDataHandle(h);
        }
    }

    Str_SetPtr(&_pszTopic, NULL);
    Str_SetPtr(&_pszParams, NULL);
}
//
// _AutomationStarted - called when automation support can be called
//
void CIEDDE::_AutomationStarted(void)
{
    ENTERPROC(1, TEXT("_AutomationStarted()"));
    if (!_fAutomationReady && _pszTopic && _pszParams)
    {
        WINITEM wi;
        if (_GetWinitemFromThread(_dwThreadID, &wi) && wi.pidt)
        {
            PostMessage(wi.hwnd, WMC_DELAYEDDDEEXEC, 0, 0);
        }
    }
    _fAutomationReady = TRUE;

    EXITPROC(1, TEXT("_AutomationStarted!"));
}

//
// _BeforeNavigate - called before a navigation occurs.
//
HRESULT CIEDDE::_BeforeNavigate(LPCTSTR pszURL, BOOL *pfProcessed)
{
    ENTERPROC(1, TEXT("_BeforeNavigate(pszURL=>%s<,pfProcessed=%08X)"), pszURL, pfProcessed);

    SHSTR shstrMsg;
    HRESULT hr = S_OK;
    int cProtocols = 0;

    ENTER_IEDDE_CRIT;
    if (_hdsaProtocolHandler)
    {
        cProtocols = DSA_GetItemCount(_hdsaProtocolHandler);
    }
    LEAVE_IEDDE_CRIT;

    if (cProtocols)
    {
        DDETHREADINFO dti;

        if (_GetDtiFromThread(GetCurrentThreadId(), &dti))
        {
            PARSEDURL pu;

            pu.cbSize = SIZEOF(pu);

            if (SUCCEEDED(ParseURL(pszURL, &pu)))
            {
                int i;

                for (i=0; i<cProtocols; i++)
                {
                    PROTOCOLREG pr;

                    ENTER_IEDDE_CRIT;
                    int iResult = DSA_GetItem(_hdsaProtocolHandler, i, &pr);
                    LEAVE_IEDDE_CRIT;

                    if (iResult != -1)
                    {
                        //
                        // Check to see if the protocol to navigate
                        // matches one of our registered protocols.
                        // We do a case insensitive compare.  Note
                        // that:
                        //
                        //   (1) ParseURL does not null terminate the
                        //       pu.pszProtocol (its length is stored
                        //       in pu.cchProtocol).
                        //
                        //   (2) pu.pszProtocol is a LPCTSTR so we
                        //       can't modify the pszProtocol ourselves.
                        //
                        //   (3) There is no win32 lstrncmpi() API.
                        //
                        // Therefore in order to do a case insensitive
                        // compare we must copy the pu.pszProtocol into
                        // a writable buffer at some point.
                        //
                        if (lstrlen(pr.pszProtocol) == (int)pu.cchProtocol)
                        {
                            shstrMsg.SetStr(pu.pszProtocol, pu.cchProtocol);
                            if (StrCmpI(pr.pszProtocol, shstrMsg) == 0)
                            {
                                shstrMsg.SetStr(TEXT("\""));
                                shstrMsg.Append(pszURL);
                                shstrMsg.Append(TEXT("\",,-1,0,,,,"));

                                if (_SendDDEMessageSz(dti.dwDDEInst, pr.pszServer, c_szWWWOpenURL, shstrMsg, XTYP_REQUEST))
                                {
                                    if (pfProcessed)
                                    {
                                        *pfProcessed = TRUE;
                                    }
                                }
                                else
                                {
                                    TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate could not DDE to protocol handler");
                                }

                                break;
                            }
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate could not get item from DSA");
                    }
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate could not parse URL");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate unable to get thread info, can't use DDE");
        }
    }

    EXITPROC(1, TEXT("_BeforeNavigate=%08X"), hr);
    return hr;
}

//
// _AfterNavigate - called after a navigation occurs
//
HRESULT CIEDDE::_AfterNavigate(LPCTSTR pszURL, HWND hwnd)
{
    ENTERPROC(1, TEXT("_AfterNavigate(pszURL=>%s<,hwnd=%08X)"), pszURL, hwnd);

    int cURLHooks = 0;
    SHSTR shstrMsg;
    HRESULT hr = S_OK;

    ENTER_IEDDE_CRIT;
    if (_hdpaUrlEcho)
    {
        cURLHooks = DPA_GetPtrCount(_hdpaUrlEcho);
    }
    LEAVE_IEDDE_CRIT;

    if (cURLHooks)
    {
        SHSTR shstrMime;

        // (mattsq 1-97)
        // this is a temporary lie - it should be fixed to use the real mimetype
        // with something like:
        //      GetMimeTypeFromUrl(pszURL, shstrMime);
        // talk to URLMON people
        shstrMime.SetStr(TEXT("text/html"));

        DDETHREADINFO dti={0};
        WINITEM wi;
        DWORD dwWindowID;
        if (GetWinitemFromHwnd(hwnd, &wi))
        {
            dwWindowID = wi.dwWindowID;
            wi.pidt->GetDdeThreadInfo(&dti);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to find browser window ID, using -1");
            dwWindowID = (DWORD)-1;

            WINITEM wiThread;

            if (_GetWinitemFromThread(GetCurrentThreadId(), &wiThread))
            {
                ASSERT(wiThread.pidt);
                wiThread.pidt->GetDdeThreadInfo(&dti);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to find DDE thread info");
            }
        }

        if (dti.dwDDEInst)
        {
            HSZ hszTopic = DdeCreateStringHandle(dti.dwDDEInst, c_szWWWUrlEcho, CP_WINNEUTRAL);
            if (hszTopic)
            {
                TCHAR szFinish[16];

                shstrMsg.SetStr(TEXT("\""));                // Quote
                shstrMsg.Append(pszURL);                    // URL
                shstrMsg.Append(TEXT("\",\""));             // Quote Comma Quote
                shstrMsg.Append(shstrMime);                 // Mime
                wnsprintf(szFinish, ARRAYSIZE(szFinish), TEXT("\",%d"), dwWindowID);    //
                shstrMsg.Append(szFinish);                  // Quote Comma dwWindowID NULL

                HSZ hszMsg = DdeCreateStringHandle(dti.dwDDEInst, shstrMsg, CP_WINNEUTRAL);

                if (hszMsg)
                {
                    //
                    // Enumerate in reverse order because calling a hook may destroy it.
                    //
                    for (int i=cURLHooks-1; i>=0; --i)
                    {
                        ENTER_IEDDE_CRIT;
                        LPTSTR pszService = (LPTSTR)DPA_GetPtr(_hdpaUrlEcho, i);
                        LEAVE_IEDDE_CRIT;

                        if (pszService != NULL)
                        {
                            HSZ hszService = DdeCreateStringHandle(dti.dwDDEInst, pszService, CP_WINNEUTRAL);

                            if (hszService)
                            {
                                if (_SendDDEMessageHsz(dti.dwDDEInst, hszService, hszTopic, hszMsg, XTYP_POKE) == 0)
                                {
                                    TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate could not DDE to URLHook handler");
                                }

                                DdeFreeStringHandle(dti.dwDDEInst, hszService);
                            }
                            else
                            {
                                TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to create hszService");
                            }
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to enumerate an URL hook");
                        }
                    }

                    DdeFreeStringHandle(dti.dwDDEInst, hszMsg);
                }
                else
                {
                    TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to create hszMsg");
                }

                DdeFreeStringHandle(dti.dwDDEInst, hszTopic);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to create hszTopic");
            }
        }
    }

    EXITPROC(1, TEXT("_AfterNavigate=%08X"), hr);
    return hr;
}

//
// GetWinitemFromHwnd - return the winitem associated with an hwnd
//
BOOL CIEDDE::GetWinitemFromHwnd(HWND hwnd, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("GetWinitemFromHwnd(hwnd=%08X,pwi=%08X)"), hwnd, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.hwnd == hwnd)
                {
                    *pwi = wi;
                    fSuccess = TRUE;
                    break;
                }
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("GetWinitemFromHwnd=%d"), fSuccess); 
    return fSuccess;
}

//
// GetWinitemFromWindowID - return the winitem associated with a window ID
//
BOOL CIEDDE::GetWinitemFromWindowID(DWORD dwWindowID, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(3, TEXT("GetWinitemFromWindowID(dwWindowID=%08X,pwi=%08X)"), dwWindowID, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.dwWindowID == dwWindowID)
                {
                    *pwi = wi;
                    fSuccess = TRUE;
                    break;
                }
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("GetWinitemFromWindowID=%d"), fSuccess); 
    return fSuccess;
}

//
// _GetWinitemFromThread - return the first winitem associated with a thread
//
BOOL CIEDDE::_GetWinitemFromThread(DWORD dwThreadID, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_GetWinitemFromThread(dwThreadID=%08X,pwi=%08X)"), dwThreadID, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.dwThreadID == dwThreadID)
                {
                    *pwi = wi;
                    fSuccess = TRUE;
                    break;
                }
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_GetWinitemFromThread=%d"), fSuccess); 
    return fSuccess;
}

//
// _GetDtiFromThread - return the threadinfo associated with a thread
//
BOOL CIEDDE::_GetDtiFromThread(DWORD dwThreadID, DDETHREADINFO *pdti)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_GetDtiFromThread(dwThreadID=%08X,pdti=%08X)"), dwThreadID, pdti);

    ENTER_IEDDE_CRIT;

    WINITEM wi;
    if (_GetWinitemFromThread(dwThreadID, &wi))
    {
        wi.pidt->GetDdeThreadInfo(pdti);
        fSuccess = TRUE;
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _GetDtiFromThread unable to find winitem");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_GetDtiFromThread=%d"), fSuccess); 
    return fSuccess;
}

//
// _CreateDdeThreadInfo - Initialize DDE services and names for this thread
//
BOOL CIEDDE::_CreateDdeThreadInfo(DDETHREADINFO *pdti)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_CreateDdeThreadInfo(pdti=%08X)"), pdti);

    UINT uiDDE;
    DDETHREADINFO dti={0};

    //
    // Initialize DDEML, register our service.
    //

    uiDDE = DdeInitialize(&dti.dwDDEInst, (PFNCALLBACK)DdeCallback,
                           APPCLASS_STANDARD | CBF_FAIL_ADVISES |
                           CBF_SKIP_REGISTRATIONS | CBF_SKIP_UNREGISTRATIONS, 0);

    if (uiDDE == DMLERR_NO_ERROR)
    {
        dti.hszReturn = DdeCreateStringHandle(dti.dwDDEInst, c_szReturn, CP_WINNEUTRAL);
        if (dti.hszReturn)
        {
            dti.hszService = DdeCreateStringHandle(dti.dwDDEInst, c_szIExplore, CP_WINNEUTRAL);
            if (dti.hszService)
            {
                *pdti = dti;
                fSuccess = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _CreateDdeThreadInfo unable to convert service");
            }

            if (!fSuccess)
            {
                DdeFreeStringHandle(dti.dwDDEInst, dti.hszReturn);
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _CreateDdeThreadInfo unable to convert return");
        }

        if (!fSuccess)
        {
            DdeUninitialize(dti.dwDDEInst);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _CreateDdeThreadInfo unable to init DDE");
    }

    EXITPROC(2, TEXT("_CreateDdeThreadInfo=%d"), fSuccess);
    return fSuccess;
}

//
// _DestroyDdeThreadInfo - Free up any resources in a dti structure.
//
void CIEDDE::_DestroyDdeThreadInfo(DDETHREADINFO *pdti)
{
    ENTERPROC(2, TEXT("_DestroyDdeThreadInfo(pdti=%08X)"), pdti);

    if (pdti->hddNameService)
    {
        ASSERT(pdti->hszService);
        DdeNameService(pdti->dwDDEInst, pdti->hszService, 0, DNS_UNREGISTER);
        pdti->hddNameService = 0;
    }

    if (pdti->hszService)
    {
        DdeFreeStringHandle(pdti->dwDDEInst, pdti->hszService);
        pdti->hszService = 0;
    }

    if (pdti->hszReturn)
    {
        DdeFreeStringHandle(pdti->dwDDEInst, pdti->hszReturn);
        pdti->hszReturn = 0;
    }

    if (pdti->dwDDEInst)
    {
        DdeUninitialize(pdti->dwDDEInst);
        pdti->dwDDEInst = 0;
    }

    EXITPROC(2, TEXT("_DestroyDdeThreadInfo!"));
    return;
}

//
// _AddWinitem - adds a winitem to _hdsaWinitem
//
BOOL CIEDDE::_AddWinitem(WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_AddWinitem(pwi=%08X)"), pwi);

    ENTER_IEDDE_CRIT;

    if (!_hdsaWinitem)
    {
        _hdsaWinitem = DSA_Create(SIZEOF(WINITEM), DXA_GROWTH_AMOUNT);
    }

    if (_hdsaWinitem)
    {
        if (DSA_AppendItem(_hdsaWinitem, pwi) != -1)
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _AddWinitem could not append an item");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _AddWinitem could not create hdsa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_AddWinitem=%d"), fSuccess);
    return fSuccess;
}

//
// _UpdateWinitem - updates a winitem based on the dwWindowID.
//
BOOL CIEDDE::_UpdateWinitem(WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_UpdateWinitem(pwi=%08X)"), pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        int cItems = DSA_GetItemCount(_hdsaWinitem);

        for (int i=0; i<cItems; i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.dwWindowID == pwi->dwWindowID)
                {
                    if (DSA_SetItem(_hdsaWinitem, i, pwi))
                    {
                        fSuccess = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _UpdateWinitem could not update an item");
                    }
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _UpdateWinitem could not get an item");
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_UpdateWinitem=%d"), fSuccess);
    return fSuccess;
}

//
// AddUrlEcho - adds an UrlEcho entry to the dpa
//
BOOL CIEDDE::AddUrlEcho(LPCTSTR pszUrlEcho)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("AddUrlEcho(pszUrlEcho=>%s<)"), pszUrlEcho);

    ENTER_IEDDE_CRIT;

    if (!_hdpaUrlEcho)
    {
        _hdpaUrlEcho = DPA_Create(DXA_GROWTH_AMOUNT);
    }

    if (_hdpaUrlEcho)
    {
        if (DPA_AppendPtr(_hdpaUrlEcho, (LPVOID)pszUrlEcho) != -1)
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: AddUrlEcho unable to append a ptr");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: AddUrlEcho unable to create a dpa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("AddUrlEcho=%d"), fSuccess);
    return fSuccess;
}

//
// RemoveUrlEcho - remove an UrlEcho entry from the dpa
//
BOOL CIEDDE::RemoveUrlEcho(LPCTSTR pszUrlEcho)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("RemoveUrlEcho(pszUrlEcho=>%s<)"), pszUrlEcho);

    ENTER_IEDDE_CRIT;

    if (_hdpaUrlEcho)
    {
        for (int i=0; i<DPA_GetPtrCount(_hdpaUrlEcho); i++)
        {
            LPTSTR pszList = (LPTSTR)DPA_GetPtr(_hdpaUrlEcho, i);
            if (pszList)
            {
                if (StrCmpI(pszList, pszUrlEcho) == 0)
                {
                    DPA_DeletePtr(_hdpaUrlEcho, i);
                    LocalFree((HANDLE)pszList);
                    pszList = NULL;
                    fSuccess = TRUE;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_ALWAYS, "IEDDE: RemoveUrlEcho unable to get dpa ptr");
            }
        }

        if (!fSuccess)
        {
            TraceMsg(TF_WARNING, "IEDDE: RemoveUrlEcho unable to find server");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RemoveUrlEcho unable to find dpa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("RemoveUrlEcho=%d"), fSuccess);
    return fSuccess;
}

//
// AddProtocolHandler - add a PROTOCOLREG entry to the dsa
//
BOOL CIEDDE::AddProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("AddProtocolHandler(pszServer=>%s<,pszProtocol=>%s<)"), pszServer, pszProtocol);

    ENTER_IEDDE_CRIT;

    PROTOCOLREG pr;
    //
    // First, see if anybody else grabbed the protocol first.
    //
    BOOL fFoundHandler = FALSE;
    if (_hdsaProtocolHandler)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaProtocolHandler); i++)
        {
            if (DSA_GetItem(_hdsaProtocolHandler, i, &pr) != -1)
            {
                if (StrCmpI(pr.pszProtocol, pszProtocol) == 0)
                {
                    TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler already has a handler");
                    fFoundHandler = TRUE;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to get an item");
            }
        }
    }

    if (!fFoundHandler)
    {
        if (!_hdsaProtocolHandler)
        {
            _hdsaProtocolHandler = DSA_Create(SIZEOF(PROTOCOLREG), DXA_GROWTH_AMOUNT);
        }

        if (_hdsaProtocolHandler)
        {
            pr.pszServer = StrDup(pszServer);
            if (pr.pszServer)
            {
                pr.pszProtocol = StrDup(pszProtocol);
                if (pr.pszProtocol)
                {
                    if (DSA_AppendItem(_hdsaProtocolHandler, &pr) != -1)
                    {
                        fSuccess = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to append to dsa");
                    }

                    if (!fSuccess)
                    {
                        LocalFree((HANDLE)pr.pszProtocol);
                        pr.pszProtocol = NULL;
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to dup protocol");
                }

                if (!fSuccess)
                {
                    LocalFree((HANDLE)pr.pszServer);
                    pr.pszServer = NULL;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to dup server");
            }

        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to create dsa");
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("AddProtocolHandler=%d"), fSuccess);
    return fSuccess;
}

//
// RemoveProtocolHandler - removes a PROTOCOLREG item from the dsa
//
BOOL CIEDDE::RemoveProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("RemoveProtocolHandler(pszServer=>%s<,pszProtocol=>%s<)"), pszServer, pszProtocol);

    ENTER_IEDDE_CRIT;

    if (_hdsaProtocolHandler)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaProtocolHandler); i++)
        {
            PROTOCOLREG pr;

            if (DSA_GetItem(_hdsaProtocolHandler, i, &pr) != -1)
            {
                if (StrCmpI(pr.pszProtocol, pszProtocol) == 0)
                {
                    if (StrCmpI(pr.pszServer, pszServer) == 0)
                    {
                        if (DSA_DeleteItem(_hdsaProtocolHandler, i) != -1)
                        {
                            LocalFree((HANDLE)pr.pszServer);
                            pr.pszServer = NULL;
                            LocalFree((HANDLE)pr.pszProtocol);
                            pr.pszProtocol = NULL;
                            fSuccess = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler unable to remove item");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler says server didn't match");
                    }

                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler unable to get item");
            }
        }

        if (!fSuccess)
        {
            TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler unable to complete mission");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler can't find the dsa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("RemoveProtocolHandler=%d"), fSuccess);
    return fSuccess;
}

//
// _DeleteWinitemByHwnd - removes a winitem from _hdsaWinitem
//
BOOL CIEDDE::_DeleteWinitemByHwnd(HWND hwnd, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_DeleteWinitemByHwnd(hwnd=%08X,pwi=%08X)"), hwnd, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.hwnd == hwnd)
                {
                    if (DSA_DeleteItem(_hdsaWinitem, i) != -1)
                    {
                        *pwi = wi;
                        fSuccess = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _DeleteWinitemByHwnd could note delete an item");
                    }

                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _DeleteWinitemByHwnd could note get an item");
            }
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _DeleteWinitemByHwnd has no _hdsaWinitem");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_DeleteWinitemByHwnd=%d"), fSuccess);
    return fSuccess;
}

//
// _NewWindow - Add a browser window to the internal list
//
BOOL CIEDDE::_NewWindow(HWND hwnd)
{
    BOOL fSuccess = FALSE;

    ENTERPROC(1, TEXT("NewWindow(hwnd=%08X)"), hwnd);

    ASSERT(IS_VALID_HANDLE(hwnd, WND));

    ENTER_IEDDE_CRIT;

    WINITEM wi;
    if (GetWinitemFromHwnd(hwnd, &wi) == FALSE)
    {
        CIEDDEThread *pidt = new CIEDDEThread();

        if (pidt)
        {
            DDETHREADINFO dti = {0};
            DWORD dwThreadID = GetCurrentThreadId();
            WINITEM wi;
            BOOL fCreatedDTI = FALSE;

            if (_GetWinitemFromThread(dwThreadID, &wi))
            {
                wi.pidt->GetDdeThreadInfo(&dti);
            }
            else
            {
                LEAVE_IEDDE_CRIT;
                _CreateDdeThreadInfo(&dti);
                ENTER_IEDDE_CRIT;
                fCreatedDTI = TRUE;
            }

            if (dti.dwDDEInst)
            {
                static DWORD dwNextWindowID = 1;

                pidt->SetDdeThreadInfo(&dti);

                wi.dwThreadID = dwThreadID;
                wi.pidt = pidt;
                wi.hwnd = hwnd;
                wi.dwWindowID = dwNextWindowID++;

                if (_AddWinitem(&wi))
                {
                    //
                    // Now that we have a (partial) winitem in the winitem
                    // database, we can register our name service.  If we
                    // registered any sooner, there is a risk that an app
                    // will try to connect to us while we are registering,
                    // and we will fail the connect because the winitem
                    // is not in the registry yet.
                    //
                    LEAVE_IEDDE_CRIT;
                    dti.hddNameService = DdeNameService(dti.dwDDEInst, dti.hszService, 0, DNS_REGISTER);
                    ENTER_IEDDE_CRIT;

                    //
                    // Now that we have hddNameService, we can update the
                    // winitem in the database.
                    //
                    if (dti.hddNameService)
                    {
                        pidt->SetDdeThreadInfo(&dti);
                        if (_UpdateWinitem(&wi))
                        {
                            fSuccess = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: _NewWindow unable to update a win item");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _NewWindow unable to register service");
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "IEDDE: _NewWindow could not append win item");
                }

                if (!fSuccess && fCreatedDTI)
                {
                    LEAVE_IEDDE_CRIT;
                    _DestroyDdeThreadInfo(&dti);
                    ENTER_IEDDE_CRIT;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _NewWindow could not get/create dde thread info");
            }

            if (!fSuccess)
            {
                delete pidt;
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _NewWindow could not create iedde thread object");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _NewWindow says window already registered?!?");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(1, TEXT("_NewWindow=%d"), fSuccess);
    return fSuccess;
}

//
// _WindowDestroyed - Remove a browser window from the internal list
//
BOOL CIEDDE::_WindowDestroyed(HWND hwnd)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(1, TEXT("_WindowDestroyed(hwnd=%08X)"), hwnd);

    ENTER_IEDDE_CRIT;

    WINITEM wi;
    if (_DeleteWinitemByHwnd(hwnd, &wi))
    {
        fSuccess = TRUE;

        ASSERT(wi.pidt);
        WINITEM wiThread;

        if (_GetWinitemFromThread(wi.dwThreadID, &wiThread) == FALSE)
        {
            if (wi.dwThreadID == GetCurrentThreadId())
            {
                DDETHREADINFO dti;

                wi.pidt->GetDdeThreadInfo(&dti);
                // Don't hold onto critical section while doing this...
                LEAVE_IEDDE_CRIT;
                _DestroyDdeThreadInfo(&dti);
                ENTER_IEDDE_CRIT;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _WindowDestroyed called on wrong thread");
            }
        }

        delete wi.pidt;
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _WindowDestroyed could not find hwnd");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(1, TEXT("_WindowDestroyed=%d"), fSuccess);
    return fSuccess;
}





//
// IEDDE_ functions are those exported for other parts of shdocvw to call.
// They pretty much just call the equivalent function in g_pIEDDE.
//

BOOL IEDDE_Initialize(void)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("IEDDE_Initialize()"));

    if (g_pIEDDE == NULL)
    {
        g_pIEDDE = new CIEDDE;

        if (g_pIEDDE)
        {
            fRet = g_pIEDDE->_Initialize();
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: IEDDE_Initialize could not allocate an IEDDE object");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_Initialize says already initialized");
    }

    EXITPROC(2, TEXT("IEDDE_Initialize=%d"), fRet);
    return fRet;
}

void IEDDE_Uninitialize(void)
{
    ENTERPROC(2, TEXT("IEDDE_Uninitialize()"));

    if (g_pIEDDE)
    {
        g_pIEDDE->_Uninitialize();
        delete g_pIEDDE;
        g_pIEDDE = NULL;
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_Uninitialize has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_Uninitialize!"));
}

BOOL IEDDE_RunDelayedExecute()
{
    if (g_pIEDDE)
    {
        g_pIEDDE->RunDelayedExecute();
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_RunDelayedExecute has no IEDDE object");
    }
    return TRUE;
}

void IEDDE_AutomationStarted(void)
{
    ENTERPROC(2, TEXT("IEDDE_AutomationStarted()"));

    if (g_pIEDDE)
    {
        g_pIEDDE->_AutomationStarted();
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_AutomationStarted has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_AutomationStarted!"));
}

HRESULT IEDDE_BeforeNavigate(LPCWSTR pwszURL, BOOL *pfCanceled)
{
    HRESULT hr = E_FAIL;

    ENTERPROC(2, TEXT("IEDDE_BeforeNavigate(pwszURL=%08X,pfCanceled=%08X)"), pwszURL, pfCanceled);

    if (g_pIEDDE)
    {
        LPCTSTR pszURL;

        pszURL = pwszURL;

        if (pszURL)
        {
            hr = g_pIEDDE->_BeforeNavigate(pszURL, pfCanceled);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_BeforeNavigate has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_BeforeNavigate=%08X"), hr);
    return hr;
}

HRESULT IEDDE_AfterNavigate(LPCWSTR pwszURL, HWND hwnd)
{
    HRESULT hr = E_FAIL;

    ENTERPROC(2, TEXT("IEDDE_AfterNavigate(pwszURL=%08X,hwnd=%08X)"), pwszURL, hwnd);

    if (g_pIEDDE)
    {
        LPCTSTR pszURL;

        pszURL = pwszURL;

        if (pszURL)
        {
            hr = g_pIEDDE->_AfterNavigate(pszURL, hwnd);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_AfterNavigate has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_AfterNavigate=%08X"), hr);
    return hr;
}

BOOL IEDDE_NewWindow(HWND hwnd)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("IEDDE_NewWindow(hwnd=%08X)"), hwnd);

    if (g_pIEDDE)
    {
        fRet = g_pIEDDE->_NewWindow(hwnd);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_NewWindow has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_NewWindow=%d"), fRet);
    return fRet;
}

BOOL IEDDE_WindowDestroyed(HWND hwnd)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("IEDDE_WindowDestroyed(hwnd=%08X)"), hwnd);

    if (g_pIEDDE)
    {
        fRet = g_pIEDDE->_WindowDestroyed(hwnd);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_WindowDestroyed has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_WindowDestroyed=%d"), fRet);
    return fRet;
}





#ifdef DEBUG

//
// Move g_dwIEDDETrace into ccshell.ini to prevent recompiles.
//

DWORD g_dwIEDDETrace = 0;
static DWORD g_dwIndent = 0;
static const TCHAR c_szDotDot[] = TEXT("..");

#define MAX_INDENTATION_VALUE   0x10

void EnterProc(DWORD dwTraceLevel, LPTSTR szFmt, ...)
{
    TCHAR szOutput[1000];
    va_list arglist;

    if (dwTraceLevel <= g_dwIEDDETrace)
    {
        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            StrCatBuff(szOutput, c_szDotDot, ARRAYSIZE(szOutput));
        }

        va_start(arglist, szFmt);
        wvnsprintf(szOutput + lstrlen(szOutput), ARRAYSIZE(szOutput) - lstrlen(szOutput), szFmt, arglist);
        va_end(arglist);

        TraceMsg(TF_ALWAYS, "%s", szOutput);

        // This value can get out of hand if EnterProc and ExitProc
        // calls do not match. This can trash the stack.
        if(g_dwIndent < MAX_INDENTATION_VALUE)
            g_dwIndent++;
    }
}

void ExitProc(DWORD dwTraceLevel, LPTSTR szFmt, ...)
{
    TCHAR szOutput[1000];
    va_list arglist;

    if (dwTraceLevel <= g_dwIEDDETrace)
    {
        // This can happen if the EnterProc and 
        // ExitProc calls do not match.
        if(g_dwIndent > 0)
            g_dwIndent--;

        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            StrCatBuff(szOutput, c_szDotDot, ARRAYSIZE(szOutput));
        }

        va_start(arglist, szFmt);
        wvnsprintf(szOutput + lstrlen(szOutput), ARRAYSIZE(szOutput) - lstrlen(szOutput), szFmt, arglist);
        va_end(arglist);

        TraceMsg(TF_ALWAYS, "%s", szOutput);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\ibapp.cpp ===
// coming soon: new deskbar (old deskbar moved to browbar base class)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\htmlstr.h ===
/*
 * htmlstr.h
 *
 * HTML string constants
 *
 */

#ifndef _HTMLSTR_H
#define _HTMLSTR_H

#if !defined( WIN16 ) || !defined( __WATCOMC__ )

#ifdef DEFINE_STRING_CONSTANTS

#ifndef UNIX

#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];

#else

// IEUNIX : Trying to get same memory layout as above.

struct UNIX_BSTR_FORMAT {
        DWORD cbCount;                                         \
        WCHAR data[] ;                                         \
};

#define MAKEBSTR(name, count, strdata)                         \
    const struct UNIX_BSTR_FORMAT STRUCT_##name = {(count * sizeof(OLECHAR)), L##strdata};  \
    extern "C" CDECL BSTR name = (BSTR) &STRUCT_##name.data;

#endif


#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y

#else
#define MAKEBSTR(name, count, strdata) extern "C" CDECL LPCWSTR name

#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#else // !WIN16 || !__WATCOMC__

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" const char CDECL DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, strdata}; \
    extern "C" BSTR  CDECL name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y

#else
#define MAKEBSTR(name, count, strdata) extern "C" LPCWSTR CDECL name

#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#endif

#endif // !WIN16 || !__WATCOMC__


MAKEBSTR(c_bstr_AfterBegin, 10, "AfterBegin");
MAKEBSTR(c_bstr_BeforeEnd,   9, "BeforeEnd");
MAKEBSTR(c_bstr_SRC,        3,  "src");
MAKEBSTR(c_bstr_HREF,       4,  "HREF");
MAKEBSTR(c_bstr_IMG,        3,  "IMG");
MAKEBSTR(c_bstr_BGSOUND,    7,  "BGSOUND");
MAKEBSTR(c_bstr_BASE,       4,  "BASE");
MAKEBSTR(c_bstr_Word,       4,  "Word");
MAKEBSTR(c_bstr_Character,  9,  "Character");
MAKEBSTR(c_bstr_StartToEnd, 10, "StartToEnd");
MAKEBSTR(c_bstr_EndToEnd,   8,  "EndToEnd");
MAKEBSTR(c_bstr_StartToStart,   12,  "StartToStart");
MAKEBSTR(c_bstr_EndToStart, 10, "EndToStart");
MAKEBSTR(c_bstr_ANCHOR, 1, "A");
MAKEBSTR(c_bstr_BLOCKQUOTE,10,  "BLOCKQUOTE");
MAKEBSTR(c_bstr_BACKGROUND,10,  "background");
MAKEBSTR(c_bstr_BODY,      4,   "BODY");
MAKEBSTR(c_bstr_TABLE,     5,   "TABLE");
MAKEBSTR(c_bstr_TD,        2,   "TD");
MAKEBSTR(c_bstr_TH,        2,   "TH");
MAKEBSTR(c_bstr_FRAME,     5,   "FRAME");
MAKEBSTR(c_bstr_IFRAME,    6,   "IFRAME");
MAKEBSTR(c_bstr_FRAMESET,  8,   "FRAMESET");
MAKEBSTR(c_bstr_LINK,      4,   "LINK");
MAKEBSTR(c_bstr_REL,       3,   "REL");
MAKEBSTR(c_bstr_STYLESHEET, 10, "stylesheet");
MAKEBSTR(c_bstr_DYNSRC,    6,   "DYNSRC");
MAKEBSTR(c_bstr_INPUT,     5,   "INPUT" );
MAKEBSTR(c_bstr_AREA,     4,   "AREA" );
MAKEBSTR(c_bstr_ON,     2,   "on" );
MAKEBSTR(c_bstr_SCRIPT, 6,  "SCRIPT" );
MAKEBSTR(c_bstr_EMPTY,  0, "");
MAKEBSTR(c_bstr_DesignOff, 3, "off" );
MAKEBSTR(c_bstr_BLANK, 11, "about:blank");
#endif //_HTMLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iforms.h ===
// Called from hlframe
// Set user GUID, for identities
HRESULT SetIdAutoSuggestForForms(const GUID *pguidId, void *pIntelliForms);
// Exported for inetCPL
EXTERN_C HRESULT ClearAutoSuggestForForms(DWORD dwClear);   // dwClear in msiehost.h

// called from iedisp.cpp
void AttachIntelliForms(void *pOmWindow, HWND hwnd, IHTMLDocument2 *pDoc2, void **ppIntelliForms);
void ReleaseIntelliForms(void *pIntelliForms);
HRESULT IntelliFormsDoAskUser(HWND hwndBrowser, void *pv);

// called from shuioc.cpp
HRESULT IntelliFormsSaveForm(IHTMLDocument2 *pDoc2, VARIANT *pvarForm);

HRESULT IntelliFormsActiveElementChanged(void *pIntelliForms, IHTMLElement * pHTMLElement);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iface.h ===
#ifndef _IFACE_H
#define _IFACE_H

// Interfaces and IIDs defined here are private to shdocvw.dll
//


//
// IDocNavigate
//
// DocHost needs to notify the browser of certain events
//
//131A6950-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IDocNavigate
DECLARE_INTERFACE_(IDocNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocNavigate methods ***
    STDMETHOD(OnReadyStateChange)(THIS_ IShellView* psvSource, DWORD dwReadyState) PURE;
    STDMETHOD(get_ReadyState)(THIS_ DWORD * pdwReadyState) PURE;

} ;

//
// IBandNavigate
//
//  band needs to navigate its UI to a specific pidl.
//
#undef  INTERFACE
#define INTERFACE  IBandNavigate
DECLARE_INTERFACE_(IBandNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBandNavigate methods ***
    STDMETHOD(Select)(THIS_ LPCITEMIDLIST pidl) PURE;

} ;


//
// IEFrameAuto
//
// CIEFrameAuto private interface to hold randum stuff
//
//131A6953-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IEFrameAuto
DECLARE_INTERFACE_(IEFrameAuto, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IEFrameAuto methods ***
    STDMETHOD(SetOwnerHwnd)(THIS_ HWND hwndOwner) PURE;
    STDMETHOD(put_DefaultReadyState)(THIS_ DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState) PURE;
    STDMETHOD(OnDocumentComplete)(THIS) PURE;
    STDMETHOD(OnWindowsListMarshalled)(THIS) PURE;
    STDMETHOD(SetDocHostFlags)(THIS_ DWORD dwDocHostFlags) PURE;
};

//
// IPrivateOleObject
//
// a cut down version of IOleObject used for the WebBrowserOC to communicate with
// objects hosted via CDocObjectView
#undef INTERFACE
#define INTERFACE IPrivateOleObject
DECLARE_INTERFACE_(IPrivateOleObject, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPrivateOleObject
    STDMETHOD( SetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
    STDMETHOD( GetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
};


STDAPI AddUrlToUrlHistoryStg(LPCWSTR pwszUrl, LPCWSTR pwszTitle, LPUNKNOWN punk, 
                             BOOL fWriteToHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory,
                             UINT* pcodepage);

#ifdef __cplusplus
//
// IUrlHistoryPriv
//
interface IUrlHistoryPriv : IUrlHistoryStg2
{
    STDMETHOD(QueryUrlA)(LPCSTR pszUrl, DWORD dwFlags, LPSTATURL lpSTATURL) = 0;
    STDMETHOD(CleanupHistory)(void) = 0;
    STDMETHOD_(DWORD,GetDaysToKeep)(void) = 0;
    STDMETHOD(GetProperty)(LPCTSTR pszUrl, PROPID pid, PROPVARIANT* pvarOut) = 0;
    STDMETHOD(GetUserName)(LPTSTR pszUserName, DWORD cchUserName) = 0;
    STDMETHOD(AddUrlAndNotifyCP)(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags, BOOL fWriteHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory, UINT* pcodepage) = 0;
};


#define URLFLAG_DONT_DELETE_SUBSCRIBED  0x10000000

extern IUrlHistoryPriv* g_puhUrlHistory;

//
// LATER: Move all ITravelLog/ITravelEntry definitions here
//
// TLOG_BACKEXTERNAL -- succeeds only if the previous entry is external
//
#define TLOG_BACKEXTERNAL   -0x7fffffff

#endif // __cplusplus

#endif // _IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iedisp.cpp ===
#include "priv.h"
#include "sccls.h"

#include "hlframe.h"
#include <iethread.h>
#include <shobjidlp.h>

#include "stdenum.h"
#include "winlist.h"
#include "iedde.h"
#include "bindcb.h"   // for CStubBindStatusCallback
#include "mshtmdid.h"
#include "resource.h"
#include "security.h"
#include "htregmng.h"
#include "mlang.h"  // for GetRfc1766FromLcid
#include "winver.h"
#include "dhuihand.h" // for GetFindDialogUp()
#include <varutil.h>

#include <mluisupp.h>

#define DM_FRAMEPROPERTY 0

#define TO_VARIANT_BOOL(b) (b?VARIANT_TRUE:VARIANT_FALSE)


// If URL contains \1 in the string then the URL is really an empty url with the
// security information following the 0x01.
#define EMPTY_URL   0x01

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#ifndef HLNF_EXTERNALNAVIGATE
#define HLNF_EXTERNALNAVIGATE 0x10000000
#endif

#define NAVFAIL_URL                 TEXT("about:NavigationFailure")
#define NAVFAIL_URL_DESKTOPITEM     TEXT("about:DesktopItemNavigationFailure")

#define CPMSG(psz)           TraceMsg(TF_SHDAUTO, "ief ConnectionPoint::%s", psz)
#define CPMSG2(psz,d)        TraceMsg(TF_SHDAUTO, "ief ConnectionPoint::%s %x", psz, d)
#define DM_CPC 0

// Are there other definitions for these? Particularly MSIE
// We need some reasonable defaults in case we can't get the user agent string from the registry.
//
#define MSIE        L"Microsoft Internet Explorer"
#define APPCODENAME L"Mozilla"
#define APPVERSION  L"4.0 (compatible; MSIE 6.0)"
#define USERAGENT   L"Mozilla/4.0 (compatible; MSIE 6.0)"
#define NO_NAME_NAME L"_No__Name:"
#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000))
#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) & 0xFFFF0000 ) == EXTENDER_DISPID_BASE )


BOOL GetNextOption(BSTR& bstrOptionString, BSTR* optionName, int* piValue);
BSTR GetNextToken(BSTR bstr, BSTR delimiters, BSTR whitespace, BSTR *nextPos);
DWORD OpenAndNavigateToURL(CIEFrameAuto*, BSTR *, const WCHAR*, ITargetNotify*, BOOL bNoHistory, BOOL bSilent );
HRESULT __cdecl DoInvokeParamHelper(IUnknown* punk, IConnectionPoint* pccp, LPBOOL pf, void **ppv, DISPID dispid, UINT cArgs, ...);
BSTR SafeSysAllocStringLen( const WCHAR *pStr, const unsigned int len );

//====================================================================================
// Define a new internal class that is used to manage a set of simple properties that
// we manage as part of the object.  This is mainly used such that pages (or objects
// that manage a page can save state across pages.
class CIEFrameAutoProp
{
public:
    HRESULT Initialize(BSTR szProperty)
    {
        UINT cch = lstrlenW(szProperty);
        if (cch < ARRAYSIZE(_sstr.wsz)) {
            StrCpyNW(_sstr.wsz, szProperty, ARRAYSIZE(_sstr.wsz));
            _sstr.cb = cch * sizeof(WCHAR);
            _szProperty = _sstr.wsz;
            return S_OK;
        }
        _szProperty = SysAllocString(szProperty);
        return _szProperty ? S_OK : E_OUTOFMEMORY;
    }

    HRESULT SetValue(VARIANT *pvtValue, IWebBrowser2* pauto);
    HRESULT CopyValue(VARIANT *pvtValue);
    BOOL IsExpired(DWORD dwCur);
    BOOL IsOurProp(BSTR szProperty) { return StrCmpW(szProperty, _szProperty) == 0;}
    CIEFrameAutoProp * Next() {return _next;}

    CIEFrameAutoProp () { VariantInit(&_vtValue); }
    ~CIEFrameAutoProp()
    {
        if (_szProperty && _szProperty != _sstr.wsz)
            SysFreeString(_szProperty);
        _VariantClear();
    }

    void _VariantClear();

    CIEFrameAutoProp *_next;
protected:
    BSTR             _szProperty;
    VARIANT          _vtValue;
    SA_BSTRGUID      _sstr;
    BOOL             _fDiscardable : 1;
    BOOL             _fOwned : 1;           // call SetSite(NULL) when discard
    DWORD            _dwLastAccessed;
} ;

#ifdef DEBUG
#define MSEC_PROPSWEEP      (1*1000)
#define MSEC_PROPEXPIRE     (5*1000)
#else
#define MSEC_PROPSWEEP      (5*1000*60)     // sweep every 5 min
#define MSEC_PROPEXPIRE     (10*1000*60)    // expire in 10 min
#endif



void CIEFrameAutoProp::_VariantClear()
{
    if (_vtValue.vt == VT_UNKNOWN && _fOwned)
    {
        _fOwned = FALSE;

        HRESULT hr = IUnknown_SetSite(_vtValue.punkVal, NULL);
        ASSERT(SUCCEEDED(hr));
    }
    VariantClearLazy(&_vtValue);
}

HRESULT CIEFrameAutoProp::SetValue(VARIANT *pvtValue, IWebBrowser2* pauto)
{
    TraceMsg(DM_FRAMEPROPERTY, "CIEFAP::SetValue called");
    _dwLastAccessed = GetCurrentTime();

    // In case we have _fOwned==TRUE.
    _VariantClear();

    if (pvtValue->vt == VT_UNKNOWN) 
    {
        // Check if this is discardable or not.
        IUnknown* punk;
        if (SUCCEEDED(pvtValue->punkVal->QueryInterface(IID_IDiscardableBrowserProperty, (void **)&punk))) 
        {
            TraceMsg(DM_FRAMEPROPERTY, "CIEFAP::SetValue adding a discardable");
            _fDiscardable = TRUE;
            punk->Release();
        }

        //
        // Check if we need to call SetSite(NULL) when we discard.
        //
        IObjectWithSite* pows;
        HRESULT hresT = pvtValue->punkVal->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
        if (SUCCEEDED(hresT)) 
        {
            IUnknown* psite;
            hresT = pows->GetSite(IID_PPV_ARG(IUnknown, &psite));
            if (SUCCEEDED(hresT) && psite) 
            {
                _fOwned = IsSameObject(psite, pauto);
                psite->Release();
            }
            pows->Release();
        }
    }

    if (pvtValue->vt & VT_BYREF)
        return VariantCopyInd(&_vtValue, pvtValue);
    else
        return VariantCopyLazy(&_vtValue, pvtValue);
}

HRESULT CIEFrameAutoProp::CopyValue(VARIANT *pvtValue)
{
    _dwLastAccessed = GetCurrentTime();
    return VariantCopyLazy(pvtValue, &_vtValue);
}

BOOL CIEFrameAutoProp::IsExpired(DWORD dwCur)
{
    BOOL fExpired = FALSE;
    if (_fDiscardable) {
        fExpired = ((dwCur - _dwLastAccessed) > MSEC_PROPEXPIRE);
    }
    return fExpired;
}

//IDispatch functions, now part of IWebBrowserApp

STDAPI SafeGetItemObject(LPSHELLVIEW psv, UINT uItem, REFIID riid, void **ppv);

HRESULT CIEFrameAuto::v_InternalQueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENT(CIEFrameAuto, IConnectionPointContainer),     // IID_ConnectionPointContainer
        QITABENT(CIEFrameAuto, IWebBrowser2),          // IID_IWebBrowser2
        QITABENT(CIEFrameAuto, IServiceProvider),      // IID_IServiceProvider
        QITABENTMULTI(CIEFrameAuto, IWebBrowserApp, IWebBrowser2), // IID_IWebBrowserApp
        QITABENT(CIEFrameAuto, IShellService),         // IID_IShellService
        QITABENT(CIEFrameAuto, IEFrameAuto),           // IID_IEFrameAuto
        QITABENT(CIEFrameAuto, IExpDispSupport),       // IID_IExpDispSupport
        QITABENT(CIEFrameAuto, IWebBrowserPriv),       // IID_IWebBrowserPriv
        QITABENT(CIEFrameAuto, ITargetFrame2),         // IID_ITargetFrame2
        QITABENT(CIEFrameAuto, IHlinkFrame),           // IID_IHlinkFrame
        QITABENT(CIEFrameAuto, IOleCommandTarget),     // IID_IOleCommandTarget
        QITABENT(CIEFrameAuto, IUrlHistoryNotify),     // IID_IUrlHistoryNotify
        QITABENTMULTI(CIEFrameAuto, IDispatch, IWebBrowser2),  // rare IID_IDispatch
        QITABENTMULTI(CIEFrameAuto, IWebBrowser, IWebBrowser2),// rare IID_IWebBrowser
        QITABENT(CIEFrameAuto, IExternalConnection),   // rare IID_IExternalConnection
        QITABENT(CIEFrameAuto, ITargetNotify),         // rare IID_ITargetNotify
        QITABENT(CIEFrameAuto, ITargetFramePriv),      // rare IID_ITargetFramePriv
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        if (IsEqualIID(riid, IID_ITargetFrame))
        {
            *ppvObj = SAFECAST(&_TargetFrame, ITargetFrame*);
            AddRef();
            return S_OK;
        }
    }

    return hres;
}

LONG CIEFrameAuto::s_cIEFrameAuto = 0;

CIEFrameAuto::CIEFrameAuto(IUnknown* punkAgg) :
             m_dwFrameMarginWidth(0xFFFFFFFF)
            ,m_dwFrameMarginHeight(0xFFFFFFFF)
            ,CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IWebBrowser2)
            ,CAggregatedUnknown(punkAgg)
{
    TraceMsg(TF_SHDLIFE, "ctor CIEFrameAuto %x", this);

    //
    // REVIEW: We don't need to DllAddRef as long as all instances
    // of CIEFrameAuto are scoped by either CShellBrowser/CExplorerBrowser
    // or CWebBrowserOC. We can remove the DllAddRef/Release, but it's not
    // a perf hit so why bother??
    //
    DllAddRef();

    InterlockedIncrement(&s_cIEFrameAuto);

    ASSERT(_cLocks==0);
    ASSERT(_pITI==NULL);
    ASSERT(_pbs==NULL);
    ASSERT(_hwnd==NULL);
    ASSERT(_pProps==NULL);
    ASSERT(_phlbc == NULL);
    ASSERT(_dwRegHLBC == 0);
    ASSERT(m_bOffline==FALSE);
    ASSERT(m_bSilent==FALSE);
    ASSERT(_hinstMSHTML==0);
    ASSERT(_pfnMEGetIDsOfNames==0);
    ASSERT(0==_pwszShortcutPath);

    TraceMsg(TF_SHDLIFE, "ctor CIEFrameAuto(%x) being constructed", this);

    m_cpWebBrowserEvents.SetOwner(_GetInner(), &DIID_DWebBrowserEvents);
    m_cpWebBrowserEvents2.SetOwner(_GetInner(), &DIID_DWebBrowserEvents2);
    m_cpPropNotify.SetOwner(_GetInner(), &IID_IPropertyNotifySink);

    HRESULT hr = _omwin.Init( );
    ASSERT( SUCCEEDED(hr) );

    hr = _omloc.Init( );
    ASSERT( SUCCEEDED(hr) );

    hr = _omnav.Init(&_mimeTypes, &_plugins, &_profile);
    ASSERT( SUCCEEDED(hr) );

    hr = _omhist.Init( );
    ASSERT( SUCCEEDED(hr) );

    hr = _mimeTypes.Init( );
    ASSERT( SUCCEEDED(hr) );

    hr = _plugins.Init( );
    ASSERT( SUCCEEDED(hr) );

    hr = _profile.Init( );
    ASSERT( SUCCEEDED(hr) );
}

HRESULT CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk)
{
    CIEFrameAuto * pauto = new CIEFrameAuto(pUnkOuter);
    if (pauto) {
        *ppunk = pauto->_GetInner();
        return S_OK;
    }

    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

STDAPI_(void) DestroyHdpaHooks();     // implemented in url.cpp

CIEFrameAuto::~CIEFrameAuto()
{
    ASSERT(!_psp);

    // We're done with MSHTML's MatchExactGetIDsOfNames
    if (_hinstMSHTML)
    {
        FreeLibrary(_hinstMSHTML);
    }

    // Clear any pending or active navigation contexts
    _SetPendingNavigateContext(NULL, NULL);
    _ActivatePendingNavigateContext();

    // Close the browse context and release it.
    if (_phlbc)
    {
        IHlinkBrowseContext * phlbc = _phlbc;
        phlbc->AddRef();
        SetBrowseContext(NULL);
        phlbc->Close(0);
        phlbc->Release();
    }

    SetOwner(NULL);

    if (m_pszFrameName)
    {
        LocalFree( m_pszFrameName);
        m_pszFrameName = NULL;
    }
    if (m_pszFrameSrc)
    {
        LocalFree( m_pszFrameSrc);
        m_pszFrameSrc = NULL;
    }

    if (_pITI)
        _pITI->Release();

    if (_pbs)
        _pbs->Release();

    if(_pwszShortcutPath)
    {
        LocalFree(_pwszShortcutPath);
        _pwszShortcutPath = NULL;
    }

    if(_pwszShortcutPathPending)
    {
        LocalFree(_pwszShortcutPathPending);
        _pwszShortcutPathPending = NULL;
    }

    // Paranoia
    _ClearPropertyList();

    InterlockedDecrement(&s_cIEFrameAuto);
    ASSERT(s_cIEFrameAuto >= 0);
    if (s_cIEFrameAuto == 0)
    {
        //
        // we were releasing these guys
        // in DllRelease, but to avoid mem
        // leaks we need to be more aggressive
        // about deleting them.
        //

        DestroyHdpaHooks();
    }

    DllRelease();

    TraceMsg(TF_SHDLIFE, "dtor CIEFrameAuto %x", this);
}

/* IWebBrowserApp methods */

// Display name of the application
HRESULT CIEFrameAuto::get_Name(BSTR * pbstrName)
{
    *pbstrName = LoadBSTR(IDS_NAME);
    return *pbstrName ? S_OK : E_OUTOFMEMORY;
}

HRESULT CIEFrameAuto::get_HWND(LONG_PTR *pHWND)
{
    *pHWND = HandleToLong(_GetHWND());
    return *pHWND ? S_OK : E_FAIL;
}

// Fule filespec of executable, but sample I've seen doesn't give extension
HRESULT CIEFrameAuto::get_FullName(BSTR * pbstrFullName)
{
    // HACK: This is also the way to tell it to update the pidl in the window list.
    if(_pbs)    //Make sure we have a IBrowserService.
        _pbs->UpdateWindowList();

    TCHAR szPath[MAX_PATH];
    if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)) > 0)
    {
        *pbstrFullName = SysAllocStringT(szPath);
        return *pbstrFullName ? S_OK : E_OUTOFMEMORY;
    }
    *pbstrFullName = NULL;
    return E_FAIL;
}

// Path to the executable
STDMETHODIMP CIEFrameAuto::get_Path(BSTR * pbstrPath)
{
    TCHAR szPath[MAX_PATH];
    if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)) > 0)
    {
        *PathFindFileName(szPath) = TEXT('\0');
        *pbstrPath = SysAllocStringT(szPath);
        return *pbstrPath ? S_OK : E_OUTOFMEMORY;
    }
    *pbstrPath = NULL;
    return E_FAIL;
}

HRESULT CIEFrameAuto::get_Application(IDispatch  **ppDisp)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
}

HRESULT CIEFrameAuto::get_Parent(IDispatch  **ppDisp)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
}

HRESULT CIEFrameAuto::get_Left(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.left;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Left(long Left)
{
    RECT rc;

    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, Left, rc.top, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::get_Top(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.top;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Top(long Top)
{
    RECT rc;

    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, rc.left, Top, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::get_Width(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.right - rc.left;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Width(long Width)
{
    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);


    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, 0, 0, Width, rc.bottom-rc.top, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
    }
    return S_OK;
}

HRESULT CIEFrameAuto::get_Height(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.bottom - rc.top;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Height(long Height)
{
    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, 0, 0, rc.right-rc.left, Height, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
    }

    return S_OK;
}


HRESULT CIEFrameAuto::put_Titlebar(BOOL fValue)
{
    HWND hwnd;
    HRESULT hres = get_HWND((LONG_PTR*)&hwnd);
    if (SUCCEEDED(hres))
    {
        DWORD dwVal = GetWindowLong(hwnd, GWL_STYLE);
        if (fValue)
            dwVal |= WS_CAPTION;
        else
            dwVal &= ~WS_CAPTION;

        if (SetWindowLong(hwnd, GWL_STYLE, dwVal))
        {
            // We need to do a SetWindowPos in order for the style changes to take effect
            SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
        }
        else
            hres = E_FAIL;
    }
    return hres;
}

HRESULT CIEFrameAuto::get_Visible( VARIANT_BOOL * pBool)
{
    HWND hwnd = _GetHWND();
    *pBool = hwnd ? TO_VARIANT_BOOL(IsWindowVisible(hwnd)) : VARIANT_FALSE;

    return S_OK;
}

HRESULT CIEFrameAuto::put_Visible(VARIANT_BOOL Value)
{
    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        ::ShowWindow(hwnd, Value? SW_SHOW : SW_HIDE);
        if (Value)
            ::SetForegroundWindow(::GetLastActivePopup(hwnd));
        FireEvent_OnAdornment(_GetOuter(), DISPID_ONVISIBLE, Value);
    }

    return S_OK;
}


HRESULT CIEFrameAuto::get_Document(IDispatch **ppDisp)
{
    HRESULT      hres = E_FAIL;
    IShellView * psv  = NULL;

    *ppDisp = NULL;

    if (_psb)
    {
        hres = _psb->QueryActiveShellView(&psv);

        if (FAILED(hres))
        {
            CComVariant cvarUnk;

            hres = _pmsc->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGOBJECT, 0, NULL, &cvarUnk);

            if (SUCCEEDED(hres))
            {
                if ((VT_UNKNOWN == V_VT(&cvarUnk)) && V_UNKNOWN(&cvarUnk))
                {
                    hres = cvarUnk.punkVal->QueryInterface(IID_IShellView, (void**)&psv);
                }
                else
                {
                    hres = E_FAIL;
                }
            }

        }

        if (psv)
        {
            IDispatch * pDisp;

            hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, &pDisp));
            if (SUCCEEDED(hres))
            {
                // (scotrobe 01/14/2000): We need to QI for IHTMLDocument2 to support
                // bad apps (e.g., HotMetal Pro) that cast the IDispatch to IHTMLDocument2.
                // Casting like this used to work because the object returned from 
                // SafeGetItemObject() used to implement IHTMLDocument2.  Now, it delegates 
                // that implementation to another object. If the QI for IHTMLDocument2 fails, '
                // then the object is not MSHTML. In that case, we just return the
                // IDispatch that was returned from SafeGetItemObject().
                //
                IHTMLDocument2 * pDocument;

                HRESULT hr = pDisp->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDocument));

                if (SUCCEEDED(hr))
                {
                    *ppDisp = pDocument;
                    pDisp->Release();
                }
                else  // Non-html document
                {
                    *ppDisp = pDisp;  // Don't release pDisp
                }
            }

            psv->Release();
        }
    }

    return hres;
}

HRESULT CIEFrameAuto::get_Busy(VARIANT_BOOL *pBool)
{
    if (_pbs == NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::get_Busy called _pbs==NULL");
        return E_FAIL;
    }

    BNSTATE bnstate;
    HRESULT hres = _pbs->GetNavigateState(&bnstate);
    if (SUCCEEDED(hres))
    {
        *pBool = TO_VARIANT_BOOL(bnstate != BNS_NORMAL);
        hres = S_OK;
    }

    return hres;
}


// MSDN97 keeps asking for a location until it gets success, so it
// hangs if we fail.  Make sure no code paths return early from here...
//
HRESULT CIEFrameAuto::_get_Location(BSTR * pbstr, UINT uFlags)
{
    if (_pbs)
    {
        LPITEMIDLIST pidl;
        HRESULT hres = _pbs->GetPidl(&pidl);

        if (SUCCEEDED(hres))
        {
            WCHAR wszTitle[MAX_URL_STRING];

            hres = _pbs->IEGetDisplayName(pidl, wszTitle, uFlags);

            ILFree(pidl);

            if (SUCCEEDED(hres))
            {
                //
                // if url is a pluggable protocol, get the real url by
                // chopping of the base url
                //
                WCHAR *pchUrl = StrChrW(wszTitle, L'\1');
                if (pchUrl)
                    *pchUrl = 0;

                //
                //  if there is already an URL then we just use it
                //
                if ((uFlags & SHGDN_FORPARSING) && !PathIsURLW(wszTitle))
                {
                    int nScheme;
                    //
                    // otherwise we need to treat it as if it were new
                    // and make sure it is a parseable URL.
                    //
                    DWORD cchTitle = ARRAYSIZE(wszTitle);

                    ParseURLFromOutsideSourceW(wszTitle, wszTitle, &cchTitle, NULL);

                    // BUG FIX #12221:
                    // ParseURLFromOutsideSource() was called to turn a file path into
                    // a fully qualified FILE URL.  If the URL was of any other type
                    // (non-URL sections of the name space), then we want to NULL out the
                    // string to indicate that it's invalid.  We don't return E_FAIL because
                    // HotDog Pro appears to have problems with that as indicated by the comment
                    // below.
                    nScheme = GetUrlSchemeW(wszTitle);
                    if (URL_SCHEME_FILE != nScheme)
                        wszTitle[0] = TEXT('\0');
                }
                *pbstr = SysAllocString(wszTitle);
                return *pbstr ? S_OK : E_OUTOFMEMORY;
            }
        }
    }

    // If we're here, the TLGetPidl call failed.  This can happen if get_LocationName
    // or get_LocationURL is called before the first navigate is complete.  HotDog Pro does
    // this, and was failing with E_FAIL.  Now we'll just return an empty string with S_FALSE.
    //
    // Also MSDN97 hangs (NT5 bug 232126) if we return failure.  Guess there hosed on low
    // memory situations...
    //
    *pbstr = SysAllocString(L"");
    return *pbstr ? S_FALSE : E_OUTOFMEMORY;
}

HRESULT CIEFrameAuto::get_LocationName(BSTR * pbstrLocationName)
{
    return _get_Location(pbstrLocationName, SHGDN_NORMAL);
}

HRESULT CIEFrameAuto::get_LocationURL(BSTR * pbstrLocationURL)
{
    return _get_Location(pbstrLocationURL, SHGDN_FORPARSING);
}

HRESULT CIEFrameAuto::Quit()
{
    // try to close it down...
    _fQuitInProgress = 1;
    HWND hwnd = _GetHWND();
    if (hwnd)
        PostMessage(hwnd, WM_CLOSE, 0, 0);

    return S_OK;
}

HRESULT CIEFrameAuto::ClientToWindow(int *pcx, int *pcy)
{
    if (_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::ClientToWindow called _pbs==NULL");
        return E_FAIL;
    }

    HWND hwnd;
    RECT rc;
    BOOL b;

    rc.left = 0;
    rc.right = *pcx;
    rc.top = 0;
    rc.bottom = *pcy;

    _pbs->IsControlWindowShown(FCW_MENUBAR, &b);

    HWND hwnd2 = _GetHWND();

    if (hwnd2)
        AdjustWindowRect(&rc, GetWindowLong(hwnd2, GWL_STYLE), b);

    *pcx = rc.right-rc.left;
    *pcy = rc.bottom-rc.top;

    _pbs->IsControlWindowShown(FCW_STATUS, &b);
    if (b)
    {
        _psb->GetControlWindow(FCW_STATUS, &hwnd);
        if (hwnd)
        {
            GetWindowRect(hwnd, &rc);
            *pcy += rc.bottom-rc.top;
        }
    }

    _pbs->IsControlWindowShown(FCW_INTERNETBAR, &b);
    if (b)
    {
        _psb->GetControlWindow(FCW_INTERNETBAR, &hwnd);
        if (hwnd)
        {
            GetWindowRect(hwnd, &rc);
            *pcy += rc.bottom-rc.top;
        }
    }

    //  add in 4 pixels for 3d borders, but don't include scrollbars
    //  'cause Netscape doesn't
    *pcy += 2*GetSystemMetrics(SM_CYEDGE);
    *pcx += 2*GetSystemMetrics(SM_CXEDGE);

    return S_OK;
}

void CIEFrameAuto::_ClearPropertyList()
{
    CIEFrameAutoProp *pprop = _pProps;
    _pProps = NULL;     // cleared out early...

    CIEFrameAutoProp *ppropNext;
    while (pprop)
    {
        ppropNext = pprop->Next();
        delete pprop;
        pprop = ppropNext;
    }
}

HRESULT CIEFrameAuto::PutProperty(BSTR bstrProperty, VARIANT vtValue)
{
    if (!bstrProperty)
    {
        TraceMsg( TF_ERROR, "CIEFrameAuto::PutProperty() - bstrProperty is NULL!" );
        return E_INVALIDARG;
    }

#ifdef DEBUG
    // Check if this BSTR is a valid BSTR
    SA_BSTR* psstr = (SA_BSTR*)((LPBYTE)bstrProperty - sizeof(ULONG));
    ASSERT(psstr->cb == lstrlenW(psstr->wsz)*sizeof(WCHAR));
#endif

    HRESULT hres;
    CIEFrameAutoProp *pprop = _pProps;
    while (pprop && !pprop->IsOurProp(bstrProperty))
        pprop=pprop->Next();

    if (!pprop)
    {
        pprop = new CIEFrameAutoProp;
        if (!pprop)
            return E_OUTOFMEMORY;
        if (FAILED(hres=pprop->Initialize(bstrProperty)))
        {
            delete pprop;
            return hres;
        }
        pprop->_next = _pProps;

        _pProps = pprop;
    }

    hres = pprop->SetValue(&vtValue, this);

    // We should now tell anyone who is listening about the change...
    FireEvent_DoInvokeBstr(_GetOuter(), DISPID_PROPERTYCHANGE, bstrProperty);

    return hres;
}

HRESULT CIEFrameAuto::GetProperty(BSTR bstrProperty, VARIANT * pvtValue)
{
    if (!bstrProperty || !pvtValue)
        return E_INVALIDARG;

    VariantInit(pvtValue);

    CIEFrameAutoProp *pprop = _pProps;
    while (pprop && !pprop->IsOurProp(bstrProperty))
        pprop = pprop->Next();
    if (pprop)
    {
        return pprop->CopyValue(pvtValue);
    }

    // Did not find property return empty...
    // Not there.  Probably not worth an error...
    return S_OK;
}


extern HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::Navigate
//
//  Interface : IWebBrowser
//
//--------------------------------------------------------------------------

HRESULT CIEFrameAuto::Navigate(BSTR      URL,
                               VARIANT * Flags,
                               VARIANT * TargetFrameName,
                               VARIANT * PostData,
                               VARIANT * Headers)
{
    return _NavigateHelper(URL, Flags, TargetFrameName, PostData, Headers);
}

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::NavigateWithBindCtx
//
//  Interface : IWebBrowserPriv
//
//--------------------------------------------------------------------------

HRESULT CIEFrameAuto::NavigateWithBindCtx(VARIANT FAR * pvarUrl,
                                          VARIANT FAR * pvarFlags,
                                          VARIANT FAR * pvarTargetFrameName,
                                          VARIANT FAR * pvarPostData,
                                          VARIANT FAR * pvarHeaders,
                                          IBindCtx    * pBindCtx,
                                          BSTR          bstrLocation)
{
    return _NavigateHelper(V_BSTR(pvarUrl),
                           pvarFlags,
                           pvarTargetFrameName,
                           pvarPostData,
                           pvarHeaders,
                           pBindCtx,
                           bstrLocation);
}

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::NavigateWithBC
//
//  Interface : IWebBrowserPriv
//
//--------------------------------------------------------------------------

HRESULT
CIEFrameAuto::OnClose()
{
    // Clear any pending or active navigation contexts
    //
    _SetPendingNavigateContext(NULL, NULL);
    _ActivatePendingNavigateContext();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method : CIEFrameAuto::_NavigateHelper
//
//--------------------------------------------------------------------------

HRESULT
CIEFrameAuto::_NavigateHelper(BSTR       URL,
                              VARIANT  * Flags,
                              VARIANT  * TargetFrameName,
                              VARIANT  * PostData,
                              VARIANT  * Headers,
                              IBindCtx * pNavBindCtx, /* = NULL */
                              BSTR       bstrLocation /* = NULL */)
{
    if (NULL == _pbs)
    {
        TraceMsg(DM_WARNING, "CIEA::Navigate called _pbs==NULL");
        return E_FAIL;
    }

    if (NULL == URL)
    {
        TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto::Navigate <NULL> called");
        return(_BrowseObject(PIDL_NOTHING, 0));
    }

    // Special hack for AOL:  They send us the following "url" as a null navigate.
    // Then they immediately follow it with the url for the new window.  That second
    // navigate is failing with RPC_E_CALL_REJECTED because of our message filter.
    // We fix the new window case by special casing this URL and returning S_FALSE.
    // This url will not likely ever be seen in the real world, and if it is typed in,
    // will get normalized and canonicalized long before getting here.
    //
    if (!StrCmpIW( URL, L"x-$home$://null"))
    {
        return S_FALSE;
    }

#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
    // if we want ALL navigates to be in a separate process, then we need to
    // pick off URL navigates for CShellBrowser IShellBrowser implementations
    // when we are in the explorer process.  We can wait until IShellBrowser::BrowseObject,
    // but then we may lose TargetFrameName etc...
    //
    if (IsBrowseNewProcessAndExplorer() && !IsShellUrl(URL, TRUE))
    {
    }
#endif


    HRESULT      hres;
    LPITEMIDLIST pidl               = NULL;
    LPBINDCTX    pBindCtx           = NULL;
    DWORD        cbPostData         = 0;
    LPCWSTR      pwzHeaders         = NULL;
    DWORD        dwInFlags          = 0;
    DWORD        dwFlags            = 0;
    LPCBYTE      pPostData          = NULL;
    DWORD        grBindFlags        = 0;
    SAFEARRAY  * pPostDataArray     = NULL;
    BOOL         fOpenWithFrameName = FALSE;
    WCHAR        wszPath[MAX_URL_STRING+2];  // note stomping below if changed to dynalloc
    CStubBindStatusCallback * pStubCallback = NULL;

    // get target frame name out of variant
    LPCWSTR pwzTargetFrameName = NULL;
    LPCWSTR pwzUnprefixedTargetFrameName = NULL;

    hres = E_FAIL;
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto::Navigate %s called", URL);

    if (TargetFrameName)
    {
       if ((VT_BSTR | VT_BYREF) == TargetFrameName->vt)
           pwzTargetFrameName = *TargetFrameName->pbstrVal;
       else if (VT_BSTR == TargetFrameName->vt)
           pwzTargetFrameName = TargetFrameName->bstrVal;
    }

    // if a target name was specified, send the navigation to the appropriate target
    // NOTE: for compatibility we can't change the meaning of target here
    // thus we don't attempt to find alias
    if ((pwzTargetFrameName && pwzTargetFrameName[0]))
    {
        LPTARGETFRAME2 pOurTargetFrame = NULL;
        IUnknown *punkTargetFrame;
        IWebBrowserApp * pIWebBrowserApp;
        BOOL fHandled = FALSE;

        // see if there is an existing frame with the specified target name
        // NOTE: we used docked parameter of _self to force navigation of this
        // frame, regardless of whether it is WebBar.
#ifndef UNIX
        hres = TargetQueryService((IShellBrowser *)this, IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));
#else
        // IEUNIX : Typecasting to IWebBrowser2 instead of IShellBrowser
        //        - compiler doesn't give appropriate vtable ptr.
        hres = TargetQueryService((IWebBrowser2 *)this, IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));
#endif

        ASSERT(SUCCEEDED(hres));

        if (SUCCEEDED(hres))
        {
            // Workaround for the way Compuserve handles the NewWindow event (window.open)
            // They tell the new instance of the web browser to navigate, but they pass the target frame
            // name they received on the NewWindow event.  This confuses us because that frame name
            // has the "_[number]" prefix.
            //
            // If the first two characters are "_[", then look for the "]" and reallocate a string
            // with everthing after that bracket.
            //

            if ( StrCmpNW( pwzTargetFrameName, L"_[", 2) == 0 )
            {
                pwzUnprefixedTargetFrameName = StrChrW(pwzTargetFrameName, L']');
                if ( pwzUnprefixedTargetFrameName )
                {
                    pwzUnprefixedTargetFrameName++;
                    pwzTargetFrameName = SysAllocString( pwzUnprefixedTargetFrameName );
                    if ( !pwzTargetFrameName )
                    {
                        hres = E_OUTOFMEMORY;
                        goto exit;
                    }
                }
            }

            hres = pOurTargetFrame->FindFrame(pwzTargetFrameName,
                                              FINDFRAME_JUSTTESTEXISTENCE,
                                              &punkTargetFrame);

            if (SUCCEEDED(hres) && punkTargetFrame) 
            {
                // yes, we found a frame with that name.  QI for the automation
                // interface on that frame and call navigate on it.
                hres = punkTargetFrame->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pIWebBrowserApp));
                punkTargetFrame->Release();

                ASSERT(SUCCEEDED(hres));

                if (SUCCEEDED(hres)) 
                {
                    VARIANT var;
                    LBSTR::CString      strFrame;

                    VariantInit(&var);

                    var.vt = VT_BSTR;
                    var.bstrVal = strFrame;

                    hres = pIWebBrowserApp->Navigate( URL, Flags, &var, PostData, Headers );

                    var.bstrVal = NULL;
                    VariantClearLazy(&var);

                    pIWebBrowserApp->Release();
                    fHandled = TRUE;
                }
            }
            else if (SUCCEEDED(hres))
            {
                //no target found means we need to open a new window
                //hres = E_FAIL forces parsing of URL into pidl
                //if we have no target frame name, then
                //  BETA1 hack chrisfra 3/3/97.  in BETA 2 TargetFrame2
                //  interface must support aliasing of targets (even if NULL
                //  to support links in desktop components as per PM requirements
                if (!pwzTargetFrameName || !pwzTargetFrameName[0])
                {
                    ASSERT(_fDesktopComponent());
                    pwzTargetFrameName = L"_desktop";
                }

                dwFlags |= HLNF_OPENINNEWWINDOW;
                fOpenWithFrameName = TRUE;
                hres = E_FAIL;
            }

            pOurTargetFrame->Release();
            if (fHandled)
                goto exit;
        }
    }

    if (FAILED(hres))
    {
        hres = _PidlFromUrlEtc(CP_ACP, (LPCWSTR)URL, bstrLocation, &pidl);

        if (FAILED(hres))
            goto exit;
    }

    // to perform the navigation, we either call an internal method
    // (_pbs->NavigateToPidl) or an external interface (IHlinkFrame::Navigate),
    // depending on what data we need to pass.  NavigateToPidl is faster
    // and cheaper, but does not allow us to pass headers or post data, just
    // the URL!  So what we do is call the fast and cheap way if only the URL
    // was specified (the 90% case), and if either headers or post data were
    // specified then we call the external interface.  We have to do a bunch
    // of wrapping of parameters in IMonikers and IHlinks and whatnot only to
    // unwrap them at the other end, so we won't call this unless we need to.

    if (Headers)
    {
       if ((VT_BSTR | VT_BYREF) == Headers->vt)
       {
           pwzHeaders = *Headers->pbstrVal;
       }
       else if (VT_BSTR == Headers->vt)
       {
           pwzHeaders = Headers->bstrVal;
       }
    }

    //
    // HACK: We used to do VT_ARRAY==PostData->vt, which is bogus.
    //  It is supposed to be VT_ARRAY|VT_UI1==PostData->vt. We can't
    //  however do it for backward compatibility with AOL and CompuServe.
    //  Therefore, we do (VT_ARRAY & PostData->vt)
    //
    if (PostData && (VT_ARRAY & PostData->vt))
    {
        if (VT_BYREF & PostData->vt)
        {
            pPostDataArray = *PostData->pparray;
        }
        else
        {
            pPostDataArray = PostData->parray;
        }

        ASSERT(pPostDataArray);

        if (pPostDataArray)
        {
            // lock the array for reading, get pointer to data
            hres = SafeArrayAccessData(pPostDataArray, (void**)&pPostData);

            if (SUCCEEDED(hres)) 
            {
                long nElements = 0;
                DWORD dwElemSize;
                // get number of elements in array
                SafeArrayGetUBound(pPostDataArray,1,(long *) &nElements);
                // SafeArrayGetUBound returns zero-based max index, add one to get element count
                nElements++;
                // get bytes per element
                dwElemSize = SafeArrayGetElemsize(pPostDataArray);
                // bytes per element should be one if we created this array
                ASSERT(dwElemSize == 1);
                // calculate total byte count anyway so that we can handle
                // safe arrays other people might create with different element sizes
                cbPostData = dwElemSize * nElements;

                if (0 == cbPostData)
                    pPostData = NULL;
            }
        }
    }


    // convert from automation interface flags (nav*) to
    // hyperlinking flags (HLNF_*)
    if (Flags)
    {
        if (Flags->vt == VT_I4)
        {
            dwInFlags = Flags->lVal;
        }
        else if (Flags->vt == VT_I2)
        {
            dwInFlags = Flags->iVal;
        }

        if ((dwInFlags & navOpenInNewWindow))
        {
            dwFlags |= HLNF_OPENINNEWWINDOW;
        }

        if (dwInFlags & navNoHistory)
        {
            dwFlags |= HLNF_CREATENOHISTORY;
        }

        if (dwInFlags & navNoReadFromCache)
        {
            grBindFlags |= BINDF_RESYNCHRONIZE | BINDF_PRAGMA_NO_CACHE;
        }

        if (dwInFlags & navNoWriteToCache)
        {
            grBindFlags |= BINDF_NOWRITECACHE;
        }

        if (dwInFlags & navHyperlink)
        {
            grBindFlags |= BINDF_HYPERLINK;
        }

        if (dwInFlags & navEnforceRestricted)
        {
            grBindFlags |= BINDF_ENFORCERESTRICTED;
        }

        // Should call IsBrowserFrameOptionsPidlSet() instead.  Some URL delegate
        //         NSEs may or may not want this feature.
        if (IsURLChild(pidl, TRUE) && (dwInFlags & navAllowAutosearch))
        {
            dwFlags |= HLNF_ALLOW_AUTONAVIGATE;
        }
    }


    // if we have either headers or post data or need to open the page in a
    // new window or pass HLNF_CREATENOHISTORY, we have to do the navigation
    // the hard way (through IHlinkFrame::Navigate) -- here we have to do
    // a bunch of wrapping of parameters into COM objects that IHlinkFrame::
    // Navigate wants.
    if (pwzHeaders || pPostData || dwFlags || grBindFlags)
    {
        // Check to see if this frame is offline.
        // This is the same as doing a get_Offline

        //  rgardner Should use TO_VARIANT_BOOL
        // (dsheldon) Actually, this code seems totally broken, it should be VT_TRUE, not TRUE.
        VARIANT_BOOL vtbFrameIsOffline = m_bOffline ? TRUE : FALSE;
        VARIANT_BOOL vtbFrameIsSilent = m_bSilent ? TRUE : FALSE;

        // make a "stub" bind status callback to hold that data and pass it
        // to the URL moniker when requested
        hres = CStubBindStatusCallback_Create(pwzHeaders,pPostData,cbPostData,
                                              vtbFrameIsOffline, vtbFrameIsSilent,
                                              TRUE, grBindFlags, &pStubCallback);

        if (FAILED(hres))
            goto exit;

        // get the canonicalized name back out of the pidl.  Note this is
        // different than the URL passed in... it has been auto-protocol-ized,
        // canonicalized and generally munged in the process of creating the pidl,
        // which is what we want to use.
        hres = _pbs->IEGetDisplayName(pidl, wszPath, SHGDN_FORPARSING);
        if (FAILED(hres))
        {
            // On Win9x, IEGetDisplayName(SHGDN_FORPARSING) will return NOT_IMPLEMENTED
            // for \\servername (but not \\servername\share)
            // We need to work around this.
            DWORD ccPath = ARRAYSIZE(wszPath);
            if (SUCCEEDED(PathCreateFromUrl(URL, wszPath, &ccPath, 0))
                && *wszPath==L'\\' 
                && *(wszPath+1)==L'\\')
            {
                hres = _pbs->IEGetDisplayName(pidl, wszPath + 2, SHGDN_FORADDRESSBAR);
            }
        }

        if (FAILED(hres))
        {
            TraceMsg(DM_ERROR, "CIEFrameAuto::Navigate _pbs->IEGetDisplayName failed %x", hres);
            goto exit;
        }

        WCHAR *pwzLocation = (WCHAR *)UrlGetLocationW(wszPath);

        if (pwzLocation)
        {
            //  NOTE: we allocated a extra char, just so we could do the following
            MoveMemory(pwzLocation+1, pwzLocation, (lstrlenW(pwzLocation)+1)*sizeof(WCHAR));
            *pwzLocation++ = TEXT('\0');   // we own wszPath, so we can do this.
        }

        if (!pNavBindCtx)  // A bind ctx was not passed in.
        {
            // Create a bind context to pass to IHlinkFrame::Navigate
            //
            hres = CreateBindCtx(0, &pBindCtx);

            if (FAILED(hres))
                goto exit;
        }
        else
        {
            pBindCtx = pNavBindCtx;
            pBindCtx->AddRef();
        }

        // We have either post data or headers (or we need to open
        // in a new window) to pass in addition to URL.
        // Call IHlinkFrame::Navigate to do the navigation
        //
        hres = NavigateHack(dwFlags,
                            pBindCtx,
                            pStubCallback,
                            fOpenWithFrameName ? pwzTargetFrameName:NULL,
                            wszPath,
                            pwzLocation);
    }
    else
    {
        ASSERT(dwFlags == 0);

        if (pNavBindCtx)
        {
            _SetPendingNavigateContext(pNavBindCtx, NULL);
        }

        //
        // NOTES: We used to call _pbs->NavigatePidl (in IE3.0), now we call
        // _psb->BrowseObject, so that we ALWAYS hit that code path.
        //
        hres = _BrowseObject(pidl, SBSP_SAMEBROWSER|SBSP_ABSOLUTE);
    }

exit:

    // clean up
    if (pPostDataArray)
    {
        // done reading from array, unlock it
        SafeArrayUnaccessData(pPostDataArray);
    }

    // If pwzUnprefixedTargetFrameName is non-null, then we allocated and set our own
    //  pwzTargetFrameName.
    //
    if (pwzUnprefixedTargetFrameName && pwzTargetFrameName)
    {
        SysFreeString( (BSTR) pwzTargetFrameName );
    }

    ATOMICRELEASE(pStubCallback);
    ATOMICRELEASE(pBindCtx);

    Pidl_Set(&pidl, NULL);

    return hres;
}

//
// Parameters:
//  pvaClsid Specifies the bar to be shown/hide
//  pvaShow  Specifies whether or not we should show or hide (default is show)
//  pvaSize  Specifies the size (optional)
//  HACK: really hoaky nCmdExecOpt overloading...
//
HRESULT CIEFrameAuto::ShowBrowserBar(VARIANT * pvaClsid, VARIANT *pvaShow, VARIANT *pvaSize)
{
    // Use this convenient, marshalable method to show or hide the Address (URL) band, the tool band,
    //  or the link band.
    //
    if (pvaShow && pvaShow->vt == VT_EMPTY)
        pvaShow = NULL;

    if (pvaShow && pvaShow->vt != VT_BOOL)
        return DISP_E_TYPEMISMATCH;

    if (pvaClsid->vt == VT_I2
        && (pvaClsid->iVal == FCW_ADDRESSBAR
         || pvaClsid->iVal == FCW_TOOLBAND
         || pvaClsid->iVal == FCW_LINKSBAR ))
    {
        return IUnknown_Exec(_pbs, &CGID_Explorer, SBCMDID_SHOWCONTROL,
            MAKELONG(pvaClsid->iVal, pvaShow ? pvaShow->boolVal : 1), NULL, NULL);
    }
    else {
        return IUnknown_Exec(_pbs, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR,
            pvaShow ? pvaShow->boolVal : 1, pvaClsid, NULL);
    }
}

HRESULT CIEFrameAuto::Navigate2(VARIANT * pvURL, VARIANT * pFlags, VARIANT * pTargetFrameName, VARIANT * pPostData, VARIANT * pHeaders)
{
    HRESULT hr = E_INVALIDARG;

    if (pFlags && ((WORD)(VT_I4) == pFlags->vt) && (pFlags->lVal == navBrowserBar))
    {
        hr = IUnknown_Exec(_pbs, &CGID_ShellDocView, SHDVID_NAVIGATEBB, 0, pvURL, NULL);
    }
    else if (!pvURL)
    {
        hr = Navigate(NULL, NULL, NULL, NULL, NULL);
    }
    else
    {
        LPCWSTR pszURL = VariantToStrCast(pvURL);
        if (pszURL)
        {
            hr = Navigate((BSTR)pszURL, pFlags, pTargetFrameName, pPostData, pHeaders);
        }
        else
        {
            LPITEMIDLIST pidl = VariantToIDList(pvURL);
            if (pidl)
            {
                hr = _BrowseObject(pidl, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
                ILFree(pidl);
            }
        }
    }

    return hr;
}

HRESULT CIEFrameAuto::GoBack()
{
    HRESULT hr;
    IWebBrowser *pwb;

    if (!IsSameObject(_psb, _psbFrameTop) && _psbFrameTop)
    {
        hr = IUnknown_QueryService(_psbFrameTop, IID_ITargetFrame2, IID_PPV_ARG(IWebBrowser, &pwb));
        if (pwb)
        {
            hr = pwb->GoBack();
            pwb->Release();
        }
        else
            hr = E_FAIL;
    }
    else
        hr = _BrowseObject(NULL, SBSP_SAMEBROWSER|SBSP_NAVIGATEBACK);
    return hr;
}


HRESULT CIEFrameAuto::GoForward()
{
    HRESULT hr;
    IWebBrowser *pwb;

    if (!IsSameObject(_psb, _psbFrameTop) && _psbFrameTop)
    {
        hr = IUnknown_QueryService(_psbFrameTop, IID_ITargetFrame2, IID_PPV_ARG(IWebBrowser, &pwb));
        if (pwb)
        {
            hr = pwb->GoForward();
            pwb->Release();
        }
        else
            hr = E_FAIL;
    }
    else
        hr = _BrowseObject(NULL, SBSP_SAMEBROWSER|SBSP_NAVIGATEFORWARD);
    return hr;
}

HRESULT CIEFrameAuto::_GoStdLocation(DWORD dwWhich)
{
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto:GoHome called");

    HRESULT hres;
    LPITEMIDLIST pidl = NULL;
    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        hres = SHDGetPageLocation(hwnd, dwWhich, NULL, 0, &pidl);
        if (SUCCEEDED(hres)) {
            //
            // NOTES: We used to call _pbs->NavigatePidl (in IE3.0), now we call
            // _psb->BrowseObject, so that we ALWAYS hit that code path.
            //
            hres = _BrowseObject(pidl, SBSP_SAMEBROWSER|SBSP_ABSOLUTE);
            ILFree(pidl);
        }
    }
    else
    {
        hres = S_FALSE;
    }

    return hres;
}

HRESULT CIEFrameAuto::GoHome()
{
    return _GoStdLocation(IDP_START);
}

HRESULT CIEFrameAuto::GoSearch()
{
    return _GoStdLocation(IDP_SEARCH);
}

HRESULT CIEFrameAuto::Stop()
{
    //
    //  Calling _CancelPendingNavigation() is not enough here because
    // it does not stop the on-going navigation in the current page.
    // Exec(NULL, OLECMDID_STOP) will cancel pending navigation AND
    // stop the on-going navigation.
    //
    if (_pmsc) {
        return _pmsc->Exec(NULL, OLECMDID_STOP, 0, NULL, NULL);
    }

    return(E_UNEXPECTED);
}

HRESULT CIEFrameAuto::Refresh()
{
    VARIANT v = {0};
    v.vt = VT_I4;
    v.lVal = OLECMDIDF_REFRESH_NO_CACHE;
    return Refresh2(&v);
}

HRESULT CIEFrameAuto::Refresh2(VARIANT * Level)
{
    HRESULT hres = E_FAIL;
    IShellView *psv;

    if (_psb && SUCCEEDED(hres = _psb->QueryActiveShellView(&psv)) && psv)
    {
        hres = IUnknown_Exec(psv, NULL, OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER, Level, NULL);
#ifdef UNIX
        /* v-sriran: 12/10/97
         * On windows, when we add an item to the folder which is currently being displayed in
         * the browser (but not through the browser), we get a notification from the OS.
         * On Unix, we don't have this. Also, the IUnknown_Exec return E_NOINTERFACE when we
         * do a refresh and this is same on windows. But, on windows, it works because of the notification.
         * Actually, on windows, the newly added folder shows up even before we click the refresh button.
         */
        if (hres == E_NOINTERFACE) {
           /* We are showing the file system in the browser */
           psv->Refresh();
        }
#endif /* UNIX */
        psv->Release();
    }


    return hres;
}

STDMETHODIMP CIEFrameAuto::get_Container(IDispatch  **ppDisp)
{
    *ppDisp = NULL;
    return NOERROR;
}

STDMETHODIMP CIEFrameAuto::get_FullScreen(VARIANT_BOOL * pBool)
{
    HRESULT hres;
    BOOL bValue;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_FullScreen called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pBool;
    hres = _pbs->IsControlWindowShown((UINT)-1, &bValue);
    *pBool = TO_VARIANT_BOOL(bValue);
    return hres;
}

STDMETHODIMP CIEFrameAuto::put_FullScreen(VARIANT_BOOL Bool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_FullScreen called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    // Put the processing of this in the main Frame class
    hres = _pbs->ShowControlWindow((UINT)-1, (BOOL)Bool);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONFULLSCREEN, Bool);

    return(hres);
}

STDMETHODIMP CIEFrameAuto::get_StatusBar(VARIANT_BOOL * pBool)
{
    HRESULT hres;
    BOOL bValue;

    if ( !pBool )
        return E_INVALIDARG;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_StatusBar called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pBool;
    hres = _pbs->IsControlWindowShown(FCW_STATUS, &bValue);
    *pBool = TO_VARIANT_BOOL(bValue);
    return hres;
}

STDMETHODIMP CIEFrameAuto::put_StatusBar(VARIANT_BOOL Bool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_StatusBar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    hres = _pbs->ShowControlWindow(FCW_STATUS, (BOOL)Bool);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONSTATUSBAR, Bool);

    return(hres);
}


STDMETHODIMP CIEFrameAuto::get_StatusText(BSTR * pbstr)
{
    HRESULT hr = E_FAIL;

    *pbstr = NULL;  // clear out in case of error...

    if (_pbs)
    {
        IShellBrowser *psb;
        hr = _pbs->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr))
        {
            LRESULT ret;
            hr = psb->SendControlMsg(FCW_STATUS, SB_GETTEXTLENGTH, 0, 0, &ret);
            if (SUCCEEDED(hr))
            {
                ret++;     // #246956: We need to make 2 extra spaces for the end
                *pbstr = SysAllocStringLen(NULL, LOWORD(ret)+1); // ret doesn't include NULL in count
                if (*pbstr)
                {
                    hr = psb->SendControlMsg(FCW_STATUS, SB_GETTEXTW, 0, (LPARAM)(*pbstr), &ret);
                    if (FAILED(hr))
                    {
                        SysFreeString(*pbstr);
                        *pbstr = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            psb->Release();
        }
    }
    return hr;
}

STDMETHODIMP CIEFrameAuto::put_StatusText(BSTR bstr)
{
    if (_pbs==NULL) 
    {
        TraceMsg(DM_WARNING, "CIEA::put_StatusText called _pbs==NULL");
        return E_FAIL;
    }

    IShellBrowser *psb;
    HRESULT hres = _pbs->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hres))
    {
        hres = psb->SendControlMsg(FCW_STATUS, SB_SETTEXTW, 0, (LPARAM)bstr, NULL);
        psb->Release();
    }

    return hres;
}

STDMETHODIMP CIEFrameAuto::get_ToolBar(int * pBool)
{
    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_ToolBar called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    BOOL fShown;
    HRESULT hres;

    *pBool = 0;
    if (SUCCEEDED(hres = _pbs->IsControlWindowShown(FCW_INTERNETBAR, &fShown)) && fShown)
        *pBool = 1;

    // Don't user hres of next call as this will fail on IE3 which does not
    // have a FCW_TOOLBAR control
    else if (SUCCEEDED(_pbs->IsControlWindowShown(FCW_TOOLBAR, &fShown)) && fShown)
        *pBool = 2;

    return hres;
}

STDMETHODIMP CIEFrameAuto::put_ToolBar(int Bool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_Toolbar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    // Put the processing of this in the main Frame class
    _pbs->ShowControlWindow(FCW_TOOLBAR, (Bool == 2));

    hres = _pbs->ShowControlWindow(FCW_INTERNETBAR, ((Bool==1)||(Bool == VARIANT_TRUE)));

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONTOOLBAR, Bool);

    return(hres);
}

STDMETHODIMP CIEFrameAuto::get_MenuBar(THIS_ VARIANT_BOOL * pbool)
{
    BOOL bValue;
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_MenuBar called _pbs==NULL");
        return E_FAIL;
    }

    if (pbool==NULL)
        return E_INVALIDARG;

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pbool;
    hres = _pbs->IsControlWindowShown(FCW_MENUBAR, &bValue);
    *pbool = TO_VARIANT_BOOL(bValue);
    return hres;
}

STDMETHODIMP CIEFrameAuto::put_MenuBar(THIS_ VARIANT_BOOL mybool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_MenuBar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    hres = _pbs->ShowControlWindow(FCW_MENUBAR, (BOOL)mybool);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONMENUBAR, mybool);

    return(hres);
}


//
// IWebBrowser2
//

HRESULT CIEFrameAuto::QueryStatusWB(OLECMDID cmdID, OLECMDF * pcmdf)
{
    if (_pmsc)
    {
        OLECMD rgcmd;
        HRESULT hr;

        rgcmd.cmdID = cmdID;
        rgcmd.cmdf = *pcmdf;

        hr = _pmsc->QueryStatus(NULL, 1, &rgcmd, NULL);

        *pcmdf = (OLECMDF) rgcmd.cmdf;

        return hr;
    }
    return (E_UNEXPECTED);
}
HRESULT CIEFrameAuto::ExecWB(OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT * pvaIn, VARIANT * pvaOut)
{
    if (_pmsc)
    {
        return _pmsc->Exec(NULL, cmdID, cmdexecopt, pvaIn, pvaOut);
    }
    return (E_UNEXPECTED);
}

STDMETHODIMP CIEFrameAuto::get_Offline(THIS_ VARIANT_BOOL * pbOffline)
{
    if ( !pbOffline)
        return E_INVALIDARG;

    *pbOffline = TO_VARIANT_BOOL(m_bOffline);
    return S_OK;
}

void SendAmbientPropChange(IOleCommandTarget* pct, int prop)
{
    if (pct)
    {
        VARIANTARG VarArgIn;

        VarArgIn.vt = VT_I4;
        VarArgIn.lVal = prop;

        pct->Exec(&CGID_ShellDocView, SHDVID_AMBIENTPROPCHANGE, 0, &VarArgIn, NULL);
    }
}

STDMETHODIMP CIEFrameAuto::put_Offline(THIS_ VARIANT_BOOL bOffline)
{
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto:put_Offline called");

    if((m_bOffline && bOffline) || (!(m_bOffline || bOffline))) // The mode is not changing
        return S_OK;

    m_bOffline = bOffline ? TRUE : FALSE;

    // Let children know an ambient property may have changed
    //
    SendAmbientPropChange(_pmsc, DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);

    return S_OK;
}


STDMETHODIMP CIEFrameAuto::get_Silent(THIS_ VARIANT_BOOL * pbSilent)
{
    if (!pbSilent)
        return E_INVALIDARG;
    *pbSilent = TO_VARIANT_BOOL(m_bSilent);
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::put_Silent(THIS_ VARIANT_BOOL bSilent)
{
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto:put_Silent called");

    if((m_bSilent && bSilent) || (!(m_bSilent || bSilent))) // The mode is not changing
        return S_OK;

    m_bSilent = bSilent ? TRUE : FALSE;

    // Let children know an ambient property may have changed
    //
    SendAmbientPropChange(_pmsc, DISPID_AMBIENT_SILENT);

    return S_OK;
}


//
//  NOTE:  RegisterAsBrowser is a kind of a misnomer here - zekel 8-SEP-97
//  this is used for 3rd party apps to register the browser as being theirs,
//  and not being one of our default shell browsers to use and abuse at
//  our pleasure.  this keeps it out of the reusable winlist.  this fixes
//  the bug where our welcome.exe page gets reused on a shellexec.
//
HRESULT CIEFrameAuto::get_RegisterAsBrowser(VARIANT_BOOL * pbRegister)
{
    if (pbRegister)
    {
        *pbRegister = _fRegisterAsBrowser ? VARIANT_TRUE : VARIANT_FALSE;
        return S_OK;
    }

    return E_INVALIDARG;
}

HRESULT CIEFrameAuto::put_RegisterAsBrowser(VARIANT_BOOL bRegister)
{
    if (bRegister)
    {
        if(_pbs == NULL)    //Make sure we have a IBrowserService.
            return S_FALSE;

        _fRegisterAsBrowser = TRUE;
        _pbs->RegisterWindow(TRUE, SWC_3RDPARTY);
        return S_OK;
    }
    //
    //  we dont support a way to turn it off
    return E_FAIL;
}

HRESULT CIEFrameAuto::get_TheaterMode(VARIANT_BOOL * pbRegister)
{
    if ( !pbRegister )
        return E_INVALIDARG;

    if (_pbs) {
        DWORD dw;
        _pbs->GetFlags(&dw);

        *pbRegister = TO_VARIANT_BOOL(dw & BSF_THEATERMODE);
        return S_OK;
    }
    // rgardner poor choice of return error code - need better error
    // This error puts of "undefined error" dialog
    return E_FAIL;
}

HRESULT CIEFrameAuto::put_TheaterMode(VARIANT_BOOL bRegister)
{
    if (_pbs) {
        _pbs->SetFlags(bRegister ? BSF_THEATERMODE : 0, BSF_THEATERMODE);
        return S_OK;
    }
    return S_FALSE;
}


HRESULT CIEFrameAuto::get_RegisterAsDropTarget(VARIANT_BOOL * pbRegister)
{
    if ( !pbRegister )
        return E_INVALIDARG;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_RegisterAsDropTarget called _pbs==NULL");
        return E_FAIL;
    }

    DWORD dw;
    _pbs->GetFlags(&dw);

    *pbRegister = TO_VARIANT_BOOL(dw & BSF_REGISTERASDROPTARGET);

    return S_OK;
}
HRESULT CIEFrameAuto::put_RegisterAsDropTarget(VARIANT_BOOL bRegister)
{
    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_RegisterAsDropTarget called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(bRegister ? BSF_REGISTERASDROPTARGET : 0, BSF_REGISTERASDROPTARGET);

    return S_OK;
}

HRESULT CIEFrameAuto::get_AddressBar(VARIANT_BOOL * pValue)
{
    BOOL bValue;
    HRESULT hres;

    if ( !pValue )
        return E_INVALIDARG;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_AddressBar called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pValue;

    hres = _pbs->IsControlWindowShown(FCW_ADDRESSBAR, &bValue);

    *pValue = TO_VARIANT_BOOL(pValue);
    return hres;
}

HRESULT CIEFrameAuto::put_AddressBar(VARIANT_BOOL Value)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_AddressBar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    hres = _pbs->ShowControlWindow(FCW_ADDRESSBAR, (BOOL)Value);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONADDRESSBAR, Value);

    return(hres);
}

HRESULT CIEFrameAuto::get_Resizable(VARIANT_BOOL * pValue)
{
    HRESULT hres;
    DWORD   dw;

    if ( !pValue )
        return E_INVALIDARG;

    if (_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::get_Resizable called _pbs==NULL");
        return E_FAIL;
    }

    hres = _pbs->GetFlags(&dw);

    *pValue = TO_VARIANT_BOOL (dw & BSF_RESIZABLE);
    return hres;
}

HRESULT CIEFrameAuto::put_Resizable(VARIANT_BOOL Value)
{
    HRESULT hres;

    if (_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::put_Resizable called _pbs==NULL");
        return E_FAIL;
    }

    hres = _pbs->SetFlags( 
                Value ? (BSF_RESIZABLE | BSF_CANMAXIMIZE) : 0, 
                (BSF_RESIZABLE | BSF_CANMAXIMIZE));

    return hres ;
}


void UpdateBrowserReadyState(IUnknown * punk, DWORD dwReadyState)
{
    if (punk)
    {
        IDocNavigate *pdn;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDocNavigate, &pdn))))
        {
            pdn->OnReadyStateChange(NULL, dwReadyState);
            pdn->Release();
        }
    }
}

HRESULT CIEFrameAuto::put_DefaultReadyState(DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState)
{
    _dwDefaultReadyState = dwDefaultReadyState;

    TraceMsg(TF_SHDNAVIGATE, "CIEA(%x)::psb(%x) new default ReadyState %d", this, _psb, dwDefaultReadyState);

    if (fUpdateBrowserReadyState)
    {
        UpdateBrowserReadyState(_psb, _dwDefaultReadyState);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::OnDocumentComplete(void)
{
    TraceMsg(DM_FRAMEPROPERTY, "CIEFA::OnDocumentComplete called");
    DWORD dwCur = GetCurrentTime();
    VARIANT varEmpty = { 0 };

    if (dwCur - _dwTickPropertySweep > MSEC_PROPSWEEP) {
        TraceMsg(DM_FRAMEPROPERTY, "CIEFA::OnDocumentComplete start sweeping");
        for (CIEFrameAutoProp *pprop = _pProps; pprop; ) {
            CIEFrameAutoProp* ppropNext = pprop->Next();
            if (pprop->IsExpired(dwCur)) {
                TraceMsg(DM_FRAMEPROPERTY, "CIEFA::OnDocumentComplete deleting an expired property");
                pprop->SetValue(&varEmpty, this);
            }
            pprop=ppropNext;
        }

        _dwTickPropertySweep = dwCur;
    }
    return S_OK;
}

HRESULT CIEFrameAuto::OnWindowsListMarshalled(void)
{
    _fWindowsListMarshalled = TRUE;
    return S_OK;
}

HRESULT CIEFrameAuto::SetDocHostFlags(DWORD dwDocHostFlags)
{
    _dwDocHostInfoFlags = dwDocHostFlags;
    return S_OK;
}

HRESULT CIEFrameAuto::get_ReadyState(READYSTATE * plReadyState)
{
    READYSTATE lReadyState = (READYSTATE)_dwDefaultReadyState;

    if (_psb)
    {
        IDocNavigate* pdn;
        if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IDocNavigate, &pdn))))
        {
            pdn->get_ReadyState((LPDWORD)&lReadyState);
            pdn->Release();
        }
    }

    TraceMsg(TF_SHDNAVIGATE, "CIEA(%x)::psb(%x)->get_ReadyState returning %d", this, _psb, lReadyState);
    *plReadyState = lReadyState;
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::get_TopLevelContainer(VARIANT_BOOL * pBool)
{
    *pBool = TRUE;
    return NOERROR;
}

STDMETHODIMP CIEFrameAuto::get_Type(BSTR * pbstrType)
{
    HRESULT hres = E_FAIL;
    *pbstrType = NULL;

    IShellView *psv;

    if (_psb && SUCCEEDED(hres = _psb->QueryActiveShellView(&psv)) && psv)
    {
        IOleObject *pobj;
        hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IOleObject, &pobj));
        if (SUCCEEDED(hres))
        {
            LPOLESTR pwszUserType;
            hres = pobj->GetUserType(USERCLASSTYPE_FULL, &pwszUserType);
            if (hres == OLE_S_USEREG)
            {
                CLSID clsid;
                hres = pobj->GetUserClassID(&clsid);
                if (SUCCEEDED(hres))
                {
                    hres = OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &pwszUserType);
                }
            }
            if (SUCCEEDED(hres) && pwszUserType)
            {
                *pbstrType = SysAllocString(pwszUserType);
                if (*pbstrType == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                OleFree(pwszUserType);
            }
            pobj->Release();
        }
        psv->Release();
    }
    return hres;
}

HRESULT CIEFrameAuto::SetOwner(IUnknown* punkOwner)
{
    ATOMICRELEASE(_pbs);
    ATOMICRELEASE(_psp);
    ATOMICRELEASE(_psb);
    ATOMICRELEASE(_psbProxy);
    ATOMICRELEASE(_poctFrameTop);
    ATOMICRELEASE(_psbFrameTop);
    ATOMICRELEASE(_psbTop);
    ATOMICRELEASE(_pmsc);

    if (punkOwner)
    {
        //  Check if we're the desktop - if so, we do not act as
        //  parent frame to our children (desktop components)
        _fDesktopFrame = FALSE;

        IUnknown *punkDesktop;
        if (SUCCEEDED(punkOwner->QueryInterface(SID_SShellDesktop, (void **)&punkDesktop)))
        {
            _fDesktopFrame = TRUE;
            punkDesktop->Release();
        }

        punkOwner->QueryInterface(IID_PPV_ARG(IBrowserService, &_pbs));
        punkOwner->QueryInterface(IID_PPV_ARG(IShellBrowser, &_psb));

        UpdateBrowserReadyState(_psb, _dwDefaultReadyState);

        HRESULT hresT = punkOwner->QueryInterface(IID_PPV_ARG(IServiceProvider, &_psp));
        if (SUCCEEDED(hresT))
        {
            _psp->QueryService(SID_SShellBrowser,    IID_PPV_ARG(IOleCommandTarget, &_pmsc));
            _psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &_psbTop));
            _psp->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IShellBrowser, &_psbFrameTop));

            // this is the browser we should tell to navigate if we're asked to navigate
            _psp->QueryService(SID_SProxyBrowser, IID_PPV_ARG(IShellBrowser, &_psbProxy));
            if (!_psbProxy)
            {
                _psbProxy = _psb;
                _psbProxy->AddRef();
            }
            //  we use _poctFrameTop::Exec to set history selection pidl
            if (_psbFrameTop && _psbProxy == _psb)
            {
                _psbFrameTop->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_poctFrameTop));
            }

            // We should always have one of these -- used to notify of frame closing
            // and new window navigation.
            ASSERT(_psbTop);
            ASSERT(_psbFrameTop);

            // Since the desktop does not support IOleCommandTarget (intentionally)
            // _pmsc could be NULL. No need to RIP here.
            //
            // ASSERT(_pmsc);
        }

        ASSERT(_pbs);
        ASSERT(_psp);
        ASSERT(_psb);
    }
    else
    {
        _omwin.DeInit( );
        //
        // We need to clear the property list here (than in the destructor)
        // to break the circular ref-count.
        //
        _ClearPropertyList();
    }

    return S_OK;
}

HRESULT CIEFrameAuto::SetOwnerHwnd(HWND hwndOwner)
{
    _hwnd = hwndOwner;
    return S_OK;
}
HWND CIEFrameAuto::_GetHWND()
{
    if (!_hwnd && _pbs)
    {
        IOleWindow * pow;
        if (SUCCEEDED(_pbs->QueryInterface(IID_PPV_ARG(IOleWindow, &pow))))
        {
            pow->GetWindow(&_hwnd);
            pow->Release();
        }
    }

    // people that call this assume that we always succeed
    //
    // ... people who call this better quit making incorrect
    // assumptions.  If we can't guarantee an hwnd the caller
    // can't assume they'll be getting one. (edwardp)
    if (_hwnd == NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::_GetHWND returning NULL");
    }

    return _hwnd;
}


// *** IConnectionPointContainer ***

CConnectionPoint* CIEFrameAuto::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    CConnectionPoint* pccp;

    // VB team claims its safe to fire new dispids to old event sinks.
    // This will cause a fault on an old event sink if they assumed
    // only the dispids in the old typelib would ever be fired and they
    // did no bounds checking and jumped into space. Let's trust the VB
    // team and see if we discover any poor event sinks.
    //
    // They also say we sould just extend our primary dispinterface instead
    // of replace it with an equivalent but different one. That approach
    // unfortunately leaves the offending bad event mechanism sit in
    // the VB programmer's face.
    //
    // I want to do three things:
    //   1. Change the primary dispinterface to see what headaches that causes.
    //      This has nice positives and its easy to change back later. (fdisp==TRUE case)
    //   2. Don't fire old events to consumers of the new dispinterface.
    //      This will flush out any compatability issues of containers
    //      connecting to the default dispinterface when they really
    //      wanted the old DIID.
    //   3. Do fire new events to old sinks. This will flush out any
    //      compatability issues with VBs theory.
    //
    // We can't do all three, so let's choose 1 and 2. We can
    // force 3 by randomly firing out-of-range dispids if this
    // is important...
    //
    if (IsEqualIID(iid, DIID_DWebBrowserEvents2) ||
        (fdisp && IsEqualIID(iid, IID_IDispatch)))
    {
        pccp = &m_cpWebBrowserEvents2;
    }
    else if (IsEqualIID(iid, DIID_DWebBrowserEvents))
    {
        pccp = &m_cpWebBrowserEvents;
    }
    else if (IsEqualIID(iid, IID_IPropertyNotifySink))
    {
        pccp = &m_cpPropNotify;
    }
    else
    {
        pccp = NULL;
    }

    return pccp;
}

STDMETHODIMP CIEFrameAuto::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 3,
                m_cpWebBrowserEvents2.CastToIConnectionPoint(),
                m_cpWebBrowserEvents.CastToIConnectionPoint(),
                m_cpPropNotify.CastToIConnectionPoint());
}


//=============================================================================
// Our class factory
class CIEFrameClassFactory : public IClassFactory
{
public:
    CIEFrameClassFactory(IUnknown* punkAuto, REFCLSID clsid, UINT uFlags);

    // IUnKnown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(
            IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

    // Helper functions...
    HRESULT CleanUpAutomationObject();
    void Revoke(void);

protected:
    ~CIEFrameClassFactory();

    LONG        _cRef;
    IUnknown   *_punkAuto;      // Only for the first one for the process
    DWORD       _dwRegister;    // The value returned from CoRegisterClassObject;
    UINT        _uFlags;        // extra COF_ bits to pass to our create browser window code
};


#define AssertParking() ASSERT(g_tidParking==0 || g_tidParking == GetCurrentThreadId())

#ifdef NO_MARSHALLING
EXTERN_C void IEFrameNewWindowSameThread(IETHREADPARAM* piei);
#endif

CIEFrameClassFactory::CIEFrameClassFactory(IUnknown* punkAuto, REFCLSID clsid, UINT uFlags)
        : _cRef(1), _dwRegister((DWORD)-1), _uFlags(uFlags)
{
    AssertParking();

    if (punkAuto)
    {
        _punkAuto = punkAuto;
        punkAuto->AddRef();
    }

    HRESULT hres = CoRegisterClassObject(clsid, this, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
        REGCLS_MULTIPLEUSE, &_dwRegister);
    if (FAILED(hres))
    {
        _dwRegister = (DWORD)-1;
    }

    TraceMsg(TF_SHDLIFE, "ctor CIEFrameClassFactory %x", this);
}

CIEFrameClassFactory::~CIEFrameClassFactory()
{
    AssertParking();
    ASSERT(_dwRegister == (DWORD)-1);
    if (_punkAuto)
        _punkAuto->Release();

    TraceMsg(TF_SHDLIFE, "dtor CIEFrameClassFactory %x", this);
}

void CIEFrameClassFactory::Revoke(void)
{
    if (_dwRegister != (DWORD)-1)
    {
        CoRevokeClassObject(_dwRegister);
        _dwRegister = (DWORD)-1;
    }
}

HRESULT CIEFrameClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CIEFrameClassFactory, IClassFactory), // IID_IClassFactory
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CIEFrameClassFactory::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CIEFrameClassFactory::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

//
//  We call this function to clean up the automation object if something
// goes wrong and OLE did not pick it up. Under a normal circumstance,
// _punkAuto is supposed to be NULL.
//
HRESULT CIEFrameClassFactory::CleanUpAutomationObject()
{
    AssertParking();

    ASSERT(_punkAuto==NULL);

    ATOMICRELEASE(_punkAuto);

    return S_OK;
}

class IETHREADHANDSHAKE : public IEFreeThreadedHandShake
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, void ** ppvObj) { *ppvObj = NULL; return E_NOTIMPL; } // HACK: we're not a real com object
    STDMETHODIMP_(ULONG) AddRef(THIS);
    STDMETHODIMP_(ULONG) Release(THIS);

    // *** IIEFreeThreadedHandShake methods ***
    STDMETHODIMP_(void)   PutHevent(THIS_ HANDLE hevent) { _hevent = hevent; }
    STDMETHODIMP_(HANDLE) GetHevent(THIS) { return _hevent; }
    STDMETHODIMP_(void)    PutHresult(THIS_ HRESULT hres) { _hres = hres; }
    STDMETHODIMP_(HRESULT) GetHresult(THIS) { return _hres; }
    STDMETHODIMP_(IStream*) GetStream(THIS) { return _pstm; }

protected:
    LONG    _cRef;       // ref-count (must be thread safe)
    HANDLE  _hevent;
    IStream* _pstm;
    HRESULT _hres;       // result from CoMarshalInterface

    friend IEFreeThreadedHandShake* CreateIETHREADHANDSHAKE();

    IETHREADHANDSHAKE(HANDLE heventIn, IStream* pstmIn);
    ~IETHREADHANDSHAKE();
};

IETHREADHANDSHAKE::IETHREADHANDSHAKE(HANDLE heventIn, IStream* pstmIn)
    : _cRef(1), _hevent(heventIn), _pstm(pstmIn), _hres(E_FAIL)
{
    TraceMsg(TF_SHDLIFE, "ctor IETHREADHANDSHAKE %x", this);
    ASSERT(_hevent);
    ASSERT(_pstm);
    _pstm->AddRef();
}

IETHREADHANDSHAKE::~IETHREADHANDSHAKE()
{
    TraceMsg(TF_SHDLIFE, "dtor IETHREADHANDSHAKE %x", this);
    CloseHandle(_hevent);
    _pstm->Release();
}

ULONG IETHREADHANDSHAKE::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG IETHREADHANDSHAKE::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

IEFreeThreadedHandShake* CreateIETHREADHANDSHAKE()
{
    IEFreeThreadedHandShake* piehs = NULL;

    HANDLE hevent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hevent)
    {
        IStream* pstm;
        HRESULT hres = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
        if (SUCCEEDED(hres))
        {
            IETHREADHANDSHAKE* p = new IETHREADHANDSHAKE(hevent, pstm);
            if (p)
            {
                // this is free threaded, so we can't know which thread will free it.
                // technically our caller should do this, but we return an
                // interface and not the class itself...
                piehs = SAFECAST(p, IEFreeThreadedHandShake*);
            }
            
            pstm->Release();
        }

        if (!piehs)
            CloseHandle(hevent);
    }

    return piehs;
}

HRESULT CIEFrameClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    HRESULT hres = E_FAIL;

    //
    // Check if this is the very first automation request.
    //
    if (_punkAuto && g_tidParking == GetCurrentThreadId())
    {
        //
        // Yes, return the first browser object.
        //
        hres = _punkAuto->QueryInterface(riid, ppvObject);

        // We don't want to return it twice.
        ATOMICRELEASE(_punkAuto);
    }
    else
    {
#ifndef NO_MARSHALLING
        //
        // No, create a new browser window in a new thread and
        // return a marshalled pointer.
        //
        hres = E_OUTOFMEMORY;
        IEFreeThreadedHandShake* piehs = CreateIETHREADHANDSHAKE();
        if (piehs)
        {
            IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, SW_SHOWNORMAL, NULL, piehs);
            if (piei)
            {
                piei->uFlags |= (_uFlags | COF_CREATENEWWINDOW | COF_NOFINDWINDOW | COF_INPROC);

                DWORD idThread;
                HANDLE hthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SHOpenFolderWindow, piei, 0, &idThread);
                if (hthread)
                {
                    // Wait until either
                    //  (1) the thread is terminated
                    //  (2) the event is signaled (by the new thread)
                    //  (3) time-out
                    //
                    //  Note that we call MsgWaitForMultipleObjects
                    // to avoid dead lock in case the other thread
                    // sends a broadcast message to us (unlikely, but
                    // theoreticallly possible).
                    //
                    HANDLE ah[] = { piehs->GetHevent(), hthread };
                    DWORD dwStart = GetTickCount();
#define MSEC_MAXWAIT (30 * 1000)
                    DWORD dwWait = MSEC_MAXWAIT;
                    DWORD dwWaitResult;

                    do {
                        dwWaitResult = MsgWaitForMultipleObjects(ARRAYSIZE(ah), ah, FALSE,
                                dwWait, QS_SENDMESSAGE);
                        if (dwWaitResult == WAIT_OBJECT_0 + ARRAYSIZE(ah)) // msg input
                        {
                            // allow pending SendMessage() to go through
                            MSG msg;
                            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
                        }
                        else
                            break;  // signaled or timed out, exit the loop

                        // Update the dwWait. It will become larger
                        // than MSEC_MAXWAIT if we wait more than that.
                        dwWait = dwStart + MSEC_MAXWAIT - GetTickCount();

                    } while (dwWait <= MSEC_MAXWAIT);

                    switch (dwWaitResult)
                    {
                    default:
                        ASSERT(0);
                    case WAIT_OBJECT_0 + 1:
                        TraceMsg(DM_ERROR, "CIECF::CI thread terminated before signaling us"); // probably leak the IETHREADPARAM and IETHREADHANDSHAKE in this case
                        hres = E_FAIL;
                        break;

                    case WAIT_OBJECT_0 + ARRAYSIZE(ah): // msg input
                    case WAIT_TIMEOUT:
                        TraceMsg(DM_ERROR, "CIECF::CI time out");
                        hres = E_FAIL;
                        break;

                    case WAIT_OBJECT_0: // hevent signaled
                        hres = piehs->GetHresult();
                        if (SUCCEEDED(hres))
                        {
                            IStream* pstm = piehs->GetStream();
                            pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
                            hres = CoUnmarshalInterface(pstm, riid, ppvObject);
                        }
                        else
                            TraceMsg(DM_ERROR, "CIECF::CI piehs->hres has an error %x", hres);
                        break;
                    }
                    CloseHandle(hthread);
                }
                else
                {
                    SHDestroyIETHREADPARAM(piei);
                    hres = E_OUTOFMEMORY;
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
                TraceMsg(DM_ERROR, "CIECF::CI new IETHREADPARAM failed");
            }
            piehs->Release();
        }
#else // !NO_MARSHALLING

        //
        // Create a new window on the same thread
        //

        IEFreeThreadedHandShake* piehs = CreateIETHREADHANDSHAKE();
        if (piehs)
        {
            IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, SW_SHOWNORMAL, NULL, piehs);
            if (piei)
                IEFrameNewWindowSameThread(piei);


            if (SUCCEEDED(piehs->GetHresult()))
            {
                IUnknown* punk;
                IStream * pstm = piehs->GetStream();

                if (pstm)
                {
                    ULONG pcbRead = 0;
                    pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
                    hres = pstm->Read( &punk, sizeof(punk), &pcbRead );
                    if (SUCCEEDED(hres))
                    {
                        hres = punk->QueryInterface(riid, ppvObject);
                        punk->Release();
                    }
                }
            }
            else
            {
                hres = piehs->GetHresult();
                TraceMsg(DM_ERROR, "CIECF::CI piehs->hres has an error %x", piehs->GetHresult());
            }
            piehs->Release();
        }
#endif // NO_MARSHALLING
    }
    return hres;
}

HRESULT CIEFrameClassFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

BOOL Is98orEarlier()
{
    BOOL bRet = FALSE;
    OSVERSIONINFOA s_osvi;

    s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
    GetVersionExA(&s_osvi);
   
    bRet = s_osvi.dwPlatformId   == VER_PLATFORM_WIN32_WINDOWS && 
           s_osvi.dwMajorVersion == 4;

    return bRet;
}   

void GetEventURL( LPCITEMIDLIST pidl, LBSTR::CString & p_rstrPath )
{
    HRESULT hres = E_FAIL;

    if (pidl)
    {
        LPTSTR      pstrPath = p_rstrPath.GetBuffer( MAX_URL_STRING );

        if ( p_rstrPath.GetAllocLength() < MAX_URL_STRING )
        {
            TraceMsg( TF_WARNING, "GetEventURL() - p_rstrPath Allocation Failed!" );

            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = IEGetDisplayName( pidl, pstrPath, SHGDN_FORPARSING );

            // Let CString class own the buffer again.
            p_rstrPath.ReleaseBuffer();
        }

        if (FAILED(hres) && Is98orEarlier())
        {
            LBSTR::CString  strTempUrl;

            LPTSTR          pstrTempUrl = strTempUrl.GetBuffer( INTERNET_MAX_URL_LENGTH );

            if ( strTempUrl.GetAllocLength() < INTERNET_MAX_URL_LENGTH )
            {
                TraceMsg( TF_WARNING, "GetEventURL() - strTempUrl Allocation Failed!" );

                hres = E_OUTOFMEMORY;
            }
            else
            {
                hres = IEGetDisplayName( pidl, pstrTempUrl, SHGDN_NORMAL );

                // Let CString class own the buffer again.
                strTempUrl.ReleaseBuffer();
            }

            if (SUCCEEDED(hres))
            {
                LPTSTR  pFoundStr = NULL;
                BOOL    bNotMachineName = FALSE;

                pFoundStr = StrChr( strTempUrl, _T(':') );

                if (pFoundStr)
                {
                    bNotMachineName = TRUE;
                }
                else if ((strTempUrl[0] == _T('\\')) ||
                         (strTempUrl[0] == _T('/')))
                {
                    bNotMachineName = TRUE;
                }   

                if (bNotMachineName)
                {
                    p_rstrPath = strTempUrl;
                }
                else
                {
                    p_rstrPath = _T("\\\\") + strTempUrl;
                }
            }
        }
    }

    if (FAILED(hres))
    {
        p_rstrPath.Empty();
    }
}


HRESULT GetWBConnectionPoints(IUnknown* punk, IConnectionPoint **ppccp1, IConnectionPoint **ppccp2);
HRESULT GetTopWBConnectionPoints(IUnknown* punk, IConnectionPoint **ppccpTop1, IConnectionPoint **ppccpTop2)
{
    HRESULT hres = E_FAIL;

    if (ppccpTop1)
        *ppccpTop1 = NULL;
    if (ppccpTop2)
        *ppccpTop2 = NULL;


    IServiceProvider *pspSB;
    if (punk && SUCCEEDED(IUnknown_QueryService(punk, SID_STopFrameBrowser, IID_PPV_ARG(IServiceProvider, &pspSB))))
    {
        IWebBrowser2 *pwb;
        if (SUCCEEDED(pspSB->QueryService(SID_SInternetExplorer, IID_PPV_ARG(IWebBrowser2, &pwb))))
        {
            // We only want the toplevel interfaces if we're a frameset
            //
            if (!IsSameObject(punk, pwb))
            {
                hres = GetWBConnectionPoints(pwb, ppccpTop1, ppccpTop2);
            }

            pwb->Release();
        }
        pspSB->Release();
    }

    return hres;
}

// Fires a NavigateComplete (DISPID_NAVIGATECOMPLETE)
// event to container if there are any advise sinks

void FireEvent_NavigateComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl, HWND hwnd)
{
    IConnectionPoint* pcp1 = NULL;
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //

    LBSTR::CString      strPath;

    GetEventURL( pidl, strPath );

    //
    // Notify IEDDE of navigate complete.
    //
    IEDDE_AfterNavigate( strPath, hwnd);

    // Fire NavigateComplete2 off the parent and top-level frames.
    // We only fire [Frame]NavigateComplete off the top-level
    // frame for backward compatibility.
    //
    GetTopWBConnectionPoints(punk, &pcp1, &pcpTopWBEvt2);

    DISPID dispid = pcp1 ? DISPID_FRAMENAVIGATECOMPLETE : DISPID_NAVIGATECOMPLETE;

    GetWBConnectionPoints(punk, pcp1 ? NULL : &pcp1, &pcpWBEvt2);

    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        VARIANT vURL = {0};
        BOOL    bSysAllocated = FALSE;

        // If IEGetDisplayName above failed, pack the PIDL in the variant
        //

        // Try to keep OLEAUT32 unloaded if possible.
        //

        V_VT(&vURL) = VT_BSTR;

        // If OLEAUT32 is already loaded
        if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
        {
            // then do the SysAllocString
            V_BSTR(&vURL) = SysAllocString( strPath );
            // What happens if this comes back NULL?
            bSysAllocated = TRUE;
        }
        else
        {
            // else use the stack version
            V_BSTR(&vURL) = strPath;
        }

        TraceMsg(TF_SHDCONTROL, "Event: NavigateComplete2[%ls]", strPath );

        // Fire the event to the parent first and then the top-level object.
        // For symmetry we fire NavigateComplete2 packed as a Variant.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_NAVIGATECOMPLETE2, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpWBEvt2);
        }

        if (pcpTopWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_NAVIGATECOMPLETE2, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpTopWBEvt2);
        }

        // Since we pass the BSTR in a VT_VARIANT|VT_BYREF, OLEAUT32 might have freed and reallocated it.
        //
        ASSERT( V_VT(&vURL) == VT_BSTR );
        if (bSysAllocated)
        {
            SysFreeString(V_BSTR(&vURL));
        }
    }

    if (pcp1)
    {
        //
        // Compuserve History manager compatability: Don't fire NavigateComplete if it's a javascript:
        // or vbscript: URL.
        //
        if (GetUrlSchemeW( strPath ) != URL_SCHEME_JAVASCRIPT &&
            GetUrlSchemeW( strPath ) != URL_SCHEME_VBSCRIPT)
        {
            // IE3 did not fire on NULL pidl
            if (pidl)
            {
                TraceMsg(TF_SHDCONTROL, "Event: NavigateComplete[%ls]", strPath );

                // call DoInvokeParam to package up parameters and call
                // IDispatch::Invoke on the container.
                //
                // This pseudo-BSTR is passed as a straight BSTR so doesn't need to be SysAllocString'ed.
                //
                DoInvokeParamHelper(punk, pcp1, NULL, NULL, dispid, 1, VT_BSTR, strPath );
            }
        }

        ATOMICRELEASE(pcp1);
    }

}

void FireEvent_DocumentComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl)
{
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // TODO: (mwatt) Investigate why we are occasionally getting bogus DocumentComplete events 
    // with null disp pointers.
    
    if (!punk)
    {
        return;
    }

    LBSTR::CString      strPath;

    GetEventURL( pidl, strPath );

    // Fire DocumentComplete off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        VARIANT vURL = {0};
        BOOL    bSysAllocated = FALSE;

        // If IEGetDisplayName above failed, pack the PIDL in the variant
        //

        // Try to keep OLEAUT32 unloaded if possible.
        //

        V_VT(&vURL) = VT_BSTR;

        // If OLEAUT32 is already loaded
        if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
        {
            // then do the SysAllocString
            V_BSTR(&vURL) = SysAllocString( strPath );
            bSysAllocated = TRUE;
        }
        else
        {
            // else use the stack version
            V_BSTR(&vURL) = strPath;
        }

        // Fire the event to the parent first and then the top-level object.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_DOCUMENTCOMPLETE, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpWBEvt2);
        }

        if (pcpTopWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_DOCUMENTCOMPLETE, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpTopWBEvt2);
        }

        // Since we pass the BSTR in a VT_VARIANT|VT_BYREF, OLEAUT32 might have freed and reallocated it.
        //
        ASSERT( V_VT(&vURL) == VT_BSTR );
        if (bSysAllocated)
        {
            SysFreeString(V_BSTR(&vURL));
        }
    }

    IEFrameAuto* pief;
    if (SUCCEEDED(pwb2->QueryInterface(IID_PPV_ARG(IEFrameAuto, &pief)))) 
    {
        pief->OnDocumentComplete();
        pief->Release();
    }
}

void AllocEventStuff(LPCTSTR pszFrameName, BSTR * pbstrFrameName,
                     LPCTSTR pszHeaders, BSTR * pbstrHeaders,
                     LPBYTE pPostData, DWORD cbPostData, VARIANTARG * pvaPostData)
{
    SAFEARRAY * psaPostData = NULL;

    // allocate BSTRs for frame name, headers
    *pbstrFrameName = NULL;
    if (pszFrameName && pszFrameName[0])
    {
        *pbstrFrameName = SysAllocStringT(pszFrameName);
    }

    *pbstrHeaders = NULL;
    if (pszHeaders && pszHeaders[0])
    {
        *pbstrHeaders = SysAllocStringT(pszHeaders);
    }

    if (pPostData && cbPostData) {
        // make a SAFEARRAY for post data
        psaPostData = MakeSafeArrayFromData(pPostData,cbPostData);
    }

    // put the post data SAFEARRAY into a variant so we can pass through automation
    VariantInit(pvaPostData);
    if (psaPostData) {
        pvaPostData->vt = VT_ARRAY | VT_UI1;
        pvaPostData->parray = psaPostData;
    }
}
void FreeEventStuff(BSTR bstrFrameName, BSTR bstrHeaders, VARIANTARG * pvaPostData)
{
    // free the things we allocated
    if (bstrFrameName)
        SysFreeString(bstrFrameName);

    if (bstrHeaders)
        SysFreeString(bstrHeaders);

    if (pvaPostData->parray)
    {
        ASSERT(pvaPostData->vt == (VT_ARRAY | VT_UI1));
        VariantClearLazy(pvaPostData);
    }
}

/*******************************************************************

    NAME:       FireEvent_BeforeNavigate

    SYNOPSIS:   Fires a BeforeNavigate (DISPID_BEFORENAVIGATE) event to container
                if there are any advise sinks

    NOTES:      If the container wants to cancel this navigation,
                it fills in pfCancel with TRUE and we should cancel.

********************************************************************/
void FireEvent_BeforeNavigate(IUnknown* punk, HWND hwnd, IWebBrowser2* pwb2,
        LPCITEMIDLIST pidl,LPCWSTR pwzLocation,
        DWORD dwFlags,LPCTSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPCTSTR pszHeaders,BOOL * pfProcessedInOut)
{
    HRESULT hres = E_FAIL;
    IConnectionPoint* pcpTopWBEvt1 = NULL;
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;
    BSTR bstrFrameName = NULL;
    BSTR bstrHeaders = NULL;
    VARIANTARG vaPostData;

    ASSERT(pfProcessedInOut);

    //
    // HACKHACK (5.5 bug#98986) for fault caused by FrontPage indexing
    //   past the end of this bool (instead of V_BOOLREF, they
    //   use V_VARIANTREF->boolVal (CIEControl::XEventSink::Invoke))
    //   and trashing our stack.
    //  This has been entered as a bug for Office10, the contact
    //  is TCrowley our PM is KamV.  (marcmill 1/04/2000)
    //
    union tagFrontPageHack {
        BOOL    fCancel;
        VARIANT varBogus;
    } CancelHack = { 0 };
    
    BOOL *pfProcessed = &CancelHack.fCancel;

    // We start with "unprocessed"
    //    
    ASSERT(*pfProcessed == FALSE);

    // Build the URL name
    //
    
    LBSTR::CString      strPath;

    GetEventURL( pidl, strPath );

    // Fire BeforeNavigate2 off the parent and top-level frames.
    // We only fire [Frame]BeforeNavigate off the top-level
    // frame for backward compatibility.
    //
    GetTopWBConnectionPoints(punk, &pcpTopWBEvt1, &pcpTopWBEvt2);

    DISPID dispid = pcpTopWBEvt1 ? DISPID_FRAMEBEFORENAVIGATE : DISPID_BEFORENAVIGATE;

    GetWBConnectionPoints(punk, pcpTopWBEvt1 ? NULL : &pcpTopWBEvt1, &pcpWBEvt2);

    // Our caller couldn't pass in the proper IExpDispSupport since
    // it may have been aggregated. We do the QI here. Only call
    // AllocEventStuff if we really are going to fire an event.
    //
    if (pcpTopWBEvt1 || pcpTopWBEvt2 || pcpWBEvt2)
    {
        AllocEventStuff(pszFrameName, &bstrFrameName, pszHeaders, &bstrHeaders, pPostData, cbPostData, &vaPostData);
    }

    // We fire BeforeNavigate2 before DDE because whoever created us may
    // redirect this navigate by cancelling and trying again. DDE will get
    // notified on the redirected Navigate. IE3 didn't do it this way,
    // so fire the BeforeNavigate event last...
    //
    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        // For symmetry we pack everything in variants
        //
        // If FAILED(hresGDN) then pack URL as PIDL, not BSTR
        //
        BOOL bSysAllocated = FALSE;

        VARIANT vURL = {0};
        V_VT(&vURL) = VT_BSTR;

        if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
        {
            // then do the SysAllocString
            V_BSTR(&vURL) = SysAllocString( strPath );
            bSysAllocated = TRUE;
        }
        else
        {
            // else use the stack version
            V_BSTR(&vURL) = strPath;
        }

        VARIANT vFlags = {0};
        V_VT(&vFlags) = VT_I4;
        V_I4(&vFlags) = dwFlags;

        VARIANT vFrameName = {0};
        V_VT(&vFrameName) = VT_BSTR;
        V_BSTR(&vFrameName) = bstrFrameName;

        VARIANT vPostData = {0};
        V_VT(&vPostData) = VT_VARIANT | VT_BYREF;
        V_VARIANTREF(&vPostData) = &vaPostData;

        VARIANT vHeaders = {0};
        V_VT(&vHeaders) = VT_BSTR;
        V_BSTR(&vHeaders) = bstrHeaders;

        TraceMsg(TF_SHDCONTROL, "Event: BeforeNavigate2[%ls]", strPath );

        // Fire the event ot the parent first and then the top-level object.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, pfProcessed, NULL, DISPID_BEFORENAVIGATE2, 7,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT | VT_BYREF, &vURL,
                                VT_VARIANT | VT_BYREF, &vFlags,
                                VT_VARIANT | VT_BYREF, &vFrameName,
                                VT_VARIANT | VT_BYREF, &vPostData,
                                VT_VARIANT | VT_BYREF, &vHeaders,
                                VT_BOOL    | VT_BYREF, pfProcessed);
        }

        // Only continue if the parent object didn't cancel.
        //
        if (pcpTopWBEvt2 && !*pfProcessed)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, pfProcessed, NULL, DISPID_BEFORENAVIGATE2, 7,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT | VT_BYREF, &vURL,
                                VT_VARIANT | VT_BYREF, &vFlags,
                                VT_VARIANT | VT_BYREF, &vFrameName,
                                VT_VARIANT | VT_BYREF, &vPostData,
                                VT_VARIANT | VT_BYREF, &vHeaders,
                                VT_BOOL    | VT_BYREF, pfProcessed);
        }

        if (bSysAllocated)
        {
            SysFreeString(V_BSTR(&vURL));
        }

        bstrFrameName = V_BSTR(&vFrameName);
        bstrHeaders = V_BSTR(&vHeaders);
    }
    if (*pfProcessed)
        goto Exit;

    //
    // NOTE: IE3 called the IEDDE hook before BeforeNavigate.
    //
    IEDDE_BeforeNavigate( strPath, pfProcessed );
    if (*pfProcessed)
        goto Exit;

    //
    // Compuserve History manager compatability: Don't fire BeforeNavigate if it's a javascript:
    // or vbscript: URL.
    //
    if (pcpTopWBEvt1
        && GetUrlSchemeW( strPath ) != URL_SCHEME_JAVASCRIPT
        && GetUrlSchemeW( strPath ) != URL_SCHEME_VBSCRIPT)
    {
        TraceMsg(TF_SHDCONTROL, "Event: BeforeNavigate[%ls]", strPath );

        // call DoInvokeParam to package up these parameters and call
        // IDispatch::Invoke on the container.
        DoInvokeParamHelper(punk, pcpTopWBEvt1, pfProcessed,NULL, dispid, 6,
                     VT_BSTR, strPath, // URL
                     VT_I4, dwFlags,       // flags
                     VT_BSTR, bstrFrameName,  // target frame name
                     VT_VARIANT | VT_BYREF, &vaPostData,  // post data
                     VT_BSTR, bstrHeaders,  // headers
                     VT_BOOL | VT_BYREF, pfProcessed); // BOOL * for indicating "processed"
    }

Exit:
    *pfProcessedInOut = *pfProcessed;  // HACK for FrontPage -- see above for details
    
    if (pcpTopWBEvt1 || pcpTopWBEvt2 || pcpWBEvt2)
    {
        FreeEventStuff(bstrFrameName, bstrHeaders, &vaPostData);

        ATOMICRELEASE(pcpTopWBEvt1);
        ATOMICRELEASE(pcpTopWBEvt2);
        ATOMICRELEASE(pcpWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_NavigateError

    SYNOPSIS:   Fires a NavigateError (DISPID_NAVIGATEERROR) event 
                to the container if there are any advise sinks

    NOTES:      If the container wants to cancel 
                autosearch and friendly error pages,
                it fills in pfCancel with TRUE and we should cancel.

********************************************************************/

void FireEvent_NavigateError(IUnknown     * punk, 
                             IWebBrowser2 * pwb2,
                             LPCITEMIDLIST  pidl,
                             BSTR           bstrTargetFrameName,
                             DWORD          dwStatusCode,
                             BOOL         * pfCancel)
       
{
    // If we find that the dwStatusCode can legally be 0,
    // we should just return from this method and not
    // fire the event. dwStatusCode == 0 implies no error.
    //
    ASSERT(dwStatusCode != 0);

    ASSERT(!IsBadReadPtr(punk, sizeof(IUnknown*)));
    ASSERT(!IsBadReadPtr(pwb2, sizeof(IWebBrowser2*)));
    ASSERT(!IsBadWritePtr(pfCancel, sizeof(BOOL)));

    BSTR bstrFrameName = NULL;

    if (bstrTargetFrameName && bstrTargetFrameName[0])
    {
        bstrFrameName = SysAllocStringT(bstrTargetFrameName);
    }

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint * pcpTopWBEvt2 = NULL;
    IConnectionPoint * pcpWBEvt2    = NULL;

    *pfCancel = FALSE;

    // Fire event off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    // Need to convert the URL to version that matches BN2

    LBSTR::CString      strPath;

    BOOL    bSysAllocated = FALSE;

    GetEventURL( pidl, strPath );

    VARIANT vTargetURL = {0};
    V_VT(&vTargetURL) = VT_BSTR;

    if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
    {
        // then do the SysAllocString
        V_BSTR(&vTargetURL) = SysAllocString( strPath );

        bSysAllocated = TRUE;
    }
    else
    {
        // else use the stack version
        V_BSTR(&vTargetURL) = strPath;
    }

    VARIANT vStatusCode = {0};
    V_VT(&vStatusCode) = VT_I4;
    V_I4(&vStatusCode) = dwStatusCode;

    VARIANT vTargetFrame  = {0};
    V_VT(&vTargetFrame)   = VT_BSTR;
    V_BSTR(&vTargetFrame) = bstrFrameName;

    // Fire the event to the parent first and then the top-level object.
    //
    if (pcpWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_NAVIGATEERROR, 5,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT | VT_BYREF, &vTargetURL,
                            VT_VARIANT | VT_BYREF, &vTargetFrame,
                            VT_VARIANT | VT_BYREF, &vStatusCode,
                            VT_BOOL | VT_BYREF, pfCancel);

        ATOMICRELEASE(pcpWBEvt2);
    }

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_NAVIGATEERROR, 5,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT | VT_BYREF, &vTargetURL,
                            VT_VARIANT | VT_BYREF, &vTargetFrame,
                            VT_VARIANT | VT_BYREF, &vStatusCode,
                            VT_BOOL | VT_BYREF, pfCancel);

        ATOMICRELEASE(pcpTopWBEvt2);
    }

    if (bSysAllocated)
    {
        SysFreeString(V_BSTR(&vTargetURL));
    }
    
    bstrFrameName = V_BSTR(&vTargetFrame);

    if (bstrFrameName)
    {
        SysFreeString(bstrFrameName);
    }
}

/*******************************************************************

    NAME:       FireEvent_PrintTemplateEvent

    SYNOPSIS:   Fires a PrintTemplateInstantiation (DISPID_PRINTTEMPLATEINSTANTIATION) or
                a PrintTemplateTeardown (DISPID_PRINTTEMPLATETEARDOWN) event to container
                if there are any advise sinks

********************************************************************/

void FireEvent_PrintTemplateEvent(IUnknown* punk, IWebBrowser2* pwb2, DISPID dispidPrintEvent) 
{
    ASSERT(!IsBadReadPtr(punk, sizeof(IUnknown*)));
    ASSERT(!IsBadReadPtr(pwb2, sizeof(IWebBrowser2*)));

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // Fire the event off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    // Fire the event to the parent first and then the top-level object.
    //
    if (pcpWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, dispidPrintEvent, 1,
                            VT_DISPATCH, pwb2);

        ATOMICRELEASE(pcpWBEvt2);
    }

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, dispidPrintEvent, 1,
                            VT_DISPATCH, pwb2);

        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_UpdatePageStatus

    SYNOPSIS:   Fires a UpdatePageStatus (DISPID_UPDATEPAGESTATUS) 
                event to container
                if there are any advise sinks

********************************************************************/

void FireEvent_UpdatePageStatus(IUnknown* punk, IWebBrowser2* pwb2, DWORD nPage, BOOL fDone)
{
    ASSERT(!IsBadReadPtr(punk, sizeof(IUnknown*)));
    ASSERT(!IsBadReadPtr(pwb2, sizeof(IWebBrowser2*)));

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // Fire the event off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    VARIANT vnPage = {0};
    V_VT(&vnPage)  = VT_I4;
    V_I4(&vnPage)  = nPage;

    VARIANT vfDone  = {0};
    V_VT(&vfDone)   = VT_BOOL;
    V_BOOL(&vfDone) = fDone;

    // Fire the event to the parent first and then the top-level object.
    //
    if (pcpWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_UPDATEPAGESTATUS, 3,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT|VT_BYREF, &vnPage,
                            VT_VARIANT|VT_BYREF, &vfDone);

        ATOMICRELEASE(pcpWBEvt2);
    }

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_UPDATEPAGESTATUS, 3,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT|VT_BYREF, &vnPage,
                            VT_VARIANT|VT_BYREF, &vfDone);

        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_PrivacyImpactedStateChange

    SYNOPSIS:   Fires the privacy PrivacyImpactedStateChange event 
                to container if there are any advise sinks

********************************************************************/

void FireEvent_PrivacyImpactedStateChange(IUnknown* punk, BOOL bPrivacyImpacted)
{
    ASSERT(!IsBadReadPtr(punk, sizeof(IUnknown*)));

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint* pcpTopWBEvt2 = NULL;

    //
    // Typically most events fire at the frame or both at frame and top level
    // Since we want to fire at the top level only we just call 
    // GetWBConnectionPoints instead of GetTopWBConnectionPoints  here
    // since we always get passed in the punk for the top level
    // GetTopWBConnectionPoints returns the event interfaces ONLY
    // in a frameset scenario anyway.
    //
    GetWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_PRIVACYIMPACTEDSTATECHANGE, 1,
                            VT_BOOL, bPrivacyImpacted);

        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_NewWindow

    SYNOPSIS:   Fires an NewWindow (DISPID_NEWWINDOW) event to container
                if there are any advise sinks

    NOTES:      If the container wants to handle new window creation itself,
                pfProcessed is filled in with TRUE on exit and we should not
                create a new window ourselves.

********************************************************************/
void FireEvent_NewWindow(IUnknown* punk, HWND hwnd,
        LPCITEMIDLIST pidl,LPWSTR pwzLocation,
        DWORD dwFlags,LPTSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPTSTR pszHeaders,BOOL * pfProcessed)
{
    ASSERT(!IsBadReadPtr(punk, sizeof(IUnknown*)));
    ASSERT(!IsBadWritePtr(pfProcessed, sizeof(BOOL)));

    LBSTR::CString      strPath;

    GetEventURL( pidl, strPath );

    *pfProcessed = FALSE;

    IEDDE_BeforeNavigate( strPath, pfProcessed );
    if (*pfProcessed)
        return;

    // We fire [Frame]NewWindow off the top frame only
    //
    // NOTE: This will break anyone watching navigations within a frameset...
    //       Do we care?
    //
    IConnectionPoint *pccp;
    DISPID dispid = 0;  // init to suppress bogus C4701 warning

    if (S_OK == GetTopWBConnectionPoints(punk, &pccp, NULL))
        dispid = DISPID_FRAMENEWWINDOW;
    else if (S_OK == GetWBConnectionPoints(punk, &pccp, NULL))
        dispid = DISPID_NEWWINDOW;
    if (pccp)
    {
        BSTR bstrFrameName, bstrHeaders;
        VARIANTARG vaPostData;

        AllocEventStuff(pszFrameName, &bstrFrameName, pszHeaders, &bstrHeaders, pPostData, cbPostData, &vaPostData);

        if (pidl != NULL)
        {
            // call DoInvokeParam to package up these parameters and call
            // IDispatch::Invoke on the container.
            DoInvokeParamHelper(punk, pccp, pfProcessed, NULL, dispid, 6,
                         VT_BSTR, strPath,      // URL
                         VT_I4, dwFlags,       // flags
                         VT_BSTR, bstrFrameName,  // target frame name
                         VT_VARIANT | VT_BYREF, &vaPostData,  // post data
                         VT_BSTR, bstrHeaders,  // headers
                         VT_BOOL | VT_BYREF, pfProcessed); // BOOL * for indicating "processed"

        }

        FreeEventStuff(bstrFrameName, bstrHeaders, &vaPostData);

        pccp->Release();
    }

    return;
}

void FireEvent_NewWindow2(IUnknown* punk, IUnknown** ppunkNewWindow, BOOL *pfCancel)
{
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    *pfCancel = FALSE;
    *ppunkNewWindow = NULL;

    // Fire NewWindow2 off the parent and top-level frames.
    // We only fire [Frame]NewWindow off the top-level
    // frame for backward compatibility.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        //
        //  The AOL browser wants to override the behavior of "Open in New Window"
        //  so it opens a new AOL window instead of a new IE window.  They do this by
        //  responding to this message by creating the AOL window and putting its
        //  IUnknown into *ppunkNewWindow.
        //  Fire the event to the parent and then the top-level window. The
        //  pfCancel and ppunkNewWindow returned by the parent override the ones
        //  returned by the top-level window.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, pfCancel, (void **)ppunkNewWindow, DISPID_NEWWINDOW2, 2,
                                VT_DISPATCH|VT_BYREF, ppunkNewWindow,
                                VT_BOOL    |VT_BYREF, pfCancel);
        }

        // If the parent object cancels or specifies a new window,
        // don't fire the event to the top-level object.
        //
        if (pcpTopWBEvt2 && !*pfCancel && !*ppunkNewWindow)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, pfCancel, (void **)ppunkNewWindow, DISPID_NEWWINDOW2, 2,
                                VT_DISPATCH|VT_BYREF, ppunkNewWindow,
                                VT_BOOL    |VT_BYREF, pfCancel);
        }

        ATOMICRELEASE(pcpWBEvt2);
        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

void FireEvent_FileDownload(IUnknown * punk, BOOL * pfCancel, VARIANT_BOOL bDocObject)
{
    IConnectionPoint * pcpWBEvt2    = NULL;
    IConnectionPoint * pcpTopWBEvt2 = NULL;

    *pfCancel = FALSE;

    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);

    if (pcpWBEvt2)
    {
        // disp params are reverse ordered, so the additional parameter is passed first
        DoInvokeParamHelper(punk, pcpWBEvt2, pfCancel, NULL, DISPID_FILEDOWNLOAD, 2,
                            VT_BOOL, bDocObject,
                            VT_BOOL | VT_BYREF, pfCancel);
    }

    if (pcpTopWBEvt2 && !*pfCancel)
    {
        // disp params are reverse ordered, so the additional parameter is passed first
        DoInvokeParamHelper(punk, pcpWBEvt2, pfCancel, NULL, DISPID_FILEDOWNLOAD, 2,
                            VT_BOOL, bDocObject,
                            VT_BOOL | VT_BYREF, pfCancel);
    }

    ATOMICRELEASE(pcpWBEvt2);
    ATOMICRELEASE(pcpTopWBEvt2);
}

void FireEvent_DoInvokeString(IExpDispSupport* peds, DISPID dispid, LPSTR psz)
{
    IConnectionPoint* pccp1, * pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        // send as generic parameter to DoInvokeParam to package up
        LBSTR::CString          strText;

        LPTSTR          pstrText = strText.GetBuffer( MAX_URL_STRING );

        if ( strText.GetAllocLength() < MAX_URL_STRING )
        {
            TraceMsg( TF_WARNING, "FireEvent_DoInvokeString() - strText Allocation Failed!" );

            strText.Empty();
        }
        else
        {
            SHAnsiToUnicode( psz, pstrText, MAX_URL_STRING );

            // Let CString class own the buffer again.
            strText.ReleaseBuffer();
        }

        if ( ! strText.IsEmpty() )
        {
            if (pccp2)
            {
                DoInvokeParamHelper( SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, dispid, 1, VT_BSTR, strText );
            }

            if (pccp1)
            {
                DoInvokeParamHelper( SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, dispid, 1, VT_BSTR, strText );
            }
        }

        if (pccp2)
        {
            pccp2->Release();
        }

        if (pccp1)
        {
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeStringW(IExpDispSupport* peds, DISPID dispid, LPWSTR psz)
{
    IConnectionPoint* pccp1, * pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        // send as generic parameter to DoInvokeParam to package up
        LBSTR::CString          strText;

        if ( psz )
        {
            strText = psz;
        }
        else
        {
            strText.Empty();
        }

        if (pccp2)
        {
            DoInvokeParamHelper( SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, dispid, 1, VT_BSTR, strText );
        }

        if (pccp1)
        {
            DoInvokeParamHelper( SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, dispid, 1, VT_BSTR, strText );
        }

        if (pccp2)
        {
            pccp2->Release();
        }

        if (pccp1)
        {
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeBstr(IUnknown* punk, DISPID dispid, BSTR bstr)
{
    IConnectionPoint* pccp1, * pccp2;

    if (S_OK == GetWBConnectionPoints(punk, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(punk, pccp2, NULL, NULL, dispid, 1, VT_BSTR, bstr);
            pccp2->Release();
        }
        if (pccp1)
        {
            DoInvokeParamHelper(punk, pccp1, NULL, NULL, dispid, 1, VT_BSTR, bstr);
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeDispid(IUnknown* punk, DISPID dispid)
{
    IConnectionPoint *pccp1, *pccp2;

    if (S_OK == GetWBConnectionPoints(punk, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(punk, pccp2, NULL, NULL, dispid, 0);
            pccp2->Release();
        }
        if (pccp1)
        {
            DoInvokeParamHelper(punk, pccp1, NULL, NULL, dispid, 0);
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeDwords(IExpDispSupport* peds, DISPID dispid, DWORD dw1,DWORD dw2)
{
    IConnectionPoint *pccp1, *pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, dispid, 2, VT_I4, dw1, VT_I4, dw2);
            pccp2->Release();
        }
        if (pccp1)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, dispid, 2, VT_I4, dw1, VT_I4, dw2);
            pccp1->Release();
        }
    }
}

void FireEvent_Quit(IExpDispSupport* peds)
{
    IConnectionPoint *pccp1, *pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, DISPID_ONQUIT, 0);
            pccp2->Release();
        }
        if (pccp1)
        {
            // IE3 fired the quit event incorrectly. It was supposed to
            // be VT_BOOL|VT_BYREF and we were supposed to honor the return
            // result and not allow the quit. It never worked that way...
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, DISPID_QUIT, 1, VT_BOOL, VARIANT_FALSE);
            pccp1->Release();
        }
    }
}

void FireEvent_OnAdornment(IUnknown* punk, DISPID dispid, VARIANT_BOOL f)
{
    VARIANTARG args[1];
    IUnknown_CPContainerInvokeParam(punk, DIID_DWebBrowserEvents2,
                                    dispid, args, 1, VT_BOOL, f);
#ifdef DEBUG
    // Verify that every IExpDispSupport also supports IConnectionPointContainer
    IConnectionPointContainer *pcpc;
    IExpDispSupport* peds;

    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpc))))
    {
        pcpc->Release();
    }
    else if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IExpDispSupport, &peds))))
    {
        peds->Release();
        AssertMsg(0, TEXT("IExpDispSupport without IConnectionPointContainer for %08x"), punk);
    }
#endif
}


HRESULT CIEFrameAuto::OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                 VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    VARIANT_BOOL vtb = FALSE;
    HRESULT hres = S_OK;

     //riid is supposed to be IID_NULL always
    if (IID_NULL != iid)
        return DISP_E_UNKNOWNINTERFACE;

    if (!(wFlags & DISPATCH_PROPERTYGET))
        return E_FAIL; // Currently we only handle Gets for Ambient Properties

    switch (dispidMember)
    {
    case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED:
        get_Offline(&vtb);
        pVarResult->vt = VT_BOOL;
        pVarResult->boolVal = vtb ? TRUE : FALSE;
        break;

    case DISPID_AMBIENT_SILENT:
        get_Silent(&vtb);
        pVarResult->vt = VT_BOOL;
        pVarResult->boolVal = vtb ? TRUE : FALSE;
        break;

    case DISPID_AMBIENT_PALETTE:
        if (_pbs)
        {
            HPALETTE hpal;
            hres = _pbs->GetPalette( &hpal );
            if (SUCCEEDED(hres))
            {
                pVarResult->vt = VT_HANDLE;
                pVarResult->intVal = PtrToLong(hpal);
            }
        }
        else
            hres = E_FAIL;
        break;

    default:
        hres = E_FAIL;
    }

    return hres;
}


// *** IExternalConnection ***

DWORD CIEFrameAuto::AddConnection(DWORD extconn, DWORD reserved)
{
    TraceMsg(TF_SHDLIFE, "shd - TR CIEFrameAuto::AddConnection(%d) called _cLock(before)=%d", extconn, _cLocks);
    if (extconn & EXTCONN_STRONG)
        return ++_cLocks;
    return 0;
}

DWORD CIEFrameAuto::ReleaseConnection(DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
    TraceMsg(TF_SHDLIFE, "shd - TR CIEFrameAuto::ReleaseConnection(%d,,%d) called _cLock(before)=%d", extconn, fLastReleaseCloses, _cLocks);
    if (!(extconn & EXTCONN_STRONG))
        return 0;

    _cLocks--;

    if (((_cLocks == 0) || (_cLocks == 1 && _fWindowsListMarshalled)) && fLastReleaseCloses)
    {
        // We could/should have the visiblity update the count of locks.
        // but this is implier for now.
        VARIANT_BOOL fVisible;
        get_Visible(&fVisible);
        if (!fVisible)
        {
            HWND hwnd = _GetHWND();
            //
            // Notice that we close it only if that's the top level browser
            // to avoid closing a hidden WebBrowserOC by mistake.
            //
            if (hwnd && _psbTop == _psb && !IsNamedWindow(hwnd, c_szShellEmbedding))
            {
                // The above test is necessary but not sufficient to determine if the item we're looking
                // at is the browser frame or the WebBrowserOC.
                TraceMsg(TF_SHDAUTO, "CIEFrameAuto::ReleaseConnection posting WM_CLOSE to %x", hwnd);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
    }
    return _cLocks;
}

HRESULT CIEFrameAuto::_BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    if (_psb)
        return _psb->BrowseObject(pidl, wFlags);
    return E_FAIL;
}

//  return interace for riid via pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGOBJECT...)
HRESULT ExecPending(IOleCommandTarget *pct, REFIID riid, void **ppvoid, VARIANT *pvarargIn)
{
    HRESULT hres = E_FAIL;
    VARIANT varOut;

    VariantInit(&varOut);
    hres = pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGOBJECT, 0, pvarargIn, &varOut);
    if (SUCCEEDED(hres))
    {
        if(varOut.vt == VT_UNKNOWN && varOut.punkVal)
        {
            hres = varOut.punkVal->QueryInterface(riid, ppvoid);

            // Avoid oleaut for this common and known case
            varOut.punkVal->Release();
            return hres;
        }
        else hres = E_FAIL;
    }
    VariantClearLazy(&varOut);
    return hres;
}

//  returns URL for pending shell view iff there is one and there is NOT an
//  active view.  result returned in VT_BSTR variant
HRESULT CIEFrameAuto::_QueryPendingUrl(VARIANT *pvarResult)
{
    HRESULT hres = E_FAIL;

    if (_psb)
    {
        IShellView *psv;

        if (SUCCEEDED(_psb->QueryActiveShellView(&psv)))
        {
            SAFERELEASE(psv);
        }
        else
        {
            IOleCommandTarget *pct;

            //  Use ExecPending to get IOleCommandTarget on pending shell view
            hres = ExecPending(_pmsc, IID_PPV_ARG(IOleCommandTarget, &pct), NULL);
            if (SUCCEEDED(hres))
            {
                // Use Exec to get URL corresponding to pending shell view
                hres = pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGURL, 0, NULL, pvarResult);
                pct->Release();
            }
        }
    }

    return hres;
}

HRESULT CIEFrameAuto::_QueryPendingDelegate(IDispatch **ppDisp, VARIANT *pvarargIn)
{
    HRESULT hres = E_FAIL;
    *ppDisp = NULL;
    if (_psb)
    {
        if (_pmsc)
        {
            IOleCommandTarget *pct;

            //  Use ExecPending to get IOleCommandTarget of pending shell view
            hres = ExecPending(_pmsc, IID_PPV_ARG(IOleCommandTarget, &pct), pvarargIn);
            if (SUCCEEDED(hres))
            {
                // Use ExecPending to get IDispatch of DocObject in pending shell view
                hres = ExecPending(pct, IID_PPV_ARG(IDispatch, ppDisp), NULL);
                pct->Release();
            }
        }
    }
    return hres;
}

//  Gets IDispath of either the DocObject of the active shell view or, if there
//  isn't an active shell view, but there is a pending shell view, ask for it's
//  DocObject.  If necessary, one will be created on the fly
HRESULT CIEFrameAuto::_QueryDelegate(IDispatch **ppDisp)
{
    HRESULT hres = E_FAIL;
    IShellView *psv;
    *ppDisp = NULL;
    if (_psb)
    {
        if (SUCCEEDED(_psb->QueryActiveShellView(&psv)) && psv)
        {
            ITargetContainer *ptgcActive;
            HRESULT hrLocal;
            LPOLESTR pwzFrameSrc;

            hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, ppDisp));

            //  Hack to support x = window.open("","FRAME");x = window.open("URL","FRAME")
            if (SUCCEEDED(hres) &&
                *ppDisp &&
                SUCCEEDED((*ppDisp)->QueryInterface(IID_PPV_ARG(ITargetContainer, &ptgcActive))))
            {
                hrLocal = ptgcActive->GetFrameUrl(&pwzFrameSrc);
                if (SUCCEEDED(hrLocal) && pwzFrameSrc)
                {
                    if (URL_SCHEME_ABOUT == GetUrlSchemeW(pwzFrameSrc))
                    {
                        IDispatch *pidPending;
                        VARIANT varIn;

                        //  Pass in bool to override safety check for no active shell view
                        VariantInit(&varIn);
                        varIn.vt = VT_BOOL;
                        varIn.boolVal = TRUE;
                        hrLocal = _QueryPendingDelegate(&pidPending, &varIn);
                        if (SUCCEEDED(hrLocal) && pidPending)
                        {
                            (*ppDisp)->Release();
                            *ppDisp = pidPending;
                        }
                        VariantClearLazy(&varIn);
                    }
                    OleFree(pwzFrameSrc);
                }
                ptgcActive->Release();
            }
            psv->Release();
        }
        else
        {
            hres = _QueryPendingDelegate(ppDisp, NULL);
        }
    }
    return hres;
}

extern HRESULT ShowHlinkFrameWindow(IUnknown *pUnkTargetHlinkFrame);

//=========================================================================
// Helper API
//=========================================================================

//
// API: HlinkFrameNavigate{NHL}
//
//  This is a helper function to be called by DocObject implementations
// which are not be able to open itself as a stand-alone app (like MSHTML).
// If their IHlinkTarget::Navigate is called when the client is not set,
// they will call this API to open a separate browser window in a separate
// process (I assume that those DocObjects are all InProc DLLs).
//
//  HLINK.DLL's IHlink implementation will hit this code path when
// a hyperlink object is activated in non-browser window (such as Office
// apps).
//
#ifdef UNIX
EXTERN_C
#endif
STDAPI HlinkFrameNavigate(DWORD grfHLNF, LPBC pbc,
                           IBindStatusCallback *pibsc,
                           IHlink* pihlNavigate,
                           IHlinkBrowseContext *pihlbc)
{
    HRESULT hres S_OK;
    IUnknown* punk = NULL;

    TraceMsg(TF_COCREATE, "HlinkFrameNavigate called");
#ifdef DEBUG
    DWORD dwTick = GetCurrentTime();
#endif

    grfHLNF &= ~HLNF_OPENINNEWWINDOW;   // Implied by CreateTargetFrame
    hres = CreateTargetFrame(NULL, &punk);

#ifdef DEBUG
    TraceMsg(TF_COCREATE, "HlinkFrameNavigate called CoCreate %x (took %d msec)",
             hres, GetCurrentTime()-dwTick);
#endif
    if (SUCCEEDED(hres))
    {
        IHlinkFrame* phfrm;

        hres = punk->QueryInterface(IID_PPV_ARG(IHlinkFrame, &phfrm));
        if (SUCCEEDED(hres))
        {
            if (pihlbc)
            {
                phfrm->SetBrowseContext(pihlbc);
                grfHLNF |= HLNF_EXTERNALNAVIGATE;
            }

            hres = phfrm->Navigate(grfHLNF, pbc, pibsc, pihlNavigate);
            if (SUCCEEDED(hres))
            {
                hres = ShowHlinkFrameWindow(punk);
            } else {
                TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(InternetExplorer) failed (%x)", hres);
            }

            TraceMsg(TF_SHDNAVIGATE, "HlinkFrameNavigate phfrm->Navigate returned (%x)", hres);
            phfrm->Release();
        } else {
            TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(IHlinkFrame) failed (%x)", hres);
        }
        punk->Release();
    } else {
        TraceMsg(DM_ERROR, "HlinkFrameNavigate CoCreateInstance failed (%x)", hres);
    }

    return hres;
}

#ifdef UNIX
EXTERN_C
#endif
STDAPI HlinkFrameNavigateNHL(DWORD grfHLNF, LPBC pbc,
                           IBindStatusCallback *pibsc,
                           LPCWSTR pszTargetFrame,
                           LPCWSTR pszUrl,
                           LPCWSTR pszLocation)
{
    HRESULT hres S_OK;
    IUnknown* punk = NULL;
#define MAX_CONTENTTYPE MAX_PATH        // This is a good size.

    TraceMsg(TF_COCREATE, "HlinkFrameNavigateNHL called");
#ifdef DEBUG
    DWORD dwTick = GetCurrentTime();
#endif

    //  This should be more general, but we're punting the FILE: case for IE 4
    //  unless the extension is .htm or .html (all that Netscape 3.0 registers for)
    //  we'll go with ShellExecute if IE is not the default browser.  NOTE:
    //  this means POST will not be supported and pszTargetFrame will be ignored
    //  we don't shellexecute FILE: url's because URL.DLL doesn't give a security
    //  warning for .exe's etc.
    if ((!IsIEDefaultBrowser()))
    {
        WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];
        CHAR  aszUrl[INTERNET_MAX_URL_LENGTH];
        int chUrl;
        HINSTANCE hinstRet;
        LPWSTR pwszExt;
        BOOL bSafeToExec = TRUE;
        DWORD dwCodePage = 0;
        if (pibsc)
        {
            DWORD dw = 0;
            BINDINFO bindinfo = { sizeof(BINDINFO) };
            HRESULT hrLocal = pibsc->GetBindInfo(&dw, &bindinfo);

            if (SUCCEEDED(hrLocal)) {
                dwCodePage = bindinfo.dwCodePage;
                ReleaseBindInfo(&bindinfo);
            }

        }
        if (!dwCodePage)
        {
            dwCodePage = CP_ACP;
        }

        chUrl = lstrlenW(pszUrl);

        pwszExt = PathFindExtensionW(pszUrl);
        if (URL_SCHEME_FILE == GetUrlSchemeW(pszUrl))
        {
            WCHAR wszContentType[MAX_CONTENTTYPE];
            DWORD dwSize = ARRAYSIZE(wszContentType);

            bSafeToExec = FALSE;
            // Get Content type.
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pwszExt, NULL, wszContentType, &dwSize)))
            {
                bSafeToExec = 0 == StrCmpIW(wszContentType, L"text/html");
            }
        }

        if (bSafeToExec)
        {
            StrCpyNW(wszUrl, pszUrl, ARRAYSIZE(wszUrl));
            //  don't attempt unless we have at least enough for '#' {any} '\0'
            //  NOTE: # is included in pszLocation
            if (pszLocation && *pszLocation && ARRAYSIZE(wszUrl) - chUrl >= 3)
            {
               StrCpyNW(&wszUrl[chUrl], pszLocation, ARRAYSIZE(wszUrl) - chUrl - 1);
            }
            //
            // UNICODE - should this get changed to wchar?
            //
            // finally we will get the string in the native codepage
            SHUnicodeToAnsiCP(dwCodePage, wszUrl, aszUrl, ARRAYSIZE(aszUrl));
            hinstRet = ShellExecuteA(NULL, NULL, aszUrl, NULL, NULL, SW_SHOWNORMAL);
            return ((UINT_PTR)hinstRet) <= 32 ? E_FAIL:S_OK;
        }
    }

    grfHLNF &= ~HLNF_OPENINNEWWINDOW;   // Implied by CreateTargetFrame
    hres = CreateTargetFrame(pszTargetFrame, &punk);

#ifdef DEBUG
    TraceMsg(TF_COCREATE, "HlinkFrameNavigateNHL called CoCreate %x (took %d msec)",
             hres, GetCurrentTime()-dwTick);
#endif
    if (SUCCEEDED(hres))
    {
        ITargetFramePriv *ptgfp;

        hres = punk->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfp));
        if (SUCCEEDED(hres))
        {
            hres = ptgfp->NavigateHack(grfHLNF, pbc, pibsc, NULL, pszUrl, pszLocation);
            if (SUCCEEDED(hres))
            {
                hres = ShowHlinkFrameWindow(punk);
            } else {
                TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(InternetExplorer) failed (%x)", hres);
            }

            TraceMsg(TF_SHDNAVIGATE, "HlinkFrameNavigate phfrm->Navigate returned (%x)", hres);
            ptgfp->Release();
        } else {
            TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(IHlinkFrame) failed (%x)", hres);
        }
        punk->Release();
    } else {
        TraceMsg(DM_ERROR, "HlinkFrameNavigate CoCreateInstance failed (%x)", hres);
    }

    return hres;
}

CIEFrameClassFactory* g_pcfactory = NULL;
CIEFrameClassFactory* g_pcfactoryShell = NULL;

//
//  This function is called when the first browser window is being created.
// punkAuto is non-NULL if and only if the browser is started as the result
// of CoCreateInstance.
//
void IEInitializeClassFactoryObject(IUnknown* punkAuto)
{
    ASSERT(g_pcfactory==NULL);
    ASSERT(g_pcfactoryShell==NULL);
    AssertParking();

    // We don't want to register this local server stuff for the shell process
    // if we are in browse in new process and this is the Explorer process.
    if (!IsBrowseNewProcessAndExplorer())
    {
        g_pcfactory = new CIEFrameClassFactory(punkAuto, CLSID_InternetExplorer, COF_IEXPLORE);
    }
    g_pcfactoryShell = new CIEFrameClassFactory(NULL, CLSID_ShellBrowserWindow, COF_SHELLFOLDERWINDOW);
}

//
//  This function is called when the primaty thread is going away.
// It revokes the class factory object and release it.
//
void IERevokeClassFactoryObject(void)
{
    AssertParking();

    if (g_pcfactory)
    {
        g_pcfactory->Revoke();
        ATOMICRELEASE(g_pcfactory);
    }
    if (g_pcfactoryShell)
    {
        g_pcfactoryShell->Revoke();
        ATOMICRELEASE(g_pcfactoryShell);
    }
}

//
//  This function is called when the first browser window is being destroyed.
// It will remove the registered automation object (via IEInitializeClass...)
// to accidentally return an automation object to closed window.
//
void IECleanUpAutomationObject()
{
    if (g_pcfactory)
        g_pcfactory->CleanUpAutomationObject();

    if (g_pcfactoryShell)
        g_pcfactoryShell->CleanUpAutomationObject();
}

void IEOnFirstBrowserCreation(IUnknown* punk)
{
    // For the desktop case, we DON'T have a g_tidParking set
    // and we don't need one, so this assert is bogus in that
    // case.  But it's probably checking something valid, so
    // I made the assert not fire in the desktop case. Unfortunately
    // this also makes it not fire in most other cases that it
    // checks, but at least it will check a few things (if automated)
    //
    ASSERT(g_tidParking == GetCurrentThreadId() || !punk);

    // If automation, now is good time to register ourself...
    if (g_fBrowserOnlyProcess)
        IEInitializeClassFactoryObject(punk);

    //
    // Tell IEDDE that automation services are now available.
    //
    IEDDE_AutomationStarted();
}

HRESULT CoCreateNewIEWindow( DWORD dwClsContext, REFIID riid, void **ppvunk )
{
    // QFE 2844 -- We don't want to create a new window as a local
    // server off of the registered class object.  Simply create
    // the window in a new thread by a direct createinstance.
    if (dwClsContext & CLSCTX_INPROC_SERVER)
    {
        HRESULT hr = REGDB_E_CLASSNOTREG;
        IClassFactory *pcf = NULL;

        *ppvunk = NULL;
        if (g_pcfactory &&
            SUCCEEDED(hr = g_pcfactory->QueryInterface( IID_IClassFactory, (LPVOID*) &pcf )) ) {
            hr = pcf->CreateInstance( NULL, riid, ppvunk );
            pcf->Release();
        }

        if ( SUCCEEDED(hr) ) {
            return hr;
        }
        else {
            // Try other contexts via CoCreateInstance since inproc failed.
            dwClsContext &= ~CLSCTX_INPROC_SERVER;

            if (!dwClsContext) {
                return hr;
            }
        }
    }
    return CoCreateInstance( CLSID_InternetExplorer, NULL,
                             dwClsContext,
                             riid, ppvunk );
}



SAFEARRAY * MakeSafeArrayFromData(LPCBYTE pData,DWORD cbData)
{
    SAFEARRAY * psa;

    if (!pData || 0 == cbData)
        return NULL;  // nothing to do

    // create a one-dimensional safe array
    psa = SafeArrayCreateVector(VT_UI1,0,cbData);
    ASSERT(psa);

    if (psa) {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is OK.

        ASSERT(psa->pvData);
        memcpy(psa->pvData,pData,cbData);
    }

    return psa;
}


/******************************************************************************
                    Helper Functions
******************************************************************************/


/******************************************************************************
 Safe version of the Win32 SysAllocStringLen() function. Allows you to
 pass in a string (pStr) that is smaller than the desired BSTR (len).
******************************************************************************/
BSTR SafeSysAllocStringLen( const WCHAR *pStr, const unsigned int len )
{
    // SysAllocStringLen allocates len + 1
    BSTR pNewStr = SysAllocStringLen( 0, len );

    if( pStr && pNewStr )
    {
        // StrCpyNW always null terminates so we need to copy len+1
        StrCpyNW( pNewStr, pStr, len + 1);
    }

    return pNewStr;
}

BSTR SysAllocStringFromANSI( const char *pStr, int size = -1 )
{
    if( !pStr )
        return 0;

    if( size < 0 )
        size = lstrlenA( pStr );

    // Allocates size + 1
    BSTR bstr = SysAllocStringLen( 0, size );
    if( bstr )
    {
        if( !MultiByteToWideChar( CP_ACP, 0, pStr, -1, bstr, size + 1 ) )
        {
            SysFreeString( bstr );
            bstr = 0;
        }
    }

    return bstr;
}


HRESULT GetDelegateOnIDispatch( IDispatch* pdisp, const DISPID delegateID, IDispatch ** const ppDelegate )
{
    HRESULT hres;

    if( !pdisp || ! ppDelegate )
        return E_POINTER;

    DISPPARAMS dispparams;
    VARIANT VarResult;
    VariantInit(&VarResult);
    ZeroMemory(&dispparams, sizeof(dispparams));

    hres = pdisp->Invoke(    delegateID,
                            IID_NULL,
                            0,
                            DISPATCH_PROPERTYGET,
                            &dispparams,
                            &VarResult,
                            NULL,
                            NULL                );

    if( SUCCEEDED(hres) )
    {
        if( VarResult.vt == VT_DISPATCH && VarResult.pdispVal )
        {
            *ppDelegate = VarResult.pdispVal;
            (*ppDelegate)->AddRef();
        }
        else
        {
            // Temporary hack (I think) until Trident always returns IDispatch
            if( VarResult.pdispVal && VarResult.vt == VT_UNKNOWN )
                hres = VarResult.pdispVal->QueryInterface( IID_IDispatch, (void**)ppDelegate );
            else
                hres = E_FAIL;
        }

        VariantClearLazy( &VarResult );
    }

    return hres;
}

HRESULT GetRootDelegate( CIEFrameAuto* pauto, IDispatch ** const ppRootDelegate )
{
    IDispatch *pdiDocObject;
    HRESULT hres;

    if( !pauto || !ppRootDelegate )
        return E_POINTER;

    //  Get the IHTMLWindow2 of docobject in our frame.  Note: if this is cached
    //  you must put glue into docobjhost to release the cache when deactivating
    //  view.
    hres = pauto->_QueryDelegate(&pdiDocObject);

    if (SUCCEEDED(hres))
    {
        hres = GetDelegateOnIDispatch( pdiDocObject, DISPID_WINDOWOBJECT, ppRootDelegate );
        pdiDocObject->Release();
    }

    return hres;
}

HRESULT GetWindowFromUnknown(IUnknown *pUnk, IHTMLWindow2 **pWinOut)
{
    return IUnknown_QueryService(pUnk, SID_SOmWindow, IID_PPV_ARG(IHTMLWindow2, pWinOut));
}


/******************************************************************************
                    Automation Stub Object
******************************************************************************/

CIEFrameAuto::CAutomationStub::CAutomationStub( DISPID minDispid, DISPID maxDispid, BOOL fOwnDefaultDispid ) :
    _MinDispid(minDispid), _MaxDispid(maxDispid), _fOwnDefaultDispid(fOwnDefaultDispid)
{
    ASSERT( !_pInterfaceTypeInfo2 );
    ASSERT( !_pCoClassTypeInfo2 );
    ASSERT( !_pAuto );
    ASSERT( !_pInstance );
    ASSERT( !_fLoaded );
}

CIEFrameAuto::CAutomationStub::~CAutomationStub( )
{
    SAFERELEASE( _pInterfaceTypeInfo2 );
    SAFERELEASE( _pCoClassTypeInfo2 );
}

HRESULT CIEFrameAuto::CAutomationStub::Init( void *instance, REFIID iid, REFIID clsid, CIEFrameAuto *pauto )
{
    if( !pauto || !instance )
        return E_POINTER;

    _iid = iid;
    _clsid = clsid;

    // Don't need to AddRef this since our lifetime is controled by CIEFrameAuto
    _pAuto = pauto;
    _pInstance = instance;

    return S_OK;
}

STDMETHODIMP CIEFrameAuto::CAutomationStub::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)   ||
       IsEqualIID(riid, IID_IDispatch)  ||
       IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppv = SAFECAST( this, IDispatchEx* );
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
        *ppv = SAFECAST( this, IProvideClassInfo* );
    }
    else
    {
        return _InternalQueryInterface( riid, ppv );
    }

    AddRef( );
    return S_OK;
}

ULONG CIEFrameAuto::CAutomationStub::AddRef(void)
{
    ASSERT( _pAuto );
    return _pAuto->AddRef();
}

ULONG CIEFrameAuto::CAutomationStub::Release(void)
{
    ASSERT( _pAuto );
    return _pAuto->Release();
}

/******************************************************************************
// bradsch 11/8/96
// I don't think typeinfo for the object implemented in the browser should
// live in MSHTML. It should be moved to shdocvw. For now so we don't have
// to worry about hard coded LIBIDs and changing versions this methods gets
// typeinfo from the delegate that lives in Trident. In cases where we have
// not delegate this method tries to load typeinfo directly from MSHTML.
******************************************************************************/
HRESULT CIEFrameAuto::CAutomationStub::ResolveTypeInfo2( )
{
    HRESULT hr;
    ASSERT( !_pInterfaceTypeInfo2 );
    ASSERT( !_pCoClassTypeInfo2 );
    ASSERT( _pAuto );

    // Only try once.
    _fLoaded = TRUE;

    // Have we computed MatchExactGetIDsOfNames yet?
    if (!IEFrameAuto()->_hinstMSHTML)
    {
        // No, so look for helper function in mshtml.dll
        IEFrameAuto()->_hinstMSHTML = LoadLibrary(TEXT("mshtml.dll"));
        if (IEFrameAuto()->_hinstMSHTML && !IEFrameAuto()->_pfnMEGetIDsOfNames)
        {
            IEFrameAuto()->_pfnMEGetIDsOfNames =
                (PFN_MatchExactGetIDsOfNames)GetProcAddress(IEFrameAuto()->_hinstMSHTML, "MatchExactGetIDsOfNames");
        }
    }

    ITypeLib *pTypeLib = 0;
    IDispatch *pDisp = 0;

    hr = GetRootDelegate( _pAuto, &pDisp );

    if( SUCCEEDED(hr) )
    {
        UINT supported;
        hr = pDisp->GetTypeInfoCount( &supported );

        if( SUCCEEDED(hr) && supported )
        {
            ITypeInfo *pTypeInfo = 0;
            hr = pDisp->GetTypeInfo( 0, 0, &pTypeInfo );

            if( SUCCEEDED(hr) )
            {
                UINT index;
                hr = pTypeInfo->GetContainingTypeLib( &pTypeLib, &index );
                SAFERELEASE(pTypeInfo);
            }
        }

        SAFERELEASE(pDisp);
    }

    if( FAILED(hr) )
    {
        // If, for some reason, we failed to load the type library this way,
        // load the type library directly out of MSHTML's resources.

        // We shouldn't hard code this...
        hr = LoadTypeLib(L"mshtml.tlb", &pTypeLib);
    }

    if( FAILED(hr) )
        return hr;

    ITypeInfo *pTopTypeInfo = 0;
    ITypeInfo *pTmpTypeInfo = 0;
    ITypeInfo *pCoClassTypeInfo = 0;

    // Get the coclass TypeInfo
    hr = pTypeLib->GetTypeInfoOfGuid( _clsid, &pCoClassTypeInfo );
    if( SUCCEEDED(hr) )
        hr = pCoClassTypeInfo->QueryInterface( IID_ITypeInfo2, (void**)&_pCoClassTypeInfo2 );

    if( FAILED(hr) )
        goto Exit;

    // get the TKIND_INTERFACE
    hr = pTypeLib->GetTypeInfoOfGuid( _iid, &pTopTypeInfo );

    if( SUCCEEDED(hr) )
    {
        HREFTYPE hrt;

        // get the TKIND_INTERFACE from a TKIND_DISPATCH
        hr = pTopTypeInfo->GetRefTypeOfImplType( 0xffffffff, &hrt );

        if( SUCCEEDED(hr) )
        {
            // get the typeInfo associated with the href
            hr = pTopTypeInfo->GetRefTypeInfo(hrt, &pTmpTypeInfo);

            if( SUCCEEDED(hr) )
                hr = pTmpTypeInfo->QueryInterface( IID_ITypeInfo2, (void**)&_pInterfaceTypeInfo2 );
        }
    }

Exit:
    SAFERELEASE( pCoClassTypeInfo );
    SAFERELEASE( pTmpTypeInfo );
    SAFERELEASE( pTopTypeInfo );
    SAFERELEASE( pTypeLib );
    return hr;
}



// *** IDispatch members ***

HRESULT CIEFrameAuto::CAutomationStub::GetTypeInfoCount( UINT *typeinfo )
{
    if( !typeinfo )
        return E_POINTER;

    if( !_fLoaded )
        ResolveTypeInfo2( );

    *typeinfo = _pInterfaceTypeInfo2 ? 1 : 0;

    return S_OK;
}

HRESULT CIEFrameAuto::CAutomationStub::GetTypeInfo( UINT itinfo, LCID, ITypeInfo **typeinfo )
{
    if( !typeinfo )
        return E_POINTER;

    *typeinfo = NULL;

    if( 0 != itinfo )
        return TYPE_E_ELEMENTNOTFOUND;

    if( !_fLoaded )
    {
        HRESULT hr = ResolveTypeInfo2( );
        if( FAILED(hr) )
            return hr;
    }

    if (_pInterfaceTypeInfo2)
    {
        *typeinfo = _pInterfaceTypeInfo2;
        _pInterfaceTypeInfo2->AddRef();
    }

    return *typeinfo ? S_OK : E_FAIL;
}

HRESULT CIEFrameAuto::CAutomationStub::GetIDsOfNames(
  REFIID riid,
  OLECHAR **rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID *rgdispid )
{
    // Since the majority of script operates on built in (non-expando) properties
    // This implementation should be faster than simply passing all lookups to
    // the delegate.

    // Handle it if we can. It is OK to return a DISPID for a method/property
    // that is implemented by Trident. We will simply pass it through in Invoke
    if( !_fLoaded )
        ResolveTypeInfo2( );

    if( !_pInterfaceTypeInfo2 )
        return TYPE_E_CANTLOADLIBRARY;

    HRESULT  hr = _pInterfaceTypeInfo2->GetIDsOfNames( rgszNames, cNames, rgdispid );

    if( FAILED(hr) )
    {
        IDispatchEx *delegate = 0;
        hr = _GetIDispatchExDelegate( &delegate );

        if( SUCCEEDED(hr) )
        {
            hr = delegate->GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid );
            delegate->Release( );
        }
    }

    return hr;
}

HRESULT CIEFrameAuto::CAutomationStub::InvokeEx (DISPID dispidMember,
   LCID lcid,
   WORD wFlags,
   DISPPARAMS * pdispparams,
   VARIANT * pvarResult,
   EXCEPINFO * pexcepinfo,
   IServiceProvider *pSrvProvider )
{
    HRESULT hr;

    if (dispidMember == DISPID_SECURITYCTX)
    {
        //
        // Return the url of the document as a bstr.
        //

        if (pvarResult)
        {
            hr = _pAuto->_QueryPendingUrl(pvarResult);
            if (SUCCEEDED(hr)) return S_OK;
        }
    }

    if( (dispidMember != DISPID_SECURITYCTX) &&
        ((dispidMember >= _MinDispid && dispidMember <= _MaxDispid) ||
         (_fOwnDefaultDispid && DISPID_VALUE == dispidMember) ) )
    {
        BOOL    fNamedDispThis = FALSE;
        VARIANTARG *rgOldVarg = NULL;           // init to suppress bogus C4701 warning
        DISPID *rgdispidOldNamedArgs = NULL;    // init to suppress bogus C4701 warning

        if( !_fLoaded )
            ResolveTypeInfo2( );

        if( !_pInterfaceTypeInfo2 )
            return TYPE_E_CANTLOADLIBRARY;

        // Any invoke call from a script engine might have the named argument
        // DISPID_THIS.  If so then we'll not include this argument in the
        // list of parameters because oleaut doesn't know how to deal with this
        // argument.
        if (pdispparams->cNamedArgs && (pdispparams->rgdispidNamedArgs[0] == DISPID_THIS))
        {
            fNamedDispThis = TRUE;

            pdispparams->cNamedArgs--;
            pdispparams->cArgs--;

            rgOldVarg = pdispparams->rgvarg;
            rgdispidOldNamedArgs = pdispparams->rgdispidNamedArgs;

            pdispparams->rgvarg++;
            pdispparams->rgdispidNamedArgs++;

            if (pdispparams->cNamedArgs == 0)
                pdispparams->rgdispidNamedArgs = NULL;

            if (pdispparams->cArgs == 0)
                pdispparams->rgvarg = NULL;
        }

        // It belongs to us. Use the typelib to call our method.
        hr = _pInterfaceTypeInfo2->Invoke(_pInstance,
                                    dispidMember,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    NULL);

        // Replace the named DISPID_THIS argument.
        if (fNamedDispThis)
        {
            pdispparams->cNamedArgs++;
            pdispparams->cArgs++;

            pdispparams->rgvarg = rgOldVarg;
            pdispparams->rgdispidNamedArgs = rgdispidOldNamedArgs;
        }
    }
    else
    {
        // Pass it along
        IDispatchEx *delegate = 0;
        hr = _GetIDispatchExDelegate( &delegate );

        if( SUCCEEDED(hr) )
        {
            hr = delegate->InvokeEx(dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider );
            delegate->Release( );
        }
        else
        {
            // If we're hosting a non-Trident DocObject, we can get here trying to answer an
            // Invoke on the Security Context.  This can cause cross-frame access to fail,
            // even when we want it to succeed.  If we pass back the URL of the active view,
            // then Trident can do the proper cross-frame access checking.
            //
            if (dispidMember == DISPID_SECURITYCTX)
            {
                if (_pAuto && _pAuto->_psb)  // Check them both for paranoia.
                {
                    IShellView *psv;

                    if (SUCCEEDED(_pAuto->_psb->QueryActiveShellView(&psv)))
                    {
                        IOleCommandTarget  *pct;

                        if (SUCCEEDED(psv->QueryInterface(IID_IOleCommandTarget, (void**)&pct)))
                        {
                            // The name of the ID is misleading -- it really returns the URL of the view.  It was
                            // invented for Pending views, but works just as well for active views.
                            //
                            hr = pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGURL, 0, NULL, pvarResult);
                            SAFERELEASE(pct);
                        }
                        SAFERELEASE(psv);
                    }
                }
            }
        }
    }

    return hr;

}

HRESULT CIEFrameAuto::CAutomationStub::Invoke(
  DISPID dispidMember,
  REFIID,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS *pdispparams,
  VARIANT *pvarResult,
  EXCEPINFO *pexcepinfo,
  UINT * )
{
    return InvokeEx ( dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL );
}

// *** IDispatchEx members ***

STDMETHODIMP CIEFrameAuto::CAutomationStub::GetDispID(
  BSTR bstrName,
  DWORD grfdex,
  DISPID *pid)
{
    HRESULT       hr;

        if( !_fLoaded )
        ResolveTypeInfo2( );

    if( !_pInterfaceTypeInfo2 )
        return TYPE_E_CANTLOADLIBRARY;

    // Do a case sensitive compare?
    if ( IEFrameAuto()->_pfnMEGetIDsOfNames )
    {
        // Case sensitve GetIDsOfNames.
        hr = (IEFrameAuto()->_pfnMEGetIDsOfNames)(_pInterfaceTypeInfo2,
                                                  IID_NULL,
                                                  &bstrName,
                                                  1, 0, pid,
                                                  grfdex & fdexNameCaseSensitive);
    }
    else
    {
        hr = _pInterfaceTypeInfo2->GetIDsOfNames( &bstrName, 1, pid );
    }

    // If fails then try typelibrary.
    if( FAILED(hr) )
    {
        IDispatchEx *delegate = 0;

        // Always delegate which is faster, avoids loading the typelibrary.
        hr = _GetIDispatchExDelegate( &delegate );

        if( SUCCEEDED(hr) )
        {
            hr = delegate->GetDispID(bstrName, grfdex, pid);
            delegate->Release( );
        }
    }

    return hr;
}


STDMETHODIMP CIEFrameAuto::CAutomationStub::DeleteMemberByName(BSTR bstr, DWORD grfdex)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate( &delegate );

    if( SUCCEEDED(hr) )
    {
        hr = delegate->DeleteMemberByName( bstr,grfdex );
        delegate->Release( );
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::CAutomationStub::DeleteMemberByDispID(DISPID id)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate( &delegate );

    if( SUCCEEDED(hr) )
    {
        hr = delegate->DeleteMemberByDispID( id );
        delegate->Release( );
    }

    return hr;
}

STDMETHODIMP  CIEFrameAuto::CAutomationStub::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate( &delegate );

    if( SUCCEEDED(hr) )
    {
        hr = delegate->GetMemberProperties(  id, grfdexFetch, pgrfdex );
        delegate->Release( );
    }

    return hr;
}


STDMETHODIMP  CIEFrameAuto::CAutomationStub::GetMemberName(DISPID id, BSTR *pbstrName)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate( &delegate );

    if( SUCCEEDED(hr) )
    {
        hr = delegate->GetMemberName(  id, pbstrName );
        delegate->Release( );
    }

    return hr;
}


STDMETHODIMP CIEFrameAuto::CAutomationStub::GetNextDispID(
  DWORD grfdex,
  DISPID id,
  DISPID *pid)
{
    IDispatchEx *delegate = 0;
    HRESULT hr = _GetIDispatchExDelegate( &delegate );

    if( SUCCEEDED(hr) )
    {
        hr = delegate->GetNextDispID( grfdex, id, pid );
        delegate->Release( );
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::CAutomationStub::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT hr;

    if (!ppunk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppunk = NULL;
    hr = S_OK;

Cleanup:
    return hr;
}


// *** IProvideClassInfo members ***

STDMETHODIMP CIEFrameAuto::CAutomationStub::GetClassInfo( ITypeInfo **typeinfo )
{
    if( !typeinfo )
        return E_POINTER;

    if( !_fLoaded )
    {
        HRESULT hr = ResolveTypeInfo2( );
        if( FAILED(hr) )
        {
            *typeinfo = NULL;
            return hr;
        }
    }

    *typeinfo = _pCoClassTypeInfo2;

    if (*typeinfo)
    {
        (*typeinfo)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}

/******************************************************************************
                    Window Object
******************************************************************************/

// Define static variables
unsigned long CIEFrameAuto::COmWindow::s_uniqueIndex = 0;


CIEFrameAuto::COmWindow::COmWindow() :
    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, FALSE )
{
    ASSERT( FALSE == _fCallbackOK );
    ASSERT( !_pOpenedWindow );
    ASSERT( _varOpener.vt == VT_EMPTY );
    ASSERT( !_dwCPCookie );
    ASSERT( !_pCP );
    ASSERT( !_fOnloadFired );
    ASSERT( !_fIsChild );
    ASSERT( !_pIntelliForms );

    _fDelegateWindowOM = TRUE;     // Always delegate, unless told otherwise.

}

HRESULT CIEFrameAuto::COmWindow::Init( )
{
    _cpWindowEvents.SetOwner( SAFECAST(SAFECAST(this, CAutomationStub*), IDispatchEx*), &DIID_HTMLWindowEvents);

    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omwin, this);
    return CAutomationStub::Init( SAFECAST(this, IHTMLWindow2*), IID_IHTMLWindow2, CLSID_HTMLWindow2, pauto );
}


#ifdef NO_MARSHALLING
EXTERN_C  const GUID IID_IWindowStatus;
#endif

HRESULT CIEFrameAuto::COmWindow::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    ASSERT( !IsEqualIID(riid, IID_IUnknown) );

    if( IsEqualIID(riid, IID_IHTMLWindow2) || IsEqualIID(riid, IID_IHTMLFramesCollection2) )
        *ppv = SAFECAST(this, IHTMLWindow2*);
    else if( IsEqualIID(riid, IID_IHTMLWindow3))
        *ppv = SAFECAST(this, IHTMLWindow3*);
    else if( IsEqualIID(riid, IID_ITargetNotify) )
        *ppv = SAFECAST(this, ITargetNotify*);
    else if( IsEqualIID(riid, IID_IShellHTMLWindowSupport) )
        *ppv = SAFECAST(this, IShellHTMLWindowSupport*);
    else if( IsEqualIID(riid, IID_IShellHTMLWindowSupport2) )
        *ppv = SAFECAST(this, IShellHTMLWindowSupport2*);
    else if( IsEqualIID(riid, IID_IProvideMultipleClassInfo) ||
             IsEqualIID(riid, IID_IProvideClassInfo2) )
        *ppv = SAFECAST(this, IProvideMultipleClassInfo*);
    else if( IsEqualIID(riid, IID_IConnectionPointCB) )
        *ppv = SAFECAST(this, IConnectionPointCB* );
    else if( IsEqualIID(riid, IID_IConnectionPointContainer) )
        *ppv = SAFECAST(this, IConnectionPointContainer* );
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *ppv = SAFECAST(this, IServiceProvider *);
#ifdef NO_MARSHALLING
    else if (IsEqualIID(riid, IID_IWindowStatus))
        *ppv = SAFECAST(this, IWindowStatus *);
#endif
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}


// ** IProvideMultipleClassInfo

STDMETHODIMP CIEFrameAuto::COmWindow::GetGUID( DWORD dwGuidKind, GUID* pGUID )
{
    if( !pGUID )
        return E_POINTER;

    if( GUIDKIND_DEFAULT_SOURCE_DISP_IID == dwGuidKind )
    {
        *pGUID = DIID_HTMLWindowEvents;
        return S_OK;
    }
    else
        return E_INVALIDARG;
}

/******************************************************************************
 Both IProvideMultipleClassInfo specific methods are passed along to Trident.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::GetMultiTypeInfoCount( ULONG *pcti )
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        IProvideMultipleClassInfo *pMCI = 0;
        hr = pWindow->QueryInterface( IID_IProvideMultipleClassInfo, (void**)&pMCI );
        pWindow->Release( );

        if( SUCCEEDED(hr) )
        {
            hr = pMCI->GetMultiTypeInfoCount( pcti );
            pMCI->Release();
        }
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::GetInfoOfIndex( ULONG iti, DWORD dwFlags, ITypeInfo **pptiCoClass, DWORD *pdwTIFlags, ULONG *pcdispidReserved,IID *piidPrimary,IID *piidSource )
{
    IHTMLWindow2 *pWindow;
    HRESULT hr = _GetWindowDelegate( &pWindow );
    if( SUCCEEDED(hr) )
    {
        IProvideMultipleClassInfo *pMCI = 0;
        hr = pWindow->QueryInterface( IID_IProvideMultipleClassInfo, (void**)&pMCI );
        pWindow->Release( );

        if( SUCCEEDED(hr) )
        {
            hr = pMCI->GetInfoOfIndex( iti, dwFlags, pptiCoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource );
            pMCI->Release();
        }
    }
    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    IDispatchEx *delegate;
    HRESULT hr = _GetIDispatchExDelegate( &delegate );
    if( SUCCEEDED(hr) )
    {
        hr = delegate->GetDispID(bstrName, grfdex, pid);
        delegate->Release( );
    }
    else
    {
        return CAutomationStub::GetDispID(bstrName, grfdex, pid);
    }
    return hr;
}

/*****************************************************************************
 IServiceProvider - this is used by mshtml as well as intelliforms in iforms.cpp
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (IsEqualGUID(guidService,IID_IHTMLWindow2))
    {
        return QueryInterface(iid, ppv);
    }
    else if (IsEqualGUID(guidService, IID_IEnumPrivacyRecords))
    {
        IHTMLWindow2 *pWindow = 0;
        IServiceProvider * pISP = NULL;
        hr = _GetWindowDelegate( &pWindow );

        if( SUCCEEDED(hr) )
        {
            hr = pWindow->QueryInterface(IID_IServiceProvider, (void**)&pISP);
            if (SUCCEEDED(hr))
            {
                hr = pISP->QueryService(IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, ppv);
                pISP->Release();
            }
            pWindow->Release( );
        }

        return hr;
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::ViewReleaseIntelliForms()
{
    ReleaseIntelliForms();

    return S_OK;
}

/******************************************************************************
 This method is called when the document contained by the browser is being
 deactivated (like when navigating to a new location). Currently we only use
 this knowledge to handle event sourcing.

 This method could also be used to optimize our connections to expando
 implentations in the document (trident). Currently we obtain and release
 the expando implementations for the Navigator, History, and Location objects
 each time they are needed. ViewRelease (along with ViewActivated) would allow
 us to grab and hold expando implementations until the next navigation.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::ViewReleased()
{
    UnsinkDelegate( );
    ReleaseIntelliForms( );

    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        VARIANT varProp;
        if (SUCCEEDED(_pAuto->GetProperty(bstrName, &varProp)))
        {
            if ( (varProp.vt == VT_DISPATCH) && (varProp.pdispVal != NULL) )
            {
                IUnknown* pWindow = varProp.pdispVal;

                VARIANT vtTmp = {0};
                _pAuto->PutProperty(bstrName, vtTmp);

                //(davemi) see IE5 bug 57060 for why the below line doesn't work and IDispatch must be used instead
                //pWindow->close();
                IDispatch * pdisp;
                if (SUCCEEDED(pWindow->QueryInterface(IID_IDispatch, (void**)&pdisp)))
                {
                    DISPID dispid;
                    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

                    BSTR bstrClose = SysAllocString(L"close");

                    if (bstrClose)
                    {
                        HRESULT hr;

                        hr = pdisp->GetIDsOfNames(IID_NULL, &bstrClose, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                        if (hr == S_OK)
                        {
                            VARIANT varTmp = {0};
                            pdisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &dispparamsNoArgs, &varTmp, NULL, NULL);
                        }

                        SysFreeString(bstrClose);
                    }

                    pdisp->Release();
                }
            }
            VariantClear(&varProp);
        }
        SysFreeString(bstrName);
    }

    return FireOnUnload( );
}

/******************************************************************************
 This method is called when the document contained by the browser is being
 activated. Currently we only use this knowledge to handle event sourcing.

 See comments for ViewReleased()
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::ViewActivated()
{
    HRESULT hr;

    // These will fail for non-trident documents which is OK.
    SinkDelegate( );
    AttachIntelliForms( );

    // This call will return TRUE if either:
    // - The document has reached READYSTATE_COMPLETE or
    // - The document does not support the ReadyState property
    // If the delegate is not complete then we will be notified of READYSTATE
    // changes later. These notifications will tell use when the document is
    // complete and the Onload even should be fired.
    if( IsDelegateComplete( ) )
        hr = FireOnLoad( );
    else
        hr = S_OK;

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::ReadyStateChangedTo( long ready_state, IShellView *psv )
{
    HRESULT hr = S_OK;

    // We only want to fire Onload if the ready state has changed to
    // READYSTATE_COMPLETE and the view that has changed states is the
    // currently active view. If the pending view has completed states
    // we can ignore the notification because Onload will be fired when
    // the pending view is activated. Ignoring READYSTATE changes from
    // the pending view garauntees we will never fire onload early for
    // the currently active view.
    if( (READYSTATE_COMPLETE == ready_state) && psv)
    {
        IShellView * const pCurrSV = _pAuto->_GetShellView( );

        if( pCurrSV )
        {
            if (IsSameObject(pCurrSV, psv))
            {
                hr = FireOnLoad( );
            }
            pCurrSV->Release( );
        }
    }

    return hr;
}


// Attach intelliforms to FORM elements on page
HRESULT CIEFrameAuto::COmWindow::AttachIntelliForms()
{
    HRESULT hr = E_FAIL;

    if (_pIntelliForms)
    {
        ReleaseIntelliForms();
        _pIntelliForms = NULL;
    }

    IHTMLDocument2 *pDoc2=NULL;
    IDispatch *pdispDoc=NULL;

    _pAuto->get_Document(&pdispDoc);
    if (pdispDoc)
    {
        pdispDoc->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc2));
        pdispDoc->Release();
    }

    if (pDoc2)
    {
        ::AttachIntelliForms(this, NULL, pDoc2, &_pIntelliForms);

        pDoc2->Release();

        hr = S_OK;
    }

    if (_fIntelliFormsAskUser)
    {
        // Possibly ask user if they'd like to enable this feature
        IntelliFormsDoAskUser(_pAuto->_GetHWND(), NULL); // NULL from _GetHWND() OK
        _fIntelliFormsAskUser=FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::ReleaseIntelliForms()
{
    if (_pIntelliForms)
    {
        void *p = _pIntelliForms;
        _pIntelliForms = NULL;
        ::ReleaseIntelliForms(p);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::DestroyIntelliForms()
{
    ReleaseIntelliForms();

    return S_OK;
}

// Request from Intelliforms that we prompt user on next load about
//  enabling the Intelliforms feature
HRESULT CIEFrameAuto::COmWindow::IntelliFormsAskUser(LPCWSTR pwszValue)
{
    _fIntelliFormsAskUser = TRUE;

    return S_OK;
}

/******************************************************************************
 This method is called when the browser is no longer busy and we should
 retry any navigate that we had to defer while it was busy.

******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::CanNavigate()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omwin, this);

    pauto->_omloc.RetryNavigate();
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmWindow::ActiveElementChanged(IHTMLElement * pHTMLElement)
{
    return IntelliFormsActiveElementChanged(_pIntelliForms, pHTMLElement);
}

STDMETHODIMP CIEFrameAuto::COmWindow::IsGalleryMeta(BOOL bFlag)
{
//    _bIsGalleryMeta = bFlag;
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::_GetIDispatchExDelegate( IDispatchEx ** const delegate )
{
    if( !delegate )
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate( _pAuto, &pRootDisp );
    if( SUCCEEDED(hr) )
    {
        hr = pRootDisp->QueryInterface( IID_IDispatchEx, (void**)delegate );
        pRootDisp->Release( );
    }

    return hr;
}


// *** IHTMLFramesCollection2 ***

HRESULT CIEFrameAuto::COmWindow::item(
    /* [in] */ VARIANT *pvarIndex,
    /* [retval][out] */ VARIANT *pvarResult)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->item( pvarIndex, pvarResult );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_length(long *pl)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_length( pl );
        pWindow->Release( );
    }

    return hr;
}

// *** IHTMLWindow2 ***

HRESULT CIEFrameAuto::COmWindow::get_name(BSTR *retval)
{
    if( !retval )
        return E_POINTER;

    WCHAR *real_frame_name = 0;
    WCHAR *use_frame_name = 0;

    // Why doesn't GetFrameName use BSTR?
    HRESULT hr = _pAuto->GetFrameName( &real_frame_name );

    if( FAILED(hr) )
        return hr;

    // If the frame's name is our special NO_NAME_NAME
    // then our name is really be an empty string.
    if( !real_frame_name || !StrCmpNW(real_frame_name, NO_NAME_NAME, ARRAYSIZE(NO_NAME_NAME) -1 ) )
        use_frame_name = L"";
    else
        use_frame_name = real_frame_name;

    ASSERT( use_frame_name );
    *retval = SysAllocString( use_frame_name );

    if( real_frame_name )
        OleFree( real_frame_name );

    return *retval ? S_OK : E_OUTOFMEMORY;
}

HRESULT CIEFrameAuto::COmWindow::put_name(
    /* [in] */ BSTR theName)
{
    if( !theName )
        return E_POINTER;

    return _pAuto->SetFrameName( theName );
}

HRESULT CIEFrameAuto::COmWindow::get_parent(IHTMLWindow2 **retval)
{
    if( !retval )
        return E_POINTER;

    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    // Attempt to delegate this to the contained object.
    if (_fDelegateWindowOM)
    {
        hr = _GetWindowDelegate(&pWindow);
        if (SUCCEEDED(hr) && pWindow)
        {
            hr = pWindow->get_parent(retval);
        }
    }

    // If delegation fails, use our implementation.
    if (FAILED(hr))
    {
        *retval = 0;
        IUnknown *pUnk = 0;

        hr = _pAuto->GetParentFrame( &pUnk );

        // If we are already the top, GetParentFrame set pUnk to NULL
        if( SUCCEEDED(hr) )
        {
            if( pUnk )
            {
                hr = GetWindowFromUnknown( pUnk, retval );
                pUnk->Release( );
            }
            else
            {
                *retval = this;
                AddRef( );
            }
        }
    }

    SAFERELEASE(pWindow);
    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_self(IHTMLWindow2 **retval)
{
    if( !retval )
        return E_POINTER;

    *retval = this;
    AddRef();

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_top(IHTMLWindow2 **retval)
{
    if( !retval )
        return E_POINTER;

    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    // Attempt to delegate this to contained object.
    if (_fDelegateWindowOM)
    {
        hr = _GetWindowDelegate(&pWindow);
        if (SUCCEEDED(hr) && pWindow)
        {
            hr = pWindow->get_top(retval);
        }
    }

    // If delegation fails, use our implementation.
    if (FAILED(hr))
    {
        *retval = 0;
        IUnknown *pUnk = 0;

        // AddRef the interface to we can Release it in the while loop
        ITargetFrame2 *pTfr = _pAuto;
        pTfr->AddRef();

        hr = pTfr->GetParentFrame( &pUnk );

        // Keep calling GetParent until we fail or get a NULL (which is the top
        while( SUCCEEDED(hr) && pUnk )
        {
            SAFERELEASE( pTfr );
            hr = pUnk->QueryInterface(IID_PPV_ARG(ITargetFrame2, &pTfr));
            pUnk->Release( );

            if( SUCCEEDED(hr) )
                hr = pTfr->GetParentFrame( &pUnk );
        }

        if( SUCCEEDED(hr) )
            hr = GetWindowFromUnknown( pTfr, retval );

        SAFERELEASE( pTfr );
    }

    SAFERELEASE(pWindow);
    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_window(IHTMLWindow2 **retval)
{
    if( !retval )
        return E_POINTER;

    *retval = this;
    AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_frames(IHTMLFramesCollection2 **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_frames( retval );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_location( IHTMLLocation **retval )
{
    if( !retval )
        return E_POINTER;

    *retval = &_pAuto->_omloc;
    (*retval)->AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_navigator( IOmNavigator **retval)
{
    if( !retval )
        return E_POINTER;

    *retval = &_pAuto->_omnav;
    (*retval)->AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_clientInformation( IOmNavigator **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_clientInformation( retval );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_history( IOmHistory **retval)
{
    if( !retval )
        return E_POINTER;

    *retval = &_pAuto->_omhist;
    (*retval)->AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::put_defaultStatus(BSTR statusmsg)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_defaultStatus( statusmsg );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_defaultStatus(BSTR *retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_defaultStatus( retval );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_status(BSTR statusmsg)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_status( statusmsg );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_status(BSTR *retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_status( retval );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::setTimeout(
    /* [in] */ BSTR expression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->setTimeout( expression, msec, language, timerID );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::clearTimeout(long timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->clearTimeout( timerID );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::setInterval(
    /* [in] */ BSTR expression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->setInterval( expression, msec, language, timerID );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::clearInterval(long timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->clearInterval( timerID );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::alert(BSTR message)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->alert( message );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::focus()
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->focus();
        pWindow->Release( );
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::close()
{
    IUnknown *pUnk = 0;
    HRESULT hr;

    if (_pAuto->_psb != _pAuto->_psbProxy) //if it's a band, just hide it
    {
        return IUnknown_ShowBrowserBar(_pAuto->_psbTop, CLSID_SearchBand, FALSE);
    }

    hr = _pAuto->GetParentFrame( &pUnk );

    if( SUCCEEDED(hr) )
    {
        if( !pUnk )
        {
            if (_fIsChild ||
                IDYES == MLShellMessageBox(
                                         _pAuto->_GetHWND(),  // NULL from _GetHWND() OK
                                         MAKEINTRESOURCE(IDS_CONFIRM_SCRIPT_CLOSE_TEXT),
                                         MAKEINTRESOURCE(IDS_TITLE),
                                         MB_YESNO | MB_ICONQUESTION))
            {
                _pAuto->Quit( );
            }
        }
        else
            pUnk->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::blur()
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->blur();
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::scroll(long x, long y)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->scroll( x, y );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::confirm(
    /* [optional] */ BSTR message,
    /* [retval][out] */VARIANT_BOOL* confirmed)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->confirm( message, confirmed );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::prompt(
    /* [optional] */ BSTR message,
    /* [optional] */ BSTR defstr,
    /* [retval][out] */ VARIANT* textdata)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->prompt( message, defstr, textdata );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_closed(VARIANT_BOOL *pl)
{
    *pl = 0;
    return S_OK;
}

#ifdef NO_MARSHALLING

HRESULT CIEFrameAuto::COmWindow::IsWindowActivated()
{
    ASSERT( _pAuto );

    BOOL fComplete = FALSE;

    // Check for proper readystate support
    IDispatch *pdispatch;
    if( SUCCEEDED(_pAuto->get_Document( &pdispatch )) )
    {
        VARIANTARG va;
        EXCEPINFO excp;

        if( SUCCEEDED(pdispatch->Invoke( DISPID_READYSTATE,
                                         IID_NULL,
                                         LOCALE_USER_DEFAULT,
                                         DISPATCH_PROPERTYGET,
                                         (DISPPARAMS *)&g_dispparamsNoArgs,
                                         &va,
                                         &excp,
                                         NULL)) )
        {
            if( VT_I4 == va.vt && READYSTATE_COMPLETE == va.lVal )
                fComplete = TRUE;
        }

        pdispatch->Release();
    }

    return (fComplete?S_OK:S_FALSE);
}

#endif

// *** IHTMLWindow2 ***

HRESULT CIEFrameAuto::COmWindow::open(
            /* [in] */ BSTR url,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [out][retval] */ IHTMLWindow2 **ppomWindowResult)
{
    // bradsch 11/11/96 this needs to be added back in at some point.
/*
    // If the host does not support multiple windows in the same thread,
    // then disable window.open
    if (!g_fMultipleWindowsSupportedByHost)
    {
        // Hide the resulting error message from the user
        if (m_pParser)
            m_pParser->ShowErrors(FALSE);
        return E_NOTIMPL;
    }
*/
    ASSERT( ppomWindowResult );

    if( !ppomWindowResult )
        return E_POINTER;

    HRESULT hr = S_OK;

    BSTR bstrUrl = NULL;
    BSTR bstrWindowName = NULL;
    BSTR bstrUrlAbsolute = NULL;

    _OpenOptions.ReInitialize();

    // Process parameter: url
    if( !url )
    {
        // if the URL is empty, use blank.htm instead
        bstrUrl = SysAllocString(L"");
    }

    // Process parameter: name
    if ( name )
    {
        // Make sure we have a legal name
        for( int i = 0; i < lstrlenW( name ); i++ )
        {
            if (!(IsCharAlphaNumericWrapW( name[i] ) || TEXT('_') == name[i]))
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
        }
    }

    // Process parameter: features
    if( features && lstrlenW(features) > 0 )
    {
        hr = _ParseOptionString( features );
        if (hr)
            goto Exit;
    }

    //
    // ***TLL*** shdocvw needs to handle the replace parameter.
    //

    // Compute the absolute version of the URL
    if (!bstrUrl || *bstrUrl)
    {
        if (url)
        {
            if (*url == EMPTY_URL)
            {
                bstrUrlAbsolute = SysAllocString(url);
            }
            else
            {
                bstrUrlAbsolute = _pAuto->_omloc.ComputeAbsoluteUrl( bstrUrl ? bstrUrl : url );
            }
        }
    }
    else
    {
        bstrUrlAbsolute = bstrUrl;
        bstrUrl = NULL;
    }

    if( !bstrUrlAbsolute )
        goto Exit;

    // If a window name is not provided we need to assign it a private name
    // so we do not lose track of it. If the window name is "_blank" we need
    // to create a new window each time with a private name. Other portions
    // of this class must be smart enough to return and an empty string when
    // this private name is used.
    if( !name || !*name || (*name && !StrCmpW(name, L"_blank")) )
    {
        bstrWindowName = _GenerateUniqueWindowName( );
    }

    // Window open state tracking
    _fCallbackOK = FALSE;
    *ppomWindowResult = NULL;

    // Try to navigate a frame in an existing window to the url or open a new one
    hr = OpenAndNavigateToURL( _pAuto,
                               &bstrUrlAbsolute,
                               bstrWindowName ? bstrWindowName : name,
                               SAFECAST( this, ITargetNotify*),
                               replace,
                               BOOLIFY(_pAuto->m_bSilent));

    if( SUCCEEDED(hr) )
    {
        if( _fCallbackOK )
        {
            *ppomWindowResult = _pOpenedWindow;
            _pOpenedWindow = NULL;
            ASSERT( *ppomWindowResult );

#ifdef NO_MARSHALLING
            MSG msg;
            IWindowStatus *pws;
            while( GetMessage( &msg, NULL, 0, 0 ))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);

                if ((*ppomWindowResult) && SUCCEEDED((*ppomWindowResult)->QueryInterface( IID_IWindowStatus, (void**)&pws)))
                {
                    if( pws->IsWindowActivated() == S_OK )
                    {
                        pws->Release();
                        break;
                    }
                    pws->Release();
                }
                else
                    break;
            }
#endif

        }

        // This might turn an S_FALSE into an S_OK, but is needed to keep Trident happy.
        // Change this back to if (hr != S_FALSE) hr = E_FAIL,
        //         change BASESB.CPP to return S_FALSE instead of S_OK on a busy navigate,
        //         and change Trident to handle S_FALSE from window.open (RRETURN1(hr, S_FALSE));
        // hr = S_OK;
    }


Exit:
    SAFERELEASE( _pOpenedWindow );

    // Clean up the unique name if we generated it ourself
    if( bstrUrl )
        SysFreeString(bstrUrl);
    if( bstrUrlAbsolute )
        SysFreeString(bstrUrlAbsolute);
    if( bstrWindowName )
        SysFreeString( bstrWindowName );

    return hr;
}

BSTR CIEFrameAuto::COmWindow::_GenerateUniqueWindowName( )
{
    WCHAR buffer[ ARRAYSIZE(NO_NAME_NAME) + 12 ];

    // Choose a name the user isn't likely to typed. Need to guard
    // this becuase s_uniqueIndex is a shared static variable.
    ENTERCRITICAL;
    unsigned long val = ++s_uniqueIndex;
    LEAVECRITICAL;

    wnsprintf( buffer, ARRAYSIZE(buffer), L"%ls%lu", NO_NAME_NAME, val );

    return SysAllocString( buffer );
}

//
// Zhenbinx - Trident only talks OM Unit, not device unit.
//
class CHiResUnitConvert
{
public:
    CHiResUnitConvert(IHTMLWindow2 *pWindow2)
        : _pWindow2(pWindow2)
    {
        if (_pWindow2)
        {
            _pWindow2->AddRef();
        }
        _llogicalXDPI = _llogicalYDPI = 1;
        _ldeviceXDPI = _ldeviceYDPI = 1;
        _fInited = FALSE;
    }
    ~CHiResUnitConvert()
    {
        if (_pWindow2)
        {
            _pWindow2->Release();
        }
    }

    HRESULT Init();
    
    LONG  DeviceFromDocPixelsX(LONG cx)
    {
        if (!_fInited)  Init();
        return cx * _ldeviceXDPI / _llogicalXDPI;
    }
    LONG  DeviceFromDocPixelsY(LONG cy)
    {
        if (!_fInited)  Init();
        return cy * _ldeviceYDPI / _llogicalYDPI;
    }
    
private:
    IHTMLWindow2  *_pWindow2;
    BOOL          _fInited;
    LONG    _llogicalXDPI;
    LONG    _llogicalYDPI;
    LONG    _ldeviceXDPI;
    LONG    _ldeviceYDPI;
};


HRESULT  CHiResUnitConvert::Init()
{
    HRESULT hr = S_OK;
    IHTMLScreen  *pScreen = NULL;
    IHTMLScreen2 *pScreen2 = NULL;

    if (!_pWindow2)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _fInited = TRUE;
    hr = _pWindow2->get_screen(&pScreen);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen->QueryInterface(IID_IHTMLScreen2, (LPVOID *)&pScreen2);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen2->get_logicalXDPI( &_llogicalXDPI );
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen2->get_logicalYDPI( &_llogicalYDPI );
    if (!SUCCEEDED(hr))
        goto Cleanup;
    
    hr = pScreen2->get_deviceXDPI( &_ldeviceXDPI );
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen2->get_deviceYDPI( &_ldeviceYDPI );
    if (!SUCCEEDED(hr))
        goto Cleanup;

#if DBG == 1
    {
        WCHAR wcBuffer[255];    
        wnsprintf(wcBuffer, ARRAYSIZE(wcBuffer), _T("logical: [%d]-[%d], device: [%d]-[%d]" ), _llogicalXDPI, _llogicalYDPI, _ldeviceXDPI, _ldeviceYDPI);
        OutputDebugString(wcBuffer);
    }
#endif

Cleanup:
    if (pScreen)
        pScreen->Release();
    if (pScreen2)
        pScreen2->Release();
    
    return hr;
}


HRESULT CIEFrameAuto::COmWindow::_ParseOptionString( BSTR bstrOptionString, ITargetNotify2 * ptgnNotify2 /* = NULL */ )
{
    BSTR optionName = NULL;
    BSTR optionValue = NULL;
    int fValue = TRUE;
    BOOL fFirstSet = TRUE;
    IHTMLWindow2  *pWindow =  NULL;

    if (!SUCCEEDED(_GetWindowDelegate(&pWindow)) && ptgnNotify2)
    {
        ptgnNotify2->QueryInterface(IID_IHTMLWindow2, (void**)&pWindow);
    }

    CHiResUnitConvert   unitcvt(pWindow);

    // CHiResUnitConvert's constructor AddRefs pWindow, we can release this here
    if (pWindow)
        pWindow->Release();

    // Parse the options
    while( GetNextOption(bstrOptionString, &optionName, &fValue) )
    {
        if (fFirstSet)
        {
            //  Netscape's interpretation is, if you set any open options
            //  then, unless explicitly set, turn off various UI options
            _OpenOptions.fToolbar = FALSE;
            _OpenOptions.fLocation = FALSE;
            _OpenOptions.fDirectories = FALSE;
            _OpenOptions.fStatus = FALSE;
            _OpenOptions.fMenubar = FALSE;
            _OpenOptions.fScrollbars = FALSE;
            _OpenOptions.fResizable = FALSE;
            fFirstSet = FALSE;
        }
        if (!StrCmpIW(L"toolbar", optionName))
            _OpenOptions.fToolbar = fValue;
        else if (!StrCmpIW(L"location", optionName))
            _OpenOptions.fLocation = fValue;
        else if (!StrCmpIW(L"directories", optionName))
            _OpenOptions.fDirectories = fValue;
        else if (!StrCmpIW(L"status", optionName))
            _OpenOptions.fStatus = fValue;
        else if (!StrCmpIW(L"menubar", optionName))
            _OpenOptions.fMenubar = fValue;
        else if (!StrCmpIW(L"scrollbars", optionName))
            _OpenOptions.fScrollbars = fValue;
        else if (!StrCmpIW(L"resizable", optionName))
            _OpenOptions.fResizable = fValue;
        else if (!StrCmpIW(L"width", optionName))
             _OpenOptions.iWidth = unitcvt.DeviceFromDocPixelsX(fValue);
        else if (!StrCmpIW(L"height", optionName))
             _OpenOptions.iHeight = unitcvt.DeviceFromDocPixelsY(fValue);
        else if (!StrCmpIW(L"fullscreen", optionName))
            _OpenOptions.fFullScreen = fValue;  // For 22596, this should change to fChannelMode.
        else if (!StrCmpIW(L"top", optionName))
            _OpenOptions.iTop = unitcvt.DeviceFromDocPixelsY(fValue);
        else if (!StrCmpIW(L"left", optionName))
            _OpenOptions.iLeft = unitcvt.DeviceFromDocPixelsX(fValue);
        else if (!StrCmpIW(L"channelmode", optionName))
            _OpenOptions.fChannelMode = fValue;
        else if (!StrCmpIW(L"titlebar", optionName))
            _OpenOptions.fTitlebar = fValue;

        SysFreeString(optionName);
    }

    return S_OK;
}


// *** ITargetNotify members ***

/******************************************************************************
  Called when navigate must create a new window.  pUnkDestination is
  IWebBrowserApp object for new frame (also HLinkFrame,ITargetFrame).
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::OnCreate(IUnknown *pUnkDestination, ULONG cbCookie)
{
    if( !pUnkDestination )
    {
        _fCallbackOK = FALSE;
        return E_FAIL;
    }

    IWebBrowser2 *pNewIE = NULL;
    HRESULT hr = pUnkDestination->QueryInterface( IID_IWebBrowser2, (void**)&pNewIE );

    if( SUCCEEDED(hr) )
    {
        _ApplyOpenOptions( pNewIE );

        SAFERELEASE( _pOpenedWindow );
        // We do not want to release this window. It will be handed out
        // to caller of window.open. It is up to the caller to release it.
           hr = GetWindowFromUnknown( pUnkDestination, &_pOpenedWindow );
        if( SUCCEEDED(hr) )
        {
            VARIANT var, varDummy;
            VariantInit( &var );
            VariantInit( &varDummy );
            var.vt = VT_DISPATCH;
            var.pdispVal = static_cast<CAutomationStub*>(this);

            // call dummy put_opener in order to make use of its marshalling to set
            // child flag in opened window
            V_VT(&varDummy) = VT_BOOL;
            V_BOOL(&varDummy) = 666;
            hr = _pOpenedWindow->put_opener( varDummy );

            // set actual opener
            hr = _pOpenedWindow->put_opener( var );
        }

        //bradsch 10/27/96
        //Need some code here that tells the IWebBrowserApp not to persist its state.
        //This capability does not yet exist on IWebBrowserApp, mikesch is adding it.

        pNewIE->Release();
    }

    if( SUCCEEDED(hr) )
        _fCallbackOK = TRUE;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::OnReuse(IUnknown *pUnkDestination)
{
    if( !pUnkDestination )
    {
        _fCallbackOK = FALSE;
        return E_FAIL;
    }

    SAFERELEASE( _pOpenedWindow );

    // We do not want to release this window. It will be handed out
    // to caller of window.open. It is up to the caller to release it.
    HRESULT hr = GetWindowFromUnknown( pUnkDestination, &_pOpenedWindow );

    if( SUCCEEDED(hr) )
        _fCallbackOK = TRUE;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::_ApplyOpenOptions( IWebBrowser2 *pie )
{
    BOOL fMinusOne = FALSE;

    ASSERT(pie);

    // test TRUE explictly, as "2" is used as not inited
    if (TRUE == _OpenOptions.fChannelMode)
    {
        pie->put_TheaterMode(-1);

        if (!SHRestricted2W(REST_NoChannelUI, NULL, 0))
        {
            SA_BSTRGUID  strGuid;
            VARIANT      vaGuid;

            InitFakeBSTR(&strGuid, CLSID_FavBand);

            vaGuid.vt = VT_BSTR;
            vaGuid.bstrVal = strGuid.wsz;

            pie->ShowBrowserBar(&vaGuid, NULL, NULL);
        }
    }
    else if (_OpenOptions.fLocation
        || _OpenOptions.fDirectories
        || (_OpenOptions.fToolbar && _OpenOptions.fToolbar != CIEFrameAuto::COmWindow::BOOL_NOTSET)
        || _OpenOptions.fMenubar)
    {
        // If either "location=yes" (Address bar) or "directories=yes" (Quick Links bar) or
        // "toolbar=yes" are on, we need the internet toolbar to be on.
        // Then we can turn off the bands we don't want.
        //
        pie->put_ToolBar(TRUE);

        // We need to use the ShowBrowserBar method to handle bars/bands for which we don't have individual
        // properties.
        //
        VARIANT varClsid, varShow, varOptional;

        VariantInit(&varClsid);
        VariantInit(&varShow);
        VariantInit(&varOptional);

        varClsid.vt = VT_I2;

        varShow.vt = VT_BOOL;
        varShow.boolVal = VARIANT_FALSE;

        varOptional.vt = VT_ERROR;
        varOptional.scode = DISP_E_PARAMNOTFOUND;

        // "location=yes/no"
        //
        pie->put_AddressBar( BOOLIFY( _OpenOptions.fLocation) );
        fMinusOne = fMinusOne || !_OpenOptions.fLocation;

        // "toolbar=yes/no"
        //
        varClsid.iVal = FCW_TOOLBAND;
        varShow.boolVal = TO_VARIANT_BOOL( _OpenOptions.fToolbar );
        pie->ShowBrowserBar(&varClsid, &varShow, &varOptional);
        fMinusOne = fMinusOne || !_OpenOptions.fToolbar;

        // "directories=yes/no"
        //
        varClsid.iVal = FCW_LINKSBAR;
        varShow.boolVal = TO_VARIANT_BOOL( _OpenOptions.fDirectories );
        pie->ShowBrowserBar(&varClsid, &varShow, &varOptional);
        fMinusOne = fMinusOne || !_OpenOptions.fDirectories;
    }
    else
    {
        pie->put_ToolBar(FALSE);
    }

    // "statusbar=yes/no"
    //
    pie->put_StatusBar( BOOLIFY( _OpenOptions.fStatus) );
    fMinusOne = fMinusOne || !_OpenOptions.fStatus;

    // "menubar=yes/no"
    //
    pie->put_MenuBar( BOOLIFY( _OpenOptions.fMenubar) );
    fMinusOne = fMinusOne || !_OpenOptions.fMenubar;

    if( CIEFrameAuto::COmWindow::BOOL_NOTSET != _OpenOptions.fFullScreen )
        pie->put_FullScreen(_OpenOptions.fFullScreen);

    if ( _OpenOptions.fScrollbars == FALSE )
    {
        DWORD dwFlags;
        LPTARGETFRAME2 ptgf;

        if (SUCCEEDED(pie->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            if (SUCCEEDED(ptgf->GetFrameOptions(&dwFlags)))
            {
                if (_OpenOptions.fScrollbars == FALSE)
                {
                    dwFlags &= ~(FRAMEOPTIONS_SCROLL_YES|FRAMEOPTIONS_SCROLL_NO|FRAMEOPTIONS_SCROLL_AUTO);
                    dwFlags |= FRAMEOPTIONS_SCROLL_NO;
                }
                ptgf->SetFrameOptions(dwFlags);
            }
            ptgf->Release();
        }
    }

    pie->put_Resizable( BOOLIFY(_OpenOptions.fResizable) );

    // Only use the position and size information if the
    // the script does not enable full-screen mode
    if( TRUE != _OpenOptions.fFullScreen )
    {
        CIEFrameAuto * pFrameAuto = SAFECAST( pie, CIEFrameAuto * );
        if (pFrameAuto)
            pFrameAuto->put_Titlebar(_OpenOptions.fTitlebar);

        // If the script specifies no size or positional information and
        // the current window is in FullScreen mode then open the new
        // window in FullScreen mode as well.
        if( _OpenOptions.iWidth < 0 && _OpenOptions.iHeight < 0 && _OpenOptions.iTop < 0 && _OpenOptions.iLeft < 0 )
        {
            VARIANT_BOOL fs = 0;
            CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omwin, this);

            HRESULT hr = pauto->get_FullScreen( &fs );
            if( SUCCEEDED(hr) && fs )
                pie->put_FullScreen( fs );
        }
        else
        {
            int iWidth = _OpenOptions.iWidth > 0 ? _OpenOptions.iWidth:300;
            int iHeight = _OpenOptions.iHeight > 0 ? _OpenOptions.iHeight:300;

            // Set a minimum size of 100x100
            iWidth = iWidth > 100 ? iWidth : 100;
            iHeight = iHeight > 100 ? iHeight : 100;

            //  Yes! Netscape doesn't treat the width and height as a content
            //  size when at least one adornment is turned off
            if (fMinusOne) pie->ClientToWindow(&iWidth, &iHeight);
            if( _OpenOptions.iWidth > 0 )
                pie->put_Width(iWidth);
            if( _OpenOptions.iHeight > 0 )
                pie->put_Height(iHeight);

            if( _OpenOptions.iTop >= 0 )
                pie->put_Top(_OpenOptions.iTop);
            if( _OpenOptions.iLeft >= 0 )
                pie->put_Left(_OpenOptions.iLeft);
        }
    }

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_document(IHTMLDocument2 **ppomDocumentResult)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_document( ppomDocumentResult );
        pWindow->Release( );
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::navigate(BSTR url)
{
    // This will do all the fun things that must be done
    // to an URL before is can be used to navigate.
    return _pAuto->_omloc.put_href( url );
}


/******************************************************************************
get_opener -

    Returns the value of the opener property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_opener(
    /* [retval][out] */ VARIANT *retval)
{
    if( !retval )
        return E_POINTER;

    return VariantCopy( retval, &_varOpener);
}

/******************************************************************************
put_opener -

    Sets the opener property opener of this window. This method may
    be called either internally (from C++ code) or from a script. We must
    Release our current opener if the new opener is valid (or VT_NULL).

    COmWindow's DeInit method ensures this never causes a circular reference
    when this object is in the same thread as "opener".
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::put_opener(VARIANT opener)
{

    // piggy back on put_opener's marshalling to set child flag. This will be called
    // with VT_TYPE==VT_BOOL and a value of 666 only from oncreate(). Chances of this
    // happening from script is very remote.

    if (!_fIsChild && V_VT(&opener) == VT_BOOL && V_BOOL(&opener) == 666)
    {
        _fIsChild = TRUE;
        return S_OK;
    }

    return VariantCopy(&_varOpener, &opener);
}


/******************************************************************************
executScript -

      immediately executes the script passed in. needed for the multimedia
      controls
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::execScript(
    /* [in] */ BSTR bstrCode,
    /* [in] */ BSTR bstrLanguage,
    /* [out] */ VARIANT *pvarRet)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->execScript( bstrCode, bstrLanguage, pvarRet);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onblur(VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onblur( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onblur(
    /* [in] */ VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onblur( v );
        pWindow->Release( );
    }

    return hr;
}

/******************************************************************************
get_onfocus -

    Returns the value of the onfocus property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onfocus(VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onfocus( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onfocus(
    /* [in] */ VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onfocus( v );
        pWindow->Release( );
    }

    return hr;
}

/******************************************************************************
get_onload -

    Returns the value of the onload property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onload(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onload( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onload(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onload( v );
        pWindow->Release( );
    }

    return hr;
}

/******************************************************************************
get_onunload -

    Returns the value of the onunload property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onunload(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onunload( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onunload(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onunload( v );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onbeforeunload(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onbeforeunload( v );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onbeforeunload(VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onbeforeunload( p );
        pWindow->Release( );
    }

    return hr;
}

/******************************************************************************
get_onhelp -

    Returns the value of the onhelp property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onhelp(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onhelp( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onhelp(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onhelp( v );
        pWindow->Release( );
    }

    return hr;
}
/******************************************************************************
get_onresize -

    Returns the value of the resize property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onresize(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onresize( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onresize(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onresize( v );
        pWindow->Release( );
    }

    return hr;
}
/******************************************************************************
get_onscroll -

    Returns the value of the onscroll property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onscroll(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onscroll( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onscroll(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onscroll( v );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_Image(IHTMLImageElementFactory **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_Image( retval );
        pWindow->Release( );
    }

    return hr;
}
/******************************************************************************
get_onerror -

    Returns the value of the onerror property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onerror(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onerror( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onerror(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onerror( v );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_event(IHTMLEventObj **p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_event( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get__newEnum(IUnknown **p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get__newEnum( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::showModalDialog(BSTR dialog,
                                                 VARIANT* varArgIn,
                                                 VARIANT* varOptions,
                                                 VARIANT* varArgOut)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->showModalDialog(dialog, varArgIn, varOptions, varArgOut);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::showHelp(BSTR helpURL, VARIANT helpArg, BSTR features)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->showHelp(helpURL, helpArg, features);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_screen( IHTMLScreen **p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_screen( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_Option(IHTMLOptionElementFactory **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_Option( retval );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::toString(BSTR *Str)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->toString(Str);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::scrollBy(long x, long y)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->scrollBy( x, y );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::scrollTo(long x, long y)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->scrollTo( x, y );
        pWindow->Release( );
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::get_external(IDispatch **ppDisp)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_external(ppDisp);
        pWindow->Release( );
    }

    return hr;
}

// ****  IHTMLWindow3 ****

HRESULT CIEFrameAuto::COmWindow::print()
{
    IHTMLWindow3 *pWindow = NULL;
    HRESULT       hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->print();
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::showModelessDialog(BSTR strUrl,
                                     VARIANT * pvarArgIn,
                                     VARIANT * pvarOptions,
                                     IHTMLWindow2 ** ppDialog)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->showModelessDialog(strUrl,
                                           pvarArgIn,
                                           pvarOptions,
                                           ppDialog);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onbeforeprint(VARIANT v)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onbeforeprint( v );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onbeforeprint(VARIANT *p)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onbeforeprint( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onafterprint(VARIANT v)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_onafterprint( v );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onafterprint(VARIANT *p)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_onafterprint( p );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_screenTop(long *plVal)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_screenTop(plVal);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_screenLeft(long *plVal)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_screenLeft(plVal);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_clipboardData(IHTMLDataTransfer **ppDataTransfer)
{
    IHTMLWindow3 *pWindow = NULL;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_clipboardData(ppDataTransfer);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->attachEvent(event, pDisp, pResult);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::detachEvent(BSTR event, IDispatch* pDisp)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->detachEvent(event, pDisp);
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::setTimeout(
    /* [in] */ VARIANT *pExpression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->setTimeout( pExpression, msec, language, timerID );
        pWindow->Release( );
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::setInterval(
    /* [in] */ VARIANT *pExpression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->setInterval( pExpression, msec, language, timerID );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::moveTo(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();

    if ( !hwnd )
        return S_OK;

    ::SetWindowPos( hwnd, NULL, x, y, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::moveBy(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();
    RECT rcWindow;

    if ( !hwnd )
        return S_OK;

    ::GetWindowRect ( hwnd, &rcWindow );

    ::SetWindowPos( hwnd, NULL, rcWindow.left+x, rcWindow.top+y, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::resizeTo(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();

    if ( !hwnd )
        return S_OK;

    if (x < 100)
        x = 100;

    if (y < 100)
        y = 100;

    ::SetWindowPos( hwnd, NULL, 0, 0, x, y, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::resizeBy(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();
    RECT rcWindow;
    long w, h;

    if ( !hwnd )
        return S_OK;

    ::GetWindowRect ( hwnd, &rcWindow );

    w = rcWindow.right - rcWindow.left + x;
    h = rcWindow.bottom - rcWindow.top + y;

    if (w < 100)
        w = 100;

    if (h < 100)
        h = 100;

    ::SetWindowPos( hwnd, NULL, 0, 0, w, h, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);

    return S_OK;
}


HRESULT CIEFrameAuto::COmWindow::_GetWindowDelegate( IHTMLWindow2 **ppomwDelegate )
{
    if( !ppomwDelegate )
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate( _pAuto, &pRootDisp );
    if( SUCCEEDED(hr) )
    {
        hr = pRootDisp->QueryInterface( IID_IHTMLWindow2, (void**)ppomwDelegate );
        pRootDisp->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::_GetWindowDelegate( IHTMLWindow3 **ppomwDelegate )
{
    if( !ppomwDelegate )
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate( _pAuto, &pRootDisp );
    if( SUCCEEDED(hr) )
    {
        hr = pRootDisp->QueryInterface( IID_IHTMLWindow3, (void**)ppomwDelegate );
        pRootDisp->Release( );
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::SinkDelegate( )
{
    // Force an Unadvise if we already have a connection
    if( _pCP )
        UnsinkDelegate( );

    // If we do not have anyone sinking us, then we don't need to sink our
    // delegate. If someone sinks us later we will sink our delegate in
    // the IConnectionPointCB::OnAdvise callback.
    if (_cpWindowEvents.IsEmpty())
        return S_OK;

    IHTMLWindow2 *pWindow;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        // We have to connect to the event source to get Trident specific events.
      
        hr = ConnectToConnectionPoint(&_wesDelegate, DIID_HTMLWindowEvents, TRUE, pWindow, &_dwCPCookie, &_pCP);

        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::UnsinkDelegate( )
{
    if( _pCP )
    {
        _pCP->Unadvise( _dwCPCookie );
        _pCP->Release();
        _pCP = 0;
        _dwCPCookie = 0;
    }

    return S_OK;
}

/******************************************************************************
 Someone has sinked our events. This means we need to sink the events of our
 delegate docobject if we have not already done so.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::OnAdvise(REFIID iid, DWORD cSinks, ULONG_PTR dwCookie )
{
    HRESULT hr;

    if( !_pCP )
        hr = SinkDelegate( );
    else
        hr = S_OK;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::FireOnUnload( )
{
    HRESULT hr;
    if( _fOnloadFired )
    {
        hr = _cpWindowEvents.InvokeDispid(DISPID_ONUNLOAD);
        _fOnloadFired = FALSE;
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::FireOnLoad( )
{
    HRESULT hr;
    if( !_fOnloadFired )
    {
        hr = _cpWindowEvents.InvokeDispid(DISPID_ONUNLOAD);
        _fOnloadFired = TRUE;
    }
    else
        hr = S_OK;

    return hr;
}

/******************************************************************************
  Check of the docobject document is complete. The document is considered
  complete if either:
    - The document has reached READYSTATE_COMPLETE or
    - The document does not support the DISPID_READYSTATE property

  If the document is not complete, the caller of this method knows the
  delegate supports the READYSTATE property and will receive a future
  READYSTATE_COMPLETE notification.
******************************************************************************/
BOOL CIEFrameAuto::COmWindow::IsDelegateComplete( )
{
    ASSERT( _pAuto );

    BOOL fSupportsReadystate = FALSE;
    BOOL fComplete = FALSE;

    // Check for proper readystate support
    IDispatch *pdispatch;
    if( SUCCEEDED(_pAuto->get_Document( &pdispatch )) )
    {
        VARIANTARG va;
        EXCEPINFO excp;

        if( SUCCEEDED(pdispatch->Invoke( DISPID_READYSTATE,
                                         IID_NULL,
                                         LOCALE_USER_DEFAULT,
                                         DISPATCH_PROPERTYGET,
                                         (DISPPARAMS *)&g_dispparamsNoArgs,
                                         &va,
                                         &excp,
                                         NULL)) )
        {
            fSupportsReadystate = TRUE;

            if( VT_I4 == va.vt && READYSTATE_COMPLETE == va.lVal )
                fComplete = TRUE;
        }

        pdispatch->Release();
    }

    return !fSupportsReadystate || fComplete;
}


STDMETHODIMP CIEFrameAuto::COmWindow::CWindowEventSink::QueryInterface(REFIID riid, void **ppv)
{
    if( IsEqualIID(riid, IID_IUnknown)          ||
             IsEqualIID(riid, IID_IDispatch)    ||
             IsEqualIID(riid, DIID_HTMLWindowEvents)   )
    {
        *ppv = SAFECAST(this, IDispatch* );
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef( );
    return S_OK;
}

/******************************************************************************
 We want to bind the lifetime of our owning object to this object
******************************************************************************/
ULONG CIEFrameAuto::COmWindow::CWindowEventSink::AddRef(void)
{
    COmWindow* pwin = IToClass(COmWindow, _wesDelegate, this);
    return pwin->AddRef();
}

/******************************************************************************
 We want to bind the lifetime of our owning object to this object
******************************************************************************/
ULONG CIEFrameAuto::COmWindow::CWindowEventSink::Release(void)
{
    COmWindow* pwin = IToClass(COmWindow, _wesDelegate, this);
    return pwin->Release();
}

// *** IDispatch ***

STDMETHODIMP CIEFrameAuto::COmWindow::CWindowEventSink::Invoke(
  DISPID dispid,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS *pdispparams,
  VARIANT *pvarResult,
  EXCEPINFO *pexcepinfo,
  UINT *puArgErr        )
{
    HRESULT hr;

    // This object just acts as a pass through for our delegate's
    // window object. Since we interally generated events for both
    //      DISPID_ONLOAD
    //      DISPID_ONUNLOAD
    // we just ignore those that are sourced by our delegate.

    if( DISPID_ONLOAD == dispid ||
        DISPID_ONUNLOAD == dispid       )
    {
        hr = S_OK;
    }
    else
    {
        COmWindow* pwin = IToClass(COmWindow, _wesDelegate, this);
        hr = pwin->_cpWindowEvents.InvokeDispid(dispid);
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::put_offscreenBuffering(VARIANT var)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->put_offscreenBuffering( var );
        pWindow->Release( );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_offscreenBuffering(VARIANT *retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate( &pWindow );

    if( SUCCEEDED(hr) )
    {
        hr = pWindow->get_offscreenBuffering( retval );
        pWindow->Release( );
    }

    return hr;
}


// *** IConnectionPointContainer ***

STDMETHODIMP CIEFrameAuto::COmWindow::FindConnectionPoint( REFIID iid, LPCONNECTIONPOINT *ppCP )
{
    ASSERT( ppCP );

    if (!ppCP )
        return E_POINTER;

    if ( IsEqualIID(iid, DIID_HTMLWindowEvents) || IsEqualIID(iid, IID_IDispatch))
    {
        *ppCP = _cpWindowEvents.CastToIConnectionPoint();
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    (*ppCP)->AddRef();
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmWindow::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1,
            _cpWindowEvents.CastToIConnectionPoint());
}

/******************************************************************************
                    Location Object

// bradsch 11/12/96
// The entire COmLocation object was copied from MSHTML and is a slimy pig
// dog. It should be replaced with the new URL cracking stuff in SHLWAPI.
******************************************************************************/


CIEFrameAuto::COmLocation::COmLocation( ) :
    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE )
{
    ASSERT( !m_bstrFullUrl );
    ASSERT( !m_bstrPort );
    ASSERT( !m_bstrProtocol );
    ASSERT( !m_bstrHostName );
    ASSERT( !m_bstrPath );
    ASSERT( !m_bstrSearch );
    ASSERT( !m_bstrHash );
    ASSERT( FALSE == m_fdontputinhistory );
    ASSERT( FALSE == m_fRetryingNavigate );
}

HRESULT CIEFrameAuto::COmLocation::Init( )
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omloc, this);
    return CAutomationStub::Init( SAFECAST(this, IHTMLLocation*), IID_IHTMLLocation, CLSID_HTMLLocation, pauto );
}

HRESULT CIEFrameAuto::COmLocation::CheckUrl()
{
    BSTR currentUrl = 0;
    HRESULT hr;
    VARIANT varUrl;

    VariantInit(&varUrl);
    hr = _pAuto->_QueryPendingUrl( &varUrl);
    if (FAILED(hr) || varUrl.vt != VT_BSTR || varUrl.bstrVal == NULL)
    {
        VariantClearLazy(&varUrl);
        hr = _pAuto->get_LocationURL( &currentUrl );
    }
    else
    {
        //  No VariantClear, we're extracting the bstrVal
        currentUrl = varUrl.bstrVal;
    }

    if( SUCCEEDED(hr) )
    {
        // If our stashed URL does not match the real current URL we need to reparse everything
        if( !m_bstrFullUrl || StrCmpW( m_bstrFullUrl, currentUrl ) )
        {
            // This code is all going to change, so I am not worried about efficiency
            FreeStuff( );

            m_bstrFullUrl = currentUrl;

            hr = ParseUrl();
        }
        else
            SysFreeString( currentUrl );
    }

    return hr;
}

HRESULT CIEFrameAuto::COmLocation::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    ASSERT( !IsEqualIID(riid, IID_IUnknown) );

    if (IsEqualIID(riid, IID_IHTMLLocation))
        *ppv = SAFECAST(this, IHTMLLocation *);
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *ppv = SAFECAST(this, IObjectIdentity *);
    else if (IsEqualIID(riid, IID_IObjectIdentity))
        *ppv = SAFECAST(this, IServiceProvider *);
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}

HRESULT CIEFrameAuto::COmLocation::_GetIDispatchExDelegate( IDispatchEx ** const delegate )
{
    if( !delegate )
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate( _pAuto, &pRootDisp );
    if( SUCCEEDED(hr) )
    {
        IDispatch *pDelegateDisp = 0;
        hr = GetDelegateOnIDispatch( pRootDisp, DISPID_LOCATIONOBJECT, &pDelegateDisp );
        pRootDisp->Release();

        if( SUCCEEDED(hr) )
        {
            hr = pDelegateDisp->QueryInterface( IID_IDispatchEx, (void**)delegate );
            pDelegateDisp->Release( );
        }
    }

    return hr;
}


/****************************************************************************
 IObjectIdentity  member implemtnation. this is necessary since mshtml has a locatino
 proxy that it returns, whichc is a different pUnk than the location object returned by
 shdocvw.  The script engines use this interface to resolve the difference and allow
 equality test to be perfomed on these objects.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::IsEqualObject(IUnknown * pUnk)
{
    HRESULT hr;
    IServiceProvider * pISP = NULL;
    IHTMLLocation    * pLoc = NULL;
    IUnknown         * pUnkThis = NULL;
    IUnknown         * pUnkTarget = NULL;

    if (!pUnk)
        return E_POINTER;

    hr = pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pISP->QueryService(IID_IHTMLLocation, IID_IHTMLLocation, (void**)&pLoc);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pLoc->QueryInterface(IID_IUnknown, (void**)&pUnkTarget);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = QueryInterface(IID_IUnknown, (void**)&pUnkThis);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = (pUnkThis == pUnkTarget) ? S_OK : S_FALSE;

Cleanup:
    if (pISP)        ATOMICRELEASE(pISP);
    if (pLoc)        ATOMICRELEASE(pLoc);
    if (pUnkTarget)  ATOMICRELEASE(pUnkTarget);
    if (pUnkThis)    ATOMICRELEASE(pUnkThis);

    return hr;
}

/*****************************************************************************
 IServiceProvider - this is currently only used by the impl of ISEqual object
 on mshtml side,. adn only needs to return *this* when Queryied for location
 service
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (IsEqualGUID(guidService, IID_IHTMLLocation))
    {
        *ppv = SAFECAST(this, IHTMLLocation *);
        hr = S_OK;
    }

    return hr;
}

/******************************************************************************
 Helper function for the property access functions
 Makes sure that the URL has been parsed and returns a copy
 of the requested field as a BSTR.
******************************************************************************/
HRESULT CIEFrameAuto::COmLocation::GetField(BSTR* bstrField, BSTR* pbstr)
{
    HRESULT hr;

    if (!pbstr)
        return E_INVALIDARG;

    if (!bstrField)
        return E_FAIL;

    hr = CheckUrl( );
    if( FAILED(hr) )
        return hr;

    *pbstr = *bstrField ? SysAllocString(*bstrField): SysAllocString(L"");
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CIEFrameAuto::COmLocation::toString (BSTR* pbstr)
{
    return GetField(&m_bstrFullUrl, pbstr);
}


STDMETHODIMP CIEFrameAuto::COmLocation::get_href(BSTR* pbstr)
{
    return GetField(&m_bstrFullUrl, pbstr);
}


STDMETHODIMP CIEFrameAuto::COmLocation::get_protocol(BSTR* pbstr)
{
    return GetField(&m_bstrProtocol, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_hostname(BSTR* pbstr)
{
    return GetField(&m_bstrHostName, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_host(BSTR* pbstr)
{
    HRESULT            hr;
    INT                cch;
    BOOL               fHavePort;

    hr = CheckUrl( );
    if( FAILED(hr) )
        return hr;

    if( !m_bstrHostName )
        return E_POINTER;

    cch = lstrlenW(m_bstrHostName);
    fHavePort = m_bstrPort && *m_bstrPort;
    if (fHavePort)
        cch += lstrlenW(m_bstrPort) + 1; // for the ":"

    *pbstr = SafeSysAllocStringLen( 0, cch );

    if( !*pbstr )
        return E_OUTOFMEMORY;

    // Get the hostname
    StrCpyNW( *pbstr, m_bstrHostName, cch + 1);

    // add additional character for colon
    // concatenate ":" and the port number, if there is a port number
    if (fHavePort)
    {
        StrCatBuffW(*pbstr, L":", cch + 1);
        StrCatBuffW(*pbstr, m_bstrPort, cch + 1);
    }

    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_pathname(BSTR* pbstr)
{
    // Hack for Netscape compatability -- not in Nav3 or nav4.maybe in nav2?
    // Netscape returned nothing for a path of "/"
    // we used to do this but it looks like we should follow nav3/4 now (for OMCOMPAT)

    return GetField(&m_bstrPath, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_search(BSTR* pbstr)
{
    return GetField(&m_bstrSearch, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_hash(BSTR* pbstr)
{
    return GetField(&m_bstrHash, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_port(BSTR* pbstr)
{
    return GetField(&m_bstrPort, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::reload(VARIANT_BOOL fFlag)
{
    VARIANT v = {0};
    v.vt = VT_I4;
    v.lVal = fFlag ?
        OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_CLEARUSERINPUT :
        OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT;
    return _pAuto->Refresh2( &v );
}

STDMETHODIMP CIEFrameAuto::COmLocation::replace( BSTR url )
{
    m_fdontputinhistory = TRUE;
    return put_href( url );
}

STDMETHODIMP CIEFrameAuto::COmLocation::assign( BSTR url )
{
    return put_href( url );
}

void CIEFrameAuto::COmLocation::RetryNavigate()
{
    //
    // If a page does a navigate on an unload event and the unload is happening
    // because the user shutdown the browser we would recurse to death.
    // m_fRetryingNavigate was added to fix this scenario.
    //

    if (m_fPendingNavigate && !m_fRetryingNavigate)
    {
        m_fRetryingNavigate = TRUE;
        DoNavigate();
        m_fRetryingNavigate = FALSE;
    }
}

//
//
// PrvHTParse - wrapper for Internet{Canonicalize/Combine}Url
//           which does a local allocation of our returned string so we can
//           free it as needed.
//
//
//   We start by calling InternetCanonicalizeUrl() to perform any required
//   canonicalization.  If the caller specificed PARSE_ALL, we're done at that
//   point and return the URL.  This is the most common case.
//
//   If the caller wanted parts of the URL, we will then call
//   InternetCrackUrl() to break the URL into it's components, and
//   finally InternetCreateUrl() to give us a string with just those
//   components.
//
//   ICU() has a bug which forces it to always prepend a scheme, so we have
//   some final code at the end which removes the scheme if the caller
//   specifically did not want one.
//

#define STARTING_URL_SIZE        127           // 128 minus 1
#define PARSE_ACCESS            16
#define PARSE_HOST               8
#define PARSE_PATH               4
#define PARSE_ANCHOR             2
#define PARSE_PUNCTUATION        1
#define PARSE_ALL               31

BSTR PrvHTParse( BSTR bstraName, BSTR bstrBaseName, int wanted)
{
    DWORD cchP = STARTING_URL_SIZE+1;
    DWORD cchNeed = cchP;
    BOOL      rc;
    HRESULT hr;

    if ((!bstraName && !bstrBaseName))
        return NULL;

    WCHAR *p = new WCHAR[cchP];
    if (!p)
        return NULL;

    // ICU() does not accept NULL pointers, but it does handle "" strings
    if (!bstrBaseName)
        bstrBaseName = L"";
    if (!bstraName)
        bstraName = L"";

    URL_COMPONENTSW uc;
    ZeroMemory (&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);

    // We will retry once if the failure was due to an insufficiently large buffer
    hr = UrlCombineW(bstrBaseName, bstraName, p, &cchNeed, 0);
    if (hr == E_POINTER)
    {
        // From the code, cchNeed has the same value as if UrlCombine had succeeded, 
        // which is the length of the combined URL, excluding the null.

        cchP = ++cchNeed;
        delete [] p;
        p = NULL;
        p = new WCHAR[cchP];
        if(!p)
            goto free_and_exit;
        hr = UrlCombineW(bstrBaseName, bstraName, p, &cchNeed, 0);
    }


    // bradsch 11/1/96 shouldn't we check hr again??  zekel - yes <g>


    if (wanted != PARSE_ALL)
    {
        // Since CreateUrl() will ignore our request to not add a scheme,
        // we always ask it to crack one, so we can know the size if we need
        // to remove it ourselves
        uc.dwSchemeLength = INTERNET_MAX_SCHEME_LENGTH;
        uc.lpszScheme = new WCHAR[uc.dwSchemeLength];

        if (wanted & PARSE_HOST) {
            uc.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;
            uc.lpszHostName = new WCHAR[uc.dwHostNameLength];
        }
        if (wanted & PARSE_PATH) {
            uc.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
            uc.lpszUrlPath = new WCHAR[uc.dwUrlPathLength];
        }
        if (wanted & PARSE_ANCHOR) {
            uc.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;
            uc.lpszExtraInfo = new WCHAR[uc.dwExtraInfoLength];
        }

        // if any of our allocations fail, fail the whole operation.
        if ( (!uc.lpszScheme) ||
             ((wanted & PARSE_HOST) && (!uc.lpszHostName)) ||
             ((wanted & PARSE_PATH) && (!uc.lpszUrlPath)) ||
             ((wanted & PARSE_ANCHOR) && (!uc.lpszExtraInfo)) )
            goto free_and_exit;

        rc = InternetCrackUrlW(p, cchNeed, 0, &uc);
        // If we are failing here, we need to figure out why and fix it
        if (!rc)
        {
            //TraceMsg(TF_WARNING, TEXT("PrvHTParse: InternetCrackUrl failed for \"\""), Dbg_SafeStr(p));
            goto free_and_exit;   // Couldn't crack it, so give back what we can
        }

        // InternetCreateUrlW takes in a count of WCHARs but if it 
        // fails, the same variable is set to a count of bytes.  So we'll 
        // call this variable the ambiguous dwLength.  Yuck.

        cchNeed = cchP;
        DWORD dwLength = cchNeed;

        rc = InternetCreateUrlW(&uc, 0, p, &dwLength);
        if (!rc)
        {
            delete [] p;
            p = NULL;
            const DWORD err = GetLastError();
            if ((ERROR_INSUFFICIENT_BUFFER == err) && (dwLength > 0))
            {
                // dwLength comes out in bytes.  We'll turn it into a char count
                // The previous ANSI version allocated one char too many 
                // but it's too risky to correct that now

                dwLength /= sizeof(WCHAR);   
                cchP = ++dwLength;  

                p = new WCHAR[cchP];
                if( !p )
                    goto free_and_exit;
                rc = InternetCreateUrlW(&uc, 0, p, &dwLength);
            }
        }  // if !rc   

        if (rc)
        {
            // The most recent InternetCreateUrl was successful, so dwLength contains
            // the number of wide chars stored in p.
            cchNeed = dwLength;

            // Special case: remove protocol if not requested.  ICU() adds
            // a protocol even if you tell it not to.

            if (!(wanted & PARSE_ACCESS))
            {
               WCHAR *q;

               // Make sure our string is sufficiently large for
               ASSERT(cchNeed > uc.dwSchemeLength);

               // For non-pluggable protocols, Add 3 for the ://, which is not counted in the scheme length, else add 1
               int cch = lstrlenW(p + uc.dwSchemeLength + ((uc.nScheme == INTERNET_SCHEME_UNKNOWN) ? 1 : 3)) + 1;
               q = new WCHAR[cch];
               if (q)
               {
                   StrCpyNW( q, (p + uc.dwSchemeLength + ((uc.nScheme == INTERNET_SCHEME_UNKNOWN) ? 1 : 3)), cch);
                   delete [] p;
                   p = q;
                   q = NULL;   // no accidental free later
               }
            }
            else
            {
                if ( (wanted & (~PARSE_PUNCTUATION)) == PARSE_ACCESS)
                {
                    // Special case #2: When only PARSE_ACCESS is requested,
                    // don't return the // suffix
                    p[uc.dwSchemeLength + 1] = '\0';
                }
            }
        }

    } // if wanted

free_and_exit:
    delete [] uc.lpszScheme;
    delete [] uc.lpszHostName;
    delete [] uc.lpszUrlPath;
    delete [] uc.lpszExtraInfo;

    BSTR bstrp = 0;
    if( p )
    {
        bstrp = SysAllocString( p );
        delete [] p;
    }

    return bstrp;
}


STDMETHODIMP CIEFrameAuto::COmLocation::put_href( BSTR url )
{
    HRESULT hr;

    if( !url )
        return E_INVALIDARG;

    // Call CheckUrl before PrvHTParse to ensure we have a valid URL
    hr = CheckUrl( );
    if( FAILED(hr) )
        return hr;

    BSTR bstrUrlAbsolute = PrvHTParse(url, m_bstrFullUrl, PARSE_ALL);

    if( !bstrUrlAbsolute  )
        return E_OUTOFMEMORY;

    // Actually set the URL field
    hr = SetField(&m_bstrFullUrl, bstrUrlAbsolute, FALSE);

    SysFreeString( bstrUrlAbsolute );

    return hr;
}


STDMETHODIMP CIEFrameAuto::COmLocation::put_protocol(BSTR bstr)
{
    return SetField(&m_bstrProtocol, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_hostname(BSTR bstr)
{
    return SetField(&m_bstrHostName, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_host(BSTR bstr)
{
    HRESULT hr = S_OK;
    WCHAR* colonPos = 0;
    WCHAR* portName = NULL;
    WCHAR* hostName = NULL;

    hr = CheckUrl( );
    if( FAILED(hr) )
        return hr;

    // Parse out the hostname and port and store them in
    // the appropriate fields
    colonPos = StrChrW(bstr, L':');
    // Copy the characters up to the colon in the
    // hostname field

    if (colonPos == 0)
    {
        hostName = SysAllocString(bstr);
        portName = SysAllocString(L"");
    }
    else
    {
        hostName = SafeSysAllocStringLen(bstr, (unsigned int)(colonPos-bstr));
        portName = SafeSysAllocStringLen(colonPos+1, SysStringLen(bstr) - (unsigned int)(colonPos-bstr+1));
    }

    if( hostName && portName )
    {
        if( m_bstrHostName )
            SysFreeString( m_bstrHostName );
        if( m_bstrPort )
            SysFreeString( m_bstrPort );

        m_bstrHostName = hostName;
        m_bstrPort = portName;

        hostName = portName = 0;

        hr = ComposeUrl();
        if( SUCCEEDED(hr) )
        {
            hr = DoNavigate( );
        }
    }
    else
        hr = E_OUTOFMEMORY;


    if (hostName)
        SysFreeString(hostName);

    if (portName)
        SysFreeString(portName);

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_pathname(BSTR bstr)
{
    return SetField(&m_bstrPath, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_search(BSTR bstr)
{
    if (!bstr)
        return E_POINTER;

    // If the provided search string begins with a "?" already,
    // just use it "as is"
    if (bstr[0] == L'?')
    {
        return SetField(&m_bstrSearch, bstr, TRUE);
    }
    // Otherwise prepend a question mark
    else
    {
        // Allocate enough space for the string plus one more character ('#')
        BSTR bstrSearch = SafeSysAllocStringLen(L"?", lstrlenW(bstr) + 1);
        if (!bstrSearch)
            return E_OUTOFMEMORY;
        StrCatW(bstrSearch, bstr);
        HRESULT hr = SetField(&m_bstrSearch, bstrSearch, TRUE);
        SysFreeString(bstrSearch);
        return hr;
    }
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_hash(BSTR bstr)
{
    if (!bstr)
        return E_POINTER;

    // If the provided hash string begins with a "#" already,
    // just use it "as is"
    if (bstr[0] == L'#')
    {
        return SetField(&m_bstrHash, bstr, TRUE);
    }
    // Otherwise prepend a pound sign
    else
    {
        // Allocate enough space for the string plus one more character ('#')
        BSTR bstrHash = SafeSysAllocStringLen(L"#", lstrlenW(bstr) + 1);
        if (!bstrHash)
            return E_OUTOFMEMORY;
        StrCatW(bstrHash, bstr);
        HRESULT hr = SetField(&m_bstrHash, bstrHash, TRUE);
        SysFreeString(bstrHash);
        return hr;
    }
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_port(BSTR bstr)
{
    return SetField(&m_bstrPort, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::PrivateGet_href(BSTR* pbstr, BOOL *fdontputinhistory)
{
    *fdontputinhistory = m_fdontputinhistory;
    return GetField(&m_bstrFullUrl, pbstr);
}

/******************************************************************************
// Helper function for the property setting functions
// Makes sure that the URL has been parsed
// Sets the field to its new value
// recomposes the URL, IF fRecomposeUrl is true
// If part of a window, tells the window to go to the new URL
//
// @todo JavaScript has some funky behavior on field setting--
// for example, the protocol field can be set to an entire URL.
// We need to make sure this functionality is duplicated
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::SetField(BSTR* field, BSTR newval, BOOL fRecomposeUrl)
{
    HRESULT hr = S_OK;
    BSTR valCopy = 0;

    hr = CheckUrl( );
    if( FAILED(hr) )
        return hr;

    // Copy the current URL!
    BSTR bstrCurrentURL = SysAllocString(m_bstrFullUrl);

    // Make a copy of the new value
    valCopy = SysAllocString(newval);
    if (valCopy == 0)
        return E_OUTOFMEMORY;

    // free the old value of field and set it to point to the new string
    if (*field)
        SysFreeString(*field);
    *field = valCopy;
    valCopy = NULL;

    // Put together a new URL based on its constituents, if requested
    if (fRecomposeUrl)
        hr = ComposeUrl( );

    if( SUCCEEDED(hr) )
    {
        if (bstrCurrentURL)
        {
            // If the new url is the same as the previous url then we want to navigate but not have it
            // add to the history!
            if (StrCmpW(bstrCurrentURL,m_bstrFullUrl) == 0)
            {
                m_fdontputinhistory = TRUE;
            }

            //
            //clean up the old stuff before navigation
            //
            valCopy = SysAllocString(m_bstrFullUrl);

            FreeStuff( );

            // valCopy can be NULL. does everybody else handle
            // the NULL m_bstrFullUrl case?
            m_bstrFullUrl = valCopy;
            valCopy = NULL;

            ParseUrl();

            SysFreeString(bstrCurrentURL);
        }

        // Go to the new URL
        hr = DoNavigate();
    }

    if (FAILED(hr) && valCopy )
        SysFreeString(valCopy);

    return hr;
}

/******************************************************************************
// Derive a new m_bstrUrl and m_bstrFullUrl from its constituents
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::ComposeUrl()
{
    BSTR bstrUrl = 0;

    HRESULT hr = S_OK;

    ULONG len =
        SysStringLen(m_bstrProtocol) +
        2 +                                    // //
        SysStringLen(m_bstrHostName) +
        1 +                                    // trailing /
        SysStringLen(m_bstrPort) +
        1 +                                 // :
        SysStringLen(m_bstrPath) +
        1 +                                 // Possible leading /
        (m_bstrSearch ? 1 : 0) +            // ?
        SysStringLen(m_bstrSearch) +
        (m_bstrHash ? 1 : 0) +                // #
        SysStringLen(m_bstrHash) +
        10;                                    // Trailing Termination + some slop

    bstrUrl = SafeSysAllocStringLen(L"", len);
    if (!bstrUrl)
        return E_OUTOFMEMORY;

    StrCatW(bstrUrl, m_bstrProtocol);
    StrCatW(bstrUrl, L"//");
    StrCatW(bstrUrl, m_bstrHostName);

    if (lstrlenW(m_bstrPort))
    {
        StrCatW(bstrUrl, L":");
        StrCatW(bstrUrl, m_bstrPort);
    }

    if (lstrlenW(m_bstrPath))
    {
        // prepend the leading slash if needed
        if (m_bstrPath[0] != '/')
            StrCatW(bstrUrl, L"/");
        StrCatW(bstrUrl, m_bstrPath);
    }

    if (lstrlenW(m_bstrSearch) > 0)
    {
        StrCatW(bstrUrl, m_bstrSearch);
    }
    if (lstrlenW(m_bstrHash) > 0)
    {
        StrCatW(bstrUrl, m_bstrHash);
    }

    // OK, everything has succeeded
    // Assign to member variables
    if (m_bstrFullUrl)
        SysFreeString(m_bstrFullUrl);
    m_bstrFullUrl = bstrUrl;

    return hr;
}

BSTR CIEFrameAuto::COmLocation::ComputeAbsoluteUrl( BSTR bstrUrlRelative )
{
    if( FAILED(CheckUrl()) )
        return 0;

    return PrvHTParse(bstrUrlRelative, m_bstrFullUrl, PARSE_ALL);
}


/******************************************************************************
// Tell the window to go to the current URL
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::DoNavigate()
{
    VARIANT v1;
    v1.vt    = VT_ERROR;
    v1.scode = DISP_E_PARAMNOTFOUND;

    if (m_fdontputinhistory)
    {
        v1.vt = VT_I4;
        v1.lVal = navNoHistory;

        // Reset the flag.
        m_fdontputinhistory = FALSE;
    }

    HRESULT hres = _pAuto->Navigate(m_bstrFullUrl, &v1, PVAREMPTY, PVAREMPTY, PVAREMPTY);

    if (hres == HRESULT_FROM_WIN32(ERROR_BUSY))
    {
        hres = S_OK;
        m_fPendingNavigate = TRUE;
    }
    else
        m_fPendingNavigate = FALSE;
    return hres;
}

/******************************************************************************
// Parse a URL into its constituents and store them in member variables
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::ParseUrl()
{
    HRESULT hr = S_OK;
    BSTR szProtocol = 0,
         szHost = 0,
         szPath = 0,
         szSearch = 0,
         szHash = 0,
         searchPos = 0,
         portPos = 0,
         hashPos = 0;

    m_bstrSearch = NULL;


    // Strip out the search string and the hash string from the URL--
    // the parser is too dumb to recognize them
    searchPos = StrChrW(m_bstrFullUrl, L'?');
    hashPos = StrChrW(m_bstrFullUrl, L'#');
    if( searchPos )
        *searchPos = 0;
    if( hashPos )
        *hashPos = 0;

    // Get the search string
    if( searchPos )
    {
        *searchPos = L'?';  // temporarily restore the search prefix
        m_bstrSearch = SysAllocString(searchPos);
        *searchPos = 0; // take it away again so it doesn't cause confusion
    }
    else
    {
        m_bstrSearch = SysAllocString(L"");
    }
    if (NULL == m_bstrSearch)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    // Get the anchor string, including the '#' prefix
    if( hashPos )
    {
        *hashPos = L'#';  // temporarily restore the anchor prefix
        m_bstrHash = SysAllocString( hashPos );
        *hashPos = 0; // take it away again so it doesn't cause confusion
    }
    else
    {
        m_bstrHash = SysAllocString( L"" );
    }
    if (NULL == m_bstrHash)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Both m_bstrSearch and m_bstrHash can be NULL at this point
    // does all the affected code handle this case?
    // note there are more cases like this below (m_bstrProtocol for example)

    // Parse the protocol
    szProtocol = PrvHTParse(m_bstrFullUrl, 0, PARSE_ACCESS | PARSE_PUNCTUATION);
    if( !szProtocol )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_bstrProtocol = SysAllocString( szProtocol );
    if (NULL == m_bstrProtocol)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    // Parse the host name and port number (if any)

    // First look for a port
    szHost = PrvHTParse(m_bstrFullUrl, 0, PARSE_HOST);
    if( !szHost )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    portPos = StrChrW(szHost, L':');
    if (portPos)
    {
        m_bstrHostName = SafeSysAllocStringLen( szHost, (unsigned int)(portPos-szHost));
        m_bstrPort = SysAllocString( portPos + 1 );
    }
    else
    {
        m_bstrHostName = SysAllocString( szHost );
        m_bstrPort = SysAllocString( L"" );
    }

    if (NULL == m_bstrHostName || NULL == m_bstrPort)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Parse the path and search string (if any)
    szPath = PrvHTParse(m_bstrFullUrl, 0, PARSE_PATH);
    if( !szPath )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // If the path doesn't start with a '/' then prepend one - Netscape compatibility
    if (StrCmpIW(szProtocol, L"javascript:") && StrCmpIW(szProtocol, L"vbscript:") && szPath[0] != L'/')
    {
        WCHAR *szPath2 = szPath;
        szPath = SafeSysAllocStringLen( 0, lstrlenW(szPath2)+2 );
        if(szPath)
        {
            szPath[0] = L'/';
            szPath[1] = L'\0';
            StrCatW(szPath,szPath2);
            szPath[ lstrlenW(szPath2) + 2 ] = 0;
            SysFreeString( szPath2 );
        }
        else
            szPath = szPath2;
    }

    m_bstrPath = SysAllocString( szPath );
    if (NULL == m_bstrPath)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


exit:
    // Restore hash and search characters
    if( searchPos )
        *searchPos =  L'?';
    if( hashPos )
        *hashPos = L'#';

    // Have to free these using SysFreeString because they come from PrvHTParse
    if (szProtocol)
        SysFreeString(szProtocol);
    if (szHost)
        SysFreeString(szHost);
    if (szPath)
        SysFreeString(szPath);
    if (szHash)
        SysFreeString(szHash);
    return hr;
}

CIEFrameAuto::COmLocation::~COmLocation()
{
    FreeStuff( );
}

HRESULT CIEFrameAuto::COmLocation::FreeStuff( )
{
    if(m_bstrFullUrl)
    {
        SysFreeString( m_bstrFullUrl );
        m_bstrFullUrl = 0;
    }
    if(m_bstrProtocol)
    {
        SysFreeString( m_bstrProtocol );
        m_bstrProtocol = 0;
    }
    if(m_bstrHostName)
    {
        SysFreeString( m_bstrHostName );
        m_bstrHostName = 0;
    }
    if(m_bstrPort)
    {
        SysFreeString( m_bstrPort );
        m_bstrPort = 0;
    }
    if(m_bstrPath)
    {
        SysFreeString( m_bstrPath );
        m_bstrPath = 0;
    }
    if(m_bstrSearch)
    {
        SysFreeString( m_bstrSearch );
        m_bstrSearch = 0;
    }
    if(m_bstrHash)
    {
        SysFreeString( m_bstrHash );
        m_bstrHash = 0;
    }
    return S_OK;
}

/******************************************************************************
                    Navigator Object
******************************************************************************/


CIEFrameAuto::COmNavigator::COmNavigator() :
    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE )
{
    ASSERT( !_UserAgent );
    ASSERT( FALSE == _fLoaded );
}

HRESULT CIEFrameAuto::COmNavigator::Init(CMimeTypes *pMimeTypes, CPlugins *pPlugins, COpsProfile *pProfile)
{
    ASSERT(pMimeTypes != NULL);
    _pMimeTypes = pMimeTypes;
    ASSERT(pPlugins != NULL);
    _pPlugins = pPlugins;
    ASSERT(pProfile != NULL);
    _pProfile = pProfile;

    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omnav, this);
    return CAutomationStub::Init( SAFECAST(this, IOmNavigator*), IID_IOmNavigator, CLSID_HTMLNavigator, pauto );
}

/******************************************************************************
// bradsc 11/5/97
// This method should not use hard coded values. Where can we get this info?

// This method has to use non-unicode junk because of Win95
******************************************************************************/
HRESULT CIEFrameAuto::COmNavigator::LoadUserAgent( )
{
    _fLoaded = TRUE;

    CHAR    szUserAgent[MAX_PATH];  // URLMON says the max length of the UA string is MAX_PATH
    DWORD   dwSize = MAX_PATH;

    szUserAgent[0] = '\0';

    if ( ObtainUserAgentString( 0, szUserAgent, &dwSize ) == S_OK )
    {

        // Just figure out the real length since 'size' is ANSI bytes required.
        //
        _UserAgent = SysAllocStringFromANSI( szUserAgent );
    }

    return _UserAgent ? S_OK : E_FAIL;
}

HRESULT CIEFrameAuto::COmNavigator::_InternalQueryInterface( REFIID riid, void ** const ppv )
{
    ASSERT( !IsEqualIID(riid, IID_IUnknown) );

    if( IsEqualIID(riid, IID_IOmNavigator) )
        *ppv = SAFECAST(this, IOmNavigator *);
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}


STDMETHODIMP CIEFrameAuto::COmNavigator::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
{
    HRESULT hr = CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr );

    if ( hr == DISP_E_MEMBERNOTFOUND
        && (wFlags & DISPATCH_PROPERTYGET)
        && dispid == DISPID_VALUE
        && pvarResult != NULL && dispparams->cArgs == 0)
    {
        pvarResult->vt = VT_BSTR;
        pvarResult->bstrVal = SysAllocString(L"[object Navigator]");
        hr = pvarResult->bstrVal ? S_OK : E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::_GetIDispatchExDelegate( IDispatchEx ** const delegate )
{
    if( !delegate )
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate( _pAuto, &pRootDisp );
    if( SUCCEEDED(hr) )
    {
        IDispatch *pDelegateDisp = 0;
        hr = GetDelegateOnIDispatch( pRootDisp, DISPID_NAVIGATOROBJECT, &pDelegateDisp );
        pRootDisp->Release();

        if( SUCCEEDED(hr) )
        {
            hr = pDelegateDisp->QueryInterface( IID_IDispatchEx, (void**)delegate );
            pDelegateDisp->Release( );
        }
    }

    return hr;
}

// All of these have hard-coded lengths and locations

STDMETHODIMP CIEFrameAuto::COmNavigator::get_appCodeName( BSTR* retval )
{
    HRESULT hr;

    if (retval)
    {
        if( !_fLoaded )
            LoadUserAgent( );

        if(_UserAgent )
        {
            *retval = SafeSysAllocStringLen( _UserAgent, 7 );
            hr = S_OK;
        }
        else
        {
            *retval = SysAllocString( APPCODENAME );
            hr = *retval ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

/******************************************************************************
// bradsch 11/8/96
// We should read this out of the registry instead of hard coding!!
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmNavigator::get_appName( BSTR* retval )
{
    *retval = SysAllocString( MSIE );
    return *retval ? S_OK : E_OUTOFMEMORY;
}

/******************************************************************************
// Netscape defined appVersion to be everything after
// the first 8 characters in the userAgent string.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmNavigator::get_appVersion(BSTR* retval)
{
    if (retval)
    {
        if( !_fLoaded )
            LoadUserAgent( );

        if( _UserAgent )
        {
            // If _UserAgent is less than 8 characters the registry is messed up.
            // If _UserAgent is exactly 8 characters we will just return a NULL string.
            if( lstrlenW(_UserAgent) < 8 )
                *retval = SysAllocString( L"" );
            else
                *retval = SysAllocString( _UserAgent + 8 );

            return *retval ? S_OK : E_OUTOFMEMORY;
        }
        *retval = SysAllocString( APPVERSION );
        return *retval ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        return S_FALSE;
    }
}

STDMETHODIMP CIEFrameAuto::COmNavigator::get_userAgent(BSTR* retval)
{
    if (retval)
    {
        if( !_fLoaded )
            LoadUserAgent( );

        if(_UserAgent )
        {
            *retval = SysAllocString( _UserAgent );
        }
        else
        {
            *retval = SysAllocString( USERAGENT );
        }

        return *retval ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        return S_FALSE;
    }
}

STDMETHODIMP CIEFrameAuto::COmNavigator::get_cookieEnabled(VARIANT_BOOL* enabled)
{
    HRESULT hr = E_POINTER;

    if (enabled)
    {
        BSTR    strUrl;

        *enabled =  VARIANT_FALSE;

        hr = _pAuto->_omloc.get_href(&strUrl);
        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy;

            if (SUCCEEDED(ZoneCheckUrlExW(strUrl, &dwPolicy, sizeof(dwPolicy), NULL, NULL,
                                        URLACTION_COOKIES_ENABLED, PUAF_NOUI, NULL)) &&
                (URLPOLICY_DISALLOW != dwPolicy))
            {
                *enabled = VARIANT_TRUE;
            }

            SysFreeString(strUrl);
        }
        else
            ASSERT(!strUrl);    // If this failed and strUrl isn't NULL, then we are leaking.
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmNavigator::javaEnabled(VARIANT_BOOL* enabled)
{
    HRESULT hr = E_POINTER;

    if (enabled)
    {
        BSTR    strUrl;

        *enabled =  VARIANT_FALSE;

        hr = _pAuto->_omloc.get_href(&strUrl);

#ifdef UNIX
        if (SUCCEEDED(hr) &&
            StrStr((LPCTSTR)strUrl, L"/exchange/calendar/pick.asp"))
        {
            SysFreeString(strUrl);
            return hr;
        }
#endif //UNIX
        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy;

            if (SUCCEEDED(ZoneCheckUrlExW(strUrl, &dwPolicy, sizeof(dwPolicy), NULL, NULL,
                                        URLACTION_JAVA_PERMISSIONS, PUAF_NOUI, NULL)) &&
                (URLPOLICY_JAVA_PROHIBIT != dwPolicy))
            {
                *enabled = VARIANT_TRUE;
            }

            SysFreeString(strUrl);
        }
        else
            ASSERT(!strUrl);    // If this failed and strUrl isn't NULL, then we are leaking.
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmNavigator::taintEnabled (VARIANT_BOOL *pfEnabled)
{
    if(pfEnabled)
    {
        *pfEnabled = VARIANT_FALSE;
    }
    else
        return E_POINTER;


    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmNavigator::get_mimeTypes (IHTMLMimeTypesCollection**ppMimeTypes)
{
    if(ppMimeTypes)
    {
        *ppMimeTypes = _pMimeTypes;
        _pMimeTypes->AddRef();
        return S_OK;
    }
    else
        return E_POINTER;
}

/******************************************************************************
//  member: toString method
//  Synopsis : we need to invoke on dispid_value, and coerce the result into
//       a bstr.
//
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmNavigator::toString(BSTR * pbstr)
{
    HRESULT hr = E_POINTER;

    if (pbstr)
    {
       *pbstr= SysAllocString( L"[object Navigator]" );

       if (!*pbstr)
           hr = E_OUTOFMEMORY;
       else
           hr = S_OK;
    }

    return hr;
}



CIEFrameAuto::CCommonCollection::CCommonCollection( ) :
    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE )
{
}


HRESULT CIEFrameAuto::CMimeTypes::Init()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _mimeTypes, this);
    return CAutomationStub::Init( SAFECAST(this, IHTMLMimeTypesCollection*), IID_IHTMLMimeTypesCollection,
                        CLSID_CMimeTypes, pauto );
}

HRESULT CIEFrameAuto::CCommonCollection::_GetIDispatchExDelegate( IDispatchEx ** const delegate )
{
    if( !delegate )
        return E_POINTER;

    // We do not handle expandos yet
    *delegate = NULL;

    return DISP_E_MEMBERNOTFOUND;
}

HRESULT CIEFrameAuto::CMimeTypes::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    if( IsEqualIID(riid, IID_IHTMLMimeTypesCollection) )
        *ppv = SAFECAST(this, IHTMLMimeTypesCollection *);
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}


HRESULT CIEFrameAuto::CCommonCollection::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;

    hr = CAutomationStub::GetDispID(bstrName, grfdex, pid);

    if(hr == DISP_E_MEMBERNOTFOUND)
    {
        // We ignore the command we do not understand
        *pid = DISPID_UNKNOWN;
        hr = S_OK;
    }

    return hr;
}

HRESULT CIEFrameAuto::CCommonCollection::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    if(id == DISPID_UNKNOWN && pvarRes)
    {
        V_VT(pvarRes) = VT_EMPTY;
        return S_OK;
    }

    return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
}


HRESULT CIEFrameAuto::CCommonCollection::get_length(LONG* pLength)
{
    if(pLength == NULL)
        return E_POINTER;

    *pLength = 0;
    return S_OK;
}

HRESULT CIEFrameAuto::COmNavigator::get_plugins (IHTMLPluginsCollection **ppPlugins)
{
    if(ppPlugins)
    {
        *ppPlugins = _pPlugins;
        _pPlugins->AddRef();
        return S_OK;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_opsProfile (IHTMLOpsProfile **ppOpsProfile)
{
    if(ppOpsProfile)
    {
        *ppOpsProfile = _pProfile;
        (*ppOpsProfile)->AddRef();
        return S_OK;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_cpuClass(BSTR * p)
{
    if (p)
    {
        SYSTEM_INFO SysInfo;
        ::GetSystemInfo(&SysInfo);
        switch(SysInfo.wProcessorArchitecture)
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            *p = SysAllocString(L"x86");
            break;
        case PROCESSOR_ARCHITECTURE_ALPHA:
            *p = SysAllocString(L"Alpha");
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            *p = SysAllocString(L"IA64");
            break;
        default:
            *p = SysAllocString(L"Other");
            break;
        }

        if(*p == NULL)
            return E_OUTOFMEMORY;
        else
            return S_OK;
    }
    else
        return E_POINTER;
}


#define MAX_VERSION_STRING 30

HRESULT CIEFrameAuto::COmNavigator::get_systemLanguage(BSTR * p)
{
    HRESULT hr = E_POINTER;

    if (p)
    {
        LCID lcid;
        WCHAR strVer[MAX_VERSION_STRING];

        *p = NULL;

        lcid = ::GetSystemDefaultLCID();
        hr = LcidToRfc1766W(lcid, strVer, MAX_VERSION_STRING);
        if(!hr)
        {
            *p = SysAllocString(strVer);
            if(!*p)
                hr = E_OUTOFMEMORY;

        }
    }

    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::get_browserLanguage(BSTR * p)
{
#ifndef UNIX
    LCID lcid =0;
    LANGID  lidUI;
    WCHAR strVer[MAX_VERSION_STRING];
    HRESULT hr;

    if (!p)
    {
        return E_POINTER;
    }

    *p = NULL;

    lidUI = MLGetUILanguage();
    lcid = MAKELCID(lidUI, SORT_DEFAULT);

    hr = LcidToRfc1766W(lcid, strVer, MAX_VERSION_STRING);
    if(!hr)
    {
        *p = SysAllocString(strVer);
        if(!*p)
            return E_OUTOFMEMORY;
        else
        {
            return S_OK;
        }
    }
    return E_INVALIDARG;
#else
    // hard code for UNIX
    *p = SysAllocString(TEXT("en-us"));
    if(!*p)
        return E_OUTOFMEMORY;
    else
        return S_OK;
#endif
}

HRESULT CIEFrameAuto::COmNavigator::get_userLanguage(BSTR * p)
{
    HRESULT hr = E_POINTER;

    if (p)
    {
        LCID lcid;
        WCHAR strVer[MAX_VERSION_STRING];

        *p = NULL;

        lcid = ::GetUserDefaultLCID();
        hr = LcidToRfc1766W(lcid, strVer, MAX_VERSION_STRING);
        if(!hr)
        {
            *p = SysAllocString(strVer);
            if(!*p)
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::get_platform(BSTR * p)
{
    // Nav compatability item, returns the following in Nav:-
    // Win32,Win16,Unix,Motorola,Max68k,MacPPC
    // shdocvw is Win32 only, so
    if (p)
    {
#ifndef UNIX
        *p = SysAllocString ( L"Win32");
#else
#ifndef ux10
        *p = SysAllocString ( L"SunOS");
#else
        *p = SysAllocString ( L"HP-UX");
#endif
#endif
        return *p ? S_OK : E_OUTOFMEMORY;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_appMinorVersion(BSTR * p)
{
    HKEY hkInetSettings;
    long lResult;
    HRESULT hr = S_FALSE;

    if (!p)
    {
        return E_POINTER;
    }

    *p = NULL;

    lResult = RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
        &hkInetSettings );

    if( ERROR_SUCCESS == lResult )
    {
        DWORD dwType;
        TCHAR buffer[MAX_URL_STRING];
        DWORD size = sizeof(buffer);

        // If this is bigger than MAX_URL_STRING the registry is probably hosed.
        lResult = RegQueryValueEx( hkInetSettings, TEXT("MinorVersion"), 0, &dwType, (BYTE*)buffer, &size );

        RegCloseKey(hkInetSettings);

        if( ERROR_SUCCESS == lResult && dwType == REG_SZ )
        {
            // Just figure out the real length since 'size' is ANSI bytes required.
            *p = SysAllocString( buffer );
            hr = *p ? S_OK : E_OUTOFMEMORY;
        }
    }

    if ( hr )
    {
        *p = SysAllocString ( L"0" );
        hr = *p ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::get_connectionSpeed(long * p)
{
    if (p)
    {
        *p = NULL;
        return E_NOTIMPL;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_onLine(VARIANT_BOOL * p)
{
    if(p)
    {
        *p = TO_VARIANT_BOOL(!IsGlobalOffline());
        return S_OK;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::CPlugins::Init()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _plugins, this);
    return CAutomationStub::Init( SAFECAST(this, IHTMLPluginsCollection*), IID_IHTMLPluginsCollection,
                        CLSID_CPlugins, pauto );
}

HRESULT CIEFrameAuto::CPlugins::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    if( IsEqualIID(riid, IID_IHTMLPluginsCollection) )
        *ppv = SAFECAST(this, IHTMLPluginsCollection *);
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}


/******************************************************************************
                    Window Open Support
******************************************************************************/

CIEFrameAuto::COmHistory::COmHistory( ) :
    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE )
{
}

HRESULT CIEFrameAuto::COmHistory::Init( )
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omhist, this);
    return CAutomationStub::Init( SAFECAST(this, IOmHistory*), IID_IOmHistory, CLSID_HTMLHistory, pauto );
}

HRESULT CIEFrameAuto::COmHistory::_InternalQueryInterface( REFIID riid, void ** const ppv )
{
    ASSERT( !IsEqualIID(riid, IID_IUnknown) );

    if( IsEqualIID(riid, IID_IOmHistory) )
        *ppv = SAFECAST(this, IOmHistory *);
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}


HRESULT CIEFrameAuto::COmHistory::_GetIDispatchExDelegate( IDispatchEx ** const delegate )
{
    if( !delegate )
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate( _pAuto, &pRootDisp );
    if( SUCCEEDED(hr) )
    {
        IDispatch *pDelegateDisp = 0;
        hr = GetDelegateOnIDispatch( pRootDisp, DISPID_HISTORYOBJECT, &pDelegateDisp );
        pRootDisp->Release();

        if( SUCCEEDED(hr) )
        {
            hr = pDelegateDisp->QueryInterface( IID_IDispatchEx, (void**)delegate );
            pDelegateDisp->Release( );
        }
    }

    return hr;
}


/******************************************************************************
// I just tested Nav3 and they simply ignore parameters to back() and forward. They
// do, however, honor the value passed to go(). Hey... Netscape actually followed
// their documented behavior for once!
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmHistory::back( VARIANT* )
{
    //
    // Netscape ignores all errors from these navigation functions
    //

    _pAuto->GoBack( );
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmHistory::forward( VARIANT* )
{
    //
    // Netscape ignores all errors from these navigation functions
    //

    _pAuto->GoForward( );
    return S_OK;
}

/******************************************************************************
Get History Length from TravelLog
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmHistory::get_length(short* retval)
{
    // Make sure we have an IBrowserService pointer
    if (_pAuto->_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::history.go called _pbs==NULL");
        return E_FAIL;
    }

    // The new ITravelLog
    ITravelLog *ptl;

    // Get the new TravelLog from the browser service object.
    if (SUCCEEDED(_pAuto->_pbs->GetTravelLog(&ptl)))
    {
        if(ptl)
            *retval = (short)ptl->CountEntries(_pAuto->_pbs);
        ptl->Release();
    }

    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmHistory::go( VARIANT *pVargDist )
{
    // Parameter is optional.  If not present, just refresh.
    if( pVargDist->vt == VT_ERROR
        && pVargDist->scode == DISP_E_PARAMNOTFOUND )
        return _pAuto->Refresh( );

    // Change type to short if possible.
    //
    HRESULT hr = VariantChangeType( pVargDist, pVargDist, NULL, VT_I2 );

    if (SUCCEEDED(hr))
    {
        //
        // If 0, just call Refresh
        //
        if( pVargDist->iVal == 0 )
        {
            return _pAuto->Refresh( );
        }

        // Make sure we have an IBrowserService pointer
        if (_pAuto->_pbs==NULL)
        {
            TraceMsg(DM_WARNING, "CIEA::history.go called _pbs==NULL");
            return E_FAIL;
        }

        // The new ITravelLog
        ITravelLog *ptl;

        // Get the new TravelLog from the browser service object.
        if (SUCCEEDED(_pAuto->_pbs->GetTravelLog(&ptl)))
        {
            // Tell it to travel.  Pass in the IShellBrowser pointer.
            ptl->Travel(_pAuto->_pbs, pVargDist->iVal);
            ptl->Release();
        }
        return S_OK;
    }

    // Now see if it's a string.
    //
    if ( pVargDist->vt == VT_BSTR )
    {
        LPITEMIDLIST  pidl;
        ITravelLog    *ptl;
        ITravelEntry  *pte;

        // Make sure we have an IBrowserService pointer
        if (_pAuto->_pbs==NULL)
        {
            TraceMsg(DM_WARNING, "CIEA::history.go called _pbs==NULL");
            return E_FAIL;
        }

        if (SUCCEEDED( _pAuto->_PidlFromUrlEtc( CP_ACP, pVargDist->bstrVal, NULL, &pidl ) ))
        {
            if (SUCCEEDED( _pAuto->_pbs->GetTravelLog( &ptl ) ))
            {
                if (SUCCEEDED( ptl->FindTravelEntry( _pAuto->_pbs, pidl, &pte ) ))
                {
                    pte->Invoke( _pAuto->_pbs );
                    pte->Release();
                }
                ptl->Release();
            }
            ILFree( pidl );
        }
    }

    //
    // Netscape ignores all errors from these navigation functions
    //

    return S_OK;
}






/******************************************************************************
                    Window Open Support
******************************************************************************/

DWORD OpenAndNavigateToURL(
    CIEFrameAuto *pauto,            // IEFrameAuto of caller. Used to get IWeBrowserApp, ITargetFrame2, and IHlinkFrame methods
    BSTR         *pbstrURL,         // URL to navigate to. Should already be an escaped absolute URL
    const WCHAR *pwzTarget,         // Name of the frame to navigate
    ITargetNotify *pNotify,         // Received callback on open. May be NULL
    BOOL          bNoHistory,       // Don't add to history
    BOOL          bSilent )         // This frame is in silent Mode
{
    ASSERT( *pbstrURL );
    ASSERT( pwzTarget );
    ASSERT( pauto );

    IUnknown *punkTargetFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpTarget = NULL;
    BOOL fOpenInNewWindow = FALSE;
    LPBINDCTX pBindCtx = NULL;
    LPMONIKER pMoniker = NULL;
    LPHLINK pHlink = NULL;
    DWORD dwHlinkFlags = 0;
    DWORD zone_cross = 0;
    const WCHAR *pwzFindLoc = 0;

    // Used to open a new window if there is not an existing frame
    LPTARGETFRAMEPRIV ptgfp = SAFECAST( pauto, ITargetFramePriv* );


    //  Lookup the frame cooresponding to the target - this will give us the
    //  IUnknown for an object that can give us the coresponding IHlinkFrame
    //  via IServiceProvider::QueryService.
    HRESULT hr = pauto->FindFrame(    pwzTarget,
                                      FINDFRAME_JUSTTESTEXISTENCE,
                                      &punkTargetFrame            );
    if( punkTargetFrame )
    {
        //    Get the IHlinkFrame for the target'ed frame.
        hr = punkTargetFrame->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpTarget));
        if( FAILED(hr) )
            goto Exit;

        ptgfp = ptgfpTarget;

        // if URL is empty
        if (!**pbstrURL || **pbstrURL == EMPTY_URL)
        {
            LPTARGETNOTIFY ptgnNotify = NULL;
            if (pNotify)
            {
                if (FAILED(pNotify->QueryInterface(IID_PPV_ARG(ITargetNotify, &ptgnNotify))))
                    ptgnNotify = NULL;
            }
            if (ptgnNotify)
            {
                ptgnNotify->OnReuse(punkTargetFrame);
                ptgnNotify->Release();
            }
            goto Exit;  // Don't navigate.
        }
    }
    else if( SUCCEEDED(hr) )
    {
        // No luck, open in new window
        fOpenInNewWindow = TRUE;

        // Now, if the URL is empty, replace it with "about:blank"
        if (!**pbstrURL || **pbstrURL == EMPTY_URL)
        {
            BSTR    bstrOldURL = *pbstrURL;

            *pbstrURL = NULL;

            if (*bstrOldURL == EMPTY_URL)
                // The URL is really empty string however when the 0x01 is the
                // character of the URL this signals that the security information
                // follows.  Therefore, we'll need to append the about:blank +
                // \1 + callerURL.
                CreateBlankURL(pbstrURL, TEXT("about:blank"), bstrOldURL);
            else
                CreateBlankURL(pbstrURL, pauto->_fDesktopComponent() ? NAVFAIL_URL_DESKTOPITEM : NAVFAIL_URL, bstrOldURL);

            SysFreeString(bstrOldURL);
        }
    }
    else
        goto Exit;


    // bradsch 11/12/96
    // Need to figure out Browser-Control stuff for webcheck


    // 11/12/96
    // Need to implment this with Trident... I think "JavaScript:" should be
    // supported as a real protocol. This would provide greater Navigator
    // compatibility and allows us to avoid the following hack.
    /*
    if ( !StrCmpNI(pszURL, JAVASCRIPT_PROTOCOL, ARRAY_ELEMENTS(JAVASCRIPT_PROTOCOL)-1 ) )
    {
        if ( tw && tw->w3doc && DLCtlShouldRunScripts(tw->lDLCtlFlags) )
            ScriptOMExecuteThis( tw->w3doc->dwScriptHandle, JAVASCRIPT, &pszURL[ARRAY_ELEMENTS(JAVASCRIPT_PROTOCOL)-1],
                pszJavascriptTarget);
        return ERROR_SUCCESS;
    }
    */

    LONG_PTR hwnd;
    hr = pauto->get_HWND(&hwnd);
    if( FAILED(hr) )
        goto Exit;

    BSTR bstrCurrentURL;
    hr = pauto->get_LocationURL( &bstrCurrentURL );
    if( FAILED(hr) )
        goto Exit;

    zone_cross = ERROR_SUCCESS;
    if(!bSilent)
    {
        ASSERT(pauto->_psb);
        if(pauto->_psb)
            pauto->_psb->EnableModelessSB(FALSE);

        zone_cross = InternetConfirmZoneCrossing( (HWND) hwnd, bstrCurrentURL, *pbstrURL, FALSE );
        if(pauto->_psb)
            pauto->_psb->EnableModelessSB(TRUE);
    }

    SysFreeString(bstrCurrentURL);

    if( ERROR_CANCELLED == zone_cross )
    {
        hr = HRESULT_FROM_WIN32(zone_cross);
        goto Exit;
    }


    // create a moniker and bind context for this URL
    // use CreateAsyncBindCtxEx so that destination still navigates
    // even if we exit, as in the following code:
    //      window.close()
    //      window.open("http://haha/jokesonyou.html","_blank");
    hr = CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBindCtx, 0);
    if( FAILED(hr) )
        goto Exit;

    if( pNotify )
    {
        hr = pBindCtx->RegisterObjectParam( TARGET_NOTIFY_OBJECT_NAME, pNotify );
        ASSERT( SUCCEEDED(hr) );
    }


    // Seperate the base URL from the location (hash)
    if(pwzFindLoc = StrChrW(*pbstrURL, '#'))
    {
        const WCHAR *pwzTemp = StrChrW(pwzFindLoc, '/');
        if( !pwzTemp )
            pwzTemp = StrChrW(pwzFindLoc, '\\');

        // no delimiters past this # marker... we've found a location.
        // break out
        if( pwzTemp )
            pwzFindLoc = NULL;
    }

    WCHAR wszBaseURL[MAX_URL_STRING+1];
    WCHAR wszLocation[MAX_URL_STRING+1];

    if( pwzFindLoc )
    {
        // StrCpyNW alway null terminates to we need to copy len+1
        StrCpyNW( wszBaseURL, *pbstrURL, (int)(pwzFindLoc-*pbstrURL+1));
        StrCpyNW( wszLocation, pwzFindLoc, ARRAYSIZE(wszLocation) );
    }
    else
    {
        StrCpyNW( wszBaseURL, *pbstrURL, ARRAYSIZE(wszBaseURL) );
        wszLocation[0] = 0;
    }

    ASSERT( pBindCtx );


    if( fOpenInNewWindow )
    {
        dwHlinkFlags |= HLNF_OPENINNEWWINDOW;
    }

    if( bNoHistory )
    {
        dwHlinkFlags |= HLNF_CREATENOHISTORY;
    }

    hr = ptgfp->NavigateHack( dwHlinkFlags,
                              pBindCtx,
                              NULL,
                              fOpenInNewWindow ? pwzTarget : NULL,
                              wszBaseURL,
                              pwzFindLoc ? wszLocation : NULL);

Exit:
    SAFERELEASE(ptgfpTarget);
    SAFERELEASE(punkTargetFrame);
    SAFERELEASE(pBindCtx);

    return hr;
}

HRESULT CreateBlankURL(BSTR *url, LPCTSTR pszErrorUrl, BSTR oldUrl)
{
    ASSERT( url );

    unsigned int cbTotal = 0;

    if (pszErrorUrl)
        cbTotal = lstrlen(pszErrorUrl);
    if (oldUrl)     // Security portion of URL to append.
        cbTotal += lstrlenW(oldUrl);

    if (cbTotal)
    {
        *url = SysAllocStringByteLen(NULL, (cbTotal + 1) * sizeof(WCHAR));
        if (*url)
        {
            StrCpyN(*url, pszErrorUrl, cbTotal + 1);
            // Append the security URL to the actual URL.
            if (oldUrl)
            {
                StrCatBuffW(*url, oldUrl, cbTotal + 1);
            }

            return S_OK;
        }
    }

    return E_FAIL;
}


// bradsch 11/14/96
// This parsing code was copied from MSHTML and really bites. It should be replaced.


BOOL GetNextOption( BSTR& bstrOptionString, BSTR* optionName, int* piValue )
{
    WCHAR* delimiter;

    // Get the name of the option being set
    *optionName = GetNextToken(bstrOptionString, L"=,", L" \t\n\r", &delimiter);

    BSTR  optionSetting = NULL;

    if (!*optionName)
        return FALSE;

    // If there is an equal sign, get the value being set
    if (*delimiter=='=')
        optionSetting = GetNextToken(delimiter+1, L"=,", L" \t\n\r", &delimiter);

    if (!optionSetting)
        *piValue = TRUE;
    else
    {
        if (StrCmpIW(optionSetting, L"yes")==0)
            *piValue = 1;    // TRUE
        else if (StrCmpIW(optionSetting, L"no")==0)
            *piValue = 0;    // FALSE
        else
        {
            *piValue = StrToIntW( optionSetting );
        }

        SysFreeString(optionSetting);
    }

    // Advance the option string to the delimiter
    bstrOptionString=delimiter;

    return TRUE;
}

/******************************************************************************
// Return the next token, or NULL if there are no more tokens
******************************************************************************/
BSTR GetNextToken( BSTR bstr, BSTR delimiters, BSTR whitespace, BSTR *nextPos )
{

    BSTR result = NULL;
    WCHAR* curPos = bstr;

    // skip delimiters and whitespace to get the start of the token
    while (*curPos && (StrChrW(delimiters, *curPos) || StrChrW(whitespace, *curPos)))
        curPos++;

    WCHAR* start = curPos;

    // keep scanning until we reach another delimiter or whitespace
    while (*curPos && !StrChrW(delimiters, *curPos) && !StrChrW(whitespace, *curPos))
        curPos++;

    if (curPos > start)
    {
        // copy out the token as the result
        result = SafeSysAllocStringLen(start, (int)(curPos-start));
    }

    // scan to past the whitespace to the next delimiter
    while (*curPos && StrChrW(whitespace, *curPos))
        curPos++;

    // return the delimiter
    *nextPos = curPos;

    return result;
}

#define MAX_ARGS 10

HRESULT __cdecl DoInvokeParamHelper(IUnknown* punk, IConnectionPoint* pccp, 
                                    BOOL *pf, void **ppv, DISPID dispid, UINT cArgs, ...
                                    /* param pairs of: LPVOID Arg, VARENUM Type, ... */ )
{
    HRESULT hr;
    IShellBrowser * psb = NULL;

    if (punk && S_OK == punk->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb)))
        psb->EnableModelessSB(FALSE);

    // Calling with no params is wasteful, they should call DoInvoke directly
    //
    if (cArgs == 0)
    {
        // Can't possible cancel if there are no parameters
        ASSERT(pf == NULL && ppv == NULL);
        IConnectionPoint_SimpleInvoke(pccp, dispid, NULL);
        hr = S_OK;
    }
    else if (cArgs < MAX_ARGS)
    {
        // This function can potentially get called *very frequently*.  It is
        // used, among other things, to set status text and progress barometer
        // values.  We need to make an array of VARIANTARGs to hold a variable
        // number of parameters.  As an optimization since we want to minimize
        // overhead in this function, we will use a static array on the stack
        // rather than allocating memory.  This puts a limit (of MAX_ARGS) on
        // the number of arguments this function can process; but this is just
        // an internal function so that's OK.  Bump up MAX_ARGS if you run out of
        // room.
        VARIANTARG VarArgList[MAX_ARGS];
        DISPPARAMS dispparams = {0};

        va_list ArgList;
        va_start(ArgList, cArgs);

        hr = SHPackDispParamsV(&dispparams, VarArgList, cArgs, ArgList);

        va_end(ArgList);

        // Now Simply Call The DoInvoke to do the real work...
        if (S_OK == hr)
            IConnectionPoint_InvokeWithCancel(pccp, dispid, &dispparams, pf, ppv);

        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    if (psb)
    {
        psb->EnableModelessSB(TRUE);
        SAFERELEASE(psb);
    }

    return hr;
}

#ifdef UNIX

#ifdef NO_MARSHALLING
HRESULT CreateNewBrowserSameThread(REFIID riid, void **ppvObject)
{
    HRESULT hres = E_FAIL;
    IEFreeThreadedHandShake* piehs = CreateIETHREADHANDSHAKE();
    if (piehs)
    {
        IETHREADPARAM* piei =
            SHCreateIETHREADPARAM(NULL,SW_SHOWNORMAL,NULL,piehs);
        if (piei)
        {
            piei->fOnIEThread = FALSE;
            piei->uFlags |= COF_HELPMODE;
            IEFrameNewWindowSameThread(piei);
        }

        if (SUCCEEDED(piehs->GetHresult()))
        {
            IUnknown* punk;
            IStream* pstm = piehs->GetStream();

            if (pstm)
            {
                ULONG  pcbRead = 0;
                pstm->Seek(c_li0, STREAM_SEEK_SET,NULL);
                hres = pstm->Read( &punk, sizeof(punk), &pcbRead);
                if (SUCCEEDED(hres))
                {
                    hres = punk->QueryInterface(riid, ppvObject);
                    punk->Release();
                }
            }
         }
         else
         {
             hres = piehs->GetHresult();
             TraceMsg(DM_ERROR, "CIECF::CI piehs->hres has an error %x",piehs->GetHresult());
         }
         piehs->Release();
    }

    return hres;
}
#endif


STDAPI CoCreateInternetExplorer(REFIID iid, DWORD dwClsContext, void **ppv)
{
#ifndef NO_RPCSS_ON_UNIX
    return CoCreateInstance(CLSID_InternetExplorer, NULL, dwClsContext, iid, ppv);
#else
    HRESULT hr = E_FAIL;

    *ppv = NULL;
    if (!g_pcfactory)
    {
#ifndef NO_MARSHALLING
        return E_FAIL;
#else
        return CreateNewBrowserSameThread(iid, ppv);
#endif
    }

    IClassFactory *pcf;
    hr = g_pcfactory->QueryInterface(IID_PPV_ARG(IClassFactory, &pcf));
    if (SUCCEEDED(hr))
    {
        hr = pcf->CreateInstance(NULL, iid, ppv);
        pcf->Release();
    }
    return hr;
#endif
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iforms.cpp ===
// iforms.cpp : Implementation of CIntelliForms

#include "priv.h"
#include <iehelpid.h>
#include <pstore.h>
#include "hlframe.h"
#include "iformsp.h"
#include "shldisp.h"
#include "opsprof.h"
#include "resource.h"

#include <mluisupp.h>


// {E161255A-37C3-11d2-BCAA-00C04FD929DB}
static const GUID c_PStoreType =
{ 0xe161255a, 0x37c3, 0x11d2, { 0xbc, 0xaa, 0x0, 0xc0, 0x4f, 0xd9, 0x29, 0xdb } };
const TCHAR c_szIntelliForms[] = TEXT("Internet Explorer");

#define TF_IFORMS TF_CUSTOM2

// ALLOW_SHELLUIOC_HOST code will allow us to host intelliforms
//  from the Shell UI OC (shuioc.cpp). This is used for the
//  HTML Find dialog
#define ALLOW_SHELLUIOC_HOST

CIntelliForms *GetIntelliFormsFromDoc(IHTMLDocument2 *pDoc2);

inline void MyToLower(LPWSTR pwszStr)
{
    if (g_fRunningOnNT)
    {
        CharLowerBuffW(pwszStr, lstrlenW(pwszStr));
    }
    else
    {
        // Ideally we would use the code page contained in the string instead of
        //  the system code page.
        CHAR chBuf[MAX_PATH];
        SHUnicodeToAnsi(pwszStr, chBuf, ARRAYSIZE(chBuf));
        CharLowerBuffA(chBuf, lstrlenA(chBuf));
        SHAnsiToUnicode(chBuf, pwszStr, lstrlenW(pwszStr)+1);
    }
}


//=================== Exported functions =====================
// Exported for inetCPL
HRESULT ClearAutoSuggestForForms(DWORD dwClear)
{
    CIntelliForms *pObj = new CIntelliForms();

    if (pObj)
    {
        HRESULT hr;

        hr = pObj->ClearStore(dwClear);

        pObj->Release();

        return hr;
    }

    return E_OUTOFMEMORY;
}

HRESULT SetIdAutoSuggestForForms(const GUID *pguidId, void *pIntelliForms)
{
    CIntelliForms *pThis = (CIntelliForms *)pIntelliForms;

    if (pThis)
    {
        if (GUID_NULL == *pguidId)
        {
            pThis->m_guidUserId = c_PStoreType;
        }
        else
        {
            pThis->m_guidUserId = *pguidId;
        }

        return S_OK;
    }

    return E_FAIL;
}


// called from iedisp.cpp
void AttachIntelliForms(void *pvOmWindow, HWND hwnd, IHTMLDocument2 *pDoc2, void **ppIntelliForms)
{
static DWORD s_dwAdminRestricted = 0xFE;

    CIEFrameAuto::COmWindow *pOmWindow = (CIEFrameAuto::COmWindow *)pvOmWindow;

    ASSERT(ppIntelliForms && *ppIntelliForms==NULL);

    if (s_dwAdminRestricted == 0xFE)
    {
        s_dwAdminRestricted = CIntelliForms::IsAdminRestricted(c_szRegValFormSuggestRestrict) &&
                              CIntelliForms::IsAdminRestricted(c_szRegValSavePasswords);
    }

    if (s_dwAdminRestricted)
    {
        return;
    }

    // If we're not hosted by internet explorer, we don't want to enable Intelliforms
    //  unless dochost explicitly overrides this
    if (!IsInternetExplorerApp() &&
        !(pOmWindow && (DOCHOSTUIFLAG_ENABLE_FORMS_AUTOCOMPLETE & pOmWindow->IEFrameAuto()->GetDocHostFlags())))
    {
        return;
    }

    if (!hwnd && pOmWindow)
    {
        pOmWindow->IEFrameAuto()->get_HWND((LONG_PTR *)&hwnd);
    }

    if (!hwnd || !pDoc2 || !ppIntelliForms || (*ppIntelliForms != NULL))
    {
        return;
    }

#ifndef ALLOW_SHELLUIOC_HOST
    if (!pOmWindow)
    {
        return;
    }
#else
    if (!pOmWindow)
    {
        // Script is asking to attach to this document
        // Deny their request if another CIntelliForms is already attached
        if (NULL != GetIntelliFormsFromDoc(pDoc2))
        {
            return;
        }
    }
#endif

    CIntelliForms *pForms = new CIntelliForms();

    if (pForms)
    {
        if (SUCCEEDED(pForms->Init(pOmWindow, pDoc2, hwnd)))
        {
            *ppIntelliForms = pForms;
        }
        else
        {
            pForms->Release();
        }
    }
}

void ReleaseIntelliForms(void *pIntelliForms)
{
    CIntelliForms *pForms = (CIntelliForms *) pIntelliForms;

    if (pForms)
    {
        pForms->UnInit();
        pForms->Release();
    }
}

HRESULT IntelliFormsActiveElementChanged(void *pIntelliForms, IHTMLElement * pHTMLElement)
{
    CIntelliForms *pForms = (CIntelliForms *) pIntelliForms;

    if (pForms)
        return pForms->ActiveElementChanged(pHTMLElement);
    return E_FAIL;
}

INT_PTR CALLBACK AskUserDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT IncrementAskCount();

HRESULT IntelliFormsDoAskUser(HWND hwndBrowser, void *pv)
{
    // Make sure that we haven't asked them yet
    if (S_OK == IncrementAskCount())
    {
        // Modal dialog to ask the user our little question
        SHFusionDialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_ASK_USER),
                hwndBrowser, AskUserDlgProc, NULL);
    }

    return S_OK;
}

// Linked list of active CIntelliform objects to translate from
//  IHTMLDocument2->CIntelliforms when script calls window.external.saveforms
// Protected by g_csDll
CIntelliForms *g_pIntelliFormsFirst=NULL;

// Translate this pDoc2 to an existing instance of CIntelliForms
// Will return NULL if no CIntelliForms attached to this doc
// NO REFCOUNT IS ADDED TO THE RETURN
CIntelliForms *GetIntelliFormsFromDoc(IHTMLDocument2 *pDoc2)
{
    if (!pDoc2)
    {
        return NULL;
    }

    ENTERCRITICAL;
    CIntelliForms *pNext = g_pIntelliFormsFirst;
    IUnknown *punkDoc;
    CIntelliForms *pIForms=NULL;

    pDoc2->QueryInterface(IID_IUnknown, (void **)&punkDoc);

    if (punkDoc)
    {
        while (pNext)
        {
            if (pNext->GetDocument() == punkDoc)
            {
                pIForms = pNext;
                break;
            }
            pNext=pNext->GetNext();
        }

        punkDoc->Release();
    }

    LEAVECRITICAL;

    return pIForms;
}

// called from shuioc.cpp
HRESULT IntelliFormsSaveForm(IHTMLDocument2 *pDoc2, VARIANT *pvarForm)
{
    HRESULT hrRet = S_FALSE;
    IHTMLFormElement *pForm=NULL;
    CIntelliForms *pIForms=NULL;

    if (pvarForm->vt == VT_DISPATCH)
    {
        pvarForm->pdispVal->QueryInterface(IID_IHTMLFormElement, (void **)&pForm);
    }

    if (pForm)
    {
        pIForms = GetIntelliFormsFromDoc(pDoc2);

        if (pIForms)
        {
            // Should validate that pIForms was created on this thread
            hrRet = pIForms->ScriptSubmit(pForm);
        }

        pForm->Release();
    }

    return hrRet;
}

const TCHAR c_szYes[] = TEXT("yes");
const TCHAR c_szNo[] = TEXT("no");

INT_PTR AutoSuggestDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

#ifdef CHECKBOX_HELP
const DWORD c_aIFormsHelpIds[] = {
        IDC_AUTOSUGGEST_NEVER, IDH_INTELLIFORM_PW_PROMPT,
        0, 0
};
#endif

const WCHAR c_wszVCardPrefix[] = L"vCard.";

BOOL CIntelliForms::CAutoSuggest::s_fRegisteredWndClass = FALSE;

// Must be in same order as EVENT enum type
// All events we need to sink anywhere
CEventSinkCallback::EventSinkEntry CEventSinkCallback::EventsToSink[] =
{
    { EVENT_KEYDOWN,    L"onkeydown",   L"keydown"  },
    { EVENT_KEYPRESS,   L"onkeypress",  L"keypress" },
    { EVENT_MOUSEDOWN,  L"onmousedown", L"mousedown"},
    { EVENT_DBLCLICK,   L"ondblclick",  L"dblclick" },
    { EVENT_FOCUS,      L"onfocus",     L"focus"    },
    { EVENT_BLUR,       L"onblur",      L"blur"     },
    { EVENT_SUBMIT,     L"onsubmit",    L"submit"   },
    { EVENT_SCROLL,     L"onscroll",    L"scroll"   },
    { EVENT_COMPOSITION,NULL,           L"composition"},
    { EVENT_NOTIFY,     NULL,           L"notify"   },
};

// Fake edit window class
const WCHAR c_szEditWndClass[] = TEXT("IntelliFormClass");

// Minimum dropdown width
const int MINIMUM_WIDTH=100;

// Submit number to ask user to enable us
const int ASK_USER_ON_SUBMIT_N = 2;

void GetStuffFromEle(IUnknown *punkEle, IHTMLWindow2 **ppWin2, IHTMLDocument2 **ppDoc2)
{
    if (ppWin2)
        *ppWin2=NULL;

    if (ppDoc2)
        *ppDoc2=NULL;

    IHTMLElement *pEle=NULL;
    punkEle->QueryInterface(IID_IHTMLElement, (void **)&pEle);

    if (pEle)
    {
        IDispatch *pDisp=NULL;
        pEle->get_document(&pDisp);
        if (pDisp)
        {
            IHTMLDocument2 *pDoc2 = NULL;
            pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2);
            if (pDoc2)
            {
                if (ppWin2)
                {
                    pDoc2->get_parentWindow(ppWin2);
                }

                if (ppDoc2)
                {
                    *ppDoc2 = pDoc2;
                }
                else
                {
                    pDoc2->Release();
                }
            }
            pDisp->Release();
        }

        pEle->Release();
    }
}

void Win3FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow3 **ppWin3)
{
    *ppWin3=NULL;

    IHTMLWindow2 *pWin2=NULL;

    if (SUCCEEDED(pDoc2->get_parentWindow(&pWin2)) && pWin2)
    {
        pWin2->QueryInterface(IID_IHTMLWindow3, (void **)ppWin3);
        pWin2->Release();
    }
}

// Increment the count of whether we've asked the user to enable us or not. We won't
//  ask them on the first form submit since installing ie5.
HRESULT IncrementAskCount()
{
    DWORD dwData, dwSize, dwType;
    dwSize = sizeof(dwData);

    // c_szRegValAskUser contains the number of form submits
    //  0 means we've already asked user whether to enable us
    //  1 means we've already had one form submit, and should ask the user this time
    //  value not present means we haven't had any form submits

    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
            c_szRegKeyIntelliForms, c_szRegValAskUser, &dwType, &dwData, &dwSize)) &&
        dwType == REG_DWORD)
    {
        if (dwData == 0)
        {
            // Shouldn't get this far
            TraceMsg(TF_IFORMS|TF_WARNING, "IntelliFormsDoAskUser: Already asked user");
            return E_FAIL;      // Already asked user
        }
    }
    else
    {
        dwData = 0;
    }

    if (dwData+1 < ASK_USER_ON_SUBMIT_N)
    {
        dwData ++;
        SHSetValue(HKEY_CURRENT_USER, c_szRegKeyIntelliForms, c_szRegValAskUser,
            REG_DWORD, &dwData, sizeof(dwData));

        TraceMsg(TF_IFORMS, "IntelliFormsDoAskUser incrementing submit count. Not asking user.");

        return E_FAIL;      // Don't ask the user
    }

    return S_OK;            // Let's ask the user
}


/////////////////////////////////////////////////////////////////////////////
// CIntelliForms

CIntelliForms::CIntelliForms()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CIntelliForms");

    m_cRef = 1;

    m_iRestoredIndex = -1;

    m_fRestricted = IsAdminRestricted(c_szRegValFormSuggestRestrict);
    m_fRestrictedPW = IsAdminRestricted(c_szRegValSavePasswords);
    m_guidUserId = c_PStoreType;
    
    // Add us to global linked list
    ENTERCRITICAL;
    m_pNext = g_pIntelliFormsFirst;
    g_pIntelliFormsFirst = this;
    LEAVECRITICAL;
}

CIntelliForms::~CIntelliForms()
{
    // Remove us from global linked list
    ENTERCRITICAL;

    CIntelliForms *pLast=NULL, *pNext = g_pIntelliFormsFirst;

    while (pNext && pNext != this)
    {
        pLast = pNext;
        pNext=pNext->m_pNext;
    }

    ASSERT(pNext == this);

    if (pNext)
    {
        if (pLast)
        {
            pLast->m_pNext = m_pNext;
        }
        else
        {
            g_pIntelliFormsFirst = m_pNext;
        }
    }
    LEAVECRITICAL;

    TraceMsg(TF_IFORMS, "CIntelliForms::~CIntelliForms");
}

// Called when document is ready to attach to
// We don't support re-initting
HRESULT CIntelliForms::Init(CIEFrameAuto::COmWindow *pOmWindow, IHTMLDocument2 *pDoc2, HWND hwndBrowser)
{
    HRESULT hr;

    ASSERT(pDoc2 && hwndBrowser);

#ifndef ALLOW_SHELLUIOC_HOST
    if (pOmWindow == NULL)
    {
        return E_INVALIDARG;
    }
#endif

    // Connect to get active element changed notifications

    m_pOmWindow = pOmWindow;
    if (pOmWindow)
    {
        pOmWindow->AddRef();
    }

    m_pDoc2 = pDoc2;
    pDoc2->AddRef();
    pDoc2->QueryInterface(IID_IUnknown, (void **)&m_punkDoc2);

    m_hwndBrowser = hwndBrowser;

    m_iRestoredIndex = -1;

    hr = S_OK;

#ifdef ALLOW_SHELLUIOC_HOST
    if (!pOmWindow && (hr == S_OK))
    {
        // Check for the current active element since the page is requesting
        //  us to attach to an existing document
        IHTMLElement *pHTMLElement = NULL;

        m_pDoc2->get_activeElement(&pHTMLElement);
        ActiveElementChanged(pHTMLElement);

        if (pHTMLElement)
            pHTMLElement->Release();
    }
#endif

    GetUrl();       // Init Url member variables so we don't get the url on the
                    //   wrong thread in the FillEnumerator call

    TraceMsg(TF_IFORMS, "CIntelliForms::Init hr=%08x", hr);

    return hr;
}

HRESULT CIntelliForms::UnInit()
{
    if (m_fInModalDialog)
    {
        // Lifetime management. If UnInit is called during modal dialog, we keep ourself
        //  alive. Use Enter/LeaveModalDialog to ensure correct use
        ASSERT(m_fUninitCalled == FALSE);       // Should only be called once...
        m_fUninitCalled = TRUE;
        return S_FALSE;
    }


    // Destroy this now, before we free other member variables, to ensure CAutoSuggest doesn't
    //  try to access us on a second thread.
    if (m_pAutoSuggest)
    {
        m_pAutoSuggest->SetParent(NULL);
        m_pAutoSuggest->DetachFromInput();
        delete m_pAutoSuggest;
        m_pAutoSuggest = NULL;
    }

    if (m_hdpaForms && m_pSink)
    {
        IHTMLElement2 *pEle2;
        EVENTS events[] = { EVENT_SUBMIT };

        for (int i=DPA_GetPtrCount(m_hdpaForms)-1; i>=0; i--)
        {
            ((IHTMLFormElement *)(DPA_FastGetPtr(m_hdpaForms, i)))->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
            m_pSink->UnSinkEvents(pEle2, ARRAYSIZE(events), events);
            pEle2->Release();
        }
    }

    SysFreeString(m_bstrFullUrl);
    m_bstrFullUrl = NULL;

    SysFreeString(m_bstrUrl);
    m_bstrUrl = NULL;

    if (m_pwszUrlHash)
    {
        LocalFree((void *)m_pwszUrlHash);
        m_pwszUrlHash = NULL;
    }

    // Unhook regular event sink
    if (m_pSink)
    {
#ifndef ALLOW_SHELLUIOC_HOST
        ASSERT(m_pOmWindow);
#endif
        if (m_pOmWindow)
        {
            IHTMLWindow3 *pWin3=NULL;

            Win3FromDoc2(m_pDoc2, &pWin3);

            if (pWin3)
            {
                EVENTS events[] = { EVENT_SCROLL };
                m_pSink->UnSinkEvents(pWin3, ARRAYSIZE(events), events);
                pWin3->Release();
            }
        }

        m_pSink->SetParent(NULL);
        m_pSink->Release();
        m_pSink=NULL;
    }

    // Unhook designer event sink
    if (m_pEditSink)
    {
        m_pEditSink->Attach(NULL);
        m_pEditSink->SetParent(NULL);
        m_pEditSink->Release();
        m_pEditSink=NULL;
    }

    // SAFERELEASE (and ATOMICRELEASE) macro in shdocvw is actually function which requires IUnknown
    ATOMICRELEASET(m_pOmWindow, CIEFrameAuto::COmWindow);
    SAFERELEASE(m_pDoc2);
    SAFERELEASE(m_punkDoc2);

    FreeElementList();
    FreeFormList();

    if (m_pslPasswords)
    {
        delete m_pslPasswords;
        m_pslPasswords = NULL;
    }

    ReleasePStore();

    TraceMsg(TF_IFORMS, "CIntelliForms::UnInit");

    return S_OK;
}

STDMETHODIMP CIntelliForms::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IPropertyNotifySink == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IPropertyNotifySink *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CIntelliForms::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntelliForms::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CIntelliForms::ActiveElementChanged(IHTMLElement * pHTMLElement)
{
    ASSERT(m_pDoc2);

    // Detach the AutoSuggest object and destroy it
    if (m_pAutoSuggest)
    {
        m_pAutoSuggest->DetachFromInput();
        delete m_pAutoSuggest;
        m_pAutoSuggest=NULL;
    }

    if (m_pDoc2)
    {
        IHTMLElement *pEle=pHTMLElement;

        if (pEle)
        {
            BOOL fPassword=FALSE;
            IHTMLInputTextElement *pTextEle = NULL;

            if (SUCCEEDED(ShouldAttachToElement(pEle, TRUE, NULL, &pTextEle, NULL, &fPassword)))
            {
                BOOL fEnabledInCPL = IsEnabledInCPL();
                BOOL fEnabledPW = IsEnabledRestorePW();

                // We need to watch user activity if...
                if (fEnabledInCPL ||        // Intelliforms is enabled
                    fEnabledPW ||           // Or Restore Passwords is enabled
                    !AskedUserToEnable())   // Or we may ask them to enable us
                {
                    m_pAutoSuggest = new CAutoSuggest(this, fEnabledInCPL, fEnabledPW);

                    if (m_pAutoSuggest)
                    {
                        if (!m_pSink)
                        {
                            m_pSink = new CEventSink(this);

                            if (m_pSink)
                            {
#ifndef ALLOW_SHELLUIOC_HOST
                                // Don't sink scroll event if hosted by ShellUIOC
                                //  or jscript.dll asserts on unload
                                ASSERT(m_pOmWindow);
#endif
                                if (m_pOmWindow)
                                {
                                    IHTMLWindow3 *pWin3=NULL;

                                    Win3FromDoc2(m_pDoc2, &pWin3);

                                    if (pWin3)
                                    {
                                        EVENTS events[] = { EVENT_SCROLL };
                                        m_pSink->SinkEvents(pWin3, ARRAYSIZE(events), events);
                                        pWin3->Release();
                                    }
                                }
                            }
                        }

                        // Hook up designer sink for IME event
                        if (!m_pEditSink)
                        {
                            m_pEditSink = new CEditEventSink(this);

                            if (m_pEditSink)
                            {
                                m_pEditSink->Attach(pEle);
                            }
                        }

                        if (!m_pSink || FAILED(m_pAutoSuggest->AttachToInput(pTextEle)))
                        {
                            delete m_pAutoSuggest;
                            m_pAutoSuggest = NULL;
                        }
                    }
                }

                pTextEle->Release();
            }
            else
            {
                ASSERT(!pTextEle);

                if (fPassword)
                {
                    m_fHitPWField = TRUE;
                }
            }
            //
            // Don't release pEle
        }
    }

    return S_OK;
}

// Helper functions
BOOL CIntelliForms::AskedUserToEnable()
{
    DWORD dwType, dwSize;
    DWORD dwVal;
    DWORD dwRet;

    dwSize = sizeof(dwVal);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyIntelliForms, c_szRegValAskUser,
                            &dwType, &dwVal, &dwSize);

    if ((dwRet == ERROR_SUCCESS) && (dwType == REG_DWORD))
    {
        return (dwVal == 0) ? TRUE : FALSE;
    }

    return FALSE;
}

BOOL CIntelliForms::IsEnabledInRegistry(LPCTSTR pszKey, LPCTSTR pszValue, BOOL fDefault)
{
    DWORD dwType, dwSize;
    TCHAR szEnabled[16];
    DWORD dwRet;

    dwSize = sizeof(szEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, pszKey, pszValue, &dwType, szEnabled, &dwSize);

    if (dwRet == ERROR_INSUFFICIENT_BUFFER)
    {
        // Invalid value in registry.
        ASSERT(dwRet == ERROR_SUCCESS);
        return FALSE;
    }

    if (dwRet == ERROR_SUCCESS)
    {
        if ((dwType == REG_SZ) &&
            (!StrCmp(szEnabled, TEXT("yes"))))
        {
            // Enabled
            return TRUE;
        }
        else
        {
            // Disabled
            return FALSE;
        }
    }

    // Value not found
    return fDefault;
}

BOOL CIntelliForms::IsAdminRestricted(LPCTSTR pszRegVal)
{
    DWORD lSize;
    DWORD  lValue;

    lValue = 0; // clear it
    lSize = sizeof(lValue);
    if (ERROR_SUCCESS !=
        SHGetValue(HKEY_CURRENT_USER, c_szRegKeyRestrict, pszRegVal, NULL, (LPBYTE)&lValue, &lSize ))
    {
        return FALSE;
    }

    ASSERT(lSize == sizeof(lValue));

    return (0 != lValue) ? TRUE : FALSE;
}

BOOL CIntelliForms::IsEnabledForPage()
{
    if (!m_fCheckedIfEnabled)
    {
        m_fCheckedIfEnabled = TRUE;

        // We will have our Url in m_bstrFullUrl, only if it is https: protocol
        if (m_bstrFullUrl)
        {
            ASSERT(!StrCmpNIW(m_bstrFullUrl, L"https:", 5));

            m_fEnabledForPage = TRUE;

            // See if this page is in the internet cache. If not, we won't intelliform
            //  for this page either.
            if (!GetUrlCacheEntryInfoW(m_bstrFullUrl, NULL, NULL) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
            {
                // Failed - it's not in the cache
                m_fEnabledForPage = FALSE;
            }
        }
        else
        {
            // Url is not https: so always enable Intelliforms
            m_fEnabledForPage = TRUE;
        }
    }

    return m_fEnabledForPage;
}

HRESULT CIntelliForms::GetBodyEle(IHTMLElement2 **ppEle2)
{
    if (!m_pDoc2 || !ppEle2)
    {
        return E_INVALIDARG;
    }

    *ppEle2=NULL;

    IHTMLElement *pBodyEle=NULL;

    m_pDoc2->get_body(&pBodyEle);

    if (pBodyEle)
    {
        pBodyEle->QueryInterface(IID_IHTMLElement2, (void **)ppEle2);
        pBodyEle->Release();
    }

    return (*ppEle2) ? S_OK : E_FAIL;
}

// static
BOOL CIntelliForms::IsElementEnabled(IHTMLElement *pEle)
{
    BOOL fEnabled=TRUE;
    BSTR bstrAttribute;

    VARIANT varVal;
    varVal.vt = VT_EMPTY;

    // First check "AutoComplete=OFF"
    bstrAttribute=SysAllocString(L"AutoComplete");

    if (bstrAttribute &&
        SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal)))
    {
        if (varVal.vt == VT_BSTR)
        {
            if (!StrCmpIW(varVal.bstrVal, L"off"))
            {
                // We are disabled.
                fEnabled=FALSE;
            }
        }

        VariantClear(&varVal);
    }

    SysFreeString(bstrAttribute);

    // Then check "READONLY" attribute
    if (fEnabled)
    {
        IHTMLInputElement *pInputEle=NULL;

        pEle->QueryInterface(IID_IHTMLInputElement, (void **)&pInputEle);

        if (pInputEle)
        {
            VARIANT_BOOL vbReadOnly=VARIANT_FALSE;

            pInputEle->get_readOnly(&vbReadOnly);

            if (vbReadOnly)
            {
                // We are read only.
                fEnabled=FALSE;
            }

            pInputEle->Release();
        }
    }

    return fEnabled;
}

// static
HRESULT CIntelliForms::ShouldAttachToElement(IUnknown                *punkEle,
                                             BOOL                     fCheckForm,
                                             IHTMLElement2          **ppEle2,
                                             IHTMLInputTextElement  **ppITE,
                                             IHTMLFormElement       **ppFormEle,
                                             BOOL                    *pfPassword)
{
    IHTMLInputTextElement *pITE = NULL;

    if (ppEle2)
    {
        *ppEle2 = NULL;
    }

    if (ppITE)
    {
        *ppITE = NULL;
    }

    if (ppFormEle)
    {
        *ppFormEle = NULL;
    }

    punkEle->QueryInterface(IID_IHTMLInputTextElement, (void **)&pITE);

    if (NULL == pITE)
    {
        // Not an input text element. Do not attach.
        return E_FAIL;
    }

    HRESULT hr = E_FAIL;

    IHTMLElement2 *pEle2        = NULL;
    IHTMLElement *pEle          = NULL;
    IHTMLFormElement *pFormEle  = NULL;

    punkEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
    punkEle->QueryInterface(IID_IHTMLElement, (void **)&pEle);

    if (pEle2 && pEle)
    {
        // type=text is all that's allowed
        BSTR bstrType=NULL;

        if (SUCCEEDED(pITE->get_type(&bstrType)) && bstrType)
        {
            if (!StrCmpICW(bstrType, L"text"))
            {
                // FormSuggest=off attribute turns us off for this element
                if (IsElementEnabled(pEle))
                {
                    IHTMLElement *pFormHTMLEle=NULL;

                    if (fCheckForm || ppFormEle)
                    {
                        pITE->get_form(&pFormEle);

                        if (pFormEle)
                        {
                            pFormEle->QueryInterface(IID_IHTMLElement, (void **)&pFormHTMLEle);
                        }
                        else
                        {
                            // This may be valid if element is not in form
                            TraceMsg(TF_IFORMS, "Iforms: pITE->get_form() returned NULL");
                        }
                    }

                    // FormSuggest=off for form turns us off for this form
                    if (pFormEle &&
                        (!fCheckForm || (pFormHTMLEle && IsElementEnabled(pFormHTMLEle))))
                    {
                        hr = S_OK;
                        if (ppEle2)
                        {
                            *ppEle2 = pEle2;
                            pEle2->AddRef();
                        }
                        if (ppFormEle)
                        {
                            *ppFormEle = pFormEle;
                            pFormEle->AddRef();
                        }
                        if (ppITE)
                        {
                            *ppITE = pITE;
                            pITE->AddRef();
                        }
                    }

                    SAFERELEASE(pFormHTMLEle);
                    SAFERELEASE(pFormEle);
                }
            }
            else
            {
                if (pfPassword && !StrCmpICW(bstrType, L"password") && IsElementEnabled(pEle))
                {
                    TraceMsg(TF_IFORMS, "IForms: Password field detected.");
                    *pfPassword = TRUE;
                }
            }

            SysFreeString(bstrType);
        }
        else
        {
            TraceMsg(TF_IFORMS, "IntelliForms disabled for single element via attribute");
        }
    }

    SAFERELEASE(pITE);
    SAFERELEASE(pEle2);
    SAFERELEASE(pEle);

    return hr;
}

// Get the URL that we're located at, with query string/anchor stripped.
LPCWSTR CIntelliForms::GetUrl()
{
    if (m_bstrUrl)
    {
        return m_bstrUrl;
    }

    if (m_pOmWindow)
    {
        m_pOmWindow->IEFrameAuto()->get_LocationURL(&m_bstrUrl);
    }
#ifdef ALLOW_SHELLUIOC_HOST
    else
    {
        IHTMLLocation *pHTMLLocation=NULL;

        m_pDoc2->get_location(&pHTMLLocation);

        if (NULL != pHTMLLocation)
        {
            pHTMLLocation->get_href(&m_bstrUrl);
            pHTMLLocation->Release();
        }
    }
#endif

    if (m_bstrUrl)
    {
        PARSEDURLW puW = {0};
        puW.cbSize = sizeof(puW);

        // Save the full url for a security check, if we are https protocol
        if (SUCCEEDED(ParseURLW(m_bstrUrl, &puW)))
        {
            if (puW.nScheme == URL_SCHEME_HTTPS)
            {
                m_bstrFullUrl = SysAllocString(m_bstrUrl);
                if (!m_bstrFullUrl)
                {
                    SysFreeString(m_bstrUrl);
                    m_bstrUrl=NULL;
                }
            }
        }
    }

    if (m_bstrUrl)
    {
        // Strip off any query string or anchor
        LPWSTR lpUrl = m_bstrUrl;
        while (*lpUrl)
        {
            if ((*lpUrl == L'?') || (*lpUrl == L'#'))
            {
                *lpUrl = L'\0';
                break;
            }
            lpUrl ++;
        }

        return m_bstrUrl;
    }

    TraceMsg(TF_WARNING|TF_IFORMS, "CIntelliForms::GetUrl() failing!");
    return L"";     // We can assume non-NULL pointer
}

// hook our "Submit" event sink to this form
HRESULT CIntelliForms::AttachToForm(IHTMLFormElement *pFormEle)
{
    ASSERT(m_pSink);

    if (m_pSink)
    {
        IHTMLElement2 *pEle2 = NULL;

        pFormEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);

        if (pEle2)
        {
            // Sink event for the form
            EVENTS events[] = { EVENT_SUBMIT };
            m_pSink->SinkEvents(pEle2, ARRAYSIZE(events), events);
        }

        SAFERELEASE(pEle2);

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

// Returns TRUE if nothing but spaces in string
inline BOOL IsEmptyString(LPCWSTR lpwstr)
{
    while (*lpwstr && (*lpwstr == L' ')) lpwstr++;
    return (*lpwstr == 0);
}

// called for each element in the form we are submitting
HRESULT CIntelliForms::SubmitElement(IHTMLInputTextElement *pITE, FILETIME ftSubmit, BOOL fEnabledInCPL)
{
    if (m_fRestricted) return E_FAIL;

    HRESULT hrRet = S_OK;

    BSTR bstrName;

    CIntelliForms::GetName(pITE, &bstrName);

    if (bstrName && bstrName[0])
    {
        BSTR bstrValue=NULL;

        pITE->get_value(&bstrValue);

        if (bstrValue && bstrValue[0] && !IsEmptyString(bstrValue))
        {
            if (fEnabledInCPL)
            {
                TraceMsg(TF_IFORMS, "IForms: Saving field \"%ws\" as \"%ws\"", bstrName, bstrValue);

                CStringList *psl;

                if (FAILED(ReadFromStore(bstrName, &psl)))
                {
                    CStringList_New(&psl);
                }

                if (psl)
                {
                    HRESULT hr;

                    if (SUCCEEDED(hr = psl->AddString(bstrValue, ftSubmit)))
                    {
                        if ((S_OK == hr) ||
                            (psl->NumStrings() > CStringList::MAX_STRINGS / 4))
                        {
                            // We added a non-duplicate string, or we updated the
                            //  last submit time of an existing string
                            WriteToStore(bstrName, psl);
                        }
                    }

                    delete psl;
                }
            }
            else
            {
                hrRet = S_FALSE;   // Tell caller that we didn't save because we were disabled
            }
        }

        SysFreeString(bstrValue);
    }

    SysFreeString(bstrName);

    return hrRet;
}

HRESULT CIntelliForms::HandleFormSubmit(IHTMLFormElement *pForm)
{
    IUnknown *punkForm=NULL;

    if (!pForm)
    {
        // We currently require a form element even from script
        return E_INVALIDARG;
    }

    if (!m_hdpaElements || !m_hdpaForms)
    {
        return S_OK;
    }

    // Make sure we're enabled
    BOOL fEnabledInCPL = IsEnabledInCPL();
    if (fEnabledInCPL || IsEnabledRestorePW() || !AskedUserToEnable())
    {
        pForm->QueryInterface(IID_IUnknown, (void **)&punkForm);

        if (punkForm)
        {
            IHTMLFormElement *pThisFormEle;
            IUnknown *punkThisForm;
            FILETIME ftSubmit;
            int     iCount=0;
            BOOL    fShouldAskUser=FALSE;
            IHTMLInputTextElement *pFirstEle=NULL;

            GetSystemTimeAsFileTime(&ftSubmit);

            // Go through list of 'changed' elements and save their values
            //  make sure we loop backwards since we nuke elements as we find them
            for (int i=DPA_GetPtrCount(m_hdpaElements)-1; i>=0; i--)
            {
                IHTMLInputTextElement *pITE = ((IHTMLInputTextElement *)(DPA_FastGetPtr(m_hdpaElements, i)));

                if (SUCCEEDED(pITE->get_form(&pThisFormEle)) && pThisFormEle)
                {
                    if (SUCCEEDED(pThisFormEle->QueryInterface(IID_IUnknown, (void **)&punkThisForm)))
                    {
                        if (punkThisForm == punkForm)
                        {
                            // Verify that we're still allowed to save this element
                            if (SUCCEEDED(ShouldAttachToElement(pITE, TRUE, NULL, NULL, NULL, NULL)))
                            {
                                iCount ++;

                                if (!pFirstEle)
                                {
                                    pFirstEle = pITE;
                                    pFirstEle->AddRef();
                                }

                                // Don't save non-password stuff for non-cached pages
                                if (IsEnabledForPage())
                                {
                                    // Won't actually save the value if fEnabledInCPL is FALSE
                                    if (S_FALSE == SubmitElement(pITE, ftSubmit, fEnabledInCPL))
                                    {
                                        // We would have saved this if we were enabled
                                        fShouldAskUser = TRUE;
                                    }
                                }

                                // Remove this element from the DPA to prevent any possibility of
                                //  saving before more user input takes place
                                pITE->Release();
                                DPA_DeletePtr(m_hdpaElements, i);
                            }
                        }
                        else
                        {
                            TraceMsg(TF_IFORMS, "IForms: User input in different form than was submitted...?");
                        }

                        punkThisForm->Release();
                    }

                    pThisFormEle->Release();
                }
                else
                {
                    // It shouldn't be in our DPA if it isn't in a form...
                    TraceMsg(TF_WARNING|TF_IFORMS, "Iforms: pITE->get_form() returned NULL!");
                }
            }

            if (0 == DPA_GetPtrCount(m_hdpaElements))
            {
                DPA_Destroy(m_hdpaElements);
                m_hdpaElements=NULL;
            }

            if (m_fHitPWField || (m_iRestoredIndex != -1))
            {
                // ?? why not check iCount==1 here?
                if (pFirstEle)
                {
                    // May have restored PW and may have changed or entered it
                    SavePassword(pForm, ftSubmit, pFirstEle);

                    // WARNING - after returning from "SavePassword" our object may be invalid
                    //  if we got released/detached during modal dialog
                }
            }
            else if (fShouldAskUser)
            {
                // Possibly ask user if they want to enable intelliforms, only if
                //  this isn't a login
                if (m_pOmWindow)
                {
                    m_pOmWindow->IntelliFormsAskUser(NULL);
                }
                fShouldAskUser = FALSE;
            }

            if (fShouldAskUser)
            {
                // If we should ask the user but we're not going to (login form),
                //  increment our count anyway so that we ask them as soon as we can
                IncrementAskCount();
            }

            punkForm->Release();
            SAFERELEASE(pFirstEle);
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    if (Event == EVENT_SUBMIT)
    {
        // Save strings for modified text inputs when appropriate
        IHTMLFormElement *pFormEle = NULL;

        if (pEle)
        {
            pEle->QueryInterface(IID_IHTMLFormElement, (void **)&pFormEle);
            if (pFormEle)
            {
                HandleFormSubmit(pFormEle);
                // Warning - "this" may be detached/destroyed at this point
                pFormEle->Release();
            }
        }
    }
    else
    {
        ASSERT(Event == EVENT_SCROLL);
        if (m_pAutoSuggest)
            m_pAutoSuggest->UpdateDropdownPosition();
    }

    return S_OK;
}

HRESULT CIntelliForms::PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj* pIEventObj)
{
    if ((inEvtDispId == 0) &&
        (m_pAutoSuggest != NULL) &&
        (m_pAutoSuggest->AttachedElement() != NULL))
    {
        BSTR bstrType = NULL;
        CEventSinkCallback::EVENTS Event = EVENT_BOGUS;

        pIEventObj->get_type(&bstrType);

        if (bstrType)
        {
#if 0
            // Spew wParam and lParam
            IHTMLEventObj3 *pObj3 = NULL;

            pIEventObj->QueryInterface(IID_PPV_ARG(IHTMLEventObj3, &pObj3));

            if (pObj3)
            {
                long lLong=0;
                long wWord=0;
                pObj3->get_imeCompositionChange(&lLong);
                pObj3->get_imeNotifyCommand(&wWord);
                TraceMsg(TF_ALWAYS, "PreHandleEvent: %ws - wWord=0x%04x   lLong=0x%08x", bstrType, wWord, lLong);
                pObj3->Release();
            }
#endif
            if (!StrCmp(bstrType, L"composition"))
            {
                Event = EVENT_COMPOSITION;
            }
            else if (!StrCmp(bstrType, L"notify"))
            {
                Event = EVENT_NOTIFY;
            }

            if (Event != EVENT_BOGUS)
            {
                // Trident doesn't set srcElement on eventobj, so just use the one
                // we're attached to
                IHTMLElement *pEle;

                m_pAutoSuggest->AttachedElement()->QueryInterface(IID_IHTMLElement, (void **)&pEle);

                if (pEle)
                {
                    m_pAutoSuggest->HandleEvent(pEle, Event, pIEventObj);
                    pEle->Release();
                }
            }

            SysFreeString(bstrType);
        }
        
    }

    return S_FALSE;     // S_FALSE so that Trident will still process this
}


// Our passwords are stored in username/value pairs
// Search every other string for the username
HRESULT CIntelliForms::FindPasswordEntry(LPCWSTR pwszValue, int *piIndex)
{
    ASSERT(m_pslPasswords);
    ASSERT(!(m_pslPasswords->NumStrings() & 1));   // Should be even number

    int i;

    for (i=0; i<m_pslPasswords->NumStrings(); i += 2)
    {
        if (!StrCmpIW(pwszValue, m_pslPasswords->GetString(i)))
        {
            // Found it
            *piIndex = i+1;
            return S_OK;
        }
    }

    return E_FAIL;
}

// Convert url to string based on shlwapi UrlHash return
LPCWSTR CIntelliForms::GetUrlHash()
{
    BYTE bBuf[15];

    if (m_pwszUrlHash)
    {
        return m_pwszUrlHash;
    }

    LPCWSTR pwszUrl = GetUrl();

    if (!pwszUrl || !*pwszUrl)
    {
        return NULL;
    }

    if (SUCCEEDED(UrlHashW(pwszUrl, bBuf, ARRAYSIZE(bBuf))))
    {
        // Translate this array of bytes into 7-bit chars
        m_pwszUrlHash = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(ARRAYSIZE(bBuf)+1));

        if (m_pwszUrlHash)
        {
            for (int i=0; i<ARRAYSIZE(bBuf); i++)
            {
                // Translate each char into 32-96 range
                ((LPWSTR)m_pwszUrlHash)[i] = (WCHAR)((bBuf[i] & 0x3F) + 0x20);
            }
            ((LPWSTR)m_pwszUrlHash)[i] = L'\0';
        }

        return m_pwszUrlHash;
    }

    return NULL;
}

// Tells us if passwords are present for this url
BOOL CIntelliForms::ArePasswordsSaved()
{
    if (!m_fRestrictedPW)
    {
        DWORD dwVal, dwSize=sizeof(dwVal);
        LPCWSTR pwsz = GetUrlHash();

        if (pwsz && (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, c_wszRegKeyIntelliFormsSPW, pwsz, NULL, &dwVal, &dwSize)))
        {
            return TRUE;
        }
    }

    return FALSE;
}

// Will return password list in m_pslPasswords, if passwords are saved
BOOL CIntelliForms::LoadPasswords()
{
    if (!m_fCheckedPW)
    {
        m_fCheckedPW = TRUE;

        // Check if passwords are present without hitting pstore
        if (ArePasswordsSaved())
        {
            // We should have passwords for this url. Hit PStore.
            ReadFromStore(GetUrl(), &m_pslPasswords, TRUE);

            m_iRestoredIndex = -1;
        }
    }
    else if (m_pslPasswords)
    {
        // If we already have passwords, double check the registry in case the user
        //  nuked saved stuff via inetcpl
        if (!ArePasswordsSaved())
        {
            delete m_pslPasswords;
            m_pslPasswords=NULL;
            m_iRestoredIndex = -1;
        }
    }

    return (m_pslPasswords != NULL);
}

void CIntelliForms::SavePasswords()
{
    if (m_pslPasswords && m_bstrUrl)
    {
        WriteToStore(m_bstrUrl, m_pslPasswords);
        SetPasswordsAreSaved(TRUE);
    }
}

// Mark that we have passwords saved for this url
void CIntelliForms::SetPasswordsAreSaved(BOOL fSaved)
{
    LPCWSTR pwsz = GetUrlHash();

    if (pwsz)
    {
        if (fSaved)
        {
            DWORD dwSize = sizeof(DWORD);
            DWORD dw = 0;
            SHSetValueW(HKEY_CURRENT_USER, c_wszRegKeyIntelliFormsSPW, pwsz, REG_DWORD, &dw, sizeof(dw));
        }
        else
        {
            SHDeleteValueW(HKEY_CURRENT_USER, c_wszRegKeyIntelliFormsSPW, pwsz);
        }

    }
}

// enumerates form & gets password fields
class CDetectLoginForm
{
public:
    CDetectLoginForm() { m_pNameEle=m_pPasswordEle=m_pPasswordEle2=NULL; }
    ~CDetectLoginForm() { SAFERELEASE(m_pNameEle); SAFERELEASE(m_pPasswordEle); }

    HRESULT ParseForm(IHTMLFormElement *pFormEle, BOOL fRestoring);

    IHTMLInputTextElement *GetNameEle() { return m_pNameEle; }
    IHTMLInputTextElement *GetPasswordEle() { return m_pPasswordEle; }

protected:
    IHTMLInputTextElement  *m_pNameEle;
    IHTMLInputTextElement  *m_pPasswordEle;

    IHTMLInputTextElement  *m_pPasswordEle2;

    static HRESULT s_PasswordCB(IDispatch *pDispEle, DWORD_PTR dwCBData);
};

// if SUCCEEDED(hr), GetNameEle and GetPasswordEle are guaranteed non-NULL
HRESULT CDetectLoginForm::ParseForm(IHTMLFormElement *pFormEle, BOOL fRestoring)
{
    if (m_pPasswordEle || m_pNameEle || m_pPasswordEle2)
    {
        return E_FAIL;
    }

    CIntelliForms::CEnumCollection<IHTMLFormElement>::EnumCollection(pFormEle, s_PasswordCB, (DWORD_PTR)this);

    // For forms with two password fields (possibly used for login *and* new accounts)
    //  we clear the second field on PW restore and require it to be blank for saving.
    // Ideally, we would detect this as a password change situation as well.
    if (m_pPasswordEle2)
    {
        if (fRestoring)
        {
            BSTR bstrEmpty=SysAllocString(L"");
            if (bstrEmpty)
            {
                m_pPasswordEle2->put_value(bstrEmpty);
                SysFreeString(bstrEmpty);
            }
        }
        else
        {
            BSTR bstrVal=NULL;

            m_pPasswordEle2->get_value(&bstrVal);

            if (bstrVal && bstrVal[0])
            {
                // Failure! Second password field isn't empty.
                SAFERELEASE(m_pNameEle);
                SAFERELEASE(m_pPasswordEle);
            }

            SysFreeString(bstrVal);
        }

        SAFERELEASE(m_pPasswordEle2);   // Always release this
    }

    if (m_pPasswordEle && m_pNameEle)
    {
        return S_OK;
    }

    SAFERELEASE(m_pNameEle);
    SAFERELEASE(m_pPasswordEle);
    ASSERT(!m_pPasswordEle2);

    return E_FAIL;
}

// Password callback for CEnumCollection to find username and password fields
//   in a login form
HRESULT CDetectLoginForm::s_PasswordCB(IDispatch *pDispEle, DWORD_PTR dwCBData)
{
    CDetectLoginForm *pThis = (CDetectLoginForm *)dwCBData;

    HRESULT hr=S_OK;

    IHTMLInputTextElement *pTextEle=NULL;

    pDispEle->QueryInterface(IID_IHTMLInputTextElement, (void **)&pTextEle);

    if (pTextEle)
    {
        BSTR bstrType;

        pTextEle->get_type(&bstrType);

        if (bstrType)
        {
            if (!StrCmpICW(bstrType, L"text"))
            {
                // Assume this is the 'name' field
                if (pThis->m_pNameEle)
                {
                    // Whoops, we've already got a name field. Can't have two...
                    hr = E_ABORT;
                }
                else
                {
                    pThis->m_pNameEle = pTextEle;
                    pTextEle->AddRef();
                }
            }
            else if (!StrCmpICW(bstrType, L"password"))
            {
                // Assume this is the 'password' field
                if (pThis->m_pPasswordEle)
                {
                    // Whoops, we've already got a password field. Can't have two...
                    //  ...oh wait, yes we can...
                    if (pThis->m_pPasswordEle2)
                    {
                        // ...but we definitely can't have three!!!
                        hr = E_ABORT;
                    }
                    else
                    {
                        pThis->m_pPasswordEle2 = pTextEle;
                        pTextEle->AddRef();
                    }
                }
                else
                {
                    pThis->m_pPasswordEle = pTextEle;
                    pTextEle->AddRef();
                }
            }

            SysFreeString(bstrType);
        }

        pTextEle->Release();
    }

    if (hr == E_ABORT)
    {
        SAFERELEASE(pThis->m_pNameEle);
        SAFERELEASE(pThis->m_pPasswordEle);
        SAFERELEASE(pThis->m_pPasswordEle2);
    }

    return hr;
}

// Fill in passwords for this username, if one is available
HRESULT CIntelliForms::AutoFillPassword(IHTMLInputTextElement *pTextEle, LPCWSTR pwszUsername)
{
    BSTR bstrUrl = NULL;

    if (!pTextEle || !pwszUsername)
        return E_INVALIDARG;

    if (!IsEnabledRestorePW() || !LoadPasswords())
    {
        // We have no passwords for this url
        return S_FALSE;
    }

    int iIndex;

    if (SUCCEEDED(FindPasswordEntry(pwszUsername, &iIndex)))
    {
        // Returns index of password in m_pslPasswords
        ASSERT(iIndex>=0 && iIndex<m_pslPasswords->NumStrings() && (iIndex&1));

        FILETIME ft;

        // StringTime==0 indicates user said "no" to saving password
        if (SUCCEEDED(m_pslPasswords->GetStringTime(iIndex, &ft)) && (FILETIME_TO_INT(ft) != 0))
        {
            TraceMsg(TF_IFORMS, "IntelliForms found saved password");

            // We have a password saved for this specific username. Fill it in.
            CDetectLoginForm LoginForm;
            IHTMLFormElement *pFormEle=NULL;
            HRESULT hr = E_FAIL;

            pTextEle->get_form(&pFormEle);
            if (pFormEle)
            {
                // See if this is a valid form: One plain text input, One password input. Find the fields.
                hr = LoginForm.ParseForm(pFormEle, TRUE);

                pFormEle->Release();
            }
            else
            {
                // Shouldn't get this far if we don't have a form for this element
                TraceMsg(TF_WARNING|TF_IFORMS, "Iforms: pITE->get_form() returned NULL!");
            }

            if (SUCCEEDED(hr))
            {
                BSTR bstrPW=NULL;
                m_pslPasswords->GetBSTR(iIndex, &bstrPW);
                if (bstrPW)
                {
                    LoginForm.GetPasswordEle()->put_value(bstrPW);
                    SysFreeString(bstrPW);
                    m_iRestoredIndex = iIndex;

                    // We restored this password. sink the SUBMIT for this form (if we haven't yet)
                    UserInput(pTextEle);
                }
            }
        }
        else
        {
            // User previously said 'no' to remembering passwords
            m_iRestoredIndex = -1;
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::DeletePassword(LPCWSTR pwszUsername)
{
    // If we have a password, ask them if they want to delete it.
    if (LoadPasswords())
    {
        int iIndex;

        if (SUCCEEDED(FindPasswordEntry(pwszUsername, &iIndex)))
        {
            // If they previously said "no", delete without asking - they don't actually
            //  have a password saved
            // Otherwise, ask and delete only if they say "yes"
            FILETIME ft;
            if (FAILED(m_pslPasswords->GetStringTime(iIndex, &ft)) ||
                (0 == FILETIME_TO_INT(ft)) ||
                (IDYES == DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_DELETEPASSWORD),
                                m_hwndBrowser, AutoSuggestDlgProc, IDD_AUTOSUGGEST_DELETEPASSWORD)))
            {
                // Delete username then password from string list
                if (SUCCEEDED(m_pslPasswords->DeleteString(iIndex-1)) &&
                    SUCCEEDED(m_pslPasswords->DeleteString(iIndex-1)))
                {
                    TraceMsg(TF_IFORMS, "Deleting password for user \"%ws\"", pwszUsername);
                    ASSERT(!(m_pslPasswords->NumStrings() & 1));

                    if (m_iRestoredIndex == iIndex)
                    {
                        m_iRestoredIndex = -1;
                    }
                    else if (m_iRestoredIndex > iIndex)
                    {
                        m_iRestoredIndex -= 2;
                    }

                    if (m_pslPasswords->NumStrings() == 0)
                    {
                        // No more strings for this url. Nuke it.
                        DeleteFromStore(GetUrl());
                        SetPasswordsAreSaved(FALSE);
                        delete m_pslPasswords;
                        m_pslPasswords = NULL;
                        ASSERT(m_iRestoredIndex == -1);
                    }
                    else
                    {
                        SavePasswords();
                    }
                }
            }
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::SavePassword(IHTMLFormElement *pFormEle, FILETIME ftSubmit, IHTMLInputTextElement *pFirstEle)
{
    if (m_fRestrictedPW ||
        !IsEnabledRestorePW())
    {
        return S_FALSE;
    }

    BOOL fAskUser = TRUE;

    // First let's check for previously saved entries for this username
    if (LoadPasswords())
    {
        int iIndex;

        BSTR bstrUserName=NULL;

        pFirstEle->get_value(&bstrUserName);

        if (bstrUserName)
        {
            if (SUCCEEDED(FindPasswordEntry(bstrUserName, &iIndex)))
            {
                FILETIME ft;
                if (SUCCEEDED(m_pslPasswords->GetStringTime(iIndex, &ft)))
                {
                    if (FILETIME_TO_INT(ft) == 0)
                    {
                        // StringTime==0 means user previously said "no".
                        TraceMsg(TF_IFORMS, "IForms not asking about saving password");
                        fAskUser = FALSE;
                    }
                    else if (m_iRestoredIndex != iIndex)
                    {
                        // User previously said "yes" - but we didn't restore it for some reason
                        // Can happen with "back" button then submit
                        TraceMsg(TF_WARNING|TF_IFORMS, "IForms - user saved password and we didn't restore it");

                        // Write regkey in case that was the problem - we'll work next time
                        SetPasswordsAreSaved(TRUE);
                        m_iRestoredIndex = iIndex;
                    }
                }
            }
            else
            {
                m_iRestoredIndex = -1;
            }

            SysFreeString(bstrUserName);
        }
    }

    // Then lets ask the user if they'd like to save the password for this username
    if (fAskUser)
    {
        CDetectLoginForm LoginForm;

        // See if this is a valid form: One plain text input, One password input. Find the fields.

        if (SUCCEEDED(LoginForm.ParseForm(pFormEle, FALSE)))
        {
            TraceMsg(TF_IFORMS, "IForms Successfully detected 'save password' form");
            BSTR bstrUsername=NULL;
            BSTR bstrPassword=NULL;

            LoginForm.GetNameEle()->get_value(&bstrUsername);
            LoginForm.GetPasswordEle()->get_value(&bstrPassword);

            if (bstrUsername && bstrPassword)
            {
                if (m_iRestoredIndex != -1)
                {
                    // We have a previously saved password. See if our current entry is the same.
                    if (!StrCmpW(bstrPassword, m_pslPasswords->GetString(m_iRestoredIndex)))
                    {
                        // They're the same... nothing to do...
                        TraceMsg(TF_IFORMS, "IForms - user entered PW same as saved PW - nothing to do");
                        // Check to see that the username case is the same, just to be sure
                        if (StrCmpW(bstrUsername, m_pslPasswords->GetString(m_iRestoredIndex-1)))
                        {
                            TraceMsg(TF_IFORMS, "IForms - except change the username's case");
                            if (SUCCEEDED(m_pslPasswords->ReplaceString(m_iRestoredIndex-1, bstrUsername)))
                            {
                                SavePasswords();
                            }
                            else
                            {
                                // Something went horribly wrong!
                                delete m_pslPasswords;
                                m_pslPasswords=NULL;
                            }
                        }
                    }
                    else
                    {
                        // Ask the user if we want to change the saved password
                        INT_PTR iMB;

                        EnterModalDialog();

                        iMB = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_CHANGEPASSWORD),
                                    m_hwndBrowser, AutoSuggestDlgProc, IDD_AUTOSUGGEST_CHANGEPASSWORD);

                        if (IDYES == iMB)
                        {
                            // Delete the old one and add the new one. Update filetimes.
                            if (SUCCEEDED(m_pslPasswords->ReplaceString(m_iRestoredIndex, bstrPassword)))
                            {
                                m_pslPasswords->SetStringTime(m_iRestoredIndex, ftSubmit);
                                SavePasswords();
                                TraceMsg(TF_IFORMS, "IForms successfully saved changed password");
                            }
                            else
                            {
                                TraceMsg(TF_IFORMS|TF_WARNING, "IForms couldn't change password!");
                                delete m_pslPasswords;
                                m_pslPasswords = NULL;
                            }
                        }

                        LeaveModalDialog();
                    }
                }
                else
                {
                    // We don't have a previously saved password for this user. See if they want to save it.
                    // If the password is empty, don't bother asking or saving
                    if (IsEnabledAskPW() && bstrPassword[0])
                    {
                        EnterModalDialog();

                        INT_PTR iMB = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_SAVEPASSWORD),
                                        m_hwndBrowser, AutoSuggestDlgProc, IDD_AUTOSUGGEST_SAVEPASSWORD);

                        // If we can't load passwords, then create a new list
                        if (!LoadPasswords())
                        {
                            CStringList_New(&m_pslPasswords);
                            if (m_pslPasswords)
                                m_pslPasswords->SetListData(LIST_DATA_PASSWORD);
                        }

                        if (m_pslPasswords)
                        {
                            if ((IDCANCEL == iMB) || ((IDNO == iMB) && (!IsEnabledAskPW())))
                            {
                                // If they hit the close box or said "no" and checked "don't ask",
                                //  don't even save the username; we may ask them again next time
                            }
                            else
                            {
                                if (IDYES != iMB)
                                {
                                    // User said "no" but we save the username (no password) and
                                    //   set filetime to 0 which means they said "no"
                                    bstrPassword[0] = L'\0';
                                    ftSubmit.dwLowDateTime = ftSubmit.dwHighDateTime = 0;
                                }
                                else
                                {
                                    TraceMsg(TF_IFORMS, "IForms saving password for user %ws", bstrUsername);
                                }

                                m_pslPasswords->SetAutoScavenge(FALSE);

                                // Save the username and password, or just the username if they said "no"
                                if (SUCCEEDED(m_pslPasswords->AppendString(bstrUsername, ftSubmit)) &&
                                    SUCCEEDED(m_pslPasswords->AppendString(bstrPassword, ftSubmit)))
                                {
                                    SavePasswords();
                                }
                                else
                                {
                                    TraceMsg(TF_WARNING, "IForms couldn't save username/password");
                                    delete m_pslPasswords;
                                    m_pslPasswords=NULL;
                                }
                            }
                        }

                        LeaveModalDialog();
                    }
                }
            }

            SysFreeString(bstrUsername);
            SysFreeString(bstrPassword);
        } // if (SUCCEEDED(ParseForm()))
    }

    return S_OK;
}

// Returns reference to password string list if present. Return value must be used
//  immediately and not destroyed. Used only by CEnumString.
HRESULT CIntelliForms::GetPasswordStringList(CStringList **ppslPasswords)
{
    if (LoadPasswords())
    {
        *ppslPasswords = m_pslPasswords;
        return S_OK;
    }

    *ppslPasswords = NULL;
    return E_FAIL;
}


HRESULT CIntelliForms::CreatePStore()
{
    if (!m_pPStore)
    {
        if (!m_hinstPStore)
        {
            m_hinstPStore = LoadLibrary(TEXT("PSTOREC.DLL"));
        }

        if (m_hinstPStore)
        {
            HRESULT (* pfn)(IPStore **, PST_PROVIDERID *, void *, DWORD) = NULL;

            *(FARPROC *)&pfn = GetProcAddress(m_hinstPStore, "PStoreCreateInstance");

            if (pfn)
            {
                pfn(&m_pPStore, NULL, NULL, 0);
            }
        }
    }

    return m_pPStore ? S_OK : E_FAIL;
}

void CIntelliForms::ReleasePStore()
{
    SAFERELEASE(m_pPStore);
    if (m_hinstPStore)
    {
        FreeLibrary(m_hinstPStore);
        m_hinstPStore = NULL;
    }

    m_fPStoreTypeInit=FALSE;
}

HRESULT CIntelliForms::CreatePStoreAndType()
{
    HRESULT hr;

    hr = CreatePStore();

    if (SUCCEEDED(hr) && !m_fPStoreTypeInit)
    {
        PST_TYPEINFO    typeInfo;

        typeInfo.cbSize = sizeof(typeInfo);
        typeInfo.szDisplayName = (LPTSTR)c_szIntelliForms;

        hr = m_pPStore->CreateType(PST_KEY_CURRENT_USER, &c_PStoreType, &typeInfo, 0);

        if (hr == PST_E_TYPE_EXISTS)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pPStore->CreateSubtype(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, &typeInfo, NULL, 0);

            if (hr == PST_E_TYPE_EXISTS)
            {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr))
        {
            m_fPStoreTypeInit = TRUE;
        }
    }

    return hr;
}

const WCHAR c_szBlob1Value[] = L"StringIndex";
const WCHAR c_szBlob2Value[] = L"StringData";

HRESULT CIntelliForms::WriteToStore(LPCWSTR pwszName, CStringList *psl)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_IFORMS, "+WriteToStore");

    if (SUCCEEDED(CreatePStoreAndType()))
    {
        LPBYTE pBlob1, pBlob2;
        DWORD  cbBlob1, cbBlob2;

        if (SUCCEEDED(psl->WriteToBlobs(&pBlob1, &cbBlob1, &pBlob2, &cbBlob2)))
        {
            PST_PROMPTINFO  promptInfo;

            promptInfo.cbSize = sizeof(promptInfo);
            promptInfo.dwPromptFlags = 0;
            promptInfo.hwndApp = NULL;
            promptInfo.szPrompt = NULL;

            LPWSTR pwszValue;

            int iValLen = lstrlenW(c_szBlob1Value) + lstrlenW(pwszName) + 10;

            pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, iValLen * sizeof(WCHAR));

            if (pwszValue)
            {
                // Write Index
                wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
                hr = m_pPStore->WriteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                        cbBlob1,
                                        pBlob1,
                                        &promptInfo, PST_CF_NONE, 0);

                if (FAILED(hr))
                {
                    TraceMsg(TF_WARNING | TF_IFORMS, "Failure writing Blob1 (Index).  hr=%x", hr);
                }
                else
                {
                    // Wrote Index successfully.  Write data.
                    wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
                    hr = m_pPStore->WriteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                            cbBlob2,
                                            pBlob2,
                                            &promptInfo, PST_CF_NONE, 0);
                    if (FAILED(hr))
                    {
                        // IE6#16676: This call failed on 64-bit Windows.  Added a warning trace here to facilitate
                        // future debugging.
                        TraceMsg(TF_WARNING | TF_IFORMS, "Failure writing Blob2 (Data).  hr=%x", hr);
                    }
                }

                // If *either* WriteItem failed, we really need to delete both the Index and the Data.
                //
                if (FAILED(hr))
                {
                    // Delete bogus Blobs

                    // Delete Index Blob
                    wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
                    if (FAILED(m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0)))
                    {
                        TraceMsg(TF_ERROR | TF_IFORMS, "Failure deleting Blob1 (Index).  hr=%x", hr);
                    }

                    // Delete Data Blob
                    wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
                    if (FAILED(m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0)))
                    {
                        TraceMsg(TF_ERROR | TF_IFORMS, "Failure deleting Blob2 (Data).  hr=%x", hr);
                    }
                }

                LocalFree(pwszValue);
                pwszValue = NULL;
            }

            if (pBlob1)
            {
                LocalFree(pBlob1);
                pBlob1 = NULL;
            }

            if (pBlob2)
            {
                LocalFree(pBlob2);
                pBlob2 = NULL;
            }
        }
    }

    TraceMsg(TF_IFORMS, "-WriteToStore");

    return hr;
}

HRESULT CIntelliForms::ReadFromStore(LPCWSTR pwszName, CStringList **ppsl, BOOL fPasswordList/*=FALSE*/)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_IFORMS, "+ReadFromStore");

    *ppsl=NULL;

    if (SUCCEEDED(CreatePStore()))
    {
        PST_PROMPTINFO  promptInfo;

        promptInfo.cbSize = sizeof(promptInfo);
        promptInfo.dwPromptFlags = 0;
        promptInfo.hwndApp = NULL;
        promptInfo.szPrompt = NULL;

        LPWSTR pwszValue;

        int iValLen = lstrlenW(c_szBlob1Value) + lstrlenW(pwszName) + 10;

        pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, iValLen * sizeof(WCHAR));

        if (pwszValue)
        {
            DWORD dwBlob1Size, dwBlob2Size;
            LPBYTE pBlob1=NULL, pBlob2=NULL;

            wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
            hr = m_pPStore->ReadItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                    &dwBlob1Size,
                                    &pBlob1,
                                    &promptInfo, 0);

            if (SUCCEEDED(hr))
            {
                wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
                hr = m_pPStore->ReadItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                        &dwBlob2Size,
                                        &pBlob2,
                                        &promptInfo, 0);

                if (SUCCEEDED(hr))
                {
                    // bogus... have to reallocate here... bogus... bogus...
                    LPBYTE pBlob1b, pBlob2b;

                    pBlob1b=(LPBYTE)LocalAlloc(LMEM_FIXED, dwBlob1Size);
                    pBlob2b=(LPBYTE)LocalAlloc(LMEM_FIXED, dwBlob2Size);

                    if (pBlob1b && pBlob2b)
                    {
                        memcpy(pBlob1b, pBlob1, dwBlob1Size);
                        memcpy(pBlob2b, pBlob2, dwBlob2Size);

                        CStringList_New(ppsl);
                        if (*ppsl)
                        {
                            hr = (*ppsl)->ReadFromBlobs(&pBlob1b, dwBlob1Size, &pBlob2b, dwBlob2Size);

                            if (SUCCEEDED(hr))
                            {
                                INT64 i;

                                if (FAILED((*ppsl)->GetListData(&i)) ||
                                    ((fPasswordList && !(i & LIST_DATA_PASSWORD)) ||
                                     (!fPasswordList && (i & LIST_DATA_PASSWORD))))
                                {
                                    TraceMsg(TF_WARNING|TF_IFORMS, "IForms: Password/nonpassword lists mixed up");
                                    hr = E_FAIL;    // don't allow malicious site to access PW data
                                }
                            }

                            if (FAILED(hr))
                            {
                                delete *ppsl;
                                *ppsl=NULL;
                            }
                        }
                    }
                    else
                    {
                        if (pBlob1b)
                        {
                            LocalFree(pBlob1b);
                            pBlob1b = NULL;
                        }

                        if (pBlob2b)
                        {
                            LocalFree(pBlob2b);
                            pBlob2b = NULL;
                        }
                    }
                }
                else
                {
                    TraceMsg(TF_IFORMS, "Failed reading Blob2.  hr=%x", hr);
                }
            }
            else
            {
                TraceMsg(TF_IFORMS, "Failed reading Blob1.  hr=%x", hr);
            }

            LocalFree(pwszValue);
            pwszValue = NULL;

            if (pBlob1)
            {
                CoTaskMemFree(pBlob1);
                pBlob1 = NULL;
            }

            if (pBlob2)
            {
                CoTaskMemFree(pBlob2);
                pBlob2 = NULL;
            }
        }
    }

    TraceMsg(TF_IFORMS, "-ReadFromStore");

    return hr;
}

HRESULT CIntelliForms::DeleteFromStore(LPCWSTR pwszName)
{
    HRESULT hr=E_FAIL;

    if (SUCCEEDED(CreatePStore()))
    {
        HRESULT hr1, hr2;
        LPWSTR pwszValue;

        int iValLen = lstrlenW(c_szBlob1Value) + lstrlenW(pwszName) + 10;

        pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, iValLen * sizeof(WCHAR));

        if (pwszValue)
        {
            PST_PROMPTINFO  promptInfo;

            promptInfo.cbSize = sizeof(promptInfo);
            promptInfo.dwPromptFlags = 0;
            promptInfo.hwndApp = NULL;
            promptInfo.szPrompt = NULL;

            wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
            hr1 = m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0);

            wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
            hr2 = m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0);

            if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
            {
                hr = S_OK;
            }

            LocalFree(pwszValue);
            pwszValue = NULL;
        }
    }

    return hr;
}


const int c_iEnumSize=256;

HRESULT CIntelliForms::ClearStore(DWORD dwClear)
{
    BOOL fReleasePStore = (m_pPStore == NULL);

    ASSERT(dwClear <= 2);

    if (dwClear > 2)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(CreatePStoreAndType()))
    {
        IEnumPStoreItems *pEnumItems;
        ULONG cFetched=0;

        do
        {
            if (SUCCEEDED(m_pPStore->EnumItems(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, 0, &pEnumItems)))
            {
                LPWSTR pwszName[c_iEnumSize];
                PST_PROMPTINFO  promptInfo;

                promptInfo.cbSize = sizeof(promptInfo);
                promptInfo.dwPromptFlags = 0;
                promptInfo.hwndApp = NULL;
                promptInfo.szPrompt = NULL;

                // Enumerator doesn't keep its state - deleting items while we enumerate makes us
                //  miss some. It does support celt>1... but returns failure codes when it succeeds.
                cFetched = 0;

                pEnumItems->Next(c_iEnumSize, pwszName, &cFetched);

                if (cFetched)
                {
                    for (ULONG i=0; i<cFetched; i++)
                    {
                        ASSERT(pwszName[i]);
                        if (pwszName[i])
                        {
                            BOOL fDelete = TRUE;

                            // Hack to work around PStore string-case bug: first take their
                            //  enum value literally, then convert to lowercase and do it
                            //  again; IE5.0 #71001
                            for (int iHack=0; iHack<2; iHack++)
                            {
                                if (iHack == 1)
                                {
                                    // Convert the pwszName[i] to lowercase... only before
                                    //  the colon...
                                    WCHAR *pwch = StrRChrW(pwszName[i], NULL, L':');
                                    if (pwch)
                                    {
                                        *pwch = L'\0';
                                        MyToLower(pwszName[i]);
                                        *pwch = L':';
                                    }
                                    else
                                        break;
                                }

                                if (dwClear != IECMDID_ARG_CLEAR_FORMS_ALL)
                                {
                                    fDelete = FALSE;

                                    // See if this is a password item or not
                                    // This is pretty annoying. Since our string lists are split
                                    //  into two blobs, we need to find out which one this is and
                                    //  load the index for it.
                                    WCHAR *pwch = StrRChrW(pwszName[i], NULL, L':');
                                    if (pwch)
                                    {
                                        LPWSTR pwszIndexName=NULL;
                                        if (!StrCmpCW(pwch+1, c_szBlob2Value))
                                        {
                                            int iSize = sizeof(WCHAR) * (lstrlenW(pwszName[i])+10);
                                            pwszIndexName = (LPWSTR) LocalAlloc(LMEM_FIXED, iSize);
                                            if (pwszIndexName)
                                            {
                                                *pwch = L'\0';
                                                wnsprintfW(pwszIndexName, iSize, L"%s:%s", pwszName[i], c_szBlob1Value);
                                                *pwch = L':';
                                            }
                                        }

                                        DWORD dwBlob1Size;
                                        LPBYTE pBlob1=NULL;
                                        INT64 iFlags;

                                        if (SUCCEEDED(m_pPStore->ReadItem(
                                                PST_KEY_CURRENT_USER,
                                                &c_PStoreType, &m_guidUserId,
                                                (pwszIndexName) ? pwszIndexName : pwszName[i],
                                                &dwBlob1Size,
                                                &pBlob1,
                                                &promptInfo, 0)) && pBlob1)
                                        {
                                            if (SUCCEEDED(CStringList::GetFlagsFromIndex(pBlob1, &iFlags)))
                                            {
                                                if (((iFlags & LIST_DATA_PASSWORD) && (dwClear == IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY)) ||
                                                    (!(iFlags & LIST_DATA_PASSWORD) && (dwClear == IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS)))
                                                {
                                                    // Delete this item
                                                    fDelete = TRUE;
                                                }
                                            }

                                            CoTaskMemFree(pBlob1);
                                        }
                                        else
                                        {
                                            // The index is already deleted
                                            fDelete = TRUE;
                                        }

                                        if (pwszIndexName)
                                        {
                                            LocalFree(pwszIndexName);
                                            pwszIndexName = NULL;
                                        }
                                    }
                                } // if (dwClear != CLEAR_INTELLIFORMS_ALL)

                                if (fDelete)
                                {
                                    m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszName[i], &promptInfo, 0);
                                }
                            } // for (iHack)

                            CoTaskMemFree(pwszName[i]);
                        } // if (pwszName[i])
                    }
                }

                pEnumItems->Release();
            }
        }
        while (cFetched == c_iEnumSize);  // In case we didn't cover everything in one pass

        if (dwClear == IECMDID_ARG_CLEAR_FORMS_ALL)
        {
            m_pPStore->DeleteSubtype(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, 0);
            m_pPStore->DeleteType(PST_KEY_CURRENT_USER, &c_PStoreType, 0);
        }

        if ((dwClear == IECMDID_ARG_CLEAR_FORMS_ALL) ||
            (dwClear == IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY))
        {
            // Delete the urlhash key storing which urls we have passwords saved for
            SHDeleteKey(HKEY_CURRENT_USER, c_szRegKeyIntelliForms);
        }

        TraceMsg(TF_IFORMS, "IForms: ClearStore cleared at least %d entries", cFetched);
    }

    if (fReleasePStore)
    {
        ReleasePStore();
    }

    return S_OK;
}

// static: Get the name from an input element - uses VCARD_NAME attribute if present.
HRESULT CIntelliForms::GetName(IHTMLInputTextElement *pTextEle, BSTR *pbstrName)
{
    IHTMLElement *pEle=NULL;

    *pbstrName = NULL;

    pTextEle->QueryInterface(IID_IHTMLElement, (void **)&pEle);

    if (pEle)
    {
        BSTR bstrAttr = SysAllocString(L"VCARD_NAME");

        if (bstrAttr)
        {
            VARIANT var;
            var.vt = VT_EMPTY;

            pEle->getAttribute(bstrAttr, 0, &var);

            if (var.vt == VT_BSTR && var.bstrVal)
            {
                *pbstrName = var.bstrVal;
            }
            else
            {
                VariantClear(&var);
            }

            SysFreeString(bstrAttr);
        }

        pEle->Release();
    }

    if (!*pbstrName)
    {
        pTextEle->get_name(pbstrName);
    }

    // Convert the name to lowercase
    if (*pbstrName)
    {
        // Call "MyToLower" instead
        if (g_fRunningOnNT)
        {
            CharLowerBuffW(*pbstrName, lstrlenW(*pbstrName));
        }
        else
        {
            // Ideally we would use the code page contained in the string instead of
            //  the system code page.
            CHAR chBuf[MAX_PATH];
            SHUnicodeToAnsi(*pbstrName, chBuf, ARRAYSIZE(chBuf));
            CharLowerBuffA(chBuf, lstrlenA(chBuf));
            SHAnsiToUnicode(chBuf, *pbstrName, SysStringLen(*pbstrName)+1);
        }
    }

    return (*pbstrName) ? S_OK : E_FAIL;
}

// Called when script calls window.external.AutoCompleteSaveForm
HRESULT CIntelliForms::ScriptSubmit(IHTMLFormElement *pForm)
{
    HRESULT hr = E_FAIL;

    if (pForm)
    {
        hr = HandleFormSubmit(pForm);
    }

    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}


// Called when user changes a text field. Mark it "dirty" and sink submit event for form
HRESULT CIntelliForms::UserInput(IHTMLInputTextElement *pTextEle)
{
    AddToElementList(pTextEle);

    IHTMLFormElement *pForm=NULL;
    pTextEle->get_form(&pForm);

    if (pForm)
    {
        if (S_OK == AddToFormList(pForm))
        {
            AttachToForm(pForm);
        }

        pForm->Release();
    }
    else
    {
        TraceMsg(TF_WARNING|TF_IFORMS, "Iforms: pITE->get_form() returned NULL!");
    }


    return S_OK;
}

HRESULT CIntelliForms::AddToElementList(IHTMLInputTextElement *pITE)
{
    if (m_hdpaElements)
    {
        if (SUCCEEDED(FindInElementList(pITE)))
        {
            return S_FALSE;
        }
    }
    else
    {
        m_hdpaElements = DPA_Create(4);
    }

    if (m_hdpaElements)
    {
        TraceMsg(TF_IFORMS, "CIntelliForms::AddToElementList adding");

        if (DPA_AppendPtr(m_hdpaElements, pITE) >= 0)
        {
            pITE->AddRef();
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

HRESULT CIntelliForms::FindInElementList(IHTMLInputTextElement *pITE)
{
    IUnknown *punk;
    HRESULT hr = E_FAIL;

    pITE->QueryInterface(IID_IUnknown, (void **)&punk);

    if (m_hdpaElements)
    {
        for (int i=DPA_GetPtrCount(m_hdpaElements)-1; i>=0; i--)
        {
            IUnknown *punk2;

            ((IUnknown *)DPA_FastGetPtr(m_hdpaElements, i))->QueryInterface(IID_IUnknown, (void **)&punk2);

            if (punk == punk2)
            {
                punk2->Release();
                break;
            }

            punk2->Release();
        }

        if (i >= 0)
        {
            hr = S_OK;
        }
    }

    punk->Release();

    return hr;
}

void CIntelliForms::FreeElementList()
{
    if (m_hdpaElements)
    {
        for (int i=DPA_GetPtrCount(m_hdpaElements)-1; i>=0; i--)
        {
            ((IUnknown *)(DPA_FastGetPtr(m_hdpaElements, i)))->Release();
        }

        DPA_Destroy(m_hdpaElements);
        m_hdpaElements=NULL;
    }
}

HRESULT CIntelliForms::AddToFormList(IHTMLFormElement *pFormEle)
{
    if (m_hdpaForms)
    {
        if (SUCCEEDED(FindInFormList(pFormEle)))
        {
            return S_FALSE;
        }
    }
    else
    {
        m_hdpaForms = DPA_Create(2);
    }

    if (m_hdpaForms)
    {
        if (DPA_AppendPtr(m_hdpaForms, pFormEle) >= 0)
        {
            TraceMsg(TF_IFORMS, "CIntelliForms::AddToFormList adding");

            pFormEle->AddRef();
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

HRESULT CIntelliForms::FindInFormList(IHTMLFormElement *pFormEle)
{
    IUnknown *punk;
    HRESULT hr = E_FAIL;

    pFormEle->QueryInterface(IID_IUnknown, (void **)&punk);

    if (m_hdpaForms)
    {
        for (int i=DPA_GetPtrCount(m_hdpaForms)-1; i>=0; i--)
        {
            IUnknown *punk2;

            ((IUnknown *)DPA_FastGetPtr(m_hdpaForms, i))->QueryInterface(IID_IUnknown, (void **)&punk2);

            if (punk == punk2)
            {
                punk2->Release();
                break;
            }

            punk2->Release();
        }

        if (i >= 0)
        {
            hr = S_OK;
        }
    }

    punk->Release();

    return hr;
}

void CIntelliForms::FreeFormList()
{
    if (m_hdpaForms)
    {
        for (int i=DPA_GetPtrCount(m_hdpaForms)-1; i>=0; i--)
        {
            ((IUnknown *)(DPA_FastGetPtr(m_hdpaForms, i)))->Release();
        }

        DPA_Destroy(m_hdpaForms);
        m_hdpaForms = NULL;
    }
}

//=========================================================================
//
// Event sinking class
//
//  We simply implement IDispatch and make a call into our parent when
//   we receive a sinked event.
//
//=========================================================================
CIntelliForms::CEventSink::CEventSink(CEventSinkCallback *pParent)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEventSink::CEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CIntelliForms::CEventSink::~CEventSink()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEventSink::~CEventSink");
    ASSERT( m_cRef == 0 );
    DllRelease();
}

STDMETHODIMP CIntelliForms::CEventSink::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IDispatch == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IDispatch *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CIntelliForms::CEventSink::SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CIntelliForms::CEventSink::SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CIntelliForms::CEventSink::UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::CEventSink::UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

// IDispatch
STDMETHODIMP CIntelliForms::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CIntelliForms::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CIntelliForms::CEventSink::GetIDsOfNames(
                REFIID          riid,
                OLECHAR**       rgszNames,
                UINT            cNames,
                LCID            lcid,
                DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CIntelliForms::CEventSink::Invoke(
            DISPID dispIdMember,
            REFIID, LCID,
            WORD wFlags,
            DISPPARAMS* pDispParams,
            VARIANT* pVarResult,
            EXCEPINFO*,
            UINT* puArgErr)
{
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                EVENTS Event=EVENT_BOGUS;
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    for (int i=0; i<ARRAYSIZE(CEventSinkCallback::EventsToSink); i++)
                    {
                        if (!StrCmpCW(bstrEvent, CEventSinkCallback::EventsToSink[i].pwszEventName))
                        {
                            Event = (EVENTS) i;
                            break;
                        }
                    }

                    SysFreeString(bstrEvent);
                }

                if (Event != EVENT_BOGUS)
                {
                    IHTMLElement *pEle=NULL;

                    pObj->get_srcElement(&pEle);

                    // EVENT_SCROLL comes from our window so we won't have an
                    //  element for it
                    if (pEle || (Event == EVENT_SCROLL))
                    {
                        // Call the event handler here
                        m_pParent->HandleEvent(pEle, Event, pObj);

                        if (pEle)
                        {
                            pEle->Release();
                        }
                    }
                }

                pObj->Release();
            }
        }
    }

    return S_OK;
}

//=========================================================================
//
// Event sinking class
//
//  We implement IHTMLEditDesigner and make a call into our parent when
//   we receive any event.
//
//=========================================================================
CIntelliForms::CEditEventSink::CEditEventSink(CEditEventSinkCallback *pParent)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEditEventSink::CEditEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CIntelliForms::CEditEventSink::~CEditEventSink()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEditEventSink::~CEditEventSink");
    ASSERT(m_cRef == 0);
    ASSERT(!m_pEditServices);
    DllRelease();
}

STDMETHODIMP CIntelliForms::CEditEventSink::QueryInterface(REFIID riid, void **ppv)
{
    if ((IID_IHTMLEditDesigner == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = SAFECAST(this, IHTMLEditDesigner *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEditEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEditEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CIntelliForms::CEditEventSink::Attach(IUnknown *punkElement)
{
    HRESULT hr = S_OK;

    // Detach from any existing element
    if (m_pEditServices)
    {
        m_pEditServices->RemoveDesigner(this);
        m_pEditServices->Release();
        m_pEditServices = NULL;
    }

    // Attach to any new element
    if (punkElement)
    {
        hr = E_FAIL;

        IHTMLDocument2 *pDoc2 = NULL;
        GetStuffFromEle(punkElement, NULL, &pDoc2);

        if (pDoc2)
        {
            IServiceProvider *pSP = NULL;

            pDoc2->QueryInterface(IID_IServiceProvider, (void **)&pSP);

            if (pSP)
            {
                pSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)&m_pEditServices);
                pSP->Release();
            }

            if (m_pEditServices)
            {
                hr = m_pEditServices->AddDesigner(this);
            }

            pDoc2->Release();
        }
    }

    return hr;
}

HRESULT CIntelliForms::CEditEventSink::PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj)
{
    if (m_pParent)
    {
        return m_pParent->PreHandleEvent(inEvtDispId, pIEventObj);
    }

    return S_FALSE;
}

HRESULT CIntelliForms::CEditEventSink::PostHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj)
{
    return S_FALSE;
}

HRESULT CIntelliForms::CEditEventSink::TranslateAccelerator(DISPID inEvtDispId, IHTMLEventObj *pIEventObj)
{
    return S_FALSE;
}


//=========================================================================
//
// AutoSuggest class
//
// Handles connecting and disconnecting the AutoComplete object, as well
//  as translating between Trident OM and Edit window messages
//=========================================================================

CIntelliForms::CAutoSuggest::CAutoSuggest(CIntelliForms *pParent, BOOL fEnabled, BOOL fEnabledPW)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::CAutoSuggest");

    m_pParent = pParent;
    m_fEnabled = fEnabled;
    m_fEnabledPW = fEnabledPW;

    ASSERT(m_pEventSink == NULL);
    ASSERT(m_pAutoComplete == NULL);
    ASSERT(m_hwndEdit == NULL);
    ASSERT(m_pTextEle == NULL);

    //
    // bug 81414 : To avoid clashing with app messages used by the edit window, we 
    // use registered messages.
    //
    m_uMsgItemActivate = RegisterWindowMessageA("AC_ItemActivate");
    if (m_uMsgItemActivate == 0)
    {
        m_uMsgItemActivate = WM_APP + 301;
    }

    // Register our window class if necessary
    if (!s_fRegisteredWndClass)
    {
        s_fRegisteredWndClass = TRUE;

        WNDCLASSEXW wndclass =
        {
            sizeof(WNDCLASSEX),
            0,
            CIntelliForms::CAutoSuggest::WndProc,
            0,
            sizeof(DWORD_PTR),
            g_hinst,
            NULL,
            NULL,
            NULL,
            NULL,
            c_szEditWndClass
        };

        if (!RegisterClassEx(&wndclass))
        {
            TraceMsg(TF_IFORMS, "Intelliforms failed to register wnd class!");
        }
    }
}

CIntelliForms::CAutoSuggest::~CAutoSuggest()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::~CAutoSuggest");
    CleanUp();
}

HRESULT CIntelliForms::CAutoSuggest::CleanUp()
{
    SetParent(NULL);
    DetachFromInput();

    return S_OK;
}

// List of all events we sink for an individual INPUT tag
// post IE5.5 we can use CEditEventSink instead of CEventSink for all of these events.
CEventSinkCallback::EVENTS CIntelliForms::CAutoSuggest::s_EventsToSink[] =
        {
            EVENT_KEYPRESS,
            EVENT_KEYDOWN,
            EVENT_MOUSEDOWN,
            EVENT_DBLCLICK,
            EVENT_FOCUS,
            EVENT_BLUR,
        };

HRESULT CIntelliForms::CAutoSuggest::AttachToInput(IHTMLInputTextElement *pTextEle)
{
    HRESULT hr;

    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::AttachToInput");

    if (!pTextEle)
        return E_INVALIDARG;

    hr = DetachFromInput();

    if (SUCCEEDED(hr))
    {
        m_pTextEle = pTextEle;
        pTextEle->AddRef();

        if (!m_pEventSink)
        {
            m_pEventSink = new CEventSink(this);

            if (!m_pEventSink)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Hook up our event sink
            IHTMLElement2 *pEle2=NULL;

            hr = pTextEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);

            if (pEle2)
            {
                hr = m_pEventSink->SinkEvents(pEle2, ARRAYSIZE(s_EventsToSink), s_EventsToSink);

                pEle2->Release();
            }
        }
    }

    if (FAILED(hr))
    {
        TraceMsg(TF_IFORMS, "IForms: AttachToInput failed");
        DetachFromInput();
    }

    return hr;
}

HRESULT CIntelliForms::CAutoSuggest::DetachFromInput()
{
    if (!m_pTextEle)
    {
        return S_FALSE;
    }

    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::DetachFromInput");

    // Auto Fill Password here, since we get ACTIVEELEMENT change before blur event
    BSTR bstrUsername=NULL;
    m_pTextEle->get_value(&bstrUsername);
    if (bstrUsername)
    {
        CheckAutoFillPassword(bstrUsername);
        SysFreeString(bstrUsername);
    }

    if (m_bstrLastUsername)
    {
        SysFreeString(m_bstrLastUsername);
        m_bstrLastUsername=NULL;
    }

    if (m_hwndEdit)
    {
        // This is for subclass wndproc
        SendMessage(m_hwndEdit, WM_KILLFOCUS, 0, 0);
    }

    if (m_pEnumString)
    {
        m_pEnumString->UnInit();
        m_pEnumString->Release();
        m_pEnumString = NULL;
    }

    if (m_pEventSink)
    {
        IHTMLElement2 *pEle2=NULL;

        m_pTextEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);

        if (pEle2)
        {
            m_pEventSink->UnSinkEvents(pEle2, ARRAYSIZE(s_EventsToSink), s_EventsToSink);
            pEle2->Release();
        }

        m_pEventSink->SetParent(NULL);
        m_pEventSink->Release();
        m_pEventSink=NULL;
    }

    SAFERELEASE(m_pAutoComplete);
    SAFERELEASE(m_pAutoCompleteDD);

    if (m_hwndEdit)
    {
        DestroyWindow(m_hwndEdit);
        m_hwndEdit = NULL;
    }

    SAFERELEASE(m_pTextEle);

    m_fInitAutoComplete = FALSE;

    return S_OK;
}

// Creates autocomplete and string enumerator.
HRESULT CIntelliForms::CAutoSuggest::CreateAutoComplete()
{
    if (m_fInitAutoComplete)
    {
        return (m_pAutoCompleteDD != NULL) ? S_OK : E_FAIL;
    }

    HRESULT hr = S_OK;

    ASSERT(!m_hwndEdit && !m_pEnumString && !m_pAutoComplete && !m_pAutoCompleteDD);

    // Create the edit window
#ifndef UNIX
    m_hwndEdit = CreateWindowEx(0, c_szEditWndClass, TEXT("IntelliFormProxy"), WS_POPUP,
#else
    m_hwndEdit = CreateWindowEx(WS_EX_MW_UNMANAGED_WINDOW, c_szEditWndClass, TEXT("IntelliFormProxy"), WS_POPUP,
#endif
        300, 200, 200, 50, m_pParent->m_hwndBrowser, NULL, g_hinst, this);

    if (!m_hwndEdit)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        // Create our enumerator
        m_pEnumString = new CEnumString();

        if (m_pEnumString)
        {
            m_pEnumString->Init(m_pTextEle, m_pParent);

            // Create the AutoComplete Object
            if (!m_pAutoComplete)
            {
                hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_IAutoComplete2, (void **)&m_pAutoComplete);
                if (m_pAutoComplete)
                {
                    m_pAutoComplete->QueryInterface(IID_IAutoCompleteDropDown, (void **)&m_pAutoCompleteDD);
                    if (!m_pAutoCompleteDD)
                    {
                        SAFERELEASE(m_pAutoComplete);
                    }
                }
            }

            if (m_pAutoComplete)
            {
                hr = m_pAutoComplete->Init(m_hwndEdit, (IUnknown *) m_pEnumString, NULL, NULL);

                DWORD dwOptions = ACO_AUTOSUGGEST | ACO_UPDOWNKEYDROPSLIST;

                // Add the RTLREADING option to the dropdown, if the element is RTL
                BSTR bstrDir = NULL;

                IHTMLElement2 *pEle2=NULL;
                m_pTextEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
                if (pEle2)
                {
                    pEle2->get_dir(&bstrDir);
                    pEle2->Release();
                }

                if (bstrDir)
                {
                    if (!StrCmpIW(bstrDir, L"RTL"))
                    {
                        dwOptions |= ACO_RTLREADING;
                    }

                    SysFreeString(bstrDir);
                }

                m_pAutoComplete->SetOptions(dwOptions);
            }
        }
    }

    m_fInitAutoComplete = TRUE;

    ASSERT_MSG(SUCCEEDED(hr), "IForms: CreateAutoComplete failed");

    return hr;
}

void CIntelliForms::CAutoSuggest::CheckAutoFillPassword(LPCWSTR pwszUsername)
{
    // We don't autofill their password unless we know they've hit a key
    if (m_pParent && m_fEnabledPW && m_fAllowAutoFillPW)
    {
        if (m_bstrLastUsername && !StrCmpCW(pwszUsername, m_bstrLastUsername))
        {
            return;
        }

        SysFreeString(m_bstrLastUsername);
        m_bstrLastUsername = SysAllocString(pwszUsername);

        m_pParent->AutoFillPassword(m_pTextEle, pwszUsername);
    }
}

HRESULT GetScreenCoordinates(IUnknown *punkEle, HWND hwnd, long *plLeft, long *plTop, long *plWidth, long *plHeight)
{
    long lScreenLeft=0, lScreenTop=0;
    HRESULT hr = E_FAIL;

    *plLeft = *plTop = *plWidth = *plHeight = 0;

    IHTMLElement2 *pEle2;
    if (SUCCEEDED(punkEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2)) && pEle2)
    {
        IHTMLRect *pRect=NULL;

        if (SUCCEEDED(pEle2->getBoundingClientRect(&pRect)) && pRect)
        {
            IHTMLWindow2 *pWin2;

            long lLeft, lRight, lTop, lBottom;

            pRect->get_left(&lLeft);
            pRect->get_right(&lRight);
            pRect->get_top(&lTop);
            pRect->get_bottom(&lBottom);

            lBottom -= 2;           // put dropdown on top of edit box
            if (lBottom < lTop)
            {
                lBottom = lTop;
            }

            if (lTop >= 0 && lLeft >= 0)
            {
                GetStuffFromEle(punkEle, &pWin2, NULL);

                if (pWin2)
                {
                    IHTMLWindow3 *pWin3;
                    
                    if (SUCCEEDED(pWin2->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3)) && pWin3)
                    {
                        IHTMLScreen *pScreen = NULL;
                        RECT rcBrowserWnd;

                        pWin3->get_screenLeft(&lScreenLeft);
                        pWin3->get_screenTop(&lScreenTop);

                        // GetClientRect & the screen_* APIs return document coordinates.
                        // We're position using device coordinates.
                        // Use document (currently 96DPI) and device resolutions & transform
                        pWin2->get_screen(&pScreen);
                        if (pScreen)
                        {
                            IHTMLScreen2 * pScreen2 = NULL;

                            if (SUCCEEDED(pScreen->QueryInterface(IID_IHTMLScreen2, (void **)&pScreen2)))
                            {
                                if (pScreen2)
                                {                        
                                    long xDeviceDPI, yDeviceDPI, xLogicalDPI, yLogicalDPI;

                                    pScreen2->get_deviceXDPI(&xDeviceDPI);
                                    pScreen2->get_deviceYDPI(&yDeviceDPI);
                                    pScreen2->get_logicalXDPI(&xLogicalDPI);
                                    pScreen2->get_logicalYDPI(&yLogicalDPI);

                                    lBottom     = (lBottom * yDeviceDPI) / yLogicalDPI;
                                    lTop        = (lTop * yDeviceDPI) / yLogicalDPI;
                                    lScreenTop  = (lScreenTop * yDeviceDPI) / yLogicalDPI;
                                    lLeft       = (lLeft * xDeviceDPI) / xLogicalDPI;
                                    lRight      = (lRight * xDeviceDPI) / xLogicalDPI;
                                    lScreenLeft = (lScreenLeft * xDeviceDPI) / xLogicalDPI;
                                    pScreen2->Release();
                                }
                            }

                            pScreen->Release();
                        }

                        if (GetWindowRect(hwnd, &rcBrowserWnd))
                        {
                            // Clip the right edge to the window
                            if (lRight+lScreenLeft > rcBrowserWnd.right)
                            {
                                lRight = rcBrowserWnd.right - lScreenLeft;
                            }

                            *plLeft = lScreenLeft + lLeft;
                            *plWidth = lRight-lLeft;
                            *plTop = lScreenTop + lTop;
                            *plHeight = lBottom-lTop;

                            hr = S_OK;

                            if (*plWidth < MINIMUM_WIDTH)
                            {
                                // Primitive minimum width for now
                                *plWidth = MINIMUM_WIDTH;
                            }
                        }

                        pWin3->Release();
                    }

                    pWin2->Release();
                }
            }

            pRect->Release();
        }
        pEle2->Release();
    }

    return hr;
}

HRESULT CIntelliForms::CAutoSuggest::UpdateDropdownPosition()
{
    if (m_pTextEle && m_pParent && m_hwndEdit)
    {
        long lLeft, lTop, lWidth, lHeight;

        if (SUCCEEDED(GetScreenCoordinates(m_pTextEle, m_pParent->m_hwndBrowser, &lLeft, &lTop, &lWidth, &lHeight)))
        {
            MoveWindow(m_hwndEdit, lLeft, lTop, lWidth, lHeight, FALSE);
        }
        else
        {
            // Send "escape" key to autocomplete so that it hides the dropdown.
            // This will happen if dropdown moves outside of parent window, for example.
            SendMessage(m_hwndEdit, IF_CHAR, (WPARAM) VK_ESCAPE, 0);
        }
    }

    return S_OK;
}


HRESULT CIntelliForms::CAutoSuggest::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    ASSERT(SHIsSameObject(pEle, m_pTextEle));

    long lKey = 0;
    BOOL fIsComposition = FALSE;

    if (!m_pParent)
    {
        TraceMsg(TF_WARNING|TF_IFORMS, "IForms autosuggest receiving events while invalid");
        return E_FAIL;
    }

    if (Event == EVENT_KEYPRESS || Event == EVENT_KEYDOWN)
    {
        pEventObj->get_keyCode(&lKey);
    }

    if (Event == EVENT_COMPOSITION)
    {
        fIsComposition = TRUE;

        Event = EVENT_KEYPRESS; // Pretend to be a "keypress" for various processing below

    }

    if (Event == EVENT_NOTIFY)
    {
        // Send WM_IME_NOTIFY to AutoComplete so it can hide the dropdown
        //  if necessary
        IHTMLEventObj3 *pObj3 = NULL;

        pEventObj->QueryInterface(IID_PPV_ARG(IHTMLEventObj3, &pObj3));

        if (pObj3)
        {
            LONG_PTR wParam = 0;
            pObj3->get_imeNotifyCommand(&wParam);

            SendMessage(m_hwndEdit, WM_IME_NOTIFY, (WPARAM)wParam, 0);

            pObj3->Release();
        }

        return S_OK;
    }

    if (!m_fEnabled && !m_fEnabledPW)
    {
        // If the dropdown isn't enabled, our only purpose is to tell Intelliforms when
        //  user activity occurs for the first-time enable dialog box.
        if (Event == EVENT_KEYPRESS && lKey != VK_TAB)
        {
            // Add this element to the master list so we save it when we submit
            //  and sink the submit event for this element's form
            MarkDirty();
        }

        return S_OK;
    }

    if (Event == EVENT_KEYDOWN || Event == EVENT_KEYPRESS ||
        Event == EVENT_MOUSEDOWN || Event == EVENT_DBLCLICK)
    {
        m_fAllowAutoFillPW = TRUE;

        // Create our autocomplete object if it hasn't happened yet.
        // If it's "tab" we don't create it; we're leaving the field
        if (lKey != VK_TAB)
        {
            if (FAILED(CreateAutoComplete()))
                return E_FAIL;
        }
        else
        {
          